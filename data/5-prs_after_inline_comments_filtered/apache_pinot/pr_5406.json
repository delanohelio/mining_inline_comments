{"pr_number": 5406, "pr_title": "Adding support to execute functions during query compilation", "pr_createdAt": "2020-05-18T07:35:17Z", "pr_url": "https://github.com/apache/pinot/pull/5406", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQyNTA0NQ==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426425045", "bodyText": "this should be recursively evaluated, technically a function of function of literal should still be true here.\nE.g. format_time(now(), 'yyyy-MM-dd')", "author": "xiangfu0", "createdAt": "2020-05-18T07:39:07Z", "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -615,7 +618,47 @@ private static Expression toExpression(SqlNode node) {\n             funcExpr.getFunctionCall().addToOperands(toExpression(child));\n           }\n         }\n+\n+        if (FunctionDefinitionRegistry.isScalarFunc(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+\n+          ScalarFunctionType scalarFunctionType = ScalarFunctionType.getScalarFunctionType(funcName);\n+          switch (scalarFunctionType) {\n+            case NOW:\n+              funcExpr = RequestUtils.getLiteralExpression(System.currentTimeMillis());\n+              break;\n+            case FORMAT_DATETIME:\n+              //DATETIME_FORMAT ('2020-01-01', 'yyyy-MM-dd')\n+              String input = funcExpr.getFunctionCall().getOperands().get(0).getLiteral().getStringValue();\n+              String format = funcExpr.getFunctionCall().getOperands().get(1).getLiteral().getStringValue();\n+              long output = DateTimeFormat.forPattern(format).parseMillis(input);\n+              funcExpr = RequestUtils.getLiteralExpression(output);\n+              break;\n+            default:\n+              //no change, let the expression be handled during execution phase\n+          }\n+        }\n+\n         return funcExpr;\n     }\n   }\n+\n+  /**\n+   * Utility method to check if the function can be evaluated during the query compilation phae\n+   * @param funcExpr\n+   * @return true if all arguments are literals\n+   */\n+  private static boolean isCompileTimeEvaluationPossible(Expression funcExpr) {\n+\n+    boolean compileTimeEvaluationPossible = true;\n+    Function functionCall = funcExpr.getFunctionCall();\n+    if(functionCall.getOperandsSize() > 0) {\n+      for (Expression expression : functionCall.getOperands()) {\n+        if (expression.getType() != ExpressionType.LITERAL) {", "originalCommit": "b91b4f33292c594307fe5e7087beae7f13dc0531", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzMTQ5MA==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426431490", "bodyText": "since logic is depth-first, it should work.\nformat_time(now(), 'yyyy-MM-dd') will first get changed to\nformat_time(123123123123, 'yyyy-MM-dd') which will be evaluated to\n2020-01-01", "author": "kishoreg", "createdAt": "2020-05-18T07:51:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQyNTA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQyODg5OQ==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426428899", "bodyText": "better to implement method eval for each function which take operands list as argument which could be either literal or functions.\nThen this logic will just be\nfuncExpr = getScalarFunction(scalarFunctionType).eval(funcExpr.getFunctionCall().getOperands())", "author": "xiangfu0", "createdAt": "2020-05-18T07:46:30Z", "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -615,7 +618,47 @@ private static Expression toExpression(SqlNode node) {\n             funcExpr.getFunctionCall().addToOperands(toExpression(child));\n           }\n         }\n+\n+        if (FunctionDefinitionRegistry.isScalarFunc(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+\n+          ScalarFunctionType scalarFunctionType = ScalarFunctionType.getScalarFunctionType(funcName);\n+          switch (scalarFunctionType) {\n+            case NOW:\n+              funcExpr = RequestUtils.getLiteralExpression(System.currentTimeMillis());\n+              break;\n+            case FORMAT_DATETIME:\n+              //DATETIME_FORMAT ('2020-01-01', 'yyyy-MM-dd')\n+              String input = funcExpr.getFunctionCall().getOperands().get(0).getLiteral().getStringValue();\n+              String format = funcExpr.getFunctionCall().getOperands().get(1).getLiteral().getStringValue();\n+              long output = DateTimeFormat.forPattern(format).parseMillis(input);\n+              funcExpr = RequestUtils.getLiteralExpression(output);", "originalCommit": "b91b4f33292c594307fe5e7087beae7f13dc0531", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzMjc3Mw==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426432773", "bodyText": "Most of the functions are already available in FunctionRegistry and FunctionInvoker added by @npawar. Unfortunately, those functions are in pinot-core, we can move the scalar functions into pinot-common in another PR and remove custom implementation for now and datetime format", "author": "kishoreg", "createdAt": "2020-05-18T07:53:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQyODg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc0NDU1MA==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r427744550", "bodyText": "Added support for eval function of functions as long as all the recursive params are literal.", "author": "xiangfu0", "createdAt": "2020-05-20T05:10:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQyODg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NDgwNQ==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426964805", "bodyText": "What's the purpose of this? Flexibility to support variations of function names?", "author": "mayankshriv", "createdAt": "2020-05-19T00:35:45Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/function/ScalarFunctionType.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.function;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+\n+\n+public enum ScalarFunctionType {\n+\n+  NOW(\"now\"), FORMAT_DATETIME(\"format_datetime\");\n+\n+  private final String _name;\n+\n+  static HashMap<String, ScalarFunctionType> _scalarFunctions = new HashMap<>();\n+\n+  static {\n+    ScalarFunctionType[] values = ScalarFunctionType.values();\n+    for (ScalarFunctionType value : values) {\n+      String upperCaseFunctionName = value.getName().toUpperCase();\n+      _scalarFunctions.put(upperCaseFunctionName, value);\n+      _scalarFunctions.put(upperCaseFunctionName.replace(\"_\", \"\"), value);", "originalCommit": "b91b4f33292c594307fe5e7087beae7f13dc0531", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk4MzI5NA==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426983294", "bodyText": "e.g. presto use _ in function names. It provides more robustness from user perspective.", "author": "xiangfu0", "createdAt": "2020-05-19T01:46:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NDgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NTAyMA==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426965020", "bodyText": "Would it be easy to identify this based on function args, as opposed to pre-register?", "author": "mayankshriv", "createdAt": "2020-05-19T00:36:41Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/function/ScalarFunctionType.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.function;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+\n+\n+public enum ScalarFunctionType {\n+\n+  NOW(\"now\"), FORMAT_DATETIME(\"format_datetime\");\n+\n+  private final String _name;\n+\n+  static HashMap<String, ScalarFunctionType> _scalarFunctions = new HashMap<>();\n+\n+  static {\n+    ScalarFunctionType[] values = ScalarFunctionType.values();\n+    for (ScalarFunctionType value : values) {", "originalCommit": "b91b4f33292c594307fe5e7087beae7f13dc0531", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk4Mzk5Nw==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426983997", "bodyText": "I somehow feel, we should still pre-register those functions.", "author": "xiangfu0", "createdAt": "2020-05-19T01:49:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NTAyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc0NDc4Mw==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r427744783", "bodyText": "Removed these code path for now.", "author": "xiangfu0", "createdAt": "2020-05-20T05:11:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NTAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NTkzOA==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426965938", "bodyText": "Will this approach scale, as number of scalar functions increase? For example, each one would need to be added here. What do you think about modelling this as a query rewrite phase that goes over all scalars and evaluates them?", "author": "mayankshriv", "createdAt": "2020-05-19T00:40:15Z", "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -615,7 +618,47 @@ private static Expression toExpression(SqlNode node) {\n             funcExpr.getFunctionCall().addToOperands(toExpression(child));\n           }\n         }\n+\n+        if (FunctionDefinitionRegistry.isScalarFunc(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+\n+          ScalarFunctionType scalarFunctionType = ScalarFunctionType.getScalarFunctionType(funcName);\n+          switch (scalarFunctionType) {\n+            case NOW:", "originalCommit": "b91b4f33292c594307fe5e7087beae7f13dc0531", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk4MzU4NQ==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426983585", "bodyText": "I think we will need to move to function registry/invoker model", "author": "xiangfu0", "createdAt": "2020-05-19T01:47:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NTkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5NzE1Mw==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r427597153", "bodyText": "yes, this is to just ensure that the logic of detection if a function can be evaluated at query compile time works.", "author": "kishoreg", "createdAt": "2020-05-19T21:00:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NTkzOA=="}], "type": "inlineReview"}, {"oid": "6d95bb72ecd2be67e17bd8fa6d01190cdbb44bef", "url": "https://github.com/apache/pinot/commit/6d95bb72ecd2be67e17bd8fa6d01190cdbb44bef", "message": "Adding support to execute functions during query compilation", "committedDate": "2020-05-19T10:40:39Z", "type": "forcePushed"}, {"oid": "53acdfa8231d430232cefaa7cf09b75673abb90d", "url": "https://github.com/apache/pinot/commit/53acdfa8231d430232cefaa7cf09b75673abb90d", "message": "Adding support to execute functions during query compilation", "committedDate": "2020-05-19T16:57:09Z", "type": "forcePushed"}, {"oid": "0e21590e08d954d73c0d28dd3ffa4b40727bdc25", "url": "https://github.com/apache/pinot/commit/0e21590e08d954d73c0d28dd3ffa4b40727bdc25", "message": "Adding support to execute functions during query compilation", "committedDate": "2020-05-19T18:19:38Z", "type": "forcePushed"}, {"oid": "5ef20ce5a37b5c7a9fbe98de46fc75f5ca906a8e", "url": "https://github.com/apache/pinot/commit/5ef20ce5a37b5c7a9fbe98de46fc75f5ca906a8e", "message": "Adding support to execute functions during query compilation", "committedDate": "2020-05-19T18:51:57Z", "type": "forcePushed"}, {"oid": "cbb6ad6dcc29ecbe7481717f6e2ff834800e44dd", "url": "https://github.com/apache/pinot/commit/cbb6ad6dcc29ecbe7481717f6e2ff834800e44dd", "message": "Adding support to execute functions during query compilation", "committedDate": "2020-05-19T19:22:03Z", "type": "forcePushed"}, {"oid": "55c9814681067386671b37db749235eca0cded56", "url": "https://github.com/apache/pinot/commit/55c9814681067386671b37db749235eca0cded56", "message": "Adding support to execute functions during query compilation", "committedDate": "2020-05-19T19:25:56Z", "type": "forcePushed"}, {"oid": "1368749a6375b6c94202b59a610a75b11dcabed0", "url": "https://github.com/apache/pinot/commit/1368749a6375b6c94202b59a610a75b11dcabed0", "message": "Adding support to execute functions during query compilation", "committedDate": "2020-05-19T19:31:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4MDczOQ==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r427580739", "bodyText": "Instead of this, why don't we just have a constant value function registry  where all compile time evaluated functions are registered. So this check then becomes if the function is part of the constant value function registry.", "author": "siddharthteotia", "createdAt": "2020-05-19T20:30:12Z", "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -615,7 +620,44 @@ private static Expression toExpression(SqlNode node) {\n             funcExpr.getFunctionCall().addToOperands(toExpression(child));\n           }\n         }\n+\n+        if (FunctionRegistry.containsFunctionByName(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+          int functionOperandsLength = funcSqlNode.getOperands().length;\n+          FunctionInfo functionInfo = FunctionRegistry.getFunctionByName(funcName);\n+          Object[] arguments = new Object[functionOperandsLength];\n+          for (int i = 0; i < functionOperandsLength; i++) {\n+            SqlLiteral argSqlNode = (SqlLiteral) funcSqlNode.getOperands()[i];\n+            arguments[i] = argSqlNode.toValue();\n+          }\n+          try {\n+            FunctionInvoker invoker = new FunctionInvoker(functionInfo);\n+            funcExpr = RequestUtils.getLiteralExpression(invoker.process(arguments).toString());\n+          } catch (Exception e) {\n+            throw new SqlCompilationException(\"Unsupported Scalar function - \" + funcName);\n+          }\n+        }\n         return funcExpr;\n     }\n   }\n+\n+  /**\n+   * Utility method to check if the function can be evaluated during the query compilation phae\n+   * @param funcExpr\n+   * @return true if all arguments are literals\n+   */\n+  private static boolean isCompileTimeEvaluationPossible(Expression funcExpr) {", "originalCommit": "1368749a6375b6c94202b59a610a75b11dcabed0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5NjI0NQ==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r427596245", "bodyText": "One thing here is that the function could be used in transform functions in query/ingestion field conversion. Ideally we should be able to evaluate any transform function with literal here.", "author": "xiangfu0", "createdAt": "2020-05-19T20:59:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4MDczOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5NzM0MA==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r427597340", "bodyText": "+1", "author": "kishoreg", "createdAt": "2020-05-19T21:01:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4MDczOQ=="}], "type": "inlineReview"}, {"oid": "9a4e8ca5e5343246c7f2c312c9826819426f5c42", "url": "https://github.com/apache/pinot/commit/9a4e8ca5e5343246c7f2c312c9826819426f5c42", "message": "Adding support to execute functions during query compilation", "committedDate": "2020-05-19T23:09:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMDQ3Nw==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r429500477", "bodyText": "this function is the same as fromDateTime on line 217. Do we need both?", "author": "npawar", "createdAt": "2020-05-23T01:09:13Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/function/DateTimeFunctions.java", "diffHunk": "@@ -216,4 +217,18 @@ static String toDateTime(Long millis, String pattern) {\n   static Long fromDateTime(String dateTimeString, String pattern) {\n     return DateTimePatternHandler.parseDateTimeStringToEpochMillis(dateTimeString, pattern);\n   }\n+\n+  /**\n+   * Return current time as epoch millis\n+   */\n+  static Long now() {\n+    return System.currentTimeMillis();\n+  }\n+\n+  /**\n+   * Return epoch millis value based on a given date time string and it's corresponding format.\n+   */\n+  public static Long formatDatetime(String input, String format) {", "originalCommit": "9a4e8ca5e5343246c7f2c312c9826819426f5c42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUxMTEwMg==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r429511102", "bodyText": "will delete", "author": "xiangfu0", "createdAt": "2020-05-23T03:50:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMDQ3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMTkwNg==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r429501906", "bodyText": "i didn't quite follow why there is special casing for  DISTINCTCOUNT ?", "author": "npawar", "createdAt": "2020-05-23T01:26:44Z", "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -593,29 +596,77 @@ private static Expression toExpression(SqlNode node) {\n           // Move on to process default logic.\n         }\n       default:\n-        SqlBasicCall funcSqlNode = (SqlBasicCall) node;\n-        String funcName = funcSqlNode.getOperator().getKind().name();\n-        if (funcSqlNode.getOperator().getKind() == SqlKind.OTHER_FUNCTION) {\n-          funcName = funcSqlNode.getOperator().getName();\n+        return evaluateFunctionExpression((SqlBasicCall) node);\n+    }\n+  }\n+\n+  private static String extractFunctionName(SqlBasicCall funcSqlNode) {\n+    String funcName = funcSqlNode.getOperator().getKind().name();\n+    if (funcSqlNode.getOperator().getKind() == SqlKind.OTHER_FUNCTION) {\n+      funcName = funcSqlNode.getOperator().getName();\n+    }\n+    if (funcName.equalsIgnoreCase(SqlKind.COUNT.toString()) && (funcSqlNode.getFunctionQuantifier() != null)", "originalCommit": "9a4e8ca5e5343246c7f2c312c9826819426f5c42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUxMTM2OA==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r429511368", "bodyText": "this is a special handling for the case of COUNT(DISTINCT A).", "author": "xiangfu0", "createdAt": "2020-05-23T03:56:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMTkwNg=="}], "type": "inlineReview"}, {"oid": "8d84161496a68ff55916d2b4bb8fed401a65418b", "url": "https://github.com/apache/pinot/commit/8d84161496a68ff55916d2b4bb8fed401a65418b", "message": "Adding support to execute functions during query compilation", "committedDate": "2020-05-23T03:57:53Z", "type": "commit"}, {"oid": "cc89fe3aba61f035864cd1bda86e2c62642c4131", "url": "https://github.com/apache/pinot/commit/cc89fe3aba61f035864cd1bda86e2c62642c4131", "message": "Remove function formatDatetime", "committedDate": "2020-05-23T03:57:53Z", "type": "commit"}, {"oid": "cc89fe3aba61f035864cd1bda86e2c62642c4131", "url": "https://github.com/apache/pinot/commit/cc89fe3aba61f035864cd1bda86e2c62642c4131", "message": "Remove function formatDatetime", "committedDate": "2020-05-23T03:57:53Z", "type": "forcePushed"}]}