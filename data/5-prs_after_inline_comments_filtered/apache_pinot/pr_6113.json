{"pr_number": 6113, "pr_title": "Adding the upsert support to real-time ingestion and query", "pr_createdAt": "2020-10-06T18:59:41Z", "pr_url": "https://github.com/apache/pinot/pull/6113", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY3OTY1MQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500679651", "bodyText": "Suggest renaming to TableUpsertMetadataManager for consistency with TableDataManager", "author": "Jackie-Jiang", "createdAt": "2020-10-07T01:07:40Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertMetadataTableManager.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.data.manager.realtime.RealtimeTableDataManager;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * The manager of the upsert metadata of a table.\n+ */\n+@ThreadSafe\n+public class UpsertMetadataTableManager {", "originalCommit": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY3OTc5Mg==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500679792", "bodyText": "Suggest renaming to PartitionUpsertMetadataManager for consistency", "author": "Jackie-Jiang", "createdAt": "2020-10-07T01:08:15Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertMetadataPartitionManager.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Manages the upsert metadata per partition. This shall be accessed from UpsertMetadataTableManager.\n+ */\n+@ThreadSafe\n+class UpsertMetadataPartitionManager {", "originalCommit": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcxOTQ3MA==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500719470", "bodyText": "Good point", "author": "yupeng9", "createdAt": "2020-10-07T03:41:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY3OTc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4MDEzMA==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500680130", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final Map<Integer, UpsertMetadataPartitionManager> _partitionMetadataManagerMap = new ConcurrentHashMap();\n          \n          \n            \n              private final Map<Integer, UpsertMetadataPartitionManager> _partitionMetadataManagerMap = new ConcurrentHashMap<>();", "author": "Jackie-Jiang", "createdAt": "2020-10-07T01:09:40Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertMetadataTableManager.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.data.manager.realtime.RealtimeTableDataManager;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * The manager of the upsert metadata of a table.\n+ */\n+@ThreadSafe\n+public class UpsertMetadataTableManager {\n+  private final Map<Integer, UpsertMetadataPartitionManager> _partitionMetadataManagerMap = new ConcurrentHashMap();", "originalCommit": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4NDkzNg==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500684936", "bodyText": "I went through the code, and seems we don't need to do the table level management, partition level management should be good enough. Directly using PartitionUpsertMetadataManager can save lots of unnecessary map lookups, and eliminate the contention of the concurrent lookups", "author": "Jackie-Jiang", "createdAt": "2020-10-07T01:28:54Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertMetadataTableManager.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.data.manager.realtime.RealtimeTableDataManager;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * The manager of the upsert metadata of a table.\n+ */\n+@ThreadSafe\n+public class UpsertMetadataTableManager {", "originalCommit": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcyMTUwNA==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500721504", "bodyText": "I'd like to keep this class for (1) a group of the PartitionUpsertMetadataManager  (note PartitionUpsertMetadataManager  is package-private); (2) more features might be added to this class, such as future offline table support, record retrieval for partial update, etc", "author": "yupeng9", "createdAt": "2020-10-07T03:49:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4NDkzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcyMjIwNQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500722205", "bodyText": "Also why would there be concurrent lookup contention, since we don't the synchronized keywords on most methods?", "author": "yupeng9", "createdAt": "2020-10-07T03:52:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4NDkzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE5NjAwOQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r501196009", "bodyText": "There won't be lots of partitions, and all the lookups are very likely hitting the same partition, which can cause contention for concurrent hash map. It is okay to keep this class for easier management, but try to directly use partition level manager instead of look up this one", "author": "Jackie-Jiang", "createdAt": "2020-10-07T17:43:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4NDkzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxMjQ1NQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r501212455", "bodyText": "try to directly use partition level manager instead of look up this one can you be more specific on this? The current methods in this class delegate to the partition level manager?", "author": "yupeng9", "createdAt": "2020-10-07T18:10:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4NDkzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4NTA4NA==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500685084", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final Map<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap();\n          \n          \n            \n              // the mapping between the (sealed) segment and its validDocuments\n          \n          \n            \n              private final Map<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIndexMap = new ConcurrentHashMap();\n          \n          \n            \n              private final Map<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap<>();\n          \n          \n            \n              // the mapping between the (sealed) segment and its validDocuments\n          \n          \n            \n              private final Map<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIndexMap = new ConcurrentHashMap<>();", "author": "Jackie-Jiang", "createdAt": "2020-10-07T01:29:28Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertMetadataPartitionManager.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Manages the upsert metadata per partition. This shall be accessed from UpsertMetadataTableManager.\n+ */\n+@ThreadSafe\n+class UpsertMetadataPartitionManager {\n+\n+  private final int _partitionId;\n+\n+  private final Map<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap();\n+  // the mapping between the (sealed) segment and its validDocuments\n+  private final Map<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIndexMap = new ConcurrentHashMap();", "originalCommit": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4NjIwNw==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500686207", "bodyText": "Remove all the synchronized for these methods. ConcurrentHashMap can handle concurrent accesses", "author": "Jackie-Jiang", "createdAt": "2020-10-07T01:34:04Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertMetadataPartitionManager.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Manages the upsert metadata per partition. This shall be accessed from UpsertMetadataTableManager.\n+ */\n+@ThreadSafe\n+class UpsertMetadataPartitionManager {\n+\n+  private final int _partitionId;\n+\n+  private final Map<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap();\n+  // the mapping between the (sealed) segment and its validDocuments\n+  private final Map<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIndexMap = new ConcurrentHashMap();\n+\n+  UpsertMetadataPartitionManager(int partitionId) {\n+    _partitionId = partitionId;\n+  }\n+\n+  synchronized void removeRecordLocation(PrimaryKey primaryKey) {", "originalCommit": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4NzAxNA==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500687014", "bodyText": "This part won't be correct if multiple segments are being loaded at the same time.\n\nSegment 1 put a key to the primaryKeyIndex\nSegment 2 put the same key with newer timestamp to the primaryKeyIndex\nSegment 2 update the metadata first\nSegment 1 will override the metadata from segment 2, which will cause wrong result", "author": "Jackie-Jiang", "createdAt": "2020-10-07T01:37:10Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertMetadataPartitionManager.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Manages the upsert metadata per partition. This shall be accessed from UpsertMetadataTableManager.\n+ */\n+@ThreadSafe\n+class UpsertMetadataPartitionManager {\n+\n+  private final int _partitionId;\n+\n+  private final Map<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap();\n+  // the mapping between the (sealed) segment and its validDocuments\n+  private final Map<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIndexMap = new ConcurrentHashMap();\n+\n+  UpsertMetadataPartitionManager(int partitionId) {\n+    _partitionId = partitionId;\n+  }\n+\n+  synchronized void removeRecordLocation(PrimaryKey primaryKey) {\n+    _primaryKeyIndex.remove(primaryKey);\n+  }\n+\n+  synchronized boolean containsKey(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.containsKey(primaryKey);\n+  }\n+\n+  RecordLocation getRecordLocation(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.get(primaryKey);\n+  }\n+\n+  synchronized void updateRecordLocation(PrimaryKey primaryKey, RecordLocation recordLocation) {\n+    _primaryKeyIndex.put(primaryKey, recordLocation);\n+  }\n+\n+  synchronized ThreadSafeMutableRoaringBitmap getValidDocIndex(String segmentName) {\n+    return _segmentToValidDocIndexMap.get(segmentName);\n+  }\n+\n+  synchronized void putUpsertMetadata(String segmentName, Map<PrimaryKey, RecordLocation> primaryKeyIndex,\n+      ThreadSafeMutableRoaringBitmap validDocIndex) {\n+    //TODO(upsert) do we need to make a backup before update?\n+    _primaryKeyIndex.putAll(primaryKeyIndex);", "originalCommit": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcyMDExMg==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500720112", "bodyText": "Don't quite follow. This is a batch addition with the synchronized protection?", "author": "yupeng9", "createdAt": "2020-10-07T03:44:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4NzAxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE5NjU4Mg==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r501196582", "bodyText": "If 2 segments are loaded at the same time, you need to do record by record modification instead of batching all the modifications then apply them all", "author": "Jackie-Jiang", "createdAt": "2020-10-07T17:44:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4NzAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4ODExOA==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500688118", "bodyText": "Suggest renaming to removeUpsertMetadata\nPlease also add some notes stating that it won't work properly if the segment is relatively new and not removed by the retention manager (in which case it might override the value for the existing segments)", "author": "Jackie-Jiang", "createdAt": "2020-10-07T01:41:35Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertMetadataPartitionManager.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * Manages the upsert metadata per partition. This shall be accessed from UpsertMetadataTableManager.\n+ */\n+@ThreadSafe\n+class UpsertMetadataPartitionManager {\n+\n+  private final int _partitionId;\n+\n+  private final Map<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap();\n+  // the mapping between the (sealed) segment and its validDocuments\n+  private final Map<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIndexMap = new ConcurrentHashMap();\n+\n+  UpsertMetadataPartitionManager(int partitionId) {\n+    _partitionId = partitionId;\n+  }\n+\n+  synchronized void removeRecordLocation(PrimaryKey primaryKey) {\n+    _primaryKeyIndex.remove(primaryKey);\n+  }\n+\n+  synchronized boolean containsKey(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.containsKey(primaryKey);\n+  }\n+\n+  RecordLocation getRecordLocation(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.get(primaryKey);\n+  }\n+\n+  synchronized void updateRecordLocation(PrimaryKey primaryKey, RecordLocation recordLocation) {\n+    _primaryKeyIndex.put(primaryKey, recordLocation);\n+  }\n+\n+  synchronized ThreadSafeMutableRoaringBitmap getValidDocIndex(String segmentName) {\n+    return _segmentToValidDocIndexMap.get(segmentName);\n+  }\n+\n+  synchronized void putUpsertMetadata(String segmentName, Map<PrimaryKey, RecordLocation> primaryKeyIndex,\n+      ThreadSafeMutableRoaringBitmap validDocIndex) {\n+    //TODO(upsert) do we need to make a backup before update?\n+    _primaryKeyIndex.putAll(primaryKeyIndex);\n+    _segmentToValidDocIndexMap.put(segmentName, validDocIndex);\n+  }\n+\n+  synchronized void removeSegment(String segmentName) {", "originalCommit": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcyMDM4NA==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500720384", "bodyText": "Same reason with synchronization on this?", "author": "yupeng9", "createdAt": "2020-10-07T03:45:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4ODExOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE5Nzg1MA==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r501197850", "bodyText": "E.g.\nSegment 1 writes key1 as value1\nSegment 2 overrides key1 as value2\nSegment 2 gets removed\nIn this case, we should use value1 as the value for key1, but the current way will remove key1 from the metadata", "author": "Jackie-Jiang", "createdAt": "2020-10-07T17:46:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4ODExOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIyMTU4MQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r501221581", "bodyText": "I see. But will this happen?\nIf segment 1 is earlier, and segment 2 overrides only during segment loading. Why would a loaded segment be removed?", "author": "yupeng9", "createdAt": "2020-10-07T18:22:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4ODExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4ODkwNg==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500688906", "bodyText": "Suggest moving this logic into the PartitionUpsertMetadataManager so that all metadata management methods are at the same place", "author": "Jackie-Jiang", "createdAt": "2020-10-07T01:44:50Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertProcessorUtil.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.Map;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public final class UpsertProcessorUtil {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(UpsertProcessorUtil.class);\n+\n+  private UpsertProcessorUtil() {\n+  }\n+\n+  public static void handleUpsert(PrimaryKey primaryKey, long timestamp, String segmentName, int docId, int partitionId,", "originalCommit": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcyMjU4OA==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500722588", "bodyText": "hmm, I thought about that. But this logic does not fully belong to the PartitionUpsertMetadataManager , but only the part in the else if branch.\nIn fact, it's a common logic used in two places, and that's why I put it in a util class.", "author": "yupeng9", "createdAt": "2020-10-07T03:54:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4ODkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE5OTk1OA==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r501199958", "bodyText": "I checked both places, and IMO the handleUpsert (update metadata) should definitely be part of the metadata manager.\nThe benefit of putting this into the manager class is that we can easily add more concurrency control for the class if needed (I'm pretty sure there are cases not handled)", "author": "Jackie-Jiang", "createdAt": "2020-10-07T17:49:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4ODkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIyMzUwMA==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r501223500", "bodyText": "I don't quite buy the concurrency control argument. Static methods are executed concurrently, and if the concurrent access within this block of code is actually on PartitionUpsertMetadataManager  access. So from this front, the current way has better concurrency control IMO.\nCode organization for better clarity is a different perspective, and we can discuss it.", "author": "yupeng9", "createdAt": "2020-10-07T18:26:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4ODkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5MTM3NQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500691375", "bodyText": "This should only be initialized when upsert is enabled, or addSegment() will always pass the non-null UpsertMetadataTableManager, which will enable the upsert for the segments", "author": "Jackie-Jiang", "createdAt": "2020-10-07T01:53:49Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -96,8 +106,15 @@\n   // likely that we get fresh data each time instead of multiple copies of roughly same data.\n   private static final int MIN_INTERVAL_BETWEEN_STATS_UPDATES_MINUTES = 30;\n \n+  // TODO(upsert): TableConfig is not available at class init phase, so we have to always create a new upsertMetadataTableManager\n+  private UpsertMetadataTableManager _upsertMetadataTableManager;\n+  private UpsertConfig.Mode _upsertMode;\n+  private List<String> _primaryKeyColumns;\n+  private String _timeColumnName;\n+\n   public RealtimeTableDataManager(Semaphore segmentBuildSemaphore) {\n     _segmentBuildSemaphore = segmentBuildSemaphore;\n+    _upsertMetadataTableManager = new UpsertMetadataTableManager();", "originalCommit": "afe3918dbbcdc61ced1b339b0e19a67279b1c02b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc0NTgxMA==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500745810", "bodyText": "NIT: please use parentheses in the boolean condition to avoid confusion.", "author": "chenboat", "createdAt": "2020-10-07T05:29:06Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -266,14 +291,59 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n         manager =\n             new LLRealtimeSegmentDataManager(realtimeSegmentZKMetadata, tableConfig, this, _indexDir.getAbsolutePath(),\n                 indexLoadingConfig, schema, llcSegmentName, _partitionIdToSemaphoreMap.get(streamPartitionId),\n-                _serverMetrics);\n+                _serverMetrics, _upsertMetadataTableManager);\n       }\n       _logger.info(\"Initialize RealtimeSegmentDataManager - \" + segmentName);\n       _segmentDataManagerMap.put(segmentName, manager);\n       _serverMetrics.addValueToTableGauge(_tableNameWithType, ServerGauge.SEGMENT_COUNT, 1L);\n     }\n   }\n \n+  private boolean isUpsertEnabled() {\n+    return _upsertMode != null && _upsertMode == UpsertConfig.Mode.FULL || _upsertMode == UpsertConfig.Mode.PARTIAL;", "originalCommit": "410b977b6830c03aab39f4e765e0689a08427790", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1NTU4Mg==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500755582", "bodyText": "What's the estimated memory usage for the extra data structure? if the primary key+RecordLocation is around 1K, this means we will use 10G heap for this data structure for 1M records. We might want to be careful about part of memory usage", "author": "jamesyfshao", "createdAt": "2020-10-07T06:00:12Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -266,14 +291,59 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n         manager =\n             new LLRealtimeSegmentDataManager(realtimeSegmentZKMetadata, tableConfig, this, _indexDir.getAbsolutePath(),\n                 indexLoadingConfig, schema, llcSegmentName, _partitionIdToSemaphoreMap.get(streamPartitionId),\n-                _serverMetrics);\n+                _serverMetrics, _upsertMetadataTableManager);\n       }\n       _logger.info(\"Initialize RealtimeSegmentDataManager - \" + segmentName);\n       _segmentDataManagerMap.put(segmentName, manager);\n       _serverMetrics.addValueToTableGauge(_tableNameWithType, ServerGauge.SEGMENT_COUNT, 1L);\n     }\n   }\n \n+  private boolean isUpsertEnabled() {\n+    return _upsertMode != null && _upsertMode == UpsertConfig.Mode.FULL || _upsertMode == UpsertConfig.Mode.PARTIAL;\n+  }\n+\n+  @Override\n+  public void addSegment(ImmutableSegment immutableSegment) {\n+    if(isUpsertEnabled()) {\n+      handleUpsert(immutableSegment);\n+    }\n+    super.addSegment(immutableSegment);\n+  }\n+\n+  private void handleUpsert(ImmutableSegment immutableSegment) {\n+    Preconditions.checkArgument(!_primaryKeyColumns.isEmpty(), \"the primary key columns cannot be empty\");\n+    Map<String, PinotSegmentColumnReader> columnToReaderMap = new HashMap<>();\n+    for (String primaryKeyColumn : _primaryKeyColumns) {\n+      columnToReaderMap.put(primaryKeyColumn, new PinotSegmentColumnReader(immutableSegment, primaryKeyColumn));\n+    }\n+    columnToReaderMap.put(_timeColumnName, new PinotSegmentColumnReader(immutableSegment, _timeColumnName));\n+    int numTotalDocs = immutableSegment.getSegmentMetadata().getTotalDocs();\n+\n+    // upsert metadata of the current segment\n+    Map<PrimaryKey, RecordLocation> primaryKeyIndex = new HashMap<>();", "originalCommit": "410b977b6830c03aab39f4e765e0689a08427790", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEyODYxNQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r501128615", "bodyText": "Agreed on being careful about memory usage. I discussed this in the design doc, and my estimate of the memory usage shall be < 2GB.\nI do plan a followup PR of adding metrics of the memory usage.", "author": "yupeng9", "createdAt": "2020-10-07T15:59:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1NTU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc2MzQzNQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500763435", "bodyText": "where is this class used?", "author": "chenboat", "createdAt": "2020-10-07T06:22:34Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentIndexCreationDriverImpl.java", "diffHunk": "@@ -54,6 +54,7 @@\n import org.apache.pinot.core.util.IngestionUtils;\n import org.apache.pinot.spi.config.table.StarTreeIndexConfig;\n import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.config.table.UpsertConfig;", "originalCommit": "410b977b6830c03aab39f4e765e0689a08427790", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc3MDM4NA==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500770384", "bodyText": "Does this mean all replicas of a stream partition share the same PartitionUpsertMetadataManager?", "author": "chenboat", "createdAt": "2020-10-07T06:39:41Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/TableUpsertMetadataManager.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * The manager of the upsert metadata of a table.\n+ */\n+@ThreadSafe\n+public class TableUpsertMetadataManager {\n+  private final Map<Integer, PartitionUpsertMetadataManager> _partitionMetadataManagerMap = new ConcurrentHashMap<>();", "originalCommit": "410b977b6830c03aab39f4e765e0689a08427790", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzMzM1Mg==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r501133352", "bodyText": "No, this is per server, so it tracks local segment only. And there is at most one replica per server", "author": "yupeng9", "createdAt": "2020-10-07T16:05:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc3MDM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc3MjM5NQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500772395", "bodyText": "local means in-memory segment? local is a bit ambiguous.", "author": "chenboat", "createdAt": "2020-10-07T06:44:21Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/UpsertProcessorUtil.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.Map;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public final class UpsertProcessorUtil {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(UpsertProcessorUtil.class);\n+\n+  private UpsertProcessorUtil() {\n+  }\n+\n+  public static void handleUpsert(PrimaryKey primaryKey, long timestamp, String segmentName, int docId, int partitionId,\n+      Map<PrimaryKey, RecordLocation> primaryKeyIndex, ThreadSafeMutableRoaringBitmap validDocIndex,\n+      TableUpsertMetadataManager upsertMetadataTableManager) {\n+    RecordLocation location = new RecordLocation(segmentName, docId, timestamp);\n+    // check local primary key index first", "originalCommit": "410b977b6830c03aab39f4e765e0689a08427790", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzNDA4Nw==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r501134087", "bodyText": "I think all segments are in-memory? Changed it to for mutable segment.", "author": "yupeng9", "createdAt": "2020-10-07T16:06:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc3MjM5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc4MDUzOA==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r500780538", "bodyText": "It is pretty expensive to loop through all the records in a segment and apply the upsert handling per record. Need to think through and better do a benchmark on the performance of this addSegment() method. This method is used when a segment is becoming online from offline state \u2014 which means it is invoked when a segment is loaded when the server starts OR when a server download the segment from another server in LLC. So it means slowdown of server start and segment download operations.", "author": "chenboat", "createdAt": "2020-10-07T07:01:24Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -266,14 +291,59 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n         manager =\n             new LLRealtimeSegmentDataManager(realtimeSegmentZKMetadata, tableConfig, this, _indexDir.getAbsolutePath(),\n                 indexLoadingConfig, schema, llcSegmentName, _partitionIdToSemaphoreMap.get(streamPartitionId),\n-                _serverMetrics);\n+                _serverMetrics, _upsertMetadataTableManager);\n       }\n       _logger.info(\"Initialize RealtimeSegmentDataManager - \" + segmentName);\n       _segmentDataManagerMap.put(segmentName, manager);\n       _serverMetrics.addValueToTableGauge(_tableNameWithType, ServerGauge.SEGMENT_COUNT, 1L);\n     }\n   }\n \n+  private boolean isUpsertEnabled() {\n+    return _upsertMode != null && _upsertMode == UpsertConfig.Mode.FULL || _upsertMode == UpsertConfig.Mode.PARTIAL;\n+  }\n+\n+  @Override\n+  public void addSegment(ImmutableSegment immutableSegment) {\n+    if(isUpsertEnabled()) {\n+      handleUpsert(immutableSegment);\n+    }\n+    super.addSegment(immutableSegment);\n+  }\n+\n+  private void handleUpsert(ImmutableSegment immutableSegment) {\n+    Preconditions.checkArgument(!_primaryKeyColumns.isEmpty(), \"the primary key columns cannot be empty\");\n+    Map<String, PinotSegmentColumnReader> columnToReaderMap = new HashMap<>();\n+    for (String primaryKeyColumn : _primaryKeyColumns) {\n+      columnToReaderMap.put(primaryKeyColumn, new PinotSegmentColumnReader(immutableSegment, primaryKeyColumn));\n+    }\n+    columnToReaderMap.put(_timeColumnName, new PinotSegmentColumnReader(immutableSegment, _timeColumnName));\n+    int numTotalDocs = immutableSegment.getSegmentMetadata().getTotalDocs();\n+\n+    // upsert metadata of the current segment\n+    Map<PrimaryKey, RecordLocation> primaryKeyIndex = new HashMap<>();\n+    ThreadSafeMutableRoaringBitmap validDocIndex = new ThreadSafeMutableRoaringBitmap();\n+\n+    String segmentName = immutableSegment.getSegmentName();\n+    int partitionId = new LLCSegmentName(immutableSegment.getSegmentName()).getPartitionId();\n+    for (int docId = 0; docId < numTotalDocs; docId++) {", "originalCommit": "410b977b6830c03aab39f4e765e0689a08427790", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzMTk2Ng==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r501131966", "bodyText": "That's a good point. I think some optimization on batch loading the columns can be considered in future PRs. In fact, this may improve other index loading code path such as the null vector loading etc.\nIn the initial version, we can build the foundation for the functionality first, and later via profiling we will have better understanding of the performance bottlenecks, and we can improve accordingly.", "author": "yupeng9", "createdAt": "2020-10-07T16:03:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc4MDUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNzkxMQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502127911", "bodyText": "Move this part into the init(), where you can read the table config and schema from the property store passed in. It is weird to reset these variables when adding each segment", "author": "Jackie-Jiang", "createdAt": "2020-10-09T01:48:15Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -224,6 +242,16 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n     Schema schema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n     Preconditions.checkNotNull(schema);\n \n+    // TODO(upsert): better checking&hanlding of upsert mode/primary key change", "originalCommit": "a54c1616ad0a78f9dbf765f312aa92ca2a6aef53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3MzQ0NQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502173445", "bodyText": "Good point", "author": "yupeng9", "createdAt": "2020-10-09T03:51:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNzkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyODI2Mw==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502128263", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return _upsertMode != null && (_upsertMode == UpsertConfig.Mode.FULL || _upsertMode == UpsertConfig.Mode.PARTIAL);\n          \n          \n            \n                return _upsertMode == UpsertConfig.Mode.FULL || _upsertMode == UpsertConfig.Mode.PARTIAL;", "author": "Jackie-Jiang", "createdAt": "2020-10-09T01:49:37Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -266,14 +293,71 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n         manager =\n             new LLRealtimeSegmentDataManager(realtimeSegmentZKMetadata, tableConfig, this, _indexDir.getAbsolutePath(),\n                 indexLoadingConfig, schema, llcSegmentName, _partitionIdToSemaphoreMap.get(streamPartitionId),\n-                _serverMetrics);\n+                _serverMetrics, _tableUpsertMetadataManager);\n       }\n       _logger.info(\"Initialize RealtimeSegmentDataManager - \" + segmentName);\n       _segmentDataManagerMap.put(segmentName, manager);\n       _serverMetrics.addValueToTableGauge(_tableNameWithType, ServerGauge.SEGMENT_COUNT, 1L);\n     }\n   }\n \n+  private boolean isUpsertEnabled() {\n+    return _upsertMode != null && (_upsertMode == UpsertConfig.Mode.FULL || _upsertMode == UpsertConfig.Mode.PARTIAL);", "originalCommit": "a54c1616ad0a78f9dbf765f312aa92ca2a6aef53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyODg0OA==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502128848", "bodyText": "Move this logic into the PartitionUpsertMetadataManager class and you need to add concurrency control for it. Currently this part of the code is not thread-safe if 2 segments are updating upsert metadata at the same time", "author": "Jackie-Jiang", "createdAt": "2020-10-09T01:52:28Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -266,14 +293,71 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n         manager =\n             new LLRealtimeSegmentDataManager(realtimeSegmentZKMetadata, tableConfig, this, _indexDir.getAbsolutePath(),\n                 indexLoadingConfig, schema, llcSegmentName, _partitionIdToSemaphoreMap.get(streamPartitionId),\n-                _serverMetrics);\n+                _serverMetrics, _tableUpsertMetadataManager);\n       }\n       _logger.info(\"Initialize RealtimeSegmentDataManager - \" + segmentName);\n       _segmentDataManagerMap.put(segmentName, manager);\n       _serverMetrics.addValueToTableGauge(_tableNameWithType, ServerGauge.SEGMENT_COUNT, 1L);\n     }\n   }\n \n+  private boolean isUpsertEnabled() {\n+    return _upsertMode != null && (_upsertMode == UpsertConfig.Mode.FULL || _upsertMode == UpsertConfig.Mode.PARTIAL);\n+  }\n+\n+  @Override\n+  public void addSegment(ImmutableSegment immutableSegment) {\n+    if (isUpsertEnabled()) {\n+      handleUpsert(immutableSegment);\n+    }\n+    super.addSegment(immutableSegment);\n+  }\n+\n+  private void handleUpsert(ImmutableSegment immutableSegment) {\n+    Preconditions.checkArgument(!_primaryKeyColumns.isEmpty(), \"the primary key columns cannot be empty\");\n+    Map<String, PinotSegmentColumnReader> columnToReaderMap = new HashMap<>();\n+    for (String primaryKeyColumn : _primaryKeyColumns) {\n+      columnToReaderMap.put(primaryKeyColumn, new PinotSegmentColumnReader(immutableSegment, primaryKeyColumn));\n+    }\n+    columnToReaderMap.put(_timeColumnName, new PinotSegmentColumnReader(immutableSegment, _timeColumnName));\n+    int numTotalDocs = immutableSegment.getSegmentMetadata().getTotalDocs();\n+    String segmentName = immutableSegment.getSegmentName();\n+    int partitionId = new LLCSegmentName(immutableSegment.getSegmentName()).getPartitionId();\n+    PartitionUpsertMetadataManager partitionUpsertMetadataManager =\n+        _tableUpsertMetadataManager.getOrCreatePartitionManager(partitionId);\n+    for (int docId = 0; docId < numTotalDocs; docId++) {\n+      Object[] fields = new Object[_primaryKeyColumns.size()];\n+      for (int i = 0; i < _primaryKeyColumns.size(); i++) {\n+        fields[i] = columnToReaderMap.get(_primaryKeyColumns.get(i)).getValue(docId);\n+      }\n+      PrimaryKey primaryKey = new PrimaryKey(fields);\n+      Object timeValue = columnToReaderMap.get(_timeColumnName).getValue(docId);\n+      Preconditions.checkArgument(timeValue instanceof Comparable, \"time column shall be comparable\");\n+      long timestamp = IngestionUtils.extractTimeValue((Comparable) timeValue);\n+      RecordLocation location = new RecordLocation(segmentName, docId, timestamp);\n+      if (partitionUpsertMetadataManager.containsKey(primaryKey)) {\n+        RecordLocation prevLocation = partitionUpsertMetadataManager.getRecordLocation(primaryKey);\n+        // upsert\n+        if (location.getTimestamp() >= prevLocation.getTimestamp()) {\n+          partitionUpsertMetadataManager.removeRecordLocation(primaryKey);\n+          partitionUpsertMetadataManager.putRecordLocation(primaryKey, location);\n+          partitionUpsertMetadataManager.getValidDocIndex(prevLocation.getSegmentName())\n+              .remove(prevLocation.getDocId());\n+          partitionUpsertMetadataManager.getOrCreateValidDocIndex(segmentName).checkAndAdd(location.getDocId());\n+          LOGGER.debug(String\n+              .format(\"upsert: replace old doc id %d with %d for key: %s, hash: %d\", prevLocation.getDocId(),\n+                  location.getDocId(), primaryKey, primaryKey.hashCode()));\n+        } else {\n+          LOGGER.debug(\n+              String.format(\"upsert: ignore a late-arrived record: %s, hash: %d\", primaryKey, primaryKey.hashCode()));\n+        }\n+      } else { // append\n+        partitionUpsertMetadataManager.putRecordLocation(primaryKey, location);\n+        partitionUpsertMetadataManager.getOrCreateValidDocIndex(segmentName).checkAndAdd(location.getDocId());\n+      }", "originalCommit": "a54c1616ad0a78f9dbf765f312aa92ca2a6aef53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyOTExNw==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502129117", "bodyText": "Similarly, this part of the logic should be moved into the PartitionUpsertMetadataManager with concurrency control", "author": "Jackie-Jiang", "createdAt": "2020-10-09T01:53:49Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -453,6 +465,49 @@ public boolean index(GenericRow row, @Nullable RowMetadata rowMetadata) {\n     return canTakeMore;\n   }\n \n+  private boolean isUpsertEnabled() {\n+    return _upsertMode != null && _upsertMode != UpsertConfig.Mode.NONE;\n+  }\n+\n+  private void handleUpsert(GenericRow row, int docId) {\n+    // below are upsert operations\n+    PrimaryKey primaryKey = row.getPrimaryKey(_schema.getPrimaryKeyColumns());\n+    Object timeValue = row.getValue(_timeColumnName);\n+    Preconditions.checkArgument(timeValue instanceof Comparable, \"time column shall be comparable\");\n+    long timestamp = IngestionUtils.extractTimeValue((Comparable) timeValue);\n+    RecordLocation location = new RecordLocation(_segmentName, docId, timestamp);\n+    // check local primary key index first\n+    if (_primaryKeyIndex.containsKey(primaryKey)) {\n+      RecordLocation prevLocation = _primaryKeyIndex.get(primaryKey);\n+      if (location.getTimestamp() >= prevLocation.getTimestamp()) {\n+        _primaryKeyIndex.put(primaryKey, location);\n+        // update validDocIndex\n+        _validDocIndex.remove(prevLocation.getDocId());\n+        _validDocIndex.checkAndAdd(location.getDocId());\n+        LOGGER.debug(String\n+            .format(\"upsert: replace old doc id %d with %d for key: %s, hash: %d\", prevLocation.getDocId(),\n+                location.getDocId(), primaryKey, primaryKey.hashCode()));\n+      } else {\n+        LOGGER.debug(\n+            String.format(\"upsert: ignore a late-arrived record: %s, hash: %d\", primaryKey, primaryKey.hashCode()));\n+      }\n+    } else if (_partitionUpsertMetadataManager.containsKey(primaryKey)) {\n+      RecordLocation prevLocation = _partitionUpsertMetadataManager.getRecordLocation(primaryKey);\n+      if (location.getTimestamp() >= prevLocation.getTimestamp()) {\n+        _partitionUpsertMetadataManager.removeRecordLocation(primaryKey);\n+        _primaryKeyIndex.put(primaryKey, location);\n+\n+        // update validDocIndex\n+        _partitionUpsertMetadataManager.getValidDocIndex(prevLocation.getSegmentName())\n+            .remove(prevLocation.getDocId());\n+        _validDocIndex.checkAndAdd(location.getDocId());\n+      }\n+    } else {\n+      _primaryKeyIndex.put(primaryKey, location);\n+      _validDocIndex.checkAndAdd(location.getDocId());\n+    }", "originalCommit": "a54c1616ad0a78f9dbf765f312aa92ca2a6aef53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU2NDgwNg==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r503564806", "bodyText": "+1", "author": "mcvsubbu", "createdAt": "2020-10-12T22:26:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyOTExNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY3Mjc0OQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r503672749", "bodyText": "okay, let me refactor this a bit.", "author": "yupeng9", "createdAt": "2020-10-13T05:19:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyOTExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyOTg2Mg==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502129862", "bodyText": "(nit) Cache _indexSegment.getValidDocIndex() into a local variable in line 61", "author": "Jackie-Jiang", "createdAt": "2020-10-09T01:56:46Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/plan/FilterPlanNode.java", "diffHunk": "@@ -58,7 +59,17 @@ public FilterPlanNode(IndexSegment indexSegment, QueryContext queryContext) {\n   public BaseFilterOperator run() {\n     FilterContext filter = _queryContext.getFilter();\n     if (filter != null) {\n-      return constructPhysicalOperator(filter, _queryContext.getDebugOptions());\n+      BaseFilterOperator filterOperator = constructPhysicalOperator(filter, _queryContext.getDebugOptions());\n+      if (_indexSegment.getValidDocIndex() != null) {", "originalCommit": "a54c1616ad0a78f9dbf765f312aa92ca2a6aef53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEzMDEyNQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502130125", "bodyText": "For better performance\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return FilterOperatorUtils.getAndFilterOperator(Lists.newArrayList(filterOperator, validDocFilter), _numDocs,\n          \n          \n            \n                    return FilterOperatorUtils.getAndFilterOperator(Arrays.asList(filterOperator, validDocFilter), _numDocs,", "author": "Jackie-Jiang", "createdAt": "2020-10-09T01:57:56Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/plan/FilterPlanNode.java", "diffHunk": "@@ -58,7 +59,17 @@ public FilterPlanNode(IndexSegment indexSegment, QueryContext queryContext) {\n   public BaseFilterOperator run() {\n     FilterContext filter = _queryContext.getFilter();\n     if (filter != null) {\n-      return constructPhysicalOperator(filter, _queryContext.getDebugOptions());\n+      BaseFilterOperator filterOperator = constructPhysicalOperator(filter, _queryContext.getDebugOptions());\n+      if (_indexSegment.getValidDocIndex() != null) {\n+        BaseFilterOperator validDocFilter =\n+            new BitmapBasedFilterOperator(_indexSegment.getValidDocIndex().getValidDocBitmap(), false, _numDocs);\n+        return FilterOperatorUtils.getAndFilterOperator(Lists.newArrayList(filterOperator, validDocFilter), _numDocs,", "originalCommit": "a54c1616ad0a78f9dbf765f312aa92ca2a6aef53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEzMDQyNQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502130425", "bodyText": "(nit) I don't think this is useful?", "author": "Jackie-Jiang", "createdAt": "2020-10-09T01:59:14Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/TableUpsertMetadataManager.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * The manager of the upsert metadata of a table.\n+ */\n+@ThreadSafe\n+public class TableUpsertMetadataManager {\n+  private final Map<Integer, PartitionUpsertMetadataManager> _partitionMetadataManagerMap = new ConcurrentHashMap<>();\n+\n+  public TableUpsertMetadataManager() {\n+  }\n+\n+  public synchronized PartitionUpsertMetadataManager getOrCreatePartitionManager(int partitionId) {\n+    if(!_partitionMetadataManagerMap.containsKey(partitionId)) {\n+      _partitionMetadataManagerMap.put(partitionId, new PartitionUpsertMetadataManager(partitionId));\n+    }\n+    return _partitionMetadataManagerMap.get(partitionId);\n+  }\n+\n+  public boolean isEmpty() {", "originalCommit": "a54c1616ad0a78f9dbf765f312aa92ca2a6aef53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEzMDk0MQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502130941", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public synchronized PartitionUpsertMetadataManager getOrCreatePartitionManager(int partitionId) {\n          \n          \n            \n                if(!_partitionMetadataManagerMap.containsKey(partitionId)) {\n          \n          \n            \n                  _partitionMetadataManagerMap.put(partitionId, new PartitionUpsertMetadataManager(partitionId));\n          \n          \n            \n                }\n          \n          \n            \n                return _partitionMetadataManagerMap.get(partitionId);\n          \n          \n            \n              }\n          \n          \n            \n              public PartitionUpsertMetadataManager getOrCreatePartitionManager(int partitionId) {\n          \n          \n            \n                return _partitionMetadataManagerMap.computeIfAbsent(partitionId, PartitionUpsertMetadataManager::new);\n          \n          \n            \n              }", "author": "Jackie-Jiang", "createdAt": "2020-10-09T02:01:21Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/TableUpsertMetadataManager.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * The manager of the upsert metadata of a table.\n+ */\n+@ThreadSafe\n+public class TableUpsertMetadataManager {\n+  private final Map<Integer, PartitionUpsertMetadataManager> _partitionMetadataManagerMap = new ConcurrentHashMap<>();\n+\n+  public TableUpsertMetadataManager() {\n+  }\n+\n+  public synchronized PartitionUpsertMetadataManager getOrCreatePartitionManager(int partitionId) {\n+    if(!_partitionMetadataManagerMap.containsKey(partitionId)) {\n+      _partitionMetadataManagerMap.put(partitionId, new PartitionUpsertMetadataManager(partitionId));\n+    }\n+    return _partitionMetadataManagerMap.get(partitionId);\n+  }", "originalCommit": "a54c1616ad0a78f9dbf765f312aa92ca2a6aef53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3NjIzNQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502176235", "bodyText": "nice", "author": "yupeng9", "createdAt": "2020-10-09T03:57:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEzMDk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk3NTQ3Ng==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502975476", "bodyText": "we can think about defining an interface and allow the implementation of upsert/append Metadata Manager. This would prevent a lot of null checking/special case handling of upsert related logics", "author": "jamesyfshao", "createdAt": "2020-10-11T22:39:55Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManager.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Manages the upsert metadata per partition.\n+ */\n+@ThreadSafe\n+public class PartitionUpsertMetadataManager {", "originalCommit": "6711a7d55effb22c3ee55043a5b7977fc5523417", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAwNTQ5NA==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r503005494", "bodyText": "I don't quite get this. Do you suggest other implementations of the Upsert Metadata Manager by introducing the interface? It's unclear to how this helps the null checking.", "author": "yupeng9", "createdAt": "2020-10-12T02:15:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk3NTQ3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcwMTY4Mw==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r503701683", "bodyText": "I mean for a new component like this it will be great if they are implemented as interface -> concrete class. This provides multiple benefits:\n\n\nit allows people to use different implementations of the same upsert logics. Think of someone who wants to use a key/value mapping backed by rocksdb, it will be much easier to swap this part out if it is backed by an interface.\n\n\nit allows us to provide a dummy implementation of MetadataManager for append-only segmentImpl. For example, this could be one PartitionUpsertMetadataManager and PartitionAppendMetadataManager both extends PartitionMetadataManager interface. This way it would allow us to create a concrete class based on whether we are dealing with upsert/append table and avoid the branching conditions for append/upsert logics", "author": "jamesyfshao", "createdAt": "2020-10-13T06:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk3NTQ3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5NDY2OQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r504094669", "bodyText": "I see.\nI think we can do the abstraction and add the interface when we come to it. For now, I feel it's a bit too early to add this generalization. You know, I'm a bit influenced by this philosophy :)", "author": "yupeng9", "createdAt": "2020-10-13T16:30:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk3NTQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk3NzU1Ng==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502977556", "bodyText": "recommend to use {} for string substitute in logging", "author": "jamesyfshao", "createdAt": "2020-10-11T22:58:39Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -453,6 +465,49 @@ public boolean index(GenericRow row, @Nullable RowMetadata rowMetadata) {\n     return canTakeMore;\n   }\n \n+  private boolean isUpsertEnabled() {\n+    return _upsertMode != null && _upsertMode != UpsertConfig.Mode.NONE;\n+  }\n+\n+  private void handleUpsert(GenericRow row, int docId) {\n+    // below are upsert operations\n+    PrimaryKey primaryKey = row.getPrimaryKey(_schema.getPrimaryKeyColumns());\n+    Object timeValue = row.getValue(_timeColumnName);\n+    Preconditions.checkArgument(timeValue instanceof Comparable, \"time column shall be comparable\");\n+    long timestamp = IngestionUtils.extractTimeValue((Comparable) timeValue);\n+    RecordLocation location = new RecordLocation(_segmentName, docId, timestamp);\n+    // check local primary key index first\n+    if (_primaryKeyIndex.containsKey(primaryKey)) {\n+      RecordLocation prevLocation = _primaryKeyIndex.get(primaryKey);\n+      if (location.getTimestamp() >= prevLocation.getTimestamp()) {\n+        _primaryKeyIndex.put(primaryKey, location);\n+        // update validDocIndex\n+        _validDocIndex.remove(prevLocation.getDocId());\n+        _validDocIndex.checkAndAdd(location.getDocId());\n+        LOGGER.debug(String\n+            .format(\"upsert: replace old doc id %d with %d for key: %s, hash: %d\", prevLocation.getDocId(),", "originalCommit": "6711a7d55effb22c3ee55043a5b7977fc5523417", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk3ODQwOQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502978409", "bodyText": "It seems that we don't update the record location _partitionUpsertMetadataManager in this if condition, is that any concern for data correctness over here?", "author": "jamesyfshao", "createdAt": "2020-10-11T23:06:54Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -453,6 +465,49 @@ public boolean index(GenericRow row, @Nullable RowMetadata rowMetadata) {\n     return canTakeMore;\n   }\n \n+  private boolean isUpsertEnabled() {\n+    return _upsertMode != null && _upsertMode != UpsertConfig.Mode.NONE;\n+  }\n+\n+  private void handleUpsert(GenericRow row, int docId) {\n+    // below are upsert operations\n+    PrimaryKey primaryKey = row.getPrimaryKey(_schema.getPrimaryKeyColumns());\n+    Object timeValue = row.getValue(_timeColumnName);\n+    Preconditions.checkArgument(timeValue instanceof Comparable, \"time column shall be comparable\");\n+    long timestamp = IngestionUtils.extractTimeValue((Comparable) timeValue);\n+    RecordLocation location = new RecordLocation(_segmentName, docId, timestamp);\n+    // check local primary key index first\n+    if (_primaryKeyIndex.containsKey(primaryKey)) {", "originalCommit": "6711a7d55effb22c3ee55043a5b7977fc5523417", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAxMzkxMw==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r503013913", "bodyText": "Yes. This is a local cache in the mutable segment, and the cache is only added to _partitionUpsertMetadataManager  during segment sealing. Note that the docId may change during sealing, that's why _primaryKeyIndex  needs to be recomputed at that time.", "author": "yupeng9", "createdAt": "2020-10-12T02:57:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk3ODQwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4MDU1Nw==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502980557", "bodyText": "handleUpsert()?", "author": "jamesyfshao", "createdAt": "2020-10-11T23:26:38Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManager.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Manages the upsert metadata per partition.\n+ */\n+@ThreadSafe\n+public class PartitionUpsertMetadataManager {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(PartitionUpsertMetadataManager.class);\n+\n+  private final int _partitionId;\n+\n+  private final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap<>();\n+  // the mapping between the (sealed) segment and its validDocuments\n+  private final ConcurrentHashMap<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIndexMap = new ConcurrentHashMap<>();\n+\n+  public PartitionUpsertMetadataManager(int partitionId) {\n+    _partitionId = partitionId;\n+  }\n+\n+  public void removeRecordLocation(PrimaryKey primaryKey) {\n+    _primaryKeyIndex.remove(primaryKey);\n+  }\n+\n+  public boolean containsKey(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.containsKey(primaryKey);\n+  }\n+\n+  public RecordLocation getRecordLocation(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.get(primaryKey);\n+  }\n+\n+  public ThreadSafeMutableRoaringBitmap getValidDocIndex(String segmentName) {\n+    return _segmentToValidDocIndexMap.get(segmentName);\n+  }\n+\n+  private ThreadSafeMutableRoaringBitmap getOrCreateValidDocIndex(String segmentName) {\n+    return _segmentToValidDocIndexMap.computeIfAbsent(segmentName, k->new ThreadSafeMutableRoaringBitmap());\n+  }\n+\n+  public synchronized void removeUpsertMetadata(String segmentName) {\n+    _segmentToValidDocIndexMap.remove(segmentName);\n+    for (Map.Entry<PrimaryKey, RecordLocation> entry : new HashSet<>(_primaryKeyIndex.entrySet())) {\n+      if (entry.getValue().getSegmentName().equals(segmentName)) {\n+        _primaryKeyIndex.remove(entry.getKey());\n+      }\n+    }\n+  }\n+\n+  int getPartitionId() {\n+    return _partitionId;\n+  }\n+\n+  public synchronized void handUpsert(PrimaryKey primaryKey, RecordLocation location, String segmentName) {", "originalCommit": "6711a7d55effb22c3ee55043a5b7977fc5523417", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4MDYzOQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502980639", "bodyText": "piggyback on @Jackie-Jiang comment in other class, I think we should abstract all primary key interaction from segment to this class", "author": "jamesyfshao", "createdAt": "2020-10-11T23:27:19Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManager.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Manages the upsert metadata per partition.\n+ */\n+@ThreadSafe\n+public class PartitionUpsertMetadataManager {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(PartitionUpsertMetadataManager.class);\n+\n+  private final int _partitionId;\n+\n+  private final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap<>();\n+  // the mapping between the (sealed) segment and its validDocuments\n+  private final ConcurrentHashMap<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIndexMap = new ConcurrentHashMap<>();\n+\n+  public PartitionUpsertMetadataManager(int partitionId) {\n+    _partitionId = partitionId;\n+  }\n+\n+  public void removeRecordLocation(PrimaryKey primaryKey) {\n+    _primaryKeyIndex.remove(primaryKey);\n+  }\n+\n+  public boolean containsKey(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.containsKey(primaryKey);\n+  }\n+\n+  public RecordLocation getRecordLocation(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.get(primaryKey);\n+  }\n+\n+  public ThreadSafeMutableRoaringBitmap getValidDocIndex(String segmentName) {\n+    return _segmentToValidDocIndexMap.get(segmentName);\n+  }\n+\n+  private ThreadSafeMutableRoaringBitmap getOrCreateValidDocIndex(String segmentName) {\n+    return _segmentToValidDocIndexMap.computeIfAbsent(segmentName, k->new ThreadSafeMutableRoaringBitmap());\n+  }\n+\n+  public synchronized void removeUpsertMetadata(String segmentName) {\n+    _segmentToValidDocIndexMap.remove(segmentName);\n+    for (Map.Entry<PrimaryKey, RecordLocation> entry : new HashSet<>(_primaryKeyIndex.entrySet())) {\n+      if (entry.getValue().getSegmentName().equals(segmentName)) {\n+        _primaryKeyIndex.remove(entry.getKey());\n+      }\n+    }\n+  }\n+\n+  int getPartitionId() {\n+    return _partitionId;\n+  }\n+\n+  public synchronized void handUpsert(PrimaryKey primaryKey, RecordLocation location, String segmentName) {\n+    if (containsKey(primaryKey)) {", "originalCommit": "6711a7d55effb22c3ee55043a5b7977fc5523417", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4MjQwMw==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502982403", "bodyText": "do we need to handle the case where the old DocIndex get deleted because of old segment removal? It might generate null pointer in this case", "author": "jamesyfshao", "createdAt": "2020-10-11T23:42:55Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManager.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Manages the upsert metadata per partition.\n+ */\n+@ThreadSafe\n+public class PartitionUpsertMetadataManager {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(PartitionUpsertMetadataManager.class);\n+\n+  private final int _partitionId;\n+\n+  private final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap<>();\n+  // the mapping between the (sealed) segment and its validDocuments\n+  private final ConcurrentHashMap<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIndexMap = new ConcurrentHashMap<>();\n+\n+  public PartitionUpsertMetadataManager(int partitionId) {\n+    _partitionId = partitionId;\n+  }\n+\n+  public void removeRecordLocation(PrimaryKey primaryKey) {\n+    _primaryKeyIndex.remove(primaryKey);\n+  }\n+\n+  public boolean containsKey(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.containsKey(primaryKey);\n+  }\n+\n+  public RecordLocation getRecordLocation(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.get(primaryKey);\n+  }\n+\n+  public ThreadSafeMutableRoaringBitmap getValidDocIndex(String segmentName) {\n+    return _segmentToValidDocIndexMap.get(segmentName);\n+  }\n+\n+  private ThreadSafeMutableRoaringBitmap getOrCreateValidDocIndex(String segmentName) {\n+    return _segmentToValidDocIndexMap.computeIfAbsent(segmentName, k->new ThreadSafeMutableRoaringBitmap());\n+  }\n+\n+  public synchronized void removeUpsertMetadata(String segmentName) {\n+    _segmentToValidDocIndexMap.remove(segmentName);\n+    for (Map.Entry<PrimaryKey, RecordLocation> entry : new HashSet<>(_primaryKeyIndex.entrySet())) {\n+      if (entry.getValue().getSegmentName().equals(segmentName)) {\n+        _primaryKeyIndex.remove(entry.getKey());\n+      }\n+    }\n+  }\n+\n+  int getPartitionId() {\n+    return _partitionId;\n+  }\n+\n+  public synchronized void handUpsert(PrimaryKey primaryKey, RecordLocation location, String segmentName) {\n+    if (containsKey(primaryKey)) {\n+      RecordLocation prevLocation = getRecordLocation(primaryKey);\n+      // upsert\n+      if (location.getTimestamp() >= prevLocation.getTimestamp()) {\n+        removeRecordLocation(primaryKey);\n+        _primaryKeyIndex.put(primaryKey, location);\n+        getValidDocIndex(prevLocation.getSegmentName())", "originalCommit": "6711a7d55effb22c3ee55043a5b7977fc5523417", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAxNDQ3Ng==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r503014476", "bodyText": "I don't think so, because of the lock. But let me add the check to be extra safe.", "author": "yupeng9", "createdAt": "2020-10-12T02:59:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4MjQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4Mzg0OQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502983849", "bodyText": "this question might be better addressed in the design doc, but I wonder have we measure the performance & space trade-off of using RoaringBitMap for validDoc? Another alternative will be just using simple bitArray/bytes to store this data, will be interesting to see if we can explain further in the design doc or in codes", "author": "jamesyfshao", "createdAt": "2020-10-11T23:55:55Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/ValidDocIndexReader.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.index.readers;\n+\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+\n+\n+public interface ValidDocIndexReader {\n+\n+  /**\n+   * Return the underlying validDoc bitmap (used in query execution)\n+   */\n+  ImmutableRoaringBitmap getValidDocBitmap();", "originalCommit": "6711a7d55effb22c3ee55043a5b7977fc5523417", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAxNTAzNQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r503015035", "bodyText": "Because the valid doc index can be frequently changed, i.e. when an update happens to invalidate an old doc.\nI think we can reuse the same technique that is used for null vector?", "author": "yupeng9", "createdAt": "2020-10-12T03:02:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4Mzg0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NDMzMw==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502984333", "bodyText": "back to my previous point about memory usage, I think maybe you can extract this HashMap to something like an interface wrapping the actual implmentation so we can potentially explore other implementations for primary key mapping", "author": "jamesyfshao", "createdAt": "2020-10-12T00:00:31Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManager.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Manages the upsert metadata per partition.\n+ */\n+@ThreadSafe\n+public class PartitionUpsertMetadataManager {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(PartitionUpsertMetadataManager.class);\n+\n+  private final int _partitionId;\n+\n+  private final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap<>();", "originalCommit": "6711a7d55effb22c3ee55043a5b7977fc5523417", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NDM5Mg==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r502984392", "bodyText": "handleUpsert?", "author": "jamesyfshao", "createdAt": "2020-10-12T00:00:53Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManager.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Manages the upsert metadata per partition.\n+ */\n+@ThreadSafe\n+public class PartitionUpsertMetadataManager {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(PartitionUpsertMetadataManager.class);\n+\n+  private final int _partitionId;\n+\n+  private final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyIndex = new ConcurrentHashMap<>();\n+  // the mapping between the (sealed) segment and its validDocuments\n+  private final ConcurrentHashMap<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIndexMap = new ConcurrentHashMap<>();\n+\n+  public PartitionUpsertMetadataManager(int partitionId) {\n+    _partitionId = partitionId;\n+  }\n+\n+  public void removeRecordLocation(PrimaryKey primaryKey) {\n+    _primaryKeyIndex.remove(primaryKey);\n+  }\n+\n+  public boolean containsKey(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.containsKey(primaryKey);\n+  }\n+\n+  public RecordLocation getRecordLocation(PrimaryKey primaryKey) {\n+    return _primaryKeyIndex.get(primaryKey);\n+  }\n+\n+  public ThreadSafeMutableRoaringBitmap getValidDocIndex(String segmentName) {\n+    return _segmentToValidDocIndexMap.get(segmentName);\n+  }\n+\n+  private ThreadSafeMutableRoaringBitmap getOrCreateValidDocIndex(String segmentName) {\n+    return _segmentToValidDocIndexMap.computeIfAbsent(segmentName, k->new ThreadSafeMutableRoaringBitmap());\n+  }\n+\n+  public synchronized void removeUpsertMetadata(String segmentName) {\n+    _segmentToValidDocIndexMap.remove(segmentName);\n+    for (Map.Entry<PrimaryKey, RecordLocation> entry : new HashSet<>(_primaryKeyIndex.entrySet())) {\n+      if (entry.getValue().getSegmentName().equals(segmentName)) {\n+        _primaryKeyIndex.remove(entry.getKey());\n+      }\n+    }\n+  }\n+\n+  int getPartitionId() {\n+    return _partitionId;\n+  }\n+\n+  public synchronized void handUpsert(PrimaryKey primaryKey, RecordLocation location, String segmentName) {", "originalCommit": "6711a7d55effb22c3ee55043a5b7977fc5523417", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNTg1OA==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r503515858", "bodyText": "tableconfig is available at the time TableDataManager is created. Can you use that instead of fetching it again here?\nAlso, TableDataManager is not recreaated if table config changes. How do you plan to address tha?", "author": "mcvsubbu", "createdAt": "2020-10-12T20:26:04Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -132,6 +146,19 @@ protected void doInit() {\n     String consumerDirPath = getConsumerDir();\n     File consumerDir = new File(consumerDirPath);\n \n+    TableConfig tableConfig = ZKMetadataProvider.getTableConfig(_propertyStore, _tableNameWithType);", "originalCommit": "8420b0f171757ad7198bec17258dcec4472410c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY2ODUzMg==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r503668532", "bodyText": "hmm, I did not see how to access it but from _propertyStore . Can you be more specific?\nAlso, I am not sure the upsert config can change dynamically: partial vs full seems a disruptive change.", "author": "yupeng9", "createdAt": "2020-10-13T05:03:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNTg1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5NjE0Mw==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r504096143", "bodyText": "It is ok to require that the servers need to be restarted if the table config is changed, but we need to note it some place. I am not sure if the table reload reloads the table config, please verify.", "author": "mcvsubbu", "createdAt": "2020-10-13T16:33:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNTg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNTk1Mg==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r503515952", "bodyText": "Please ise _streamPartitionId member variable", "author": "mcvsubbu", "createdAt": "2020-10-12T20:26:18Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/LLRealtimeSegmentDataManager.java", "diffHunk": "@@ -1165,6 +1172,14 @@ public LLRealtimeSegmentDataManager(RealtimeSegmentZKMetadata segmentZKMetadata,\n     Set<String> textIndexColumns = indexLoadingConfig.getTextIndexColumns();\n     _textIndexColumns = new ArrayList<>(textIndexColumns);\n \n+    PartitionUpsertMetadataManager partitionUpsertMetadataManager = null;\n+    UpsertConfig.Mode upsertMode = _tableConfig.getUpsertMode();\n+    if (_upsertMetadataTableManager != null && upsertMode != UpsertConfig.Mode.NONE) {\n+      int partitionId = new LLCSegmentName(_segmentNameStr).getPartitionId();", "originalCommit": "8420b0f171757ad7198bec17258dcec4472410c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY1NTk4MA==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r503655980", "bodyText": "Good point.", "author": "yupeng9", "createdAt": "2020-10-13T04:10:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNTk1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNzg1NQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r503517855", "bodyText": "Can we move the upsert handling to a different class? Perhaps a subclass of RealtimeTableDataManager?", "author": "mcvsubbu", "createdAt": "2020-10-12T20:30:58Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -266,14 +292,52 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n         manager =\n             new LLRealtimeSegmentDataManager(realtimeSegmentZKMetadata, tableConfig, this, _indexDir.getAbsolutePath(),\n                 indexLoadingConfig, schema, llcSegmentName, _partitionIdToSemaphoreMap.get(streamPartitionId),\n-                _serverMetrics);\n+                _serverMetrics, _tableUpsertMetadataManager);\n       }\n       _logger.info(\"Initialize RealtimeSegmentDataManager - \" + segmentName);\n       _segmentDataManagerMap.put(segmentName, manager);\n       _serverMetrics.addValueToTableGauge(_tableNameWithType, ServerGauge.SEGMENT_COUNT, 1L);\n     }\n   }\n \n+  private boolean isUpsertEnabled() {\n+    return _upsertMode == UpsertConfig.Mode.FULL || _upsertMode == UpsertConfig.Mode.PARTIAL;\n+  }\n+\n+  @Override\n+  public void addSegment(ImmutableSegment immutableSegment) {\n+    if (isUpsertEnabled()) {\n+      handleUpsert(immutableSegment);\n+    }\n+    super.addSegment(immutableSegment);\n+  }\n+\n+  private void handleUpsert(ImmutableSegment immutableSegment) {", "originalCommit": "8420b0f171757ad7198bec17258dcec4472410c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY3MjM0OA==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r503672348", "bodyText": "Do you suggest creating a RealTimeUpsertTableDataManager in TableDataManagerProvider.getTableDataManager?  It's an option to me, though I feel uspert shall be better built as a first-class citizen in realtime table. @Jackie-Jiang what do you think?", "author": "yupeng9", "createdAt": "2020-10-13T05:17:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNzg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA5ODM1MA==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r504098350", "bodyText": "Yes, I would prefer creating a RealtimeUpsertTableDataManager if upsert is on for a table. This can be a subclass of RealtimeTableDataManager. It will still be a first class citizen, just  keeping code independent with minimum if statement", "author": "mcvsubbu", "createdAt": "2020-10-13T16:36:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNzg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE4MjAwMQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r504182001", "bodyText": "@mcvsubbu It is a little bit hard to create this new class without duplicating code. Going through the code, there are very few checks for upsert, so I think for now it is okay to colocate the upsert within the RealtimeTableManager. Upsert is just a feature on top of the LLC table, and it does not rely on any external services to work (different from the previous design).", "author": "Jackie-Jiang", "createdAt": "2020-10-13T18:49:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNzg1NQ=="}], "type": "inlineReview"}, {"oid": "7df7d77991cd679d7e4f8ab2455a4ff759317aa8", "url": "https://github.com/apache/pinot/commit/7df7d77991cd679d7e4f8ab2455a4ff759317aa8", "message": "upsert local\n\nsupport where clause\n\nclean up upsert config\n\nadd metadataPartitionManager\n\nadd upsert during segment loading\n\nupdates\n\nadd partition by key to upsert quick start", "committedDate": "2020-10-13T23:03:14Z", "type": "commit"}, {"oid": "b8f292af8f5125a4b4fdb4b8fc872604bff19105", "url": "https://github.com/apache/pinot/commit/b8f292af8f5125a4b4fdb4b8fc872604bff19105", "message": "fix", "committedDate": "2020-10-13T23:03:14Z", "type": "commit"}, {"oid": "d0873cb39f8f3c82268f0d1fa820cdde7a0f149e", "url": "https://github.com/apache/pinot/commit/d0873cb39f8f3c82268f0d1fa820cdde7a0f149e", "message": "add ingestion test", "committedDate": "2020-10-13T23:03:14Z", "type": "commit"}, {"oid": "c3b3a9127b7924735ca42d3cdd4a5d91ad5e7f4d", "url": "https://github.com/apache/pinot/commit/c3b3a9127b7924735ca42d3cdd4a5d91ad5e7f4d", "message": "cleanup", "committedDate": "2020-10-13T23:03:14Z", "type": "commit"}, {"oid": "7d3d2b2bdae3da7aecfa48c0dc2d4e37838aeb20", "url": "https://github.com/apache/pinot/commit/7d3d2b2bdae3da7aecfa48c0dc2d4e37838aeb20", "message": "add fix", "committedDate": "2020-10-13T23:03:14Z", "type": "commit"}, {"oid": "96c7e220d05fd065866ad7e0b70a33ab738b178c", "url": "https://github.com/apache/pinot/commit/96c7e220d05fd065866ad7e0b70a33ab738b178c", "message": "change back log level", "committedDate": "2020-10-13T23:03:14Z", "type": "commit"}, {"oid": "72698b6b3d8523db7ba849da98c40e72d1e93f32", "url": "https://github.com/apache/pinot/commit/72698b6b3d8523db7ba849da98c40e72d1e93f32", "message": "use logger", "committedDate": "2020-10-13T23:03:15Z", "type": "commit"}, {"oid": "17f07728d3e1d37726b13c755418be581c19de1c", "url": "https://github.com/apache/pinot/commit/17f07728d3e1d37726b13c755418be581c19de1c", "message": "address comments", "committedDate": "2020-10-13T23:03:15Z", "type": "commit"}, {"oid": "a721dff9ee8611c9af421de565d301ed325c40b0", "url": "https://github.com/apache/pinot/commit/a721dff9ee8611c9af421de565d301ed325c40b0", "message": "comments", "committedDate": "2020-10-13T23:03:15Z", "type": "commit"}, {"oid": "71f7de576b15dfc6cdaec1351a9d338d08c31c32", "url": "https://github.com/apache/pinot/commit/71f7de576b15dfc6cdaec1351a9d338d08c31c32", "message": "comments", "committedDate": "2020-10-13T23:03:15Z", "type": "commit"}, {"oid": "38f42941a5e7c5132e916dcdff9101a817898ae1", "url": "https://github.com/apache/pinot/commit/38f42941a5e7c5132e916dcdff9101a817898ae1", "message": "address comments", "committedDate": "2020-10-13T23:03:15Z", "type": "commit"}, {"oid": "ff342fc88a759ed0754ef0abe0eea0f84a185471", "url": "https://github.com/apache/pinot/commit/ff342fc88a759ed0754ef0abe0eea0f84a185471", "message": "fix tests", "committedDate": "2020-10-13T23:03:15Z", "type": "commit"}, {"oid": "017e03406416b04eeb89fa21300d873f71466e55", "url": "https://github.com/apache/pinot/commit/017e03406416b04eeb89fa21300d873f71466e55", "message": "more comments", "committedDate": "2020-10-13T23:03:15Z", "type": "commit"}, {"oid": "bc40ec8ed477d46221ee2879cb8d889b3bbe2900", "url": "https://github.com/apache/pinot/commit/bc40ec8ed477d46221ee2879cb8d889b3bbe2900", "message": "fix test", "committedDate": "2020-10-13T23:03:15Z", "type": "commit"}, {"oid": "77b2d8ad4a24e87bc0db37139e2da7cc684e3623", "url": "https://github.com/apache/pinot/commit/77b2d8ad4a24e87bc0db37139e2da7cc684e3623", "message": "fix test", "committedDate": "2020-10-13T23:03:15Z", "type": "commit"}, {"oid": "b78faf4db59e1f7da6aa2b8599964c723a69c9a5", "url": "https://github.com/apache/pinot/commit/b78faf4db59e1f7da6aa2b8599964c723a69c9a5", "message": "fix test", "committedDate": "2020-10-13T23:03:15Z", "type": "commit"}, {"oid": "b145ac6adad0c3e6f1ed0a3600dfbc1f26c72d51", "url": "https://github.com/apache/pinot/commit/b145ac6adad0c3e6f1ed0a3600dfbc1f26c72d51", "message": "comments", "committedDate": "2020-10-13T23:03:15Z", "type": "commit"}, {"oid": "18060adc535d171cb4b928cc8bc9a5142c524661", "url": "https://github.com/apache/pinot/commit/18060adc535d171cb4b928cc8bc9a5142c524661", "message": "address comments", "committedDate": "2020-10-13T23:03:15Z", "type": "commit"}, {"oid": "bda7184fe8b7b5f87e473142a8bc2a5d9cbc756c", "url": "https://github.com/apache/pinot/commit/bda7184fe8b7b5f87e473142a8bc2a5d9cbc756c", "message": "Fix the concurrency issue", "committedDate": "2020-10-13T23:03:15Z", "type": "commit"}, {"oid": "6c08e7222b9e12b2e222ef230ccbe20ae2703d34", "url": "https://github.com/apache/pinot/commit/6c08e7222b9e12b2e222ef230ccbe20ae2703d34", "message": "Add more logs", "committedDate": "2020-10-13T23:03:15Z", "type": "commit"}, {"oid": "382c3f5a934f6d7654425a42660d37cfd01035ff", "url": "https://github.com/apache/pinot/commit/382c3f5a934f6d7654425a42660d37cfd01035ff", "message": "Fix test", "committedDate": "2020-10-13T23:03:15Z", "type": "commit"}, {"oid": "242d013310bea763d78720ec7bad5916338a513f", "url": "https://github.com/apache/pinot/commit/242d013310bea763d78720ec7bad5916338a513f", "message": "add missing resources", "committedDate": "2020-10-13T23:03:15Z", "type": "commit"}, {"oid": "29a8831d56f244269f34a81025a434dc4b1fa790", "url": "https://github.com/apache/pinot/commit/29a8831d56f244269f34a81025a434dc4b1fa790", "message": "Misc fixes", "committedDate": "2020-10-13T23:03:15Z", "type": "commit"}, {"oid": "29a8831d56f244269f34a81025a434dc4b1fa790", "url": "https://github.com/apache/pinot/commit/29a8831d56f244269f34a81025a434dc4b1fa790", "message": "Misc fixes", "committedDate": "2020-10-13T23:03:15Z", "type": "forcePushed"}, {"oid": "ac006cd57d80f8937499c147c8401e53baae437b", "url": "https://github.com/apache/pinot/commit/ac006cd57d80f8937499c147c8401e53baae437b", "message": "Fix concurrent issue in ThreadSafeMutableRoaringBitmap", "committedDate": "2020-10-14T00:36:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgzOTYzMQ==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r504839631", "bodyText": "We should find a better way of getting partitionId than from the segment name. We are looking to integrate with other streams where partition ID is not an integer (e.g. kinesis). In that case, this will not work.\n@npawar may also want to comment on this", "author": "mcvsubbu", "createdAt": "2020-10-14T17:10:04Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -378,7 +463,12 @@ public void replaceLLSegment(String segmentName, IndexLoadingConfig indexLoading\n     try {\n       File indexDir = new File(_indexDir, segmentName);\n       Schema schema = ZKMetadataProvider.getTableSchema(_propertyStore, _tableNameWithType);\n-      addSegment(ImmutableSegmentLoader.load(indexDir, indexLoadingConfig, schema));\n+      PartitionUpsertMetadataManager partitionUpsertMetadataManager = null;\n+      if (_tableUpsertMetadataManager != null) {\n+        int partitionId = new LLCSegmentName(segmentName).getPartitionId();", "originalCommit": "ac006cd57d80f8937499c147c8401e53baae437b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk4MzM2Mg==", "url": "https://github.com/apache/pinot/pull/6113#discussion_r504983362", "bodyText": "as of now I don't see any other way of getting the partition id. Separately, we might want to start changes to put partition id/ sequence number into the segment zk metadata.", "author": "npawar", "createdAt": "2020-10-14T21:30:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgzOTYzMQ=="}], "type": "inlineReview"}]}