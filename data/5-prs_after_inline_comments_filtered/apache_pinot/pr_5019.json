{"pr_number": 5019, "pr_title": "Make output schema to match selection list for aggregation groupbys", "pr_createdAt": "2020-01-27T14:12:15Z", "pr_url": "https://github.com/apache/pinot/pull/5019", "timeline": [{"oid": "3a3d70ca78aa700a7af5ed0a177dbd87c03011ed", "url": "https://github.com/apache/pinot/commit/3a3d70ca78aa700a7af5ed0a177dbd87c03011ed", "message": "Make output schema to match selection list for aggregation groupbys", "committedDate": "2020-01-27T14:10:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzNjg4MA==", "url": "https://github.com/apache/pinot/pull/5019#discussion_r371436880", "bodyText": "When will this if block be needed? These will always be in the group by clause, and hence be handled by 269 right?", "author": "npawar", "createdAt": "2020-01-27T19:28:56Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -194,14 +210,104 @@ private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNativ\n         values[index] = _aggregationFunctions[aggNum++].extractFinalResult(values[index]);\n         index++;\n       }\n-      rows.add(values);\n+      if (_sqlSelectionList != null) {\n+        Object[] finalValues = new Object[_sqlSelectionList.size()];\n+        for (int i = 0; i < finalSchemaMapIdx.length; i++) {\n+          if (finalSchemaMapIdx[i] == -1) {\n+            finalValues[i] = null;\n+          } else {\n+            finalValues[i] = values[finalSchemaMapIdx[i]];\n+          }\n+        }\n+        rows.add(finalValues);\n+      } else {\n+        rows.add(values);\n+      }\n       numRows++;\n     }\n \n     DataSchema finalDataSchema = getSQLResultTableSchema(dataSchema);\n+    if (_sqlSelectionList != null) {\n+      int columnSize = _sqlSelectionList.size();\n+      String[] columns = new String[columnSize];\n+      DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[columnSize];\n+      for (int i = 0; i < columnSize; i++) {\n+        if (finalSchemaMapIdx[i] == -1) {\n+          columns[i] = RequestUtils.prettyPrint(_sqlSelectionList.get(i));\n+          columnDataTypes[i] = DataSchema.ColumnDataType.STRING;\n+        } else {\n+          columns[i] = finalDataSchema.getColumnName(finalSchemaMapIdx[i]);\n+          columnDataTypes[i] = finalDataSchema.getColumnDataType(finalSchemaMapIdx[i]);\n+        }\n+      }\n+      finalDataSchema = new DataSchema(columns, columnDataTypes);\n+    }\n     brokerResponseNative.setResultTable(new ResultTable(finalDataSchema, rows));\n   }\n \n+  /**\n+   * Generate index mapping based on selection expression to DataTable schema, which is groupBy columns,\n+   * then aggregation functions.\n+   * @param dataSchema\n+   *\n+   * @return a mapping from final schema idx to corresponding idx in data table schema.\n+   */\n+  private int[] getFinalSchemaMapIdx(DataSchema dataSchema) {\n+    int[] finalSchemaMapIdx = new int[_sqlSelectionList.size()];\n+    int nextAggregationIdx = _numGroupBy;\n+    for (int i = 0; i < _sqlSelectionList.size(); i++) {\n+      finalSchemaMapIdx[i] = getExpressionMapIdx(dataSchema, _sqlSelectionList.get(i), nextAggregationIdx);\n+      if (finalSchemaMapIdx[i] == nextAggregationIdx) {\n+        nextAggregationIdx++;\n+      }\n+    }\n+    return finalSchemaMapIdx;\n+  }\n+\n+  private int getExpressionMapIdx(DataSchema dataSchema, Expression expression, int nextAggregationIdx) {\n+    // Check if expression matches groupBy list.\n+    int idxFromGroupByList = getGroupByIdx(_groupByList, expression);\n+    if (idxFromGroupByList != -1) {\n+      return idxFromGroupByList;\n+    }\n+    // Handle all functions\n+    if (expression.getFunctionCall() != null) {\n+      // handle AS\n+      if (expression.getFunctionCall().getOperator().equalsIgnoreCase(\"AS\")) {\n+        return getExpressionMapIdx(dataSchema, expression.getFunctionCall().getOperands().get(0), nextAggregationIdx);\n+      }\n+      // Return next aggregation idx.\n+      return nextAggregationIdx;\n+    }\n+    // Handle identifier, which is a column.\n+    if (expression.getIdentifier() != null) {", "originalCommit": "3a3d70ca78aa700a7af5ed0a177dbd87c03011ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ1NjY4OA==", "url": "https://github.com/apache/pinot/pull/5019#discussion_r371456688", "bodyText": "Right, will remove this block", "author": "xiangfu0", "createdAt": "2020-01-27T20:08:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzNjg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzODUwNA==", "url": "https://github.com/apache/pinot/pull/5019#discussion_r371438504", "bodyText": "this group by list will be scanned for every single expression in the selection. Do you think it's worth constructing a map upfront groupByExpr -> index , within getFinalSchemaIdx method?", "author": "npawar", "createdAt": "2020-01-27T19:31:58Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -194,14 +210,104 @@ private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNativ\n         values[index] = _aggregationFunctions[aggNum++].extractFinalResult(values[index]);\n         index++;\n       }\n-      rows.add(values);\n+      if (_sqlSelectionList != null) {\n+        Object[] finalValues = new Object[_sqlSelectionList.size()];\n+        for (int i = 0; i < finalSchemaMapIdx.length; i++) {\n+          if (finalSchemaMapIdx[i] == -1) {\n+            finalValues[i] = null;\n+          } else {\n+            finalValues[i] = values[finalSchemaMapIdx[i]];\n+          }\n+        }\n+        rows.add(finalValues);\n+      } else {\n+        rows.add(values);\n+      }\n       numRows++;\n     }\n \n     DataSchema finalDataSchema = getSQLResultTableSchema(dataSchema);\n+    if (_sqlSelectionList != null) {\n+      int columnSize = _sqlSelectionList.size();\n+      String[] columns = new String[columnSize];\n+      DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[columnSize];\n+      for (int i = 0; i < columnSize; i++) {\n+        if (finalSchemaMapIdx[i] == -1) {\n+          columns[i] = RequestUtils.prettyPrint(_sqlSelectionList.get(i));\n+          columnDataTypes[i] = DataSchema.ColumnDataType.STRING;\n+        } else {\n+          columns[i] = finalDataSchema.getColumnName(finalSchemaMapIdx[i]);\n+          columnDataTypes[i] = finalDataSchema.getColumnDataType(finalSchemaMapIdx[i]);\n+        }\n+      }\n+      finalDataSchema = new DataSchema(columns, columnDataTypes);\n+    }\n     brokerResponseNative.setResultTable(new ResultTable(finalDataSchema, rows));\n   }\n \n+  /**\n+   * Generate index mapping based on selection expression to DataTable schema, which is groupBy columns,\n+   * then aggregation functions.\n+   * @param dataSchema\n+   *\n+   * @return a mapping from final schema idx to corresponding idx in data table schema.\n+   */\n+  private int[] getFinalSchemaMapIdx(DataSchema dataSchema) {\n+    int[] finalSchemaMapIdx = new int[_sqlSelectionList.size()];\n+    int nextAggregationIdx = _numGroupBy;\n+    for (int i = 0; i < _sqlSelectionList.size(); i++) {\n+      finalSchemaMapIdx[i] = getExpressionMapIdx(dataSchema, _sqlSelectionList.get(i), nextAggregationIdx);\n+      if (finalSchemaMapIdx[i] == nextAggregationIdx) {\n+        nextAggregationIdx++;\n+      }\n+    }\n+    return finalSchemaMapIdx;\n+  }\n+\n+  private int getExpressionMapIdx(DataSchema dataSchema, Expression expression, int nextAggregationIdx) {\n+    // Check if expression matches groupBy list.\n+    int idxFromGroupByList = getGroupByIdx(_groupByList, expression);\n+    if (idxFromGroupByList != -1) {\n+      return idxFromGroupByList;\n+    }\n+    // Handle all functions\n+    if (expression.getFunctionCall() != null) {\n+      // handle AS\n+      if (expression.getFunctionCall().getOperator().equalsIgnoreCase(\"AS\")) {\n+        return getExpressionMapIdx(dataSchema, expression.getFunctionCall().getOperands().get(0), nextAggregationIdx);\n+      }\n+      // Return next aggregation idx.\n+      return nextAggregationIdx;\n+    }\n+    // Handle identifier, which is a column.\n+    if (expression.getIdentifier() != null) {\n+      String columnName = expression.getIdentifier().getName();\n+      for (int i = 0; i < dataSchema.size(); i++) {\n+        if (columnName.equalsIgnoreCase(dataSchema.getColumnName(i))) {\n+          return i;\n+        }\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  /**\n+   * Trying to match an expression based on given groupByList.\n+   *\n+   * @param groupByList\n+   * @param expression\n+   * @return matched idx from groupByList\n+   */\n+  private int getGroupByIdx(List<Expression> groupByList, Expression expression) {\n+    for (int i = 0; i < groupByList.size(); i++) {", "originalCommit": "3a3d70ca78aa700a7af5ed0a177dbd87c03011ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ2MDkzNA==", "url": "https://github.com/apache/pinot/pull/5019#discussion_r371460934", "bodyText": "I'm not too worried about this as the check would be selectionSize + groupBySize * groupBySize times", "author": "xiangfu0", "createdAt": "2020-01-27T20:18:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzODUwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzOTc5OA==", "url": "https://github.com/apache/pinot/pull/5019#discussion_r371439798", "bodyText": "should this ever happen? the validation during parsing should prevent this right?", "author": "npawar", "createdAt": "2020-01-27T19:34:34Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -194,14 +210,104 @@ private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNativ\n         values[index] = _aggregationFunctions[aggNum++].extractFinalResult(values[index]);\n         index++;\n       }\n-      rows.add(values);\n+      if (_sqlSelectionList != null) {\n+        Object[] finalValues = new Object[_sqlSelectionList.size()];\n+        for (int i = 0; i < finalSchemaMapIdx.length; i++) {\n+          if (finalSchemaMapIdx[i] == -1) {", "originalCommit": "3a3d70ca78aa700a7af5ed0a177dbd87c03011ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ1OTY4OQ==", "url": "https://github.com/apache/pinot/pull/5019#discussion_r371459689", "bodyText": "true, removed this block", "author": "xiangfu0", "createdAt": "2020-01-27T20:15:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzOTc5OA=="}], "type": "inlineReview"}, {"oid": "2c513258eb669782ba001beeb133488bdb9157c9", "url": "https://github.com/apache/pinot/commit/2c513258eb669782ba001beeb133488bdb9157c9", "message": "address comments", "committedDate": "2020-01-27T20:23:27Z", "type": "commit"}, {"oid": "2c513258eb669782ba001beeb133488bdb9157c9", "url": "https://github.com/apache/pinot/commit/2c513258eb669782ba001beeb133488bdb9157c9", "message": "address comments", "committedDate": "2020-01-27T20:23:27Z", "type": "forcePushed"}]}