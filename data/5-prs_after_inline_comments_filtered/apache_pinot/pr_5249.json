{"pr_number": 5249, "pr_title": "Adding Pinot S3 Filesystem Plugin", "pr_createdAt": "2020-04-15T15:51:52Z", "pr_url": "https://github.com/apache/pinot/pull/5249", "timeline": [{"oid": "e0876f2026ebf04bd508664ad9604d651a4763b7", "url": "https://github.com/apache/pinot/commit/e0876f2026ebf04bd508664ad9604d651a4763b7", "message": "adding pinot-s3-filsystem module", "committedDate": "2020-04-15T12:02:05Z", "type": "commit"}, {"oid": "2270bc4e145336b32ad22ecef3e00fd2fcc857ff", "url": "https://github.com/apache/pinot/commit/2270bc4e145336b32ad22ecef3e00fd2fcc857ff", "message": "bug fixes", "committedDate": "2020-04-15T15:15:30Z", "type": "commit"}, {"oid": "4a55cc4ceef627cf87d4ce344435ded19f249b49", "url": "https://github.com/apache/pinot/commit/4a55cc4ceef627cf87d4ce344435ded19f249b49", "message": "fix: excluding package for succesfull build", "committedDate": "2020-04-15T15:50:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTExNTYyOA==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r409115628", "bodyText": "Add docs on what are the properties needed for this and how to configure S3PinotFS", "author": "kishoreg", "createdAt": "2020-04-15T20:31:30Z", "path": "pinot-plugins/pinot-file-system/pinot-s3/src/main/java/org/apache/pinot/plugin/filesystem/S3PinotFS.java", "diffHunk": "@@ -0,0 +1,485 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.plugin.filesystem;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.pinot.spi.filesystem.PinotFS;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.EnvironmentVariableCredentialsProvider;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.core.ResponseBytes;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.exception.SdkServiceException;\n+import software.amazon.awssdk.core.sync.RequestBody;\n+import software.amazon.awssdk.core.sync.ResponseTransformer;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.s3.S3Client;\n+import software.amazon.awssdk.services.s3.internal.resource.S3BucketResource;\n+import software.amazon.awssdk.services.s3.model.*;\n+\n+import java.io.*;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+import static joptsimple.internal.Strings.isNullOrEmpty;\n+import static org.glassfish.jersey.internal.guava.Preconditions.checkArgument;\n+\n+public class S3PinotFS extends PinotFS {", "originalCommit": "4a55cc4ceef627cf87d4ce344435ded19f249b49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTExNTg2OQ==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r409115869", "bodyText": "should this be passed in as part of config", "author": "kishoreg", "createdAt": "2020-04-15T20:31:58Z", "path": "pinot-plugins/pinot-file-system/pinot-s3/src/main/java/org/apache/pinot/plugin/filesystem/S3PinotFS.java", "diffHunk": "@@ -0,0 +1,485 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.plugin.filesystem;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.pinot.spi.filesystem.PinotFS;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.EnvironmentVariableCredentialsProvider;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.core.ResponseBytes;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.exception.SdkServiceException;\n+import software.amazon.awssdk.core.sync.RequestBody;\n+import software.amazon.awssdk.core.sync.ResponseTransformer;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.s3.S3Client;\n+import software.amazon.awssdk.services.s3.internal.resource.S3BucketResource;\n+import software.amazon.awssdk.services.s3.model.*;\n+\n+import java.io.*;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+import static joptsimple.internal.Strings.isNullOrEmpty;\n+import static org.glassfish.jersey.internal.guava.Preconditions.checkArgument;\n+\n+public class S3PinotFS extends PinotFS {\n+    public static final String ACCESS_KEY = \"accessKey\";\n+    public static final String SECRET_KEY = \"secretKey\";\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(S3PinotFS.class);\n+    private static final String DELIMITER = \"/\";\n+    private S3Client s3Client;\n+\n+    @Override\n+    public void init(Configuration config) {\n+        checkArgument(!isNullOrEmpty(config.getString(ACCESS_KEY)));\n+        checkArgument(!isNullOrEmpty(config.getString(SECRET_KEY)));\n+        String accessKey = config.getString(ACCESS_KEY);\n+        String secretKey = config.getString(SECRET_KEY);\n+        try {\n+            AwsBasicCredentials awsBasicCredentials = AwsBasicCredentials.create(accessKey, secretKey);\n+            s3Client = S3Client.builder()", "originalCommit": "4a55cc4ceef627cf87d4ce344435ded19f249b49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2OTkwMA==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r409269900", "bodyText": "Missing space between } and catch. Please format the files with codestyle config in https://github.com/apache/incubator-pinot/tree/master/config", "author": "haibow", "createdAt": "2020-04-16T04:10:29Z", "path": "pinot-plugins/pinot-file-system/pinot-s3/src/main/java/org/apache/pinot/plugin/filesystem/S3PinotFS.java", "diffHunk": "@@ -0,0 +1,485 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.plugin.filesystem;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.pinot.spi.filesystem.PinotFS;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.EnvironmentVariableCredentialsProvider;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.core.ResponseBytes;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.exception.SdkServiceException;\n+import software.amazon.awssdk.core.sync.RequestBody;\n+import software.amazon.awssdk.core.sync.ResponseTransformer;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.s3.S3Client;\n+import software.amazon.awssdk.services.s3.internal.resource.S3BucketResource;\n+import software.amazon.awssdk.services.s3.model.*;\n+\n+import java.io.*;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+import static joptsimple.internal.Strings.isNullOrEmpty;\n+import static org.glassfish.jersey.internal.guava.Preconditions.checkArgument;\n+\n+public class S3PinotFS extends PinotFS {\n+    public static final String ACCESS_KEY = \"accessKey\";\n+    public static final String SECRET_KEY = \"secretKey\";\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(S3PinotFS.class);\n+    private static final String DELIMITER = \"/\";\n+    private S3Client s3Client;\n+\n+    @Override\n+    public void init(Configuration config) {\n+        checkArgument(!isNullOrEmpty(config.getString(ACCESS_KEY)));\n+        checkArgument(!isNullOrEmpty(config.getString(SECRET_KEY)));\n+        String accessKey = config.getString(ACCESS_KEY);\n+        String secretKey = config.getString(SECRET_KEY);\n+        try {\n+            AwsBasicCredentials awsBasicCredentials = AwsBasicCredentials.create(accessKey, secretKey);\n+            s3Client = S3Client.builder()\n+                    .region(Region.AP_SOUTHEAST_1)\n+                    .credentialsProvider(StaticCredentialsProvider.create(awsBasicCredentials))\n+                    .build();\n+\n+        } catch (S3Exception e) {\n+            throw new RuntimeException(\"Could not initialize S3PinotFS\", e);\n+        }\n+    }\n+\n+    private HeadObjectResponse getS3ObjectMetadata(URI uri) throws IOException {\n+            URI base = getBase(uri);\n+            String path = sanitizePath(base.relativize(uri).getPath());\n+            HeadObjectRequest headObjectRequest = HeadObjectRequest.builder()\n+                    .bucket(uri.getHost())\n+                    .key(path)\n+                    .build();\n+\n+            return s3Client.headObject(headObjectRequest);\n+    }\n+\n+    private boolean isPathTerminatedByDelimiter(URI uri) {\n+        return uri.getPath().endsWith(DELIMITER);\n+    }\n+\n+    private String normalizeToDirectoryPrefix(URI uri) throws IOException {\n+        requireNonNull(uri, \"uri is null\");\n+        URI strippedUri = getBase(uri).relativize(uri);\n+        if (isPathTerminatedByDelimiter(strippedUri)) {\n+            return sanitizePath(strippedUri.getPath());\n+        }\n+        return sanitizePath(strippedUri.getPath() + DELIMITER);\n+    }\n+\n+    private URI normalizeToDirectoryUri(URI uri) throws IOException {\n+        if (isPathTerminatedByDelimiter(uri)) {\n+            return uri;\n+        }\n+        try {\n+            return new URI(uri.getScheme(), uri.getHost(), sanitizePath(uri.getPath() + DELIMITER), null);\n+        } catch (URISyntaxException e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    private String sanitizePath(String path) {\n+        path = path.replaceAll(DELIMITER + \"+\", DELIMITER);\n+        if (path.startsWith(DELIMITER) && !path.equals(DELIMITER)) {\n+            path = path.substring(1);\n+        }\n+        return path;\n+    }\n+\n+    private URI getBase(URI uri) throws IOException {\n+        try {\n+            return new URI(uri.getScheme(), uri.getHost(), null, null);\n+        } catch (URISyntaxException e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    private boolean existsFile(URI uri) throws IOException {\n+        try {\n+            URI base = getBase(uri);\n+            String path = sanitizePath(base.relativize(uri).getPath());\n+            HeadObjectRequest headObjectRequest = HeadObjectRequest.builder()\n+                    .bucket(uri.getHost())\n+                    .key(path)\n+                    .build();\n+\n+            s3Client.headObject(headObjectRequest);\n+            return true;\n+        }catch(NoSuchKeyException e){", "originalCommit": "4a55cc4ceef627cf87d4ce344435ded19f249b49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MTE0Ng==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r409271146", "bodyText": "Why log.info and continue, instead of directly throwing exception?", "author": "haibow", "createdAt": "2020-04-16T04:15:20Z", "path": "pinot-plugins/pinot-file-system/pinot-s3/src/main/java/org/apache/pinot/plugin/filesystem/S3PinotFS.java", "diffHunk": "@@ -0,0 +1,485 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.plugin.filesystem;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.pinot.spi.filesystem.PinotFS;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.EnvironmentVariableCredentialsProvider;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.core.ResponseBytes;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.exception.SdkServiceException;\n+import software.amazon.awssdk.core.sync.RequestBody;\n+import software.amazon.awssdk.core.sync.ResponseTransformer;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.s3.S3Client;\n+import software.amazon.awssdk.services.s3.internal.resource.S3BucketResource;\n+import software.amazon.awssdk.services.s3.model.*;\n+\n+import java.io.*;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+import static joptsimple.internal.Strings.isNullOrEmpty;\n+import static org.glassfish.jersey.internal.guava.Preconditions.checkArgument;\n+\n+public class S3PinotFS extends PinotFS {\n+    public static final String ACCESS_KEY = \"accessKey\";\n+    public static final String SECRET_KEY = \"secretKey\";\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(S3PinotFS.class);\n+    private static final String DELIMITER = \"/\";\n+    private S3Client s3Client;\n+\n+    @Override\n+    public void init(Configuration config) {\n+        checkArgument(!isNullOrEmpty(config.getString(ACCESS_KEY)));\n+        checkArgument(!isNullOrEmpty(config.getString(SECRET_KEY)));\n+        String accessKey = config.getString(ACCESS_KEY);\n+        String secretKey = config.getString(SECRET_KEY);\n+        try {\n+            AwsBasicCredentials awsBasicCredentials = AwsBasicCredentials.create(accessKey, secretKey);\n+            s3Client = S3Client.builder()\n+                    .region(Region.AP_SOUTHEAST_1)\n+                    .credentialsProvider(StaticCredentialsProvider.create(awsBasicCredentials))\n+                    .build();\n+\n+        } catch (S3Exception e) {\n+            throw new RuntimeException(\"Could not initialize S3PinotFS\", e);\n+        }\n+    }\n+\n+    private HeadObjectResponse getS3ObjectMetadata(URI uri) throws IOException {\n+            URI base = getBase(uri);\n+            String path = sanitizePath(base.relativize(uri).getPath());\n+            HeadObjectRequest headObjectRequest = HeadObjectRequest.builder()\n+                    .bucket(uri.getHost())\n+                    .key(path)\n+                    .build();\n+\n+            return s3Client.headObject(headObjectRequest);\n+    }\n+\n+    private boolean isPathTerminatedByDelimiter(URI uri) {\n+        return uri.getPath().endsWith(DELIMITER);\n+    }\n+\n+    private String normalizeToDirectoryPrefix(URI uri) throws IOException {\n+        requireNonNull(uri, \"uri is null\");\n+        URI strippedUri = getBase(uri).relativize(uri);\n+        if (isPathTerminatedByDelimiter(strippedUri)) {\n+            return sanitizePath(strippedUri.getPath());\n+        }\n+        return sanitizePath(strippedUri.getPath() + DELIMITER);\n+    }\n+\n+    private URI normalizeToDirectoryUri(URI uri) throws IOException {\n+        if (isPathTerminatedByDelimiter(uri)) {\n+            return uri;\n+        }\n+        try {\n+            return new URI(uri.getScheme(), uri.getHost(), sanitizePath(uri.getPath() + DELIMITER), null);\n+        } catch (URISyntaxException e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    private String sanitizePath(String path) {\n+        path = path.replaceAll(DELIMITER + \"+\", DELIMITER);\n+        if (path.startsWith(DELIMITER) && !path.equals(DELIMITER)) {\n+            path = path.substring(1);\n+        }\n+        return path;\n+    }\n+\n+    private URI getBase(URI uri) throws IOException {\n+        try {\n+            return new URI(uri.getScheme(), uri.getHost(), null, null);\n+        } catch (URISyntaxException e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    private boolean existsFile(URI uri) throws IOException {\n+        try {\n+            URI base = getBase(uri);\n+            String path = sanitizePath(base.relativize(uri).getPath());\n+            HeadObjectRequest headObjectRequest = HeadObjectRequest.builder()\n+                    .bucket(uri.getHost())\n+                    .key(path)\n+                    .build();\n+\n+            s3Client.headObject(headObjectRequest);\n+            return true;\n+        }catch(NoSuchKeyException e){\n+            return false;\n+        }catch(S3Exception e){\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    private boolean isEmptyDirectory(URI uri) throws IOException {\n+        if (!isDirectory(uri)) {\n+            return false;\n+        }\n+        String prefix = normalizeToDirectoryPrefix(uri);\n+        boolean isEmpty = true;\n+        ListObjectsV2Response listObjectsV2Response;\n+        ListObjectsV2Request.Builder listObjectsV2RequestBuilder = ListObjectsV2Request.builder()\n+                .bucket(uri.getHost());\n+\n+        if (prefix.equals(DELIMITER)) {\n+            ListObjectsV2Request listObjectsV2Request = listObjectsV2RequestBuilder.build();\n+            listObjectsV2Response = s3Client.listObjectsV2(listObjectsV2Request);\n+        } else {\n+            ListObjectsV2Request listObjectsV2Request = listObjectsV2RequestBuilder.prefix(prefix).build();\n+            listObjectsV2Response = s3Client.listObjectsV2(listObjectsV2Request);\n+        }\n+        for (S3Object s3Object : listObjectsV2Response.contents()) {\n+            if (s3Object.key().equals(prefix)) {\n+                continue;\n+            } else {\n+                isEmpty = false;\n+                break;\n+            }\n+        }\n+        return isEmpty;\n+    }\n+\n+    private boolean copyFile(URI srcUri, URI dstUri) throws IOException {\n+        try {\n+            String encodedUrl = null;\n+            try {\n+                encodedUrl = URLEncoder.encode(srcUri.getHost() + srcUri.getPath(), StandardCharsets.UTF_8.toString());\n+            } catch (UnsupportedEncodingException e) {\n+                LOGGER.info(\"URL could not be encoded: {}\", e.getMessage());", "originalCommit": "4a55cc4ceef627cf87d4ce344435ded19f249b49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MTUxMw==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r409271513", "bodyText": "nit: listObjectsV2Response = s3Client.listObjectsV2(listObjectsV2Request); seems repetitive in both blocks. Move it below if-else.", "author": "haibow", "createdAt": "2020-04-16T04:17:01Z", "path": "pinot-plugins/pinot-file-system/pinot-s3/src/main/java/org/apache/pinot/plugin/filesystem/S3PinotFS.java", "diffHunk": "@@ -0,0 +1,485 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.plugin.filesystem;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.pinot.spi.filesystem.PinotFS;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.EnvironmentVariableCredentialsProvider;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.core.ResponseBytes;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.exception.SdkServiceException;\n+import software.amazon.awssdk.core.sync.RequestBody;\n+import software.amazon.awssdk.core.sync.ResponseTransformer;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.s3.S3Client;\n+import software.amazon.awssdk.services.s3.internal.resource.S3BucketResource;\n+import software.amazon.awssdk.services.s3.model.*;\n+\n+import java.io.*;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+import static joptsimple.internal.Strings.isNullOrEmpty;\n+import static org.glassfish.jersey.internal.guava.Preconditions.checkArgument;\n+\n+public class S3PinotFS extends PinotFS {\n+    public static final String ACCESS_KEY = \"accessKey\";\n+    public static final String SECRET_KEY = \"secretKey\";\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(S3PinotFS.class);\n+    private static final String DELIMITER = \"/\";\n+    private S3Client s3Client;\n+\n+    @Override\n+    public void init(Configuration config) {\n+        checkArgument(!isNullOrEmpty(config.getString(ACCESS_KEY)));\n+        checkArgument(!isNullOrEmpty(config.getString(SECRET_KEY)));\n+        String accessKey = config.getString(ACCESS_KEY);\n+        String secretKey = config.getString(SECRET_KEY);\n+        try {\n+            AwsBasicCredentials awsBasicCredentials = AwsBasicCredentials.create(accessKey, secretKey);\n+            s3Client = S3Client.builder()\n+                    .region(Region.AP_SOUTHEAST_1)\n+                    .credentialsProvider(StaticCredentialsProvider.create(awsBasicCredentials))\n+                    .build();\n+\n+        } catch (S3Exception e) {\n+            throw new RuntimeException(\"Could not initialize S3PinotFS\", e);\n+        }\n+    }\n+\n+    private HeadObjectResponse getS3ObjectMetadata(URI uri) throws IOException {\n+            URI base = getBase(uri);\n+            String path = sanitizePath(base.relativize(uri).getPath());\n+            HeadObjectRequest headObjectRequest = HeadObjectRequest.builder()\n+                    .bucket(uri.getHost())\n+                    .key(path)\n+                    .build();\n+\n+            return s3Client.headObject(headObjectRequest);\n+    }\n+\n+    private boolean isPathTerminatedByDelimiter(URI uri) {\n+        return uri.getPath().endsWith(DELIMITER);\n+    }\n+\n+    private String normalizeToDirectoryPrefix(URI uri) throws IOException {\n+        requireNonNull(uri, \"uri is null\");\n+        URI strippedUri = getBase(uri).relativize(uri);\n+        if (isPathTerminatedByDelimiter(strippedUri)) {\n+            return sanitizePath(strippedUri.getPath());\n+        }\n+        return sanitizePath(strippedUri.getPath() + DELIMITER);\n+    }\n+\n+    private URI normalizeToDirectoryUri(URI uri) throws IOException {\n+        if (isPathTerminatedByDelimiter(uri)) {\n+            return uri;\n+        }\n+        try {\n+            return new URI(uri.getScheme(), uri.getHost(), sanitizePath(uri.getPath() + DELIMITER), null);\n+        } catch (URISyntaxException e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    private String sanitizePath(String path) {\n+        path = path.replaceAll(DELIMITER + \"+\", DELIMITER);\n+        if (path.startsWith(DELIMITER) && !path.equals(DELIMITER)) {\n+            path = path.substring(1);\n+        }\n+        return path;\n+    }\n+\n+    private URI getBase(URI uri) throws IOException {\n+        try {\n+            return new URI(uri.getScheme(), uri.getHost(), null, null);\n+        } catch (URISyntaxException e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    private boolean existsFile(URI uri) throws IOException {\n+        try {\n+            URI base = getBase(uri);\n+            String path = sanitizePath(base.relativize(uri).getPath());\n+            HeadObjectRequest headObjectRequest = HeadObjectRequest.builder()\n+                    .bucket(uri.getHost())\n+                    .key(path)\n+                    .build();\n+\n+            s3Client.headObject(headObjectRequest);\n+            return true;\n+        }catch(NoSuchKeyException e){\n+            return false;\n+        }catch(S3Exception e){\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    private boolean isEmptyDirectory(URI uri) throws IOException {\n+        if (!isDirectory(uri)) {\n+            return false;\n+        }\n+        String prefix = normalizeToDirectoryPrefix(uri);\n+        boolean isEmpty = true;\n+        ListObjectsV2Response listObjectsV2Response;\n+        ListObjectsV2Request.Builder listObjectsV2RequestBuilder = ListObjectsV2Request.builder()\n+                .bucket(uri.getHost());\n+\n+        if (prefix.equals(DELIMITER)) {\n+            ListObjectsV2Request listObjectsV2Request = listObjectsV2RequestBuilder.build();\n+            listObjectsV2Response = s3Client.listObjectsV2(listObjectsV2Request);\n+        } else {\n+            ListObjectsV2Request listObjectsV2Request = listObjectsV2RequestBuilder.prefix(prefix).build();\n+            listObjectsV2Response = s3Client.listObjectsV2(listObjectsV2Request);\n+        }\n+        for (S3Object s3Object : listObjectsV2Response.contents()) {\n+            if (s3Object.key().equals(prefix)) {\n+                continue;\n+            } else {\n+                isEmpty = false;\n+                break;\n+            }\n+        }\n+        return isEmpty;\n+    }\n+\n+    private boolean copyFile(URI srcUri, URI dstUri) throws IOException {\n+        try {\n+            String encodedUrl = null;\n+            try {\n+                encodedUrl = URLEncoder.encode(srcUri.getHost() + srcUri.getPath(), StandardCharsets.UTF_8.toString());\n+            } catch (UnsupportedEncodingException e) {\n+                LOGGER.info(\"URL could not be encoded: {}\", e.getMessage());\n+            }\n+\n+            String dstPath = sanitizePath(dstUri.getPath());\n+            CopyObjectRequest copyReq = CopyObjectRequest.builder()\n+                    .copySource(encodedUrl)\n+                    .destinationBucket(dstUri.getHost())\n+                    .destinationKey(dstPath)\n+                    .build();\n+\n+            CopyObjectResponse copyObjectResponse = s3Client.copyObject(copyReq);\n+            return copyObjectResponse.sdkHttpResponse().isSuccessful();\n+        }catch(S3Exception e){\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean mkdir(URI uri) throws IOException {\n+        LOGGER.info(\"mkdir {}\", uri);\n+        try {\n+            requireNonNull(uri, \"uri is null\");\n+            String path = normalizeToDirectoryPrefix(uri);\n+            // Bucket root directory already exists and cannot be created\n+            if (path.equals(DELIMITER)) {\n+                return true;\n+            }\n+\n+            PutObjectRequest putObjectRequest = PutObjectRequest.builder()\n+                    .bucket(uri.getHost())\n+                    .key(path)\n+                    .build();\n+\n+            PutObjectResponse putObjectResponse = s3Client.putObject(putObjectRequest, RequestBody.fromBytes(new byte[0]));\n+\n+            return putObjectResponse.sdkHttpResponse().isSuccessful();\n+        } catch (Throwable t) {\n+            throw new IOException(t);\n+        }\n+    }\n+\n+    @Override\n+    public boolean delete(URI segmentUri, boolean forceDelete) throws IOException {\n+        LOGGER.info(\"Deleting uri {} force {}\", segmentUri, forceDelete);\n+        try {\n+            if (isDirectory(segmentUri)) {\n+                if (!forceDelete) {\n+                    checkState(isEmptyDirectory(segmentUri), \"ForceDelete flag is not set and directory '%s' is not empty\", segmentUri);\n+                }\n+                String prefix = normalizeToDirectoryPrefix(segmentUri);\n+                ListObjectsV2Response listObjectsV2Response;\n+                ListObjectsV2Request.Builder listObjectsV2RequestBuilder = ListObjectsV2Request.builder()\n+                        .bucket(segmentUri.getHost());\n+\n+                if (prefix.equals(DELIMITER)) {\n+                    ListObjectsV2Request listObjectsV2Request = listObjectsV2RequestBuilder.build();\n+                    listObjectsV2Response = s3Client.listObjectsV2(listObjectsV2Request);\n+                } else {\n+                    ListObjectsV2Request listObjectsV2Request = listObjectsV2RequestBuilder.prefix(prefix).build();\n+                    listObjectsV2Response = s3Client.listObjectsV2(listObjectsV2Request);", "originalCommit": "4a55cc4ceef627cf87d4ce344435ded19f249b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0MjU1Ng==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r412442556", "bodyText": "done", "author": "KKcorps", "createdAt": "2020-04-21T19:45:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MTUxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MTcyNg==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r409271726", "bodyText": "nit: move this repetitive line outside if-else blocks.", "author": "haibow", "createdAt": "2020-04-16T04:17:59Z", "path": "pinot-plugins/pinot-file-system/pinot-s3/src/main/java/org/apache/pinot/plugin/filesystem/S3PinotFS.java", "diffHunk": "@@ -0,0 +1,485 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.plugin.filesystem;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.pinot.spi.filesystem.PinotFS;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.EnvironmentVariableCredentialsProvider;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.core.ResponseBytes;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.exception.SdkServiceException;\n+import software.amazon.awssdk.core.sync.RequestBody;\n+import software.amazon.awssdk.core.sync.ResponseTransformer;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.s3.S3Client;\n+import software.amazon.awssdk.services.s3.internal.resource.S3BucketResource;\n+import software.amazon.awssdk.services.s3.model.*;\n+\n+import java.io.*;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+import static joptsimple.internal.Strings.isNullOrEmpty;\n+import static org.glassfish.jersey.internal.guava.Preconditions.checkArgument;\n+\n+public class S3PinotFS extends PinotFS {\n+    public static final String ACCESS_KEY = \"accessKey\";\n+    public static final String SECRET_KEY = \"secretKey\";\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(S3PinotFS.class);\n+    private static final String DELIMITER = \"/\";\n+    private S3Client s3Client;\n+\n+    @Override\n+    public void init(Configuration config) {\n+        checkArgument(!isNullOrEmpty(config.getString(ACCESS_KEY)));\n+        checkArgument(!isNullOrEmpty(config.getString(SECRET_KEY)));\n+        String accessKey = config.getString(ACCESS_KEY);\n+        String secretKey = config.getString(SECRET_KEY);\n+        try {\n+            AwsBasicCredentials awsBasicCredentials = AwsBasicCredentials.create(accessKey, secretKey);\n+            s3Client = S3Client.builder()\n+                    .region(Region.AP_SOUTHEAST_1)\n+                    .credentialsProvider(StaticCredentialsProvider.create(awsBasicCredentials))\n+                    .build();\n+\n+        } catch (S3Exception e) {\n+            throw new RuntimeException(\"Could not initialize S3PinotFS\", e);\n+        }\n+    }\n+\n+    private HeadObjectResponse getS3ObjectMetadata(URI uri) throws IOException {\n+            URI base = getBase(uri);\n+            String path = sanitizePath(base.relativize(uri).getPath());\n+            HeadObjectRequest headObjectRequest = HeadObjectRequest.builder()\n+                    .bucket(uri.getHost())\n+                    .key(path)\n+                    .build();\n+\n+            return s3Client.headObject(headObjectRequest);\n+    }\n+\n+    private boolean isPathTerminatedByDelimiter(URI uri) {\n+        return uri.getPath().endsWith(DELIMITER);\n+    }\n+\n+    private String normalizeToDirectoryPrefix(URI uri) throws IOException {\n+        requireNonNull(uri, \"uri is null\");\n+        URI strippedUri = getBase(uri).relativize(uri);\n+        if (isPathTerminatedByDelimiter(strippedUri)) {\n+            return sanitizePath(strippedUri.getPath());\n+        }\n+        return sanitizePath(strippedUri.getPath() + DELIMITER);\n+    }\n+\n+    private URI normalizeToDirectoryUri(URI uri) throws IOException {\n+        if (isPathTerminatedByDelimiter(uri)) {\n+            return uri;\n+        }\n+        try {\n+            return new URI(uri.getScheme(), uri.getHost(), sanitizePath(uri.getPath() + DELIMITER), null);\n+        } catch (URISyntaxException e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    private String sanitizePath(String path) {\n+        path = path.replaceAll(DELIMITER + \"+\", DELIMITER);\n+        if (path.startsWith(DELIMITER) && !path.equals(DELIMITER)) {\n+            path = path.substring(1);\n+        }\n+        return path;\n+    }\n+\n+    private URI getBase(URI uri) throws IOException {\n+        try {\n+            return new URI(uri.getScheme(), uri.getHost(), null, null);\n+        } catch (URISyntaxException e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    private boolean existsFile(URI uri) throws IOException {\n+        try {\n+            URI base = getBase(uri);\n+            String path = sanitizePath(base.relativize(uri).getPath());\n+            HeadObjectRequest headObjectRequest = HeadObjectRequest.builder()\n+                    .bucket(uri.getHost())\n+                    .key(path)\n+                    .build();\n+\n+            s3Client.headObject(headObjectRequest);\n+            return true;\n+        }catch(NoSuchKeyException e){\n+            return false;\n+        }catch(S3Exception e){\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    private boolean isEmptyDirectory(URI uri) throws IOException {\n+        if (!isDirectory(uri)) {\n+            return false;\n+        }\n+        String prefix = normalizeToDirectoryPrefix(uri);\n+        boolean isEmpty = true;\n+        ListObjectsV2Response listObjectsV2Response;\n+        ListObjectsV2Request.Builder listObjectsV2RequestBuilder = ListObjectsV2Request.builder()\n+                .bucket(uri.getHost());\n+\n+        if (prefix.equals(DELIMITER)) {\n+            ListObjectsV2Request listObjectsV2Request = listObjectsV2RequestBuilder.build();\n+            listObjectsV2Response = s3Client.listObjectsV2(listObjectsV2Request);\n+        } else {\n+            ListObjectsV2Request listObjectsV2Request = listObjectsV2RequestBuilder.prefix(prefix).build();\n+            listObjectsV2Response = s3Client.listObjectsV2(listObjectsV2Request);\n+        }\n+        for (S3Object s3Object : listObjectsV2Response.contents()) {\n+            if (s3Object.key().equals(prefix)) {\n+                continue;\n+            } else {\n+                isEmpty = false;\n+                break;\n+            }\n+        }\n+        return isEmpty;\n+    }\n+\n+    private boolean copyFile(URI srcUri, URI dstUri) throws IOException {\n+        try {\n+            String encodedUrl = null;\n+            try {\n+                encodedUrl = URLEncoder.encode(srcUri.getHost() + srcUri.getPath(), StandardCharsets.UTF_8.toString());\n+            } catch (UnsupportedEncodingException e) {\n+                LOGGER.info(\"URL could not be encoded: {}\", e.getMessage());\n+            }\n+\n+            String dstPath = sanitizePath(dstUri.getPath());\n+            CopyObjectRequest copyReq = CopyObjectRequest.builder()\n+                    .copySource(encodedUrl)\n+                    .destinationBucket(dstUri.getHost())\n+                    .destinationKey(dstPath)\n+                    .build();\n+\n+            CopyObjectResponse copyObjectResponse = s3Client.copyObject(copyReq);\n+            return copyObjectResponse.sdkHttpResponse().isSuccessful();\n+        }catch(S3Exception e){\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean mkdir(URI uri) throws IOException {\n+        LOGGER.info(\"mkdir {}\", uri);\n+        try {\n+            requireNonNull(uri, \"uri is null\");\n+            String path = normalizeToDirectoryPrefix(uri);\n+            // Bucket root directory already exists and cannot be created\n+            if (path.equals(DELIMITER)) {\n+                return true;\n+            }\n+\n+            PutObjectRequest putObjectRequest = PutObjectRequest.builder()\n+                    .bucket(uri.getHost())\n+                    .key(path)\n+                    .build();\n+\n+            PutObjectResponse putObjectResponse = s3Client.putObject(putObjectRequest, RequestBody.fromBytes(new byte[0]));\n+\n+            return putObjectResponse.sdkHttpResponse().isSuccessful();\n+        } catch (Throwable t) {\n+            throw new IOException(t);\n+        }\n+    }\n+\n+    @Override\n+    public boolean delete(URI segmentUri, boolean forceDelete) throws IOException {\n+        LOGGER.info(\"Deleting uri {} force {}\", segmentUri, forceDelete);\n+        try {\n+            if (isDirectory(segmentUri)) {\n+                if (!forceDelete) {\n+                    checkState(isEmptyDirectory(segmentUri), \"ForceDelete flag is not set and directory '%s' is not empty\", segmentUri);\n+                }\n+                String prefix = normalizeToDirectoryPrefix(segmentUri);\n+                ListObjectsV2Response listObjectsV2Response;\n+                ListObjectsV2Request.Builder listObjectsV2RequestBuilder = ListObjectsV2Request.builder()\n+                        .bucket(segmentUri.getHost());\n+\n+                if (prefix.equals(DELIMITER)) {\n+                    ListObjectsV2Request listObjectsV2Request = listObjectsV2RequestBuilder.build();\n+                    listObjectsV2Response = s3Client.listObjectsV2(listObjectsV2Request);\n+                } else {\n+                    ListObjectsV2Request listObjectsV2Request = listObjectsV2RequestBuilder.prefix(prefix).build();\n+                    listObjectsV2Response = s3Client.listObjectsV2(listObjectsV2Request);\n+                }\n+                boolean deleteSucceeded = true;\n+                for (S3Object s3Object : listObjectsV2Response.contents()) {\n+                    DeleteObjectRequest deleteObjectRequest = DeleteObjectRequest.builder()\n+                            .bucket(segmentUri.getHost())\n+                            .key(s3Object.key())\n+                            .build();\n+\n+                    DeleteObjectResponse deleteObjectResponse = s3Client.deleteObject(deleteObjectRequest);\n+\n+                    deleteSucceeded &= deleteObjectResponse.sdkHttpResponse().isSuccessful();\n+                }\n+                return deleteSucceeded;\n+            } else {\n+                String prefix = sanitizePath(segmentUri.getPath());\n+                DeleteObjectRequest deleteObjectRequest = DeleteObjectRequest.builder()\n+                        .bucket(segmentUri.getHost())\n+                        .key(prefix)\n+                        .build();\n+\n+                DeleteObjectResponse deleteObjectResponse = s3Client.deleteObject(deleteObjectRequest);\n+\n+                return deleteObjectResponse.sdkHttpResponse().isSuccessful();\n+            }\n+        }catch(NoSuchKeyException e){\n+            return false;\n+        } catch (S3Exception e) {\n+            throw e;\n+        } catch(Throwable t) {\n+            throw new IOException(t);\n+        }\n+    }\n+\n+    @Override\n+    public boolean doMove(URI srcUri, URI dstUri) throws IOException {\n+        if (copy(srcUri, dstUri)) {\n+            return  delete(srcUri, true);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean copy(URI srcUri, URI dstUri) throws IOException {\n+        LOGGER.info(\"Copying uri {} to uri {}\", srcUri, dstUri);\n+        checkState(exists(srcUri), \"Source URI '%s' does not exist\", srcUri);\n+        if (srcUri.equals(dstUri)) {\n+            return true;\n+        }\n+        if (!isDirectory(srcUri)) {\n+            delete(dstUri, true);\n+            return copyFile(srcUri, dstUri);\n+        }\n+        dstUri = normalizeToDirectoryUri(dstUri);\n+        ImmutableList.Builder<URI> builder = ImmutableList.builder();\n+        Path srcPath = Paths.get(srcUri.getPath());\n+        try {\n+            boolean copySucceeded = true;\n+            for (String directoryEntry : listFiles(srcUri, true)) {\n+                URI src = new URI(srcUri.getScheme(), srcUri.getHost(), directoryEntry, null);\n+                String relativeSrcPath = srcPath.relativize(Paths.get(directoryEntry)).toString();\n+                String dstPath = dstUri.resolve(relativeSrcPath).getPath();\n+                URI dst = new URI(dstUri.getScheme(), dstUri.getHost(), dstPath, null);\n+                copySucceeded &= copyFile(src, dst);\n+            }\n+            return copySucceeded;\n+        } catch (URISyntaxException e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean exists(URI fileUri) throws IOException {\n+        try {\n+            if (isDirectory(fileUri)) {\n+                return true;\n+            }\n+            if (isPathTerminatedByDelimiter(fileUri)) {\n+                return false;\n+            }\n+            return existsFile(fileUri);\n+        }catch(NoSuchKeyException e){\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public long length(URI fileUri) throws IOException {\n+        try {\n+            checkState(!isPathTerminatedByDelimiter(fileUri), \"URI is a directory\");\n+            HeadObjectResponse s3ObjectMetadata = getS3ObjectMetadata(fileUri);\n+            checkState((s3ObjectMetadata != null), \"File '%s' does not exist\", fileUri);\n+            if(s3ObjectMetadata.contentLength() == null){\n+                return 0;\n+            }\n+            return s3ObjectMetadata.contentLength();\n+        } catch (Throwable t) {\n+            throw new IOException(t);\n+        }\n+    }\n+\n+    @Override\n+    public String[] listFiles(URI fileUri, boolean recursive) throws IOException {\n+        try {\n+            ImmutableList.Builder<String> builder = ImmutableList.builder();\n+            String prefix = normalizeToDirectoryPrefix(fileUri);\n+            ListObjectsV2Response listObjectsV2Response;\n+            ListObjectsV2Request.Builder listObjectsV2RequestBuilder = ListObjectsV2Request.builder()\n+                    .bucket(fileUri.getHost())\n+                    .prefix(prefix);\n+\n+            if (recursive) {\n+                ListObjectsV2Request listObjectsV2Request = listObjectsV2RequestBuilder.build();\n+                listObjectsV2Response = s3Client.listObjectsV2(listObjectsV2Request);\n+            } else {\n+                ListObjectsV2Request listObjectsV2Request = listObjectsV2RequestBuilder.delimiter(DELIMITER).build();\n+                listObjectsV2Response = s3Client.listObjectsV2(listObjectsV2Request);", "originalCommit": "4a55cc4ceef627cf87d4ce344435ded19f249b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0MjQ4OQ==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r412442489", "bodyText": "done", "author": "KKcorps", "createdAt": "2020-04-21T19:45:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MTcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MTgyOA==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r409271828", "bodyText": "remove System.out.println", "author": "haibow", "createdAt": "2020-04-16T04:18:25Z", "path": "pinot-plugins/pinot-file-system/pinot-s3/src/main/java/org/apache/pinot/plugin/filesystem/S3PinotFS.java", "diffHunk": "@@ -0,0 +1,485 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.plugin.filesystem;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.pinot.spi.filesystem.PinotFS;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.EnvironmentVariableCredentialsProvider;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.core.ResponseBytes;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.exception.SdkServiceException;\n+import software.amazon.awssdk.core.sync.RequestBody;\n+import software.amazon.awssdk.core.sync.ResponseTransformer;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.s3.S3Client;\n+import software.amazon.awssdk.services.s3.internal.resource.S3BucketResource;\n+import software.amazon.awssdk.services.s3.model.*;\n+\n+import java.io.*;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+import static joptsimple.internal.Strings.isNullOrEmpty;\n+import static org.glassfish.jersey.internal.guava.Preconditions.checkArgument;\n+\n+public class S3PinotFS extends PinotFS {\n+    public static final String ACCESS_KEY = \"accessKey\";\n+    public static final String SECRET_KEY = \"secretKey\";\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(S3PinotFS.class);\n+    private static final String DELIMITER = \"/\";\n+    private S3Client s3Client;\n+\n+    @Override\n+    public void init(Configuration config) {\n+        checkArgument(!isNullOrEmpty(config.getString(ACCESS_KEY)));\n+        checkArgument(!isNullOrEmpty(config.getString(SECRET_KEY)));\n+        String accessKey = config.getString(ACCESS_KEY);\n+        String secretKey = config.getString(SECRET_KEY);\n+        try {\n+            AwsBasicCredentials awsBasicCredentials = AwsBasicCredentials.create(accessKey, secretKey);\n+            s3Client = S3Client.builder()\n+                    .region(Region.AP_SOUTHEAST_1)\n+                    .credentialsProvider(StaticCredentialsProvider.create(awsBasicCredentials))\n+                    .build();\n+\n+        } catch (S3Exception e) {\n+            throw new RuntimeException(\"Could not initialize S3PinotFS\", e);\n+        }\n+    }\n+\n+    private HeadObjectResponse getS3ObjectMetadata(URI uri) throws IOException {\n+            URI base = getBase(uri);\n+            String path = sanitizePath(base.relativize(uri).getPath());\n+            HeadObjectRequest headObjectRequest = HeadObjectRequest.builder()\n+                    .bucket(uri.getHost())\n+                    .key(path)\n+                    .build();\n+\n+            return s3Client.headObject(headObjectRequest);\n+    }\n+\n+    private boolean isPathTerminatedByDelimiter(URI uri) {\n+        return uri.getPath().endsWith(DELIMITER);\n+    }\n+\n+    private String normalizeToDirectoryPrefix(URI uri) throws IOException {\n+        requireNonNull(uri, \"uri is null\");\n+        URI strippedUri = getBase(uri).relativize(uri);\n+        if (isPathTerminatedByDelimiter(strippedUri)) {\n+            return sanitizePath(strippedUri.getPath());\n+        }\n+        return sanitizePath(strippedUri.getPath() + DELIMITER);\n+    }\n+\n+    private URI normalizeToDirectoryUri(URI uri) throws IOException {\n+        if (isPathTerminatedByDelimiter(uri)) {\n+            return uri;\n+        }\n+        try {\n+            return new URI(uri.getScheme(), uri.getHost(), sanitizePath(uri.getPath() + DELIMITER), null);\n+        } catch (URISyntaxException e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    private String sanitizePath(String path) {\n+        path = path.replaceAll(DELIMITER + \"+\", DELIMITER);\n+        if (path.startsWith(DELIMITER) && !path.equals(DELIMITER)) {\n+            path = path.substring(1);\n+        }\n+        return path;\n+    }\n+\n+    private URI getBase(URI uri) throws IOException {\n+        try {\n+            return new URI(uri.getScheme(), uri.getHost(), null, null);\n+        } catch (URISyntaxException e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    private boolean existsFile(URI uri) throws IOException {\n+        try {\n+            URI base = getBase(uri);\n+            String path = sanitizePath(base.relativize(uri).getPath());\n+            HeadObjectRequest headObjectRequest = HeadObjectRequest.builder()\n+                    .bucket(uri.getHost())\n+                    .key(path)\n+                    .build();\n+\n+            s3Client.headObject(headObjectRequest);\n+            return true;\n+        }catch(NoSuchKeyException e){\n+            return false;\n+        }catch(S3Exception e){\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    private boolean isEmptyDirectory(URI uri) throws IOException {\n+        if (!isDirectory(uri)) {\n+            return false;\n+        }\n+        String prefix = normalizeToDirectoryPrefix(uri);\n+        boolean isEmpty = true;\n+        ListObjectsV2Response listObjectsV2Response;\n+        ListObjectsV2Request.Builder listObjectsV2RequestBuilder = ListObjectsV2Request.builder()\n+                .bucket(uri.getHost());\n+\n+        if (prefix.equals(DELIMITER)) {\n+            ListObjectsV2Request listObjectsV2Request = listObjectsV2RequestBuilder.build();\n+            listObjectsV2Response = s3Client.listObjectsV2(listObjectsV2Request);\n+        } else {\n+            ListObjectsV2Request listObjectsV2Request = listObjectsV2RequestBuilder.prefix(prefix).build();\n+            listObjectsV2Response = s3Client.listObjectsV2(listObjectsV2Request);\n+        }\n+        for (S3Object s3Object : listObjectsV2Response.contents()) {\n+            if (s3Object.key().equals(prefix)) {\n+                continue;\n+            } else {\n+                isEmpty = false;\n+                break;\n+            }\n+        }\n+        return isEmpty;\n+    }\n+\n+    private boolean copyFile(URI srcUri, URI dstUri) throws IOException {\n+        try {\n+            String encodedUrl = null;\n+            try {\n+                encodedUrl = URLEncoder.encode(srcUri.getHost() + srcUri.getPath(), StandardCharsets.UTF_8.toString());\n+            } catch (UnsupportedEncodingException e) {\n+                LOGGER.info(\"URL could not be encoded: {}\", e.getMessage());\n+            }\n+\n+            String dstPath = sanitizePath(dstUri.getPath());\n+            CopyObjectRequest copyReq = CopyObjectRequest.builder()\n+                    .copySource(encodedUrl)\n+                    .destinationBucket(dstUri.getHost())\n+                    .destinationKey(dstPath)\n+                    .build();\n+\n+            CopyObjectResponse copyObjectResponse = s3Client.copyObject(copyReq);\n+            return copyObjectResponse.sdkHttpResponse().isSuccessful();\n+        }catch(S3Exception e){\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean mkdir(URI uri) throws IOException {\n+        LOGGER.info(\"mkdir {}\", uri);\n+        try {\n+            requireNonNull(uri, \"uri is null\");\n+            String path = normalizeToDirectoryPrefix(uri);\n+            // Bucket root directory already exists and cannot be created\n+            if (path.equals(DELIMITER)) {\n+                return true;\n+            }\n+\n+            PutObjectRequest putObjectRequest = PutObjectRequest.builder()\n+                    .bucket(uri.getHost())\n+                    .key(path)\n+                    .build();\n+\n+            PutObjectResponse putObjectResponse = s3Client.putObject(putObjectRequest, RequestBody.fromBytes(new byte[0]));\n+\n+            return putObjectResponse.sdkHttpResponse().isSuccessful();\n+        } catch (Throwable t) {\n+            throw new IOException(t);\n+        }\n+    }\n+\n+    @Override\n+    public boolean delete(URI segmentUri, boolean forceDelete) throws IOException {\n+        LOGGER.info(\"Deleting uri {} force {}\", segmentUri, forceDelete);\n+        try {\n+            if (isDirectory(segmentUri)) {\n+                if (!forceDelete) {\n+                    checkState(isEmptyDirectory(segmentUri), \"ForceDelete flag is not set and directory '%s' is not empty\", segmentUri);\n+                }\n+                String prefix = normalizeToDirectoryPrefix(segmentUri);\n+                ListObjectsV2Response listObjectsV2Response;\n+                ListObjectsV2Request.Builder listObjectsV2RequestBuilder = ListObjectsV2Request.builder()\n+                        .bucket(segmentUri.getHost());\n+\n+                if (prefix.equals(DELIMITER)) {\n+                    ListObjectsV2Request listObjectsV2Request = listObjectsV2RequestBuilder.build();\n+                    listObjectsV2Response = s3Client.listObjectsV2(listObjectsV2Request);\n+                } else {\n+                    ListObjectsV2Request listObjectsV2Request = listObjectsV2RequestBuilder.prefix(prefix).build();\n+                    listObjectsV2Response = s3Client.listObjectsV2(listObjectsV2Request);\n+                }\n+                boolean deleteSucceeded = true;\n+                for (S3Object s3Object : listObjectsV2Response.contents()) {\n+                    DeleteObjectRequest deleteObjectRequest = DeleteObjectRequest.builder()\n+                            .bucket(segmentUri.getHost())\n+                            .key(s3Object.key())\n+                            .build();\n+\n+                    DeleteObjectResponse deleteObjectResponse = s3Client.deleteObject(deleteObjectRequest);\n+\n+                    deleteSucceeded &= deleteObjectResponse.sdkHttpResponse().isSuccessful();\n+                }\n+                return deleteSucceeded;\n+            } else {\n+                String prefix = sanitizePath(segmentUri.getPath());\n+                DeleteObjectRequest deleteObjectRequest = DeleteObjectRequest.builder()\n+                        .bucket(segmentUri.getHost())\n+                        .key(prefix)\n+                        .build();\n+\n+                DeleteObjectResponse deleteObjectResponse = s3Client.deleteObject(deleteObjectRequest);\n+\n+                return deleteObjectResponse.sdkHttpResponse().isSuccessful();\n+            }\n+        }catch(NoSuchKeyException e){\n+            return false;\n+        } catch (S3Exception e) {\n+            throw e;\n+        } catch(Throwable t) {\n+            throw new IOException(t);\n+        }\n+    }\n+\n+    @Override\n+    public boolean doMove(URI srcUri, URI dstUri) throws IOException {\n+        if (copy(srcUri, dstUri)) {\n+            return  delete(srcUri, true);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean copy(URI srcUri, URI dstUri) throws IOException {\n+        LOGGER.info(\"Copying uri {} to uri {}\", srcUri, dstUri);\n+        checkState(exists(srcUri), \"Source URI '%s' does not exist\", srcUri);\n+        if (srcUri.equals(dstUri)) {\n+            return true;\n+        }\n+        if (!isDirectory(srcUri)) {\n+            delete(dstUri, true);\n+            return copyFile(srcUri, dstUri);\n+        }\n+        dstUri = normalizeToDirectoryUri(dstUri);\n+        ImmutableList.Builder<URI> builder = ImmutableList.builder();\n+        Path srcPath = Paths.get(srcUri.getPath());\n+        try {\n+            boolean copySucceeded = true;\n+            for (String directoryEntry : listFiles(srcUri, true)) {\n+                URI src = new URI(srcUri.getScheme(), srcUri.getHost(), directoryEntry, null);\n+                String relativeSrcPath = srcPath.relativize(Paths.get(directoryEntry)).toString();\n+                String dstPath = dstUri.resolve(relativeSrcPath).getPath();\n+                URI dst = new URI(dstUri.getScheme(), dstUri.getHost(), dstPath, null);\n+                copySucceeded &= copyFile(src, dst);\n+            }\n+            return copySucceeded;\n+        } catch (URISyntaxException e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean exists(URI fileUri) throws IOException {\n+        try {\n+            if (isDirectory(fileUri)) {\n+                return true;\n+            }\n+            if (isPathTerminatedByDelimiter(fileUri)) {\n+                return false;\n+            }\n+            return existsFile(fileUri);\n+        }catch(NoSuchKeyException e){\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public long length(URI fileUri) throws IOException {\n+        try {\n+            checkState(!isPathTerminatedByDelimiter(fileUri), \"URI is a directory\");\n+            HeadObjectResponse s3ObjectMetadata = getS3ObjectMetadata(fileUri);\n+            checkState((s3ObjectMetadata != null), \"File '%s' does not exist\", fileUri);\n+            if(s3ObjectMetadata.contentLength() == null){\n+                return 0;\n+            }\n+            return s3ObjectMetadata.contentLength();\n+        } catch (Throwable t) {\n+            throw new IOException(t);\n+        }\n+    }\n+\n+    @Override\n+    public String[] listFiles(URI fileUri, boolean recursive) throws IOException {\n+        try {\n+            ImmutableList.Builder<String> builder = ImmutableList.builder();\n+            String prefix = normalizeToDirectoryPrefix(fileUri);\n+            ListObjectsV2Response listObjectsV2Response;\n+            ListObjectsV2Request.Builder listObjectsV2RequestBuilder = ListObjectsV2Request.builder()\n+                    .bucket(fileUri.getHost())\n+                    .prefix(prefix);\n+\n+            if (recursive) {\n+                ListObjectsV2Request listObjectsV2Request = listObjectsV2RequestBuilder.build();\n+                listObjectsV2Response = s3Client.listObjectsV2(listObjectsV2Request);\n+            } else {\n+                ListObjectsV2Request listObjectsV2Request = listObjectsV2RequestBuilder.delimiter(DELIMITER).build();\n+                listObjectsV2Response = s3Client.listObjectsV2(listObjectsV2Request);\n+            }\n+\n+            listObjectsV2Response.contents().stream()\n+                    .forEach(object -> {\n+                        //Only add files and not directories\n+                        if (!object.key().equals(fileUri.getPath()) && !object.key().endsWith(DELIMITER)) {\n+                            builder.add(object.key());\n+                        }\n+                    });\n+            return builder.build().toArray(new String[0]);\n+        } catch (Throwable t) {\n+            throw new IOException(t);\n+        }\n+    }\n+\n+    @Override\n+    public void copyToLocalFile(URI srcUri, File dstFile) throws Exception {\n+        LOGGER.info(\"Copy {} to local {}\", srcUri, dstFile.getAbsolutePath());\n+        URI base = getBase(srcUri);\n+        String prefix = sanitizePath(base.relativize(srcUri).getPath());\n+        GetObjectRequest getObjectRequest = GetObjectRequest.builder()\n+                .bucket(srcUri.getHost())\n+                .key(prefix)\n+                .build();\n+\n+        s3Client.getObject(getObjectRequest, ResponseTransformer.toFile(dstFile));\n+    }\n+\n+    @Override\n+    public void copyFromLocalFile(File srcFile, URI dstUri) throws Exception {\n+        LOGGER.info(\"Copy {} from local to {}\", srcFile.getAbsolutePath(), dstUri);\n+        URI base = getBase(dstUri);\n+        String prefix = sanitizePath(base.relativize(dstUri).getPath());\n+        PutObjectRequest putObjectRequest = PutObjectRequest.builder()\n+                .bucket(dstUri.getHost())\n+                .key(prefix)\n+                .build();\n+\n+        PutObjectResponse putObjectResponse = s3Client.putObject(putObjectRequest, srcFile.toPath());\n+    }\n+\n+    @Override\n+    public boolean isDirectory(URI uri){\n+        try{\n+            String prefix = sanitizePath(uri.getPath());\n+            if (prefix.equals(DELIMITER)) {\n+                return true;\n+            }\n+            HeadObjectResponse s3ObjectMetadata;\n+            HeadObjectRequest headObjectRequest = HeadObjectRequest.builder()\n+                    .bucket(uri.getHost())\n+                    .key(prefix)\n+                    .build();\n+            s3ObjectMetadata = s3Client.headObject(headObjectRequest);\n+            return s3ObjectMetadata.contentType().contentEquals(\"application/x-directory\");\n+        }catch(NoSuchKeyException e){\n+            LOGGER.error(\"Could not get directory entry for {}\", uri);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public long lastModified(URI uri) throws IOException {\n+        return getS3ObjectMetadata(uri).lastModified().toEpochMilli();\n+    }\n+\n+    @Override\n+    public boolean touch(URI uri) throws IOException {\n+        try {\n+                HeadObjectResponse s3ObjectMetadata = getS3ObjectMetadata(uri);\n+                String encodedUrl = null;\n+                try {\n+                    encodedUrl = URLEncoder.encode(uri.getHost() + uri.getPath(), StandardCharsets.UTF_8.toString());\n+                } catch (UnsupportedEncodingException e) {\n+                    LOGGER.info(\"URL could not be encoded: {}\", e.getMessage());\n+                }\n+\n+                String path = sanitizePath(uri.getPath());\n+                Map<String, String> mp = new HashMap<>();\n+                mp.put(\"lastModified\", String.valueOf(System.currentTimeMillis()));\n+                CopyObjectRequest request = CopyObjectRequest.builder()\n+                        .copySource(encodedUrl)\n+                        .destinationBucket(uri.getHost())\n+                        .destinationKey(path)\n+                        .metadata(mp)\n+                        .metadataDirective(MetadataDirective.REPLACE)\n+                        .build();\n+\n+                System.out.println(\"COPY\");", "originalCommit": "4a55cc4ceef627cf87d4ce344435ded19f249b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0MjQ0Mw==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r412442443", "bodyText": "done", "author": "KKcorps", "createdAt": "2020-04-21T19:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MTgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI4MTE2MA==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r409281160", "bodyText": "expand .* imports", "author": "xiangfu0", "createdAt": "2020-04-16T04:54:56Z", "path": "pinot-plugins/pinot-file-system/pinot-s3/src/main/java/org/apache/pinot/plugin/filesystem/S3PinotFS.java", "diffHunk": "@@ -0,0 +1,485 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.plugin.filesystem;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.pinot.spi.filesystem.PinotFS;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.EnvironmentVariableCredentialsProvider;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.core.ResponseBytes;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.exception.SdkServiceException;\n+import software.amazon.awssdk.core.sync.RequestBody;\n+import software.amazon.awssdk.core.sync.ResponseTransformer;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.s3.S3Client;\n+import software.amazon.awssdk.services.s3.internal.resource.S3BucketResource;\n+import software.amazon.awssdk.services.s3.model.*;\n+\n+import java.io.*;", "originalCommit": "4a55cc4ceef627cf87d4ce344435ded19f249b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0MTY5Nw==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r412441697", "bodyText": "done", "author": "KKcorps", "createdAt": "2020-04-21T19:43:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI4MTE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI4MTc0Nw==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r409281747", "bodyText": "Can we also add the support of checking System properties and environment variable?\nThis is to allow more flexible way to config the application.\nAs usually in kubernetes environment, people may store these credential as a Secrets then import as Environment Variables.", "author": "xiangfu0", "createdAt": "2020-04-16T04:57:23Z", "path": "pinot-plugins/pinot-file-system/pinot-s3/src/main/java/org/apache/pinot/plugin/filesystem/S3PinotFS.java", "diffHunk": "@@ -0,0 +1,485 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.plugin.filesystem;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.pinot.spi.filesystem.PinotFS;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.EnvironmentVariableCredentialsProvider;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.core.ResponseBytes;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.exception.SdkServiceException;\n+import software.amazon.awssdk.core.sync.RequestBody;\n+import software.amazon.awssdk.core.sync.ResponseTransformer;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.s3.S3Client;\n+import software.amazon.awssdk.services.s3.internal.resource.S3BucketResource;\n+import software.amazon.awssdk.services.s3.model.*;\n+\n+import java.io.*;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+import static joptsimple.internal.Strings.isNullOrEmpty;\n+import static org.glassfish.jersey.internal.guava.Preconditions.checkArgument;\n+\n+public class S3PinotFS extends PinotFS {\n+    public static final String ACCESS_KEY = \"accessKey\";\n+    public static final String SECRET_KEY = \"secretKey\";\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(S3PinotFS.class);\n+    private static final String DELIMITER = \"/\";\n+    private S3Client s3Client;\n+\n+    @Override\n+    public void init(Configuration config) {\n+        checkArgument(!isNullOrEmpty(config.getString(ACCESS_KEY)));", "originalCommit": "4a55cc4ceef627cf87d4ce344435ded19f249b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU3MTU2Mw==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r409571563", "bodyText": "That makes sense. So should I create like levels of fallbacks i.e. first check Env, then System properties and finally the configuration given?", "author": "KKcorps", "createdAt": "2020-04-16T13:50:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI4MTc0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTczODUwNA==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r409738504", "bodyText": "yes, just the order should be reverse, if people specify the config, then we should always honor that. If configs are not existed, then we check system properties. if system properties doesn't exist, then we  check env var.\nAlso this needs to be documented :)\nThanks!", "author": "xiangfu0", "createdAt": "2020-04-16T17:46:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI4MTc0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc4NzQwNQ==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r409787405", "bodyText": "cool. Does it look good now?", "author": "KKcorps", "createdAt": "2020-04-16T19:10:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI4MTc0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0MTU5OQ==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r412441599", "bodyText": "done", "author": "KKcorps", "createdAt": "2020-04-21T19:43:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI4MTc0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI4MjAxMQ==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r409282011", "bodyText": "region should also be configurable.", "author": "xiangfu0", "createdAt": "2020-04-16T04:58:16Z", "path": "pinot-plugins/pinot-file-system/pinot-s3/src/main/java/org/apache/pinot/plugin/filesystem/S3PinotFS.java", "diffHunk": "@@ -0,0 +1,485 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.plugin.filesystem;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.pinot.spi.filesystem.PinotFS;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.EnvironmentVariableCredentialsProvider;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.core.ResponseBytes;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.exception.SdkServiceException;\n+import software.amazon.awssdk.core.sync.RequestBody;\n+import software.amazon.awssdk.core.sync.ResponseTransformer;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.s3.S3Client;\n+import software.amazon.awssdk.services.s3.internal.resource.S3BucketResource;\n+import software.amazon.awssdk.services.s3.model.*;\n+\n+import java.io.*;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+import static joptsimple.internal.Strings.isNullOrEmpty;\n+import static org.glassfish.jersey.internal.guava.Preconditions.checkArgument;\n+\n+public class S3PinotFS extends PinotFS {\n+    public static final String ACCESS_KEY = \"accessKey\";\n+    public static final String SECRET_KEY = \"secretKey\";\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(S3PinotFS.class);\n+    private static final String DELIMITER = \"/\";\n+    private S3Client s3Client;\n+\n+    @Override\n+    public void init(Configuration config) {\n+        checkArgument(!isNullOrEmpty(config.getString(ACCESS_KEY)));\n+        checkArgument(!isNullOrEmpty(config.getString(SECRET_KEY)));\n+        String accessKey = config.getString(ACCESS_KEY);\n+        String secretKey = config.getString(SECRET_KEY);\n+        try {\n+            AwsBasicCredentials awsBasicCredentials = AwsBasicCredentials.create(accessKey, secretKey);\n+            s3Client = S3Client.builder()\n+                    .region(Region.AP_SOUTHEAST_1)", "originalCommit": "4a55cc4ceef627cf87d4ce344435ded19f249b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0MTQ4OA==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r412441488", "bodyText": "done", "author": "KKcorps", "createdAt": "2020-04-21T19:43:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI4MjAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI4NDQ4MA==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r409284480", "bodyText": "Could you add a test to ensure this copy directory logic is correct?\nEspecially the relative path is correct.", "author": "xiangfu0", "createdAt": "2020-04-16T05:07:38Z", "path": "pinot-plugins/pinot-file-system/pinot-s3/src/main/java/org/apache/pinot/plugin/filesystem/S3PinotFS.java", "diffHunk": "@@ -0,0 +1,485 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.plugin.filesystem;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.pinot.spi.filesystem.PinotFS;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.EnvironmentVariableCredentialsProvider;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.core.ResponseBytes;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.exception.SdkServiceException;\n+import software.amazon.awssdk.core.sync.RequestBody;\n+import software.amazon.awssdk.core.sync.ResponseTransformer;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.s3.S3Client;\n+import software.amazon.awssdk.services.s3.internal.resource.S3BucketResource;\n+import software.amazon.awssdk.services.s3.model.*;\n+\n+import java.io.*;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+import static joptsimple.internal.Strings.isNullOrEmpty;\n+import static org.glassfish.jersey.internal.guava.Preconditions.checkArgument;\n+\n+public class S3PinotFS extends PinotFS {\n+    public static final String ACCESS_KEY = \"accessKey\";\n+    public static final String SECRET_KEY = \"secretKey\";\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(S3PinotFS.class);\n+    private static final String DELIMITER = \"/\";\n+    private S3Client s3Client;\n+\n+    @Override\n+    public void init(Configuration config) {\n+        checkArgument(!isNullOrEmpty(config.getString(ACCESS_KEY)));\n+        checkArgument(!isNullOrEmpty(config.getString(SECRET_KEY)));\n+        String accessKey = config.getString(ACCESS_KEY);\n+        String secretKey = config.getString(SECRET_KEY);\n+        try {\n+            AwsBasicCredentials awsBasicCredentials = AwsBasicCredentials.create(accessKey, secretKey);\n+            s3Client = S3Client.builder()\n+                    .region(Region.AP_SOUTHEAST_1)\n+                    .credentialsProvider(StaticCredentialsProvider.create(awsBasicCredentials))\n+                    .build();\n+\n+        } catch (S3Exception e) {\n+            throw new RuntimeException(\"Could not initialize S3PinotFS\", e);\n+        }\n+    }\n+\n+    private HeadObjectResponse getS3ObjectMetadata(URI uri) throws IOException {\n+            URI base = getBase(uri);\n+            String path = sanitizePath(base.relativize(uri).getPath());\n+            HeadObjectRequest headObjectRequest = HeadObjectRequest.builder()\n+                    .bucket(uri.getHost())\n+                    .key(path)\n+                    .build();\n+\n+            return s3Client.headObject(headObjectRequest);\n+    }\n+\n+    private boolean isPathTerminatedByDelimiter(URI uri) {\n+        return uri.getPath().endsWith(DELIMITER);\n+    }\n+\n+    private String normalizeToDirectoryPrefix(URI uri) throws IOException {\n+        requireNonNull(uri, \"uri is null\");\n+        URI strippedUri = getBase(uri).relativize(uri);\n+        if (isPathTerminatedByDelimiter(strippedUri)) {\n+            return sanitizePath(strippedUri.getPath());\n+        }\n+        return sanitizePath(strippedUri.getPath() + DELIMITER);\n+    }\n+\n+    private URI normalizeToDirectoryUri(URI uri) throws IOException {\n+        if (isPathTerminatedByDelimiter(uri)) {\n+            return uri;\n+        }\n+        try {\n+            return new URI(uri.getScheme(), uri.getHost(), sanitizePath(uri.getPath() + DELIMITER), null);\n+        } catch (URISyntaxException e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    private String sanitizePath(String path) {\n+        path = path.replaceAll(DELIMITER + \"+\", DELIMITER);\n+        if (path.startsWith(DELIMITER) && !path.equals(DELIMITER)) {\n+            path = path.substring(1);\n+        }\n+        return path;\n+    }\n+\n+    private URI getBase(URI uri) throws IOException {\n+        try {\n+            return new URI(uri.getScheme(), uri.getHost(), null, null);\n+        } catch (URISyntaxException e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    private boolean existsFile(URI uri) throws IOException {\n+        try {\n+            URI base = getBase(uri);\n+            String path = sanitizePath(base.relativize(uri).getPath());\n+            HeadObjectRequest headObjectRequest = HeadObjectRequest.builder()\n+                    .bucket(uri.getHost())\n+                    .key(path)\n+                    .build();\n+\n+            s3Client.headObject(headObjectRequest);\n+            return true;\n+        }catch(NoSuchKeyException e){\n+            return false;\n+        }catch(S3Exception e){\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    private boolean isEmptyDirectory(URI uri) throws IOException {\n+        if (!isDirectory(uri)) {\n+            return false;\n+        }\n+        String prefix = normalizeToDirectoryPrefix(uri);\n+        boolean isEmpty = true;\n+        ListObjectsV2Response listObjectsV2Response;\n+        ListObjectsV2Request.Builder listObjectsV2RequestBuilder = ListObjectsV2Request.builder()\n+                .bucket(uri.getHost());\n+\n+        if (prefix.equals(DELIMITER)) {\n+            ListObjectsV2Request listObjectsV2Request = listObjectsV2RequestBuilder.build();\n+            listObjectsV2Response = s3Client.listObjectsV2(listObjectsV2Request);\n+        } else {\n+            ListObjectsV2Request listObjectsV2Request = listObjectsV2RequestBuilder.prefix(prefix).build();\n+            listObjectsV2Response = s3Client.listObjectsV2(listObjectsV2Request);\n+        }\n+        for (S3Object s3Object : listObjectsV2Response.contents()) {\n+            if (s3Object.key().equals(prefix)) {\n+                continue;\n+            } else {\n+                isEmpty = false;\n+                break;\n+            }\n+        }\n+        return isEmpty;\n+    }\n+\n+    private boolean copyFile(URI srcUri, URI dstUri) throws IOException {\n+        try {\n+            String encodedUrl = null;\n+            try {\n+                encodedUrl = URLEncoder.encode(srcUri.getHost() + srcUri.getPath(), StandardCharsets.UTF_8.toString());\n+            } catch (UnsupportedEncodingException e) {\n+                LOGGER.info(\"URL could not be encoded: {}\", e.getMessage());\n+            }\n+\n+            String dstPath = sanitizePath(dstUri.getPath());\n+            CopyObjectRequest copyReq = CopyObjectRequest.builder()\n+                    .copySource(encodedUrl)\n+                    .destinationBucket(dstUri.getHost())\n+                    .destinationKey(dstPath)\n+                    .build();\n+\n+            CopyObjectResponse copyObjectResponse = s3Client.copyObject(copyReq);\n+            return copyObjectResponse.sdkHttpResponse().isSuccessful();\n+        }catch(S3Exception e){\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean mkdir(URI uri) throws IOException {\n+        LOGGER.info(\"mkdir {}\", uri);\n+        try {\n+            requireNonNull(uri, \"uri is null\");\n+            String path = normalizeToDirectoryPrefix(uri);\n+            // Bucket root directory already exists and cannot be created\n+            if (path.equals(DELIMITER)) {\n+                return true;\n+            }\n+\n+            PutObjectRequest putObjectRequest = PutObjectRequest.builder()\n+                    .bucket(uri.getHost())\n+                    .key(path)\n+                    .build();\n+\n+            PutObjectResponse putObjectResponse = s3Client.putObject(putObjectRequest, RequestBody.fromBytes(new byte[0]));\n+\n+            return putObjectResponse.sdkHttpResponse().isSuccessful();\n+        } catch (Throwable t) {\n+            throw new IOException(t);\n+        }\n+    }\n+\n+    @Override\n+    public boolean delete(URI segmentUri, boolean forceDelete) throws IOException {\n+        LOGGER.info(\"Deleting uri {} force {}\", segmentUri, forceDelete);\n+        try {\n+            if (isDirectory(segmentUri)) {\n+                if (!forceDelete) {\n+                    checkState(isEmptyDirectory(segmentUri), \"ForceDelete flag is not set and directory '%s' is not empty\", segmentUri);\n+                }\n+                String prefix = normalizeToDirectoryPrefix(segmentUri);\n+                ListObjectsV2Response listObjectsV2Response;\n+                ListObjectsV2Request.Builder listObjectsV2RequestBuilder = ListObjectsV2Request.builder()\n+                        .bucket(segmentUri.getHost());\n+\n+                if (prefix.equals(DELIMITER)) {\n+                    ListObjectsV2Request listObjectsV2Request = listObjectsV2RequestBuilder.build();\n+                    listObjectsV2Response = s3Client.listObjectsV2(listObjectsV2Request);\n+                } else {\n+                    ListObjectsV2Request listObjectsV2Request = listObjectsV2RequestBuilder.prefix(prefix).build();\n+                    listObjectsV2Response = s3Client.listObjectsV2(listObjectsV2Request);\n+                }\n+                boolean deleteSucceeded = true;\n+                for (S3Object s3Object : listObjectsV2Response.contents()) {\n+                    DeleteObjectRequest deleteObjectRequest = DeleteObjectRequest.builder()\n+                            .bucket(segmentUri.getHost())\n+                            .key(s3Object.key())\n+                            .build();\n+\n+                    DeleteObjectResponse deleteObjectResponse = s3Client.deleteObject(deleteObjectRequest);\n+\n+                    deleteSucceeded &= deleteObjectResponse.sdkHttpResponse().isSuccessful();\n+                }\n+                return deleteSucceeded;\n+            } else {\n+                String prefix = sanitizePath(segmentUri.getPath());\n+                DeleteObjectRequest deleteObjectRequest = DeleteObjectRequest.builder()\n+                        .bucket(segmentUri.getHost())\n+                        .key(prefix)\n+                        .build();\n+\n+                DeleteObjectResponse deleteObjectResponse = s3Client.deleteObject(deleteObjectRequest);\n+\n+                return deleteObjectResponse.sdkHttpResponse().isSuccessful();\n+            }\n+        }catch(NoSuchKeyException e){\n+            return false;\n+        } catch (S3Exception e) {\n+            throw e;\n+        } catch(Throwable t) {\n+            throw new IOException(t);\n+        }\n+    }\n+\n+    @Override\n+    public boolean doMove(URI srcUri, URI dstUri) throws IOException {\n+        if (copy(srcUri, dstUri)) {\n+            return  delete(srcUri, true);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean copy(URI srcUri, URI dstUri) throws IOException {\n+        LOGGER.info(\"Copying uri {} to uri {}\", srcUri, dstUri);\n+        checkState(exists(srcUri), \"Source URI '%s' does not exist\", srcUri);\n+        if (srcUri.equals(dstUri)) {\n+            return true;\n+        }\n+        if (!isDirectory(srcUri)) {\n+            delete(dstUri, true);\n+            return copyFile(srcUri, dstUri);\n+        }\n+        dstUri = normalizeToDirectoryUri(dstUri);\n+        ImmutableList.Builder<URI> builder = ImmutableList.builder();\n+        Path srcPath = Paths.get(srcUri.getPath());\n+        try {\n+            boolean copySucceeded = true;\n+            for (String directoryEntry : listFiles(srcUri, true)) {\n+                URI src = new URI(srcUri.getScheme(), srcUri.getHost(), directoryEntry, null);\n+                String relativeSrcPath = srcPath.relativize(Paths.get(directoryEntry)).toString();", "originalCommit": "4a55cc4ceef627cf87d4ce344435ded19f249b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0MTM3OA==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r412441378", "bodyText": "done", "author": "KKcorps", "createdAt": "2020-04-21T19:43:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI4NDQ4MA=="}], "type": "inlineReview"}, {"oid": "bb793634ee6d10e4838737669ca0f6cc348131dc", "url": "https://github.com/apache/pinot/commit/bb793634ee6d10e4838737669ca0f6cc348131dc", "message": "fixing codestyle", "committedDate": "2020-04-16T13:35:15Z", "type": "commit"}, {"oid": "2d2c1a7dfcbeb50ad5c711115e0dfec528bd7fa2", "url": "https://github.com/apache/pinot/commit/2d2c1a7dfcbeb50ad5c711115e0dfec528bd7fa2", "message": "fixing linting and copy operation", "committedDate": "2020-04-16T16:09:36Z", "type": "commit"}, {"oid": "bc995b05c68ab5df207bb0a9dbc7fec44a97097f", "url": "https://github.com/apache/pinot/commit/bc995b05c68ab5df207bb0a9dbc7fec44a97097f", "message": "adding new line to pom", "committedDate": "2020-04-16T16:11:06Z", "type": "commit"}, {"oid": "71e40da73e5d829f5521352d24dbeda71004efa6", "url": "https://github.com/apache/pinot/commit/71e40da73e5d829f5521352d24dbeda71004efa6", "message": "changing AWS credentials logic", "committedDate": "2020-04-16T19:09:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg3OTQwNQ==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r409879405", "bodyText": "convention followed is to not have static import. Instead use Preconditions.checkState", "author": "npawar", "createdAt": "2020-04-16T22:13:57Z", "path": "pinot-plugins/pinot-file-system/pinot-s3/src/main/java/org/apache/pinot/plugin/filesystem/S3PinotFS.java", "diffHunk": "@@ -0,0 +1,505 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.plugin.filesystem;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.pinot.spi.filesystem.PinotFS;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.AwsCredentialsProvider;\n+import software.amazon.awssdk.auth.credentials.AwsCredentialsProviderChain;\n+import software.amazon.awssdk.auth.credentials.EnvironmentVariableCredentialsProvider;\n+import software.amazon.awssdk.auth.credentials.ProfileCredentialsProvider;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.auth.credentials.SystemPropertyCredentialsProvider;\n+import software.amazon.awssdk.core.ResponseBytes;\n+import software.amazon.awssdk.core.sync.RequestBody;\n+import software.amazon.awssdk.core.sync.ResponseTransformer;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.s3.S3Client;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.io.IOException;\n+import java.io.File;\n+import java.io.UnsupportedEncodingException;\n+import java.io.InputStream;\n+\n+import software.amazon.awssdk.services.s3.model.S3Exception;\n+import software.amazon.awssdk.services.s3.model.NoSuchKeyException;\n+import software.amazon.awssdk.services.s3.model.HeadObjectRequest;\n+import software.amazon.awssdk.services.s3.model.HeadObjectResponse;\n+import software.amazon.awssdk.services.s3.model.ListObjectsV2Request;\n+import software.amazon.awssdk.services.s3.model.ListObjectsV2Response;\n+import software.amazon.awssdk.services.s3.model.GetObjectRequest;\n+import software.amazon.awssdk.services.s3.model.CopyObjectRequest;\n+import software.amazon.awssdk.services.s3.model.CopyObjectResponse;\n+import software.amazon.awssdk.services.s3.model.DeleteObjectRequest;\n+import software.amazon.awssdk.services.s3.model.DeleteObjectResponse;\n+import software.amazon.awssdk.services.s3.model.PutObjectRequest;\n+import software.amazon.awssdk.services.s3.model.PutObjectResponse;\n+import software.amazon.awssdk.services.s3.model.S3Object;\n+import software.amazon.awssdk.services.s3.model.MetadataDirective;\n+\n+import static com.google.common.base.Preconditions.checkState;", "originalCommit": "71e40da73e5d829f5521352d24dbeda71004efa6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg3OTU1Mw==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r409879553", "bodyText": "Use com.google.common.base.Preconditions instead?", "author": "npawar", "createdAt": "2020-04-16T22:14:18Z", "path": "pinot-plugins/pinot-file-system/pinot-s3/src/main/java/org/apache/pinot/plugin/filesystem/S3PinotFS.java", "diffHunk": "@@ -0,0 +1,505 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.plugin.filesystem;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.pinot.spi.filesystem.PinotFS;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.AwsCredentialsProvider;\n+import software.amazon.awssdk.auth.credentials.AwsCredentialsProviderChain;\n+import software.amazon.awssdk.auth.credentials.EnvironmentVariableCredentialsProvider;\n+import software.amazon.awssdk.auth.credentials.ProfileCredentialsProvider;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.auth.credentials.SystemPropertyCredentialsProvider;\n+import software.amazon.awssdk.core.ResponseBytes;\n+import software.amazon.awssdk.core.sync.RequestBody;\n+import software.amazon.awssdk.core.sync.ResponseTransformer;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.s3.S3Client;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.io.IOException;\n+import java.io.File;\n+import java.io.UnsupportedEncodingException;\n+import java.io.InputStream;\n+\n+import software.amazon.awssdk.services.s3.model.S3Exception;\n+import software.amazon.awssdk.services.s3.model.NoSuchKeyException;\n+import software.amazon.awssdk.services.s3.model.HeadObjectRequest;\n+import software.amazon.awssdk.services.s3.model.HeadObjectResponse;\n+import software.amazon.awssdk.services.s3.model.ListObjectsV2Request;\n+import software.amazon.awssdk.services.s3.model.ListObjectsV2Response;\n+import software.amazon.awssdk.services.s3.model.GetObjectRequest;\n+import software.amazon.awssdk.services.s3.model.CopyObjectRequest;\n+import software.amazon.awssdk.services.s3.model.CopyObjectResponse;\n+import software.amazon.awssdk.services.s3.model.DeleteObjectRequest;\n+import software.amazon.awssdk.services.s3.model.DeleteObjectResponse;\n+import software.amazon.awssdk.services.s3.model.PutObjectRequest;\n+import software.amazon.awssdk.services.s3.model.PutObjectResponse;\n+import software.amazon.awssdk.services.s3.model.S3Object;\n+import software.amazon.awssdk.services.s3.model.MetadataDirective;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+import static joptsimple.internal.Strings.isNullOrEmpty;\n+import static org.glassfish.jersey.internal.guava.Preconditions.checkArgument;", "originalCommit": "71e40da73e5d829f5521352d24dbeda71004efa6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg4Mjg0Ng==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r409882846", "bodyText": "Preconditions.checkNotNull", "author": "npawar", "createdAt": "2020-04-16T22:22:36Z", "path": "pinot-plugins/pinot-file-system/pinot-s3/src/main/java/org/apache/pinot/plugin/filesystem/S3PinotFS.java", "diffHunk": "@@ -0,0 +1,505 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.plugin.filesystem;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.pinot.spi.filesystem.PinotFS;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;\n+import software.amazon.awssdk.auth.credentials.AwsCredentialsProvider;\n+import software.amazon.awssdk.auth.credentials.AwsCredentialsProviderChain;\n+import software.amazon.awssdk.auth.credentials.EnvironmentVariableCredentialsProvider;\n+import software.amazon.awssdk.auth.credentials.ProfileCredentialsProvider;\n+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;\n+import software.amazon.awssdk.auth.credentials.SystemPropertyCredentialsProvider;\n+import software.amazon.awssdk.core.ResponseBytes;\n+import software.amazon.awssdk.core.sync.RequestBody;\n+import software.amazon.awssdk.core.sync.ResponseTransformer;\n+import software.amazon.awssdk.regions.Region;\n+import software.amazon.awssdk.services.s3.S3Client;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.io.IOException;\n+import java.io.File;\n+import java.io.UnsupportedEncodingException;\n+import java.io.InputStream;\n+\n+import software.amazon.awssdk.services.s3.model.S3Exception;\n+import software.amazon.awssdk.services.s3.model.NoSuchKeyException;\n+import software.amazon.awssdk.services.s3.model.HeadObjectRequest;\n+import software.amazon.awssdk.services.s3.model.HeadObjectResponse;\n+import software.amazon.awssdk.services.s3.model.ListObjectsV2Request;\n+import software.amazon.awssdk.services.s3.model.ListObjectsV2Response;\n+import software.amazon.awssdk.services.s3.model.GetObjectRequest;\n+import software.amazon.awssdk.services.s3.model.CopyObjectRequest;\n+import software.amazon.awssdk.services.s3.model.CopyObjectResponse;\n+import software.amazon.awssdk.services.s3.model.DeleteObjectRequest;\n+import software.amazon.awssdk.services.s3.model.DeleteObjectResponse;\n+import software.amazon.awssdk.services.s3.model.PutObjectRequest;\n+import software.amazon.awssdk.services.s3.model.PutObjectResponse;\n+import software.amazon.awssdk.services.s3.model.S3Object;\n+import software.amazon.awssdk.services.s3.model.MetadataDirective;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+import static joptsimple.internal.Strings.isNullOrEmpty;\n+import static org.glassfish.jersey.internal.guava.Preconditions.checkArgument;\n+\n+\n+public class S3PinotFS extends PinotFS {\n+  public static final String ACCESS_KEY = \"accessKey\";\n+  public static final String SECRET_KEY = \"secretKey\";\n+  public static final String REGION = \"region\";\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(S3PinotFS.class);\n+  private static final String DELIMITER = \"/\";\n+  private S3Client _s3Client;\n+\n+  @Override\n+  public void init(Configuration config) {\n+    checkArgument(!isNullOrEmpty(config.getString(REGION)));\n+    String region = config.getString(REGION);\n+\n+    AwsCredentialsProvider awsCredentialsProvider;\n+    try {\n+\n+      if (!isNullOrEmpty(config.getString(ACCESS_KEY)) && !isNullOrEmpty(config.getString(SECRET_KEY))) {\n+        String accessKey = config.getString(ACCESS_KEY);\n+        String secretKey = config.getString(SECRET_KEY);\n+        AwsBasicCredentials awsBasicCredentials = AwsBasicCredentials.create(accessKey, secretKey);\n+        awsCredentialsProvider = StaticCredentialsProvider.create(awsBasicCredentials);\n+      } else {\n+        awsCredentialsProvider =\n+            AwsCredentialsProviderChain.builder().addCredentialsProvider(SystemPropertyCredentialsProvider.create())\n+                .addCredentialsProvider(EnvironmentVariableCredentialsProvider.create()).build();\n+      }\n+\n+      _s3Client = S3Client.builder().region(Region.of(region)).credentialsProvider(awsCredentialsProvider).build();\n+    } catch (S3Exception e) {\n+      throw new RuntimeException(\"Could not initialize S3PinotFS\", e);\n+    }\n+  }\n+\n+  private HeadObjectResponse getS3ObjectMetadata(URI uri)\n+      throws IOException {\n+    URI base = getBase(uri);\n+    String path = sanitizePath(base.relativize(uri).getPath());\n+    HeadObjectRequest headObjectRequest = HeadObjectRequest.builder().bucket(uri.getHost()).key(path).build();\n+\n+    return _s3Client.headObject(headObjectRequest);\n+  }\n+\n+  private boolean isPathTerminatedByDelimiter(URI uri) {\n+    return uri.getPath().endsWith(DELIMITER);\n+  }\n+\n+  private String normalizeToDirectoryPrefix(URI uri)\n+      throws IOException {\n+    requireNonNull(uri, \"uri is null\");", "originalCommit": "71e40da73e5d829f5521352d24dbeda71004efa6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE3NDYwMw==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r410174603", "bodyText": "Does it look fine now?", "author": "KKcorps", "createdAt": "2020-04-17T11:57:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg4Mjg0Ng=="}], "type": "inlineReview"}, {"oid": "2ec54558f142ba068a1063a9702886d8ae363dc3", "url": "https://github.com/apache/pinot/commit/2ec54558f142ba068a1063a9702886d8ae363dc3", "message": "using google preconditions", "committedDate": "2020-04-17T11:56:25Z", "type": "commit"}, {"oid": "df66538235e7980536a712930eed02fac70857c5", "url": "https://github.com/apache/pinot/commit/df66538235e7980536a712930eed02fac70857c5", "message": "adding test cases", "committedDate": "2020-04-21T19:41:51Z", "type": "commit"}, {"oid": "ba6e13be879e1c8c097c07b28e27c500e752c076", "url": "https://github.com/apache/pinot/commit/ba6e13be879e1c8c097c07b28e27c500e752c076", "message": "removing printlns", "committedDate": "2020-04-21T19:45:04Z", "type": "commit"}, {"oid": "d095a46181f24a12a54cacf8889c364402a78dad", "url": "https://github.com/apache/pinot/commit/d095a46181f24a12a54cacf8889c364402a78dad", "message": "adding new line", "committedDate": "2020-04-21T19:47:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0NzQwNQ==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r412447405", "bodyText": "license header", "author": "kishoreg", "createdAt": "2020-04-21T19:53:23Z", "path": "pinot-plugins/pinot-file-system/pinot-s3/src/test/java/org/apache/pinot/plugin/filesystem/S3PinotFSTest.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package org.apache.pinot.plugin.filesystem;", "originalCommit": "d095a46181f24a12a54cacf8889c364402a78dad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1OTg1Mg==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r412459852", "bodyText": "done", "author": "KKcorps", "createdAt": "2020-04-21T20:13:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0NzQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0NzkxOA==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r412447918", "bodyText": "missing annotation", "author": "kishoreg", "createdAt": "2020-04-21T19:54:11Z", "path": "pinot-plugins/pinot-file-system/pinot-s3/src/test/java/org/apache/pinot/plugin/filesystem/S3PinotFSTest.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package org.apache.pinot.plugin.filesystem;\n+\n+import com.adobe.testing.s3mock.testng.S3Mock;\n+import java.io.File;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.apache.commons.io.IOUtils;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+import software.amazon.awssdk.core.sync.RequestBody;\n+import software.amazon.awssdk.services.s3.S3Client;\n+import software.amazon.awssdk.services.s3.model.CreateBucketRequest;\n+import software.amazon.awssdk.services.s3.model.HeadObjectResponse;\n+import software.amazon.awssdk.services.s3.model.ListObjectsV2Response;\n+import software.amazon.awssdk.services.s3.model.S3Object;\n+\n+\n+@Test\n+@Listeners(com.adobe.testing.s3mock.testng.S3MockListener.class)\n+public class S3PinotFSTest {\n+  final String DELIMITER = \"/\";\n+  S3PinotFS _s3PinotFS;\n+  S3Client _s3Client;\n+  final String BUCKET = \"test-bucket\";\n+  final String SCHEME = \"s3\";\n+  final String FILE_FORMAT = \"%s://%s/%s\";\n+  final String DIR_FORMAT = \"%s://%s\";\n+\n+  @BeforeMethod\n+  public void setUp() {\n+    S3Mock s3Mock = S3Mock.getInstance();\n+    _s3Client = s3Mock.createS3ClientV2();\n+    _s3PinotFS = new S3PinotFS();\n+    _s3PinotFS.init(_s3Client);\n+    _s3Client.createBucket(CreateBucketRequest.builder().bucket(BUCKET).build());\n+  }\n+\n+  private void createEmptyFile(String folderName, String fileName) {\n+    String fileNameWithFolder = folderName + DELIMITER + fileName;\n+    _s3Client\n+        .putObject(S3TestUtils.getPutObjectRequest(BUCKET, fileNameWithFolder), RequestBody.fromBytes(new byte[0]));\n+  }\n+\n+  @Test\n+  public void testTouchFileInBucket()\n+      throws Exception {\n+\n+    String[] originalFiles = new String[]{\"a-touch.txt\", \"b-touch.txt\", \"c-touch.txt\"};\n+\n+    for (String fileName : originalFiles) {\n+      _s3PinotFS.touch(URI.create(String.format(FILE_FORMAT, SCHEME, BUCKET, fileName)));\n+    }\n+    ListObjectsV2Response listObjectsV2Response =\n+        _s3Client.listObjectsV2(S3TestUtils.getListObjectRequest(BUCKET, \"\", true));\n+\n+    String[] response = listObjectsV2Response.contents().stream().map(S3Object::key).filter(x -> x.contains(\"touch\"))\n+        .toArray(String[]::new);\n+\n+    Assert.assertEquals(response.length, originalFiles.length);\n+    Assert.assertTrue(Arrays.equals(response, originalFiles));\n+  }\n+\n+  @Test\n+  public void testTouchFilesInFolder()\n+      throws Exception {\n+\n+    String folder = \"my-files\";\n+    String[] originalFiles = new String[]{\"a-touch.txt\", \"b-touch.txt\", \"c-touch.txt\"};\n+\n+    for (String fileName : originalFiles) {\n+      String fileNameWithFolder = folder + DELIMITER + fileName;\n+      _s3PinotFS.touch(URI.create(String.format(FILE_FORMAT, SCHEME, BUCKET, fileNameWithFolder)));\n+    }\n+    ListObjectsV2Response listObjectsV2Response =\n+        _s3Client.listObjectsV2(S3TestUtils.getListObjectRequest(BUCKET, folder, false));\n+\n+    String[] response = listObjectsV2Response.contents().stream().map(S3Object::key).filter(x -> x.contains(\"touch\"))\n+        .toArray(String[]::new);\n+    Assert.assertEquals(response.length, originalFiles.length);\n+\n+    Assert.assertTrue(Arrays.equals(response, Arrays.stream(originalFiles).map(x -> folder + DELIMITER + x).toArray()));\n+  }\n+\n+  public void testListFilesInBucketNonRecursive()", "originalCommit": "d095a46181f24a12a54cacf8889c364402a78dad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1OTc3MQ==", "url": "https://github.com/apache/pinot/pull/5249#discussion_r412459771", "bodyText": "done", "author": "KKcorps", "createdAt": "2020-04-21T20:13:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0NzkxOA=="}], "type": "inlineReview"}, {"oid": "57028afce1bdc4007a727730bc96bb4e967c279b", "url": "https://github.com/apache/pinot/commit/57028afce1bdc4007a727730bc96bb4e967c279b", "message": "adding license header and Test annotations", "committedDate": "2020-04-21T20:00:31Z", "type": "commit"}]}