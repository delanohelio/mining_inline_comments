{"pr_number": 5259, "pr_title": "Support Aggregation functions with multiple arguments.", "pr_createdAt": "2020-04-16T02:52:46Z", "pr_url": "https://github.com/apache/pinot/pull/5259", "timeline": [{"oid": "e30e6dee89b54d6ab5fa35f619cf0d2d4a4011ac", "url": "https://github.com/apache/pinot/commit/e30e6dee89b54d6ab5fa35f619cf0d2d4a4011ac", "message": "Support Aggregation functions with multiple arguments.\n\nThe current implementation assumes that all AggregationFunctions take one argument\nwith the exception of DistinctAggregationFunction. This PR handles changes related\nto supporting AggregationFunctions with multiple arguments, as we anticipate new\naggregation functions to be added that take multiple arguments.\n\n1. Enhanced parser to allow multiple arguments for aggregation functions.\n2. AggregationFunctionFactory provides the right set of arguments when instantiating\n   individual aggregation functions.\n3. AggregationFunctions now store their arguments, as opposed to assuming that the right\n   BlockValSet is passed to the aggregate() api's.\n4. AggregationFunction.aggregate() api's now take a Map<String, BlockValSet> where the key\n   is the argument expression (columnName for simple case), as opposed to a variable array\n   as that interface does not provide a way to associate BlockValSet with the argument.\n5. Cleanup: Removed env variable to enable/disable Distinct, as there is no need for it to be\n   disabled anymore.", "committedDate": "2020-04-16T03:26:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2MDc3Nw==", "url": "https://github.com/apache/pinot/pull/5259#discussion_r409260777", "bodyText": "this is only needed for distinct and it should go away after your change, right?", "author": "kishoreg", "createdAt": "2020-04-16T03:33:15Z", "path": "pinot-common/src/main/java/org/apache/pinot/parsers/CompilerConstants.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.parsers;\n+\n+/**\n+ * Class to host compiler related constants\n+ */\n+public class CompilerConstants {\n+  public static final String AGGREGATION_FUNCTION_ARG_SEPARATOR = \":\";", "originalCommit": "e30e6dee89b54d6ab5fa35f619cf0d2d4a4011ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2OTQ3Mg==", "url": "https://github.com/apache/pinot/pull/5259#discussion_r409269472", "bodyText": "The current approach is also based on concatenated arguments using a separator \":\". Two other possibilities:\n\nChange AggregationInfo thrift object to pass multiple arguments in a much cleaner manner right from the parser stage.\nChange the way arguments are stored in the map that is already there in AggregationInfo. This doesn't require change to thrift definition. We can adopt a convention where multiple arguments are stored as individual KV pairs in the map that is already there in AggregationInfo. Right now there exists a single entry in this map. Key being \"column\" and value being column name (argument to aggr function). The value is a concatenated string for aggr functions that can take multiple arguments.", "author": "siddharthteotia", "createdAt": "2020-04-16T04:08:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2MDc3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwNDk4Nw==", "url": "https://github.com/apache/pinot/pull/5259#discussion_r409304987", "bodyText": "As @siddharthteotia pointed out, passing multiple args to aggregation function via AggregationInfo may end up creating a backward incompatible change. For now, I am piggy backing on the concatenation approach to pass multiple args. We can make a backward compatible cleanup separately, unless there is trivial fix that can be included in this PR.", "author": "mayankshriv", "createdAt": "2020-04-16T06:12:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2MDc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2MTEyMQ==", "url": "https://github.com/apache/pinot/pull/5259#discussion_r409261121", "bodyText": "I dint see the use of SQLKind here, we don't want to leak this. Can you please move this constant to PinotQuery.Constants or some other place", "author": "kishoreg", "createdAt": "2020-04-16T03:34:43Z", "path": "pinot-common/src/main/java/org/apache/pinot/pql/parsers/PinotQuery2BrokerRequestConverter.java", "diffHunk": "@@ -121,7 +121,8 @@ private void convertSelectList(PinotQuery pinotQuery, BrokerRequest brokerReques\n     List<AggregationInfo> aggregationInfoList = null;\n     for (Expression expression : pinotQuery.getSelectList()) {\n       ExpressionType type = expression.getType();\n-      if (type == ExpressionType.FUNCTION && expression.getFunctionCall().getOperator().equalsIgnoreCase(SqlKind.AS.toString())) {\n+      if (type == ExpressionType.FUNCTION && expression.getFunctionCall().getOperator()", "originalCommit": "e30e6dee89b54d6ab5fa35f619cf0d2d4a4011ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwNjczOA==", "url": "https://github.com/apache/pinot/pull/5259#discussion_r409306738", "bodyText": "This diff got flagged only due to formatting change. Will file a separate PR for this.", "author": "mayankshriv", "createdAt": "2020-04-16T06:17:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2MTEyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2MTMwOA==", "url": "https://github.com/apache/pinot/pull/5259#discussion_r409261308", "bodyText": "+100", "author": "kishoreg", "createdAt": "2020-04-16T03:35:30Z", "path": "pinot-common/src/main/java/org/apache/pinot/pql/parsers/pql2/ast/FunctionCallAstNode.java", "diffHunk": "@@ -92,52 +91,34 @@ AggregationInfo buildAggregationInfo() {\n       if (children == null || children.isEmpty()) {\n         throw new Pql2CompilationException(\"Aggregation function expects non-null argument\");\n       }\n-      if (!_name.equalsIgnoreCase(AggregationFunctionType.DISTINCT.getName())) {\n-        if (children.size() != 1) {\n-          throw new Pql2CompilationException(\"Aggregation function expects exactly 1 argument as column name\");\n-        } else {\n-          expression = TransformExpressionTree.getStandardExpression(children.get(0));\n-        }\n-      } else {\n-        // DISTINCT\n-        if (!Pql2Compiler.ENABLE_DISTINCT) {\n-          throw new Pql2CompilationException(\"Support for DISTINCT is currently disabled\");\n-        }\n-        if (children.size() == 1) {\n-          // single column DISTINCT query\n-          // e.g SELECT DISTINCT(col) FROM foo\n-          if (children.get(0) instanceof StarExpressionAstNode) {\n-            // DISTINCT(*) is not supported yet. User has to specify each column that should participate in DISTINCT\n-            throw new Pql2CompilationException(\n-                \"Syntax error: Pinot currently does not support DISTINCT with *. Please specify each column name as argument to DISTINCT function\");\n-          }\n-          expression = TransformExpressionTree.getStandardExpression(children.get(0));\n-        } else {\n-          // multi-column DISTINCT query\n-          // e.g SELECT DISTINCT(col1, col2) FROM foo\n-          // we will pass down the column expression to execution code\n-          // as col1:col2\n-          Set<String> expressions = new HashSet<>();\n-          StringBuilder distinctColumnExpr = new StringBuilder();\n-          int numChildren = children.size();\n-          for (int i = 0; i < numChildren; ++i) {\n-            expression = TransformExpressionTree.getStandardExpression(children.get(i));\n-            if (expressions.add(expression)) {\n-              // deduplicate the columns\n-              if (i != 0) {\n-                distinctColumnExpr.append(DISTINCT_MULTI_COLUMN_SEPARATOR);\n-              }\n-              distinctColumnExpr.append(expression);\n-            }\n+\n+      // TODO: Remove all distinct special-casing.", "originalCommit": "e30e6dee89b54d6ab5fa35f619cf0d2d4a4011ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2MjMwNg==", "url": "https://github.com/apache/pinot/pull/5259#discussion_r409262306", "bodyText": "is this temporary for Distinct or permanent?", "author": "kishoreg", "createdAt": "2020-04-16T03:39:38Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionFactory.java", "diffHunk": "@@ -42,79 +47,87 @@ private AggregationFunctionFactory() {\n   public static AggregationFunction getAggregationFunction(AggregationInfo aggregationInfo,\n       @Nullable BrokerRequest brokerRequest) {\n     String functionName = aggregationInfo.getAggregationType();\n+    String argumentsString = AggregationFunctionUtils.getColumn(aggregationInfo);", "originalCommit": "e30e6dee89b54d6ab5fa35f619cf0d2d4a4011ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwNzU3Mg==", "url": "https://github.com/apache/pinot/pull/5259#discussion_r409307572", "bodyText": "This is for passing multiple args as one concatenated string in this PR, to avoid backward incompatible change in request.thrift for AggregationInfo. Open to suggestions if there is a trivial fix here that can be done in this PR. Otherwise, will address it separately in a backward compatible way.", "author": "mayankshriv", "createdAt": "2020-04-16T06:19:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2MjMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2Mjk3Mw==", "url": "https://github.com/apache/pinot/pull/5259#discussion_r409262973", "bodyText": "should we instead fix AggregationInfo to take in multiple arguments instead?", "author": "kishoreg", "createdAt": "2020-04-16T03:42:24Z", "path": "pinot-common/src/main/java/org/apache/pinot/pql/parsers/pql2/ast/FunctionCallAstNode.java", "diffHunk": "@@ -92,52 +91,34 @@ AggregationInfo buildAggregationInfo() {\n       if (children == null || children.isEmpty()) {\n         throw new Pql2CompilationException(\"Aggregation function expects non-null argument\");\n       }\n-      if (!_name.equalsIgnoreCase(AggregationFunctionType.DISTINCT.getName())) {\n-        if (children.size() != 1) {\n-          throw new Pql2CompilationException(\"Aggregation function expects exactly 1 argument as column name\");\n-        } else {\n-          expression = TransformExpressionTree.getStandardExpression(children.get(0));\n-        }\n-      } else {\n-        // DISTINCT\n-        if (!Pql2Compiler.ENABLE_DISTINCT) {\n-          throw new Pql2CompilationException(\"Support for DISTINCT is currently disabled\");\n-        }\n-        if (children.size() == 1) {\n-          // single column DISTINCT query\n-          // e.g SELECT DISTINCT(col) FROM foo\n-          if (children.get(0) instanceof StarExpressionAstNode) {\n-            // DISTINCT(*) is not supported yet. User has to specify each column that should participate in DISTINCT\n-            throw new Pql2CompilationException(\n-                \"Syntax error: Pinot currently does not support DISTINCT with *. Please specify each column name as argument to DISTINCT function\");\n-          }\n-          expression = TransformExpressionTree.getStandardExpression(children.get(0));\n-        } else {\n-          // multi-column DISTINCT query\n-          // e.g SELECT DISTINCT(col1, col2) FROM foo\n-          // we will pass down the column expression to execution code\n-          // as col1:col2\n-          Set<String> expressions = new HashSet<>();\n-          StringBuilder distinctColumnExpr = new StringBuilder();\n-          int numChildren = children.size();\n-          for (int i = 0; i < numChildren; ++i) {\n-            expression = TransformExpressionTree.getStandardExpression(children.get(i));\n-            if (expressions.add(expression)) {\n-              // deduplicate the columns\n-              if (i != 0) {\n-                distinctColumnExpr.append(DISTINCT_MULTI_COLUMN_SEPARATOR);\n-              }\n-              distinctColumnExpr.append(expression);\n-            }\n+\n+      // TODO: Remove all distinct special-casing.\n+      // DISTINCT(*) is not supported yet. User has to specify each column that should participate in DISTINCT\n+      if (_name.equalsIgnoreCase(AggregationFunctionType.DISTINCT.getName()) && children.size() == 1 && children\n+          .get(0) instanceof StarExpressionAstNode) {\n+        throw new Pql2CompilationException(\n+            \"Syntax error: Pinot currently does not support DISTINCT with *. Please specify each column name as argument to DISTINCT function\");\n+      }\n+\n+      Set<String> expressions = new HashSet<>();\n+      StringBuilder distinctColumnExpr = new StringBuilder();\n+      int numChildren = children.size();\n+      for (int i = 0; i < numChildren; ++i) {\n+        expression = TransformExpressionTree.getStandardExpression(children.get(i));\n+        if (expressions.add(expression)) {\n+          // deduplicate the columns\n+          if (i != 0) {\n+            distinctColumnExpr.append(AGGREGATION_FUNCTION_ARG_SEPARATOR);\n           }\n-          expression = distinctColumnExpr.toString();\n+          distinctColumnExpr.append(expression);\n         }\n       }\n+      expression = distinctColumnExpr.toString();\n     }\n \n     AggregationInfo aggregationInfo = new AggregationInfo();\n     aggregationInfo.setAggregationType(_name);\n-    aggregationInfo.putToAggregationParams(COLUMN_KEY_IN_AGGREGATION_INFO, expression);\n+    aggregationInfo.putToAggregationParams(CompilerConstants.COLUMN_KEY_IN_AGGREGATION_INFO, expression);", "originalCommit": "e30e6dee89b54d6ab5fa35f619cf0d2d4a4011ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwNzk2NQ==", "url": "https://github.com/apache/pinot/pull/5259#discussion_r409307965", "bodyText": "Yes we should. I didn't want to break backward compatibility in this PR though.", "author": "mayankshriv", "createdAt": "2020-04-16T06:20:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2Mjk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2Mzg3Mw==", "url": "https://github.com/apache/pinot/pull/5259#discussion_r409263873", "bodyText": "should we add an init method instead that passes the arguments[] as it is, this might allow us to plugin aggregation functions easily. we can do this in the next PR as well", "author": "kishoreg", "createdAt": "2020-04-16T03:46:04Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionFactory.java", "diffHunk": "@@ -42,79 +47,87 @@ private AggregationFunctionFactory() {\n   public static AggregationFunction getAggregationFunction(AggregationInfo aggregationInfo,\n       @Nullable BrokerRequest brokerRequest) {\n     String functionName = aggregationInfo.getAggregationType();\n+    String argumentsString = AggregationFunctionUtils.getColumn(aggregationInfo);\n+    List<String> arguments = Arrays.asList(argumentsString.split(CompilerConstants.AGGREGATION_FUNCTION_ARG_SEPARATOR));\n+\n     try {\n       String upperCaseFunctionName = functionName.toUpperCase();\n       if (upperCaseFunctionName.startsWith(\"PERCENTILE\")) {\n         String remainingFunctionName = upperCaseFunctionName.substring(10);\n+        List<String> args = new ArrayList<>(arguments);\n         if (remainingFunctionName.matches(\"\\\\d+\")) {\n           // Percentile\n-          return new PercentileAggregationFunction(parsePercentile(remainingFunctionName));\n+          args.add(remainingFunctionName);\n+          return new PercentileAggregationFunction(args);\n         } else if (remainingFunctionName.matches(\"EST\\\\d+\")) {\n           // PercentileEst\n-          return new PercentileEstAggregationFunction(parsePercentile(remainingFunctionName.substring(3)));\n+          args.add(remainingFunctionName.substring(3));\n+          return new PercentileEstAggregationFunction(args);\n         } else if (remainingFunctionName.matches(\"TDIGEST\\\\d+\")) {\n           // PercentileTDigest\n-          return new PercentileTDigestAggregationFunction(parsePercentile(remainingFunctionName.substring(7)));\n+          args.add(remainingFunctionName.substring(7));\n+          return new PercentileTDigestAggregationFunction(args);\n         } else if (remainingFunctionName.matches(\"\\\\d+MV\")) {\n           // PercentileMV\n-          return new PercentileMVAggregationFunction(\n-              parsePercentile(remainingFunctionName.substring(0, remainingFunctionName.length() - 2)));\n+          args.add(remainingFunctionName.substring(0, remainingFunctionName.length() - 2));\n+          return new PercentileMVAggregationFunction(args);\n         } else if (remainingFunctionName.matches(\"EST\\\\d+MV\")) {\n           // PercentileEstMV\n-          return new PercentileEstMVAggregationFunction(\n-              parsePercentile(remainingFunctionName.substring(3, remainingFunctionName.length() - 2)));\n+          args.add(remainingFunctionName.substring(3, remainingFunctionName.length() - 2));\n+          return new PercentileEstMVAggregationFunction(args);\n         } else if (remainingFunctionName.matches(\"TDIGEST\\\\d+MV\")) {\n           // PercentileTDigestMV\n-          return new PercentileTDigestMVAggregationFunction(\n-              parsePercentile(remainingFunctionName.substring(7, remainingFunctionName.length() - 2)));\n+          args.add(remainingFunctionName.substring(7, remainingFunctionName.length() - 2));\n+          return new PercentileTDigestMVAggregationFunction(args);\n         } else {\n           throw new IllegalArgumentException();\n         }\n       } else {\n+        String column = arguments.get(0);\n         switch (AggregationFunctionType.valueOf(upperCaseFunctionName)) {\n           case COUNT:\n-            return new CountAggregationFunction();\n+            return new CountAggregationFunction(column);", "originalCommit": "e30e6dee89b54d6ab5fa35f619cf0d2d4a4011ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwODEwMg==", "url": "https://github.com/apache/pinot/pull/5259#discussion_r409308102", "bodyText": "Yeah, next PR.", "author": "mayankshriv", "createdAt": "2020-04-16T06:20:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2Mzg3Mw=="}], "type": "inlineReview"}, {"oid": "c43e2c2484b0747a3bab1a194459723a26c5960a", "url": "https://github.com/apache/pinot/commit/c43e2c2484b0747a3bab1a194459723a26c5960a", "message": "Support Aggregation functions with multiple arguments.\n\nThe current implementation assumes that all AggregationFunctions take one argument\nwith the exception of DistinctAggregationFunction. This PR handles changes related\nto supporting AggregationFunctions with multiple arguments, as we anticipate new\naggregation functions to be added that take multiple arguments.\n\n1. Enhanced parser to allow multiple arguments for aggregation functions.\n2. AggregationFunctionFactory provides the right set of arguments when instantiating\n   individual aggregation functions.\n3. AggregationFunctions now store their arguments, as opposed to assuming that the right\n   BlockValSet is passed to the aggregate() api's.\n4. AggregationFunction.aggregate() api's now take a Map<String, BlockValSet> where the key\n   is the argument expression (columnName for simple case), as opposed to a variable array\n   as that interface does not provide a way to associate BlockValSet with the argument.\n5. Cleanup: Removed env variable to enable/disable Distinct, as there is no need for it to be\n   disabled anymore.", "committedDate": "2020-04-16T06:07:30Z", "type": "forcePushed"}, {"oid": "f236728138685d4c19b7bbb876b48a6228ff078b", "url": "https://github.com/apache/pinot/commit/f236728138685d4c19b7bbb876b48a6228ff078b", "message": "Support Aggregation functions with multiple arguments.\n\nThe current implementation assumes that all AggregationFunctions take one argument\nwith the exception of DistinctAggregationFunction. This PR handles changes related\nto supporting AggregationFunctions with multiple arguments, as we anticipate new\naggregation functions to be added that take multiple arguments.\n\n1. Enhanced parser to allow multiple arguments for aggregation functions.\n2. AggregationFunctionFactory provides the right set of arguments when instantiating\n   individual aggregation functions.\n3. AggregationFunctions now store their arguments, as opposed to assuming that the right\n   BlockValSet is passed to the aggregate() api's.\n4. AggregationFunction.aggregate() api's now take a Map<String, BlockValSet> where the key\n   is the argument expression (columnName for simple case), as opposed to a variable array\n   as that interface does not provide a way to associate BlockValSet with the argument.\n5. Cleanup: Removed env variable to enable/disable Distinct, as there is no need for it to be\n   disabled anymore.", "committedDate": "2020-04-16T14:05:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcxNDkzMQ==", "url": "https://github.com/apache/pinot/pull/5259#discussion_r409714931", "bodyText": "Perhaps we should introduce a map that specifies the number of arguments aggregation function expects (if fixed)? We can then throw an error right here for functions that cannot handle multiple arguments.", "author": "mcvsubbu", "createdAt": "2020-04-16T17:07:36Z", "path": "pinot-common/src/main/java/org/apache/pinot/pql/parsers/PinotQuery2BrokerRequestConverter.java", "diffHunk": "@@ -232,50 +233,32 @@ private AggregationInfo buildAggregationInfo(Function function) {\n       throw new Pql2CompilationException(\"Aggregation function expects non null argument\");\n     }\n \n-    String columnName;\n+    String argumentString;\n     String functionName = function.getOperator();\n \n-    if (functionName.equalsIgnoreCase(AggregationFunctionType.DISTINCT.getName())) {\n-      // DISTINCT can support multiple arguments\n-      if (operands.size() == 1) {\n-        // single column DISTINCT\n-        columnName = getColumnExpression(operands.get(0));\n-      } else {\n-        // multi column DISTINCT\n-        Set<String> expressions = new HashSet<>();\n-        StringBuilder sb = new StringBuilder();\n-        int numOperands = operands.size();\n-        for (int i = 0; i < numOperands; i++) {\n-          Expression expression = operands.get(i);\n-          String columnExpression = getColumnExpression(expression);\n-          if (expressions.add(columnExpression)) {\n-            // deduplicate the columns\n-            if (i != 0) {\n-              sb.append(FunctionCallAstNode.DISTINCT_MULTI_COLUMN_SEPARATOR);\n-            }\n-            sb.append(getColumnExpression(expression));\n+    if (functionName.equalsIgnoreCase(AggregationFunctionType.COUNT.getName())) {\n+      argumentString = \"*\";\n+    } else {\n+      Set<String> expressions = new HashSet<>();\n+      StringBuilder sb = new StringBuilder();\n+      int numOperands = operands.size();\n+      for (int i = 0; i < numOperands; i++) {\n+        Expression expression = operands.get(i);\n+        String columnExpression = getColumnExpression(expression);\n+        if (expressions.add(columnExpression)) {\n+          // deduplicate the columns\n+          if (i != 0) {\n+            sb.append(CompilerConstants.AGGREGATION_FUNCTION_ARG_SEPARATOR);\n           }\n+          sb.append(getColumnExpression(expression));\n         }\n-        columnName = sb.toString();\n-      }\n-    } else {\n-      // other aggregation functions support exactly one argument\n-      if (operands.size() != 1) {\n-        throw new Pql2CompilationException(\n-            \"Aggregation function\" + function.getOperator() + \" expects 1 argument. found: \" + operands);\n-      }\n-\n-      if (functionName.equalsIgnoreCase(AggregationFunctionType.COUNT.getName())) {\n-        columnName = \"*\";\n-      } else {\n-        Expression functionParam = operands.get(0);\n-        columnName = getColumnExpression(functionParam);\n       }\n+      argumentString = sb.toString();\n     }\n \n     AggregationInfo aggregationInfo = new AggregationInfo();\n     aggregationInfo.setAggregationType(functionName);\n-    aggregationInfo.putToAggregationParams(FunctionCallAstNode.COLUMN_KEY_IN_AGGREGATION_INFO, columnName);\n+    aggregationInfo.putToAggregationParams(CompilerConstants.COLUMN_KEY_IN_AGGREGATION_INFO, argumentString);", "originalCommit": "f236728138685d4c19b7bbb876b48a6228ff078b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg4NzAyMw==", "url": "https://github.com/apache/pinot/pull/5259#discussion_r409887023", "bodyText": "AggregationFunctions will do that.", "author": "mayankshriv", "createdAt": "2020-04-16T22:33:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcxNDkzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcxNjU2Mg==", "url": "https://github.com/apache/pinot/pull/5259#discussion_r409716562", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import static org.apache.pinot.parsers.CompilerConstants.AGGREGATION_FUNCTION_ARG_SEPARATOR;\n          \n          \n            \n            import org.apache.pinot.parsers.CompilerConstants;", "author": "mcvsubbu", "createdAt": "2020-04-16T17:10:22Z", "path": "pinot-common/src/main/java/org/apache/pinot/pql/parsers/pql2/ast/FunctionCallAstNode.java", "diffHunk": "@@ -24,9 +24,11 @@\n import org.apache.pinot.common.function.AggregationFunctionType;\n import org.apache.pinot.common.request.AggregationInfo;\n import org.apache.pinot.common.request.transform.TransformExpressionTree;\n-import org.apache.pinot.spi.utils.EqualityUtils;\n+import org.apache.pinot.parsers.CompilerConstants;\n import org.apache.pinot.pql.parsers.Pql2CompilationException;\n-import org.apache.pinot.pql.parsers.Pql2Compiler;\n+import org.apache.pinot.spi.utils.EqualityUtils;\n+\n+import static org.apache.pinot.parsers.CompilerConstants.AGGREGATION_FUNCTION_ARG_SEPARATOR;", "originalCommit": "f236728138685d4c19b7bbb876b48a6228ff078b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcyMjY3Mw==", "url": "https://github.com/apache/pinot/pull/5259#discussion_r409722673", "bodyText": "wouldnt the code from line 88 to 92 hold here as well? Can we move the call to function.aggregate() below, initializing the map differently (or, are we optimizing the map creation here with Collections.singletonMap())", "author": "mcvsubbu", "createdAt": "2020-04-16T17:20:38Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/DefaultAggregationExecutor.java", "diffHunk": "@@ -76,22 +78,22 @@ public void aggregate(TransformBlock transformBlock) {\n       AggregationResultHolder resultHolder = _resultHolders[i];\n       if (function.getType() == AggregationFunctionType.COUNT) {\n         // handle count(*) function\n-        function.aggregate(length, resultHolder);\n+        function.aggregate(length, resultHolder, Collections.emptyMap());\n       } else if (function.getType() == AggregationFunctionType.DISTINCT) {\n         // handle distinct (col1, col2..) function\n         // unlike other aggregate functions, distinct can work on multiple columns\n         // so we get all the projected columns (ProjectionBlockValSet) from TransformBlock\n         // for each column and then pass them over to distinct function since the uniqueness\n         // will be determined across tuples and not on a per column basis\n-        BlockValSet[] blockValSets = new BlockValSet[_expressions.length];\n+        Map<String, BlockValSet> blockValSetMap = new HashMap<>();\n         for (int j = 0; j < _expressions.length; j++) {\n-          blockValSets[j] = transformBlock.getBlockValueSet(_expressions[j]);\n+          blockValSetMap.put(_expressions[j].toString(), transformBlock.getBlockValueSet(_expressions[j]));\n         }\n-        DistinctAggregationFunction distinctFunction = (DistinctAggregationFunction) function;\n-        distinctFunction.aggregate(length, resultHolder, blockValSets);\n+        function.aggregate(length, resultHolder, blockValSetMap);\n       } else {\n         // handle rest of the aggregate functions -- sum, min, max etc\n-        function.aggregate(length, resultHolder, transformBlock.getBlockValueSet(_expressions[i]));\n+        function.aggregate(length, resultHolder,", "originalCommit": "f236728138685d4c19b7bbb876b48a6228ff078b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg4ODc2Mg==", "url": "https://github.com/apache/pinot/pull/5259#discussion_r409888762", "bodyText": "I left the optimization for now because we want to clean up the DISTINCT special casing anyways.", "author": "mayankshriv", "createdAt": "2020-04-16T22:38:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcyMjY3Mw=="}], "type": "inlineReview"}, {"oid": "b86aba552ac25c68581d71f34c6a2b8a17e3d9a7", "url": "https://github.com/apache/pinot/commit/b86aba552ac25c68581d71f34c6a2b8a17e3d9a7", "message": "Support Aggregation functions with multiple arguments.\n\nThe current implementation assumes that all AggregationFunctions take one argument\nwith the exception of DistinctAggregationFunction. This PR handles changes related\nto supporting AggregationFunctions with multiple arguments, as we anticipate new\naggregation functions to be added that take multiple arguments.\n\n1. Enhanced parser to allow multiple arguments for aggregation functions.\n2. AggregationFunctionFactory provides the right set of arguments when instantiating\n   individual aggregation functions.\n3. AggregationFunctions now store their arguments, as opposed to assuming that the right\n   BlockValSet is passed to the aggregate() api's.\n4. AggregationFunction.aggregate() api's now take a Map<String, BlockValSet> where the key\n   is the argument expression (columnName for simple case), as opposed to a variable array\n   as that interface does not provide a way to associate BlockValSet with the argument.\n5. Cleanup: Removed env variable to enable/disable Distinct, as there is no need for it to be\n   disabled anymore.", "committedDate": "2020-04-16T21:30:46Z", "type": "forcePushed"}, {"oid": "83913bdb05383c3ba68beeab199b39a6f64cf2c7", "url": "https://github.com/apache/pinot/commit/83913bdb05383c3ba68beeab199b39a6f64cf2c7", "message": "Support Aggregation functions with multiple arguments.\n\nThe current implementation assumes that all AggregationFunctions take one argument\nwith the exception of DistinctAggregationFunction. This PR handles changes related\nto supporting AggregationFunctions with multiple arguments, as we anticipate new\naggregation functions to be added that take multiple arguments.\n\n1. Enhanced parser to allow multiple arguments for aggregation functions.\n2. AggregationFunctionFactory provides the right set of arguments when instantiating\n   individual aggregation functions.\n3. AggregationFunctions now store their arguments, as opposed to assuming that the right\n   BlockValSet is passed to the aggregate() api's.\n4. AggregationFunction.aggregate() api's now take a Map<String, BlockValSet> where the key\n   is the argument expression (columnName for simple case), as opposed to a variable array\n   as that interface does not provide a way to associate BlockValSet with the argument.\n5. Cleanup: Removed env variable to enable/disable Distinct, as there is no need for it to be\n   disabled anymore.", "committedDate": "2020-04-16T22:40:19Z", "type": "forcePushed"}, {"oid": "cdca55d3b7108f631f420b9a881ca390f26a1572", "url": "https://github.com/apache/pinot/commit/cdca55d3b7108f631f420b9a881ca390f26a1572", "message": "Support Aggregation functions with multiple arguments.\n\nThe current implementation assumes that all AggregationFunctions take one argument\nwith the exception of DistinctAggregationFunction. This PR handles changes related\nto supporting AggregationFunctions with multiple arguments, as we anticipate new\naggregation functions to be added that take multiple arguments.\n\n1. Enhanced parser to allow multiple arguments for aggregation functions.\n2. AggregationFunctionFactory provides the right set of arguments when instantiating\n   individual aggregation functions.\n3. AggregationFunctions now store their arguments, as opposed to assuming that the right\n   BlockValSet is passed to the aggregate() api's.\n4. AggregationFunction.aggregate() api's now take a Map<String, BlockValSet> where the key\n   is the argument expression (columnName for simple case), as opposed to a variable array\n   as that interface does not provide a way to associate BlockValSet with the argument.\n5. Cleanup: Removed env variable to enable/disable Distinct, as there is no need for it to be\n   disabled anymore.", "committedDate": "2020-04-16T23:36:24Z", "type": "commit"}, {"oid": "cdca55d3b7108f631f420b9a881ca390f26a1572", "url": "https://github.com/apache/pinot/commit/cdca55d3b7108f631f420b9a881ca390f26a1572", "message": "Support Aggregation functions with multiple arguments.\n\nThe current implementation assumes that all AggregationFunctions take one argument\nwith the exception of DistinctAggregationFunction. This PR handles changes related\nto supporting AggregationFunctions with multiple arguments, as we anticipate new\naggregation functions to be added that take multiple arguments.\n\n1. Enhanced parser to allow multiple arguments for aggregation functions.\n2. AggregationFunctionFactory provides the right set of arguments when instantiating\n   individual aggregation functions.\n3. AggregationFunctions now store their arguments, as opposed to assuming that the right\n   BlockValSet is passed to the aggregate() api's.\n4. AggregationFunction.aggregate() api's now take a Map<String, BlockValSet> where the key\n   is the argument expression (columnName for simple case), as opposed to a variable array\n   as that interface does not provide a way to associate BlockValSet with the argument.\n5. Cleanup: Removed env variable to enable/disable Distinct, as there is no need for it to be\n   disabled anymore.", "committedDate": "2020-04-16T23:36:24Z", "type": "forcePushed"}]}