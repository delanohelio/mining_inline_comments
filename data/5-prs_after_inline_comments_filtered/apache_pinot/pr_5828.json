{"pr_number": 5828, "pr_title": "Improving retention manager to handle segment lineage clean-up", "pr_createdAt": "2020-08-07T10:51:15Z", "pr_url": "https://github.com/apache/pinot/pull/5828", "timeline": [{"oid": "b8fbed339339a04ecb47b49fabc7fe9e3fc77a40", "url": "https://github.com/apache/pinot/commit/b8fbed339339a04ecb47b49fabc7fe9e3fc77a40", "message": "Improving retention manager to handle segment lineage clean-up\n\n1. Added the logic to handle segment lineage clean-up in the\n   retention manager.\n2. Added the unit test", "committedDate": "2020-08-07T10:50:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3MzExNg==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467173116", "bodyText": "Don't log this as this can flood the log for large cluster", "author": "Jackie-Jiang", "createdAt": "2020-08-07T17:26:30Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,87 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);", "originalCommit": "b8fbed339339a04ecb47b49fabc7fe9e3fc77a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM1Mjg3Nw==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467352877", "bodyText": "removed", "author": "snleee", "createdAt": "2020-08-08T02:58:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3MzExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3NDM1Nw==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467174357", "bodyText": "Remove the null check which is redundant", "author": "Jackie-Jiang", "createdAt": "2020-08-07T17:29:02Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,87 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);\n+          return true;\n+        }\n+        SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        int expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // Delete segments based on the segment lineage\n+        PinotResourceManagerResponse response = _pinotHelixResourceManager\n+            .deleteSegments(tableNameWithType, computeSegmentsToDeleteFromSegmentLineage(segmentLineage));\n+\n+        Assert.assertTrue(response.isSuccessful());\n+\n+        // Fetch available segments for the table\n+        Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));\n+\n+        // Clean up the segment lineage\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+          if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+            // The lineage entry for 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n+            // are all removed from the table.\n+            if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n+                .disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n+              segmentLineage.deleteLineageEntry(lineageEntryId);\n+            }\n+          } else if (lineageEntry.getState() == LineageEntryState.IN_PROGRESS) {\n+            // Zombie lineage entry is safe to remove. This will allow the task scheduler to re-schedule the\n+            // source segments to be merged again.\n+            segmentLineage.deleteLineageEntry(lineageEntryId);\n+          }\n+        }\n+\n+        // Write back to the lineage entry\n+        return SegmentLineageAccessHelper\n+            .writeSegmentLineage(_pinotHelixResourceManager.getPropertyStore(), segmentLineage, expectedVersion);\n+      });\n+    } catch (Exception e) {\n+      String errorMsg = String.format(\"Failed to clean up the segment lineage. (tableName = %s)\", tableNameWithType);\n+      LOGGER.error(errorMsg, e);\n+      throw new RuntimeException(errorMsg, e);\n+    }\n+    LOGGER.info(\"Segment lineage metadata clean-up is successfully processed for table: {}\", tableNameWithType);\n+  }\n+\n+  /**\n+   * Compute the segments that can be safely deleted based on the segment lineage.\n+   *\n+   * 1. The original segments can be deleted once the merged segments are successfully uploaded.\n+   * 2. If the segmentReplacement operation fails in the middle, there can be a case where partial segments are\n+   *    uploaded to the table. We should periodically clean up those zombie segments.\n+   */\n+  private List<String> computeSegmentsToDeleteFromSegmentLineage(SegmentLineage segmentLineage) {\n+    if (segmentLineage != null) {", "originalCommit": "b8fbed339339a04ecb47b49fabc7fe9e3fc77a40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MDk5OA==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467180998", "bodyText": "Don't use Assert, use Preconditions instead", "author": "Jackie-Jiang", "createdAt": "2020-08-07T17:42:57Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,87 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);\n+          return true;\n+        }\n+        SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        int expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // Delete segments based on the segment lineage\n+        PinotResourceManagerResponse response = _pinotHelixResourceManager\n+            .deleteSegments(tableNameWithType, computeSegmentsToDeleteFromSegmentLineage(segmentLineage));\n+\n+        Assert.assertTrue(response.isSuccessful());", "originalCommit": "b8fbed339339a04ecb47b49fabc7fe9e3fc77a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM1Mjk0MQ==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467352941", "bodyText": "Good catch. I was writing a testing code right before I wrote this part :)", "author": "snleee", "createdAt": "2020-08-08T02:59:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MDk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MTU2NA==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467181564", "bodyText": "This won't give you the up-to-date segment list because we delay the deletion of segment ZK metadata", "author": "Jackie-Jiang", "createdAt": "2020-08-07T17:44:08Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,87 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);\n+          return true;\n+        }\n+        SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        int expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // Delete segments based on the segment lineage\n+        PinotResourceManagerResponse response = _pinotHelixResourceManager\n+            .deleteSegments(tableNameWithType, computeSegmentsToDeleteFromSegmentLineage(segmentLineage));\n+\n+        Assert.assertTrue(response.isSuccessful());\n+\n+        // Fetch available segments for the table\n+        Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));", "originalCommit": "b8fbed339339a04ecb47b49fabc7fe9e3fc77a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4Mjk3Mg==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467182972", "bodyText": "The lineage deletion can be handled along with the segment deletion", "author": "Jackie-Jiang", "createdAt": "2020-08-07T17:46:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MTU2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM1MzY5MQ==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467353691", "bodyText": "Changed the logic to handle together.", "author": "snleee", "createdAt": "2020-08-08T03:07:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MTU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MjQzNA==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467182434", "bodyText": "Can we directly remove the lineage entry here? Why do we need to wait for all merged segments also being removed?", "author": "Jackie-Jiang", "createdAt": "2020-08-07T17:45:54Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,87 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);\n+          return true;\n+        }\n+        SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        int expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // Delete segments based on the segment lineage\n+        PinotResourceManagerResponse response = _pinotHelixResourceManager\n+            .deleteSegments(tableNameWithType, computeSegmentsToDeleteFromSegmentLineage(segmentLineage));\n+\n+        Assert.assertTrue(response.isSuccessful());\n+\n+        // Fetch available segments for the table\n+        Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));\n+\n+        // Clean up the segment lineage\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+          if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+            // The lineage entry for 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n+            // are all removed from the table.\n+            if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n+                .disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n+              segmentLineage.deleteLineageEntry(lineageEntryId);\n+            }\n+          } else if (lineageEntry.getState() == LineageEntryState.IN_PROGRESS) {\n+            // Zombie lineage entry is safe to remove. This will allow the task scheduler to re-schedule the\n+            // source segments to be merged again.\n+            segmentLineage.deleteLineageEntry(lineageEntryId);\n+          }\n+        }\n+\n+        // Write back to the lineage entry\n+        return SegmentLineageAccessHelper\n+            .writeSegmentLineage(_pinotHelixResourceManager.getPropertyStore(), segmentLineage, expectedVersion);\n+      });\n+    } catch (Exception e) {\n+      String errorMsg = String.format(\"Failed to clean up the segment lineage. (tableName = %s)\", tableNameWithType);\n+      LOGGER.error(errorMsg, e);\n+      throw new RuntimeException(errorMsg, e);\n+    }\n+    LOGGER.info(\"Segment lineage metadata clean-up is successfully processed for table: {}\", tableNameWithType);\n+  }\n+\n+  /**\n+   * Compute the segments that can be safely deleted based on the segment lineage.\n+   *\n+   * 1. The original segments can be deleted once the merged segments are successfully uploaded.\n+   * 2. If the segmentReplacement operation fails in the middle, there can be a case where partial segments are\n+   *    uploaded to the table. We should periodically clean up those zombie segments.\n+   */\n+  private List<String> computeSegmentsToDeleteFromSegmentLineage(SegmentLineage segmentLineage) {\n+    if (segmentLineage != null) {\n+      List<String> segmentsToDelete = new ArrayList<>();\n+      for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+        LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+        if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+          // If the lineage state is 'COMPLETED', it is safe to delete all segments from 'segmentsFrom'\n+          segmentsToDelete.addAll(lineageEntry.getSegmentsFrom());", "originalCommit": "b8fbed339339a04ecb47b49fabc7fe9e3fc77a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM1MzY2NQ==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467353665", "bodyText": "I initially was thinking of the race condition.\n\nRetention manager invoke delete segments (happens with some delay in the background)\nRetention manager writes new lineage segment to ZK (this update happens first)\nbroker updates the routing table before segments get deleted.\n\nIn this case, it's possible that we may route the query to the original segments for the short term. How do you think on this?", "author": "snleee", "createdAt": "2020-08-08T03:07:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MjQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM1NjM4Mg==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467356382", "bodyText": "Actually, if we don't send out the routing table refresh message explicitly, the routing table rebuild will only get triggered after the segment gets deleted. So, it will always be the following sequence:\n\nRetention manager deletes segments, update segment lineage metadata (one of 2 operation can happen earlier).\nBroker side routing table updates will only happen after the segment is deleted (by EV change).\n\nAs long as we have the guarantee that the routing table gets updated after the segment is deleted, we are good.", "author": "snleee", "createdAt": "2020-08-08T03:40:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MjQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUwMzIxMA==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467503210", "bodyText": "Good point. In this case, we should always delete the lineage entry only if the segments are already deleted (for both COMPLETED and IN_PROGRESS).\nThe logic should be:\nIf any of the segments (segmentsFrom for COMPLETED and segmentsTo for IN_PROGRESS) still exists, delete the existing segments; if they are all already deleted, delete the lineage entry.", "author": "Jackie-Jiang", "createdAt": "2020-08-08T20:51:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MjQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzczMjQ3Nw==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467732477", "bodyText": "@Jackie-Jiang For checking whether the segment is deleted, do you think checking getSegmentsFor(tableName) <- looks at segment zk metadata is good enough? Or checking idealstate is preferred?", "author": "snleee", "createdAt": "2020-08-10T07:36:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MjQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA2NjMzNw==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r468066337", "bodyText": "@snleee Checking ZK metadata is fine. That can prevent leaving orphan segment ZK metadata", "author": "Jackie-Jiang", "createdAt": "2020-08-10T17:33:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MjQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIwMDY1MQ==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r468200651", "bodyText": "Sounds good.", "author": "snleee", "createdAt": "2020-08-10T21:38:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MjQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MzI4Mw==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467183283", "bodyText": "This part is wrong. This will remove the real in-progress lineage", "author": "Jackie-Jiang", "createdAt": "2020-08-07T17:47:35Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,87 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);\n+          return true;\n+        }\n+        SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        int expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // Delete segments based on the segment lineage\n+        PinotResourceManagerResponse response = _pinotHelixResourceManager\n+            .deleteSegments(tableNameWithType, computeSegmentsToDeleteFromSegmentLineage(segmentLineage));\n+\n+        Assert.assertTrue(response.isSuccessful());\n+\n+        // Fetch available segments for the table\n+        Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));\n+\n+        // Clean up the segment lineage\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+          if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+            // The lineage entry for 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n+            // are all removed from the table.\n+            if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n+                .disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n+              segmentLineage.deleteLineageEntry(lineageEntryId);\n+            }\n+          } else if (lineageEntry.getState() == LineageEntryState.IN_PROGRESS) {\n+            // Zombie lineage entry is safe to remove. This will allow the task scheduler to re-schedule the\n+            // source segments to be merged again.\n+            segmentLineage.deleteLineageEntry(lineageEntryId);", "originalCommit": "b8fbed339339a04ecb47b49fabc7fe9e3fc77a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM1NjQ0Nw==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467356447", "bodyText": "fixed", "author": "snleee", "createdAt": "2020-08-08T03:40:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MzI4Mw=="}], "type": "inlineReview"}, {"oid": "92635d800638f2a807919c912bffefc3d94d7686", "url": "https://github.com/apache/pinot/commit/92635d800638f2a807919c912bffefc3d94d7686", "message": "Addressing comments", "committedDate": "2020-08-08T03:41:53Z", "type": "forcePushed"}, {"oid": "9a35e7ae53dcefd59cf2c2d3a14074b06d918802", "url": "https://github.com/apache/pinot/commit/9a35e7ae53dcefd59cf2c2d3a14074b06d918802", "message": "Addressing comments", "committedDate": "2020-08-08T03:43:20Z", "type": "forcePushed"}, {"oid": "2a5b3d491ad5201f1460d0272d92c65f74717904", "url": "https://github.com/apache/pinot/commit/2a5b3d491ad5201f1460d0272d92c65f74717904", "message": "Addressing comments", "committedDate": "2020-08-10T07:49:57Z", "type": "forcePushed"}, {"oid": "8bf18a75012e905f379a3a292099ad6333591af1", "url": "https://github.com/apache/pinot/commit/8bf18a75012e905f379a3a292099ad6333591af1", "message": "Addressing comments", "committedDate": "2020-08-10T07:55:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA3MjcwOQ==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r468072709", "bodyText": "We can simplify the logic as following, same for IN_PROGRESS\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        segmentsToDelete.addAll(lineageEntry.getSegmentsFrom());\n          \n          \n            \n            \n          \n          \n            \n                        // The lineage entry with 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n          \n          \n            \n                        // are all removed from the table.\n          \n          \n            \n                        if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n          \n          \n            \n                            .disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n          \n          \n            \n                          segmentLineage.deleteLineageEntry(lineageEntryId);\n          \n          \n            \n                        }\n          \n          \n            \n                        Set<String> sourceSegments = new HashSet<>(lineageEntry.getSegmentsFrom());\n          \n          \n            \n                        sourceSegments.retainAll(segmentsForTable);\n          \n          \n            \n                        if (sourceSegments.isEmpty()) {\n          \n          \n            \n                          segmentLineage.deleteLineageEntry(lineageEntryId);\n          \n          \n            \n                        } else {\n          \n          \n            \n                          segmentsToDelete.addAll(sourceSegments);\n          \n          \n            \n                        }", "author": "Jackie-Jiang", "createdAt": "2020-08-10T17:45:05Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,63 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          return true;\n+        }\n+        SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        int expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // 1. The original segments can be deleted once the merged segments are successfully uploaded\n+        // 2. The zombie lineage entry & merged segments should be deleted if the segment replacement failed in\n+        //    the middle\n+        Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));\n+        List<String> segmentsToDelete = new ArrayList<>();\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+          if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+            // If the lineage state is 'COMPLETED', it is safe to delete all segments from 'segmentsFrom'\n+            segmentsToDelete.addAll(lineageEntry.getSegmentsFrom());\n+\n+            // The lineage entry with 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n+            // are all removed from the table.\n+            if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n+                .disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n+              segmentLineage.deleteLineageEntry(lineageEntryId);\n+            }", "originalCommit": "8bf18a75012e905f379a3a292099ad6333591af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIwMDUzMA==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r468200530", "bodyText": "Changed. Please double check the logic for IN_PROGRESS as well.", "author": "snleee", "createdAt": "2020-08-10T21:37:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA3MjcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA3NzY4Mw==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r468077683", "bodyText": "We might want to delete segments after successfully writing back the lineage, or the segment might be deleted without updating the lineage", "author": "Jackie-Jiang", "createdAt": "2020-08-10T17:53:32Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,63 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          return true;\n+        }\n+        SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        int expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // 1. The original segments can be deleted once the merged segments are successfully uploaded\n+        // 2. The zombie lineage entry & merged segments should be deleted if the segment replacement failed in\n+        //    the middle\n+        Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));\n+        List<String> segmentsToDelete = new ArrayList<>();\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+          if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+            // If the lineage state is 'COMPLETED', it is safe to delete all segments from 'segmentsFrom'\n+            segmentsToDelete.addAll(lineageEntry.getSegmentsFrom());\n+\n+            // The lineage entry with 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n+            // are all removed from the table.\n+            if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n+                .disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n+              segmentLineage.deleteLineageEntry(lineageEntryId);\n+            }\n+          } else if (lineageEntry.getState() == LineageEntryState.IN_PROGRESS) {\n+            // If the lineage state is 'IN_PROGRESS', we need to clean up the zombie lineage entry and its segments\n+            if (lineageEntry.getTimestamp() < System.currentTimeMillis() - LINEAGE_ENTRY_CLEANUP_RETENTION_IN_MILLIS) {\n+              segmentsToDelete.addAll(lineageEntry.getSegmentsTo());\n+\n+              // The lineage entry with 'IN_PROGRESS' state can only be safely removed when segmentTo are all removed\n+              // from the table. Deleting lineage will allow the task scheduler to re-schedule the source segments to\n+              // be merged again.\n+              if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n+                segmentLineage.deleteLineageEntry(lineageEntryId);\n+              }\n+            }\n+          }\n+        }\n+\n+        // Delete segments based on the segment lineage\n+        _pinotHelixResourceManager.deleteSegments(tableNameWithType, segmentsToDelete);", "originalCommit": "8bf18a75012e905f379a3a292099ad6333591af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIwMDMzOQ==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r468200339", "bodyText": "fixed", "author": "snleee", "createdAt": "2020-08-10T21:37:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA3NzY4Mw=="}], "type": "inlineReview"}, {"oid": "7dc5b3b9cd3bae1e44dbac7a51cd5cf57d16e50d", "url": "https://github.com/apache/pinot/commit/7dc5b3b9cd3bae1e44dbac7a51cd5cf57d16e50d", "message": "Addressing comments", "committedDate": "2020-08-10T21:38:21Z", "type": "forcePushed"}, {"oid": "3a637b9271a2177f6e70c80cf64b5f6c95e36de1", "url": "https://github.com/apache/pinot/commit/3a637b9271a2177f6e70c80cf64b5f6c95e36de1", "message": "Addressing comments", "committedDate": "2020-08-10T21:38:58Z", "type": "commit"}, {"oid": "3a637b9271a2177f6e70c80cf64b5f6c95e36de1", "url": "https://github.com/apache/pinot/commit/3a637b9271a2177f6e70c80cf64b5f6c95e36de1", "message": "Addressing comments", "committedDate": "2020-08-10T21:38:58Z", "type": "forcePushed"}]}