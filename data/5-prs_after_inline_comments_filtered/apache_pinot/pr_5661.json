{"pr_number": 5661, "pr_title": "Optimize selection order-by when not all selected expressions are ordered", "pr_createdAt": "2020-07-07T01:44:21Z", "pr_url": "https://github.com/apache/pinot/pull/5661", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU5MDI2NQ==", "url": "https://github.com/apache/pinot/pull/5661#discussion_r450590265", "bodyText": "not sure if this a valid check. what if the expressions are functions?", "author": "kishoreg", "createdAt": "2020-07-07T03:23:20Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java", "diffHunk": "@@ -143,24 +167,134 @@ public SelectionOrderByOperator(IndexSegment indexSegment, QueryContext queryCon\n \n   @Override\n   protected IntermediateResultsBlock getNextBlock() {\n-    TransformBlock transformBlock;\n-    while ((transformBlock = _transformOperator.nextBlock()) != null) {\n-      int numExpressions = _expressions.size();\n+    int numExpressions = _expressions.size();\n+    int numOrderByExpressions = _orderByExpressions.size();\n+\n+    if (numExpressions == numOrderByExpressions) {", "originalCommit": "b76a63b21899d1099651484edf07e44047f5baaa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE1MjU1Mg==", "url": "https://github.com/apache/pinot/pull/5661#discussion_r451152552", "bodyText": "Both order-by and selected expressions can be identifiers or functions. Expressions here are order-by expressions followed by non-order-by expressions (deduplicated, see SelectionOperatorUtils.extractExpressions() for more details.", "author": "Jackie-Jiang", "createdAt": "2020-07-07T21:25:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU5MDI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU5MDM2Nw==", "url": "https://github.com/apache/pinot/pull/5661#discussion_r450590367", "bodyText": "can we extract the if and else into separate methods for readability", "author": "kishoreg", "createdAt": "2020-07-07T03:23:50Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java", "diffHunk": "@@ -143,24 +167,134 @@ public SelectionOrderByOperator(IndexSegment indexSegment, QueryContext queryCon\n \n   @Override\n   protected IntermediateResultsBlock getNextBlock() {\n-    TransformBlock transformBlock;\n-    while ((transformBlock = _transformOperator.nextBlock()) != null) {\n-      int numExpressions = _expressions.size();\n+    int numExpressions = _expressions.size();\n+    int numOrderByExpressions = _orderByExpressions.size();\n+\n+    if (numExpressions == numOrderByExpressions) {\n+      // All selected expressions are ordered\n+\n       BlockValSet[] blockValSets = new BlockValSet[numExpressions];\n+      TransformBlock transformBlock;\n+      while ((transformBlock = _transformOperator.nextBlock()) != null) {\n+        for (int i = 0; i < numExpressions; i++) {\n+          ExpressionContext expression = _expressions.get(i);\n+          blockValSets[i] = transformBlock.getBlockValueSet(expression);\n+        }\n+        RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n+        int numDocsFetched = transformBlock.getNumDocs();\n+        _numDocsScanned += numDocsFetched;\n+        for (int i = 0; i < numDocsFetched; i++) {\n+          SelectionOperatorUtils.addToPriorityQueue(blockValueFetcher.getRow(i), _rows, _numRowsToKeep);\n+        }\n+      }\n+      _numEntriesScannedPostFilter = (long) _numDocsScanned * _transformOperator.getNumColumnsProjected();\n+\n+      String[] columnNames = new String[numExpressions];\n+      DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[numExpressions];\n       for (int i = 0; i < numExpressions; i++) {\n-        ExpressionContext expression = _expressions.get(i);\n-        blockValSets[i] = transformBlock.getBlockValueSet(expression);\n+        columnNames[i] = _expressions.get(i).toString();\n+        TransformResultMetadata expressionMetadata = _orderByExpressionMetadata[i];\n+        columnDataTypes[i] = DataSchema.ColumnDataType\n+            .fromDataType(expressionMetadata.getDataType(), expressionMetadata.isSingleValue());\n       }\n-      RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n+      return new IntermediateResultsBlock(new DataSchema(columnNames, columnDataTypes), _rows);\n+    } else {", "originalCommit": "b76a63b21899d1099651484edf07e44047f5baaa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU5MTc0Mw==", "url": "https://github.com/apache/pinot/pull/5661#discussion_r450591743", "bodyText": "can we refer to them as output expressions and orderBy expressions?\nthe two cases output expressions == orderby expressions\norderby expression is small part of output expressions", "author": "kishoreg", "createdAt": "2020-07-07T03:29:43Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java", "diffHunk": "@@ -20,72 +20,96 @@\n \n import java.util.ArrayList;\n import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Map;\n import java.util.PriorityQueue;\n+import java.util.Set;\n+import org.apache.pinot.common.utils.CommonConstants.Segment.BuiltInVirtualColumn;\n import org.apache.pinot.common.utils.DataSchema;\n import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.common.DataSource;\n import org.apache.pinot.core.common.RowBasedBlockValueFetcher;\n import org.apache.pinot.core.indexsegment.IndexSegment;\n import org.apache.pinot.core.operator.BaseOperator;\n import org.apache.pinot.core.operator.ExecutionStatistics;\n+import org.apache.pinot.core.operator.ProjectionOperator;\n+import org.apache.pinot.core.operator.blocks.DocIdSetBlock;\n import org.apache.pinot.core.operator.blocks.IntermediateResultsBlock;\n import org.apache.pinot.core.operator.blocks.TransformBlock;\n import org.apache.pinot.core.operator.transform.TransformOperator;\n import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n import org.apache.pinot.core.query.request.context.ExpressionContext;\n import org.apache.pinot.core.query.request.context.OrderByExpressionContext;\n import org.apache.pinot.core.query.request.context.QueryContext;\n import org.apache.pinot.core.query.selection.SelectionOperatorUtils;\n import org.apache.pinot.spi.data.FieldSpec.DataType;\n import org.apache.pinot.spi.utils.ByteArray;\n+import org.roaringbitmap.IntIterator;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n \n \n+/**\n+ * Operator for selection order-by queries.\n+ * <p>The operator uses a priority queue to sort the rows and return the top rows based on the order-by expressions.\n+ * <p>It is optimized to fetch only the values needed for the ordering purpose and the final result:\n+ * <ul>\n+ *   <li>\n+ *     When all the selected expressions are ordered, the operator fetches all the expressions and insert them into the", "originalCommit": "b76a63b21899d1099651484edf07e44047f5baaa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "44f30443a1d45fa61b6d371278da4ef1027a6341", "url": "https://github.com/apache/pinot/commit/44f30443a1d45fa61b6d371278da4ef1027a6341", "message": "Optimize selection order-by when not all selected expressions are ordered", "committedDate": "2020-07-07T22:20:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MDI5MQ==", "url": "https://github.com/apache/pinot/pull/5661#discussion_r451270291", "bodyText": "Nit for readability: either add a variable, or a comment to indicate row[numOrderByExpressions] has the docId.", "author": "mayankshriv", "createdAt": "2020-07-08T04:05:49Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java", "diffHunk": "@@ -143,24 +168,145 @@ public SelectionOrderByOperator(IndexSegment indexSegment, QueryContext queryCon\n \n   @Override\n   protected IntermediateResultsBlock getNextBlock() {\n+    if (_expressions.size() == _orderByExpressions.size()) {\n+      return computeAllOrdered();\n+    } else {\n+      return computePartiallyOrdered();\n+    }\n+  }\n+\n+  /**\n+   * Helper method to compute the result when all the output expressions are ordered.\n+   */\n+  private IntermediateResultsBlock computeAllOrdered() {\n+    int numExpressions = _expressions.size();\n+\n+    // Fetch all the expressions and insert them into the priority queue\n+    BlockValSet[] blockValSets = new BlockValSet[numExpressions];\n     TransformBlock transformBlock;\n     while ((transformBlock = _transformOperator.nextBlock()) != null) {\n-      int numExpressions = _expressions.size();\n-      BlockValSet[] blockValSets = new BlockValSet[numExpressions];\n       for (int i = 0; i < numExpressions; i++) {\n         ExpressionContext expression = _expressions.get(i);\n         blockValSets[i] = transformBlock.getBlockValueSet(expression);\n       }\n       RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n-\n       int numDocsFetched = transformBlock.getNumDocs();\n       _numDocsScanned += numDocsFetched;\n       for (int i = 0; i < numDocsFetched; i++) {\n         SelectionOperatorUtils.addToPriorityQueue(blockValueFetcher.getRow(i), _rows, _numRowsToKeep);\n       }\n     }\n+    _numEntriesScannedPostFilter = (long) _numDocsScanned * _transformOperator.getNumColumnsProjected();\n \n-    return new IntermediateResultsBlock(_dataSchema, _rows);\n+    // Create the data schema\n+    String[] columnNames = new String[numExpressions];\n+    DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[numExpressions];\n+    for (int i = 0; i < numExpressions; i++) {\n+      columnNames[i] = _expressions.get(i).toString();\n+      TransformResultMetadata expressionMetadata = _orderByExpressionMetadata[i];\n+      columnDataTypes[i] =\n+          DataSchema.ColumnDataType.fromDataType(expressionMetadata.getDataType(), expressionMetadata.isSingleValue());\n+    }\n+    DataSchema dataSchema = new DataSchema(columnNames, columnDataTypes);\n+\n+    return new IntermediateResultsBlock(dataSchema, _rows);\n+  }\n+\n+  /**\n+   * Helper method to compute the result when not all the output expressions are ordered.\n+   */\n+  private IntermediateResultsBlock computePartiallyOrdered() {\n+    int numExpressions = _expressions.size();\n+    int numOrderByExpressions = _orderByExpressions.size();\n+\n+    // Fetch the order-by expressions and docIds and insert them into the priority queue\n+    BlockValSet[] blockValSets = new BlockValSet[numOrderByExpressions + 1];\n+    TransformBlock transformBlock;\n+    while ((transformBlock = _transformOperator.nextBlock()) != null) {\n+      for (int i = 0; i < numOrderByExpressions; i++) {\n+        ExpressionContext expression = _orderByExpressions.get(i).getExpression();\n+        blockValSets[i] = transformBlock.getBlockValueSet(expression);\n+      }\n+      blockValSets[numOrderByExpressions] = transformBlock.getBlockValueSet(BuiltInVirtualColumn.DOCID);\n+      RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n+      int numDocsFetched = transformBlock.getNumDocs();\n+      _numDocsScanned += numDocsFetched;\n+      for (int i = 0; i < numDocsFetched; i++) {\n+        // NOTE: We pre-allocate the complete row so that we can fill up the non-order-by output expression values later\n+        //       without creating extra rows or re-constructing the priority queue. We can change the values in-place\n+        //       because the comparator only compare the values for the order-by expressions.\n+        Object[] row = new Object[numExpressions];\n+        blockValueFetcher.getRow(i, row, 0);\n+        SelectionOperatorUtils.addToPriorityQueue(row, _rows, _numRowsToKeep);\n+      }\n+    }\n+\n+    // Copy the rows (shallow copy so that any modification will also be reflected to the priority queue) into a list,\n+    // and store the document ids into a bitmap\n+    int numRows = _rows.size();\n+    List<Object[]> rowList = new ArrayList<>(numRows);\n+    MutableRoaringBitmap docIds = new MutableRoaringBitmap();\n+    for (Object[] row : _rows) {\n+      rowList.add(row);\n+      docIds.add((int) row[numOrderByExpressions]);", "originalCommit": "44f30443a1d45fa61b6d371278da4ef1027a6341", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3ODc1NQ==", "url": "https://github.com/apache/pinot/pull/5661#discussion_r451278755", "bodyText": "Done", "author": "Jackie-Jiang", "createdAt": "2020-07-08T04:41:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MDI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MTkwOQ==", "url": "https://github.com/apache/pinot/pull/5661#discussion_r451271909", "bodyText": "Not required for this PR, but does it help if we completely defer the fetching of non-orderby expressions until combine phase? I think that might actually improve further quite a bit? We might need to have a segmentId+docId as a virtual column.", "author": "mayankshriv", "createdAt": "2020-07-08T04:12:51Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java", "diffHunk": "@@ -143,24 +168,145 @@ public SelectionOrderByOperator(IndexSegment indexSegment, QueryContext queryCon\n \n   @Override\n   protected IntermediateResultsBlock getNextBlock() {\n+    if (_expressions.size() == _orderByExpressions.size()) {\n+      return computeAllOrdered();\n+    } else {\n+      return computePartiallyOrdered();\n+    }\n+  }\n+\n+  /**\n+   * Helper method to compute the result when all the output expressions are ordered.\n+   */\n+  private IntermediateResultsBlock computeAllOrdered() {\n+    int numExpressions = _expressions.size();\n+\n+    // Fetch all the expressions and insert them into the priority queue\n+    BlockValSet[] blockValSets = new BlockValSet[numExpressions];\n     TransformBlock transformBlock;\n     while ((transformBlock = _transformOperator.nextBlock()) != null) {\n-      int numExpressions = _expressions.size();\n-      BlockValSet[] blockValSets = new BlockValSet[numExpressions];\n       for (int i = 0; i < numExpressions; i++) {\n         ExpressionContext expression = _expressions.get(i);\n         blockValSets[i] = transformBlock.getBlockValueSet(expression);\n       }\n       RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n-\n       int numDocsFetched = transformBlock.getNumDocs();\n       _numDocsScanned += numDocsFetched;\n       for (int i = 0; i < numDocsFetched; i++) {\n         SelectionOperatorUtils.addToPriorityQueue(blockValueFetcher.getRow(i), _rows, _numRowsToKeep);\n       }\n     }\n+    _numEntriesScannedPostFilter = (long) _numDocsScanned * _transformOperator.getNumColumnsProjected();\n \n-    return new IntermediateResultsBlock(_dataSchema, _rows);\n+    // Create the data schema\n+    String[] columnNames = new String[numExpressions];\n+    DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[numExpressions];\n+    for (int i = 0; i < numExpressions; i++) {\n+      columnNames[i] = _expressions.get(i).toString();\n+      TransformResultMetadata expressionMetadata = _orderByExpressionMetadata[i];\n+      columnDataTypes[i] =\n+          DataSchema.ColumnDataType.fromDataType(expressionMetadata.getDataType(), expressionMetadata.isSingleValue());\n+    }\n+    DataSchema dataSchema = new DataSchema(columnNames, columnDataTypes);\n+\n+    return new IntermediateResultsBlock(dataSchema, _rows);\n+  }\n+\n+  /**\n+   * Helper method to compute the result when not all the output expressions are ordered.\n+   */\n+  private IntermediateResultsBlock computePartiallyOrdered() {", "originalCommit": "44f30443a1d45fa61b6d371278da4ef1027a6341", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI4MjM4Nw==", "url": "https://github.com/apache/pinot/pull/5661#discussion_r451282387", "bodyText": "That is possible, and could save some read for high LIMIT queries (which are always expensive), but requires quite big change because that breaks the assumption of one operator only process one segment. After combining the order-by expressions we need to reopen the segments to read the values. For the second round scan, we might also need multi-threading similar to the first round. Not sure if the optimization is worth the overhead.", "author": "Jackie-Jiang", "createdAt": "2020-07-08T04:54:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MTkwOQ=="}], "type": "inlineReview"}, {"oid": "2e0c32b1605764aec30ea609d079e04c4456f7c5", "url": "https://github.com/apache/pinot/commit/2e0c32b1605764aec30ea609d079e04c4456f7c5", "message": "Optimize selection order-by when not all selected expressions are ordered", "committedDate": "2020-07-08T04:38:37Z", "type": "commit"}, {"oid": "9f2c3d8a20355dbcde3bd3dc8cece2d54ab1a1a2", "url": "https://github.com/apache/pinot/commit/9f2c3d8a20355dbcde3bd3dc8cece2d54ab1a1a2", "message": "Address comments", "committedDate": "2020-07-08T04:55:29Z", "type": "commit"}, {"oid": "9f2c3d8a20355dbcde3bd3dc8cece2d54ab1a1a2", "url": "https://github.com/apache/pinot/commit/9f2c3d8a20355dbcde3bd3dc8cece2d54ab1a1a2", "message": "Address comments", "committedDate": "2020-07-08T04:55:29Z", "type": "forcePushed"}]}