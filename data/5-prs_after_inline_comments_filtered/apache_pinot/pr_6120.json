{"pr_number": 6120, "pr_title": "Add FST Index using lucene lib to speedup regexp queries", "pr_createdAt": "2020-10-08T16:50:29Z", "pr_url": "https://github.com/apache/pinot/pull/6120", "timeline": [{"oid": "ca17a6314c2b7d782f39238914a0a20ed39b3c74", "url": "https://github.com/apache/pinot/commit/ca17a6314c2b7d782f39238914a0a20ed39b3c74", "message": "cleanups of logs, unused headers and code", "committedDate": "2020-10-08T23:22:37Z", "type": "forcePushed"}, {"oid": "46fdd9a3fbd3e330dd84523ca4b648f2563b982c", "url": "https://github.com/apache/pinot/commit/46fdd9a3fbd3e330dd84523ca4b648f2563b982c", "message": "Remove preconditions check on bitmapbasedfilteroperation and return empty filter block when no matching dictionary items", "committedDate": "2020-10-14T21:52:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxOTkyNg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515319926", "bodyText": "why null?", "author": "siddharthteotia", "createdAt": "2020-10-30T19:09:56Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -1063,12 +1072,14 @@ void updateMVEntry(int numValuesInMVEntry) {\n       _textIndex = textIndex;\n       _bloomFilter = bloomFilter;\n       _nullValueVector = nullValueVector;\n+      _fstIndexEnabled = fstIndexEnabled;\n     }\n \n     DataSource toDataSource() {\n       return new MutableDataSource(_fieldSpec, _numDocsIndexed, _numValuesInfo._numValues,\n-          _numValuesInfo._maxNumValuesPerMVEntry, _partitionFunction, _partitions, _minValue, _maxValue, _forwardIndex,\n-          _dictionary, _invertedIndex, _rangeIndex, _textIndex, _bloomFilter, _nullValueVector);\n+          _numValuesInfo._maxNumValuesPerMVEntry, _fstIndexEnabled, _partitionFunction, _partitions, _minValue, _maxValue, _forwardIndex,\n+          _dictionary, _invertedIndex, _rangeIndex, _textIndex, null,", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQzNzQzMg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524437432", "bodyText": "FST Index is currently not built for consuming segment, only when the segment is rolled out FST index is\ngenerated", "author": "pradeepgv42", "createdAt": "2020-11-16T17:16:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxOTkyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxOTk0OA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515319948", "bodyText": "Why this change?", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:00Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/BitmapBasedFilterOperator.java", "diffHunk": "@@ -66,8 +67,9 @@ protected FilterBlock getNextBlock() {\n \n     int[] dictIds = _exclusive ? _predicateEvaluator.getNonMatchingDictIds() : _predicateEvaluator.getMatchingDictIds();\n     int numDictIds = dictIds.length;\n-    // NOTE: PredicateEvaluator without matching/non-matching dictionary ids should not reach here.\n-    Preconditions.checkState(numDictIds > 0);\n+    if (numDictIds == 0) {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQzOTIxMw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524439213", "bodyText": "Without this precondition fails, I checked with Jackie who added this condition he mentioned it should be fine to remove this. Reason could be because I enabled regexp operator to use bitmap based filter when FST index is available.", "author": "pradeepgv42", "createdAt": "2020-11-16T17:19:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxOTk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxOTk5Mw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515319993", "bodyText": "Please add javadocs", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:06Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/predicate/FSTBasedRegexpPredicateEvaluatorFactory.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.filter.predicate;\n+\n+\n+import it.unimi.dsi.fastutil.ints.IntArrayList;\n+import it.unimi.dsi.fastutil.ints.IntList;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.segment.index.readers.Dictionary;\n+import org.apache.pinot.core.segment.index.readers.TextIndexReader;\n+import org.apache.pinot.core.util.fst.RegexpMatcher;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+\n+import static org.apache.pinot.core.query.request.context.predicate.Predicate.Type.REGEXP_LIKE;\n+\n+public class FSTBasedRegexpPredicateEvaluatorFactory {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQzOTYwMg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524439602", "bodyText": "done", "author": "pradeepgv42", "createdAt": "2020-11-16T17:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxOTk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDAxNA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320014", "bodyText": "What's the difference between both predicate evaluators?", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:10Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/predicate/FSTBasedRegexpPredicateEvaluatorFactory.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.filter.predicate;\n+\n+\n+import it.unimi.dsi.fastutil.ints.IntArrayList;\n+import it.unimi.dsi.fastutil.ints.IntList;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.segment.index.readers.Dictionary;\n+import org.apache.pinot.core.segment.index.readers.TextIndexReader;\n+import org.apache.pinot.core.util.fst.RegexpMatcher;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+\n+import static org.apache.pinot.core.query.request.context.predicate.Predicate.Type.REGEXP_LIKE;\n+\n+public class FSTBasedRegexpPredicateEvaluatorFactory {\n+    public FSTBasedRegexpPredicateEvaluatorFactory() {}\n+\n+    public static BaseDictionaryBasedPredicateEvaluator newFSTBasedEvaluator(\n+            TextIndexReader fstIndexReader, Dictionary dictionary, String regexpQuery) {\n+        return new FSTBasedRegexpPredicateEvaluatorFactory.FSTBasedRegexpPredicateEvaluator(\n+                fstIndexReader, dictionary, regexpQuery);\n+    }\n+\n+    public static BaseDictionaryBasedPredicateEvaluator newAutomatonBasedEvaluator(\n+            Dictionary dictionary, String regexpQuery) {\n+        return new FSTBasedRegexpPredicateEvaluatorFactory.AutomatonBasedRegexpPredicateEvaluator(\n+                regexpQuery, dictionary);\n+    }\n+\n+    private static class AutomatonBasedRegexpPredicateEvaluator extends BaseDictionaryBasedPredicateEvaluator {\n+        private final RegexpMatcher _regexpMatcher;\n+        private final Dictionary _dictionary;\n+        int[] _matchingDictIds;\n+\n+        public AutomatonBasedRegexpPredicateEvaluator(String searchQuery, Dictionary dictionary) {\n+            _regexpMatcher = new RegexpMatcher(searchQuery, null);\n+            _dictionary = dictionary;\n+        }\n+\n+        @Override\n+        public Predicate.Type getPredicateType() {\n+            return REGEXP_LIKE;\n+        }\n+\n+        @Override\n+        public boolean applySV(int dictId) {\n+            return _regexpMatcher.match(_dictionary.getStringValue(dictId));\n+        }\n+\n+        @Override\n+        public int[] getMatchingDictIds() {\n+            if (_matchingDictIds == null) {\n+                IntList matchingDictIds = new IntArrayList();\n+                int dictionarySize = _dictionary.length();\n+                for (int dictId = 0; dictId < dictionarySize; dictId++) {\n+                    if (applySV(dictId)) {\n+                        matchingDictIds.add(dictId);\n+                    }\n+                }\n+                _matchingDictIds = matchingDictIds.toIntArray();\n+            }\n+            return _matchingDictIds;\n+        }\n+    }\n+\n+    private static class FSTBasedRegexpPredicateEvaluator extends BaseDictionaryBasedPredicateEvaluator {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ0MjcxMQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524442711", "bodyText": "FSTBasedRegexpPredicateEvaluator is used for rolled out segments and AutomatonBasedRegexpPredicateEvaluator for consuming segments. Reason for this is because java regexp matcher is much broader than the regexp matcher I am borrowing from lucene. So, to keep the results consistent between consuming and rolled out segments I am using similar matching logic when fst index is enabled.\nTo reduce complexity here we could either:\n\nswitch regexp_like to use this matching using lucene lib everywhere\nor\ncreate a new operator.\n\nMaybe in future if there is a native automaton building library, this will simplify things.", "author": "pradeepgv42", "createdAt": "2020-11-16T17:24:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDAxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ0Mjk4Mg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524442982", "bodyText": "Added comments too, let me know if I should expand more", "author": "pradeepgv42", "createdAt": "2020-11-16T17:25:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDA0Mw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320043", "bodyText": "Why is the formatting getting changed here?", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:14Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/plan/FilterPlanNode.java", "diffHunk": "@@ -122,8 +127,29 @@ private BaseFilterOperator constructPhysicalOperator(FilterContext filter,\n           DataSource dataSource = _indexSegment.getDataSource(lhs.getIdentifier());\n           switch (predicate.getType()) {\n             case TEXT_MATCH:\n-              return new TextMatchFilterOperator(dataSource.getTextIndex(),\n-                  ((TextMatchPredicate) predicate).getValue(), _numDocs);\n+                return new TextMatchFilterOperator(", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ0MzI1Mg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524443252", "bodyText": "restored.", "author": "pradeepgv42", "createdAt": "2020-11-16T17:25:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDA3Mg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320072", "bodyText": "Why are we checking for the type of data source. getFSTIndex() should return a reader that could have come from a mutable or immutable data source", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:18Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/plan/FilterPlanNode.java", "diffHunk": "@@ -122,8 +127,29 @@ private BaseFilterOperator constructPhysicalOperator(FilterContext filter,\n           DataSource dataSource = _indexSegment.getDataSource(lhs.getIdentifier());\n           switch (predicate.getType()) {\n             case TEXT_MATCH:\n-              return new TextMatchFilterOperator(dataSource.getTextIndex(),\n-                  ((TextMatchPredicate) predicate).getValue(), _numDocs);\n+                return new TextMatchFilterOperator(\n+                        dataSource.getTextIndex(),\n+                        ((TextMatchPredicate) predicate).getValue(),\n+                        _numDocs);\n+            case REGEXP_LIKE:\n+              PredicateEvaluator evaluator = null;\n+              if (dataSource.getFSTIndex() != null) {\n+                evaluator = FSTBasedRegexpPredicateEvaluatorFactory.newFSTBasedEvaluator(\n+                        dataSource.getFSTIndex(),\n+                        dataSource.getDictionary(),\n+                        ((RegexpLikePredicate) predicate).getValue());\n+              } else if (dataSource instanceof MutableDataSource &&", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ0Mzc4NQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524443785", "bodyText": "Added comments, also see my response on above comment (from FSTBasedRegexpPredicateEvaluatorFactory.java)", "author": "pradeepgv42", "createdAt": "2020-11-16T17:26:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDExNw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320117", "bodyText": "Why do we need this method?", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:22Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/realtime/impl/invertedindex/RealtimeLuceneTextIndexReader.java", "diffHunk": "@@ -89,6 +90,11 @@ public void add(String document) {\n     _indexCreator.add(document);\n   }\n \n+  @Override\n+  public ImmutableRoaringBitmap getDictIds(String searchQuery) {\n+    throw new UnsupportedOperationException();", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ0ODI3OA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524448278", "bodyText": "Yeah I agree this is not ideal, but since FST index stores key -> dictid mapping I created this overridable method.\nI moved the FSTIndexCreator to extend TextReader interface too since that looks more closer than inverted index.\nMaybe this could be moved to it's own interface if there are similar indicies in future.", "author": "pradeepgv42", "createdAt": "2020-11-16T17:32:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDE0OA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320148", "bodyText": "Please fix the message", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:26Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -129,6 +132,13 @@ public void init(SegmentGeneratorConfig segmentCreationSpec, SegmentIndexCreatio\n       _textIndexColumns.add(columnName);\n     }\n \n+    for (String columnName : config.getFSTIndexCreationColumns()) {\n+        Preconditions.checkState(\n+                schema.hasColumn(columnName),\n+                \"Cannot create text index for column: %s because it is not in schema\", columnName);", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ0ODc3MA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524448770", "bodyText": "ah sorry for the messup on text/fst, should be fixed now", "author": "pradeepgv42", "createdAt": "2020-11-16T17:32:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDE4MQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320181", "bodyText": "This formatting seems weird", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:31Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -216,7 +226,17 @@ public void init(SegmentGeneratorConfig segmentCreationSpec, SegmentIndexCreatio\n             .put(columnName, new LuceneTextIndexCreator(columnName, _indexDir, true /* commitOnClose */));\n       }\n \n-      _nullHandlingEnabled = config.isNullHandlingEnabled();\n+      if (_fstIndexColumns.contains(columnName) && indexCreationInfo.isCreateDictionary()) {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ0OTMxOA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524449318", "bodyText": "fixed", "author": "pradeepgv42", "createdAt": "2020-11-16T17:33:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDI1MA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320250", "bodyText": "Please add javadocs\nThe interface seems odd. The reader for FST index is using the TextIndexReader but writer/creator is using inverted index creator.\nAlso, this looks like an inverted index creator -- we are adding dictIDs to the FST Index?", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:40Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.creator.impl.inv.text;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import org.apache.lucene.store.OutputStreamDataOutput;\n+import org.apache.lucene.util.fst.FST;\n+import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n+import org.apache.pinot.core.segment.creator.impl.SegmentColumnarIndexCreator;\n+import org.apache.pinot.core.util.fst.FSTBuilder;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+\n+public class LuceneFSTIndexCreator implements DictionaryBasedInvertedIndexCreator {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ1MDExNg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524450116", "bodyText": "Added docs, switched this to TextIndexReader", "author": "pradeepgv42", "createdAt": "2020-11-16T17:34:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDMxOA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320318", "bodyText": "Why NO-OP?\nI think you should explain the algorithm in javadoc", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:49Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.creator.impl.inv.text;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import org.apache.lucene.store.OutputStreamDataOutput;\n+import org.apache.lucene.util.fst.FST;\n+import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n+import org.apache.pinot.core.segment.creator.impl.SegmentColumnarIndexCreator;\n+import org.apache.pinot.core.util.fst.FSTBuilder;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+\n+public class LuceneFSTIndexCreator implements DictionaryBasedInvertedIndexCreator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SegmentColumnarIndexCreator.class);\n+    private final File _fstIndexFile;\n+    public static final String FST_INDEX_FILE_EXTENSION = \".lucene.fst\";\n+    private final FSTBuilder _fstBuilder;\n+\n+    public LuceneFSTIndexCreator(\n+            File indexDir, String columnName,\n+            int cardinality, String[] sortedEntries) throws IOException {\n+        _fstIndexFile = new File(\n+                indexDir, columnName + FST_INDEX_FILE_EXTENSION);\n+\n+        _fstBuilder = new FSTBuilder();\n+\n+        for (int dictId = 0; dictId < cardinality; dictId++) {\n+            if (sortedEntries != null) {\n+                _fstBuilder.addEntry(sortedEntries[dictId], dictId);\n+            }\n+        }\n+    }\n+\n+    // add SortedDicts should be called in sorted order.\n+    public void addSortedDictIds(String document, int dictId) throws IOException {\n+        _fstBuilder.addEntry(document, dictId);\n+    }\n+\n+    @Override\n+    public void add(int dictId) {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ1NDE5Mg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524454192", "bodyText": "fixed it, added doc", "author": "pradeepgv42", "createdAt": "2020-11-16T17:41:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDMxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDM0Ng==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320346", "bodyText": "message seems misleading", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:53Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.creator.impl.inv.text;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import org.apache.lucene.store.OutputStreamDataOutput;\n+import org.apache.lucene.util.fst.FST;\n+import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n+import org.apache.pinot.core.segment.creator.impl.SegmentColumnarIndexCreator;\n+import org.apache.pinot.core.util.fst.FSTBuilder;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+\n+public class LuceneFSTIndexCreator implements DictionaryBasedInvertedIndexCreator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SegmentColumnarIndexCreator.class);\n+    private final File _fstIndexFile;\n+    public static final String FST_INDEX_FILE_EXTENSION = \".lucene.fst\";\n+    private final FSTBuilder _fstBuilder;\n+\n+    public LuceneFSTIndexCreator(\n+            File indexDir, String columnName,\n+            int cardinality, String[] sortedEntries) throws IOException {\n+        _fstIndexFile = new File(\n+                indexDir, columnName + FST_INDEX_FILE_EXTENSION);\n+\n+        _fstBuilder = new FSTBuilder();\n+\n+        for (int dictId = 0; dictId < cardinality; dictId++) {\n+            if (sortedEntries != null) {\n+                _fstBuilder.addEntry(sortedEntries[dictId], dictId);\n+            }\n+        }\n+    }\n+\n+    // add SortedDicts should be called in sorted order.\n+    public void addSortedDictIds(String document, int dictId) throws IOException {\n+        _fstBuilder.addEntry(document, dictId);\n+    }\n+\n+    @Override\n+    public void add(int dictId) {\n+        // NOOP\n+    }\n+\n+    @Override\n+    public void add(int[] dictIds, int length) {\n+        throw new IllegalStateException(\n+                \"LuceneFSTIndexCreator does not support add interface\");\n+    }\n+\n+    @Override\n+    public void seal() throws IOException {\n+        LOGGER.info(\"Sealing the segment for column: \" + _fstIndexFile.getAbsolutePath());", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ1NDgyNg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524454826", "bodyText": "fixed", "author": "pradeepgv42", "createdAt": "2020-11-16T17:42:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDM0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDM2NQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320365", "bodyText": "outputstream.close() should be in finally", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:57Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.creator.impl.inv.text;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import org.apache.lucene.store.OutputStreamDataOutput;\n+import org.apache.lucene.util.fst.FST;\n+import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n+import org.apache.pinot.core.segment.creator.impl.SegmentColumnarIndexCreator;\n+import org.apache.pinot.core.util.fst.FSTBuilder;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+\n+public class LuceneFSTIndexCreator implements DictionaryBasedInvertedIndexCreator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SegmentColumnarIndexCreator.class);\n+    private final File _fstIndexFile;\n+    public static final String FST_INDEX_FILE_EXTENSION = \".lucene.fst\";\n+    private final FSTBuilder _fstBuilder;\n+\n+    public LuceneFSTIndexCreator(\n+            File indexDir, String columnName,\n+            int cardinality, String[] sortedEntries) throws IOException {\n+        _fstIndexFile = new File(\n+                indexDir, columnName + FST_INDEX_FILE_EXTENSION);\n+\n+        _fstBuilder = new FSTBuilder();\n+\n+        for (int dictId = 0; dictId < cardinality; dictId++) {\n+            if (sortedEntries != null) {\n+                _fstBuilder.addEntry(sortedEntries[dictId], dictId);\n+            }\n+        }\n+    }\n+\n+    // add SortedDicts should be called in sorted order.\n+    public void addSortedDictIds(String document, int dictId) throws IOException {\n+        _fstBuilder.addEntry(document, dictId);\n+    }\n+\n+    @Override\n+    public void add(int dictId) {\n+        // NOOP\n+    }\n+\n+    @Override\n+    public void add(int[] dictIds, int length) {\n+        throw new IllegalStateException(\n+                \"LuceneFSTIndexCreator does not support add interface\");\n+    }\n+\n+    @Override\n+    public void seal() throws IOException {\n+        LOGGER.info(\"Sealing the segment for column: \" + _fstIndexFile.getAbsolutePath());\n+        FST<Long> fst = _fstBuilder.done();\n+        FileOutputStream fileOutputStream = new FileOutputStream(_fstIndexFile);\n+        OutputStreamDataOutput d = new OutputStreamDataOutput(fileOutputStream);\n+        fst.save(d);\n+        fileOutputStream.close();", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ1NDg5Mw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524454893", "bodyText": "done", "author": "pradeepgv42", "createdAt": "2020-11-16T17:42:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDM2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDM4Mw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320383", "bodyText": "Like the way it is done for other indexes, I don't think we check here if the index is existing or not.\nThe creation of the respective index reader will fail and the segment load will fail to let the user know that IndexLoadingConfig was incorrectly built from IndexingConfig", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:01Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/column/PhysicalColumnIndexContainer.java", "diffHunk": "@@ -142,6 +148,18 @@ public PhysicalColumnIndexContainer(SegmentDirectory.Reader segmentReader, Colum\n       } else {\n         _invertedIndex = null;\n       }\n+\n+\n+      if (loadFSTIndex) {\n+        if (segmentReader.hasIndexFor(columnName, ColumnIndexType.FST_INDEX)) {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ1NTA0MA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524455040", "bodyText": "fixed", "author": "pradeepgv42", "createdAt": "2020-11-16T17:42:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDQ4Mw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320483", "bodyText": "undo?", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:14Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/converter/SegmentV1V2ToV3FormatConverter.java", "diffHunk": "@@ -225,9 +227,26 @@ private void copyCreationMetadataIfExists(File currentDir, File v3Dir)\n     }\n   }\n \n+  private void copyLuceneFSTIndexFiles(File segmentDirectory, File v3Dir) throws IOException {\n+    File[] fstIndexFiles = segmentDirectory.listFiles(new FilenameFilter() {\n+      @Override\n+      public boolean accept(File dir, String name) {\n+        return name.endsWith(LuceneFSTIndexCreator.FST_INDEX_FILE_EXTENSION);\n+      }\n+    });\n+\n+    for (File fstIndexFile : fstIndexFiles) {\n+      File v3File = new File(v3Dir, fstIndexFile.getName());\n+      LOGGER.info(\"Copying {} to {}\", fstIndexFile.toPath(), v3File.toPath());\n+      Files.copy(fstIndexFile.toPath(), v3File.toPath());\n+    }\n+  }\n+\n   private void copyLuceneTextIndexIfExists(File segmentDirectory, File v3Dir)\n       throws IOException {\n     // TODO: see if this can be done by reusing some existing methods\n+", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ1Nzc2MQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524457761", "bodyText": "done", "author": "pradeepgv42", "createdAt": "2020-11-16T17:46:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDUyMQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320521", "bodyText": "Why this method specifically on mutable data source?", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:18Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/datasource/MutableDataSource.java", "diffHunk": "@@ -36,16 +36,26 @@\n  */\n @SuppressWarnings(\"rawtypes\")\n public class MutableDataSource extends BaseDataSource {\n+  final boolean _fstIndexEnabled;\n \n-  public MutableDataSource(FieldSpec fieldSpec, int numDocs, int numValues, int maxNumValuesPerMVEntry,\n+  public MutableDataSource(FieldSpec fieldSpec, int numDocs, int numValues, int maxNumValuesPerMVEntry, boolean fstIndexEnabled,\n       @Nullable PartitionFunction partitionFunction, @Nullable Set<Integer> partitions, @Nullable Comparable minValue,\n       @Nullable Comparable maxValue, ForwardIndexReader forwardIndex, @Nullable Dictionary dictionary,\n       @Nullable InvertedIndexReader invertedIndex, @Nullable InvertedIndexReader rangeIndex,\n-      @Nullable TextIndexReader textIndex, @Nullable BloomFilterReader bloomFilter,\n+      @Nullable TextIndexReader textIndex, @Nullable TextIndexReader fstIndex,\n+      @Nullable BloomFilterReader bloomFilter,\n       @Nullable NullValueVectorReader nullValueVector) {\n     super(new MutableDataSourceMetadata(fieldSpec, numDocs, numValues, maxNumValuesPerMVEntry, partitionFunction,\n-            partitions, minValue, maxValue), forwardIndex, dictionary, invertedIndex, rangeIndex, textIndex, bloomFilter,\n-        nullValueVector);\n+                    partitions, minValue, maxValue), forwardIndex, dictionary,\n+            invertedIndex, rangeIndex, textIndex, fstIndex,\n+            bloomFilter, nullValueVector);\n+    _fstIndexEnabled = fstIndexEnabled;\n+  }\n+\n+\n+  // Returns whether the current field has", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ1ODY2MQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524458661", "bodyText": "This is to keep the results consistent between consuming & rolled out segments (more details in comments above)", "author": "pradeepgv42", "createdAt": "2020-11-16T17:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDU0NA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320544", "bodyText": "In the table config, you need to add a validator for FST index type for now since it is only supported on dictionary encoded columns. That way we can error out during table config creation itself if someone tries to enable this index  with encoding type as RAW", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:22Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/IndexLoadingConfig.java", "diffHunk": "@@ -173,6 +175,18 @@ private void extractTextIndexColumnsFromTableConfig(TableConfig tableConfig) {\n     }\n   }\n \n+  private void extractFSTIndexColumnsFromTableConfig(TableConfig tableConfig) {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3Mjc0MQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524472741", "bodyText": "Added validation config in TableConfigUtils PTAL.", "author": "pradeepgv42", "createdAt": "2020-11-16T18:10:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDU0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDU2MQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320561", "bodyText": "Please add javadoc", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:27Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.pinot.core.segment.index.loader.invertedindex;\n+\n+import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n+import org.apache.pinot.core.segment.creator.impl.inv.text.LuceneFSTIndexCreator;\n+import org.apache.pinot.core.segment.index.metadata.ColumnMetadata;\n+import org.apache.pinot.core.segment.index.metadata.SegmentMetadataImpl;\n+import org.apache.pinot.core.segment.index.readers.BaseImmutableDictionary;\n+import org.apache.pinot.core.segment.index.readers.StringDictionary;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.core.segment.store.ColumnIndexType;\n+import org.apache.pinot.core.segment.store.SegmentDirectory;\n+import org.apache.pinot.core.segment.store.SegmentDirectoryPaths;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class LuceneFSTIndexHandler {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3MzA2MA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524473060", "bodyText": "took over comment and reworded from textindexhandler", "author": "pradeepgv42", "createdAt": "2020-11-16T18:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDU4MA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320580", "bodyText": "Fix the log", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:30Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.pinot.core.segment.index.loader.invertedindex;\n+\n+import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n+import org.apache.pinot.core.segment.creator.impl.inv.text.LuceneFSTIndexCreator;\n+import org.apache.pinot.core.segment.index.metadata.ColumnMetadata;\n+import org.apache.pinot.core.segment.index.metadata.SegmentMetadataImpl;\n+import org.apache.pinot.core.segment.index.readers.BaseImmutableDictionary;\n+import org.apache.pinot.core.segment.index.readers.StringDictionary;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.core.segment.store.ColumnIndexType;\n+import org.apache.pinot.core.segment.store.SegmentDirectory;\n+import org.apache.pinot.core.segment.store.SegmentDirectoryPaths;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class LuceneFSTIndexHandler {\n+    private static final Logger LOGGER =\n+            LoggerFactory.getLogger(LuceneFSTIndexHandler.class);\n+\n+    private final File _indexDir;\n+    private final SegmentDirectory.Writer _segmentWriter;\n+    private final String _segmentName;\n+    private final SegmentVersion _segmentVersion;\n+    private final Set<ColumnMetadata> _fstIndexColumns = new HashSet<>();\n+\n+\n+    public LuceneFSTIndexHandler(\n+            File indexDir, SegmentMetadataImpl segmentMetadata, Set<String> fstIndexColumns,\n+            SegmentDirectory.Writer segmentWriter) {\n+        _indexDir = indexDir;\n+        _segmentWriter = segmentWriter;\n+        _segmentName = segmentMetadata.getName();\n+        _segmentVersion = SegmentVersion.valueOf(segmentMetadata.getVersion());\n+\n+        for (String column : fstIndexColumns) {\n+            ColumnMetadata columnMetadata = segmentMetadata.getColumnMetadataFor(column);\n+            if (columnMetadata != null) {\n+                _fstIndexColumns.add(columnMetadata);\n+            }\n+        }\n+    }\n+\n+    private void checkUnsupportedOperationsForFSTIndex(ColumnMetadata columnMetadata) {\n+        String column = columnMetadata.getColumnName();\n+        if (columnMetadata.getDataType() != FieldSpec.DataType.STRING) {\n+            throw new UnsupportedOperationException(\"FST index is currently only supported on STRING columns: \" + column);\n+        }\n+\n+        if (!columnMetadata.hasDictionary()) {\n+            throw new UnsupportedOperationException(\"FST index is currently only supported on dictionary encoded columns: \" + column);\n+        }\n+\n+        if (!columnMetadata.isSingleValue()) {\n+            throw new UnsupportedOperationException(\n+                    \"Text index is currently not supported on multi-value columns: \" + column);", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3MzEzMA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524473130", "bodyText": "done", "author": "pradeepgv42", "createdAt": "2020-11-16T18:11:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDYwMQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320601", "bodyText": "please fix the comment", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:33Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.pinot.core.segment.index.loader.invertedindex;\n+\n+import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n+import org.apache.pinot.core.segment.creator.impl.inv.text.LuceneFSTIndexCreator;\n+import org.apache.pinot.core.segment.index.metadata.ColumnMetadata;\n+import org.apache.pinot.core.segment.index.metadata.SegmentMetadataImpl;\n+import org.apache.pinot.core.segment.index.readers.BaseImmutableDictionary;\n+import org.apache.pinot.core.segment.index.readers.StringDictionary;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.core.segment.store.ColumnIndexType;\n+import org.apache.pinot.core.segment.store.SegmentDirectory;\n+import org.apache.pinot.core.segment.store.SegmentDirectoryPaths;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class LuceneFSTIndexHandler {\n+    private static final Logger LOGGER =\n+            LoggerFactory.getLogger(LuceneFSTIndexHandler.class);\n+\n+    private final File _indexDir;\n+    private final SegmentDirectory.Writer _segmentWriter;\n+    private final String _segmentName;\n+    private final SegmentVersion _segmentVersion;\n+    private final Set<ColumnMetadata> _fstIndexColumns = new HashSet<>();\n+\n+\n+    public LuceneFSTIndexHandler(\n+            File indexDir, SegmentMetadataImpl segmentMetadata, Set<String> fstIndexColumns,\n+            SegmentDirectory.Writer segmentWriter) {\n+        _indexDir = indexDir;\n+        _segmentWriter = segmentWriter;\n+        _segmentName = segmentMetadata.getName();\n+        _segmentVersion = SegmentVersion.valueOf(segmentMetadata.getVersion());\n+\n+        for (String column : fstIndexColumns) {\n+            ColumnMetadata columnMetadata = segmentMetadata.getColumnMetadataFor(column);\n+            if (columnMetadata != null) {\n+                _fstIndexColumns.add(columnMetadata);\n+            }\n+        }\n+    }\n+\n+    private void checkUnsupportedOperationsForFSTIndex(ColumnMetadata columnMetadata) {\n+        String column = columnMetadata.getColumnName();\n+        if (columnMetadata.getDataType() != FieldSpec.DataType.STRING) {\n+            throw new UnsupportedOperationException(\"FST index is currently only supported on STRING columns: \" + column);\n+        }\n+\n+        if (!columnMetadata.hasDictionary()) {\n+            throw new UnsupportedOperationException(\"FST index is currently only supported on dictionary encoded columns: \" + column);\n+        }\n+\n+        if (!columnMetadata.isSingleValue()) {\n+            throw new UnsupportedOperationException(\n+                    \"Text index is currently not supported on multi-value columns: \" + column);\n+        }\n+    }\n+\n+    public void createFSTIndexesOnSegmentLoad()\n+            throws Exception {\n+        for (ColumnMetadata columnMetadata : _fstIndexColumns) {\n+            checkUnsupportedOperationsForFSTIndex(columnMetadata);\n+            createFSTIndexForColumn(columnMetadata);\n+        }\n+    }\n+\n+    private BaseImmutableDictionary getDictionaryReader(ColumnMetadata columnMetadata)\n+            throws IOException {\n+        PinotDataBuffer dictionaryBuffer =\n+                _segmentWriter.getIndexFor(columnMetadata.getColumnName(), ColumnIndexType.DICTIONARY);\n+        return new StringDictionary(dictionaryBuffer, columnMetadata.getCardinality(), columnMetadata.getColumnMaxLength(),\n+                (byte) columnMetadata.getPaddingCharacter());\n+    }\n+\n+    private void createFSTIndexForColumn(ColumnMetadata columnMetadata) throws IOException {\n+        String column = columnMetadata.getColumnName();\n+        boolean hasDictionary = columnMetadata.hasDictionary();\n+\n+        if (!hasDictionary) {\n+            return;\n+        }\n+\n+        if (_segmentWriter.hasIndexFor(column, ColumnIndexType.FST_INDEX)) {\n+            // Skip creating text index if already exists.", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3MzE5Mw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524473193", "bodyText": "done", "author": "pradeepgv42", "createdAt": "2020-11-16T18:11:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDYyNw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320627", "bodyText": "please fix the log", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:36Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.pinot.core.segment.index.loader.invertedindex;\n+\n+import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n+import org.apache.pinot.core.segment.creator.impl.inv.text.LuceneFSTIndexCreator;\n+import org.apache.pinot.core.segment.index.metadata.ColumnMetadata;\n+import org.apache.pinot.core.segment.index.metadata.SegmentMetadataImpl;\n+import org.apache.pinot.core.segment.index.readers.BaseImmutableDictionary;\n+import org.apache.pinot.core.segment.index.readers.StringDictionary;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.core.segment.store.ColumnIndexType;\n+import org.apache.pinot.core.segment.store.SegmentDirectory;\n+import org.apache.pinot.core.segment.store.SegmentDirectoryPaths;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class LuceneFSTIndexHandler {\n+    private static final Logger LOGGER =\n+            LoggerFactory.getLogger(LuceneFSTIndexHandler.class);\n+\n+    private final File _indexDir;\n+    private final SegmentDirectory.Writer _segmentWriter;\n+    private final String _segmentName;\n+    private final SegmentVersion _segmentVersion;\n+    private final Set<ColumnMetadata> _fstIndexColumns = new HashSet<>();\n+\n+\n+    public LuceneFSTIndexHandler(\n+            File indexDir, SegmentMetadataImpl segmentMetadata, Set<String> fstIndexColumns,\n+            SegmentDirectory.Writer segmentWriter) {\n+        _indexDir = indexDir;\n+        _segmentWriter = segmentWriter;\n+        _segmentName = segmentMetadata.getName();\n+        _segmentVersion = SegmentVersion.valueOf(segmentMetadata.getVersion());\n+\n+        for (String column : fstIndexColumns) {\n+            ColumnMetadata columnMetadata = segmentMetadata.getColumnMetadataFor(column);\n+            if (columnMetadata != null) {\n+                _fstIndexColumns.add(columnMetadata);\n+            }\n+        }\n+    }\n+\n+    private void checkUnsupportedOperationsForFSTIndex(ColumnMetadata columnMetadata) {\n+        String column = columnMetadata.getColumnName();\n+        if (columnMetadata.getDataType() != FieldSpec.DataType.STRING) {\n+            throw new UnsupportedOperationException(\"FST index is currently only supported on STRING columns: \" + column);\n+        }\n+\n+        if (!columnMetadata.hasDictionary()) {\n+            throw new UnsupportedOperationException(\"FST index is currently only supported on dictionary encoded columns: \" + column);\n+        }\n+\n+        if (!columnMetadata.isSingleValue()) {\n+            throw new UnsupportedOperationException(\n+                    \"Text index is currently not supported on multi-value columns: \" + column);\n+        }\n+    }\n+\n+    public void createFSTIndexesOnSegmentLoad()\n+            throws Exception {\n+        for (ColumnMetadata columnMetadata : _fstIndexColumns) {\n+            checkUnsupportedOperationsForFSTIndex(columnMetadata);\n+            createFSTIndexForColumn(columnMetadata);\n+        }\n+    }\n+\n+    private BaseImmutableDictionary getDictionaryReader(ColumnMetadata columnMetadata)\n+            throws IOException {\n+        PinotDataBuffer dictionaryBuffer =\n+                _segmentWriter.getIndexFor(columnMetadata.getColumnName(), ColumnIndexType.DICTIONARY);\n+        return new StringDictionary(dictionaryBuffer, columnMetadata.getCardinality(), columnMetadata.getColumnMaxLength(),\n+                (byte) columnMetadata.getPaddingCharacter());\n+    }\n+\n+    private void createFSTIndexForColumn(ColumnMetadata columnMetadata) throws IOException {\n+        String column = columnMetadata.getColumnName();\n+        boolean hasDictionary = columnMetadata.hasDictionary();\n+\n+        if (!hasDictionary) {\n+            return;\n+        }\n+\n+        if (_segmentWriter.hasIndexFor(column, ColumnIndexType.FST_INDEX)) {\n+            // Skip creating text index if already exists.\n+            LOGGER.info(\"Found text index for column: {}, in segment: {}\", column, _segmentName);", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3MzMzNQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524473335", "bodyText": "done", "author": "pradeepgv42", "createdAt": "2020-11-16T18:11:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDYyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDY2OA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320668", "bodyText": "Please add javadoc explaining the algorithm how the index is read\nSince the writer is using inverted index creator interface, reader should use the inverted index reader interface", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:41Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/LuceneFSTIndexReader.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.index.readers;\n+\n+import org.apache.lucene.util.fst.FST;\n+import org.apache.lucene.util.fst.OffHeapFSTStore;\n+import org.apache.lucene.util.fst.PositiveIntOutputs;\n+import org.apache.pinot.core.segment.creator.impl.inv.text.LuceneFSTIndexCreator;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.core.segment.store.SegmentDirectoryPaths;\n+import org.apache.pinot.core.util.fst.RegexpMatcher;\n+import org.apache.pinot.core.util.fst.PinotBufferIndexInput;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteOrder;\n+import java.util.List;\n+\n+public class LuceneFSTIndexReader implements TextIndexReader {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3MzU3Mw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524473573", "bodyText": "done, switched everything to TextIndexCreator/Reader", "author": "pradeepgv42", "createdAt": "2020-11-16T18:11:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDY2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDcxNw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320717", "bodyText": "It looks like on-disk FST index is in a single file which is mmaped upon load. I think we should try to combine this with other index files (dictionary, inverted, fwd) for v3 format into a single file.", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:48Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/LuceneFSTIndexReader.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.index.readers;\n+\n+import org.apache.lucene.util.fst.FST;\n+import org.apache.lucene.util.fst.OffHeapFSTStore;\n+import org.apache.lucene.util.fst.PositiveIntOutputs;\n+import org.apache.pinot.core.segment.creator.impl.inv.text.LuceneFSTIndexCreator;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.core.segment.store.SegmentDirectoryPaths;\n+import org.apache.pinot.core.util.fst.RegexpMatcher;\n+import org.apache.pinot.core.util.fst.PinotBufferIndexInput;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteOrder;\n+import java.util.List;\n+\n+public class LuceneFSTIndexReader implements TextIndexReader {\n+    public static final Logger LOGGER =\n+            LoggerFactory.getLogger(LuceneFSTIndexReader.class);\n+\n+    private final PinotDataBuffer _dataBuffer;\n+    private final PinotBufferIndexInput _dataBufferIndexInput;\n+    private final FST<Long> readFST;\n+    private String dir;\n+\n+    public LuceneFSTIndexReader(\n+            File segmentIndexDir, String column) throws IOException {\n+        File segmentsV3Dir = SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir);\n+\n+        File fstFile = new File(segmentsV3Dir,\n+                column + LuceneFSTIndexCreator.FST_INDEX_FILE_EXTENSION);\n+        dir = segmentsV3Dir.getAbsolutePath();\n+\n+        this._dataBuffer = PinotDataBuffer.mapFile(", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3MzcyOQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524473729", "bodyText": "Good point, combined it in v3 conversion.", "author": "pradeepgv42", "createdAt": "2020-11-16T18:12:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDc5Mw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320793", "bodyText": "I don't think this method is needed", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:55Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/TextIndexReader.java", "diffHunk": "@@ -19,11 +19,19 @@\n package org.apache.pinot.core.segment.index.readers;\n \n import java.io.Closeable;\n+\n+import org.apache.commons.lang.mutable.Mutable;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n import org.roaringbitmap.buffer.MutableRoaringBitmap;\n \n \n public interface TextIndexReader extends Closeable {\n \n+  /**\n+   * Returns the matching dictionary ids for the given search query.\n+   */\n+  ImmutableRoaringBitmap getDictIds(String searchQuery);", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3Mzg5OQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524473899", "bodyText": "see my previous comments", "author": "pradeepgv42", "createdAt": "2020-11-16T18:12:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDc5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDgxNw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320817", "bodyText": "This change should not be needed", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:59Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -116,6 +117,11 @@ private File getTextIndexFile(File segmentIndexDir) {\n     return file;\n   }\n \n+  @Override\n+  public ImmutableRoaringBitmap getDictIds(String searchQuery) {\n+    throw new UnsupportedOperationException(\"\");", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwMzgwNg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r546203806", "bodyText": "Include a message in exception", "author": "siddharthteotia", "createdAt": "2020-12-19T07:07:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDg1NA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320854", "bodyText": "javadoc", "author": "siddharthteotia", "createdAt": "2020-10-30T19:12:05Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/util/fst/FSTBuilder.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.util.fst;\n+\n+import org.apache.lucene.util.IntsRefBuilder;\n+import org.apache.lucene.util.fst.Builder;\n+import org.apache.lucene.util.fst.FST;\n+import org.apache.lucene.util.fst.PositiveIntOutputs;\n+import org.apache.lucene.util.fst.Util;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.SortedMap;\n+\n+public class FSTBuilder {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3NDAyMA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524474020", "bodyText": "done", "author": "pradeepgv42", "createdAt": "2020-11-16T18:12:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDg3NQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320875", "bodyText": "Explain the algorithm please", "author": "siddharthteotia", "createdAt": "2020-10-30T19:12:07Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/util/fst/FSTBuilder.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.util.fst;\n+\n+import org.apache.lucene.util.IntsRefBuilder;\n+import org.apache.lucene.util.fst.Builder;\n+import org.apache.lucene.util.fst.FST;\n+import org.apache.lucene.util.fst.PositiveIntOutputs;\n+import org.apache.lucene.util.fst.Util;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.SortedMap;\n+\n+public class FSTBuilder {\n+    public static final Logger LOGGER =\n+            LoggerFactory.getLogger(FSTBuilder.class);\n+    private Builder<Long> _builder = new Builder<>(\n+            FST.INPUT_TYPE.BYTE4, PositiveIntOutputs.getSingleton());\n+    private IntsRefBuilder _scratch = new IntsRefBuilder();\n+\n+    public void addEntry(String key, Integer value) throws IOException {\n+        _builder.add(\n+                Util.toUTF16(key, _scratch),\n+                value.longValue());\n+    }\n+\n+    public FST done() throws IOException {\n+        return _builder.finish();\n+    }\n+\n+    public static FST buildFST(SortedMap<String, Integer> input) throws IOException {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3NDM0Nw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524474347", "bodyText": "done, crux of the comments are in RegexpMatcher file", "author": "pradeepgv42", "createdAt": "2020-11-16T18:13:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDg3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDkwOQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320909", "bodyText": "Please add javadoc. Couple of other questions:\n\nWhy do we need a specialized Pinotbuffer extending lucene buffer\nWhat is the arrangement of FST index in pinot segment directory? Is it under separate sub-directory like lucene text index. If the on-disk index is in a single buffer, can we combine it with other buffers in v3", "author": "siddharthteotia", "createdAt": "2020-10-30T19:12:11Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/util/fst/PinotBufferIndexInput.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.util.fst;\n+\n+import org.apache.lucene.store.IndexInput;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+\n+import java.io.IOException;\n+\n+public class PinotBufferIndexInput extends IndexInput {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3NDk1MQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524474951", "bodyText": "It's a wrapper so that lucene FST reader library could traverse over the buffer.\nv1 generates a fst index file, v3 merges into the single index file now", "author": "pradeepgv42", "createdAt": "2020-11-16T18:14:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDk1NQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320955", "bodyText": "javadoc and explanation of the algorithm/ functionality", "author": "siddharthteotia", "createdAt": "2020-10-30T19:12:17Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/util/fst/RegexpMatcher.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.util.fst;\n+\n+import org.apache.lucene.util.IntsRefBuilder;\n+import org.apache.lucene.util.automaton.Automaton;\n+import org.apache.lucene.util.automaton.CharacterRunAutomaton;\n+import org.apache.lucene.util.automaton.RegExp;\n+import org.apache.lucene.util.automaton.Transition;\n+import org.apache.lucene.util.fst.FST;\n+import org.apache.lucene.util.fst.Util;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public class RegexpMatcher {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3NTA5OA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524475098", "bodyText": "Added, let me know if should expand", "author": "pradeepgv42", "createdAt": "2020-11-16T18:14:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDk3Nw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320977", "bodyText": "Explanation of algorithm would be great", "author": "siddharthteotia", "createdAt": "2020-10-30T19:12:20Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/util/fst/RegexpMatcher.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.util.fst;\n+\n+import org.apache.lucene.util.IntsRefBuilder;\n+import org.apache.lucene.util.automaton.Automaton;\n+import org.apache.lucene.util.automaton.CharacterRunAutomaton;\n+import org.apache.lucene.util.automaton.RegExp;\n+import org.apache.lucene.util.automaton.Transition;\n+import org.apache.lucene.util.fst.FST;\n+import org.apache.lucene.util.fst.Util;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public class RegexpMatcher {\n+    public static final Logger LOGGER =\n+            LoggerFactory.getLogger(FSTBuilder.class);\n+\n+    private final String _regexQuery;\n+    private final FST<Long> _fst;\n+    private final Automaton _automaton;\n+\n+    public RegexpMatcher(String regexQuery, FST<Long> fst) {\n+        _regexQuery = regexQuery;\n+        _fst = fst;\n+        _automaton = (new RegExp(_regexQuery)).toAutomaton();\n+\n+    }\n+\n+    public static final class Path<T> {\n+        public final int state;\n+        public final FST.Arc<T> fstNode;\n+        public final T output;\n+        public final IntsRefBuilder input;\n+\n+        public Path(int state, FST.Arc<T> fstNode, T output, IntsRefBuilder input) {\n+            this.state = state;\n+            this.fstNode = fstNode;\n+            this.output = output;\n+            this.input = input;\n+        }\n+    }\n+\n+    // Matches \"input\" string with _regexQuery Automaton.\n+    public boolean match(String input) {\n+        CharacterRunAutomaton characterRunAutomaton =\n+                new CharacterRunAutomaton(_automaton);\n+        return characterRunAutomaton.run(input);\n+    }\n+\n+    public static List<Long> regexMatch(String regexQuery, FST<Long> fst) throws IOException {\n+        RegexpMatcher matcher = new RegexpMatcher(regexQuery, fst);\n+        return matcher.regexMatchOnFST();\n+    }\n+\n+    public List<Long> regexMatchOnFST() throws IOException {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3NTIxMw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524475213", "bodyText": "Added, let me know if should expand", "author": "pradeepgv42", "createdAt": "2020-11-16T18:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTA0OQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515321049", "bodyText": "I think you should add another test for enabling FST on raw column (both new and existing) and verify SegmentPreprocessor fails.\nAlso, add tests in LoaderTest similar to text index tests.", "author": "siddharthteotia", "createdAt": "2020-10-30T19:12:29Z", "path": "pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java", "diffHunk": "@@ -198,6 +207,51 @@ public void testEnableTextIndexOnNewColumnRaw()\n     checkTextIndexCreation(NEWLY_ADDED_STRING_COL_RAW, 1, 1, _newColumnsSchemaWithText, true, true, true, 4);\n   }\n \n+  @Test", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3NzEzOQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524477139", "bodyText": "done, let me know if i missed something", "author": "pradeepgv42", "createdAt": "2020-11-16T18:17:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTA0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTA4OA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515321088", "bodyText": "fix the comment", "author": "siddharthteotia", "createdAt": "2020-10-30T19:12:34Z", "path": "pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java", "diffHunk": "@@ -198,6 +207,51 @@ public void testEnableTextIndexOnNewColumnRaw()\n     checkTextIndexCreation(NEWLY_ADDED_STRING_COL_RAW, 1, 1, _newColumnsSchemaWithText, true, true, true, 4);\n   }\n \n+  @Test\n+  public void testEnableFSTIndexOnNewColumnDictEncoded() throws Exception {\n+    Set<String> fstColumns = new HashSet<>();\n+    fstColumns.add(NEWLY_ADDED_FST_COL_DICT);\n+    _indexLoadingConfig.setFSTIndexColumns(fstColumns);\n+\n+    // Create a segment in V3, add a new dict encoded column with text index enabled", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3NzUwNA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524477504", "bodyText": "done", "author": "pradeepgv42", "createdAt": "2020-11-16T18:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTA5OQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515321099", "bodyText": "fix the comment?", "author": "siddharthteotia", "createdAt": "2020-10-30T19:12:36Z", "path": "pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java", "diffHunk": "@@ -198,6 +207,51 @@ public void testEnableTextIndexOnNewColumnRaw()\n     checkTextIndexCreation(NEWLY_ADDED_STRING_COL_RAW, 1, 1, _newColumnsSchemaWithText, true, true, true, 4);\n   }\n \n+  @Test\n+  public void testEnableFSTIndexOnNewColumnDictEncoded() throws Exception {\n+    Set<String> fstColumns = new HashSet<>();\n+    fstColumns.add(NEWLY_ADDED_FST_COL_DICT);\n+    _indexLoadingConfig.setFSTIndexColumns(fstColumns);\n+\n+    // Create a segment in V3, add a new dict encoded column with text index enabled\n+    constructV3Segment();\n+    checkFSTIndexCreation(\n+            NEWLY_ADDED_FST_COL_DICT, 1, 1, _newColumnsSchema4,\n+            true, true, 4);\n+\n+    constructV1Segment();\n+    checkFSTIndexCreation(\n+            NEWLY_ADDED_FST_COL_DICT, 1, 1, _newColumnsSchema4,\n+            true, true,4);\n+  }\n+\n+\n+  @Test\n+  public void testEnableFSTIndexOnExistingColumnDictEncoded() throws Exception {\n+    Set<String> fstColumns = new HashSet<>();\n+    fstColumns.add(EXISTING_STRING_COL_DICT);\n+    _indexLoadingConfig.setFSTIndexColumns(fstColumns);\n+\n+    // Create a segment in V3, add a new dict encoded column with text index enabled", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3NzU4MQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524477581", "bodyText": "done", "author": "pradeepgv42", "createdAt": "2020-11-16T18:18:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTA5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTExMQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515321111", "bodyText": "fix the comment?", "author": "siddharthteotia", "createdAt": "2020-10-30T19:12:39Z", "path": "pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java", "diffHunk": "@@ -198,6 +207,51 @@ public void testEnableTextIndexOnNewColumnRaw()\n     checkTextIndexCreation(NEWLY_ADDED_STRING_COL_RAW, 1, 1, _newColumnsSchemaWithText, true, true, true, 4);\n   }\n \n+  @Test\n+  public void testEnableFSTIndexOnNewColumnDictEncoded() throws Exception {\n+    Set<String> fstColumns = new HashSet<>();\n+    fstColumns.add(NEWLY_ADDED_FST_COL_DICT);\n+    _indexLoadingConfig.setFSTIndexColumns(fstColumns);\n+\n+    // Create a segment in V3, add a new dict encoded column with text index enabled\n+    constructV3Segment();\n+    checkFSTIndexCreation(\n+            NEWLY_ADDED_FST_COL_DICT, 1, 1, _newColumnsSchema4,\n+            true, true, 4);\n+\n+    constructV1Segment();\n+    checkFSTIndexCreation(\n+            NEWLY_ADDED_FST_COL_DICT, 1, 1, _newColumnsSchema4,\n+            true, true,4);\n+  }\n+\n+\n+  @Test\n+  public void testEnableFSTIndexOnExistingColumnDictEncoded() throws Exception {\n+    Set<String> fstColumns = new HashSet<>();\n+    fstColumns.add(EXISTING_STRING_COL_DICT);\n+    _indexLoadingConfig.setFSTIndexColumns(fstColumns);\n+\n+    // Create a segment in V3, add a new dict encoded column with text index enabled\n+    constructV3Segment();\n+    SegmentMetadataImpl segmentMetadata = new SegmentMetadataImpl(_indexDir);\n+    ColumnMetadata columnMetadata = segmentMetadata.getColumnMetadataFor(\n+            EXISTING_STRING_COL_DICT);\n+    // column exists and does not have text index enabled", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3NzY2OA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524477668", "bodyText": "done", "author": "pradeepgv42", "createdAt": "2020-11-16T18:18:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTExMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTIwMQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515321201", "bodyText": "I suggest adding tests for both aggregation and selection queries.\nAlso, test both segment level and inter segment execution. I initially didn't add text index tests for inter segment and there were few multi-threading related bugs in how I was using lucene parser.\nTest both PQL and SQL. You may want to see example tests in TextSearchQueriesTest.java for sample tests.", "author": "siddharthteotia", "createdAt": "2020-10-30T19:12:50Z", "path": "pinot-core/src/test/java/org/apache/pinot/queries/FSTBasedRegexpLikeQueriesTest.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.queries;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.Operator;\n+import org.apache.pinot.core.data.readers.GenericRowRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.indexsegment.generator.SegmentGeneratorConfig;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegment;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegmentLoader;\n+import org.apache.pinot.core.operator.blocks.IntermediateResultsBlock;\n+import org.apache.pinot.core.operator.query.AggregationGroupByOperator;\n+import org.apache.pinot.core.query.aggregation.groupby.AggregationGroupByResult;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupKeyGenerator;\n+import org.apache.pinot.core.segment.creator.impl.SegmentIndexCreationDriverImpl;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.config.table.FieldConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.RecordReader;\n+import org.apache.pinot.spi.utils.builder.TableConfigBuilder;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+public class FSTBasedRegexpLikeQueriesTest extends BaseQueriesTest {\n+    private static final File INDEX_DIR = new File(FileUtils.getTempDirectory(), \"TextSearchQueriesTest\");\n+    private static final String TABLE_NAME = \"MyTable\";\n+    private static final String SEGMENT_NAME = \"testSegment\";\n+    private static final String DOMAIN_NAMES_COL = \"DOMAIN_NAMES\";\n+    private static final String URL_COL = \"URL_COL\";\n+    private static final String INT_COL_NAME = \"INT_COL\";\n+    private static final Integer INT_BASE_VALUE = 1000;\n+    private static final Integer NUM_ROWS = 1024;\n+\n+    private final List<GenericRow> _rows = new ArrayList<>();\n+\n+    private IndexSegment _indexSegment;\n+    private List<IndexSegment> _indexSegments;\n+\n+    @Override\n+    protected String getFilter() {\n+        return \"\";\n+    }\n+\n+    @Override\n+    protected IndexSegment getIndexSegment() {\n+        return _indexSegment;\n+    }\n+\n+    @Override\n+    protected List<IndexSegment> getIndexSegments() {\n+        return _indexSegments;\n+    }\n+\n+    @BeforeClass\n+    public void setUp()\n+            throws Exception {\n+        FileUtils.deleteQuietly(INDEX_DIR);\n+\n+        buildSegment();\n+        IndexLoadingConfig indexLoadingConfig = new IndexLoadingConfig();\n+        Set<String> fstIndexCols = new HashSet<>();\n+        fstIndexCols.add(DOMAIN_NAMES_COL);\n+        indexLoadingConfig.setFSTIndexColumns(fstIndexCols);\n+\n+        Set<String> invertedIndexCols = new HashSet<>();\n+        invertedIndexCols.add(DOMAIN_NAMES_COL);\n+        indexLoadingConfig.setInvertedIndexColumns(invertedIndexCols);\n+        ImmutableSegment immutableSegment =\n+                ImmutableSegmentLoader.load(new File(INDEX_DIR, SEGMENT_NAME), indexLoadingConfig);\n+        _indexSegment = immutableSegment;\n+        _indexSegments = Arrays.asList(immutableSegment, immutableSegment);\n+    }\n+\n+    @AfterClass\n+    public void tearDown() {\n+        _indexSegment.destroy();\n+        FileUtils.deleteQuietly(INDEX_DIR);\n+    }\n+\n+    private List<String> getURLSufficies() {\n+        return Arrays.asList(\n+                \"/a\", \"/b\", \"/c\", \"/d\"\n+        );\n+    }\n+\n+    private List<String> getDomainNames() {\n+        return Arrays.asList(\n+                \"www.domain1.com\", \"www.domain1.co.ab\", \"www.domain1.co.bc\", \"www.domain1.co.cd\",\n+                \"www.sd.domain1.com\", \"www.sd.domain1.co.ab\", \"www.sd.domain1.co.bc\", \"www.sd.domain1.co.cd\",\n+                \"www.domain2.com\", \"www.domain2.co.ab\", \"www.domain2.co.bc\", \"www.domain2.co.cd\",\n+                \"www.sd.domain2.com\", \"www.sd.domain2.co.ab\", \"www.sd.domain2.co.bc\", \"www.sd.domain2.co.cd\"\n+        );\n+    }\n+\n+    private List<GenericRow> createTestData(int numRows) throws Exception {\n+        List<GenericRow> rows = new ArrayList<>();\n+        List<String> domainNames = getDomainNames();\n+        List<String> urlSufficies = getURLSufficies();\n+        for (int i = 0; i < numRows; i++) {\n+            String domain = domainNames.get(i % domainNames.size());\n+            String url = domain + urlSufficies.get(i % urlSufficies.size());\n+\n+            GenericRow row = new GenericRow();\n+            row.putField(INT_COL_NAME, INT_BASE_VALUE + i);\n+            row.putField(DOMAIN_NAMES_COL, domain);\n+            row.putField(URL_COL, url);\n+            rows.add(row);\n+        }\n+        return rows;\n+    }\n+\n+    private void buildSegment()\n+            throws Exception {\n+        List<GenericRow> rows = createTestData(NUM_ROWS);\n+        List<FieldConfig> fieldConfigs = new ArrayList<>();\n+        fieldConfigs.add(new FieldConfig(\n+                DOMAIN_NAMES_COL,\n+                FieldConfig.EncodingType.DICTIONARY,\n+                FieldConfig.IndexType.FST, null));\n+        fieldConfigs.add(new FieldConfig(\n+                URL_COL,\n+                FieldConfig.EncodingType.DICTIONARY,\n+                FieldConfig.IndexType.FST, null));\n+\n+        TableConfig tableConfig = new TableConfigBuilder(TableType.OFFLINE).setTableName(TABLE_NAME)\n+                .setInvertedIndexColumns(Arrays.asList(DOMAIN_NAMES_COL))\n+                .setFieldConfigList(fieldConfigs).build();\n+        Schema schema = new Schema.SchemaBuilder().setSchemaName(TABLE_NAME)\n+                .addSingleValueDimension(DOMAIN_NAMES_COL, FieldSpec.DataType.STRING)\n+                .addSingleValueDimension(URL_COL, FieldSpec.DataType.STRING)\n+                .addMetric(INT_COL_NAME, FieldSpec.DataType.INT).build();\n+        SegmentGeneratorConfig config = new SegmentGeneratorConfig(tableConfig, schema);\n+        config.setOutDir(INDEX_DIR.getPath());\n+        config.setTableName(TABLE_NAME);\n+        config.setSegmentName(SEGMENT_NAME);\n+\n+        SegmentIndexCreationDriverImpl driver = new SegmentIndexCreationDriverImpl();\n+        try (RecordReader recordReader = new GenericRowRecordReader(rows)) {\n+            driver.init(config, recordReader);\n+            driver.build();\n+        }\n+    }\n+\n+    private void testSelectionResults(String query, int expectedResultSize)\n+            throws Exception {\n+        Operator<IntermediateResultsBlock> operator = getOperatorForPqlQuery(query);\n+        IntermediateResultsBlock operatorResult = operator.nextBlock();\n+        List<Object[]> resultset = (List<Object[]>) operatorResult.getSelectionResult();\n+        Assert.assertNotNull(resultset);\n+        Assert.assertEquals(resultset.size(), expectedResultSize);\n+    }\n+\n+    private AggregationGroupByResult getGroupByResults(String query)\n+            throws Exception {\n+        AggregationGroupByOperator operator = getOperatorForPqlQuery(query);\n+        IntermediateResultsBlock resultsBlock = operator.nextBlock();\n+        return resultsBlock.getAggregationGroupByResult();\n+    }\n+\n+    private void matchGroupResult(AggregationGroupByResult result, String key, long count) {\n+        Iterator<GroupKeyGenerator.GroupKey> groupKeyIterator = result.getGroupKeyIterator();\n+        while (groupKeyIterator.hasNext()) {\n+            GroupKeyGenerator.GroupKey groupKey = groupKeyIterator.next();\n+            Assert.assertEquals(((Number)result.getResultForKey(groupKey, 0)).longValue(), count);\n+        }\n+    }\n+\n+    @Test\n+    public void testFSTBasedRegexpLike() throws Exception {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3NzkyMQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524477921", "bodyText": "done, let me know if I should add more tests.", "author": "pradeepgv42", "createdAt": "2020-11-16T18:19:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTI3NQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515321275", "bodyText": "You should also add tests for queries where REGEXP_LIKE filter is combined with another filter(s) using AND/OR to ensure the docID intersection/union is working fine.\nAlso combine multiple REGEXP_LIKE using a mix of FST index and no FST index.\nSee tests in TextSearchQueriesTest for examples", "author": "siddharthteotia", "createdAt": "2020-10-30T19:13:00Z", "path": "pinot-core/src/test/java/org/apache/pinot/queries/FSTBasedRegexpLikeQueriesTest.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.queries;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.Operator;\n+import org.apache.pinot.core.data.readers.GenericRowRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.indexsegment.generator.SegmentGeneratorConfig;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegment;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegmentLoader;\n+import org.apache.pinot.core.operator.blocks.IntermediateResultsBlock;\n+import org.apache.pinot.core.operator.query.AggregationGroupByOperator;\n+import org.apache.pinot.core.query.aggregation.groupby.AggregationGroupByResult;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupKeyGenerator;\n+import org.apache.pinot.core.segment.creator.impl.SegmentIndexCreationDriverImpl;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.config.table.FieldConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.RecordReader;\n+import org.apache.pinot.spi.utils.builder.TableConfigBuilder;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+public class FSTBasedRegexpLikeQueriesTest extends BaseQueriesTest {\n+    private static final File INDEX_DIR = new File(FileUtils.getTempDirectory(), \"TextSearchQueriesTest\");\n+    private static final String TABLE_NAME = \"MyTable\";\n+    private static final String SEGMENT_NAME = \"testSegment\";\n+    private static final String DOMAIN_NAMES_COL = \"DOMAIN_NAMES\";\n+    private static final String URL_COL = \"URL_COL\";\n+    private static final String INT_COL_NAME = \"INT_COL\";\n+    private static final Integer INT_BASE_VALUE = 1000;\n+    private static final Integer NUM_ROWS = 1024;\n+\n+    private final List<GenericRow> _rows = new ArrayList<>();\n+\n+    private IndexSegment _indexSegment;\n+    private List<IndexSegment> _indexSegments;\n+\n+    @Override\n+    protected String getFilter() {\n+        return \"\";\n+    }\n+\n+    @Override\n+    protected IndexSegment getIndexSegment() {\n+        return _indexSegment;\n+    }\n+\n+    @Override\n+    protected List<IndexSegment> getIndexSegments() {\n+        return _indexSegments;\n+    }\n+\n+    @BeforeClass\n+    public void setUp()\n+            throws Exception {\n+        FileUtils.deleteQuietly(INDEX_DIR);\n+\n+        buildSegment();\n+        IndexLoadingConfig indexLoadingConfig = new IndexLoadingConfig();\n+        Set<String> fstIndexCols = new HashSet<>();\n+        fstIndexCols.add(DOMAIN_NAMES_COL);\n+        indexLoadingConfig.setFSTIndexColumns(fstIndexCols);\n+\n+        Set<String> invertedIndexCols = new HashSet<>();\n+        invertedIndexCols.add(DOMAIN_NAMES_COL);\n+        indexLoadingConfig.setInvertedIndexColumns(invertedIndexCols);\n+        ImmutableSegment immutableSegment =\n+                ImmutableSegmentLoader.load(new File(INDEX_DIR, SEGMENT_NAME), indexLoadingConfig);\n+        _indexSegment = immutableSegment;\n+        _indexSegments = Arrays.asList(immutableSegment, immutableSegment);\n+    }\n+\n+    @AfterClass\n+    public void tearDown() {\n+        _indexSegment.destroy();\n+        FileUtils.deleteQuietly(INDEX_DIR);\n+    }\n+\n+    private List<String> getURLSufficies() {\n+        return Arrays.asList(\n+                \"/a\", \"/b\", \"/c\", \"/d\"\n+        );\n+    }\n+\n+    private List<String> getDomainNames() {\n+        return Arrays.asList(\n+                \"www.domain1.com\", \"www.domain1.co.ab\", \"www.domain1.co.bc\", \"www.domain1.co.cd\",\n+                \"www.sd.domain1.com\", \"www.sd.domain1.co.ab\", \"www.sd.domain1.co.bc\", \"www.sd.domain1.co.cd\",\n+                \"www.domain2.com\", \"www.domain2.co.ab\", \"www.domain2.co.bc\", \"www.domain2.co.cd\",\n+                \"www.sd.domain2.com\", \"www.sd.domain2.co.ab\", \"www.sd.domain2.co.bc\", \"www.sd.domain2.co.cd\"\n+        );\n+    }\n+\n+    private List<GenericRow> createTestData(int numRows) throws Exception {\n+        List<GenericRow> rows = new ArrayList<>();\n+        List<String> domainNames = getDomainNames();\n+        List<String> urlSufficies = getURLSufficies();\n+        for (int i = 0; i < numRows; i++) {\n+            String domain = domainNames.get(i % domainNames.size());\n+            String url = domain + urlSufficies.get(i % urlSufficies.size());\n+\n+            GenericRow row = new GenericRow();\n+            row.putField(INT_COL_NAME, INT_BASE_VALUE + i);\n+            row.putField(DOMAIN_NAMES_COL, domain);\n+            row.putField(URL_COL, url);\n+            rows.add(row);\n+        }\n+        return rows;\n+    }\n+\n+    private void buildSegment()\n+            throws Exception {\n+        List<GenericRow> rows = createTestData(NUM_ROWS);\n+        List<FieldConfig> fieldConfigs = new ArrayList<>();\n+        fieldConfigs.add(new FieldConfig(\n+                DOMAIN_NAMES_COL,\n+                FieldConfig.EncodingType.DICTIONARY,\n+                FieldConfig.IndexType.FST, null));\n+        fieldConfigs.add(new FieldConfig(\n+                URL_COL,\n+                FieldConfig.EncodingType.DICTIONARY,\n+                FieldConfig.IndexType.FST, null));\n+\n+        TableConfig tableConfig = new TableConfigBuilder(TableType.OFFLINE).setTableName(TABLE_NAME)\n+                .setInvertedIndexColumns(Arrays.asList(DOMAIN_NAMES_COL))\n+                .setFieldConfigList(fieldConfigs).build();\n+        Schema schema = new Schema.SchemaBuilder().setSchemaName(TABLE_NAME)\n+                .addSingleValueDimension(DOMAIN_NAMES_COL, FieldSpec.DataType.STRING)\n+                .addSingleValueDimension(URL_COL, FieldSpec.DataType.STRING)\n+                .addMetric(INT_COL_NAME, FieldSpec.DataType.INT).build();\n+        SegmentGeneratorConfig config = new SegmentGeneratorConfig(tableConfig, schema);\n+        config.setOutDir(INDEX_DIR.getPath());\n+        config.setTableName(TABLE_NAME);\n+        config.setSegmentName(SEGMENT_NAME);\n+\n+        SegmentIndexCreationDriverImpl driver = new SegmentIndexCreationDriverImpl();\n+        try (RecordReader recordReader = new GenericRowRecordReader(rows)) {\n+            driver.init(config, recordReader);\n+            driver.build();\n+        }\n+    }\n+\n+    private void testSelectionResults(String query, int expectedResultSize)\n+            throws Exception {\n+        Operator<IntermediateResultsBlock> operator = getOperatorForPqlQuery(query);\n+        IntermediateResultsBlock operatorResult = operator.nextBlock();\n+        List<Object[]> resultset = (List<Object[]>) operatorResult.getSelectionResult();\n+        Assert.assertNotNull(resultset);\n+        Assert.assertEquals(resultset.size(), expectedResultSize);\n+    }\n+\n+    private AggregationGroupByResult getGroupByResults(String query)\n+            throws Exception {\n+        AggregationGroupByOperator operator = getOperatorForPqlQuery(query);\n+        IntermediateResultsBlock resultsBlock = operator.nextBlock();\n+        return resultsBlock.getAggregationGroupByResult();\n+    }\n+\n+    private void matchGroupResult(AggregationGroupByResult result, String key, long count) {\n+        Iterator<GroupKeyGenerator.GroupKey> groupKeyIterator = result.getGroupKeyIterator();\n+        while (groupKeyIterator.hasNext()) {\n+            GroupKeyGenerator.GroupKey groupKey = groupKeyIterator.next();\n+            Assert.assertEquals(((Number)result.getResultForKey(groupKey, 0)).longValue(), count);\n+        }\n+    }\n+\n+    @Test\n+    public void testFSTBasedRegexpLike() throws Exception {\n+        // Select queries on col with FST + inverted index.\n+        String query =\n+                \"SELECT INT_COL, DOMAIN_NAMES FROM MyTable WHERE REGEXP_LIKE(DOMAIN_NAMES, 'www.domain1.*') LIMIT 50000\";\n+        testSelectionResults(query, 256);\n+", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3ODAxNA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524478014", "bodyText": "done, ptal", "author": "pradeepgv42", "createdAt": "2020-11-16T18:19:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTI3NQ=="}], "type": "inlineReview"}, {"oid": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "url": "https://github.com/apache/pinot/commit/4af2204937dfbf93a01fb939d84c3d11344f0d81", "message": "Add some more comments", "committedDate": "2020-11-16T09:17:30Z", "type": "forcePushed"}, {"oid": "d14596e98662ec1c8779fee809b94d2cb1fc9ecc", "url": "https://github.com/apache/pinot/commit/d14596e98662ec1c8779fee809b94d2cb1fc9ecc", "message": "fix some more review comment", "committedDate": "2020-11-16T18:09:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwMzEzOQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r546203139", "bodyText": "isCreateDictionaryForColumn() is the correct method to be used for checking if dictionary is to be created or not. indexCreationInfo.isCreateDictionary() will always return true currently", "author": "siddharthteotia", "createdAt": "2020-12-19T06:59:38Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -216,6 +225,17 @@ public void init(SegmentGeneratorConfig segmentCreationSpec, SegmentIndexCreatio\n             .put(columnName, new LuceneTextIndexCreator(columnName, _indexDir, true /* commitOnClose */));\n       }\n \n+      if (_fstIndexColumns.contains(columnName)) {\n+        Preconditions.checkState(fieldSpec.isSingleValueField(),\n+            \"FST index is currently only supported on single-value columns\");\n+        Preconditions.checkState(fieldSpec.getDataType() == DataType.STRING,\n+            \"FST index is only supported on STRING type columns\");\n+        Preconditions.checkState(indexCreationInfo.isCreateDictionary(),", "originalCommit": "d14596e98662ec1c8779fee809b94d2cb1fc9ecc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU0Mzc5Mg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r546543792", "bodyText": "Done", "author": "pradeepgv42", "createdAt": "2020-12-21T07:14:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwMzEzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwMzQxNg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r546203416", "bodyText": "This is probably not needed right? In fact, may be should add a new enum to TEXT_INDEX_TYPE to something like LUCENE_FST. TEXT_INDEX_TYPE is already serialized in on-disk metadata so just extend it to capture FST", "author": "siddharthteotia", "createdAt": "2020-12-19T07:03:33Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -515,6 +540,7 @@ public static void addColumnMetadataInfo(PropertiesConfiguration properties, Str\n     properties.setProperty(getKeyFor(column, HAS_DICTIONARY), String.valueOf(hasDictionary));\n     properties.setProperty(getKeyFor(column, TEXT_INDEX_TYPE), textIndexType.name());\n     properties.setProperty(getKeyFor(column, HAS_INVERTED_INDEX), String.valueOf(hasInvertedIndex));\n+    properties.setProperty(getKeyFor(column, HAS_FST_INDEX), String.valueOf(hasFSTIndex));", "originalCommit": "d14596e98662ec1c8779fee809b94d2cb1fc9ecc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU0Njg4OQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r546546889", "bodyText": "Wouldn't this make only one of the indicies be available?", "author": "pradeepgv42", "createdAt": "2020-12-21T07:24:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwMzQxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwMzQ4Ng==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r546203486", "bodyText": "Add javadoc", "author": "siddharthteotia", "createdAt": "2020-12-19T07:04:04Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/column/ColumnIndexContainer.java", "diffHunk": "@@ -52,6 +52,8 @@\n    */\n   TextIndexReader getTextIndex();\n \n+  TextIndexReader getFSTIndex();", "originalCommit": "d14596e98662ec1c8779fee809b94d2cb1fc9ecc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU0MzgzNQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r546543835", "bodyText": "done", "author": "pradeepgv42", "createdAt": "2020-12-21T07:15:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwMzQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwMzYyMA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r546203620", "bodyText": "hasFSTIndex is not needed", "author": "siddharthteotia", "createdAt": "2020-12-19T07:05:39Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java", "diffHunk": "@@ -411,6 +411,7 @@ protected void createColumnV1Indices(String column)\n     // Add the column metadata information to the metadata properties.\n     SegmentColumnarIndexCreator\n         .addColumnMetadataInfo(_segmentProperties, column, columnIndexCreationInfo, totalDocs, fieldSpec,\n-            true/*hasDictionary*/, dictionaryElementSize, true/*hasInvertedIndex*/, TextIndexType.NONE);\n+            true/*hasDictionary*/, dictionaryElementSize, true/*hasInvertedIndex*/,\n+            false/*hasFSTIndex*/, TextIndexType.NONE);", "originalCommit": "d14596e98662ec1c8779fee809b94d2cb1fc9ecc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "74bda88d3ad0c1cc2d1c4d06888171713181ba7f", "url": "https://github.com/apache/pinot/commit/74bda88d3ad0c1cc2d1c4d06888171713181ba7f", "message": "Add FST index which works on top of REGEXP_LIKE operator.\nThis index is set to enable only on dictionary encoded string column.", "committedDate": "2020-12-21T07:10:09Z", "type": "forcePushed"}, {"oid": "e18bedaa199ab6f4b4a3cfea1a40d28121de16ab", "url": "https://github.com/apache/pinot/commit/e18bedaa199ab6f4b4a3cfea1a40d28121de16ab", "message": "Add FST index which works on top of REGEXP_LIKE operator.\nThis index is set to enable only on dictionary encoded string column.", "committedDate": "2020-12-23T02:15:28Z", "type": "forcePushed"}, {"oid": "d0405e711f490214a9da9d6bc9e437d5b849305f", "url": "https://github.com/apache/pinot/commit/d0405e711f490214a9da9d6bc9e437d5b849305f", "message": "Add FST index which works on top of REGEXP_LIKE operator.\nThis index is set to enable only on dictionary encoded string column.", "committedDate": "2020-12-24T02:37:39Z", "type": "commit"}, {"oid": "d0405e711f490214a9da9d6bc9e437d5b849305f", "url": "https://github.com/apache/pinot/commit/d0405e711f490214a9da9d6bc9e437d5b849305f", "message": "Add FST index which works on top of REGEXP_LIKE operator.\nThis index is set to enable only on dictionary encoded string column.", "committedDate": "2020-12-24T02:37:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1MjQxNg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r556852416", "bodyText": "HAS_FST_INDEX", "author": "xiangfu0", "createdAt": "2021-01-13T21:35:20Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/metadata/ColumnMetadata.java", "diffHunk": "@@ -97,6 +98,7 @@ public static ColumnMetadata fromPropertiesConfiguration(String column, Properti\n     builder.setContainsNulls(config.getBoolean(getKeyFor(column, HAS_NULL_VALUE)));\n     builder.setHasDictionary(config.getBoolean(getKeyFor(column, HAS_DICTIONARY), true));\n     builder.setHasInvertedIndex(config.getBoolean(getKeyFor(column, HAS_INVERTED_INDEX)));\n+    builder.setHasFSTIndex(config.getBoolean(getKeyFor(column, HAS_INVERTED_INDEX), false));", "originalCommit": "d0405e711f490214a9da9d6bc9e437d5b849305f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg2NTMxOA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r556865318", "bodyText": "ah yup that's correct, let me fix it", "author": "pradeepgv42", "createdAt": "2021-01-13T21:47:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1MjQxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzUyNzY5Ng==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r557527696", "bodyText": "Here is the fix: #6441", "author": "pradeepgv42", "createdAt": "2021-01-14T16:31:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1MjQxNg=="}], "type": "inlineReview"}]}