{"pr_number": 5832, "pr_title": "Added set-diff operators and changed distinctCountThetaSketch syntax", "pr_createdAt": "2020-08-08T00:09:02Z", "pr_url": "https://github.com/apache/pinot/pull/5832", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNDc5Ng==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467334796", "bodyText": "The comment says 4 arguments, but it only lists three of them?", "author": "mayankshriv", "createdAt": "2020-08-08T00:14:15Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -78,9 +102,9 @@ public DistinctCountThetaSketchAggregationFunction(List<ExpressionContext> argum\n       throws SqlParseException {\n     int numArguments = arguments.size();\n \n-    // NOTE: This function expects at least 3 arguments: theta-sketch column, parameters, post-aggregation expression.\n-    Preconditions.checkArgument(numArguments >= 3,\n-        \"DistinctCountThetaSketch expects at least three arguments (theta-sketch column, parameters, post-aggregation expression), got: \",\n+    // NOTE: This function expects at least 4 arguments: theta-sketch column, parameters, post-aggregation expression.", "originalCommit": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ5OTAwMg==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467499002", "bodyText": "+1", "author": "Jackie-Jiang", "createdAt": "2020-08-08T19:58:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNDc5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNTEzOA==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467335138", "bodyText": "We should still keep the auto-deriving of predicates. Granted, we won't be able to use $ notation in that case though. What do you think?", "author": "mayankshriv", "createdAt": "2020-08-08T00:16:17Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -108,35 +136,24 @@ public DistinctCountThetaSketchAggregationFunction(List<ExpressionContext> argum\n     Preconditions.checkArgument(paramsExpression.getType() == ExpressionContext.Type.LITERAL,\n         \"Last argument of DistinctCountThetaSketch must be literal (post-aggregation expression)\");\n     _postAggregationExpression = QueryContextConverterUtils\n-        .getFilter(CalciteSqlParser.compileToExpression(postAggregationExpression.getLiteral()));\n+        .getExpression(CalciteSqlParser.compileToExpression(postAggregationExpression.getLiteral()));\n \n     // Initialize the predicate map\n     _predicateInfoMap = new HashMap<>();\n-    if (numArguments > 3) {\n-      // Predicates are explicitly specified\n-      for (int i = 2; i < numArguments - 1; i++) {\n-        ExpressionContext predicateExpression = arguments.get(i);\n-        Preconditions.checkArgument(predicateExpression.getType() == ExpressionContext.Type.LITERAL,\n-            \"Third to second last argument of DistinctCountThetaSketch must be literal (predicate expression)\");\n-        Predicate predicate = getPredicate(predicateExpression.getLiteral());\n-        _inputExpressions.add(predicate.getLhs());\n-        _predicateInfoMap.put(predicate, new PredicateInfo(predicate));\n-      }\n-    } else {\n-      // Auto-derive predicates from the post-aggregation expression\n-      Stack<FilterContext> stack = new Stack<>();\n-      stack.push(_postAggregationExpression);\n-      while (!stack.isEmpty()) {\n-        FilterContext filter = stack.pop();\n-        if (filter.getType() == FilterContext.Type.PREDICATE) {\n-          Predicate predicate = filter.getPredicate();\n-          _inputExpressions.add(predicate.getLhs());\n-          _predicateInfoMap.put(predicate, new PredicateInfo(predicate));\n-        } else {\n-          stack.addAll(filter.getChildren());\n-        }\n-      }\n+\n+    // Predicates are explicitly specified", "originalCommit": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0MzI4OA==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467343288", "bodyText": "Hmm I've thought about it, but if we auto-derive like before, we'd only have a subset of features. We won't be able to support SET_DIFF at all if go with that approach right?\nUsually, I would think that if there are 2 equivalent ways of writing something, the feature set would be the same. But it seems like only a subset of features would be available if we go with that route.\nI'm personally okay with both approach but wanted to point that out.", "author": "bkuang88", "createdAt": "2020-08-08T01:15:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNTEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0Nzk1MQ==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467347951", "bodyText": "I meant like use the new function call based syntax, with expanded values. For example:\nSET_DIFF('col1=A', 'col2=B')", "author": "mayankshriv", "createdAt": "2020-08-08T02:02:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNTEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUwMTQzNw==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467501437", "bodyText": "@mayankshriv I don't quite follow this comment. In what situation do we need the auto-deriving?", "author": "Jackie-Jiang", "createdAt": "2020-08-08T20:29:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNTEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzMjMxMg==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467532312", "bodyText": "@bkuang88 I don't understand why we can't support SET_DIFF with auto-derive.", "author": "ManojRThakur", "createdAt": "2020-08-09T03:53:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNTEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU5NTA4OA==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467595088", "bodyText": "Yes, that's what I am stating as well @ManojRThakur. We can auto derive as long as the post-aggr-expression uses  actual predicate strings (as opposed to $ notation).\n@Jackie-Jiang Perhaps users will prefer $ notation (in which case you can't auto-derive). But always better to have the option available (especially given that we do support right now).", "author": "mayankshriv", "createdAt": "2020-08-09T15:10:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNTEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA4MjkzMA==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r468082930", "bodyText": "Wonder if that introduces more confusion than flexibility. Because we currently don't want to support complex predicates right? Wouldn't the users make more mistakes or be confused as to when they can use complex predicates and when they cannot?\nAnd if we do start to introduce complex queries in the future, will the syntax be \"UNION($1, $2)\" or \"$1 and $2\" or \"colA='a' or colB='b'\" or \"UNION(colA='a', colB='b')\"?\nGiven the vast possibilities out there, I'm wondering if it's better to just stick to a single syntax so that it doesn't cause confusion in the future in case we do want to modify the predicate complexities.\nWhat do you guys think?", "author": "bkuang88", "createdAt": "2020-08-10T18:02:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNTEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE0MTMzNg==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r468141336", "bodyText": "It seems to me that we can always support this in future (if needed, and/or asked by users) without breaking compatibility with syntax in this PR. So I am fine with not supporting auto-derive for now.", "author": "mayankshriv", "createdAt": "2020-08-10T19:46:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNTEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNTgyOQ==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467335829", "bodyText": "Perhaps pre-substitition in the constructor would be better? For example, if the same $k arg is repeated multiple times, we might avoid the use of matcher using a temporary alias map?", "author": "mayankshriv", "createdAt": "2020-08-08T00:20:48Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -526,28 +543,51 @@ private Predicate getPredicate(String predicateString) {\n    * passed to this method to be used when evaluating the expression.\n    *\n    * @param postAggregationExpression Post-aggregation expression to evaluate (modeled as a filter)\n+   * @param expressions list of aggregation function parameters\n    * @param sketchMap Precomputed sketches for predicates that are part of the expression.\n    * @return Overall evaluated sketch for the expression.\n    */\n-  private Sketch evalPostAggregationExpression(FilterContext postAggregationExpression,\n-      Map<Predicate, Sketch> sketchMap) {\n-    switch (postAggregationExpression.getType()) {\n-      case AND:\n-        Intersection intersection = _setOperationBuilder.buildIntersection();\n-        for (FilterContext child : postAggregationExpression.getChildren()) {\n-          intersection.update(evalPostAggregationExpression(child, sketchMap));\n-        }\n-        return intersection.getResult();\n-      case OR:\n-        Union union = _setOperationBuilder.buildUnion();\n-        for (FilterContext child : postAggregationExpression.getChildren()) {\n-          union.update(evalPostAggregationExpression(child, sketchMap));\n+  private Sketch evalPostAggregationExpression(\n+      final ExpressionContext postAggregationExpression,\n+      final List<Predicate> expressions,\n+      final Map<Predicate, Sketch> sketchMap) {\n+    if (postAggregationExpression.getType() == ExpressionContext.Type.LITERAL) {\n+      throw new IllegalArgumentException(\"Literal not supported in post-aggregation function\");\n+    }\n+\n+    if (postAggregationExpression.getType() == ExpressionContext.Type.IDENTIFIER) {\n+      final Predicate exp =\n+          expressions.get(extractSubstitutionPosition(postAggregationExpression.getLiteral()) - 1);", "originalCommit": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNjA1Mw==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467336053", "bodyText": "Include the string representation of function?", "author": "mayankshriv", "createdAt": "2020-08-08T00:22:22Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -526,28 +543,51 @@ private Predicate getPredicate(String predicateString) {\n    * passed to this method to be used when evaluating the expression.\n    *\n    * @param postAggregationExpression Post-aggregation expression to evaluate (modeled as a filter)\n+   * @param expressions list of aggregation function parameters\n    * @param sketchMap Precomputed sketches for predicates that are part of the expression.\n    * @return Overall evaluated sketch for the expression.\n    */\n-  private Sketch evalPostAggregationExpression(FilterContext postAggregationExpression,\n-      Map<Predicate, Sketch> sketchMap) {\n-    switch (postAggregationExpression.getType()) {\n-      case AND:\n-        Intersection intersection = _setOperationBuilder.buildIntersection();\n-        for (FilterContext child : postAggregationExpression.getChildren()) {\n-          intersection.update(evalPostAggregationExpression(child, sketchMap));\n-        }\n-        return intersection.getResult();\n-      case OR:\n-        Union union = _setOperationBuilder.buildUnion();\n-        for (FilterContext child : postAggregationExpression.getChildren()) {\n-          union.update(evalPostAggregationExpression(child, sketchMap));\n+  private Sketch evalPostAggregationExpression(\n+      final ExpressionContext postAggregationExpression,\n+      final List<Predicate> expressions,\n+      final Map<Predicate, Sketch> sketchMap) {\n+    if (postAggregationExpression.getType() == ExpressionContext.Type.LITERAL) {\n+      throw new IllegalArgumentException(\"Literal not supported in post-aggregation function\");\n+    }\n+\n+    if (postAggregationExpression.getType() == ExpressionContext.Type.IDENTIFIER) {\n+      final Predicate exp =\n+          expressions.get(extractSubstitutionPosition(postAggregationExpression.getLiteral()) - 1);\n+      return sketchMap.get(exp);\n+    }\n+\n+    // shouldn't throw exception because of the validation in the constructor\n+    final MergeFunction func =\n+        MergeFunction.valueOf(postAggregationExpression.getFunction().getFunctionName().toUpperCase());\n+\n+    // handle functions recursively\n+    switch(func) {\n+      case SET_UNION:\n+        final Union union = _setOperationBuilder.buildUnion();\n+        for (final ExpressionContext exp : postAggregationExpression.getFunction().getArguments()) {\n+          union.update(evalPostAggregationExpression(exp, expressions, sketchMap));\n         }\n         return union.getResult();\n-      case PREDICATE:\n-        return sketchMap.get(postAggregationExpression.getPredicate());\n+      case SET_INTERSECT:\n+        final Intersection intersection = _setOperationBuilder.buildIntersection();\n+        for (final ExpressionContext exp : postAggregationExpression.getFunction().getArguments()) {\n+          intersection.update(evalPostAggregationExpression(exp, expressions, sketchMap));\n+        }\n+        return intersection.getResult();\n+      case SET_DIFF:\n+        final List<ExpressionContext> args = postAggregationExpression.getFunction().getArguments();\n+        final AnotB diff = _setOperationBuilder.buildANotB();\n+        final Sketch a = evalPostAggregationExpression(args.get(0), expressions, sketchMap);\n+        final Sketch b = evalPostAggregationExpression(args.get(1), expressions, sketchMap);\n+        diff.update(a, b);\n+        return diff.getResult();\n       default:\n-        throw new IllegalStateException();\n+        throw new IllegalStateException(\"Invalid post-aggregation function.\");", "originalCommit": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNjQxMA==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467336410", "bodyText": "We tend to avoid stream apis in query execution as they tend to have performance overhead.", "author": "mayankshriv", "createdAt": "2020-08-08T00:24:31Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -576,6 +616,69 @@ private SetOperationBuilder getSetOperationBuilder() {\n         : SetOperation.builder().setNominalEntries(_thetaSketchParams.getNominalEntries());\n   }\n \n+  /**\n+   * Validates that the function context's substitution parameters ($1, $2, etc) does not exceed the number\n+   * of predicates passed into the post-aggregation function.\n+   *\n+   * For example, if the post aggregation function is:\n+   * INTERSECT($1, $2, $3)\n+   *\n+   * But there are only 2 arguments passed into the aggregation function, throw an error\n+   * @param context The parsed function context that's a tree structure\n+   * @param numPredicates Max number of predicates available to be substituted\n+   */\n+  private static void validatePostAggregationExpression(final ExpressionContext context, final int numPredicates) {\n+    if (context.getType() == ExpressionContext.Type.LITERAL) {\n+      throw new IllegalArgumentException(\"Invalid post-aggregation function expression syntax.\");\n+    }\n+\n+    if (context.getType() == ExpressionContext.Type.IDENTIFIER) {\n+      int id = extractSubstitutionPosition(context.getIdentifier());\n+      if (id <= 0)\n+        throw new IllegalArgumentException(\"Argument substitution starts at $1\");\n+      if (id > numPredicates)\n+        throw new IllegalArgumentException(\"Argument substitution exceeded number of predicates\");\n+      // if none of the invalid conditions are met above, exit out early\n+      return;\n+    }\n+\n+    if (!MergeFunction.isValid(context.getFunction().getFunctionName())) {\n+      final String allowed =\n+          Arrays.stream(MergeFunction.values())", "originalCommit": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNjQ0NQ==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467336445", "bodyText": "+1", "author": "mayankshriv", "createdAt": "2020-08-08T00:24:43Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -576,6 +616,69 @@ private SetOperationBuilder getSetOperationBuilder() {\n         : SetOperation.builder().setNominalEntries(_thetaSketchParams.getNominalEntries());\n   }\n \n+  /**\n+   * Validates that the function context's substitution parameters ($1, $2, etc) does not exceed the number\n+   * of predicates passed into the post-aggregation function.\n+   *\n+   * For example, if the post aggregation function is:\n+   * INTERSECT($1, $2, $3)\n+   *\n+   * But there are only 2 arguments passed into the aggregation function, throw an error\n+   * @param context The parsed function context that's a tree structure\n+   * @param numPredicates Max number of predicates available to be substituted\n+   */\n+  private static void validatePostAggregationExpression(final ExpressionContext context, final int numPredicates) {\n+    if (context.getType() == ExpressionContext.Type.LITERAL) {\n+      throw new IllegalArgumentException(\"Invalid post-aggregation function expression syntax.\");\n+    }\n+\n+    if (context.getType() == ExpressionContext.Type.IDENTIFIER) {\n+      int id = extractSubstitutionPosition(context.getIdentifier());\n+      if (id <= 0)\n+        throw new IllegalArgumentException(\"Argument substitution starts at $1\");\n+      if (id > numPredicates)\n+        throw new IllegalArgumentException(\"Argument substitution exceeded number of predicates\");\n+      // if none of the invalid conditions are met above, exit out early\n+      return;\n+    }\n+\n+    if (!MergeFunction.isValid(context.getFunction().getFunctionName())) {\n+      final String allowed =\n+          Arrays.stream(MergeFunction.values())\n+              .map(MergeFunction::name)\n+              .collect(Collectors.joining(\",\"));\n+      throw new IllegalArgumentException(\n+          String.format(\"Invalid Theta Sketch aggregation function. Allowed: [%s]\", allowed));\n+    }\n+\n+    switch (MergeFunction.valueOf(context.getFunction().getFunctionName().toUpperCase())) {\n+      case SET_DIFF:\n+        // set diff can only have 2 arguments\n+        if (context.getFunction().getArguments().size() != 2) {", "originalCommit": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNzU0Nw==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467337547", "bodyText": "Isn't the fourth argument postAggregationExpression? If so, it should look more like a set operation, as opposed to \"$1\"?", "author": "mayankshriv", "createdAt": "2020-08-08T00:32:28Z", "path": "pinot-core/src/test/java/org/apache/pinot/queries/DistinctCountThetaSketchTest.java", "diffHunk": "@@ -117,60 +121,77 @@ public void testGroupBySql() {\n     testThetaSketches(true, true);\n   }\n \n+  @Test(expectedExceptions = BadQueryRequestException.class, dataProvider = \"badQueries\")\n+  public void testInvalidNoPredicates(final String query) {\n+    getBrokerResponseForSqlQuery(query);\n+  }\n+\n+  @DataProvider(name = \"badQueries\")\n+  public Object[][] badQueries() {\n+    return new Object[][] {\n+        // need at least 4 arguments in agg func\n+        {\"select distinctCountThetaSketch(colTS, 'nominalEntries=123', '$0') from testTable\"},\n+        // substitution arguments should start at $1\n+        {\"select distinctCountThetaSketch(colTS, 'nominalEntries=123', 'colA = 1', '$0') from testTable\"},\n+        // substituting variable has numeric value higher than the number of predicates provided\n+        {\"select distinctCountThetaSketch(colTS, 'nominalEntries=123', 'colA = 1', '$5') from testTable\"},\n+        // SET_DIFF requires exactly 2 arguments\n+        {\"select distinctCountThetaSketch(colTS, 'nominalEntries=123', 'colA = 1', 'SET_DIFF($1)') from testTable\"},\n+        // invalid merging function\n+        {\"select distinctCountThetaSketch(colTS, 'nominalEntries=123', 'colA = 1', 'asdf') from testTable\"}\n+    };\n+  }\n+\n   private void testThetaSketches(boolean groupBy, boolean sql) {\n     String tsQuery, distinctQuery;\n     String thetaSketchParams = \"nominalEntries=1001\";\n \n     List<String> predicateStrings = Collections.singletonList(\"colA = 1\");\n+    String substitution = \"$1\";\n     String whereClause = Strings.join(predicateStrings, \" or \");\n-    tsQuery = buildQuery(whereClause, thetaSketchParams, predicateStrings, whereClause, groupBy, false);\n+    tsQuery = buildQuery(whereClause, thetaSketchParams, predicateStrings, substitution, groupBy, false);", "originalCommit": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NDM1NA==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467344354", "bodyText": "I think this test wasn't testing any aggregations. It was just selecting a sketch without any aggregations, so I didn't touch it. Would you like me to get rid of this test then?", "author": "bkuang88", "createdAt": "2020-08-08T01:25:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNzU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzOTU1MQ==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467339551", "bodyText": "UNION, INTERSECT, DIFF for concise and simplicity?", "author": "Jackie-Jiang", "createdAt": "2020-08-08T00:47:02Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -57,11 +61,31 @@\n  * <p>TODO: For performance concern, use {@code List<Sketch>} as the intermediate result.\n  */\n public class DistinctCountThetaSketchAggregationFunction implements AggregationFunction<Map<String, Sketch>, Long> {\n+\n+  public enum MergeFunction {\n+    SET_UNION, SET_INTERSECT, SET_DIFF;", "originalCommit": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNDEyMA==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467534120", "bodyText": "I think there are some SQL keywords in there. Do we want to mix real SQL keywords with theta sketch merging functions?", "author": "bkuang88", "createdAt": "2020-08-09T04:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzOTU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU5NTE5OA==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467595198", "bodyText": "I think UNION is SQL reserved keyword, so Calcite will flag it as syntax error. If there's a way around that, I'd also prefer concise names.", "author": "mayankshriv", "createdAt": "2020-08-09T15:11:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzOTU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4Mzg0NQ==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r468183845", "bodyText": "I just tried. It won't let me use UNION/INTERSECT - unless I'm missing something completely.\nBased on the current diff, line 136-137 in DistinctCountThetaSketchAggregationFunction.java throws the exception\n    _postAggregationExpression = QueryContextConverterUtils\n        .getExpression(CalciteSqlParser.compileToExpression(postAggregationExpression.getLiteral()));\nException:\nEncountered \"INTERSECT\" at line 1, column 1.\nWas expecting one of:\n    \"+\" ...\n    \"-\" ...\n    <UNSIGNED_INTEGER_LITERAL> ...\n    <DECIMAL_NUMERIC_LITERAL> ...\n    <APPROX_NUMERIC_LITERAL> ...", "author": "bkuang88", "createdAt": "2020-08-10T21:01:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzOTU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIwMTIzMg==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r468201232", "bodyText": "NVM, seems we cannot use the preserved keyword", "author": "Jackie-Jiang", "createdAt": "2020-08-10T21:39:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzOTU1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ5ODkxNw==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467498917", "bodyText": "Let's not have method just for test in production class. In the test you should test different functions instead of the standardized one (e.g. Intersect($1, $2, $3), INTERSECT($1,$2,$3) etc.)", "author": "Jackie-Jiang", "createdAt": "2020-08-08T19:57:11Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -57,11 +61,31 @@\n  * <p>TODO: For performance concern, use {@code List<Sketch>} as the intermediate result.\n  */\n public class DistinctCountThetaSketchAggregationFunction implements AggregationFunction<Map<String, Sketch>, Long> {\n+\n+  public enum MergeFunction {\n+    SET_UNION, SET_INTERSECT, SET_DIFF;\n+\n+    /** SET_INTERSECT($1, $2, $3) => \"SET_INTERSECT($1,$2,$3)\", useful for unit tests */\n+    public String apply(final String... args) {", "originalCommit": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEyNTUwMw==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r468125503", "bodyText": "Sure, I will get rid of the method for testing purposes. But I'd like to keep the functions for type-safety and inline with some of the other sql function and sql type enums.", "author": "bkuang88", "createdAt": "2020-08-10T19:22:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ5ODkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ5ODk4Mg==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467498982", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final List<Predicate> _predicateInfoList;\n          \n          \n            \n              private final List<Predicate> _predicates;", "author": "Jackie-Jiang", "createdAt": "2020-08-08T19:57:51Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -57,11 +61,31 @@\n  * <p>TODO: For performance concern, use {@code List<Sketch>} as the intermediate result.\n  */\n public class DistinctCountThetaSketchAggregationFunction implements AggregationFunction<Map<String, Sketch>, Long> {\n+\n+  public enum MergeFunction {\n+    SET_UNION, SET_INTERSECT, SET_DIFF;\n+\n+    /** SET_INTERSECT($1, $2, $3) => \"SET_INTERSECT($1,$2,$3)\", useful for unit tests */\n+    public String apply(final String... args) {\n+      final String delimited = String.join(\",\", args);\n+      return String.format(\"%s(%s)\", name(), delimited);\n+    }\n+\n+    public static boolean isValid(final String name) {\n+      return SET_UNION.name().equalsIgnoreCase(name)\n+          || SET_INTERSECT.name().equalsIgnoreCase(name)\n+          || SET_DIFF.name().equalsIgnoreCase(name);\n+    }\n+  }\n+\n+  private static final Pattern ARGUMENT_SUBSTITUTION = Pattern.compile(\"\\\\$(\\\\d+)\");\n+\n   private final ExpressionContext _thetaSketchColumn;\n   private final ThetaSketchParams _thetaSketchParams;\n   private final SetOperationBuilder _setOperationBuilder;\n   private final List<ExpressionContext> _inputExpressions;\n-  private final FilterContext _postAggregationExpression;\n+  private final ExpressionContext _postAggregationExpression;\n+  private final List<Predicate> _predicateInfoList;", "originalCommit": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ5OTE2MA==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467499160", "bodyText": "(Code convention) We don't use final within method argument or local variables. Same for other places", "author": "Jackie-Jiang", "createdAt": "2020-08-08T20:00:06Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -57,11 +61,31 @@\n  * <p>TODO: For performance concern, use {@code List<Sketch>} as the intermediate result.\n  */\n public class DistinctCountThetaSketchAggregationFunction implements AggregationFunction<Map<String, Sketch>, Long> {\n+\n+  public enum MergeFunction {\n+    SET_UNION, SET_INTERSECT, SET_DIFF;\n+\n+    /** SET_INTERSECT($1, $2, $3) => \"SET_INTERSECT($1,$2,$3)\", useful for unit tests */\n+    public String apply(final String... args) {\n+      final String delimited = String.join(\",\", args);\n+      return String.format(\"%s(%s)\", name(), delimited);\n+    }\n+\n+    public static boolean isValid(final String name) {", "originalCommit": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ5OTk3Nw==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467499977", "bodyText": "I feel putting these functions as constant is more readable and easier to use:\npublic static final String UNION = \"UNION\";\nYou can directly switch on the expression.getFunction().getFunctionName().toUpperCase() and not need to worry about MergeFunction.valueOf() throws exception.", "author": "Jackie-Jiang", "createdAt": "2020-08-08T20:10:31Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -57,11 +61,31 @@\n  * <p>TODO: For performance concern, use {@code List<Sketch>} as the intermediate result.\n  */\n public class DistinctCountThetaSketchAggregationFunction implements AggregationFunction<Map<String, Sketch>, Long> {\n+\n+  public enum MergeFunction {", "originalCommit": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEzNjgwMA==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r468136800", "bodyText": "I got rid of the unit testing method as you suggested. But I personally like to keep the enums for type-safety. They don't really have any overhead since they are all static right? Happy to change if you feel strongly.", "author": "bkuang88", "createdAt": "2020-08-10T19:37:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ5OTk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUwMDAyNw==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467500027", "bodyText": "(Code convention) Remove final and reformat. Same for other methods", "author": "Jackie-Jiang", "createdAt": "2020-08-08T20:11:16Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -526,28 +543,51 @@ private Predicate getPredicate(String predicateString) {\n    * passed to this method to be used when evaluating the expression.\n    *\n    * @param postAggregationExpression Post-aggregation expression to evaluate (modeled as a filter)\n+   * @param expressions list of aggregation function parameters\n    * @param sketchMap Precomputed sketches for predicates that are part of the expression.\n    * @return Overall evaluated sketch for the expression.\n    */\n-  private Sketch evalPostAggregationExpression(FilterContext postAggregationExpression,\n-      Map<Predicate, Sketch> sketchMap) {\n-    switch (postAggregationExpression.getType()) {\n-      case AND:\n-        Intersection intersection = _setOperationBuilder.buildIntersection();\n-        for (FilterContext child : postAggregationExpression.getChildren()) {\n-          intersection.update(evalPostAggregationExpression(child, sketchMap));\n-        }\n-        return intersection.getResult();\n-      case OR:\n-        Union union = _setOperationBuilder.buildUnion();\n-        for (FilterContext child : postAggregationExpression.getChildren()) {\n-          union.update(evalPostAggregationExpression(child, sketchMap));\n+  private Sketch evalPostAggregationExpression(\n+      final ExpressionContext postAggregationExpression,", "originalCommit": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUwMDM1OA==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467500358", "bodyText": "(Code convention) Capitalize the first character of the comments. Same for other places", "author": "Jackie-Jiang", "createdAt": "2020-08-08T20:15:39Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -108,35 +136,24 @@ public DistinctCountThetaSketchAggregationFunction(List<ExpressionContext> argum\n     Preconditions.checkArgument(paramsExpression.getType() == ExpressionContext.Type.LITERAL,\n         \"Last argument of DistinctCountThetaSketch must be literal (post-aggregation expression)\");\n     _postAggregationExpression = QueryContextConverterUtils\n-        .getFilter(CalciteSqlParser.compileToExpression(postAggregationExpression.getLiteral()));\n+        .getExpression(CalciteSqlParser.compileToExpression(postAggregationExpression.getLiteral()));\n \n     // Initialize the predicate map\n     _predicateInfoMap = new HashMap<>();\n-    if (numArguments > 3) {\n-      // Predicates are explicitly specified\n-      for (int i = 2; i < numArguments - 1; i++) {\n-        ExpressionContext predicateExpression = arguments.get(i);\n-        Preconditions.checkArgument(predicateExpression.getType() == ExpressionContext.Type.LITERAL,\n-            \"Third to second last argument of DistinctCountThetaSketch must be literal (predicate expression)\");\n-        Predicate predicate = getPredicate(predicateExpression.getLiteral());\n-        _inputExpressions.add(predicate.getLhs());\n-        _predicateInfoMap.put(predicate, new PredicateInfo(predicate));\n-      }\n-    } else {\n-      // Auto-derive predicates from the post-aggregation expression\n-      Stack<FilterContext> stack = new Stack<>();\n-      stack.push(_postAggregationExpression);\n-      while (!stack.isEmpty()) {\n-        FilterContext filter = stack.pop();\n-        if (filter.getType() == FilterContext.Type.PREDICATE) {\n-          Predicate predicate = filter.getPredicate();\n-          _inputExpressions.add(predicate.getLhs());\n-          _predicateInfoMap.put(predicate, new PredicateInfo(predicate));\n-        } else {\n-          stack.addAll(filter.getChildren());\n-        }\n-      }\n+\n+    // Predicates are explicitly specified\n+    for (int i = 2; i < numArguments - 1; i++) {\n+      ExpressionContext predicateExpression = arguments.get(i);\n+      Preconditions.checkArgument(predicateExpression.getType() == ExpressionContext.Type.LITERAL,\n+          \"Third to second last argument of DistinctCountThetaSketch must be literal (predicate expression)\");\n+      Predicate predicate = getPredicate(predicateExpression.getLiteral());\n+      _inputExpressions.add(predicate.getLhs());\n+      _predicateInfoList.add(predicate);\n+      _predicateInfoMap.put(predicate, new PredicateInfo(predicate));\n     }\n+\n+    // first expression is the nominal entries parameter", "originalCommit": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUwMDQ1NQ==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467500455", "bodyText": "Also validate the arguments", "author": "Jackie-Jiang", "createdAt": "2020-08-08T20:16:48Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -576,6 +616,69 @@ private SetOperationBuilder getSetOperationBuilder() {\n         : SetOperation.builder().setNominalEntries(_thetaSketchParams.getNominalEntries());\n   }\n \n+  /**\n+   * Validates that the function context's substitution parameters ($1, $2, etc) does not exceed the number\n+   * of predicates passed into the post-aggregation function.\n+   *\n+   * For example, if the post aggregation function is:\n+   * INTERSECT($1, $2, $3)\n+   *\n+   * But there are only 2 arguments passed into the aggregation function, throw an error\n+   * @param context The parsed function context that's a tree structure\n+   * @param numPredicates Max number of predicates available to be substituted\n+   */\n+  private static void validatePostAggregationExpression(final ExpressionContext context, final int numPredicates) {\n+    if (context.getType() == ExpressionContext.Type.LITERAL) {\n+      throw new IllegalArgumentException(\"Invalid post-aggregation function expression syntax.\");\n+    }\n+\n+    if (context.getType() == ExpressionContext.Type.IDENTIFIER) {\n+      int id = extractSubstitutionPosition(context.getIdentifier());\n+      if (id <= 0)\n+        throw new IllegalArgumentException(\"Argument substitution starts at $1\");\n+      if (id > numPredicates)\n+        throw new IllegalArgumentException(\"Argument substitution exceeded number of predicates\");\n+      // if none of the invalid conditions are met above, exit out early\n+      return;\n+    }\n+\n+    if (!MergeFunction.isValid(context.getFunction().getFunctionName())) {\n+      final String allowed =\n+          Arrays.stream(MergeFunction.values())\n+              .map(MergeFunction::name)\n+              .collect(Collectors.joining(\",\"));\n+      throw new IllegalArgumentException(\n+          String.format(\"Invalid Theta Sketch aggregation function. Allowed: [%s]\", allowed));\n+    }\n+\n+    switch (MergeFunction.valueOf(context.getFunction().getFunctionName().toUpperCase())) {\n+      case SET_DIFF:\n+        // set diff can only have 2 arguments\n+        if (context.getFunction().getArguments().size() != 2) {\n+          throw new IllegalArgumentException(\"SET_DIFF function can only have 2 arguments.\");\n+        }\n+        break;", "originalCommit": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEzNjk2MA==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r468136960", "bodyText": "Done", "author": "bkuang88", "createdAt": "2020-08-10T19:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUwMDQ1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUwMDUxNA==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467500514", "bodyText": "Also validate that there are 2 arguments for DIFF", "author": "Jackie-Jiang", "createdAt": "2020-08-08T20:17:32Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -576,6 +616,69 @@ private SetOperationBuilder getSetOperationBuilder() {\n         : SetOperation.builder().setNominalEntries(_thetaSketchParams.getNominalEntries());\n   }\n \n+  /**\n+   * Validates that the function context's substitution parameters ($1, $2, etc) does not exceed the number\n+   * of predicates passed into the post-aggregation function.\n+   *", "originalCommit": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEzNjkxMg==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r468136912", "bodyText": "Done", "author": "bkuang88", "createdAt": "2020-08-10T19:37:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUwMDUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUwMDcwNA==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467500704", "bodyText": "Check it has more than one argument?\nPrevent inefficient function such as UNION() or UNION($1)", "author": "Jackie-Jiang", "createdAt": "2020-08-08T20:20:09Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -576,6 +616,69 @@ private SetOperationBuilder getSetOperationBuilder() {\n         : SetOperation.builder().setNominalEntries(_thetaSketchParams.getNominalEntries());\n   }\n \n+  /**\n+   * Validates that the function context's substitution parameters ($1, $2, etc) does not exceed the number\n+   * of predicates passed into the post-aggregation function.\n+   *\n+   * For example, if the post aggregation function is:\n+   * INTERSECT($1, $2, $3)\n+   *\n+   * But there are only 2 arguments passed into the aggregation function, throw an error\n+   * @param context The parsed function context that's a tree structure\n+   * @param numPredicates Max number of predicates available to be substituted\n+   */\n+  private static void validatePostAggregationExpression(final ExpressionContext context, final int numPredicates) {\n+    if (context.getType() == ExpressionContext.Type.LITERAL) {\n+      throw new IllegalArgumentException(\"Invalid post-aggregation function expression syntax.\");\n+    }\n+\n+    if (context.getType() == ExpressionContext.Type.IDENTIFIER) {\n+      int id = extractSubstitutionPosition(context.getIdentifier());\n+      if (id <= 0)\n+        throw new IllegalArgumentException(\"Argument substitution starts at $1\");\n+      if (id > numPredicates)\n+        throw new IllegalArgumentException(\"Argument substitution exceeded number of predicates\");\n+      // if none of the invalid conditions are met above, exit out early\n+      return;\n+    }\n+\n+    if (!MergeFunction.isValid(context.getFunction().getFunctionName())) {\n+      final String allowed =\n+          Arrays.stream(MergeFunction.values())\n+              .map(MergeFunction::name)\n+              .collect(Collectors.joining(\",\"));\n+      throw new IllegalArgumentException(\n+          String.format(\"Invalid Theta Sketch aggregation function. Allowed: [%s]\", allowed));\n+    }\n+\n+    switch (MergeFunction.valueOf(context.getFunction().getFunctionName().toUpperCase())) {\n+      case SET_DIFF:\n+        // set diff can only have 2 arguments\n+        if (context.getFunction().getArguments().size() != 2) {\n+          throw new IllegalArgumentException(\"SET_DIFF function can only have 2 arguments.\");\n+        }\n+        break;\n+      case SET_UNION:\n+      case SET_INTERSECT:", "originalCommit": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEzNzAwNw==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r468137007", "bodyText": "Done", "author": "bkuang88", "createdAt": "2020-08-10T19:38:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUwMDcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUwMDc3MQ==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467500771", "bodyText": "No need to pass in this argument. Directly use member variable _predicates", "author": "Jackie-Jiang", "createdAt": "2020-08-08T20:21:06Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -526,28 +543,51 @@ private Predicate getPredicate(String predicateString) {\n    * passed to this method to be used when evaluating the expression.\n    *\n    * @param postAggregationExpression Post-aggregation expression to evaluate (modeled as a filter)\n+   * @param expressions list of aggregation function parameters\n    * @param sketchMap Precomputed sketches for predicates that are part of the expression.\n    * @return Overall evaluated sketch for the expression.\n    */\n-  private Sketch evalPostAggregationExpression(FilterContext postAggregationExpression,\n-      Map<Predicate, Sketch> sketchMap) {\n-    switch (postAggregationExpression.getType()) {\n-      case AND:\n-        Intersection intersection = _setOperationBuilder.buildIntersection();\n-        for (FilterContext child : postAggregationExpression.getChildren()) {\n-          intersection.update(evalPostAggregationExpression(child, sketchMap));\n-        }\n-        return intersection.getResult();\n-      case OR:\n-        Union union = _setOperationBuilder.buildUnion();\n-        for (FilterContext child : postAggregationExpression.getChildren()) {\n-          union.update(evalPostAggregationExpression(child, sketchMap));\n+  private Sketch evalPostAggregationExpression(\n+      final ExpressionContext postAggregationExpression,\n+      final List<Predicate> expressions,", "originalCommit": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzMTkzMw==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r467531933", "bodyText": "Lets make sure we call out in the documentation that the order matters in case of SET_DIFF", "author": "ManojRThakur", "createdAt": "2020-08-09T03:47:36Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -526,28 +543,51 @@ private Predicate getPredicate(String predicateString) {\n    * passed to this method to be used when evaluating the expression.\n    *\n    * @param postAggregationExpression Post-aggregation expression to evaluate (modeled as a filter)\n+   * @param expressions list of aggregation function parameters\n    * @param sketchMap Precomputed sketches for predicates that are part of the expression.\n    * @return Overall evaluated sketch for the expression.\n    */\n-  private Sketch evalPostAggregationExpression(FilterContext postAggregationExpression,\n-      Map<Predicate, Sketch> sketchMap) {\n-    switch (postAggregationExpression.getType()) {\n-      case AND:\n-        Intersection intersection = _setOperationBuilder.buildIntersection();\n-        for (FilterContext child : postAggregationExpression.getChildren()) {\n-          intersection.update(evalPostAggregationExpression(child, sketchMap));\n-        }\n-        return intersection.getResult();\n-      case OR:\n-        Union union = _setOperationBuilder.buildUnion();\n-        for (FilterContext child : postAggregationExpression.getChildren()) {\n-          union.update(evalPostAggregationExpression(child, sketchMap));\n+  private Sketch evalPostAggregationExpression(\n+      final ExpressionContext postAggregationExpression,\n+      final List<Predicate> expressions,\n+      final Map<Predicate, Sketch> sketchMap) {\n+    if (postAggregationExpression.getType() == ExpressionContext.Type.LITERAL) {\n+      throw new IllegalArgumentException(\"Literal not supported in post-aggregation function\");\n+    }\n+\n+    if (postAggregationExpression.getType() == ExpressionContext.Type.IDENTIFIER) {\n+      final Predicate exp =\n+          expressions.get(extractSubstitutionPosition(postAggregationExpression.getLiteral()) - 1);\n+      return sketchMap.get(exp);\n+    }\n+\n+    // shouldn't throw exception because of the validation in the constructor\n+    final MergeFunction func =\n+        MergeFunction.valueOf(postAggregationExpression.getFunction().getFunctionName().toUpperCase());\n+\n+    // handle functions recursively\n+    switch(func) {\n+      case SET_UNION:\n+        final Union union = _setOperationBuilder.buildUnion();\n+        for (final ExpressionContext exp : postAggregationExpression.getFunction().getArguments()) {\n+          union.update(evalPostAggregationExpression(exp, expressions, sketchMap));\n         }\n         return union.getResult();\n-      case PREDICATE:\n-        return sketchMap.get(postAggregationExpression.getPredicate());\n+      case SET_INTERSECT:\n+        final Intersection intersection = _setOperationBuilder.buildIntersection();\n+        for (final ExpressionContext exp : postAggregationExpression.getFunction().getArguments()) {\n+          intersection.update(evalPostAggregationExpression(exp, expressions, sketchMap));\n+        }\n+        return intersection.getResult();\n+      case SET_DIFF:\n+        final List<ExpressionContext> args = postAggregationExpression.getFunction().getArguments();\n+        final AnotB diff = _setOperationBuilder.buildANotB();\n+        final Sketch a = evalPostAggregationExpression(args.get(0), expressions, sketchMap);\n+        final Sketch b = evalPostAggregationExpression(args.get(1), expressions, sketchMap);\n+        diff.update(a, b);", "originalCommit": "f1bef22f8f1028c9c17efd1dcaa6f8b9578f3867", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEzODE3Mw==", "url": "https://github.com/apache/pinot/pull/5832#discussion_r468138173", "bodyText": "Good call. Done - updated in the release notes in the PR.", "author": "bkuang88", "createdAt": "2020-08-10T19:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzMTkzMw=="}], "type": "inlineReview"}, {"oid": "c8fa12ead53abdf485dbf2c2f987b5c482df205d", "url": "https://github.com/apache/pinot/commit/c8fa12ead53abdf485dbf2c2f987b5c482df205d", "message": "Added set-diff operators and changed distinctCountThetaSketch syntax\nslightly", "committedDate": "2020-08-10T19:35:43Z", "type": "forcePushed"}, {"oid": "9a29ae6d86512a5cc70981244ba80fdff2518527", "url": "https://github.com/apache/pinot/commit/9a29ae6d86512a5cc70981244ba80fdff2518527", "message": "Added set-diff operators and changed distinctCountThetaSketch syntax\nslightly", "committedDate": "2020-08-10T20:22:16Z", "type": "forcePushed"}, {"oid": "c82534d188c462bc5a9196a3de87c60a202379ca", "url": "https://github.com/apache/pinot/commit/c82534d188c462bc5a9196a3de87c60a202379ca", "message": "Added set-diff operators and changed distinctCountThetaSketch syntax\nslightly", "committedDate": "2020-08-10T20:27:04Z", "type": "forcePushed"}, {"oid": "4c4d5c52dc7519b0affd5727e12c4366a2064773", "url": "https://github.com/apache/pinot/commit/4c4d5c52dc7519b0affd5727e12c4366a2064773", "message": "Added set-diff operators and changed distinctCountThetaSketch syntax\nslightly", "committedDate": "2020-08-10T20:30:42Z", "type": "forcePushed"}, {"oid": "c8fa12ead53abdf485dbf2c2f987b5c482df205d", "url": "https://github.com/apache/pinot/commit/c8fa12ead53abdf485dbf2c2f987b5c482df205d", "message": "Added set-diff operators and changed distinctCountThetaSketch syntax\nslightly", "committedDate": "2020-08-10T19:35:43Z", "type": "forcePushed"}, {"oid": "c78c568b92d15f2454d704d34f645fdd0bfccfce", "url": "https://github.com/apache/pinot/commit/c78c568b92d15f2454d704d34f645fdd0bfccfce", "message": "Added set-diff operators and changed distinctCountThetaSketch syntax\nslightly", "committedDate": "2020-08-10T20:42:02Z", "type": "forcePushed"}, {"oid": "427c41d48cd5daf197706e1975cf4eb16f2ad679", "url": "https://github.com/apache/pinot/commit/427c41d48cd5daf197706e1975cf4eb16f2ad679", "message": "Added set-diff operators and changed distinctCountThetaSketch syntax", "committedDate": "2020-08-11T17:52:25Z", "type": "commit"}, {"oid": "427c41d48cd5daf197706e1975cf4eb16f2ad679", "url": "https://github.com/apache/pinot/commit/427c41d48cd5daf197706e1975cf4eb16f2ad679", "message": "Added set-diff operators and changed distinctCountThetaSketch syntax", "committedDate": "2020-08-11T17:52:25Z", "type": "forcePushed"}]}