{"pr_number": 5440, "pr_title": "Add GenericTransformFunction wrapper for simple ScalarFunctions", "pr_createdAt": "2020-05-25T08:12:52Z", "pr_url": "https://github.com/apache/pinot/pull/5440", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMDI2Mw==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r429800263", "bodyText": "missing float", "author": "kishoreg", "createdAt": "2020-05-25T08:21:52Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/GenericTransformFunction.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class GenericTransformFunction extends BaseTransformFunction {\n+\n+  private FunctionInfo _info;\n+  FunctionInvoker _functionInvoker;\n+  String _name;\n+  Object[] _args;\n+  List<Integer> _nonLiteralArgIndices;\n+  List<FieldSpec.DataType> _nonLiteralArgType;\n+  List<TransformFunction> _nonLiteralTransformFunction;\n+  String[] _stringResult;\n+\n+  public GenericTransformFunction() {\n+    _nonLiteralArgIndices = new ArrayList<>();\n+    _nonLiteralArgType = new ArrayList<>();\n+    _nonLiteralTransformFunction = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return _name;\n+  }\n+\n+  public void setFunction(String functionName, FunctionInfo info)\n+      throws Exception {\n+    _name = functionName;\n+    _info = info;\n+    _functionInvoker = new FunctionInvoker(info);\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions.checkArgument(arguments.size() == _functionInvoker.getParameterTypes().length,\n+        \"The number of arguments are not same for scalar function and transform function: %s\", getName());\n+\n+    _args = new Object[arguments.size()];\n+    for (int i = 0; i < arguments.size(); i++) {\n+      TransformFunction function = arguments.get(i);\n+      if (function instanceof LiteralTransformFunction) {\n+        String literal = ((LiteralTransformFunction) function).getLiteral();\n+        Class paramType = _functionInvoker.getParameterTypes()[i];\n+        switch (paramType.getTypeName()) {\n+          case \"java.lang.Integer\":", "originalCommit": "88f5e959de8eb0b227bd94df755489241c248c46", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMDk2MQ==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r429800961", "bodyText": "you can add another switch statement in init to set this based on the return type of the scalarfunction, see functionInvoker.getReturnType", "author": "kishoreg", "createdAt": "2020-05-25T08:23:14Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/GenericTransformFunction.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class GenericTransformFunction extends BaseTransformFunction {\n+\n+  private FunctionInfo _info;\n+  FunctionInvoker _functionInvoker;\n+  String _name;\n+  Object[] _args;\n+  List<Integer> _nonLiteralArgIndices;\n+  List<FieldSpec.DataType> _nonLiteralArgType;\n+  List<TransformFunction> _nonLiteralTransformFunction;\n+  String[] _stringResult;\n+\n+  public GenericTransformFunction() {\n+    _nonLiteralArgIndices = new ArrayList<>();\n+    _nonLiteralArgType = new ArrayList<>();\n+    _nonLiteralTransformFunction = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return _name;\n+  }\n+\n+  public void setFunction(String functionName, FunctionInfo info)\n+      throws Exception {\n+    _name = functionName;\n+    _info = info;\n+    _functionInvoker = new FunctionInvoker(info);\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions.checkArgument(arguments.size() == _functionInvoker.getParameterTypes().length,\n+        \"The number of arguments are not same for scalar function and transform function: %s\", getName());\n+\n+    _args = new Object[arguments.size()];\n+    for (int i = 0; i < arguments.size(); i++) {\n+      TransformFunction function = arguments.get(i);\n+      if (function instanceof LiteralTransformFunction) {\n+        String literal = ((LiteralTransformFunction) function).getLiteral();\n+        Class paramType = _functionInvoker.getParameterTypes()[i];\n+        switch (paramType.getTypeName()) {\n+          case \"java.lang.Integer\":\n+            _args[i] = Integer.parseInt(literal);\n+            break;\n+          case \"java.lang.String\":\n+            _args[i] = literal;\n+            break;\n+          case \"java.lang.Double\":\n+            _args[i] = Double.valueOf(literal);\n+            break;\n+          case \"java.lang.Long\":\n+            _args[i] = Long.valueOf(literal);\n+            break;\n+          default:\n+            throw new RuntimeException(\n+                \"Unsupported data type \" + paramType.getTypeName() + \"for transform function \" + getName());\n+        }\n+      } else {\n+        _nonLiteralArgIndices.add(i);\n+        _nonLiteralTransformFunction.add(function);\n+        Class paramType = _functionInvoker.getParameterTypes()[i];\n+\n+        switch (paramType.getTypeName()) {\n+          case \"java.lang.Integer\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.INT);\n+            break;\n+          case \"java.lang.String\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.STRING);\n+            break;\n+          case \"java.lang.Double\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.DOUBLE);\n+            break;\n+          case \"java.lang.Long\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.LONG);\n+            break;\n+          default:\n+            throw new RuntimeException(\n+                \"Unsupported data type \" + paramType.getTypeName() + \"for transform function \" + getName());\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return STRING_SV_NO_DICTIONARY_METADATA;", "originalCommit": "88f5e959de8eb0b227bd94df755489241c248c46", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg1NDUyMw==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r429854523", "bodyText": "For return type just a switch won't work\nDifferent return types will need a different function overrides\ne.g. transformToStringValuesSV for string, transformToIntValuesSV for int and so on\nOr am I missing something?", "author": "KKcorps", "createdAt": "2020-05-25T10:12:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMDk2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA5NTM5MQ==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r430095391", "bodyText": "You are right, we need to override methods for int, long, double, float. Shouldn't be hard, its mostly copy-paste. similar to _stringResultArray, create a resultArray for each type and instantiate them in the init", "author": "kishoreg", "createdAt": "2020-05-25T23:22:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMDk2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ4ODU4Nw==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r430488587", "bodyText": "does it look better now?", "author": "KKcorps", "createdAt": "2020-05-26T15:11:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMDk2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA3NzQ0NA==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r430077444", "bodyText": "I am not sure I follow the logic here. Is GenericTransformFunction going to be the wrapper or single point of entry for all transform functions in Pinot. The name seems to suggest so but this code implies that only the functions registered in the registry can be treated as GenericTransformFunction.\nThis also brings the point that we should add good javadocs to the new class.", "author": "siddharthteotia", "createdAt": "2020-05-25T21:22:36Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/TransformFunctionFactory.java", "diffHunk": "@@ -112,13 +115,24 @@ public static TransformFunction get(TransformExpressionTree expression, Map<Stri\n     switch (expression.getExpressionType()) {\n       case FUNCTION:\n         String functionName = expression.getValue();\n-        Class<? extends TransformFunction> transformFunctionClass = TRANSFORM_FUNCTION_MAP.get(functionName);\n+        Class<? extends TransformFunction> transformFunctionClass;\n+        FunctionInfo functionInfo = null;\n+        if (FunctionRegistry.containsFunctionByName(functionName)) {\n+          transformFunctionClass = GenericTransformFunction.class;\n+          functionInfo = FunctionRegistry.getFunctionByName(functionName);", "originalCommit": "88f5e959de8eb0b227bd94df755489241c248c46", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYyNzcwOQ==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r430627709", "bodyText": "its a wrapper for all functions in FunctionRegistry. what name do you suggest - ScalarTransformFunctionWrapper", "author": "kishoreg", "createdAt": "2020-05-26T18:40:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA3NzQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA3ODA4OQ==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r430078089", "bodyText": "I believe this exercises the compilation path. You should add tests in CalciteSqlCompiler test file as well.\nAlso, we should add tests for end to end query execution. See TransformQueriesTest class or consider adding execution tests to one of the existing query tests", "author": "siddharthteotia", "createdAt": "2020-05-25T21:25:39Z", "path": "pinot-core/src/test/java/org/apache/pinot/core/operator/transform/function/GenericTransformFunctionTest.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.pinot.common.request.transform.TransformExpressionTree;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class GenericTransformFunctionTest extends BaseTransformFunctionTest {\n+\n+  @Test", "originalCommit": "88f5e959de8eb0b227bd94df755489241c248c46", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYyMjQyMA==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r430622420", "bodyText": "should we move this to constructor @mayankshriv @Jackie-Jiang", "author": "kishoreg", "createdAt": "2020-05-26T18:31:51Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/GenericTransformFunction.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class GenericTransformFunction extends BaseTransformFunction {\n+\n+  private FunctionInfo _info;\n+  FunctionInvoker _functionInvoker;\n+  String _name;\n+  Object[] _args;\n+  List<Integer> _nonLiteralArgIndices;\n+  List<FieldSpec.DataType> _nonLiteralArgType;\n+  List<TransformFunction> _nonLiteralTransformFunction;\n+  String[] _stringResult;\n+  int[] _integerResult;\n+  float[] _floatResult;\n+  double[] _doubleResult;\n+  long[] _longResult;\n+\n+  public GenericTransformFunction() {\n+    _nonLiteralArgIndices = new ArrayList<>();\n+    _nonLiteralArgType = new ArrayList<>();\n+    _nonLiteralTransformFunction = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return _name;\n+  }\n+\n+  public void setFunction(String functionName, FunctionInfo info)", "originalCommit": "c67f6d3a9b6c9bd80138fe9415505d897a8db977", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYyMzAxOQ==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r430623019", "bodyText": "better to do this in init and save the metadata, Pinot might call this function multiple times", "author": "kishoreg", "createdAt": "2020-05-26T18:32:54Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/GenericTransformFunction.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class GenericTransformFunction extends BaseTransformFunction {\n+\n+  private FunctionInfo _info;\n+  FunctionInvoker _functionInvoker;\n+  String _name;\n+  Object[] _args;\n+  List<Integer> _nonLiteralArgIndices;\n+  List<FieldSpec.DataType> _nonLiteralArgType;\n+  List<TransformFunction> _nonLiteralTransformFunction;\n+  String[] _stringResult;\n+  int[] _integerResult;\n+  float[] _floatResult;\n+  double[] _doubleResult;\n+  long[] _longResult;\n+\n+  public GenericTransformFunction() {\n+    _nonLiteralArgIndices = new ArrayList<>();\n+    _nonLiteralArgType = new ArrayList<>();\n+    _nonLiteralTransformFunction = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return _name;\n+  }\n+\n+  public void setFunction(String functionName, FunctionInfo info)\n+      throws Exception {\n+    _name = functionName;\n+    _info = info;\n+    _functionInvoker = new FunctionInvoker(info);\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions.checkArgument(arguments.size() == _functionInvoker.getParameterTypes().length,\n+        \"The number of arguments are not same for scalar function and transform function: %s\", getName());\n+\n+    _args = new Object[arguments.size()];\n+    for (int i = 0; i < arguments.size(); i++) {\n+      TransformFunction function = arguments.get(i);\n+      if (function instanceof LiteralTransformFunction) {\n+        String literal = ((LiteralTransformFunction) function).getLiteral();\n+        Class paramType = _functionInvoker.getParameterTypes()[i];\n+        switch (paramType.getTypeName()) {\n+          case \"java.lang.Integer\":\n+            _args[i] = Integer.parseInt(literal);\n+            break;\n+          case \"java.lang.String\":\n+            _args[i] = literal;\n+            break;\n+          case \"java.lang.Double\":\n+            _args[i] = Double.valueOf(literal);\n+            break;\n+          case \"java.lang.Float\":\n+            _args[i] = Float.valueOf(literal);\n+            break;\n+          case \"java.lang.Long\":\n+            _args[i] = Long.valueOf(literal);\n+            break;\n+          default:\n+            throw new RuntimeException(\n+                \"Unsupported data type \" + paramType.getTypeName() + \"for transform function \" + getName());\n+        }\n+      } else {\n+        _nonLiteralArgIndices.add(i);\n+        _nonLiteralTransformFunction.add(function);\n+        Class paramType = _functionInvoker.getParameterTypes()[i];\n+\n+        switch (paramType.getTypeName()) {\n+          case \"java.lang.Integer\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.INT);\n+            break;\n+          case \"java.lang.String\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.STRING);\n+            break;\n+          case \"java.lang.Double\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.DOUBLE);\n+            break;\n+          case \"java.lang.Float\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.FLOAT);\n+            break;\n+          case \"java.lang.Long\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.LONG);\n+            break;\n+          default:\n+            throw new RuntimeException(\n+                \"Unsupported data type \" + paramType.getTypeName() + \"for transform function \" + getName());\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    Class returnType = _functionInvoker.getReturnType();", "originalCommit": "c67f6d3a9b6c9bd80138fe9415505d897a8db977", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYyNjQyMg==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r430626422", "bodyText": "it's better to duplicate this for every type event though this code looks better for readability.\nthe switch case on every invocation will hurt perf", "author": "kishoreg", "createdAt": "2020-05-26T18:38:46Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/GenericTransformFunction.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class GenericTransformFunction extends BaseTransformFunction {\n+\n+  private FunctionInfo _info;\n+  FunctionInvoker _functionInvoker;\n+  String _name;\n+  Object[] _args;\n+  List<Integer> _nonLiteralArgIndices;\n+  List<FieldSpec.DataType> _nonLiteralArgType;\n+  List<TransformFunction> _nonLiteralTransformFunction;\n+  String[] _stringResult;\n+  int[] _integerResult;\n+  float[] _floatResult;\n+  double[] _doubleResult;\n+  long[] _longResult;\n+\n+  public GenericTransformFunction() {\n+    _nonLiteralArgIndices = new ArrayList<>();\n+    _nonLiteralArgType = new ArrayList<>();\n+    _nonLiteralTransformFunction = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return _name;\n+  }\n+\n+  public void setFunction(String functionName, FunctionInfo info)\n+      throws Exception {\n+    _name = functionName;\n+    _info = info;\n+    _functionInvoker = new FunctionInvoker(info);\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions.checkArgument(arguments.size() == _functionInvoker.getParameterTypes().length,\n+        \"The number of arguments are not same for scalar function and transform function: %s\", getName());\n+\n+    _args = new Object[arguments.size()];\n+    for (int i = 0; i < arguments.size(); i++) {\n+      TransformFunction function = arguments.get(i);\n+      if (function instanceof LiteralTransformFunction) {\n+        String literal = ((LiteralTransformFunction) function).getLiteral();\n+        Class paramType = _functionInvoker.getParameterTypes()[i];\n+        switch (paramType.getTypeName()) {\n+          case \"java.lang.Integer\":\n+            _args[i] = Integer.parseInt(literal);\n+            break;\n+          case \"java.lang.String\":\n+            _args[i] = literal;\n+            break;\n+          case \"java.lang.Double\":\n+            _args[i] = Double.valueOf(literal);\n+            break;\n+          case \"java.lang.Float\":\n+            _args[i] = Float.valueOf(literal);\n+            break;\n+          case \"java.lang.Long\":\n+            _args[i] = Long.valueOf(literal);\n+            break;\n+          default:\n+            throw new RuntimeException(\n+                \"Unsupported data type \" + paramType.getTypeName() + \"for transform function \" + getName());\n+        }\n+      } else {\n+        _nonLiteralArgIndices.add(i);\n+        _nonLiteralTransformFunction.add(function);\n+        Class paramType = _functionInvoker.getParameterTypes()[i];\n+\n+        switch (paramType.getTypeName()) {\n+          case \"java.lang.Integer\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.INT);\n+            break;\n+          case \"java.lang.String\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.STRING);\n+            break;\n+          case \"java.lang.Double\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.DOUBLE);\n+            break;\n+          case \"java.lang.Float\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.FLOAT);\n+            break;\n+          case \"java.lang.Long\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.LONG);\n+            break;\n+          default:\n+            throw new RuntimeException(\n+                \"Unsupported data type \" + paramType.getTypeName() + \"for transform function \" + getName());\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    Class returnType = _functionInvoker.getReturnType();\n+    switch(returnType.getTypeName()) {\n+      case \"java.lang.Integer\": return INT_SV_NO_DICTIONARY_METADATA;\n+      case \"java.lang.Long\": return LONG_SV_NO_DICTIONARY_METADATA;\n+      case \"java.lang.Float\": return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+      case \"java.lang.Double\": return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+      case \"java.lang.String\": return STRING_SV_NO_DICTIONARY_METADATA;\n+      default:\n+        throw new RuntimeException(\"Unsupported data type \" + returnType.getTypeName() + \"for transform function \" + getName());\n+    }\n+  }\n+\n+  @SuppressWarnings(\"Duplicates\")\n+  @Override\n+  public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {\n+    if (_integerResult == null) {\n+      _integerResult = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    transformValues(projectionBlock);\n+    return _integerResult;\n+  }\n+\n+  @SuppressWarnings(\"Duplicates\")\n+  @Override\n+  public long[] transformToLongValuesSV(ProjectionBlock projectionBlock) {\n+    if (_longResult == null) {\n+      _longResult = new long[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    transformValues(projectionBlock);\n+    return _longResult;\n+  }\n+\n+  @SuppressWarnings(\"Duplicates\")\n+  @Override\n+  public float[] transformToFloatValuesSV(ProjectionBlock projectionBlock) {\n+    if (_floatResult == null) {\n+      _floatResult = new float[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    transformValues(projectionBlock);\n+    return _floatResult;\n+  }\n+\n+  @SuppressWarnings(\"Duplicates\")\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_doubleResult == null) {\n+      _doubleResult = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    transformValues(projectionBlock);\n+    return _doubleResult;\n+  }\n+\n+  @SuppressWarnings(\"Duplicates\")\n+  @Override\n+  public String[] transformToStringValuesSV(ProjectionBlock projectionBlock) {\n+    if (_stringResult == null) {\n+      _stringResult = new String[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    transformValues(projectionBlock);\n+    return _stringResult;\n+  }\n+\n+  private void transformValues(ProjectionBlock projectionBlock) {\n+    int length = projectionBlock.getNumDocs();\n+    int numNonLiteralArgs = _nonLiteralArgIndices.size();\n+    Object[][] nonLiteralBlockValues = new Object[numNonLiteralArgs][];\n+\n+    transformNonLiteralArgsToValues(projectionBlock, numNonLiteralArgs, nonLiteralBlockValues);\n+\n+    //now invoke the actual function\n+    for (int i = 0; i < length; i++) {\n+      for (int k = 0; k < numNonLiteralArgs; k++) {\n+        _args[_nonLiteralArgIndices.get(k)] = nonLiteralBlockValues[k][i];\n+      }\n+\n+      Class returnType = _functionInvoker.getReturnType();", "originalCommit": "c67f6d3a9b6c9bd80138fe9415505d897a8db977", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0ODEyNQ==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432148125", "bodyText": "java doc", "author": "kishoreg", "createdAt": "2020-05-28T21:59:57Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/function/StringFunctions.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.function;\n+\n+import java.util.regex.Pattern;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.pinot.common.function.annotations.ScalarFunction;\n+\n+\n+/**\n+ *\n+ */\n+public class StringFunctions {", "originalCommit": "4fa6827b6f9b3a950596ef50c305a52f86139eee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0ODQyNw==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432148427", "bodyText": "add the ability to set name, add javadocs", "author": "kishoreg", "createdAt": "2020-05-28T22:00:38Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/function/annotations/ScalarFunction.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.function.annotations;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.METHOD)\n+public @interface ScalarFunction {", "originalCommit": "4fa6827b6f9b3a950596ef50c305a52f86139eee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1aee329f7f06bc84906a25c2bf6a6c1226e22fc4", "url": "https://github.com/apache/pinot/commit/1aee329f7f06bc84906a25c2bf6a6c1226e22fc4", "message": "Adding support to invoke any scalar function via GenericTransformFunction", "committedDate": "2020-05-29T22:33:51Z", "type": "commit"}, {"oid": "05f5c69bcf3a7710850d01c3b9e25d26b3d53fe1", "url": "https://github.com/apache/pinot/commit/05f5c69bcf3a7710850d01c3b9e25d26b3d53fe1", "message": "string functions", "committedDate": "2020-05-29T22:33:51Z", "type": "commit"}, {"oid": "85d2753145efbaa5eecda4b181800e8ab016587f", "url": "https://github.com/apache/pinot/commit/85d2753145efbaa5eecda4b181800e8ab016587f", "message": "adding string functions along with tests", "committedDate": "2020-05-29T22:34:36Z", "type": "commit"}, {"oid": "58a16cadabdd59f6f7678e01fb9dd37a39ed75ae", "url": "https://github.com/apache/pinot/commit/58a16cadabdd59f6f7678e01fb9dd37a39ed75ae", "message": "adding support for multiple types", "committedDate": "2020-05-29T22:34:36Z", "type": "commit"}, {"oid": "46006307aeb3a3bcd663d343d0db56d19d0310f5", "url": "https://github.com/apache/pinot/commit/46006307aeb3a3bcd663d343d0db56d19d0310f5", "message": "refactoring", "committedDate": "2020-05-29T22:34:36Z", "type": "commit"}, {"oid": "bf2fa38e8684fbb185256a3394abf0d097e84ede", "url": "https://github.com/apache/pinot/commit/bf2fa38e8684fbb185256a3394abf0d097e84ede", "message": "adding scalar function annotation", "committedDate": "2020-05-29T22:35:23Z", "type": "commit"}, {"oid": "20a099ced08be67ef64315d90e02a0d8c4278694", "url": "https://github.com/apache/pinot/commit/20a099ced08be67ef64315d90e02a0d8c4278694", "message": "refactoring and adding javadoc", "committedDate": "2020-05-29T22:36:10Z", "type": "commit"}, {"oid": "90f3854192715ca58cb8eafd88e34ef538644731", "url": "https://github.com/apache/pinot/commit/90f3854192715ca58cb8eafd88e34ef538644731", "message": "adding pom property", "committedDate": "2020-05-29T22:36:10Z", "type": "commit"}, {"oid": "90f3854192715ca58cb8eafd88e34ef538644731", "url": "https://github.com/apache/pinot/commit/90f3854192715ca58cb8eafd88e34ef538644731", "message": "adding pom property", "committedDate": "2020-05-29T22:36:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4NTA2OQ==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432785069", "bodyText": "(nit) Suggest putting name in front of method", "author": "Jackie-Jiang", "createdAt": "2020-05-29T23:49:02Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/function/FunctionRegistry.java", "diffHunk": "@@ -53,8 +61,12 @@ public static FunctionInfo getFunctionByNameWithApplicableArgumentTypes(String f\n   }\n \n   public static void registerFunction(Method method) {\n+    registerFunction(method, method.getName().toLowerCase());\n+  }\n+\n+  public static void registerFunction(Method method, String name) {", "originalCommit": "90f3854192715ca58cb8eafd88e34ef538644731", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4Nzg0MQ==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432787841", "bodyText": "For readability, can we always order them as INT, LONG, FLOAT, DOUBLE, STRING? Same for other places", "author": "Jackie-Jiang", "createdAt": "2020-05-30T00:05:25Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/ScalarTransformFunctionWrapper.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class ScalarTransformFunctionWrapper extends BaseTransformFunction {\n+\n+  FunctionInvoker _functionInvoker;\n+  String _name;\n+  Object[] _args;\n+  List<Integer> _nonLiteralArgIndices;\n+  List<FieldSpec.DataType> _nonLiteralArgType;\n+  List<TransformFunction> _nonLiteralTransformFunction;\n+  TransformResultMetadata _transformResultMetadata;\n+  String[] _stringResult;\n+  int[] _integerResult;\n+  float[] _floatResult;\n+  double[] _doubleResult;\n+  long[] _longResult;\n+\n+  public ScalarTransformFunctionWrapper() {\n+    _nonLiteralArgIndices = new ArrayList<>();\n+    _nonLiteralArgType = new ArrayList<>();\n+    _nonLiteralTransformFunction = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return _name;\n+  }\n+\n+  public void setFunction(String functionName, FunctionInfo info)\n+      throws Exception {\n+    _name = functionName;\n+    _functionInvoker = new FunctionInvoker(info);\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions.checkArgument(arguments.size() == _functionInvoker.getParameterTypes().length,\n+        \"The number of arguments are not same for scalar function and transform function: %s\", getName());\n+\n+    _args = new Object[arguments.size()];\n+    for (int i = 0; i < arguments.size(); i++) {\n+      TransformFunction function = arguments.get(i);\n+      if (function instanceof LiteralTransformFunction) {\n+        String literal = ((LiteralTransformFunction) function).getLiteral();\n+        Class paramType = _functionInvoker.getParameterTypes()[i];\n+        switch (paramType.getTypeName()) {", "originalCommit": "90f3854192715ca58cb8eafd88e34ef538644731", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4ODAxNg==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432788016", "bodyText": "Suggest directly comparing class instead of String comparison for both performance and readability:\nif (paramType == Integer.class) {\n  ...\n} else if (paramType == Long.class) {\n ...", "author": "Jackie-Jiang", "createdAt": "2020-05-30T00:06:32Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/ScalarTransformFunctionWrapper.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class ScalarTransformFunctionWrapper extends BaseTransformFunction {\n+\n+  FunctionInvoker _functionInvoker;\n+  String _name;\n+  Object[] _args;\n+  List<Integer> _nonLiteralArgIndices;\n+  List<FieldSpec.DataType> _nonLiteralArgType;\n+  List<TransformFunction> _nonLiteralTransformFunction;\n+  TransformResultMetadata _transformResultMetadata;\n+  String[] _stringResult;\n+  int[] _integerResult;\n+  float[] _floatResult;\n+  double[] _doubleResult;\n+  long[] _longResult;\n+\n+  public ScalarTransformFunctionWrapper() {\n+    _nonLiteralArgIndices = new ArrayList<>();\n+    _nonLiteralArgType = new ArrayList<>();\n+    _nonLiteralTransformFunction = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return _name;\n+  }\n+\n+  public void setFunction(String functionName, FunctionInfo info)\n+      throws Exception {\n+    _name = functionName;\n+    _functionInvoker = new FunctionInvoker(info);\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions.checkArgument(arguments.size() == _functionInvoker.getParameterTypes().length,\n+        \"The number of arguments are not same for scalar function and transform function: %s\", getName());\n+\n+    _args = new Object[arguments.size()];\n+    for (int i = 0; i < arguments.size(); i++) {\n+      TransformFunction function = arguments.get(i);\n+      if (function instanceof LiteralTransformFunction) {\n+        String literal = ((LiteralTransformFunction) function).getLiteral();\n+        Class paramType = _functionInvoker.getParameterTypes()[i];", "originalCommit": "90f3854192715ca58cb8eafd88e34ef538644731", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1MDg4Mg==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r433450882", "bodyText": "It would require changing switch case to a lot of else if since switch doesn't accept Class type. IMO, switch case looks neat so made this trade off", "author": "KKcorps", "createdAt": "2020-06-01T19:46:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4ODAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4ODE4Ng==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432788186", "bodyText": "(nit) Use a local variable int numArguments = arguments.size()", "author": "Jackie-Jiang", "createdAt": "2020-05-30T00:07:50Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/ScalarTransformFunctionWrapper.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class ScalarTransformFunctionWrapper extends BaseTransformFunction {\n+\n+  FunctionInvoker _functionInvoker;\n+  String _name;\n+  Object[] _args;\n+  List<Integer> _nonLiteralArgIndices;\n+  List<FieldSpec.DataType> _nonLiteralArgType;\n+  List<TransformFunction> _nonLiteralTransformFunction;\n+  TransformResultMetadata _transformResultMetadata;\n+  String[] _stringResult;\n+  int[] _integerResult;\n+  float[] _floatResult;\n+  double[] _doubleResult;\n+  long[] _longResult;\n+\n+  public ScalarTransformFunctionWrapper() {\n+    _nonLiteralArgIndices = new ArrayList<>();\n+    _nonLiteralArgType = new ArrayList<>();\n+    _nonLiteralTransformFunction = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return _name;\n+  }\n+\n+  public void setFunction(String functionName, FunctionInfo info)\n+      throws Exception {\n+    _name = functionName;\n+    _functionInvoker = new FunctionInvoker(info);\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions.checkArgument(arguments.size() == _functionInvoker.getParameterTypes().length,\n+        \"The number of arguments are not same for scalar function and transform function: %s\", getName());\n+\n+    _args = new Object[arguments.size()];", "originalCommit": "90f3854192715ca58cb8eafd88e34ef538644731", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4ODc4Mg==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432788782", "bodyText": "Why using different way to box the values?\nI would suggest changing all types to be the same as FLOAT. From the past experience, seems the streaming fashion has worse performance.", "author": "Jackie-Jiang", "createdAt": "2020-05-30T00:12:00Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/ScalarTransformFunctionWrapper.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class ScalarTransformFunctionWrapper extends BaseTransformFunction {\n+\n+  FunctionInvoker _functionInvoker;\n+  String _name;\n+  Object[] _args;\n+  List<Integer> _nonLiteralArgIndices;\n+  List<FieldSpec.DataType> _nonLiteralArgType;\n+  List<TransformFunction> _nonLiteralTransformFunction;\n+  TransformResultMetadata _transformResultMetadata;\n+  String[] _stringResult;\n+  int[] _integerResult;\n+  float[] _floatResult;\n+  double[] _doubleResult;\n+  long[] _longResult;\n+\n+  public ScalarTransformFunctionWrapper() {\n+    _nonLiteralArgIndices = new ArrayList<>();\n+    _nonLiteralArgType = new ArrayList<>();\n+    _nonLiteralTransformFunction = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return _name;\n+  }\n+\n+  public void setFunction(String functionName, FunctionInfo info)\n+      throws Exception {\n+    _name = functionName;\n+    _functionInvoker = new FunctionInvoker(info);\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions.checkArgument(arguments.size() == _functionInvoker.getParameterTypes().length,\n+        \"The number of arguments are not same for scalar function and transform function: %s\", getName());\n+\n+    _args = new Object[arguments.size()];\n+    for (int i = 0; i < arguments.size(); i++) {\n+      TransformFunction function = arguments.get(i);\n+      if (function instanceof LiteralTransformFunction) {\n+        String literal = ((LiteralTransformFunction) function).getLiteral();\n+        Class paramType = _functionInvoker.getParameterTypes()[i];\n+        switch (paramType.getTypeName()) {\n+          case \"java.lang.Integer\":\n+            _args[i] = Integer.parseInt(literal);\n+            break;\n+          case \"java.lang.String\":\n+            _args[i] = literal;\n+            break;\n+          case \"java.lang.Double\":\n+            _args[i] = Double.valueOf(literal);\n+            break;\n+          case \"java.lang.Float\":\n+            _args[i] = Float.valueOf(literal);\n+            break;\n+          case \"java.lang.Long\":\n+            _args[i] = Long.valueOf(literal);\n+            break;\n+          default:\n+            throw new RuntimeException(\n+                \"Unsupported data type \" + paramType.getTypeName() + \"for transform function \" + getName());\n+        }\n+      } else {\n+        _nonLiteralArgIndices.add(i);\n+        _nonLiteralTransformFunction.add(function);\n+        Class paramType = _functionInvoker.getParameterTypes()[i];\n+\n+        switch (paramType.getTypeName()) {\n+          case \"java.lang.Integer\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.INT);\n+            break;\n+          case \"java.lang.String\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.STRING);\n+            break;\n+          case \"java.lang.Double\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.DOUBLE);\n+            break;\n+          case \"java.lang.Float\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.FLOAT);\n+            break;\n+          case \"java.lang.Long\":\n+            _nonLiteralArgType.add(FieldSpec.DataType.LONG);\n+            break;\n+          default:\n+            throw new RuntimeException(\n+                \"Unsupported data type \" + paramType.getTypeName() + \"for transform function \" + getName());\n+        }\n+      }\n+    }\n+\n+    Class returnType = _functionInvoker.getReturnType();\n+    switch(returnType.getTypeName()) {\n+      case \"java.lang.Integer\":\n+        _transformResultMetadata =  INT_SV_NO_DICTIONARY_METADATA;\n+        break;\n+      case \"java.lang.Long\":\n+        _transformResultMetadata =  LONG_SV_NO_DICTIONARY_METADATA;\n+        break;\n+      case \"java.lang.Float\":\n+      case \"java.lang.Double\":\n+        _transformResultMetadata =  DOUBLE_SV_NO_DICTIONARY_METADATA;\n+        break;\n+      case \"java.lang.Boolean\":\n+      case \"java.lang.String\":\n+        _transformResultMetadata =  STRING_SV_NO_DICTIONARY_METADATA;\n+        break;\n+      default:\n+        throw new RuntimeException(\"Unsupported data type \" + returnType.getTypeName() + \"for transform function \" + getName());\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return _transformResultMetadata;\n+  }\n+\n+  @SuppressWarnings(\"Duplicates\")\n+  @Override\n+  public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {\n+    if (_integerResult == null) {\n+      _integerResult = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    int length = projectionBlock.getNumDocs();\n+    int numNonLiteralArgs = _nonLiteralArgIndices.size();\n+    Object[][] nonLiteralBlockValues = new Object[numNonLiteralArgs][];\n+\n+    transformNonLiteralArgsToValues(projectionBlock, numNonLiteralArgs, nonLiteralBlockValues);\n+\n+    //now invoke the actual function\n+    for (int i = 0; i < length; i++) {\n+      for (int k = 0; k < numNonLiteralArgs; k++) {\n+        _args[_nonLiteralArgIndices.get(k)] = nonLiteralBlockValues[k][i];\n+      }\n+      _integerResult[i] = (Integer) _functionInvoker.process(_args);\n+    }\n+    return _integerResult;\n+  }\n+\n+  @SuppressWarnings(\"Duplicates\")\n+  @Override\n+  public long[] transformToLongValuesSV(ProjectionBlock projectionBlock) {\n+    if (_longResult == null) {\n+      _longResult = new long[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    int length = projectionBlock.getNumDocs();\n+    int numNonLiteralArgs = _nonLiteralArgIndices.size();\n+    Object[][] nonLiteralBlockValues = new Object[numNonLiteralArgs][];\n+\n+    transformNonLiteralArgsToValues(projectionBlock, numNonLiteralArgs, nonLiteralBlockValues);\n+\n+    //now invoke the actual function\n+    for (int i = 0; i < length; i++) {\n+      for (int k = 0; k < numNonLiteralArgs; k++) {\n+        _args[_nonLiteralArgIndices.get(k)] = nonLiteralBlockValues[k][i];\n+      }\n+      _longResult[i] = (Long) _functionInvoker.process(_args);\n+    }\n+    return _longResult;\n+  }\n+\n+  @SuppressWarnings(\"Duplicates\")\n+  @Override\n+  public float[] transformToFloatValuesSV(ProjectionBlock projectionBlock) {\n+    if (_floatResult == null) {\n+      _floatResult = new float[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    int length = projectionBlock.getNumDocs();\n+    int numNonLiteralArgs = _nonLiteralArgIndices.size();\n+    Object[][] nonLiteralBlockValues = new Object[numNonLiteralArgs][];\n+\n+    transformNonLiteralArgsToValues(projectionBlock, numNonLiteralArgs, nonLiteralBlockValues);\n+\n+    //now invoke the actual function\n+    for (int i = 0; i < length; i++) {\n+      for (int k = 0; k < numNonLiteralArgs; k++) {\n+        _args[_nonLiteralArgIndices.get(k)] = nonLiteralBlockValues[k][i];\n+      }\n+      _floatResult[i] = (Float) _functionInvoker.process(_args);\n+    }\n+    return _floatResult;\n+  }\n+\n+  @SuppressWarnings(\"Duplicates\")\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_doubleResult == null) {\n+      _doubleResult = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    int length = projectionBlock.getNumDocs();\n+    int numNonLiteralArgs = _nonLiteralArgIndices.size();\n+    Object[][] nonLiteralBlockValues = new Object[numNonLiteralArgs][];\n+\n+    transformNonLiteralArgsToValues(projectionBlock, numNonLiteralArgs, nonLiteralBlockValues);\n+\n+    //now invoke the actual function\n+    for (int i = 0; i < length; i++) {\n+      for (int k = 0; k < numNonLiteralArgs; k++) {\n+        _args[_nonLiteralArgIndices.get(k)] = nonLiteralBlockValues[k][i];\n+      }\n+      _doubleResult[i] = (Double) _functionInvoker.process(_args);\n+    }\n+    return _doubleResult;\n+  }\n+\n+  @SuppressWarnings(\"Duplicates\")\n+  @Override\n+  public String[] transformToStringValuesSV(ProjectionBlock projectionBlock) {\n+    if (_stringResult == null) {\n+      _stringResult = new String[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    int length = projectionBlock.getNumDocs();\n+    int numNonLiteralArgs = _nonLiteralArgIndices.size();\n+    Object[][] nonLiteralBlockValues = new Object[numNonLiteralArgs][];\n+\n+    transformNonLiteralArgsToValues(projectionBlock, numNonLiteralArgs, nonLiteralBlockValues);\n+\n+    //now invoke the actual function\n+    for (int i = 0; i < length; i++) {\n+      for (int k = 0; k < numNonLiteralArgs; k++) {\n+        _args[_nonLiteralArgIndices.get(k)] = nonLiteralBlockValues[k][i];\n+      }\n+      _stringResult[i] = (String) _functionInvoker.process(_args);\n+    }\n+\n+    return _stringResult;\n+  }\n+\n+  private void transformNonLiteralArgsToValues(ProjectionBlock projectionBlock, int numNonLiteralArgs,\n+      Object[][] nonLiteralBlockValues) {\n+    for (int i = 0; i < numNonLiteralArgs; i++) {\n+      TransformFunction transformFunc = _nonLiteralTransformFunction.get(i);\n+      FieldSpec.DataType returnType = _nonLiteralArgType.get(i);\n+      switch (returnType) {\n+        case STRING:\n+          nonLiteralBlockValues[i] = transformFunc.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          int[] values = transformFunc.transformToIntValuesSV(projectionBlock);\n+          nonLiteralBlockValues[i] = Arrays.stream(values).boxed().toArray(Integer[]::new);\n+          break;\n+        case DOUBLE:\n+          double[] doubleValues = transformFunc.transformToDoubleValuesSV(projectionBlock);\n+          nonLiteralBlockValues[i] = Arrays.stream(doubleValues).boxed().toArray(Double[]::new);\n+          break;\n+        case FLOAT:\n+          float[] floatValues = transformFunc.transformToFloatValuesSV(projectionBlock);", "originalCommit": "90f3854192715ca58cb8eafd88e34ef538644731", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYxNjIzMg==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r433616232", "bodyText": "Another way is using org.apache.commons.lang3.ArrayUtils.toObject() which is clean and neat", "author": "Jackie-Jiang", "createdAt": "2020-06-02T04:40:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4ODc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4OTEyNA==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432789124", "bodyText": "Don't catch all Exceptions because it will also catch the BadQueryRequestException. We treat BadQueryRequestException differently on the caller side", "author": "Jackie-Jiang", "createdAt": "2020-05-30T00:14:22Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/TransformFunctionFactory.java", "diffHunk": "@@ -112,13 +115,24 @@ public static TransformFunction get(TransformExpressionTree expression, Map<Stri\n     switch (expression.getExpressionType()) {\n       case FUNCTION:\n         String functionName = expression.getValue();\n-        Class<? extends TransformFunction> transformFunctionClass = TRANSFORM_FUNCTION_MAP.get(functionName);\n+        Class<? extends TransformFunction> transformFunctionClass;\n+        FunctionInfo functionInfo = null;\n+        if (FunctionRegistry.containsFunctionByName(functionName)) {\n+          transformFunctionClass = ScalarTransformFunctionWrapper.class;\n+          functionInfo = FunctionRegistry.getFunctionByName(functionName);\n+        } else {\n+          transformFunctionClass = TRANSFORM_FUNCTION_MAP.get(functionName);\n+        }\n+\n         if (transformFunctionClass == null) {\n           throw new BadQueryRequestException(\"Unsupported transform function: \" + functionName);\n         }\n         try {\n           transformFunction = transformFunctionClass.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n+          if (functionInfo != null) {\n+            ((ScalarTransformFunctionWrapper) transformFunction).setFunction(functionName, functionInfo);\n+          }\n+        } catch (Exception e) {", "originalCommit": "90f3854192715ca58cb8eafd88e34ef538644731", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2Njk2NA==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r433466964", "bodyText": "Why will a constructor throw BadQueryRequestException since this catch block is meant for only the constructor?", "author": "KKcorps", "createdAt": "2020-06-01T20:19:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4OTEyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYxNTgzNQ==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r433615835", "bodyText": "Never mind, I thought this try-catch is around line 128", "author": "Jackie-Jiang", "createdAt": "2020-06-02T04:39:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4OTEyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4OTM2Mw==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432789363", "bodyText": "Suggest using a constructor with functionName and functionInfo instead of using newInstance()", "author": "Jackie-Jiang", "createdAt": "2020-05-30T00:15:55Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/TransformFunctionFactory.java", "diffHunk": "@@ -112,13 +115,24 @@ public static TransformFunction get(TransformExpressionTree expression, Map<Stri\n     switch (expression.getExpressionType()) {\n       case FUNCTION:\n         String functionName = expression.getValue();\n-        Class<? extends TransformFunction> transformFunctionClass = TRANSFORM_FUNCTION_MAP.get(functionName);\n+        Class<? extends TransformFunction> transformFunctionClass;\n+        FunctionInfo functionInfo = null;\n+        if (FunctionRegistry.containsFunctionByName(functionName)) {\n+          transformFunctionClass = ScalarTransformFunctionWrapper.class;\n+          functionInfo = FunctionRegistry.getFunctionByName(functionName);\n+        } else {\n+          transformFunctionClass = TRANSFORM_FUNCTION_MAP.get(functionName);\n+        }\n+\n         if (transformFunctionClass == null) {\n           throw new BadQueryRequestException(\"Unsupported transform function: \" + functionName);\n         }\n         try {\n           transformFunction = transformFunctionClass.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n+          if (functionInfo != null) {\n+            ((ScalarTransformFunctionWrapper) transformFunction).setFunction(functionName, functionInfo);", "originalCommit": "90f3854192715ca58cb8eafd88e34ef538644731", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4OTQzOQ==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432789439", "bodyText": "Add private or private final for these member variables", "author": "Jackie-Jiang", "createdAt": "2020-05-30T00:16:32Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/ScalarTransformFunctionWrapper.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class ScalarTransformFunctionWrapper extends BaseTransformFunction {\n+\n+  FunctionInvoker _functionInvoker;", "originalCommit": "90f3854192715ca58cb8eafd88e34ef538644731", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4OTUxNg==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432789516", "bodyText": "Suggest merging this into the constructor", "author": "Jackie-Jiang", "createdAt": "2020-05-30T00:17:10Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/ScalarTransformFunctionWrapper.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class ScalarTransformFunctionWrapper extends BaseTransformFunction {\n+\n+  FunctionInvoker _functionInvoker;\n+  String _name;\n+  Object[] _args;\n+  List<Integer> _nonLiteralArgIndices;\n+  List<FieldSpec.DataType> _nonLiteralArgType;\n+  List<TransformFunction> _nonLiteralTransformFunction;\n+  TransformResultMetadata _transformResultMetadata;\n+  String[] _stringResult;\n+  int[] _integerResult;\n+  float[] _floatResult;\n+  double[] _doubleResult;\n+  long[] _longResult;\n+\n+  public ScalarTransformFunctionWrapper() {\n+    _nonLiteralArgIndices = new ArrayList<>();\n+    _nonLiteralArgType = new ArrayList<>();\n+    _nonLiteralTransformFunction = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return _name;\n+  }\n+\n+  public void setFunction(String functionName, FunctionInfo info)", "originalCommit": "90f3854192715ca58cb8eafd88e34ef538644731", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4OTU3NQ==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r432789575", "bodyText": "Rename it to ScalarTransformFunction?", "author": "Jackie-Jiang", "createdAt": "2020-05-30T00:17:38Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/ScalarTransformFunctionWrapper.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.FunctionInfo;\n+import org.apache.pinot.common.function.FunctionInvoker;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+public class ScalarTransformFunctionWrapper extends BaseTransformFunction {", "originalCommit": "90f3854192715ca58cb8eafd88e34ef538644731", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2MjY0NA==", "url": "https://github.com/apache/pinot/pull/5440#discussion_r433462644", "bodyText": "IMO, this is a wrapper/adapater around ScalarTransformFunctions hence the name", "author": "KKcorps", "createdAt": "2020-06-01T20:10:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4OTU3NQ=="}], "type": "inlineReview"}, {"oid": "0404e96fc85664d1e5ccb11235a1a9de1d8919e3", "url": "https://github.com/apache/pinot/commit/0404e96fc85664d1e5ccb11235a1a9de1d8919e3", "message": "moving pom version to root and refactoring", "committedDate": "2020-06-01T19:43:52Z", "type": "commit"}, {"oid": "9a21b5429e935a52b018235515326cbde6966c33", "url": "https://github.com/apache/pinot/commit/9a21b5429e935a52b018235515326cbde6966c33", "message": "fixing tests", "committedDate": "2020-06-01T20:08:58Z", "type": "commit"}, {"oid": "d1161253d3e14a4bd0090344f6216975e54d20c8", "url": "https://github.com/apache/pinot/commit/d1161253d3e14a4bd0090344f6216975e54d20c8", "message": "refactoring: adding constructor to wrapper class", "committedDate": "2020-06-01T20:43:36Z", "type": "commit"}, {"oid": "4edaed45b539286d597eba86ca21e808c8e28a86", "url": "https://github.com/apache/pinot/commit/4edaed45b539286d597eba86ca21e808c8e28a86", "message": "moving dependency out of module", "committedDate": "2020-06-02T08:43:37Z", "type": "commit"}]}