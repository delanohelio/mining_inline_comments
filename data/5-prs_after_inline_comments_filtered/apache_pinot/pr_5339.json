{"pr_number": 5339, "pr_title": "Add api in AggregationFunction to get its compiled input expressions.", "pr_createdAt": "2020-05-06T05:27:33Z", "pr_url": "https://github.com/apache/pinot/pull/5339", "timeline": [{"oid": "37dc52cc5a8f38d795991ec9998ca397b1d02c4e", "url": "https://github.com/apache/pinot/commit/37dc52cc5a8f38d795991ec9998ca397b1d02c4e", "message": "Add api in AggregationFunction to return the its compiled input expressions.\n\nWith aggregation functions now taking multiple agruments, only the functions themselves\nhave the knowledge on how to interpret these arguments. This poses a problem for the planning\nphase on what columns need to be projected and what expressions need to be computed.\nWith this change, AggregationFunction's are now responsible for providing what inputs they need.\n\n1. Added a new api in AggregationFunction interface `getInputExpressions()`, that returns a list\n   of compiled TransformExpressionTrees that the aggregation function needs as input to compute.\n\n2. Cleaned up the chaining data dependency during planning phase. Before this PR, all planning nodes\n   receive the BrokerRequest (and pass to their child plan node) to extract out all information needed.\n   With this change:\n   - Aggregation plan nodes only specify the expression trees they need from Transform plan nodes, and\n     Transform plan nodes use that to specify what columns they need from projection plan nodes.\n\nTODO: Ideally we should completely eliminate passing of BrokerRequest throughout the chain plan nodes,\nand only pass minimal information instead. This change only does so for projection columns. A TODO here\nis to extend it to FilterPlanNode and deeper.", "committedDate": "2020-05-06T13:57:10Z", "type": "forcePushed"}, {"oid": "f02f5f382155389e847943e93aca915b0829bcd2", "url": "https://github.com/apache/pinot/commit/f02f5f382155389e847943e93aca915b0829bcd2", "message": "Add api in AggregationFunction to get compiled input expressions.\n\nWith aggregation functions now taking multiple agruments, only the functions themselves\nhave the knowledge on how to interpret these arguments. This poses a problem for the planning\nphase on what columns need to be projected and what expressions need to be computed.\nWith this change, AggregationFunction's are now responsible for providing what inputs they need.\n\n1. Added a new api in AggregationFunction interface `getInputExpressions()`, that returns a list\n   of compiled TransformExpressionTrees that the aggregation function needs as input to compute.\n\n2. Cleaned up the chaining data dependency during planning phase. Before this PR, all planning nodes\n   receive the BrokerRequest (and pass to their child plan node) to extract out all information needed.\n   With this change:\n   - Aggregation plan nodes only specify the expression trees they need from Transform plan nodes, and\n     Transform plan nodes use that to specify what columns they need from projection plan nodes.\n\nTODO: Ideally we should completely eliminate passing of BrokerRequest throughout the chain plan nodes,\nand only pass minimal information instead. This change only does so for projection columns. A TODO here\nis to extend it to FilterPlanNode and deeper.", "committedDate": "2020-05-06T13:59:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNjM3NQ==", "url": "https://github.com/apache/pinot/pull/5339#discussion_r421006375", "bodyText": "This logic should also be handle in the upper level (SelectionPlanNode) and passed to this class", "author": "Jackie-Jiang", "createdAt": "2020-05-06T18:34:03Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/plan/TransformPlanNode.java", "diffHunk": "@@ -43,76 +39,70 @@\n \n   private final String _segmentName;\n   private final ProjectionPlanNode _projectionPlanNode;\n-  private final Set<String> _projectionColumns = new HashSet<>();\n-  private final Set<TransformExpressionTree> _expressions = new HashSet<>();\n+  private final Set<TransformExpressionTree> _expressions;\n   private int _maxDocPerNextCall = DocIdSetPlanNode.MAX_DOC_PER_CALL;\n \n-  public TransformPlanNode(IndexSegment indexSegment, BrokerRequest brokerRequest) {\n+  public TransformPlanNode(IndexSegment indexSegment, BrokerRequest brokerRequest,\n+      Set<TransformExpressionTree> expressionsToPlan) {\n     _segmentName = indexSegment.getSegmentName();\n-    extractColumnsAndTransforms(brokerRequest, indexSegment);\n-    _projectionPlanNode = new ProjectionPlanNode(indexSegment, _projectionColumns,\n+\n+    setMaxDocsForSelection(brokerRequest);\n+    Set<String> projectionColumns = new HashSet<>();\n+    extractProjectionColumns(expressionsToPlan, projectionColumns);\n+\n+    _expressions = expressionsToPlan;\n+    _projectionPlanNode = new ProjectionPlanNode(indexSegment, projectionColumns,\n         new DocIdSetPlanNode(indexSegment, brokerRequest, _maxDocPerNextCall));\n   }\n \n+  private void extractProjectionColumns(Set<TransformExpressionTree> expressionsToPlan, Set<String> projectionColumns) {\n+    for (TransformExpressionTree expression : expressionsToPlan) {\n+      extractProjectionColumns(expression, projectionColumns);\n+    }\n+  }\n+\n+  private void extractProjectionColumns(TransformExpressionTree expression, Set<String> projectionColumns) {\n+    TransformExpressionTree.ExpressionType expressionType = expression.getExpressionType();\n+    switch (expressionType) {\n+      case FUNCTION:\n+        for (TransformExpressionTree child : expression.getChildren()) {\n+          extractProjectionColumns(child, projectionColumns);\n+        }\n+        break;\n+\n+      case IDENTIFIER:\n+        projectionColumns.add(expression.getValue());\n+        break;\n+\n+      case LITERAL:\n+        // Do nothing.\n+        break;\n+\n+      default:\n+        throw new UnsupportedOperationException(\"Unsupported expression type: \" + expressionType);\n+    }\n+  }\n+\n   /**\n-   * Helper method to extract projection columns and transform expressions from the given broker request.\n+   * Helper method to set the max number of docs to return for selection queries\n    */\n-  private void extractColumnsAndTransforms(BrokerRequest brokerRequest, IndexSegment indexSegment) {\n-    Set<String> columns = new HashSet<>();\n-    if (brokerRequest.isSetAggregationsInfo()) {\n-      // Extract aggregation expressions\n-      for (AggregationInfo aggregationInfo : brokerRequest.getAggregationsInfo()) {\n-        if (aggregationInfo.getAggregationType().equalsIgnoreCase(AggregationFunctionType.DISTINCT.getName())) {\n-          // 'DISTINCT(col1, col2 ...)' is modeled as one single aggregation function\n-          List<String> distinctColumns = AggregationFunctionUtils.getAggregationExpressions(aggregationInfo);\n-          columns.addAll(distinctColumns);\n-        } else if (!aggregationInfo.getAggregationType().equalsIgnoreCase(AggregationFunctionType.COUNT.getName())) {\n-          columns.addAll(AggregationFunctionUtils.getAggregationExpressions(aggregationInfo));\n-        }\n-      }\n-      // Extract group-by expressions\n-      if (brokerRequest.isSetGroupBy()) {\n-        columns.addAll(brokerRequest.getGroupBy().getExpressions());\n-      }\n-    } else {\n+  private void setMaxDocsForSelection(BrokerRequest brokerRequest) {", "originalCommit": "f02f5f382155389e847943e93aca915b0829bcd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1ODA2OQ==", "url": "https://github.com/apache/pinot/pull/5339#discussion_r421058069", "bodyText": "Yeah I thought so too. But upper levels can be aggregation as well, which will now have this field leaked. For now I tend to keep it here (as was the case before) until the full cleanup happens.", "author": "mayankshriv", "createdAt": "2020-05-06T20:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNjM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNzYyMw==", "url": "https://github.com/apache/pinot/pull/5339#discussion_r421007623", "bodyText": "(nit) expressionsToPlan -> expressions?\nAlso pass maxDocsPerBlock from upper level?", "author": "Jackie-Jiang", "createdAt": "2020-05-06T18:36:13Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/plan/TransformPlanNode.java", "diffHunk": "@@ -43,76 +39,70 @@\n \n   private final String _segmentName;\n   private final ProjectionPlanNode _projectionPlanNode;\n-  private final Set<String> _projectionColumns = new HashSet<>();\n-  private final Set<TransformExpressionTree> _expressions = new HashSet<>();\n+  private final Set<TransformExpressionTree> _expressions;\n   private int _maxDocPerNextCall = DocIdSetPlanNode.MAX_DOC_PER_CALL;\n \n-  public TransformPlanNode(IndexSegment indexSegment, BrokerRequest brokerRequest) {\n+  public TransformPlanNode(IndexSegment indexSegment, BrokerRequest brokerRequest,\n+      Set<TransformExpressionTree> expressionsToPlan) {", "originalCommit": "f02f5f382155389e847943e93aca915b0829bcd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1OTQ3OQ==", "url": "https://github.com/apache/pinot/pull/5339#discussion_r421059479", "bodyText": "expressions was too generic and being used in too many places for different purposes, so I thought to call it expressionsToPlan.\nReplied on maxDocsPerBlock above.", "author": "mayankshriv", "createdAt": "2020-05-06T20:05:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNzYyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwODcxNg==", "url": "https://github.com/apache/pinot/pull/5339#discussion_r421008716", "bodyText": "(nit) We don't have return argument documented in this file, maybe keep it consistent?", "author": "Jackie-Jiang", "createdAt": "2020-05-06T18:37:55Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunction.java", "diffHunk": "@@ -49,6 +51,13 @@\n    */\n   String getResultColumnName();\n \n+  /**\n+   * Returns a list of input expressions needed for performing aggregation.\n+   *\n+   * @return List of input expressions", "originalCommit": "f02f5f382155389e847943e93aca915b0829bcd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2MDIyMg==", "url": "https://github.com/apache/pinot/pull/5339#discussion_r421060222", "bodyText": "Ok, will remove. It does not enough value to go out of the norm I guess.", "author": "mayankshriv", "createdAt": "2020-05-06T20:07:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwODcxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwOTM5OQ==", "url": "https://github.com/apache/pinot/pull/5339#discussion_r421009399", "bodyText": "No need to specialize this. Just make CountAggregationFunction return empty list", "author": "Jackie-Jiang", "createdAt": "2020-05-06T18:39:05Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java", "diffHunk": "@@ -182,4 +187,37 @@ public static String concatArgs(List<String> arguments) {\n     return (arguments.size() > 1) ? String.join(CompilerConstants.AGGREGATION_FUNCTION_ARG_SEPARATOR, arguments)\n         : arguments.get(0);\n   }\n+\n+  /**\n+   * Compiles and returns all transform expressions required for computing the aggregation, group-by\n+   * and order-by\n+   *\n+   * @param brokerRequest Broker Request\n+   * @param functionContexts Aggregation Function contexts\n+   * @return Set of compiled expressions in the aggregation, group-by and order-by clauses\n+   */\n+  public static Set<TransformExpressionTree> collectExpressionsToTransform(BrokerRequest brokerRequest,\n+      AggregationFunctionContext[] functionContexts) {\n+\n+    Set<TransformExpressionTree> expressionTrees = new LinkedHashSet<>();\n+    for (AggregationFunctionContext functionContext : functionContexts) {\n+      AggregationFunction function = functionContext.getAggregationFunction();\n+\n+      // Count is always treated as count(*) and does not need any columns to be projected.\n+      if (!function.getType().equals(AggregationFunctionType.COUNT)) {", "originalCommit": "f02f5f382155389e847943e93aca915b0829bcd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2MDczNA==", "url": "https://github.com/apache/pinot/pull/5339#discussion_r421060734", "bodyText": "\ud83d\udc4d", "author": "mayankshriv", "createdAt": "2020-05-06T20:08:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwOTM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwOTgyMQ==", "url": "https://github.com/apache/pinot/pull/5339#discussion_r421009821", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return null;\n          \n          \n            \n                return Collections.emptyList();", "author": "Jackie-Jiang", "createdAt": "2020-05-06T18:39:50Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/CountAggregationFunction.java", "diffHunk": "@@ -57,6 +59,11 @@ public String getResultColumnName() {\n     return AggregationFunctionType.COUNT.getName().toLowerCase() + \"(*)\";\n   }\n \n+  @Override\n+  public List<TransformExpressionTree> getInputExpressions() {\n+    return null;", "originalCommit": "f02f5f382155389e847943e93aca915b0829bcd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2MjAzNw==", "url": "https://github.com/apache/pinot/pull/5339#discussion_r421062037", "bodyText": "\ud83d\udc4d", "author": "mayankshriv", "createdAt": "2020-05-06T20:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwOTgyMQ=="}], "type": "inlineReview"}, {"oid": "f1cd04a6a4170273d98c8971d5e6ff6b01f72c4c", "url": "https://github.com/apache/pinot/commit/f1cd04a6a4170273d98c8971d5e6ff6b01f72c4c", "message": "Add api in AggregationFunction to get compiled input expressions.\n\nWith aggregation functions now taking multiple agruments, only the functions themselves\nhave the knowledge on how to interpret these arguments. This poses a problem for the planning\nphase on what columns need to be projected and what expressions need to be computed.\nWith this change, AggregationFunction's are now responsible for providing what inputs they need.\n\n1. Added a new api in AggregationFunction interface `getInputExpressions()`, that returns a list\n   of compiled TransformExpressionTrees that the aggregation function needs as input to compute.\n\n2. Cleaned up the chaining data dependency during planning phase. Before this PR, all planning nodes\n   receive the BrokerRequest (and pass to their child plan node) to extract out all information needed.\n   With this change:\n   - Aggregation plan nodes only specify the expression trees they need from Transform plan nodes, and\n     Transform plan nodes use that to specify what columns they need from projection plan nodes.\n\nTODO: Ideally we should completely eliminate passing of BrokerRequest throughout the chain plan nodes,\nand only pass minimal information instead. This change only does so for projection columns. A TODO here\nis to extend it to FilterPlanNode and deeper.", "committedDate": "2020-05-06T20:11:49Z", "type": "commit"}, {"oid": "f1cd04a6a4170273d98c8971d5e6ff6b01f72c4c", "url": "https://github.com/apache/pinot/commit/f1cd04a6a4170273d98c8971d5e6ff6b01f72c4c", "message": "Add api in AggregationFunction to get compiled input expressions.\n\nWith aggregation functions now taking multiple agruments, only the functions themselves\nhave the knowledge on how to interpret these arguments. This poses a problem for the planning\nphase on what columns need to be projected and what expressions need to be computed.\nWith this change, AggregationFunction's are now responsible for providing what inputs they need.\n\n1. Added a new api in AggregationFunction interface `getInputExpressions()`, that returns a list\n   of compiled TransformExpressionTrees that the aggregation function needs as input to compute.\n\n2. Cleaned up the chaining data dependency during planning phase. Before this PR, all planning nodes\n   receive the BrokerRequest (and pass to their child plan node) to extract out all information needed.\n   With this change:\n   - Aggregation plan nodes only specify the expression trees they need from Transform plan nodes, and\n     Transform plan nodes use that to specify what columns they need from projection plan nodes.\n\nTODO: Ideally we should completely eliminate passing of BrokerRequest throughout the chain plan nodes,\nand only pass minimal information instead. This change only does so for projection columns. A TODO here\nis to extend it to FilterPlanNode and deeper.", "committedDate": "2020-05-06T20:11:49Z", "type": "forcePushed"}]}