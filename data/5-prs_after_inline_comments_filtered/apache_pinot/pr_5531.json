{"pr_number": 5531, "pr_title": "Fix the failure caused by Reflections in FunctionRegistry", "pr_createdAt": "2020-06-09T20:16:37Z", "pr_url": "https://github.com/apache/pinot/pull/5531", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcwMzU0Mw==", "url": "https://github.com/apache/pinot/pull/5531#discussion_r437703543", "bodyText": "Curious if there's any way to enforce this, so we ensure that future changes adhere to this?", "author": "mayankshriv", "createdAt": "2020-06-09T20:38:29Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/function/FunctionRegistry.java", "diffHunk": "@@ -39,62 +38,63 @@\n  */\n public class FunctionRegistry {\n   private static final Logger LOGGER = LoggerFactory.getLogger(FunctionRegistry.class);\n-  private static final Map<String, FunctionInfo> _functionInfoMap = new HashMap<>();\n+  private static final Map<String, FunctionInfo> FUNCTION_INFO_MAP = new HashMap<>();\n+\n+  private static boolean _initialized = false;\n \n   /**\n-   * Given a function name, asserts that a corresponding function was registered during construction and returns it\n+   * Initializes the FunctionRegistry by registering the scalar functions via reflection.\n+   * NOTE: In order to plugin methods using reflection, the methods should be inside a class that includes \".function.\"", "originalCommit": "4cb398a9c2113369c3cbe3c4139d5f968bdb3f9c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0NTAxMg==", "url": "https://github.com/apache/pinot/pull/5531#discussion_r437745012", "bodyText": "There is no easy way to enforce this for user-side classes because we can only load the classes at runtime. Added the log for all the registered functions so that at least we can catch the problem if the class is not with the correct class path.", "author": "Jackie-Jiang", "createdAt": "2020-06-09T21:56:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcwMzU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyOTUzNw==", "url": "https://github.com/apache/pinot/pull/5531#discussion_r437729537", "bodyText": "why are we measuring the time to init functions? do we expect it to take a long time?\nAlso, if we logging it may be useful to log the map size here, and also each function as they are registered", "author": "mcvsubbu", "createdAt": "2020-06-09T21:20:46Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/function/FunctionRegistry.java", "diffHunk": "@@ -39,62 +38,63 @@\n  */\n public class FunctionRegistry {\n   private static final Logger LOGGER = LoggerFactory.getLogger(FunctionRegistry.class);\n-  private static final Map<String, FunctionInfo> _functionInfoMap = new HashMap<>();\n+  private static final Map<String, FunctionInfo> FUNCTION_INFO_MAP = new HashMap<>();\n+\n+  private static boolean _initialized = false;\n \n   /**\n-   * Given a function name, asserts that a corresponding function was registered during construction and returns it\n+   * Initializes the FunctionRegistry by registering the scalar functions via reflection.\n+   * NOTE: In order to plugin methods using reflection, the methods should be inside a class that includes \".function.\"\n+   *       in its class path. This convention can significantly reduce the time of class scanning.\n    */\n-  public static FunctionInfo getFunctionByName(String functionName) {\n-    Preconditions.checkArgument(_functionInfoMap.containsKey(functionName.toLowerCase()));\n-    return _functionInfoMap.get(functionName.toLowerCase());\n+  public static synchronized void init() {\n+    if (_initialized) {\n+      LOGGER.info(\"FunctionRegistry is already initialized\");\n+      return;\n+    }\n+\n+    long startTimeMs = System.currentTimeMillis();\n+    Reflections reflections = new Reflections(\n+        new ConfigurationBuilder().setUrls(ClasspathHelper.forPackage(\"org.apache.pinot\"))\n+            .filterInputsBy(new FilterBuilder.Include(\".*\\\\.function\\\\..*\"))\n+            .setScanners(new MethodAnnotationsScanner()));\n+    Set<Method> methodSet = reflections.getMethodsAnnotatedWith(ScalarFunction.class);\n+    for (Method method : methodSet) {\n+      ScalarFunction scalarFunction = method.getAnnotation(ScalarFunction.class);\n+      if (scalarFunction.enabled()) {\n+        if (!scalarFunction.name().isEmpty()) {\n+          FunctionRegistry.registerFunction(scalarFunction.name(), method);\n+        } else {\n+          FunctionRegistry.registerFunction(method);\n+        }\n+      }\n+    }\n+    LOGGER.info(\"Initialized FunctionRegistry within {}ms\", System.currentTimeMillis() - startTimeMs);", "originalCommit": "4cb398a9c2113369c3cbe3c4139d5f968bdb3f9c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0MzQ4NA==", "url": "https://github.com/apache/pinot/pull/5531#discussion_r437743484", "bodyText": "It was taking several seconds before adding filter on the class path. That is another reason why we should explicitly initialize it instead of waiting for class loader to run the static block. Before the change, the reflection happens when the first query arrives, which means the first query have to wait for several seconds. Right now it should take ~200ms, and it happens in the instance setup.\nAdded the map size and functions registered.", "author": "Jackie-Jiang", "createdAt": "2020-06-09T21:52:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyOTUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0MDQxMg==", "url": "https://github.com/apache/pinot/pull/5531#discussion_r437740412", "bodyText": "Could you make a function like canonicalize(functionName) and use it here and also in registerFunction method where FUNCTION_INFO_MAP gets populated so in future we won't miss converting to lowercase?", "author": "sajjad-moradi", "createdAt": "2020-06-09T21:45:28Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/function/FunctionRegistry.java", "diffHunk": "@@ -39,62 +38,63 @@\n  */\n public class FunctionRegistry {\n   private static final Logger LOGGER = LoggerFactory.getLogger(FunctionRegistry.class);\n-  private static final Map<String, FunctionInfo> _functionInfoMap = new HashMap<>();\n+  private static final Map<String, FunctionInfo> FUNCTION_INFO_MAP = new HashMap<>();\n+\n+  private static boolean _initialized = false;\n \n   /**\n-   * Given a function name, asserts that a corresponding function was registered during construction and returns it\n+   * Initializes the FunctionRegistry by registering the scalar functions via reflection.\n+   * NOTE: In order to plugin methods using reflection, the methods should be inside a class that includes \".function.\"\n+   *       in its class path. This convention can significantly reduce the time of class scanning.\n    */\n-  public static FunctionInfo getFunctionByName(String functionName) {\n-    Preconditions.checkArgument(_functionInfoMap.containsKey(functionName.toLowerCase()));\n-    return _functionInfoMap.get(functionName.toLowerCase());\n+  public static synchronized void init() {\n+    if (_initialized) {\n+      LOGGER.info(\"FunctionRegistry is already initialized\");\n+      return;\n+    }\n+\n+    long startTimeMs = System.currentTimeMillis();\n+    Reflections reflections = new Reflections(\n+        new ConfigurationBuilder().setUrls(ClasspathHelper.forPackage(\"org.apache.pinot\"))\n+            .filterInputsBy(new FilterBuilder.Include(\".*\\\\.function\\\\..*\"))\n+            .setScanners(new MethodAnnotationsScanner()));\n+    Set<Method> methodSet = reflections.getMethodsAnnotatedWith(ScalarFunction.class);\n+    for (Method method : methodSet) {\n+      ScalarFunction scalarFunction = method.getAnnotation(ScalarFunction.class);\n+      if (scalarFunction.enabled()) {\n+        if (!scalarFunction.name().isEmpty()) {\n+          FunctionRegistry.registerFunction(scalarFunction.name(), method);\n+        } else {\n+          FunctionRegistry.registerFunction(method);\n+        }\n+      }\n+    }\n+    LOGGER.info(\"Initialized FunctionRegistry within {}ms\", System.currentTimeMillis() - startTimeMs);\n+    _initialized = true;\n   }\n \n   /**\n-   * Given a function name and a set of argument types, asserts that a corresponding function\n-   * was registered during construction and returns it\n+   * Registers a method with the name of the method.\n    */\n-  public static FunctionInfo getFunctionByNameWithApplicableArgumentTypes(String functionName,\n-      Class<?>[] argumentTypes) {\n-    FunctionInfo functionInfo = getFunctionByName(functionName);\n-    Preconditions.checkArgument(functionInfo.isApplicable(argumentTypes));\n-    return functionInfo;\n-  }\n-\n-  public static void registerFunction(Method method) {\n+  public static synchronized void registerFunction(Method method) {\n     registerFunction(method.getName().toLowerCase(), method);\n   }\n \n-  public static void registerFunction(String name, Method method) {\n+  /**\n+   * Registers a method with the given function name.\n+   */\n+  public static synchronized void registerFunction(String functionName, Method method) {\n     FunctionInfo functionInfo = new FunctionInfo(method, method.getDeclaringClass());\n-    _functionInfoMap.put(name, functionInfo);\n+    FUNCTION_INFO_MAP.put(functionName, functionInfo);\n   }\n \n-  public static boolean containsFunctionByName(String funcName) {\n-    return _functionInfoMap.containsKey(funcName.toLowerCase());\n-  }\n-\n-  static {\n-    try {\n-\n-      Reflections reflections = new Reflections(\n-          new ConfigurationBuilder().setUrls(ClasspathHelper.forPackage(\"org.apache.pinot\"))\n-              .setScanners(new MethodAnnotationsScanner()));\n-\n-      Set<Method> methodSet = reflections.getMethodsAnnotatedWith(ScalarFunction.class);\n-      for (Method method : methodSet) {\n-        ScalarFunction scalarFunction = method.getAnnotation(ScalarFunction.class);\n-        if (scalarFunction.enabled()) {\n-          if (!scalarFunction.name().isEmpty()) {\n-            FunctionRegistry.registerFunction(scalarFunction.name(), method);\n-          } else {\n-            FunctionRegistry.registerFunction(method);\n-          }\n-        }\n-      }\n-\n-    } catch (Exception e) {\n-      LOGGER.error(\"Caught exception when registering function\", e);\n-      throw new IllegalStateException(e);\n-    }\n+  /**\n+   * Returns the {@link FunctionInfo} associated with the given function name, or {@code null} if there is no method\n+   * registered under the name. This method should be called after the FunctionRegistry is initialized and all methods\n+   * are already registered.\n+   */\n+  @Nullable\n+  public static FunctionInfo getFunctionByName(String functionName) {\n+    return FUNCTION_INFO_MAP.get(functionName.toLowerCase());", "originalCommit": "4cb398a9c2113369c3cbe3c4139d5f968bdb3f9c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc1MDg4Ng==", "url": "https://github.com/apache/pinot/pull/5531#discussion_r437750886", "bodyText": "Added", "author": "Jackie-Jiang", "createdAt": "2020-06-09T22:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0MDQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0NDU5OQ==", "url": "https://github.com/apache/pinot/pull/5531#discussion_r437744599", "bodyText": "why are you removing this check?", "author": "sajjad-moradi", "createdAt": "2020-06-09T21:55:17Z", "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -667,21 +666,23 @@ protected static Expression invokeCompileTimeFunctionExpression(Expression funcE\n       function.getOperands().set(i, operand);\n     }\n     String funcName = function.getOperator();\n-    if (FunctionRegistry.containsFunctionByName(funcName) && compilable) {", "originalCommit": "4cb398a9c2113369c3cbe3c4139d5f968bdb3f9c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0OTQyNA==", "url": "https://github.com/apache/pinot/pull/5531#discussion_r437749424", "bodyText": "FunctionRegistry.getFunctionByName() can handle function name not registered by returning null. I have a null check after this to save the extra hash lookup.", "author": "Jackie-Jiang", "createdAt": "2020-06-09T22:07:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0NDU5OQ=="}], "type": "inlineReview"}, {"oid": "9f1eea901d019a0b434d2dd951c1e249c500bf41", "url": "https://github.com/apache/pinot/commit/9f1eea901d019a0b434d2dd951c1e249c500bf41", "message": "Fix the failure caused by Reflections in FunctionRegistry\n\nThe problem is caused by Reflections library not being thread-safe when multiple threads are accessing the same jar file.\nRead more about the thread-safety issue here: https://github.com/ronmamo/reflections/issues/81\nUsers are reporting the same issue even with the latest Reflections version 0.9.12.\nA common solution is to downgrade Reflections to 0.9.9, but we have other dependencies rely on 0.9.11, so downgrading might cause other issues.\n\nThe solution introduced here is by replacing the static block with an init() method so that we can control when to scan the files to avoid the thread-safety issue.\nAnother benefit of using an init() method is that the exception won't be swallowed (the exception in static block will be swallowed and query engine will start getting ClassNotFoundException)\n\nThis PR also introduces a convention for the plugin methods using reflection, where the class must includes \".function.\" in its class path.\nThis can significantly reduce the time of class scanning (reduced from 4 seconds to 200 ms locally)", "committedDate": "2020-06-09T22:11:42Z", "type": "forcePushed"}, {"oid": "503eff8d10b7e3dc4c9db7f2f6ae8b8d151af400", "url": "https://github.com/apache/pinot/commit/503eff8d10b7e3dc4c9db7f2f6ae8b8d151af400", "message": "Fix the failure caused by Reflections in FunctionRegistry\n\nThe problem is caused by Reflections library not being thread-safe when multiple threads are accessing the same jar file.\nRead more about the thread-safety issue here: https://github.com/ronmamo/reflections/issues/81\nUsers are reporting the same issue even with the latest Reflections version 0.9.12.\nA common solution is to downgrade Reflections to 0.9.9, but we have other dependencies rely on 0.9.11, so downgrading might cause other issues.\n\nThe solution introduced here is by replacing the static block with an init() method so that we can control when to scan the files to avoid the thread-safety issue.\nAnother benefit of using an init() method is that the exception won't be swallowed (the exception in static block will be swallowed and query engine will start getting ClassNotFoundException)\n\nThis PR also introduces a convention for the plugin methods using reflection, where the class must includes \".function.\" in its class path.\nThis can significantly reduce the time of class scanning (reduced from 4 seconds to 200 ms locally)", "committedDate": "2020-06-10T00:48:46Z", "type": "commit"}, {"oid": "503eff8d10b7e3dc4c9db7f2f6ae8b8d151af400", "url": "https://github.com/apache/pinot/commit/503eff8d10b7e3dc4c9db7f2f6ae8b8d151af400", "message": "Fix the failure caused by Reflections in FunctionRegistry\n\nThe problem is caused by Reflections library not being thread-safe when multiple threads are accessing the same jar file.\nRead more about the thread-safety issue here: https://github.com/ronmamo/reflections/issues/81\nUsers are reporting the same issue even with the latest Reflections version 0.9.12.\nA common solution is to downgrade Reflections to 0.9.9, but we have other dependencies rely on 0.9.11, so downgrading might cause other issues.\n\nThe solution introduced here is by replacing the static block with an init() method so that we can control when to scan the files to avoid the thread-safety issue.\nAnother benefit of using an init() method is that the exception won't be swallowed (the exception in static block will be swallowed and query engine will start getting ClassNotFoundException)\n\nThis PR also introduces a convention for the plugin methods using reflection, where the class must includes \".function.\" in its class path.\nThis can significantly reduce the time of class scanning (reduced from 4 seconds to 200 ms locally)", "committedDate": "2020-06-10T00:48:46Z", "type": "forcePushed"}]}