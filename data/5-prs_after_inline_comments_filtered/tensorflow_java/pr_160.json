{"pr_number": 160, "pr_title": "[Type Refactor] Merge TType and Tensor instances as a single entity", "pr_createdAt": "2020-12-02T04:37:13Z", "pr_url": "https://github.com/tensorflow/java/pull/160", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMDM1Mg==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r535330352", "bodyText": "Unless it would sometimes be correct to use a native handle from a different tensor than tensor, just pass in tensor and let the apply method obtain nativeHandle from it.", "author": "deansher", "createdAt": "2020-12-03T15:27:46Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/DataType.java", "diffHunk": "@@ -35,13 +34,13 @@\n   public interface TensorMapper<T> {\n \n     /**\n-     * Maps tensor memory to a data structure for manipulating elements of this type.\n+     * Maps the tensor memory to a n-dimensional typed data space.\n      *\n-     * @param nativeTensor pointer to the native tensor\n-     * @param shape the shape of the tensor\n-     * @return data structure of elements of this type\n+     * @param tensor the tensor to map in its raw nature\n+     * @param nativeHandle native handle of the tensor\n+     * @return a typed tensor of type {@code T}\n      */\n-    T apply(TF_Tensor nativeTensor, Shape shape);\n+    T apply(RawTensor tensor, TF_Tensor nativeHandle);", "originalCommit": "0225ab65e737ee3cccc4dcd61683779f0f8312ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ5OTI0MA==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r536499240", "bodyText": "The reason I'm passing nativeHandle as a separate parameter here is because I want to keep RawTensor.nativeHandle() package-private, reserving its use to what is located under org.tensorflow only. But as implementors of TensorMapper are outside this package, apply serves also as a visitor to RawTensor internal representation.", "author": "karllessard", "createdAt": "2020-12-05T04:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMDM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgwNDIzNA==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r536804234", "bodyText": "Convincing! Perhaps incorporate this explanation as a comment?", "author": "deansher", "createdAt": "2020-12-05T14:59:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMDM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1NTQ1Mg==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538955452", "bodyText": "We could add a default method that accepts a RawTensor and unpacks it into the RawTensor and the TF_Tensor and calls apply? I'm a little uncomfortable with the idea that we can't validate that they came from the same tensor (because we could end up with some weird bugs). At the very least the doc needs to note that the arguments are from the same object.", "author": "Craigacp", "createdAt": "2020-12-09T02:24:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMDM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMzNTIxNQ==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r539335215", "bodyText": "We could add a default method that accepts a RawTensor and unpacks it into the RawTensor and the TF_Tensor and calls apply\n\nCurrent signature for apply also ensure that only classes of the org.tensorflow package can invoke it, since you shouldn't be able to have a reference to a tensor native handle. Just accepting RawTensor will open it up to the outside world. Now, let's not be zealous about securing the tensor native handle neither, I think this is a good trade off, I'll make the changes.", "author": "karllessard", "createdAt": "2020-12-09T14:08:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMDM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU4ODc0OQ==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r539588749", "bodyText": "Sure, that's a good point. If it's something that's designed to be locked off when we eventually have modules then maybe we should just document it that way and move on.", "author": "Craigacp", "createdAt": "2020-12-09T19:33:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMDM1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0MDIxMA==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r535340210", "bodyText": "This call to asTypedTensor is semantically strange: it does significant extra work to \"upgrade\" the tensor in a way not required by resolveTensorHandle's Tensor return type.\nI don't understand the overall flow well enough yet to know whether there's a runtime requirement to call asTypedTensor here. If so, return TType. If not, omit the call.", "author": "deansher", "createdAt": "2020-12-03T15:36:45Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperation.java", "diffHunk": "@@ -156,13 +156,13 @@ private static void requireTensorHandle(TFE_TensorHandle handle) {\n     }\n   }\n \n-  private static Tensor<?> resolveTensorHandle(TFE_TensorHandle handle, EagerSession session) {\n+  private static Tensor resolveTensorHandle(TFE_TensorHandle handle, EagerSession session) {\n     requireTensorHandle(handle);\n     try (PointerScope scope = new PointerScope()) {\n       TF_Status status = TF_Status.newStatus();\n       TF_Tensor tensor = TFE_TensorHandleResolve(handle, status).withDeallocator();\n       status.throwExceptionIfNotOK();\n-      return Tensor.fromHandle(tensor, session);\n+      return RawTensor.fromHandle(tensor, session).asTypedTensor();", "originalCommit": "0225ab65e737ee3cccc4dcd61683779f0f8312ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUwMTg1Nw==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r536501857", "bodyText": "RawTensor.asTypedTensor() is also a package-private method for typing a tensor from its raw nature. The reason why I'm doing it here is that tensors resolved in an eager operation are cached in that object and are ultimately typed before they can be used by the user. Meaning that if we only preserve a raw copy of the tensor in cache, then they will need to be converted as a typed tensor everytime the user get accesses them.\nTherefore, typing them right away at this level is simply to improve performances when the tensors are accessed multiple times via its container (e.g. `Operand.asTensor()).", "author": "karllessard", "createdAt": "2020-12-05T04:06:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0MDIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgwNDI3OQ==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r536804279", "bodyText": "Convincing! Perhaps incorporate this explanation as a comment?", "author": "deansher", "createdAt": "2020-12-05T14:59:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0MDIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA3MDY1MQ==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r536070651", "bodyText": "{@link org.tensorflow.RawTensor}", "author": "deansher", "createdAt": "2020-12-04T12:39:15Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/types/family/TType.java", "diffHunk": "@@ -17,21 +17,40 @@\n \n package org.tensorflow.types.family;\n \n+import org.tensorflow.Tensor;\n+\n /**\n- * Marker interface for all tensor types.\n+ * Common interface for all typed tensors.\n  *\n- * <p>Tensor types are carried as a generic parameter of the {@link org.tensorflow.Tensor Tensor}\n- * class bound by the {@code TType} interface. This generic parameter ensure type-compatibility\n- * between operands of a computation at compile-time. For example:\n+ * <p>Typed tensors wraps a {@link RawTensor} by mapping their native memory to a n-dimensional", "originalCommit": "0225ab65e737ee3cccc4dcd61683779f0f8312ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2NjY4Nw==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538966687", "bodyText": "s/wraps/wrap/", "author": "Craigacp", "createdAt": "2020-12-09T02:55:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA3MDY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA3MzQ5Ng==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r536073496", "bodyText": "TType is documented as wrapping a RawTensor and as adding new capability (\"mapping their native memory to a n-dimensional...\"), but neither shows up in this interface.\nIf every Tensor wraps a RawTensor, then perhaps that's not something TType does?\nPerhaps it would be cleaner to have TType indicate its additional capability by itself extending NdArray, rather than leaving that to its subinterfaces? This would require that TType carry a type parameter representing its element type. Perhaps that would prove cumbersome, but it feels usefully more expressive to me. (IDEA is happy to help me browse the 2,468 uses of TType to figure this out.) So:\npublic interface TType<T> extends Tensor, NdArray<T> {\n  . . .\n}\n\npublic interface TNumber<T extends Number> extends TType<T> {}\n\npublic interface TInt32 extends IntNdArray, TNumber<Integer> {\n  . . .\n}", "author": "deansher", "createdAt": "2020-12-04T12:44:21Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/types/family/TType.java", "diffHunk": "@@ -17,21 +17,40 @@\n \n package org.tensorflow.types.family;\n \n+import org.tensorflow.Tensor;\n+\n /**\n- * Marker interface for all tensor types.\n+ * Common interface for all typed tensors.\n  *\n- * <p>Tensor types are carried as a generic parameter of the {@link org.tensorflow.Tensor Tensor}\n- * class bound by the {@code TType} interface. This generic parameter ensure type-compatibility\n- * between operands of a computation at compile-time. For example:\n+ * <p>Typed tensors wraps a {@link RawTensor} by mapping their native memory to a n-dimensional\n+ * data space allowing direct I/O access from the JVM.</p>\n  *\n- * <pre>{@code\n- * Tensor<TFloat32> tensor1 = TFloat32.ofShape(2, 3, 2);\n- * Tensor<TFloat32> tensor2 = TFloat32.ofShape(2, 3, 2);\n- * Tensor<TInt32> tensor3 = TInt32.ofShape(2, 3, 2);\n+ * <p>Subinterfaces of {@code TType} are propagated as a generic parameter to various entities of\n+ * TensorFlow to identify the type of the tensor they carry. For example, a\n+ * {@link org.tensorflow.Operand Operand<TFloat32>} is an operand which outputs is a 32-bit floating\n+ * point tensor. This parameter ensure type-compatibility between operands of a computation at\n+ * compile-time. For example:\n  *\n+ * <pre>{@code\n  * Ops tf = Ops.create();\n- * tf.math.add(tf.constant(tensor1), tf.constant(tensor2));  // OK\n- * tf.math.add(tf.constant(tensor1), tf.constant(tensor3));  // Compilation failure\n+ *\n+ * Constant<TFloat32> c1 = tf.array(2.0f, 3.0f, 2.0f);\n+ * Constant<TFloat32> c2 = tf.array(1.0f, 2.0f, 3.0f);\n+ * Constant<TInt32> c3 = tf.array(2, 3, 2);\n+ *\n+ * tf.math.add(c1, c2);  // OK\n+ * tf.math.add(c1, c3);  // Compilation failure\n  * }</pre>\n  */\n-public interface TType {}\n+public interface TType extends Tensor {", "originalCommit": "0225ab65e737ee3cccc4dcd61683779f0f8312ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUxMTI0Mw==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r536511243", "bodyText": "I deliberately tried to leave TType unparameterized, partially to reduce verbosity since this interface is carried in many endpoints and containers. If we add a parameter to TType, signatures with T extends TType now become T extends TType<U>, U, where you'll need to carry U everywhere as well, unless you turn it into a wildcard but then you lose the plus value of having a parameter.\nBoth TType and RawTensor instances are a Tensor, but only the former is typed so that a user can access its data properly but requiring him to cast it to a concrete type to do it. This is intentional as it leverages the use of primitive access endpoints to retrieve the data instead of the boxed ones.\nFor example, if a user has an instance of TType<Float> that extends from NdArray<Float>, chances are that he would retrieve its data probably directly via the boxed-type methods like t.getObject(), which would return costly Float objects.\nBut by enforcing a cast from TType to TFloat32 instead, he would retrieve the same data but now being able to use t.getFloat() from FloatNdArray, which returns float primitive values, improving performances overall.", "author": "karllessard", "createdAt": "2020-12-05T04:39:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA3MzQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgwNDQ4NA==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r536804484", "bodyText": "Convincing! Perhaps incorporate the essence of this explanation as a comment?", "author": "deansher", "createdAt": "2020-12-05T15:00:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA3MzQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA4NTk0OA==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r536085948", "bodyText": "Seems uncomfortable that both this method and asRawTensor, below, provide pathways for obtaining the DataType, but via completely different mechanisms. It would be very bad if a tbool.dataType() was different than tbool.asRawTensor().dataType().\nPerhaps have the TBoolImpl constructor throw IllegalStateException if rawTensor.dataType() != TBool.DTYPE, but then for efficiency leave the discomfort as it is?", "author": "deansher", "createdAt": "2020-12-04T13:06:14Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/types/TBool.java", "diffHunk": "@@ -111,19 +111,33 @@\n    * @return the new tensor\n    * @throws TensorFlowException if the tensor cannot be allocated or initialized\n    */\n-  static Tensor<TBool> tensorOf(Shape shape, Consumer<TBool> dataInit) {\n+  static TBool tensorOf(Shape shape, Consumer<TBool> dataInit) {\n     return Tensor.of(DTYPE, shape, dataInit);\n   }\n }\n \n /** Hidden implementation of a {@code TBool} */\n class TBoolImpl extends BooleanDenseNdArray implements TBool {\n \n-  static TBool mapTensor(TF_Tensor nativeTensor, Shape shape) {\n-    return new TBoolImpl(TensorBuffers.toBooleans(nativeTensor), shape);\n+  @Override\n+  public DataType<?> dataType() {", "originalCommit": "0225ab65e737ee3cccc4dcd61683779f0f8312ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUwNzg5Nw==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r536507897", "bodyText": "Based on how the tensors are converted from their raw nature to their typed one, I don't think it is possible that both values end up being out-of-sync. But anyhow, the ultimate plan is to return TBool.class and not TBool.DTYPE in TBoolImpl, while in RawTensor the datatype will be returned as a raw value instead, as defined in this enumeration.\nSo maybe we can mitigate this detail until we complete the changes and split dataType() in 2 different methods? I was thinking that the method returning a type class like TBool.class could be declared in TType  (maybe called type() or tensorType()) while dataType() will remain in Tensor but returning an enum value instead.", "author": "karllessard", "createdAt": "2020-12-05T04:16:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA4NTk0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgwNDU0Ng==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r536804546", "bodyText": "I am comfortable with this direction, and with leaving it this way for now.", "author": "deansher", "createdAt": "2020-12-05T15:00:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA4NTk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0MDMyNg==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538940326", "bodyText": "Why'd this go away in this PR?", "author": "Craigacp", "createdAt": "2020-12-09T01:42:37Z", "path": "tensorflow-core/tensorflow-core-api/src/gen/annotations/org/tensorflow/op/DebuggingOps.java", "diffHunk": "@@ -1,50 +0,0 @@\n-// Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//     http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-// ==============================================================================\n-//\n-// This class has been generated, DO NOT EDIT!\n-//\n-package org.tensorflow.op;\n-\n-import org.tensorflow.Operand;\n-import org.tensorflow.op.debugging.CheckNumerics;\n-import org.tensorflow.types.family.TNumber;\n-\n-/**\n- * An API for building {@code debugging} operations as {@link Op Op}s\n- *\n- * @see {@link Ops}\n- */\n-public final class DebuggingOps {\n-  private final Scope scope;\n-\n-  DebuggingOps(Scope scope) {\n-    this.scope = scope;\n-  }\n-\n-  /**\n-   * Checks a tensor for NaN and Inf values.\n-   *  <p>\n-   *  When run, reports an `InvalidArgument` error if `tensor` has any values\n-   *  that are not a number (NaN) or infinity (Inf). Otherwise, passes `tensor` as-is.\n-   *\n-   * @param <T> data type for {@code output()} output\n-   * @param tensor\n-   * @param message Prefix of the error message.\n-   * @return a new instance of CheckNumerics\n-   */\n-  public <T extends TNumber> CheckNumerics<T> checkNumerics(Operand<T> tensor, String message) {", "originalCommit": "0225ab65e737ee3cccc4dcd61683779f0f8312ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMzNzcyOQ==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r539337729", "bodyText": "I think it has been removed from the TF runtime library and we have just never updated it (ideally, we should delete our generated file folder before regenerating them, I think right now deleted ops remain present). I will need to double-check.", "author": "karllessard", "createdAt": "2020-12-09T14:11:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0MDMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0MDYwMA==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538940600", "bodyText": "I guess I should do another round on making this deterministic as it's really annoying having it move things in PRs.", "author": "Craigacp", "createdAt": "2020-12-09T01:43:27Z", "path": "tensorflow-core/tensorflow-core-api/src/gen/annotations/org/tensorflow/op/Ops.java", "diffHunk": "@@ -347,10 +346,10 @@\n \n   public final SignalOps signal;\n \n-  public final TrainOps train;\n-\n   public final QuantizationOps quantization;\n \n+  public final TrainOps train;", "originalCommit": "0225ab65e737ee3cccc4dcd61683779f0f8312ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0MTEyNA==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538941124", "bodyText": "s/capture/copy/ or immutableCopy ? I don't particularly like the name capture here as it doesn't actually change the state of the tensor argument.", "author": "Craigacp", "createdAt": "2020-12-09T01:44:54Z", "path": "tensorflow-core/tensorflow-core-api/src/gen/annotations/org/tensorflow/op/Ops.java", "diffHunk": "@@ -1071,6 +1070,17 @@ public Batch batch(Iterable<Operand<?>> inTensors, Long numBatchThreads, Long ma\n     return Bucketize.create(scope, input, boundaries);\n   }\n \n+  /**\n+   * Capture a {@code tensor} by making a constant copy of it.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param tensor a Tensor holding the constant value\n+   * @return a constant of the same data type as `tensor`\n+   */\n+  public <T extends TType> Constant<T> capture(T tensor) {", "originalCommit": "0225ab65e737ee3cccc4dcd61683779f0f8312ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0MDE1NA==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r539340154", "bodyText": "I don't like capture neither. As discussed here, eventually the tensors could be automatically converted to constants so we will not need to call this endpoint anymore. Still, I now think copy do sound more appropriate as well, I'll make the change.", "author": "karllessard", "createdAt": "2020-12-09T14:14:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0MTEyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTgzNjkyOQ==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r541836929", "bodyText": "Ok as copy already exist as another primitive op, I've decided to rename capture by constantOf, as it is close enough to the original constant name and will be easier to find by our users on auto-completion.", "author": "karllessard", "createdAt": "2020-12-13T03:53:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0MTEyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1Njg0NQ==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538956845", "bodyText": "\"implicitly via try-with-resources\"", "author": "Craigacp", "createdAt": "2020-12-09T02:28:05Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/RawTensor.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+package org.tensorflow;\n+\n+import static org.tensorflow.internal.c_api.global.tensorflow.TF_Dim;\n+import static org.tensorflow.internal.c_api.global.tensorflow.TF_NumDims;\n+import static org.tensorflow.internal.c_api.global.tensorflow.TF_TensorByteSize;\n+import static org.tensorflow.internal.c_api.global.tensorflow.TF_TensorType;\n+\n+import org.bytedeco.javacpp.PointerScope;\n+import org.tensorflow.internal.buffer.TensorBuffers;\n+import org.tensorflow.internal.c_api.TF_Tensor;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.ndarray.Shaped;\n+import org.tensorflow.ndarray.buffer.ByteDataBuffer;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * A tensor which memory has not been mapped.\n+ *\n+ * <p>A raw tensor is a minimalist representation of a tensor allocated in native memory by the\n+ * TensorFlow runtime library and it controls its lifetime within the current process. The data\n+ * is represented by a flat {@link ByteDataBuffer buffer of bytes}, until it is mapped in a\n+ * n-dimensional typed space by a {@link TType typed tensor}.</p>\n+ *\n+ * <p>Instances of a RawTensor are <b>not</b> thread-safe and their resource must be released\n+ * by calling {@link #close()} explicitly or implicitly (try-with-resources).</p>", "originalCommit": "0225ab65e737ee3cccc4dcd61683779f0f8312ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1NzAxNw==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538957017", "bodyText": "This is a little confusing. Does it mean \"A tensor which is resident on the native heap rather than the Java heap\"?", "author": "Craigacp", "createdAt": "2020-12-09T02:28:38Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/RawTensor.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+package org.tensorflow;\n+\n+import static org.tensorflow.internal.c_api.global.tensorflow.TF_Dim;\n+import static org.tensorflow.internal.c_api.global.tensorflow.TF_NumDims;\n+import static org.tensorflow.internal.c_api.global.tensorflow.TF_TensorByteSize;\n+import static org.tensorflow.internal.c_api.global.tensorflow.TF_TensorType;\n+\n+import org.bytedeco.javacpp.PointerScope;\n+import org.tensorflow.internal.buffer.TensorBuffers;\n+import org.tensorflow.internal.c_api.TF_Tensor;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.ndarray.Shaped;\n+import org.tensorflow.ndarray.buffer.ByteDataBuffer;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * A tensor which memory has not been mapped.", "originalCommit": "0225ab65e737ee3cccc4dcd61683779f0f8312ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0MjE3Mw==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r539342173", "bodyText": "A tensor never resides on the Java heap, it is always in native memory and until we map it to a given TType, we can only access its data as a flat buffer of bytes.\nSo mapped here means mapped to a multidimensional data space directly accessible from the JVM, want me to add something like this?", "author": "karllessard", "createdAt": "2020-12-09T14:17:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1NzAxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5MDMwMQ==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r539590301", "bodyText": "Sure.", "author": "Craigacp", "createdAt": "2020-12-09T19:36:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1NzAxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MDY2OA==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538960668", "bodyText": "Shouldn't this line be outside the <pre>?", "author": "Craigacp", "createdAt": "2020-12-09T02:38:33Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Tensor.java", "diffHunk": "@@ -43,44 +46,34 @@\n  * try (Tensor t = Tensor.of(...)) {\n  *   doSomethingWith(t);\n  * }\n+ *\n+ * <p>Instances of a Tensor are <b>not</b> thread-safe.", "originalCommit": "0225ab65e737ee3cccc4dcd61683779f0f8312ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MTM5Mw==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538961393", "bodyText": "Why not use tensor.asTypedTensor() here?", "author": "Craigacp", "createdAt": "2020-12-09T02:40:39Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Tensor.java", "diffHunk": "@@ -92,19 +85,13 @@\n    *                                  store the tensor data\n    * @throws IllegalStateException if tensor failed to be allocated\n    */\n-  public static <T extends TType> Tensor<T> of(DataType<T> dtype, Shape shape, long size) {\n-    // Minimum requirements for datatypes of variable length cannot be verified in a relevant way so\n-    // we only validate them for fixed length datatypes\n-    if (!dtype.isVariableLength() && shape.size() * dtype.byteSize() > size) {\n-      throw new IllegalArgumentException(\"Tensor size is not large enough to contain all scalar values\");\n-    }\n-    Tensor<T> t = new Tensor<>(dtype, shape);\n-    TF_Tensor nativeHandle = allocate(t.dtype.nativeCode(), shape.asArray(), size);\n-    try (PointerScope scope = new PointerScope()) {\n-        scope.attach(nativeHandle);\n-        t.tensorHandle = nativeHandle;\n-        t.tensorScope = scope.extend();\n-        return t;\n+  static <T extends TType> T of(DataType<T> dtype, Shape shape, long size) {\n+    RawTensor tensor = RawTensor.allocate(dtype, shape, size);\n+    try {\n+      return dtype.map(tensor);", "originalCommit": "0225ab65e737ee3cccc4dcd61683779f0f8312ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0MzA1MQ==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r539343051", "bodyText": "Ah probably I could, I've added asTypedTensor() later in my work", "author": "karllessard", "createdAt": "2020-12-09T14:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MTM5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MTcyNg==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538961726", "bodyText": "\"such as a\" or \"such as the\" (not sure if there could be more than one lookup table in a String tensor).", "author": "Craigacp", "createdAt": "2020-12-09T02:41:36Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Tensor.java", "diffHunk": "@@ -144,7 +130,7 @@\n    * size for the tensor is explicitly set instead of being computed from the datatype and shape.\n    *\n    * <p>This could be useful for tensor types that stores data but also metadata in the tensor memory,\n-   * such as {@link org.tensorflow.types.TString TString}.\n+   * such as lookup table in a tensor of strings.", "originalCommit": "0225ab65e737ee3cccc4dcd61683779f0f8312ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MjUwOA==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538962508", "bodyText": "Why does this catch Throwable? If an Error has been thrown then the JVM is going down anyway, and we might not be able to execute tensor.close(). Especially as the other of method catches Exception.", "author": "Craigacp", "createdAt": "2020-12-09T02:43:48Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Tensor.java", "diffHunk": "@@ -157,11 +143,10 @@\n    *                                  store the tensor data\n    * @throws IllegalStateException if tensor failed to be allocated\n    */\n-  public static <T extends TType> Tensor<T> of(DataType<T> dtype, Shape shape, long size,\n-      Consumer<T> dataInitializer) {\n-    Tensor<T> tensor = of(dtype, shape, size);\n+  static <T extends TType> T of(DataType<T> dtype, Shape shape, long size, Consumer<T> dataInitializer) {\n+    T tensor = of(dtype, shape, size);\n     try {\n-      dataInitializer.accept(tensor.data());\n+      dataInitializer.accept(tensor);\n       return tensor;\n     } catch (Throwable t) {", "originalCommit": "0225ab65e737ee3cccc4dcd61683779f0f8312ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MzM2MA==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538963360", "bodyText": "If we make this DataType<? extends TType> can we concretely type the subclass methods?", "author": "Craigacp", "createdAt": "2020-12-09T02:46:22Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Tensor.java", "diffHunk": "@@ -182,203 +167,39 @@\n    * @throws IllegalArgumentException if {@code rawData} is not large enough to contain the tensor data\n    * @throws IllegalStateException if tensor failed to be allocated with the given parameters\n    */\n-  public static <T extends TType> Tensor<T> of(DataType<T> dtype, Shape shape, ByteDataBuffer rawData) {\n-    Tensor<T> t = of(dtype, shape, rawData.size());\n-    rawData.copyTo(TensorBuffers.toBytes(t.nativeHandle()), rawData.size());\n-    return t;\n-  }\n-\n-  /**\n-   * Returns this Tensor object with the type {@code Tensor<U>}. This method is useful when given a\n-   * value of type {@code Tensor<?>}.\n-   *\n-   * @param dt any supported tensor data type\n-   * @param <U> a tensor type\n-   * @return a tensor of the requested data type\n-   * @throws IllegalArgumentException if the actual data type of this object does not match the type\n-   *     {@code U}.\n-   */\n-  @SuppressWarnings(\"unchecked\")\n-  public <U extends TType> Tensor<U> expect(DataType<U> dt) {\n-    if (!dt.equals(this.dtype)) {\n-      throw new IllegalArgumentException(\n-          \"Cannot cast from tensor of \" + dtype + \" to tensor of \" + dt);\n-    }\n-    return ((Tensor<U>) this);\n+  static <T extends TType> T of(DataType<T> dtype, Shape shape, ByteDataBuffer rawData) {\n+    return of(dtype, shape, rawData.size(), t -> rawData.copyTo(t.asRawTensor().data(), rawData.size()));\n   }\n \n   /**\n-   * Release resources associated with the Tensor.\n-   *\n-   * <p><b>WARNING:</b>This must be invoked for all tensors that were not been produced by an eager\n-   * operation or memory will be leaked.\n-   *\n-   * <p>The Tensor object is no longer usable after {@code close} returns.\n+   * Returns the {@link DataType} of elements stored in the tensor.\n    */\n-  @Override\n-  public void close() {\n-    tensorScope.close();\n-  }\n-\n-  /** Returns the {@link DataType} of elements stored in the Tensor. */\n-  public DataType<T> dataType() {\n-    return dtype;\n-  }\n-\n-  /** Returns the size, in bytes, of the tensor data. */\n-  public long numBytes() {\n-    if (numBytes == null) {\n-      numBytes = TF_TensorByteSize(tensorHandle);\n-    }\n-    return numBytes;\n-  }\n-\n-  /** Returns the shape of this tensor. */\n-  @Override\n-  public Shape shape() {\n-    return shape;\n-  }\n+  DataType<?> dataType();", "originalCommit": "0225ab65e737ee3cccc4dcd61683779f0f8312ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0NDkwMQ==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r539344901", "bodyText": "The next PR will replace DataType<?> by DataType, among other things. I was trying to limit the number of changes in this one.", "author": "karllessard", "createdAt": "2020-12-09T14:20:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MzM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5MDc4NQ==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r539590785", "bodyText": "Sure, I lost sight of the overall goal for a moment.", "author": "Craigacp", "createdAt": "2020-12-09T19:36:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MzM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2NDk4Mw==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538964983", "bodyText": "Can this be DataType<TBfloat16> if we type the super method appropriately?", "author": "Craigacp", "createdAt": "2020-12-09T02:50:58Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/types/TBfloat16.java", "diffHunk": "@@ -119,20 +120,33 @@\n    * @return the new tensor\n    * @throws TensorFlowException if the tensor cannot be allocated or initialized\n    */\n-  static Tensor<TBfloat16> tensorOf(Shape shape, Consumer<TBfloat16> dataInit) {\n+  static TBfloat16 tensorOf(Shape shape, Consumer<TBfloat16> dataInit) {\n     return Tensor.of(DTYPE, shape, dataInit);\n   }\n }\n \n /** Hidden implementation of a {@code TBfloat16} */\n class TBfloat16Impl extends FloatDenseNdArray implements TBfloat16 {\n \n-  static TBfloat16 mapTensor(TF_Tensor nativeTensor, Shape shape) {\n-    return new TBfloat16Impl(\n-        DataLayouts.BFLOAT16.applyTo(TensorBuffers.toShorts(nativeTensor)), shape);\n+  @Override\n+  public DataType<?> dataType() {", "originalCommit": "0225ab65e737ee3cccc4dcd61683779f0f8312ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0NTI5MQ==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r539345291", "bodyText": "See #160 (comment)", "author": "karllessard", "createdAt": "2020-12-09T14:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2NDk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2NzAzOA==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538967038", "bodyText": "s/outputs is/outputs/", "author": "Craigacp", "createdAt": "2020-12-09T02:56:33Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/types/family/TType.java", "diffHunk": "@@ -17,21 +17,40 @@\n \n package org.tensorflow.types.family;\n \n+import org.tensorflow.Tensor;\n+\n /**\n- * Marker interface for all tensor types.\n+ * Common interface for all typed tensors.\n  *\n- * <p>Tensor types are carried as a generic parameter of the {@link org.tensorflow.Tensor Tensor}\n- * class bound by the {@code TType} interface. This generic parameter ensure type-compatibility\n- * between operands of a computation at compile-time. For example:\n+ * <p>Typed tensors wraps a {@link RawTensor} by mapping their native memory to a n-dimensional\n+ * data space allowing direct I/O access from the JVM.</p>\n  *\n- * <pre>{@code\n- * Tensor<TFloat32> tensor1 = TFloat32.ofShape(2, 3, 2);\n- * Tensor<TFloat32> tensor2 = TFloat32.ofShape(2, 3, 2);\n- * Tensor<TInt32> tensor3 = TInt32.ofShape(2, 3, 2);\n+ * <p>Subinterfaces of {@code TType} are propagated as a generic parameter to various entities of\n+ * TensorFlow to identify the type of the tensor they carry. For example, a\n+ * {@link org.tensorflow.Operand Operand<TFloat32>} is an operand which outputs is a 32-bit floating", "originalCommit": "0225ab65e737ee3cccc4dcd61683779f0f8312ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2Nzk3Nw==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538967977", "bodyText": "Shouldn't the type of this list be Tensor not ??", "author": "Craigacp", "createdAt": "2020-12-09T02:59:10Z", "path": "tensorflow-core/tensorflow-core-api/src/test/java/org/tensorflow/op/core/GradientsTest.java", "diffHunk": "@@ -47,13 +47,13 @@ public void createGradients() {\n       assertNotNull(grads.dy());\n       assertEquals(2, grads.dy().size());\n \n-      try (Tensor<TFloat32> c = TFloat32.scalarOf(3.0f);\n-          AutoCloseableList<Tensor<?>> outputs =\n+      try (TFloat32 c = TFloat32.scalarOf(3.0f);\n+          AutoCloseableList<?> outputs =", "originalCommit": "0225ab65e737ee3cccc4dcd61683779f0f8312ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0NTk1NQ==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r539345955", "bodyText": "Yes, looks like a massive auto-replace mistake, thanks!", "author": "karllessard", "createdAt": "2020-12-09T14:21:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2Nzk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2ODgwNQ==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538968805", "bodyText": "Formatting seems off in this else block. Also maybe we should have a TIntegral type to go with TFloating and then the else block really can't happen. And when we get sealed types in a future Java version we can have the compiler check it for us.", "author": "Craigacp", "createdAt": "2020-12-09T03:01:25Z", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/utils/ShapeUtils.java", "diffHunk": "@@ -63,64 +63,36 @@\n    * @throws java.lang.IllegalArgumentException if the dims type is not an integer\n    */\n   public static <T extends TNumber> long[] getLongArray(Scope scope, Operand<T> dims) {\n-    DataType<T> dType = dims.asOutput().dataType();\n-    if (!dType.isInteger()) {\n-      throw new IllegalArgumentException(\"the data type must be an integer type\");\n-    }\n-    List<Long> result = new ArrayList<>();\n-\n     if (scope.env().isEager()) {\n-      if (dType.equals(TInt32.DTYPE)) {\n-        @SuppressWarnings(\"unchecked\")\n-        Operand<TInt32> idims = (Operand<TInt32>) dims;\n-\n-        idims.asOutput().data().scalars().forEach(s -> result.add((long) s.getInt()));\n-      } else if (dType.equals(TInt64.DTYPE)) {\n-        @SuppressWarnings(\"unchecked\")\n-        Operand<TInt64> ldims = (Operand<TInt64>) dims;\n-        ldims.asOutput().data().scalars().forEach(s -> result.add(s.getLong()));\n-      } else if (dType.equals(TUint8.DTYPE)) {\n-        @SuppressWarnings(\"unchecked\")\n-        Operand<TUint8> udims = (Operand<TUint8>) dims;\n-        udims.asOutput().data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n-      } else { // shouldn't happen\n-        throw new IllegalArgumentException(\"the data type must be an integer type\");\n-      }\n-\n-    } else {\n-      try (Session session = new Session((Graph) scope.env())) {\n-        if (dType.equals(TInt32.DTYPE)) {\n-          try (Tensor<TInt32> tensorResult =\n-              session.runner().fetch(dims).run().get(0).expect(TInt32.DTYPE)) {\n-            tensorResult.data().scalars().forEach(s -> result.add((long) s.getInt()));\n-          }\n-        } else if (dType.equals(TInt64.DTYPE)) {\n-          try (Tensor<TInt64> tensorResult =\n-              session.runner().fetch(dims).run().get(0).expect(TInt64.DTYPE)) {\n-            tensorResult.data().scalars().forEach(s -> result.add(s.getLong()));\n-          }\n-        } else if (dType.equals(TUint8.DTYPE)) {\n-          try (Tensor<TUint8> tensorResult =\n-              session.runner().fetch(dims).run().get(0).expect(TUint8.DTYPE)) {\n-            tensorResult.data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n-          }\n-        } else { // shouldn't happen\n-          throw new IllegalArgumentException(\"the data type must be an integer type\");\n-        }\n-      }\n+      return getLongArray(dims.asTensor());\n+    }\n+    try (Session session = new Session((Graph)scope.env());\n+        Tensor tensor = session.runner().fetch(dims).run().get(0)) {\n+      return getLongArray(tensor);\n     }\n-    return result.stream().mapToLong(i -> i).toArray();\n   }\n \n   /**\n-   * Gets the shape for the data within a Tensor\n+   * Converts a TInt32 or TInt64 to a java long array\n    *\n-   * @param tensor the tensor\n-   * @return the Shape of the tensor's data;\n+   * @param scope the TensorFlow scope\n+   * @param dims the dimension tensor\n+   * @param <T> the type of the dimensions, must either be TInt32 or TInt64 type\n+   * @return the long array\n+   * @throws java.lang.IllegalArgumentException if the dims type is not an integer\n    */\n-  public static <T extends TNumber> Shape getShape(Tensor<T> tensor) {\n-    NdArray<?> data = (NdArray<?>) tensor.data();\n-    return data.shape();\n+  public static long[] getLongArray(Tensor dims) {\n+    List<Long> result = new ArrayList<>();\n+    if (dims instanceof TInt32) {\n+      ((TInt32)dims).scalars().forEach(s -> result.add((long) s.getInt()));\n+    } else if (dims instanceof TInt64) {\n+      ((TInt64)dims).scalars().forEach(s -> result.add(s.getLong()));\n+    } else if (dims instanceof TUint8) {\n+      ((TUint8)dims).scalars().forEach(s -> result.add(s.getObject().longValue()));\n+      } else { // shouldn't happen", "originalCommit": "0225ab65e737ee3cccc4dcd61683779f0f8312ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0NzIyNQ==", "url": "https://github.com/tensorflow/java/pull/160#discussion_r539347225", "bodyText": "TIntegral is also planned, I was keeping this for another PR as well, as there is more functions in the framework that will need to be updated.", "author": "karllessard", "createdAt": "2020-12-09T14:23:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2ODgwNQ=="}], "type": "inlineReview"}, {"oid": "598fdc3e556ff4f3b57bb24ad89500e7fcc6bf63", "url": "https://github.com/tensorflow/java/commit/598fdc3e556ff4f3b57bb24ad89500e7fcc6bf63", "message": "Rectify documentation based on PR review", "committedDate": "2020-12-13T04:02:53Z", "type": "forcePushed"}, {"oid": "2576e35752ae11dbb060ef05042b08df1460df26", "url": "https://github.com/tensorflow/java/commit/2576e35752ae11dbb060ef05042b08df1460df26", "message": "Merge TType and Tensor instances as a single entity", "committedDate": "2020-12-13T16:28:56Z", "type": "commit"}, {"oid": "88e9a2166399a39bcbd5917af52dd9f32a495c17", "url": "https://github.com/tensorflow/java/commit/88e9a2166399a39bcbd5917af52dd9f32a495c17", "message": "Rectify documentation based on PR review", "committedDate": "2020-12-13T16:28:57Z", "type": "commit"}, {"oid": "8773ccc1981e4bc934af4031258df6a41a460a09", "url": "https://github.com/tensorflow/java/commit/8773ccc1981e4bc934af4031258df6a41a460a09", "message": "Rebase on master", "committedDate": "2020-12-13T21:00:13Z", "type": "commit"}, {"oid": "8773ccc1981e4bc934af4031258df6a41a460a09", "url": "https://github.com/tensorflow/java/commit/8773ccc1981e4bc934af4031258df6a41a460a09", "message": "Rebase on master", "committedDate": "2020-12-13T21:00:13Z", "type": "forcePushed"}]}