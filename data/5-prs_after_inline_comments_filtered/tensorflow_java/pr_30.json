{"pr_number": 30, "pr_title": "TF Data API for Java", "pr_createdAt": "2020-03-06T04:24:20Z", "pr_url": "https://github.com/tensorflow/java/pull/30", "timeline": [{"oid": "fca73ff129ca67a9f920bac64b5e9e34301c4e08", "url": "https://github.com/tensorflow/java/commit/fca73ff129ca67a9f920bac64b5e9e34301c4e08", "message": "TensorFlow Data examples with batching working in graph / eager mode", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "bb6cec22afd48c8ab7f84175d26b7b3f6d424fcc", "url": "https://github.com/tensorflow/java/commit/bb6cec22afd48c8ab7f84175d26b7b3f6d424fcc", "message": "Add repeat() method to Session", "committedDate": "2020-04-29T15:49:02Z", "type": "commit"}, {"oid": "4ebbaf2a6ac28636e82b1253d564bd4b9af7184d", "url": "https://github.com/tensorflow/java/commit/4ebbaf2a6ac28636e82b1253d564bd4b9af7184d", "message": "update readme with stream dataset iteration", "committedDate": "2020-04-29T15:49:02Z", "type": "commit"}, {"oid": "23f6ba3b4d95e1aca7e32a08d93b20a89d2711a9", "url": "https://github.com/tensorflow/java/commit/23f6ba3b4d95e1aca7e32a08d93b20a89d2711a9", "message": "Merge optimizers and datasets into tensorflow-framework", "committedDate": "2020-04-29T15:49:02Z", "type": "commit"}, {"oid": "d3d8d482325f8a0af17ece4722c4564caf74ba06", "url": "https://github.com/tensorflow/java/commit/d3d8d482325f8a0af17ece4722c4564caf74ba06", "message": "Add TensorFlow Exceptions, map to these from TF Statuses in tensorflow-core", "committedDate": "2020-04-29T15:49:03Z", "type": "commit"}, {"oid": "b9683c63d3afd6ce8aefc545fb09ff0242190953", "url": "https://github.com/tensorflow/java/commit/b9683c63d3afd6ce8aefc545fb09ff0242190953", "message": "Fix tests to use new exceptions from tensorflow-core", "committedDate": "2020-04-29T15:49:03Z", "type": "commit"}, {"oid": "e4afc6868f8afd3c03a2dd641206290c33f79ba3", "url": "https://github.com/tensorflow/java/commit/e4afc6868f8afd3c03a2dd641206290c33f79ba3", "message": "revert tensorflow-data readme", "committedDate": "2020-04-29T15:49:03Z", "type": "commit"}, {"oid": "70af76874119ffa5560aedd234d4a267b657d226", "url": "https://github.com/tensorflow/java/commit/70af76874119ffa5560aedd234d4a267b657d226", "message": "Update tensorflow-data.md", "committedDate": "2020-04-29T15:49:03Z", "type": "commit"}, {"oid": "104b81b1e9503c80199510df8dfe6c52b2d8aa51", "url": "https://github.com/tensorflow/java/commit/104b81b1e9503c80199510df8dfe6c52b2d8aa51", "message": "Update tensorflow-data.md", "committedDate": "2020-04-29T15:49:03Z", "type": "commit"}, {"oid": "14288add601db18f2f99b65eba5f004fffc99c3b", "url": "https://github.com/tensorflow/java/commit/14288add601db18f2f99b65eba5f004fffc99c3b", "message": ":wqremove unnecessary files, add copyrights, format with google java style, update documentation", "committedDate": "2020-04-29T15:49:20Z", "type": "commit"}, {"oid": "17cfcf46649ba1826205933bf27b6c6f82c5ab38", "url": "https://github.com/tensorflow/java/commit/17cfcf46649ba1826205933bf27b6c6f82c5ab38", "message": "Convert batches from List<Output<?>> to List<Operand<?>>", "committedDate": "2020-04-29T15:49:20Z", "type": "commit"}, {"oid": "8f6cfeff5f522465dbb9e23a63e242850737000a", "url": "https://github.com/tensorflow/java/commit/8f6cfeff5f522465dbb9e23a63e242850737000a", "message": "Fix copyright authors, add Shape.prepend(), fix pom.xml, revert Session", "committedDate": "2020-04-29T16:12:12Z", "type": "forcePushed"}, {"oid": "69f921d6c90b128a7790dc3860ec95551dbfeb51", "url": "https://github.com/tensorflow/java/commit/69f921d6c90b128a7790dc3860ec95551dbfeb51", "message": "Fix copyright authors, add Shape.prepend(), fix pom.xml, revert Session", "committedDate": "2020-04-29T17:16:24Z", "type": "commit"}, {"oid": "69f921d6c90b128a7790dc3860ec95551dbfeb51", "url": "https://github.com/tensorflow/java/commit/69f921d6c90b128a7790dc3860ec95551dbfeb51", "message": "Fix copyright authors, add Shape.prepend(), fix pom.xml, revert Session", "committedDate": "2020-04-29T17:16:24Z", "type": "forcePushed"}, {"oid": "eb61e2fcb3fb2d8f282d7f00885bed2db8fac6e0", "url": "https://github.com/tensorflow/java/commit/eb61e2fcb3fb2d8f282d7f00885bed2db8fac6e0", "message": "remove * imports from session", "committedDate": "2020-04-29T17:33:27Z", "type": "commit"}, {"oid": "28add779d43b5bf641bc6b7a87bcdc544dcddd4f", "url": "https://github.com/tensorflow/java/commit/28add779d43b5bf641bc6b7a87bcdc544dcddd4f", "message": "extend from java.lang exceptions", "committedDate": "2020-04-30T21:36:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY5NTM5NQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r390695395", "bodyText": "Maybe \"... cast from output of .... to output of.... \"?", "author": "karllessard", "createdAt": "2020-03-11T01:08:51Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Output.java", "diffHunk": "@@ -52,6 +52,24 @@ public Shape shape() {\n     return (DataType<T>)operation.dtype(index);\n   }\n \n+    /**\n+   * Returns this Output object with the type {@code Output<U>}. This method is useful when given a\n+   * value of type {@code Output<?>}.\n+   *\n+   * @param dt any supported tensor data type\n+   * @throws IllegalArgumentException if the actual data type of this object does not match the type\n+   *     {@code U}.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public <U extends TType> Output<U> expect(DataType<U> dt) {\n+    if (!dt.equals(this.dataType())) {\n+      throw new IllegalArgumentException(\n+          \"Cannot cast from tensor of \" + this.dataType() + \" to tensor of \" + dt);", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwMDk5OA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r390700998", "bodyText": "Google Java Style Guide doesn't recommend the usage of wildcard imports (I personally think it is fine for static imports though)", "author": "karllessard", "createdAt": "2020-03-11T01:33:11Z", "path": "tensorflow-frameworks/tensorflow-data/src/main/java/org/tensorflow/data/Dataset.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.tensorflow.data;\r\n+\r\n+import org.tensorflow.*;\r\n+import org.tensorflow.data.impl.*;\r", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgyNzM1Ng==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r407827356", "bodyText": "I removed all the wildcard imports.", "author": "dhruvrajan", "createdAt": "2020-04-14T02:23:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwMDk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwMTE5OA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r390701198", "bodyText": "no need of else if you throw in the previous block", "author": "karllessard", "createdAt": "2020-03-11T01:34:05Z", "path": "tensorflow-frameworks/tensorflow-data/src/main/java/org/tensorflow/data/Dataset.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.tensorflow.data;\r\n+\r\n+import org.tensorflow.*;\r\n+import org.tensorflow.data.impl.*;\r\n+import org.tensorflow.op.Ops;\r\n+import org.tensorflow.op.data.AnonymousIterator;\r\n+import org.tensorflow.op.data.MakeIterator;\r\n+import org.tensorflow.tools.Shape;\r\n+import org.tensorflow.utils.Tuple2;\r\n+\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.stream.Collectors;\r\n+\r\n+/**\r\n+ * Represents a potentially large list of independent elements (samples), and\r\n+ * allows iteration and transformations to be performed across these elements.\r\n+ */\r\n+public abstract class Dataset implements Iterable<List<Output<?>>> {\r\n+  protected Ops tf;\r\n+  private List<DataType<?>> outputTypes;\r\n+  private List<Shape> outputShapes;\r\n+\r\n+  public Dataset(Ops tf, List<DataType<?>> outputTypes, List<Shape> outputShapes) {\r\n+    if (Objects.isNull(tf)) {\r\n+      throw new IllegalArgumentException(\"Ops accessor cannot be null.\");\r\n+    } else if (outputTypes.size() != outputShapes.size()) {\r", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgyODY0NA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r407828644", "bodyText": "updated!", "author": "dhruvrajan", "createdAt": "2020-04-14T02:28:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwMTE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwMTQ4MA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r390701480", "bodyText": "Are there benefits to use Objects.isNull if it is not as a filter predicate, instead of just tf == null?", "author": "karllessard", "createdAt": "2020-03-11T01:35:34Z", "path": "tensorflow-frameworks/tensorflow-data/src/main/java/org/tensorflow/data/Dataset.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.tensorflow.data;\r\n+\r\n+import org.tensorflow.*;\r\n+import org.tensorflow.data.impl.*;\r\n+import org.tensorflow.op.Ops;\r\n+import org.tensorflow.op.data.AnonymousIterator;\r\n+import org.tensorflow.op.data.MakeIterator;\r\n+import org.tensorflow.tools.Shape;\r\n+import org.tensorflow.utils.Tuple2;\r\n+\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.stream.Collectors;\r\n+\r\n+/**\r\n+ * Represents a potentially large list of independent elements (samples), and\r\n+ * allows iteration and transformations to be performed across these elements.\r\n+ */\r\n+public abstract class Dataset implements Iterable<List<Output<?>>> {\r\n+  protected Ops tf;\r\n+  private List<DataType<?>> outputTypes;\r\n+  private List<Shape> outputShapes;\r\n+\r\n+  public Dataset(Ops tf, List<DataType<?>> outputTypes, List<Shape> outputShapes) {\r\n+    if (Objects.isNull(tf)) {\r", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA0MDQ4Mg==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r393040482", "bodyText": "I think it was added to the JDK to exist as a method reference for a null check (so people didn't have to make a lambda), not sure if it has any optimization benefits (probably not as if it's not inlined then it will be more expensive).", "author": "Craigacp", "createdAt": "2020-03-16T13:57:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwMTQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk0MDgwOQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r410940809", "bodyText": "Using == null here. There's no benefits, the implementation of isNull calls == null.", "author": "dhruvrajan", "createdAt": "2020-04-19T16:27:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwMTQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwNTUxMw==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r390705513", "bodyText": "Maybe we could add a isEager() method in ExecutionEnvironment to avoid these instanceof", "author": "karllessard", "createdAt": "2020-03-11T01:53:03Z", "path": "tensorflow-frameworks/tensorflow-data/src/main/java/org/tensorflow/data/Dataset.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.tensorflow.data;\r\n+\r\n+import org.tensorflow.*;\r\n+import org.tensorflow.data.impl.*;\r\n+import org.tensorflow.op.Ops;\r\n+import org.tensorflow.op.data.AnonymousIterator;\r\n+import org.tensorflow.op.data.MakeIterator;\r\n+import org.tensorflow.tools.Shape;\r\n+import org.tensorflow.utils.Tuple2;\r\n+\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.stream.Collectors;\r\n+\r\n+/**\r\n+ * Represents a potentially large list of independent elements (samples), and\r\n+ * allows iteration and transformations to be performed across these elements.\r\n+ */\r\n+public abstract class Dataset implements Iterable<List<Output<?>>> {\r\n+  protected Ops tf;\r\n+  private List<DataType<?>> outputTypes;\r\n+  private List<Shape> outputShapes;\r\n+\r\n+  public Dataset(Ops tf, List<DataType<?>> outputTypes, List<Shape> outputShapes) {\r\n+    if (Objects.isNull(tf)) {\r\n+      throw new IllegalArgumentException(\"Ops accessor cannot be null.\");\r\n+    } else if (outputTypes.size() != outputShapes.size()) {\r\n+      throw new IllegalArgumentException(\"`outputTypes` and `outputShapes` must have the same size.\");\r\n+    }\r\n+\r\n+    this.tf = tf;\r\n+    this.outputTypes = outputTypes;\r\n+    this.outputShapes = outputShapes;\r\n+  }\r\n+\r\n+  /**\r\n+   * Groups elements of this dataset into batches.\r\n+   *\r\n+   * @param batchSize     The number of desired elements per batch\r\n+   * @param dropLastBatch Whether to leave out the final batch if it has fewer\r\n+   *                      than `batchSize` elements.\r\n+   * @return A batched Dataset\r\n+   */\r\n+  public final Dataset batch(long batchSize, boolean dropLastBatch) {\r\n+    List<Shape> batchOutputShapes = getOutputShapes().stream()\r\n+        .map(s -> Shape.of(Utils.array(batchSize, s.asArray())))\r\n+        .collect(Collectors.toList());\r\n+    return new BatchDataset(tf, this.getVariant(), tf.val(batchSize),\r\n+        tf.val(dropLastBatch), this.getOutputTypes(), batchOutputShapes);\r\n+  }\r\n+\r\n+  /**\r\n+   * Groups elements of this dataset into batches.\r\n+   * Leaves out the last batch if it has fewer than `batchSize` elements.\r\n+   *\r\n+   * @param batchSize The number of desired elements per batch\r\n+   * @return A batched Dataset\r\n+   */\r\n+  public final Dataset batch(long batchSize) {\r\n+    return batch(batchSize, true);\r\n+  }\r\n+\r\n+  /**\r\n+   * Creates new `Dataset` skips `count` initial elements from this dataset\r\n+   *\r\n+   * @param count The number of elements to `skip` to form the new dataset.\r\n+   * @return A new Dataset with `count` elements removed.\r\n+   */\r\n+  public final Dataset skip(long count) {\r\n+    return new SkipDataset(tf, this.getVariant(), tf.val(count), this.getOutputTypes(), this.getOutputShapes());\r\n+  }\r\n+\r\n+  /**\r\n+   * Creates new `Dataset` with the first `count` elements from this dataset.\r\n+   *\r\n+   * @param count The number of elements to \"take\" from this dataset.\r\n+   * @return A new Dataset containing the first `count` elements from this dataset.\r\n+   */\r\n+  public final Dataset take(long count) {\r\n+    return new TakeDataset(tf, this.getVariant(), tf.val(count), this.getOutputTypes(), this.getOutputShapes());\r\n+  }\r\n+\r\n+  /**\r\n+   * Creates an iterator which iterates through all batches of this Dataset in an eager fashion.\r\n+   * Each batch is a list of components, returned as `Output` objects.\r\n+   * <p>\r\n+   * This method enables for-each iteration through batches when running\r\n+   * in eager mode. For Graph mode batch iteration, see `makeOneShotIterator`.\r\n+   *\r\n+   * @return an Iterator through batches of this dataset.\r\n+   */\r\n+  @Override\r\n+  public Iterator<List<Output<?>>> iterator() {\r\n+\r\n+    if (!(tf.scope().env() instanceof EagerSession)) {\r", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAyNDI4NQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r393024285", "bodyText": "Do we expect there to be more environments in the future? Maybe an enum that's returned from sessionType?", "author": "Craigacp", "createdAt": "2020-03-16T13:32:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwNTUxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA1NzAwNg==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r394057006", "bodyText": "I suspect that there will always be only these two but who knows what will come out of those Google Brains in the future, so I'm ok with an enum too.", "author": "karllessard", "createdAt": "2020-03-18T01:20:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwNTUxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgzMTI5OQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r407831299", "bodyText": "I added isEager() and isGraph() methods to the ExecutionEnvironment interface, using an enum.", "author": "dhruvrajan", "createdAt": "2020-04-14T02:38:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwNTUxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwNjE3Mg==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r390706172", "bodyText": "Method return type as Dataset instead, to preserve the abstraction?", "author": "karllessard", "createdAt": "2020-03-11T01:55:49Z", "path": "tensorflow-frameworks/tensorflow-data/src/main/java/org/tensorflow/data/Dataset.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.tensorflow.data;\r\n+\r\n+import org.tensorflow.*;\r\n+import org.tensorflow.data.impl.*;\r\n+import org.tensorflow.op.Ops;\r\n+import org.tensorflow.op.data.AnonymousIterator;\r\n+import org.tensorflow.op.data.MakeIterator;\r\n+import org.tensorflow.tools.Shape;\r\n+import org.tensorflow.utils.Tuple2;\r\n+\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.stream.Collectors;\r\n+\r\n+/**\r\n+ * Represents a potentially large list of independent elements (samples), and\r\n+ * allows iteration and transformations to be performed across these elements.\r\n+ */\r\n+public abstract class Dataset implements Iterable<List<Output<?>>> {\r\n+  protected Ops tf;\r\n+  private List<DataType<?>> outputTypes;\r\n+  private List<Shape> outputShapes;\r\n+\r\n+  public Dataset(Ops tf, List<DataType<?>> outputTypes, List<Shape> outputShapes) {\r\n+    if (Objects.isNull(tf)) {\r\n+      throw new IllegalArgumentException(\"Ops accessor cannot be null.\");\r\n+    } else if (outputTypes.size() != outputShapes.size()) {\r\n+      throw new IllegalArgumentException(\"`outputTypes` and `outputShapes` must have the same size.\");\r\n+    }\r\n+\r\n+    this.tf = tf;\r\n+    this.outputTypes = outputTypes;\r\n+    this.outputShapes = outputShapes;\r\n+  }\r\n+\r\n+  /**\r\n+   * Groups elements of this dataset into batches.\r\n+   *\r\n+   * @param batchSize     The number of desired elements per batch\r\n+   * @param dropLastBatch Whether to leave out the final batch if it has fewer\r\n+   *                      than `batchSize` elements.\r\n+   * @return A batched Dataset\r\n+   */\r\n+  public final Dataset batch(long batchSize, boolean dropLastBatch) {\r\n+    List<Shape> batchOutputShapes = getOutputShapes().stream()\r\n+        .map(s -> Shape.of(Utils.array(batchSize, s.asArray())))\r\n+        .collect(Collectors.toList());\r\n+    return new BatchDataset(tf, this.getVariant(), tf.val(batchSize),\r\n+        tf.val(dropLastBatch), this.getOutputTypes(), batchOutputShapes);\r\n+  }\r\n+\r\n+  /**\r\n+   * Groups elements of this dataset into batches.\r\n+   * Leaves out the last batch if it has fewer than `batchSize` elements.\r\n+   *\r\n+   * @param batchSize The number of desired elements per batch\r\n+   * @return A batched Dataset\r\n+   */\r\n+  public final Dataset batch(long batchSize) {\r\n+    return batch(batchSize, true);\r\n+  }\r\n+\r\n+  /**\r\n+   * Creates new `Dataset` skips `count` initial elements from this dataset\r\n+   *\r\n+   * @param count The number of elements to `skip` to form the new dataset.\r\n+   * @return A new Dataset with `count` elements removed.\r\n+   */\r\n+  public final Dataset skip(long count) {\r\n+    return new SkipDataset(tf, this.getVariant(), tf.val(count), this.getOutputTypes(), this.getOutputShapes());\r\n+  }\r\n+\r\n+  /**\r\n+   * Creates new `Dataset` with the first `count` elements from this dataset.\r\n+   *\r\n+   * @param count The number of elements to \"take\" from this dataset.\r\n+   * @return A new Dataset containing the first `count` elements from this dataset.\r\n+   */\r\n+  public final Dataset take(long count) {\r\n+    return new TakeDataset(tf, this.getVariant(), tf.val(count), this.getOutputTypes(), this.getOutputShapes());\r\n+  }\r\n+\r\n+  /**\r\n+   * Creates an iterator which iterates through all batches of this Dataset in an eager fashion.\r\n+   * Each batch is a list of components, returned as `Output` objects.\r\n+   * <p>\r\n+   * This method enables for-each iteration through batches when running\r\n+   * in eager mode. For Graph mode batch iteration, see `makeOneShotIterator`.\r\n+   *\r\n+   * @return an Iterator through batches of this dataset.\r\n+   */\r\n+  @Override\r\n+  public Iterator<List<Output<?>>> iterator() {\r\n+\r\n+    if (!(tf.scope().env() instanceof EagerSession)) {\r\n+      throw new UnsupportedOperationException(\"Cannot iterate through a dataset in graph mode.\");\r\n+    }\r\n+\r\n+    Operand<?> dataset = getVariant();\r\n+    AnonymousIterator anonymousIterator = tf.data.anonymousIterator(getOutputTypes(), getOutputShapes());\r\n+\r\n+    tf.data.makeIterator(dataset, anonymousIterator.handle());\r\n+\r\n+    return new Iterator<List<Output<?>>>() {\r\n+      private List<Output<?>> tryNext = getNext();\r\n+\r\n+      private List<Output<?>> getNext() {\r\n+        try {\r\n+          return tf.data.iteratorGetNext(anonymousIterator.handle(), getOutputTypes(), getOutputShapes()).components();\r\n+        } catch (IndexOutOfBoundsException e) {\r\n+          return null;\r\n+        }\r\n+      }\r\n+\r\n+      @Override\r\n+      public boolean hasNext() {\r\n+        return tryNext != null;\r\n+      }\r\n+\r\n+      @Override\r\n+      public List<Output<?>> next() {\r\n+        List<Output<?>> result = tryNext;\r\n+        tryNext = getNext();\r\n+        return result;\r\n+      }\r\n+    };\r\n+  }\r\n+\r\n+  /**\r\n+   * Return the necessary components to iterate through batches of this\r\n+   * dataset in Graph mode.\r\n+   * <p>\r\n+   * This method returns a Pair whose first element is a MakeIterator operation\r\n+   * that must be run first in its own session to create the iterator internally.\r\n+   * <p>\r\n+   * The second element in the pair is a list of Output objects. In sequential\r\n+   * calls to session.run() in which these (or child) nodes are fetched, the batches\r\n+   * are already loaded into these objects.\r\n+   *\r\n+   * @return A Pair whose first element is a MakeIterator Operation, and whose\r\n+   * second element is a list batch components.\r\n+   */\r\n+  public OneShotIterator makeOneShotIterator() {\r\n+    if (!(tf.scope().env() instanceof Graph)) {\r\n+      throw new UnsupportedOperationException(\"OneShotIterator should only be used in Graph mode.\");\r\n+    }\r\n+    List<DataType<?>> outputTypes = getOutputTypes();\r\n+    List<Shape> outputShapes = getOutputShapes();\r\n+    Operand<?> iterator = tf.data.iterator(\"null\", \"null\", outputTypes, outputShapes);\r\n+\r\n+    MakeIterator makeIterator = tf.data.makeIterator(getVariant(), iterator);\r\n+    List<Output<?>> components = tf.data.iteratorGetNext(iterator, outputTypes, outputShapes).components();\r\n+\r\n+    return new OneShotIterator(makeIterator, components);\r\n+  }\r\n+\r\n+  public static TensorSliceDataset fromTensorSlices(Ops tf, List<Operand<?>> slices, List<DataType<?>> outputTypes) {\r", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0MjA0NQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r405642045", "bodyText": "Thanks, I updated this!", "author": "dhruvrajan", "createdAt": "2020-04-08T16:09:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwNjE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwNzMwMg==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r390707302", "bodyText": "Maybe we can move this class as a @Operator available in Ops? e.g. tf.data.oneShotIterator(makeIterator, components)? I understand we don't have access to this op because  it uses a func attribute but that could replace it?", "author": "karllessard", "createdAt": "2020-03-11T02:00:03Z", "path": "tensorflow-frameworks/tensorflow-data/src/main/java/org/tensorflow/data/OneShotIterator.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package org.tensorflow.data;\n+\n+import org.tensorflow.Operation;\n+import org.tensorflow.Output;\n+import org.tensorflow.op.data.MakeIterator;\n+\n+import java.util.List;\n+\n+public class OneShotIterator {", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0MjgzOA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r405642838", "bodyText": "I refactored the iteration mechanisms to capture both eager and graph iteration in DatasetIterator; I think the new logic is much cleaner (See the README / RFC)", "author": "dhruvrajan", "createdAt": "2020-04-08T16:10:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwNzMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwNzgxNg==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r390707816", "bodyText": "It would be worth it to check which of the following utilities could be added directly to the Shape class instead.\nFor example, array(...) could be replaced by something like shape.extend(batchSize, 0), where 0 is the dimension index", "author": "karllessard", "createdAt": "2020-03-11T02:02:16Z", "path": "tensorflow-frameworks/tensorflow-data/src/main/java/org/tensorflow/data/Utils.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package org.tensorflow.data;\r\n+\r\n+import org.tensorflow.tools.Shape;\r\n+\r\n+public class Utils {\r", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzExMzUzNw==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r407113537", "bodyText": "That makes sense; I removed this class, and added Shape.head() and Shape.tail() to the Shape class, and a new constructor for Shape(int, int[]).", "author": "dhruvrajan", "createdAt": "2020-04-11T21:36:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwNzgxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwODQ2Nw==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r390708467", "bodyText": "That could be replaced by Arrays.copyOfRange(shape.asArray(), 1, shape.numDimensions)", "author": "karllessard", "createdAt": "2020-03-11T02:05:13Z", "path": "tensorflow-frameworks/tensorflow-data/src/main/java/org/tensorflow/data/Utils.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package org.tensorflow.data;\r\n+\r\n+import org.tensorflow.tools.Shape;\r\n+\r\n+public class Utils {\r\n+\r\n+    private static Shape head(Shape shape) {\r\n+        return Shape.of(shape.size(0));\r\n+    }\r\n+\r\n+    public static Shape tail(Shape shape) {\r\n+        long[] tail = new long[shape.numDimensions() - 1];\r\n+        for (int i = 1; i < shape.numDimensions(); i++) {\r\n+            tail[i - 1] = shape.size(i);\r\n+        }\r", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk0MTI4OQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r410941289", "bodyText": "Yup, I'm using copyOfRange in the Shape.tail implementation.", "author": "dhruvrajan", "createdAt": "2020-04-19T16:30:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwODQ2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwODUyMQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r390708521", "bodyText": "that could be replaced simply by shape.asArray(), unless you need a copy, which Arrays.copyOf can provide you", "author": "karllessard", "createdAt": "2020-03-11T02:05:29Z", "path": "tensorflow-frameworks/tensorflow-data/src/main/java/org/tensorflow/data/Utils.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package org.tensorflow.data;\r\n+\r\n+import org.tensorflow.tools.Shape;\r\n+\r\n+public class Utils {\r\n+\r\n+    private static Shape head(Shape shape) {\r\n+        return Shape.of(shape.size(0));\r\n+    }\r\n+\r\n+    public static Shape tail(Shape shape) {\r\n+        long[] tail = new long[shape.numDimensions() - 1];\r\n+        for (int i = 1; i < shape.numDimensions(); i++) {\r\n+            tail[i - 1] = shape.size(i);\r\n+        }\r\n+\r\n+        return Shape.of(tail);\r\n+    }\r\n+\r\n+    public static long[] shapeArray(Shape shape) {\r\n+        long[] arr = new long[shape.numDimensions()];\r\n+        for (int i = 0; i < arr.length; i++) {\r\n+            arr[i] = shape.size(i);\r\n+        }\r\n+        return arr;\r", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwOTcwNQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r390709705", "bodyText": "I don't know how tf.data.batchDataset works but I find it strange that we need to add the batchSize as a new dimension for all individual shapes. Just saying in case this is a mistake", "author": "karllessard", "createdAt": "2020-03-11T02:10:23Z", "path": "tensorflow-frameworks/tensorflow-data/src/main/java/org/tensorflow/data/Dataset.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.tensorflow.data;\r\n+\r\n+import org.tensorflow.*;\r\n+import org.tensorflow.data.impl.*;\r\n+import org.tensorflow.op.Ops;\r\n+import org.tensorflow.op.data.AnonymousIterator;\r\n+import org.tensorflow.op.data.MakeIterator;\r\n+import org.tensorflow.tools.Shape;\r\n+import org.tensorflow.utils.Tuple2;\r\n+\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.stream.Collectors;\r\n+\r\n+/**\r\n+ * Represents a potentially large list of independent elements (samples), and\r\n+ * allows iteration and transformations to be performed across these elements.\r\n+ */\r\n+public abstract class Dataset implements Iterable<List<Output<?>>> {\r\n+  protected Ops tf;\r\n+  private List<DataType<?>> outputTypes;\r\n+  private List<Shape> outputShapes;\r\n+\r\n+  public Dataset(Ops tf, List<DataType<?>> outputTypes, List<Shape> outputShapes) {\r\n+    if (Objects.isNull(tf)) {\r\n+      throw new IllegalArgumentException(\"Ops accessor cannot be null.\");\r\n+    } else if (outputTypes.size() != outputShapes.size()) {\r\n+      throw new IllegalArgumentException(\"`outputTypes` and `outputShapes` must have the same size.\");\r\n+    }\r\n+\r\n+    this.tf = tf;\r\n+    this.outputTypes = outputTypes;\r\n+    this.outputShapes = outputShapes;\r\n+  }\r\n+\r\n+  /**\r\n+   * Groups elements of this dataset into batches.\r\n+   *\r\n+   * @param batchSize     The number of desired elements per batch\r\n+   * @param dropLastBatch Whether to leave out the final batch if it has fewer\r\n+   *                      than `batchSize` elements.\r\n+   * @return A batched Dataset\r\n+   */\r\n+  public final Dataset batch(long batchSize, boolean dropLastBatch) {\r\n+    List<Shape> batchOutputShapes = getOutputShapes().stream()\r\n+        .map(s -> Shape.of(Utils.array(batchSize, s.asArray())))\r\n+        .collect(Collectors.toList());\r", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk0MTQ5MQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r410941491", "bodyText": "This isn't a mistake, it does seem to be needed here, since it's the outputShapes that need to be specified.", "author": "dhruvrajan", "createdAt": "2020-04-19T16:31:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwOTcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxMTkxNg==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r390711916", "bodyText": "Why do we need to remove the first dimension of each tensor shapes?", "author": "karllessard", "createdAt": "2020-03-11T02:19:24Z", "path": "tensorflow-frameworks/tensorflow-data/src/main/java/org/tensorflow/data/impl/TensorSliceDataset.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package org.tensorflow.data.impl;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.data.Dataset;\n+import org.tensorflow.data.Utils;\n+import org.tensorflow.op.Ops;\n+\n+public class TensorSliceDataset extends Dataset {\n+  private org.tensorflow.op.data.TensorSliceDataset dataset;\n+\n+  public TensorSliceDataset(Ops tf, List<Operand<?>> components, List<DataType<?>> outputTypes) {\n+    super(tf, outputTypes,\n+        components.stream()\n+            .map(c -> Utils.tail(c.asOutput().shape()))", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk0MTc5NQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r410941795", "bodyText": "The outputSize is supposed to be the size for the returned elements from the dataset. in a standard 2-D TensorSliceDataset, for example, it's the \"length of each vector\" that counts as the element shape, not the \"number of vectors\"", "author": "dhruvrajan", "createdAt": "2020-04-19T16:33:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxMTkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxMjY5MQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r390712691", "bodyText": "testMatrix1 and testMatrix2 can be of the type IntNdArray that you initialize with: StdArrays.copyOf(new int[][]{ ... })", "author": "karllessard", "createdAt": "2020-03-11T02:22:44Z", "path": "tensorflow-frameworks/tensorflow-data/src/test/java/org/tensorflow/data/DatasetTestBase.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.tensorflow.data;\n+import org.junit.Before;\n+import org.tensorflow.Tensor;\n+import org.tensorflow.types.TInt32;\n+\n+import java.nio.IntBuffer;\n+\n+public class DatasetTestBase {\n+  int[][] testMatrix1;\n+  int[][] testMatrix2;\n+\n+\n+  @Before\n+  public void setUp() {\n+    testMatrix1 = new int[][]{\n+        {1, 2, 3, 4, 5},\n+        {2, 4, 6, 8, 10},\n+        {3, 6, 8, 12, 15},\n+        {4, 8, 12, 16, 20}\n+    };\n+\n+    testMatrix2 = new int[][]{\n+        {1}, {0}, {1}, {1}\n+    };", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzExMzY2NA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r407113664", "bodyText": "Yup, I updated these!", "author": "dhruvrajan", "createdAt": "2020-04-11T21:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxMjY5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxMzI0MQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r390713241", "bodyText": "Use intTensor.data() here to return the tensor as a TInt32/IntNdArray directly", "author": "karllessard", "createdAt": "2020-03-11T02:25:00Z", "path": "tensorflow-frameworks/tensorflow-data/src/test/java/org/tensorflow/data/DatasetTestBase.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.tensorflow.data;\n+import org.junit.Before;\n+import org.tensorflow.Tensor;\n+import org.tensorflow.types.TInt32;\n+\n+import java.nio.IntBuffer;\n+\n+public class DatasetTestBase {\n+  int[][] testMatrix1;\n+  int[][] testMatrix2;\n+\n+\n+  @Before\n+  public void setUp() {\n+    testMatrix1 = new int[][]{\n+        {1, 2, 3, 4, 5},\n+        {2, 4, 6, 8, 10},\n+        {3, 6, 8, 12, 15},\n+        {4, 8, 12, 16, 20}\n+    };\n+\n+    testMatrix2 = new int[][]{\n+        {1}, {0}, {1}, {1}\n+    };\n+  }\n+\n+  static int[] concat(int[] first, int[] second) {\n+    int[] concatenated = new int[first.length + second.length];\n+    System.arraycopy(first, 0, concatenated, 0, first.length);\n+    System.arraycopy(second, 0, concatenated, first.length, second.length);\n+    return concatenated;\n+  }\n+\n+  static int[] getIntTensorAsArray(Tensor<TInt32> intTensor) {\n+    IntBuffer buffer = IntBuffer.allocate((int) intTensor.shape().size());\n+    intTensor.writeTo(buffer);\n+    return buffer.array();", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzExMzY4OA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r407113688", "bodyText": "I removed that method, and updated the tests!", "author": "dhruvrajan", "createdAt": "2020-04-11T21:38:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxMzI0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxMzQ5Mg==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r390713492", "bodyText": "As said before, tensors must be released with try-with-resources blocks", "author": "karllessard", "createdAt": "2020-03-11T02:25:52Z", "path": "tensorflow-frameworks/tensorflow-data/src/test/java/org/tensorflow/data/BatchDatasetTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package org.tensorflow.data;\n+\n+import org.junit.Test;\n+import org.tensorflow.Output;\n+import org.tensorflow.Tensor;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.TInt32;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+public class BatchDatasetTest extends DatasetTestBase {\n+\n+  @Test\n+  public void testEagerBatchDataset() {\n+    Ops tf = Ops.create();\n+\n+    // EVEN BATCH SIZES\n+    Dataset dataset = Dataset\n+        .fromTensorSlices(tf,\n+            Arrays.asList(\n+                tf.val(testMatrix1),\n+                tf.val(testMatrix2)),\n+            Arrays.asList(TInt32.DTYPE, TInt32.DTYPE))\n+        .batch(2);\n+\n+    int count = 0;\n+\n+    for (List<Output<?>> components : dataset) {\n+      Tensor<TInt32> batch1 = components.get(0).tensor().expect(TInt32.DTYPE);\n+      Tensor<TInt32> batch2 = components.get(1).tensor().expect(TInt32.DTYPE);", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzExMzcwNA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r407113704", "bodyText": "Thanks, updated!", "author": "dhruvrajan", "createdAt": "2020-04-11T21:38:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxMzQ5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNDAwMA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r390714000", "bodyText": "This PR will allow you to test equality of NdArray instances, if you make that change (see other comments)", "author": "karllessard", "createdAt": "2020-03-11T02:27:53Z", "path": "tensorflow-frameworks/tensorflow-data/src/test/java/org/tensorflow/data/BatchDatasetTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package org.tensorflow.data;\n+\n+import org.junit.Test;\n+import org.tensorflow.Output;\n+import org.tensorflow.Tensor;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.TInt32;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+public class BatchDatasetTest extends DatasetTestBase {\n+\n+  @Test\n+  public void testEagerBatchDataset() {\n+    Ops tf = Ops.create();\n+\n+    // EVEN BATCH SIZES\n+    Dataset dataset = Dataset\n+        .fromTensorSlices(tf,\n+            Arrays.asList(\n+                tf.val(testMatrix1),\n+                tf.val(testMatrix2)),\n+            Arrays.asList(TInt32.DTYPE, TInt32.DTYPE))\n+        .batch(2);\n+\n+    int count = 0;\n+\n+    for (List<Output<?>> components : dataset) {\n+      Tensor<TInt32> batch1 = components.get(0).tensor().expect(TInt32.DTYPE);\n+      Tensor<TInt32> batch2 = components.get(1).tensor().expect(TInt32.DTYPE);\n+\n+      assertArrayEquals(concat(testMatrix1[count], testMatrix1[count + 1]), getIntTensorAsArray(batch1));\n+      assertArrayEquals(concat(testMatrix2[count], testMatrix2[count + 1]), getIntTensorAsArray(batch2));", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0MzY5Mg==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r405643692", "bodyText": "Thanks Karl, I updated the tests to check for NdArray equality; it's much better now, that API works really well!", "author": "dhruvrajan", "createdAt": "2020-04-08T16:12:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNDAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNDQ1NA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r390714454", "bodyText": "In this PR again, I dropped the StaticApi class, so better not using it :) Meaning that would be NdArrays.ofInts(Shape.of(3, 4))\nBut everything in this class seems to test more tensorflow-tools functionalities than tensorflow-data, could we simply remove it? Or move it directly to tensorflow-tools if you think they are worth it.", "author": "karllessard", "createdAt": "2020-03-11T02:29:49Z", "path": "tensorflow-frameworks/tensorflow-data/src/test/java/org/tensorflow/data/DataInterfaceTester.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package org.tensorflow.data;\n+\n+import org.junit.Test;\n+import org.tensorflow.tools.ndarray.IntNdArray;\n+\n+import java.util.Arrays;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.tensorflow.tools.StaticApi.*;\n+\n+public class DataInterfaceTester {\n+  @Test\n+  public void testSomething() {\n+    IntNdArray matrix2d = ndArrayOfInts(shapeOf(3, 4));", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0Mzk1MA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r405643950", "bodyText": "I agree, I just removed it.", "author": "dhruvrajan", "createdAt": "2020-04-08T16:12:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNDQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNTE1OA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r390715158", "bodyText": "Are TensorSliceDataset, BatchDataset, etc. meant to be accessed directly or this is only for testing purposes?\nIf they are, then you'll probably want to move these out of the impl package", "author": "karllessard", "createdAt": "2020-03-11T02:32:53Z", "path": "tensorflow-frameworks/tensorflow-data/src/test/java/org/tensorflow/data/DatasetOpTester.java", "diffHunk": "@@ -0,0 +1,283 @@\n+package org.tensorflow.data;\n+\n+import org.junit.Test;\n+import org.tensorflow.*;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.op.core.Constant;\n+import org.tensorflow.op.data.*;\n+import org.tensorflow.tools.Shape;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.utils.Tuple2;\n+\n+import java.nio.IntBuffer;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class DatasetOpTester {\n+\n+  @Test\n+  public void testEagerBatching() {\n+    try (EagerSession session = EagerSession.create()) {\n+      Ops tf = Ops.create(session);\n+\n+      Constant<TInt32> X = tf.val(\n+          new int[][]{\n+              {1, 2, 3},\n+              {4, 5, 6},\n+              {7, 8, 9},\n+              {10, 11, 12}\n+          }\n+      );\n+\n+      Constant<TInt32> y = tf.val(\n+          new int[][]{\n+              {1},\n+              {4},\n+              {7},\n+              {10}\n+          }\n+      );\n+\n+\n+      List<Operand<?>> tensors = Arrays.asList(X, y);\n+\n+      // // Try running TensorDataset\n+      List<DataType<?>> outputTypes = Arrays.asList(TInt32.DTYPE, TInt32.DTYPE);\n+      List<Shape> outputShapes = Arrays.asList(\n+          Shape.of(3),\n+          Shape.of(1));\n+\n+      TensorSliceDataset tensorDataset = TensorSliceDataset.create(tf.scope(), tensors, outputShapes);\n+\n+      BatchDataset batchDataset = BatchDataset.create(", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0NDY0Mw==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r405644643", "bodyText": "They shouldn't be accessed directly. This file was just for testing, so I removed it.", "author": "dhruvrajan", "createdAt": "2020-04-08T16:13:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNTE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNTMzMQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r390715331", "bodyText": "handle tensor close", "author": "karllessard", "createdAt": "2020-03-11T02:33:34Z", "path": "tensorflow-frameworks/tensorflow-data/src/test/java/org/tensorflow/data/DatasetOpTester.java", "diffHunk": "@@ -0,0 +1,283 @@\n+package org.tensorflow.data;\n+\n+import org.junit.Test;\n+import org.tensorflow.*;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.op.core.Constant;\n+import org.tensorflow.op.data.*;\n+import org.tensorflow.tools.Shape;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.utils.Tuple2;\n+\n+import java.nio.IntBuffer;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class DatasetOpTester {\n+\n+  @Test\n+  public void testEagerBatching() {\n+    try (EagerSession session = EagerSession.create()) {\n+      Ops tf = Ops.create(session);\n+\n+      Constant<TInt32> X = tf.val(\n+          new int[][]{\n+              {1, 2, 3},\n+              {4, 5, 6},\n+              {7, 8, 9},\n+              {10, 11, 12}\n+          }\n+      );\n+\n+      Constant<TInt32> y = tf.val(\n+          new int[][]{\n+              {1},\n+              {4},\n+              {7},\n+              {10}\n+          }\n+      );\n+\n+\n+      List<Operand<?>> tensors = Arrays.asList(X, y);\n+\n+      // // Try running TensorDataset\n+      List<DataType<?>> outputTypes = Arrays.asList(TInt32.DTYPE, TInt32.DTYPE);\n+      List<Shape> outputShapes = Arrays.asList(\n+          Shape.of(3),\n+          Shape.of(1));\n+\n+      TensorSliceDataset tensorDataset = TensorSliceDataset.create(tf.scope(), tensors, outputShapes);\n+\n+      BatchDataset batchDataset = BatchDataset.create(\n+          tf.scope(),\n+          tensorDataset,\n+          tf.val(2L),\n+          tf.val(true),\n+          outputTypes,\n+          Arrays.asList(\n+              Shape.of(2, 3),\n+              Shape.of(2, 1))\n+      );\n+\n+\n+      AnonymousIterator anonymousIter = AnonymousIterator.create(tf.scope(), outputTypes, Arrays.asList(\n+          Shape.of(2, 3),\n+          Shape.of(2, 1)));\n+\n+      MakeIterator makeIterator = tf.data.makeIterator(batchDataset, anonymousIter.handle());\n+\n+      while (true) {\n+        try {\n+          IteratorGetNext getNext = tf.data.iteratorGetNext(anonymousIter.handle(), outputTypes, outputShapes);\n+          List<Output<?>> outputs = getNext.components();\n+          System.out.println(\"BATCH: \");\n+          printIntTensor(outputs.get(0).tensor());\n+          printIntTensor(outputs.get(1).tensor());", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0NDgyMg==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r405644822", "bodyText": "Thanks, updated!", "author": "dhruvrajan", "createdAt": "2020-04-08T16:13:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNTMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNTUzNQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r390715535", "bodyText": "again, any way to avoid catching an exception as part of the normal process? I think I already asked you this question before and you told me that is how Python is doing it... but still, can we do better? :)", "author": "karllessard", "createdAt": "2020-03-11T02:34:25Z", "path": "tensorflow-frameworks/tensorflow-data/src/test/java/org/tensorflow/data/DatasetOpTester.java", "diffHunk": "@@ -0,0 +1,283 @@\n+package org.tensorflow.data;\n+\n+import org.junit.Test;\n+import org.tensorflow.*;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.op.core.Constant;\n+import org.tensorflow.op.data.*;\n+import org.tensorflow.tools.Shape;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.utils.Tuple2;\n+\n+import java.nio.IntBuffer;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class DatasetOpTester {\n+\n+  @Test\n+  public void testEagerBatching() {\n+    try (EagerSession session = EagerSession.create()) {\n+      Ops tf = Ops.create(session);\n+\n+      Constant<TInt32> X = tf.val(\n+          new int[][]{\n+              {1, 2, 3},\n+              {4, 5, 6},\n+              {7, 8, 9},\n+              {10, 11, 12}\n+          }\n+      );\n+\n+      Constant<TInt32> y = tf.val(\n+          new int[][]{\n+              {1},\n+              {4},\n+              {7},\n+              {10}\n+          }\n+      );\n+\n+\n+      List<Operand<?>> tensors = Arrays.asList(X, y);\n+\n+      // // Try running TensorDataset\n+      List<DataType<?>> outputTypes = Arrays.asList(TInt32.DTYPE, TInt32.DTYPE);\n+      List<Shape> outputShapes = Arrays.asList(\n+          Shape.of(3),\n+          Shape.of(1));\n+\n+      TensorSliceDataset tensorDataset = TensorSliceDataset.create(tf.scope(), tensors, outputShapes);\n+\n+      BatchDataset batchDataset = BatchDataset.create(\n+          tf.scope(),\n+          tensorDataset,\n+          tf.val(2L),\n+          tf.val(true),\n+          outputTypes,\n+          Arrays.asList(\n+              Shape.of(2, 3),\n+              Shape.of(2, 1))\n+      );\n+\n+\n+      AnonymousIterator anonymousIter = AnonymousIterator.create(tf.scope(), outputTypes, Arrays.asList(\n+          Shape.of(2, 3),\n+          Shape.of(2, 1)));\n+\n+      MakeIterator makeIterator = tf.data.makeIterator(batchDataset, anonymousIter.handle());\n+\n+      while (true) {\n+        try {\n+          IteratorGetNext getNext = tf.data.iteratorGetNext(anonymousIter.handle(), outputTypes, outputShapes);\n+          List<Output<?>> outputs = getNext.components();\n+          System.out.println(\"BATCH: \");\n+          printIntTensor(outputs.get(0).tensor());\n+          printIntTensor(outputs.get(1).tensor());\n+          System.out.println();\n+        } catch (IndexOutOfBoundsException e) {", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0NTUwNg==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r405645506", "bodyText": "I can't think of a way to improve this, without restricting what can be done within the loop (e.g. arbitrary session runs / fetches / etc. that depend on the loop iteration).", "author": "dhruvrajan", "createdAt": "2020-04-08T16:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNTUzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgyNjcxNw==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r407826717", "bodyText": "Will resolve this since we have other threads on this topic.", "author": "dhruvrajan", "createdAt": "2020-04-14T02:21:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNTUzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgzNTk3OA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r407835978", "bodyText": "Will resolve this thread as we have others on this topic.", "author": "dhruvrajan", "createdAt": "2020-04-14T02:55:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNTUzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNTk4OQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r390715989", "bodyText": "tensor.writeTo might be remove soon, you might want to use tensor.data() instead and maybe enhanced NdArray with what is missing (like ndArray.print()?)", "author": "karllessard", "createdAt": "2020-03-11T02:36:38Z", "path": "tensorflow-frameworks/tensorflow-data/src/test/java/org/tensorflow/data/DatasetOpTester.java", "diffHunk": "@@ -0,0 +1,283 @@\n+package org.tensorflow.data;\n+\n+import org.junit.Test;\n+import org.tensorflow.*;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.op.core.Constant;\n+import org.tensorflow.op.data.*;\n+import org.tensorflow.tools.Shape;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.utils.Tuple2;\n+\n+import java.nio.IntBuffer;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class DatasetOpTester {\n+\n+  @Test\n+  public void testEagerBatching() {\n+    try (EagerSession session = EagerSession.create()) {\n+      Ops tf = Ops.create(session);\n+\n+      Constant<TInt32> X = tf.val(\n+          new int[][]{\n+              {1, 2, 3},\n+              {4, 5, 6},\n+              {7, 8, 9},\n+              {10, 11, 12}\n+          }\n+      );\n+\n+      Constant<TInt32> y = tf.val(\n+          new int[][]{\n+              {1},\n+              {4},\n+              {7},\n+              {10}\n+          }\n+      );\n+\n+\n+      List<Operand<?>> tensors = Arrays.asList(X, y);\n+\n+      // // Try running TensorDataset\n+      List<DataType<?>> outputTypes = Arrays.asList(TInt32.DTYPE, TInt32.DTYPE);\n+      List<Shape> outputShapes = Arrays.asList(\n+          Shape.of(3),\n+          Shape.of(1));\n+\n+      TensorSliceDataset tensorDataset = TensorSliceDataset.create(tf.scope(), tensors, outputShapes);\n+\n+      BatchDataset batchDataset = BatchDataset.create(\n+          tf.scope(),\n+          tensorDataset,\n+          tf.val(2L),\n+          tf.val(true),\n+          outputTypes,\n+          Arrays.asList(\n+              Shape.of(2, 3),\n+              Shape.of(2, 1))\n+      );\n+\n+\n+      AnonymousIterator anonymousIter = AnonymousIterator.create(tf.scope(), outputTypes, Arrays.asList(\n+          Shape.of(2, 3),\n+          Shape.of(2, 1)));\n+\n+      MakeIterator makeIterator = tf.data.makeIterator(batchDataset, anonymousIter.handle());\n+\n+      while (true) {\n+        try {\n+          IteratorGetNext getNext = tf.data.iteratorGetNext(anonymousIter.handle(), outputTypes, outputShapes);\n+          List<Output<?>> outputs = getNext.components();\n+          System.out.println(\"BATCH: \");\n+          printIntTensor(outputs.get(0).tensor());\n+          printIntTensor(outputs.get(1).tensor());\n+          System.out.println();\n+        } catch (IndexOutOfBoundsException e) {\n+          System.out.println(\"finished iterating.\");\n+          break;\n+        }\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testCleanEagerBatching() {\n+    try (EagerSession session = EagerSession.create()) {\n+      Ops tf = Ops.create(session);\n+\n+      Constant<TInt32> X = tf.val(\n+          new int[][]{\n+              {1, 2, 3},\n+              {4, 5, 6},\n+              {7, 8, 9},\n+              {10, 11, 12}\n+          }\n+      );\n+\n+      Constant<TInt32> y = tf.val(\n+          new int[][]{\n+              {1},\n+              {4},\n+              {7},\n+              {10}\n+          }\n+      );\n+\n+\n+      // // Try running TensorDataset\n+      List<Operand<?>> tensors = Arrays.asList(X, y);\n+      List<DataType<?>> outputTypes = Arrays.asList(TInt32.DTYPE, TInt32.DTYPE);\n+\n+      Dataset dataset = Dataset\n+          .fromTensorSlices(tf, tensors, outputTypes)\n+          .batch(50)\n+          .take(3)\n+          .skip(1);\n+      for (List<Output<?>> output : dataset) {\n+        Tensor<?> XBatch = output.get(0).tensor();\n+        Tensor<?> yBatch = output.get(1).tensor();\n+\n+        System.out.println(\"New Batch: \");\n+        System.out.print(\"   X is\");\n+        printIntTensor(XBatch);\n+        System.out.print(\"   y is\");\n+        printIntTensor(yBatch);\n+      }\n+    }\n+  }\n+\n+\n+  @Test\n+  public  void testGraphBatching() {\n+    try (Graph graph = new Graph()) {\n+\n+      Ops tf = Ops.create(graph);\n+      try (Session session = new Session(graph)) {\n+        long BATCH_SIZE = 2L;\n+\n+        Constant<TInt32> X = tf.val(\n+            new int[][]{\n+                {1, 2, 3},\n+                {4, 5, 6},\n+                {7, 8, 9},\n+                {10, 11, 12}\n+            }\n+        );\n+\n+        Constant<TInt32> y = tf.val(\n+            new int[][]{\n+                {1},\n+                {4},\n+                {7},\n+                {10}\n+            }\n+        );\n+\n+        // // Try running TensorDataset\n+        List<DataType<?>> outputTypes = Arrays.asList(TInt32.DTYPE, TInt32.DTYPE);\n+        List<Shape> outputShapes = Arrays.asList(\n+            Shape.of(3),\n+            Shape.of(1));\n+\n+        TensorSliceDataset tensorDataset = TensorSliceDataset.create(tf.scope(),\n+            Arrays.asList(X, y),\n+            outputShapes);\n+\n+        BatchDataset batchDataset = BatchDataset.create(\n+            tf.scope(),\n+            tensorDataset,\n+            tf.val(BATCH_SIZE),\n+            tf.val(true),\n+            outputTypes,\n+            Arrays.asList(\n+                Shape.of(BATCH_SIZE, 3),\n+                Shape.of(BATCH_SIZE, 1))\n+        );\n+\n+        Iterator anonymousIter = Iterator.create(tf.scope(), null, null, outputTypes, Arrays.asList(\n+            Shape.of(BATCH_SIZE, 3),\n+            Shape.of(BATCH_SIZE, 1)));\n+\n+        MakeIterator makeIterator = tf.data.makeIterator(batchDataset, anonymousIter);\n+\n+        session.runner()\n+            .addTarget(makeIterator.op())\n+            .run();\n+\n+        IteratorGetNext getNext = tf.data.iteratorGetNext(anonymousIter, outputTypes, outputShapes);\n+        Operand<?> XOp = getNext.components().get(0);\n+        Operand<?> yOp = getNext.components().get(1);\n+        while (true) {\n+          try {\n+            List<Tensor<?>> outputs = session.runner()\n+                .addTarget(getNext.op())\n+                .fetch(XOp)\n+                .fetch(yOp)\n+                .run();\n+            System.out.println(\"BATCH: \");\n+            printIntTensor(outputs.get(0));\n+            printIntTensor(outputs.get(1));\n+            System.out.println();\n+          } catch (IndexOutOfBoundsException e) {\n+            System.out.println(\"finished iterating.\");\n+            break;\n+          }\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  @Test\n+  public void testCleanGraphBatching() {\n+    try (Graph graph = new Graph()) {\n+\n+      Ops tf = Ops.create(graph);\n+      try (Session session = new Session(graph)) {\n+        long BATCH_SIZE = 2L;\n+\n+        Constant<TInt32> X = tf.val(\n+            new int[][]{\n+                {1, 2, 3},\n+                {4, 5, 6},\n+                {7, 8, 9},\n+                {10, 11, 12}\n+            }\n+        );\n+\n+        Constant<TInt32> y = tf.val(\n+            new int[][]{\n+                {1},\n+                {4},\n+                {7},\n+                {10}\n+            }\n+        );\n+\n+        // // Try running TensorDataset\n+        List<Operand<?>> tensors = Arrays.asList(X, y);\n+        List<DataType<?>> outputTypes = Arrays.asList(TInt32.DTYPE, TInt32.DTYPE);\n+\n+        Dataset dataset = Dataset\n+            .fromTensorSlices(tf, tensors, outputTypes)\n+            .batch(2);\n+\n+        OneShotIterator oneShotIterator = dataset.makeOneShotIterator();\n+        List<Output<?>> components = oneShotIterator.getComponents();\n+        Operand<?> XOp = components.get(0);\n+        Operand<?> yOp = components.get(1);\n+\n+        // Run MakeIterator Op\n+        session.runner()\n+            .addTarget(oneShotIterator.getMakeIteratorOp())\n+            .run();\n+\n+        while (true) {\n+          try {\n+            List<Tensor<?>> outputs = session.runner()\n+                .fetch(XOp)\n+                .fetch(yOp)\n+                .run();\n+\n+            System.out.println(\"BATCH: \");\n+            printIntTensor(outputs.get(0));\n+            printIntTensor(outputs.get(1));\n+            System.out.println();\n+          } catch (IndexOutOfBoundsException e) {\n+            System.out.println(\"finished iterating.\");\n+            break;\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  public static void printIntTensor(Tensor<?> tensor) {\n+    IntBuffer buffer = IntBuffer.allocate((int) tensor.shape().size());\n+    tensor.writeTo(buffer);", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0NjA0MQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r405646041", "bodyText": "I removed the print statements; but it would be great to have an print statement for NdArrays!", "author": "dhruvrajan", "createdAt": "2020-04-08T16:15:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNTk4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNzI5MA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r390717290", "bodyText": "It seems that it does not return a Pair anymore?", "author": "karllessard", "createdAt": "2020-03-11T02:42:08Z", "path": "tensorflow-frameworks/tensorflow-data/src/main/java/org/tensorflow/data/Dataset.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.tensorflow.data;\r\n+\r\n+import org.tensorflow.*;\r\n+import org.tensorflow.data.impl.*;\r\n+import org.tensorflow.op.Ops;\r\n+import org.tensorflow.op.data.AnonymousIterator;\r\n+import org.tensorflow.op.data.MakeIterator;\r\n+import org.tensorflow.tools.Shape;\r\n+import org.tensorflow.utils.Tuple2;\r\n+\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.stream.Collectors;\r\n+\r\n+/**\r\n+ * Represents a potentially large list of independent elements (samples), and\r\n+ * allows iteration and transformations to be performed across these elements.\r\n+ */\r\n+public abstract class Dataset implements Iterable<List<Output<?>>> {\r\n+  protected Ops tf;\r\n+  private List<DataType<?>> outputTypes;\r\n+  private List<Shape> outputShapes;\r\n+\r\n+  public Dataset(Ops tf, List<DataType<?>> outputTypes, List<Shape> outputShapes) {\r\n+    if (Objects.isNull(tf)) {\r\n+      throw new IllegalArgumentException(\"Ops accessor cannot be null.\");\r\n+    } else if (outputTypes.size() != outputShapes.size()) {\r\n+      throw new IllegalArgumentException(\"`outputTypes` and `outputShapes` must have the same size.\");\r\n+    }\r\n+\r\n+    this.tf = tf;\r\n+    this.outputTypes = outputTypes;\r\n+    this.outputShapes = outputShapes;\r\n+  }\r\n+\r\n+  /**\r\n+   * Groups elements of this dataset into batches.\r\n+   *\r\n+   * @param batchSize     The number of desired elements per batch\r\n+   * @param dropLastBatch Whether to leave out the final batch if it has fewer\r\n+   *                      than `batchSize` elements.\r\n+   * @return A batched Dataset\r\n+   */\r\n+  public final Dataset batch(long batchSize, boolean dropLastBatch) {\r\n+    List<Shape> batchOutputShapes = getOutputShapes().stream()\r\n+        .map(s -> Shape.of(Utils.array(batchSize, s.asArray())))\r\n+        .collect(Collectors.toList());\r\n+    return new BatchDataset(tf, this.getVariant(), tf.val(batchSize),\r\n+        tf.val(dropLastBatch), this.getOutputTypes(), batchOutputShapes);\r\n+  }\r\n+\r\n+  /**\r\n+   * Groups elements of this dataset into batches.\r\n+   * Leaves out the last batch if it has fewer than `batchSize` elements.\r\n+   *\r\n+   * @param batchSize The number of desired elements per batch\r\n+   * @return A batched Dataset\r\n+   */\r\n+  public final Dataset batch(long batchSize) {\r\n+    return batch(batchSize, true);\r\n+  }\r\n+\r\n+  /**\r\n+   * Creates new `Dataset` skips `count` initial elements from this dataset\r\n+   *\r\n+   * @param count The number of elements to `skip` to form the new dataset.\r\n+   * @return A new Dataset with `count` elements removed.\r\n+   */\r\n+  public final Dataset skip(long count) {\r\n+    return new SkipDataset(tf, this.getVariant(), tf.val(count), this.getOutputTypes(), this.getOutputShapes());\r\n+  }\r\n+\r\n+  /**\r\n+   * Creates new `Dataset` with the first `count` elements from this dataset.\r\n+   *\r\n+   * @param count The number of elements to \"take\" from this dataset.\r\n+   * @return A new Dataset containing the first `count` elements from this dataset.\r\n+   */\r\n+  public final Dataset take(long count) {\r\n+    return new TakeDataset(tf, this.getVariant(), tf.val(count), this.getOutputTypes(), this.getOutputShapes());\r\n+  }\r\n+\r\n+  /**\r\n+   * Creates an iterator which iterates through all batches of this Dataset in an eager fashion.\r\n+   * Each batch is a list of components, returned as `Output` objects.\r\n+   * <p>\r\n+   * This method enables for-each iteration through batches when running\r\n+   * in eager mode. For Graph mode batch iteration, see `makeOneShotIterator`.\r\n+   *\r\n+   * @return an Iterator through batches of this dataset.\r\n+   */\r\n+  @Override\r\n+  public Iterator<List<Output<?>>> iterator() {\r\n+\r\n+    if (!(tf.scope().env() instanceof EagerSession)) {\r\n+      throw new UnsupportedOperationException(\"Cannot iterate through a dataset in graph mode.\");\r\n+    }\r\n+\r\n+    Operand<?> dataset = getVariant();\r\n+    AnonymousIterator anonymousIterator = tf.data.anonymousIterator(getOutputTypes(), getOutputShapes());\r\n+\r\n+    tf.data.makeIterator(dataset, anonymousIterator.handle());\r\n+\r\n+    return new Iterator<List<Output<?>>>() {\r\n+      private List<Output<?>> tryNext = getNext();\r\n+\r\n+      private List<Output<?>> getNext() {\r\n+        try {\r\n+          return tf.data.iteratorGetNext(anonymousIterator.handle(), getOutputTypes(), getOutputShapes()).components();\r\n+        } catch (IndexOutOfBoundsException e) {\r\n+          return null;\r\n+        }\r\n+      }\r\n+\r\n+      @Override\r\n+      public boolean hasNext() {\r\n+        return tryNext != null;\r\n+      }\r\n+\r\n+      @Override\r\n+      public List<Output<?>> next() {\r\n+        List<Output<?>> result = tryNext;\r\n+        tryNext = getNext();\r\n+        return result;\r\n+      }\r\n+    };\r\n+  }\r\n+\r\n+  /**\r\n+   * Return the necessary components to iterate through batches of this\r\n+   * dataset in Graph mode.\r\n+   * <p>\r\n+   * This method returns a Pair whose first element is a MakeIterator operation\r\n+   * that must be run first in its own session to create the iterator internally.\r\n+   * <p>\r\n+   * The second element in the pair is a list of Output objects. In sequential\r\n+   * calls to session.run() in which these (or child) nodes are fetched, the batches\r\n+   * are already loaded into these objects.\r\n+   *\r\n+   * @return A Pair whose first element is a MakeIterator Operation, and whose\r", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyNjU3NQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r396126575", "bodyText": "Good catch, yup this returns OneShotIterator now.", "author": "dhruvrajan", "createdAt": "2020-03-22T18:37:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNzI5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0NjU1Nw==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r405646557", "bodyText": "... And now usees DatasetIterator", "author": "dhruvrajan", "createdAt": "2020-04-08T16:16:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxNzI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA0Mjk4NQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r393042985", "bodyText": "Why do we want the default behaviour to drop the last batch? Most code should be agnostic to the batch size right?", "author": "Craigacp", "createdAt": "2020-03-16T14:01:18Z", "path": "tensorflow-frameworks/tensorflow-data/src/main/java/org/tensorflow/data/Dataset.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.tensorflow.data;\r\n+\r\n+import org.tensorflow.*;\r\n+import org.tensorflow.data.impl.*;\r\n+import org.tensorflow.op.Ops;\r\n+import org.tensorflow.op.data.AnonymousIterator;\r\n+import org.tensorflow.op.data.MakeIterator;\r\n+import org.tensorflow.tools.Shape;\r\n+import org.tensorflow.utils.Tuple2;\r\n+\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.stream.Collectors;\r\n+\r\n+/**\r\n+ * Represents a potentially large list of independent elements (samples), and\r\n+ * allows iteration and transformations to be performed across these elements.\r\n+ */\r\n+public abstract class Dataset implements Iterable<List<Output<?>>> {\r\n+  protected Ops tf;\r\n+  private List<DataType<?>> outputTypes;\r\n+  private List<Shape> outputShapes;\r\n+\r\n+  public Dataset(Ops tf, List<DataType<?>> outputTypes, List<Shape> outputShapes) {\r\n+    if (Objects.isNull(tf)) {\r\n+      throw new IllegalArgumentException(\"Ops accessor cannot be null.\");\r\n+    } else if (outputTypes.size() != outputShapes.size()) {\r\n+      throw new IllegalArgumentException(\"`outputTypes` and `outputShapes` must have the same size.\");\r\n+    }\r\n+\r\n+    this.tf = tf;\r\n+    this.outputTypes = outputTypes;\r\n+    this.outputShapes = outputShapes;\r\n+  }\r\n+\r\n+  /**\r\n+   * Groups elements of this dataset into batches.\r\n+   *\r\n+   * @param batchSize     The number of desired elements per batch\r\n+   * @param dropLastBatch Whether to leave out the final batch if it has fewer\r\n+   *                      than `batchSize` elements.\r\n+   * @return A batched Dataset\r\n+   */\r\n+  public final Dataset batch(long batchSize, boolean dropLastBatch) {\r\n+    List<Shape> batchOutputShapes = getOutputShapes().stream()\r\n+        .map(s -> Shape.of(Utils.array(batchSize, s.asArray())))\r\n+        .collect(Collectors.toList());\r\n+    return new BatchDataset(tf, this.getVariant(), tf.val(batchSize),\r\n+        tf.val(dropLastBatch), this.getOutputTypes(), batchOutputShapes);\r\n+  }\r\n+\r\n+  /**\r\n+   * Groups elements of this dataset into batches.\r\n+   * Leaves out the last batch if it has fewer than `batchSize` elements.\r\n+   *\r\n+   * @param batchSize The number of desired elements per batch\r\n+   * @return A batched Dataset\r\n+   */\r\n+  public final Dataset batch(long batchSize) {\r", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzExMzg0MQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r407113841", "bodyText": "I updated this, thanks for catching! The default in python is to not drop the last batch.", "author": "dhruvrajan", "createdAt": "2020-04-11T21:40:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA0Mjk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA1MjcwMg==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r393052702", "bodyText": "Do we need both Pair and Tuple2? Or indeed either of them?", "author": "Craigacp", "createdAt": "2020-03-16T14:14:51Z", "path": "tensorflow-frameworks/tensorflow-utils/src/main/java/org/tensorflow/utils/Pair.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package org.tensorflow.utils;\r\n+\r\n+public class Pair<T> extends Tuple2<T, T> {\r", "originalCommit": "a69cfd9d8117fe6158a25e23133364b3b59b29ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA1NzM3OQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r394057379", "bodyText": "I had the same comment, I think Dhruv can safely discard them", "author": "karllessard", "createdAt": "2020-03-18T01:22:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA1MjcwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyNjI5Ng==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r396126296", "bodyText": "Yup I think for now we can remove this; I originally used a Pair instead of OneShotIterator. I always miss tuples in Java :) but the Java pattern of creating bundler classes instead is pretty useful.", "author": "dhruvrajan", "createdAt": "2020-03-22T18:34:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA1MjcwMg=="}], "type": "inlineReview"}, {"oid": "50bbd47093e8dbab28473267995e764904d3252d", "url": "https://github.com/tensorflow/java/commit/50bbd47093e8dbab28473267995e764904d3252d", "message": "add javadoc for tf.data", "committedDate": "2020-04-05T18:52:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc5MzIwMw==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r405793203", "bodyText": "This class is package private, yet returned by a public method on Dataset. Should it be public?", "author": "Craigacp", "createdAt": "2020-04-08T20:26:08Z", "path": "tensorflow-frameworks/tensorflow-data/src/main/java/org/tensorflow/data/DatasetIterator.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.tensorflow.data;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Graph;\n+import org.tensorflow.Operand;\n+import org.tensorflow.Output;\n+import org.tensorflow.op.Op;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.tools.Shape;\n+\n+import java.util.List;\n+\n+/**\n+ * Represents the state of an iteration through\n+ * a tf.data Datset.\n+ * <p>\n+ * Example: Iteration in graph mode.\n+ *\n+ * <pre>{@code\n+ *  // Create input tensors\n+ *  Operand<?> XTensor = tf.constant( ... );\n+ *  Operand<?> yTensor = tf.constant( ... );\n+ *\n+ *\n+ *  Dataset dataset = Dataset\n+ *          .fromTensorSlices(XTensor, yTensor);\n+ *          .batch(BATCH_SIZE);\n+ *\n+ *  DatasetIterator iterator = dataset.makeIterator();\n+ *  List<Output<?>> components = iterator.getNext();\n+ *  Operand<?> XBatch = components.get(0);\n+ *  Operand<?> yBatch = components.get(1);\n+ *\n+ *  // Build a TensorFlow graph that does something on each element.\n+ *  loss = computeModelLoss(X, y);\n+ *\n+ *  optimizer = ... // create an optimizer\n+ *  trainOp = optimizer.minimize(loss);\n+ *\n+ *  try (Session session = new Session(graph) {\n+ *      try {\n+ *          session.run(trainOp);\n+ *          ...\n+ *      } catch (IndexOutOfBoundsException e) {\n+ *          System.out.println(\"finished iterating.\");\n+ *          break;\n+ *      }\n+ *  }\n+ *\n+ * }</pre>\n+ * <p>\n+ * Example: Iteration in eager mode.\n+ *\n+ * <pre>{@code\n+ *  // Create input tensors\n+ *  Operand<?> XTensor = tf.constant( ... );\n+ *  Operand<?> yTensor = tf.constant( ... );\n+ *\n+ *  int BATCH_SIZE = ...\n+ *\n+ *  Dataset dataset = Dataset\n+ *          .fromTensorSlices(XTensor, yTensor)\n+ *          .batch(BATCH_SIZE);\n+ *  DatasetIterator iterator = dataset.makeIterator();\n+ *\n+ *  Optimizer optimizer = ... // create an optimizer\n+ *\n+ *  for (List<Output<?>> components : dataset) {\n+ *      Operand<?> XBatch = components.get(0);\n+ *      Operand<?> yBatch = components.get(1);\n+ *\n+ *      loss = computeModelLoss(X, y);\n+ *      trainOp = optimizer.minimize(loss);\n+ *  }\n+ * }</pre>\n+ */\n+class DatasetIterator {", "originalCommit": "3b193cddfe94d332d29e4962ac3b40c2776d9cb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkwNjM4Mw==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r406906383", "bodyText": "Yup good catch, updated!", "author": "dhruvrajan", "createdAt": "2020-04-10T19:25:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc5MzIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc5MzQyNQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r405793425", "bodyText": "There should be an explicit notice in this javadoc that DatasetIterator is not a java.util.Iterator. It's unfortunate that we can't really change the name entirely, but I guess it's best to go with what the TF Python functions are called when they mirror the functionality.", "author": "Craigacp", "createdAt": "2020-04-08T20:26:34Z", "path": "tensorflow-frameworks/tensorflow-data/src/main/java/org/tensorflow/data/DatasetIterator.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.tensorflow.data;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Graph;\n+import org.tensorflow.Operand;\n+import org.tensorflow.Output;\n+import org.tensorflow.op.Op;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.tools.Shape;\n+\n+import java.util.List;\n+\n+/**\n+ * Represents the state of an iteration through\n+ * a tf.data Datset.\n+ * <p>", "originalCommit": "3b193cddfe94d332d29e4962ac3b40c2776d9cb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkwNjAwOA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r406906008", "bodyText": "Good point, I added some explanation.", "author": "dhruvrajan", "createdAt": "2020-04-10T19:23:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc5MzQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc5NjM1MA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r405796350", "bodyText": "Should these constructors be public? They don't validate that the iteratorResource is actually an iterator.", "author": "Craigacp", "createdAt": "2020-04-08T20:32:11Z", "path": "tensorflow-frameworks/tensorflow-data/src/main/java/org/tensorflow/data/DatasetIterator.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.tensorflow.data;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Graph;\n+import org.tensorflow.Operand;\n+import org.tensorflow.Output;\n+import org.tensorflow.op.Op;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.tools.Shape;\n+\n+import java.util.List;\n+\n+/**\n+ * Represents the state of an iteration through\n+ * a tf.data Datset.\n+ * <p>\n+ * Example: Iteration in graph mode.\n+ *\n+ * <pre>{@code\n+ *  // Create input tensors\n+ *  Operand<?> XTensor = tf.constant( ... );\n+ *  Operand<?> yTensor = tf.constant( ... );\n+ *\n+ *\n+ *  Dataset dataset = Dataset\n+ *          .fromTensorSlices(XTensor, yTensor);\n+ *          .batch(BATCH_SIZE);\n+ *\n+ *  DatasetIterator iterator = dataset.makeIterator();\n+ *  List<Output<?>> components = iterator.getNext();\n+ *  Operand<?> XBatch = components.get(0);\n+ *  Operand<?> yBatch = components.get(1);\n+ *\n+ *  // Build a TensorFlow graph that does something on each element.\n+ *  loss = computeModelLoss(X, y);\n+ *\n+ *  optimizer = ... // create an optimizer\n+ *  trainOp = optimizer.minimize(loss);\n+ *\n+ *  try (Session session = new Session(graph) {\n+ *      try {\n+ *          session.run(trainOp);\n+ *          ...\n+ *      } catch (IndexOutOfBoundsException e) {\n+ *          System.out.println(\"finished iterating.\");\n+ *          break;\n+ *      }\n+ *  }\n+ *\n+ * }</pre>\n+ * <p>\n+ * Example: Iteration in eager mode.\n+ *\n+ * <pre>{@code\n+ *  // Create input tensors\n+ *  Operand<?> XTensor = tf.constant( ... );\n+ *  Operand<?> yTensor = tf.constant( ... );\n+ *\n+ *  int BATCH_SIZE = ...\n+ *\n+ *  Dataset dataset = Dataset\n+ *          .fromTensorSlices(XTensor, yTensor)\n+ *          .batch(BATCH_SIZE);\n+ *  DatasetIterator iterator = dataset.makeIterator();\n+ *\n+ *  Optimizer optimizer = ... // create an optimizer\n+ *\n+ *  for (List<Output<?>> components : dataset) {\n+ *      Operand<?> XBatch = components.get(0);\n+ *      Operand<?> yBatch = components.get(1);\n+ *\n+ *      loss = computeModelLoss(X, y);\n+ *      trainOp = optimizer.minimize(loss);\n+ *  }\n+ * }</pre>\n+ */\n+class DatasetIterator {\n+    public static final String EMPTY_SHARED_NAME = \"\";\n+\n+    private Ops tf;\n+\n+    private Operand<?> iteratorResource;\n+    private Op initializer;\n+\n+    private List<DataType<?>> outputTypes;\n+    private List<Shape> outputShapes;\n+\n+    /**\n+     * @param tf               Ops accessor corresponding to the same `ExecutionEnvironment`\n+     *                         as the `iteratorResource`.\n+     * @param iteratorResource An Operand representing the iterator\n+     *                         (e.g. constructed from `tf.data.iterator` or\n+     *                         `tf.data.anonymousIterator`)\n+     * @param initializer      An `Op` that should be run to initialize this iterator\n+     * @param outputTypes      A list of `DataType` objects corresponding to the\n+     *                         types of each component of a dataset element.\n+     * @param outputShapes     A list of `Shape` objects corresponding to the\n+     *                         shapes of each componenet of a dataset element.\n+     */\n+    public DatasetIterator(Ops tf, Operand<?> iteratorResource,", "originalCommit": "3b193cddfe94d332d29e4962ac3b40c2776d9cb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkwNjI4Mw==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r406906283", "bodyText": "I agree, makes sense to make them private for now, and require the use of makeInitializer. Updated those.", "author": "dhruvrajan", "createdAt": "2020-04-10T19:24:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc5NjM1MA=="}], "type": "inlineReview"}, {"oid": "c3ffe8c61705e8d36d4a1c6f5a56085fd3beff38", "url": "https://github.com/tensorflow/java/commit/c3ffe8c61705e8d36d4a1c6f5a56085fd3beff38", "message": "refactoring", "committedDate": "2020-04-10T19:23:09Z", "type": "forcePushed"}, {"oid": "c8c50b8c61b52a4431a32488908d6d66563abd6f", "url": "https://github.com/tensorflow/java/commit/c8c50b8c61b52a4431a32488908d6d66563abd6f", "message": "refactoring", "committedDate": "2020-04-10T19:30:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA2Njc3Ng==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r407066776", "bodyText": "The starting comment tag is offset of one character (at least in GitHub review)", "author": "karllessard", "createdAt": "2020-04-11T13:54:10Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Output.java", "diffHunk": "@@ -47,6 +47,24 @@ public Shape shape() {\n     return (DataType<T>)operation.dtype(index);\n   }\n \n+    /**", "originalCommit": "c8c50b8c61b52a4431a32488908d6d66563abd6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk0MjIzNA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r410942234", "bodyText": "thanks, fixed!", "author": "dhruvrajan", "createdAt": "2020-04-19T16:35:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA2Njc3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3MDMxMw==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r407070313", "bodyText": "I think we talked previously to add a method in the Ops or Scope class telling if we are in graph mode or not without the need of instanceof (returning either a boolean or an enum to support future execution environments). Should we do it in this PR as well?", "author": "karllessard", "createdAt": "2020-04-11T14:28:26Z", "path": "tensorflow-frameworks/tensorflow-data/src/main/java/org/tensorflow/data/Dataset.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.tensorflow.data;\r\n+\r\n+import org.tensorflow.*;\r\n+import org.tensorflow.data.impl.BatchDataset;\r\n+import org.tensorflow.data.impl.SkipDataset;\r\n+import org.tensorflow.data.impl.TakeDataset;\r\n+import org.tensorflow.data.impl.TensorSliceDataset;\r\n+import org.tensorflow.op.Op;\r\n+import org.tensorflow.op.Ops;\r\n+import org.tensorflow.tools.Shape;\r\n+\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.stream.Collectors;\r\n+\r\n+/**\r\n+ * Represents a potentially large list of independent elements (samples), and\r\n+ * allows iteration and transformations to be performed across these elements.\r\n+ */\r\n+public abstract class Dataset implements Iterable<List<Output<?>>> {\r\n+    protected Ops tf;\r\n+    private List<DataType<?>> outputTypes;\r\n+    private List<Shape> outputShapes;\r\n+\r\n+    public Dataset(Ops tf, List<DataType<?>> outputTypes, List<Shape> outputShapes) {\r\n+        if (Objects.isNull(tf)) {\r\n+            throw new IllegalArgumentException(\"Ops accessor cannot be null.\");\r\n+        } else if (outputTypes.size() != outputShapes.size()) {\r\n+            throw new IllegalArgumentException(\"`outputTypes` and `outputShapes` must have the same size.\");\r\n+        }\r\n+\r\n+        this.tf = tf;\r\n+        this.outputTypes = outputTypes;\r\n+        this.outputShapes = outputShapes;\r\n+    }\r\n+\r\n+    /**\r\n+     * Groups elements of this dataset into batches.\r\n+     *\r\n+     * @param batchSize     The number of desired elements per batch\r\n+     * @param dropLastBatch Whether to leave out the final batch if it has fewer\r\n+     *                      than `batchSize` elements.\r\n+     * @return A batched Dataset\r\n+     */\r\n+    public final Dataset batch(long batchSize, boolean dropLastBatch) {\r\n+        List<Shape> batchOutputShapes = getOutputShapes().stream()\r\n+                .map(s -> Shape.of(batchSize, s.asArray()))\r\n+                .collect(Collectors.toList());\r\n+\r\n+\r\n+        return new BatchDataset(tf, this.getVariant(), tf.constant(batchSize),\r\n+                tf.constant(dropLastBatch), this.getOutputTypes(), batchOutputShapes);\r\n+    }\r\n+\r\n+    /**\r\n+     * Groups elements of this dataset into batches.\r\n+     * Includes the last batch, even if it has fewer than `batchSize` elements.\r\n+     *\r\n+     * @param batchSize The number of desired elements per batch\r\n+     * @return A batched Dataset\r\n+     */\r\n+    public final Dataset batch(long batchSize) {\r\n+        return batch(batchSize, false);\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a new `Dataset` which skips `count` initial elements from this\r\n+     * dataset\r\n+     *\r\n+     * @param count The number of elements to `skip` to form the new dataset.\r\n+     * @return A new Dataset with `count` elements removed.\r\n+     */\r\n+    public final Dataset skip(long count) {\r\n+        return new SkipDataset(tf, this.getVariant(), tf.constant(count), this.getOutputTypes(), this.getOutputShapes());\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a new `Dataset` with only the first `count` elements from this\r\n+     * dataset.\r\n+     *\r\n+     * @param count The number of elements to \"take\" from this dataset.\r\n+     * @return A new Dataset containing the first `count` elements from this dataset.\r\n+     */\r\n+    public final Dataset take(long count) {\r\n+        return new TakeDataset(tf, this.getVariant(), tf.constant(count), this.getOutputTypes(), this.getOutputShapes());\r\n+    }\r\n+\r\n+    /**\r\n+     * Creates an iterator which iterates through all batches of this Dataset in an eager fashion.\r\n+     * Each batch is a list of components, returned as `Output` objects.\r\n+     * <p>\r\n+     * This method enables for-each iteration through batches when running\r\n+     * in eager mode. For Graph mode batch iteration, see `makeOneShotIterator`.\r\n+     *\r\n+     * @return an Iterator through batches of this dataset.\r\n+     */\r\n+    @Override\r\n+    public Iterator<List<Output<?>>> iterator() {\r\n+\r\n+        if (!(tf.scope().env() instanceof EagerSession)) {\r\n+            throw new UnsupportedOperationException(\"Cannot iterate through a dataset in graph mode.\");\r\n+        }\r\n+\r\n+        DatasetIterator iterator = makeOneShotIterator();\r\n+\r\n+        return new Iterator<List<Output<?>>>() {\r\n+            private List<Output<?>> tryNext = getNext();\r\n+\r\n+            private List<Output<?>> getNext() {\r\n+                try {\r\n+                    return iterator.getNext();\r\n+                } catch (IndexOutOfBoundsException e) {\r\n+                    return null;\r\n+                }\r\n+            }\r\n+\r\n+            @Override\r\n+            public boolean hasNext() {\r\n+                return tryNext != null;\r\n+            }\r\n+\r\n+            @Override\r\n+            public List<Output<?>> next() {\r\n+                List<Output<?>> result = tryNext;\r\n+                tryNext = getNext();\r\n+                return result;\r\n+            }\r\n+        };\r\n+    }\r\n+\r\n+    /**\r\n+     * Creates a `DatasetIterator` that can be used to iterate\r\n+     * over elements of this dataset.\r\n+     *\r\n+     * This iterator will have to be initialized with a call\r\n+     * to `iterator.makeInitializer(Dataset)` before elements\r\n+     * can be retreived in a loop.\r\n+     *\r\n+     * @return A new `DatasetIterator` based on this dataset's structure.\r\n+     */\r\n+    public DatasetIterator makeInitializeableIterator() {\r\n+        return DatasetIterator\r\n+                .fromStructure(tf, outputTypes, outputShapes);\r\n+    }\r\n+\r\n+    /**\r\n+     * Creates a `DatasetIterator` that can be used to iterate over\r\n+     * elements of this dataset. Using `makeOneShotIterator` ensures\r\n+     * that the iterator is\r\n+     * automatically initialized on this dataset.\r\n+     *skips\r\n+     * In graph mode, the initializer op will be added to the Graph's\r\n+     * intitializer list, which must be run via `tf.init()`:\r\n+     *\r\n+     * Ex:\r\n+     * <pre>\r\n+     *     try (Session session = new Session(graph) {\r\n+     *         // Immediately run initializers\r\n+     *         session.run(tf.init());\r\n+     *     }\r\n+     * </pre>\r\n+     *\r\n+     * In eager mode, the initializer will be run automatically as a result\r\n+     * of this call.\r\n+     *\r\n+     * @return A new `DatasetIterator` based on this dataset's structure.\r\n+     */\r\n+    public DatasetIterator makeOneShotIterator() {\r\n+        DatasetIterator iterator = makeInitializeableIterator();\r\n+        Op initializer = iterator.makeInitializer(this);\r\n+        if (tf.scope().env() instanceof Graph) tf.initAdd(initializer);\r", "originalCommit": "c8c50b8c61b52a4431a32488908d6d66563abd6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzExNTYyNQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r407115625", "bodyText": "I can add this to the Ops class! Which file do I change? tensorflow-core/tensorflow-core-api/gen/annotations/org/tensorflow/op/Ops.java is generated, right?", "author": "dhruvrajan", "createdAt": "2020-04-11T22:02:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3MDMxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgzNjIxNA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r407836214", "bodyText": "I added this method to the ExecutionEnvironment class; so we can use tf.scope().env().isEager()  or isGraph() instead.", "author": "dhruvrajan", "createdAt": "2020-04-14T02:56:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3MDMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3MDgzMg==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r407070832", "bodyText": "Oops, I don't think this reformatting was meant to be part of the PR", "author": "karllessard", "createdAt": "2020-04-11T14:33:15Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/Shape.java", "diffHunk": "@@ -21,122 +21,159 @@\n ", "originalCommit": "c8c50b8c61b52a4431a32488908d6d66563abd6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "692ffd60e26794ebbbd9c7eeedcf4ded37e04789", "url": "https://github.com/tensorflow/java/commit/692ffd60e26794ebbbd9c7eeedcf4ded37e04789", "message": "use 2-space indentation", "committedDate": "2020-04-11T22:05:44Z", "type": "forcePushed"}, {"oid": "4546d4d010622cfba5312dd401690a73a9a9cee7", "url": "https://github.com/tensorflow/java/commit/4546d4d010622cfba5312dd401690a73a9a9cee7", "message": "simple refactor", "committedDate": "2020-04-14T02:28:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg2MTAwMw==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r408861003", "bodyText": "Mmh, I was expecting those changes to come in, from our conversation with @Craigacp , I thought we were more heading on just finding a way to prevent to user to catch an exception as part of the control flow.\nI don't discard this idea of \"popping\" the tensors out of the Run object but there might be more thinking to do around this and it is not required for supporting the Data API.", "author": "karllessard", "createdAt": "2020-04-15T13:55:28Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Session.java", "diffHunk": "@@ -485,6 +484,51 @@ public void run(Op op) {\n      * this field may be replaced by more type-safe equivalents at any time.\n      */\n     public RunMetadata metadata;\n+\n+    /**\n+     * Current `pop` index in the `outputs` list.\n+     */\n+    private int index = 0;\n+\n+    Run(List<Tensor<?>> outputs, RunMetadata metadata) {\n+      this.outputs = outputs;\n+      this.metadata = metadata;\n+    }\n+\n+    Run(List<Tensor<?>> outputs) {\n+      this.outputs = outputs;\n+    }\n+\n+    public <T extends TType> Tensor<T> pop(DataType<T> dtype) {\n+      return outputs.get(index++).expect(dtype);\n+    }\n+\n+    public int popInt(long... coordinates) {\n+      return pop(TInt32.DTYPE).data().getInt(coordinates);\n+    }\n+\n+    public long popLong(long... coordinates) {\n+      return pop(TInt64.DTYPE).data().getLong(coordinates);\n+    }\n+\n+    public float popFloat16(long... coordinates) {\n+      return pop(TFloat16.DTYPE).data().getFloat(coordinates);\n+    }\n+\n+    public float popFloat(long... coordinates) {\n+      return pop(TFloat32.DTYPE).data().getFloat(coordinates);\n+    }\n+\n+    public double popDouble(long... coordinates) {\n+      return pop(TFloat64.DTYPE).data().getDouble(coordinates);\n+    }\n+\n+    @Override\n+    public void close() {\n+      for (Tensor<?> tensor : this.outputs) {\n+        tensor.close();\n+      }\n+    }", "originalCommit": "88f3ae9f00eef133a3bf24fa95b82f8296f5c150", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg3OTkwOQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r408879909", "bodyText": "Ah, I was playing around with this, since it sounds like we will require some extra machinery, for graph mode datasets, but I'll move it to a separate branch.", "author": "dhruvrajan", "createdAt": "2020-04-15T14:20:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg2MTAwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk0MDQyNQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r410940425", "bodyText": "I removed the pop() methods from Session.Run for this PR; but later on it would be great to find a way to simplify the data-extraction-chain.\nRun.outputs.get(...).expect(...).data().getFloat(...) etc.\nis pretty lengthy, any way of simplifying this would be quite useful. I replaced the pops with a get(int index) method to at least remove the need to reference Run.outputs.", "author": "dhruvrajan", "createdAt": "2020-04-19T16:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg2MTAwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgzNjcxOA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r411836718", "bodyText": "Yes we'll come back to this as well. I would like to reduce the chain too but at the same time, I would like to avoid having all possible variations of popFloat(), popInt(), ... presented to the user to let him pick the right one, as we are trying to keep the client type-safe as much as possible. Not to forget that as we are adding more datatypes, you will need more accessors (popFloat16, popBfloat16, ...).", "author": "karllessard", "createdAt": "2020-04-21T03:13:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg2MTAwMw=="}], "type": "inlineReview"}, {"oid": "b12686398b1a860549ea39955ece8aee266ab7f4", "url": "https://github.com/tensorflow/java/commit/b12686398b1a860549ea39955ece8aee266ab7f4", "message": "Add repeat() method to Session", "committedDate": "2020-04-19T16:18:15Z", "type": "forcePushed"}, {"oid": "baaf84c65adf8a11170d7b6585dd4831014e74fd", "url": "https://github.com/tensorflow/java/commit/baaf84c65adf8a11170d7b6585dd4831014e74fd", "message": "Add repeat() method to Session", "committedDate": "2020-04-19T16:39:27Z", "type": "forcePushed"}, {"oid": "ce003dd7e16059dd59371e1459238f861464c3f3", "url": "https://github.com/tensorflow/java/commit/ce003dd7e16059dd59371e1459238f861464c3f3", "message": "Merge optimizers and datasets into tensorflow-framework", "committedDate": "2020-04-19T21:48:45Z", "type": "forcePushed"}, {"oid": "d6a47e29d044de336c9e621724e8367c45c0d263", "url": "https://github.com/tensorflow/java/commit/d6a47e29d044de336c9e621724e8367c45c0d263", "message": "Merge optimizers and datasets into tensorflow-framework", "committedDate": "2020-04-19T21:51:03Z", "type": "forcePushed"}, {"oid": "579ebc2021672de4063c58de608b910106b913c4", "url": "https://github.com/tensorflow/java/commit/579ebc2021672de4063c58de608b910106b913c4", "message": "Fix tests to use new exceptions from tensorflow-core", "committedDate": "2020-04-23T15:33:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5MTU4Mw==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415391583", "bodyText": "Maybe rename this enum to Type? (so it is referenced as ExecutionEnvironment.Type instead of ExecutionEnvironment.Environments)", "author": "karllessard", "createdAt": "2020-04-26T20:16:16Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/ExecutionEnvironment.java", "diffHunk": "@@ -18,6 +18,11 @@\n /** Defines an environment for creating and executing TensorFlow {@link Operation}s. */\n public interface ExecutionEnvironment {\n \n+  enum Environments {", "originalCommit": "41d1b563c857107b549c80bc16a3c2cdf52a275f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQyNzM0Ng==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415427346", "bodyText": "That sounds good, renamed Environments to Types", "author": "dhruvrajan", "createdAt": "2020-04-26T23:32:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5MTU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5MjM2MA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415392360", "bodyText": "We shouldn't use wildcards in non-static imports, but looking again it seems that these new imports are not required anymore (probably a left over from the pop* methods you added before), can you please cleanup your list of imports?", "author": "karllessard", "createdAt": "2020-04-26T20:20:22Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Session.java", "diffHunk": "@@ -41,6 +48,8 @@\n import org.tensorflow.proto.framework.ConfigProto;\n import org.tensorflow.proto.framework.RunMetadata;\n import org.tensorflow.proto.framework.RunOptions;\n+import org.tensorflow.types.*;\n+import org.tensorflow.types.family.TType;", "originalCommit": "41d1b563c857107b549c80bc16a3c2cdf52a275f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQyNzQwMA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415427400", "bodyText": "Good point, went through and removed wildcard imports", "author": "dhruvrajan", "createdAt": "2020-04-26T23:32:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5MjM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5MjkzOA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415392938", "bodyText": "Just to double check, all those reformatting commits, are they the result of applying the Google Java Style formatting settings over the code or just personal settings?", "author": "karllessard", "createdAt": "2020-04-26T20:23:03Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Session.java", "diffHunk": "@@ -135,21 +148,21 @@ public void close() {\n    * Run {@link Operation}s and evaluate {@link Tensor Tensors}.\n    *\n    * <p>A Runner runs the necessary graph fragments to execute every {@link Operation} required to\n-   * evaluate the {@link Tensor Tensors} to fetch. The {@link #feed(String,int,Tensor)} call allows\n+   * evaluate the {@link Tensor Tensors} to fetch. The {@link #feed(String, int, Tensor)} call allows\n    * callers to override the value of {@link Tensor Tensors} in the graph by substituting the\n    * provided {@link Tensor Tensors} for the outputs of the operations provided to {@link\n-   * #feed(String,int,Tensor)}.\n+   * #feed(String, int, Tensor)}.\n    */\n   public final class Runner {\n     /**\n      * Avoid evaluating {@code operation} and substitute {@code t} for the value it produces.\n      *\n      * @param operation Is either the string name of the operation, in which case this method is a\n-     *     shorthand for {@code feed(operation, 0)}, or it is a string of the form\n-     *     <tt>operation_name:output_index</tt> , in which case this method acts like {@code\n-     *     feed(operation_name, output_index)}. These colon-separated names are commonly used in the\n-     *     {@code SignatureDef} protocol buffer messages that are included in {@link\n-     *     SavedModelBundle#metaGraphDef()}.\n+     *                  shorthand for {@code feed(operation, 0)}, or it is a string of the form\n+     *                  <tt>operation_name:output_index</tt> , in which case this method acts like {@code\n+     *                  feed(operation_name, output_index)}. These colon-separated names are commonly used in the\n+     *                  {@code SignatureDef} protocol buffer messages that are included in {@link\n+     *                  SavedModelBundle#metaGraphDef()}.", "originalCommit": "41d1b563c857107b549c80bc16a3c2cdf52a275f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQyNzg2MA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415427860", "bodyText": "I installed the standard google-java formatter and applied them to each file I changed, hopefully the formats look more standard now.", "author": "dhruvrajan", "createdAt": "2020-04-26T23:35:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5MjkzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5MzA5NA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415393094", "bodyText": "This is not used anymore.", "author": "karllessard", "createdAt": "2020-04-26T20:23:59Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Session.java", "diffHunk": "@@ -485,6 +499,31 @@ public void run(Op op) {\n      * this field may be replaced by more type-safe equivalents at any time.\n      */\n     public RunMetadata metadata;\n+\n+    /**\n+     * Current `pop` index in the `outputs` list.\n+     */\n+    private int index = 0;", "originalCommit": "41d1b563c857107b549c80bc16a3c2cdf52a275f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQyNzkxMQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415427911", "bodyText": "Thanks, removed!", "author": "dhruvrajan", "createdAt": "2020-04-26T23:35:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5MzA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5MzQyMA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415393420", "bodyText": "while we are at it, should we move this guy to the exceptions package as well?", "author": "karllessard", "createdAt": "2020-04-26T20:25:55Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/TensorFlowException.java", "diffHunk": "@@ -15,11 +15,14 @@\n \n package org.tensorflow;\n \n-/** Unchecked exception thrown by TensorFlow core classes */\n-public final class TensorFlowException extends RuntimeException {\n+/**\n+ * Unchecked exception thrown by TensorFlow core classes\n+ */\n+public class TensorFlowException extends RuntimeException {\n   public TensorFlowException(String message) {\n     super(message);\n   }\n+\n   public TensorFlowException(String message, Throwable cause) {\n     super(message, cause);\n   }", "originalCommit": "41d1b563c857107b549c80bc16a3c2cdf52a275f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQyNzk1Ng==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415427956", "bodyText": "Good idea, moved!", "author": "dhruvrajan", "createdAt": "2020-04-26T23:35:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5MzQyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NTM4OA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415395388", "bodyText": "Oh I didn't know we were changing all exceptions here, I thought we were only doing it for OutOfRangeException, @Craigacp  was it what you had in mind as well?\nChanging all of them might be tougher for our clients migrating for 1.* to 2.* as they are all thrown as runtime exception... another idea would have been then to extends each of these TF errors to known runtime exceptions (i.e. TFOutOfRangeException would extends from IndexOutOfBoundsException instead of TensorFlowException).\nIf we are keeping this new mapping, then I suggest that we have all distinct exceptions for each possible error (i.e. there should be  a TFResourceExhaustedException and a TFUnauthenticatedException as well)", "author": "karllessard", "createdAt": "2020-04-26T20:36:14Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/internal/c_api/AbstractTF_Status.java", "diffHunk": "@@ -69,17 +75,17 @@ public void throwExceptionIfNotOK() {\n         case TF_OK:\n           break;\n         case TF_INVALID_ARGUMENT:\n-          throw new IllegalArgumentException(TF_Message(s).getString());\n+          throw new TFInvalidArgumentException(TF_Message(s).getString());\n         case TF_UNAUTHENTICATED:\n         case TF_PERMISSION_DENIED:\n-          throw new SecurityException(TF_Message(s).getString());\n+          throw new TFPermissionDeniedException(TF_Message(s).getString());\n         case TF_RESOURCE_EXHAUSTED:\n         case TF_FAILED_PRECONDITION:\n-          throw new IllegalStateException(TF_Message(s).getString());\n+          throw new TFFailedPreconditionException(TF_Message(s).getString());\n         case TF_OUT_OF_RANGE:\n-          throw new IndexOutOfBoundsException(TF_Message(s).getString());\n+          throw new TFOutOfRangeException(TF_Message(s).getString());\n         case TF_UNIMPLEMENTED:\n-          throw new UnsupportedOperationException(TF_Message(s).getString());\n+          throw new TFUnimplementedException(TF_Message(s).getString());", "originalCommit": "41d1b563c857107b549c80bc16a3c2cdf52a275f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQzMDY2MQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415430661", "bodyText": "Good point, I had created TFUnauthenticatedException and TFResourceExhaustedException as well but hadn't mapped to them. Just added them to this mapping.\nI think it's a good idea to change it for all exceptions. The ambiguity issue we found with IndexOutOfBoundsException applies to all of these exceptions. There weren't too many issues in tests to address so within our codebase, this is a pretty low-touch change.\nAre there other major cases where current users might be catching errors from tensorflow-core? My guess is that not too many users will depend strongly on this. If we document this change well during our alpha releases, I think it can be adjusted to.", "author": "dhruvrajan", "createdAt": "2020-04-26T23:49:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NTM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzODg0OQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415838849", "bodyText": "I've gone back and forth on this, and I don't have strong opinions about if the others should be TF exceptions or not. The main reason that I want the TFOutOfRangeException is because we've made that part of the API that the user has to know about and catch. As far as I can tell the rest of the errors are programmer errors that are reasonable to leave as the standard exceptions, but they are probably also fine as wrapped TF exceptions so we have more of an idea of the provenance. I agree with Karl that if we're going to map most of them we should map all of them for completeness.", "author": "Craigacp", "createdAt": "2020-04-27T14:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NTM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzkyOA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r417023928", "bodyText": "Ok guys, sorry but I think I changed a bit my mind on this again... I think it is good to have distinct exceptions per possible errors thrown by TensorFlow, like you did @dhruvrajan. But I think those exceptions should extend from their matching runtime exception (the one that were thrown before) rather than from the generic TensorFlowException.\nMy reasoning is that it does not really matter for a user to know that, for instance, a parameter is detected to be invalid at the JVM level or at the native level. So if we throw a IllegalArgumentException when validating user parameters in the JVM, we should throw a IllegalArgumentException too (or in this case an exception that extends from it) if the validation failed in the native library.\nStill, having concrete type like TFOutOfRangeException will allow us to catch explicitly this exception without catching all IndexOutOfBoundException, which was the original purpose here.", "author": "karllessard", "createdAt": "2020-04-29T01:47:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NTM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ4ODAxMw==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r417488013", "bodyText": "I guess the thing here is, when a user tries to catch an IndexOutOfBounds exception to catch they expect from a Java array, for example (in their own code), do we want it to catch other errors thrown from tensorflow-core? Granted, these cases should be pretty infrequent, but it's still a very confusing semantic.", "author": "dhruvrajan", "createdAt": "2020-04-29T17:29:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NTM4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NjM2OQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415396369", "bodyText": "It looks to me that your line wrapping is less that 100 characters.", "author": "karllessard", "createdAt": "2020-04-26T20:41:35Z", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/data/DatasetIterator.java", "diffHunk": "@@ -0,0 +1,242 @@\n+package org.tensorflow.framework.data;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Graph;\n+import org.tensorflow.Operand;\n+import org.tensorflow.Output;\n+import org.tensorflow.op.Op;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.tools.Shape;\n+\n+import java.util.List;\n+\n+/**\n+ * Represents the state of an iteration through\n+ * a tf.data Datset. DatasetIterator is not\n+ * a java.util.Iterator. In eager mode, `Dataset`\n+ * can be used as an Iterable, returning dataset\n+ * elements each iteration.", "originalCommit": "41d1b563c857107b549c80bc16a3c2cdf52a275f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQzMDkyNQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415430925", "bodyText": "Adding the TF Java formatting, looks like the line wrapping everywhere has been updated to 100 characters.", "author": "dhruvrajan", "createdAt": "2020-04-26T23:51:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NjM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NjQ3Nw==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415396477", "bodyText": "should be TFOutOfRangeException now. Also, where is the loop?", "author": "karllessard", "createdAt": "2020-04-26T20:42:12Z", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/data/DatasetIterator.java", "diffHunk": "@@ -0,0 +1,242 @@\n+package org.tensorflow.framework.data;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Graph;\n+import org.tensorflow.Operand;\n+import org.tensorflow.Output;\n+import org.tensorflow.op.Op;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.tools.Shape;\n+\n+import java.util.List;\n+\n+/**\n+ * Represents the state of an iteration through\n+ * a tf.data Datset. DatasetIterator is not\n+ * a java.util.Iterator. In eager mode, `Dataset`\n+ * can be used as an Iterable, returning dataset\n+ * elements each iteration.\n+ *\n+ * <p>\n+ * Example: Iteration in graph mode.\n+ *\n+ * <pre>{@code\n+ *  // Create input tensors\n+ *  Operand<?> XTensor = tf.constant( ... );\n+ *  Operand<?> yTensor = tf.constant( ... );\n+ *\n+ *\n+ *  Dataset dataset = Dataset\n+ *          .fromTensorSlices(XTensor, yTensor);\n+ *          .batch(BATCH_SIZE);\n+ *\n+ *  DatasetIterator iterator = dataset.makeIterator();\n+ *  List<Output<?>> components = iterator.getNext();\n+ *  Operand<?> XBatch = components.get(0);\n+ *  Operand<?> yBatch = components.get(1);\n+ *\n+ *  // Build a TensorFlow graph that does something on each element.\n+ *  loss = computeModelLoss(X, y);\n+ *\n+ *  optimizer = ... // create an optimizer\n+ *  trainOp = optimizer.minimize(loss);\n+ *\n+ *  try (Session session = new Session(graph) {\n+ *      try {\n+ *          session.run(trainOp);\n+ *          ...\n+ *      } catch (IndexOutOfBoundsException e) {", "originalCommit": "41d1b563c857107b549c80bc16a3c2cdf52a275f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQzMTA0OA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415431048", "bodyText": "Right on both counts, updated the exception and added a while(true) loop", "author": "dhruvrajan", "createdAt": "2020-04-26T23:51:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NjQ3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NjczOQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415396739", "bodyText": "where are defined X and y? Also, variables should start with lowercase, so xTensor & cie are a better pick", "author": "karllessard", "createdAt": "2020-04-26T20:44:00Z", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/data/DatasetIterator.java", "diffHunk": "@@ -0,0 +1,242 @@\n+package org.tensorflow.framework.data;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Graph;\n+import org.tensorflow.Operand;\n+import org.tensorflow.Output;\n+import org.tensorflow.op.Op;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.tools.Shape;\n+\n+import java.util.List;\n+\n+/**\n+ * Represents the state of an iteration through\n+ * a tf.data Datset. DatasetIterator is not\n+ * a java.util.Iterator. In eager mode, `Dataset`\n+ * can be used as an Iterable, returning dataset\n+ * elements each iteration.\n+ *\n+ * <p>\n+ * Example: Iteration in graph mode.\n+ *\n+ * <pre>{@code\n+ *  // Create input tensors\n+ *  Operand<?> XTensor = tf.constant( ... );\n+ *  Operand<?> yTensor = tf.constant( ... );\n+ *\n+ *\n+ *  Dataset dataset = Dataset\n+ *          .fromTensorSlices(XTensor, yTensor);\n+ *          .batch(BATCH_SIZE);\n+ *\n+ *  DatasetIterator iterator = dataset.makeIterator();\n+ *  List<Output<?>> components = iterator.getNext();\n+ *  Operand<?> XBatch = components.get(0);\n+ *  Operand<?> yBatch = components.get(1);\n+ *\n+ *  // Build a TensorFlow graph that does something on each element.\n+ *  loss = computeModelLoss(X, y);", "originalCommit": "41d1b563c857107b549c80bc16a3c2cdf52a275f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQzMTgxNQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415431815", "bodyText": "These should be XBatch and yBatch\nNever really thought about it, in a lot of the ML code I've seen (in Python), the examples tensor X is capital and the features y is lowercase. Pretty sure this started with the scikit-learn code base.\nProbably a good idea to stick with Java conventions here; maybe a better choice would be featureBatch and labelBatch...", "author": "dhruvrajan", "createdAt": "2020-04-26T23:55:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NjczOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg0MDY4Mg==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415840682", "bodyText": "Actually I think this comes from maths notation where matrices are usually capital letters and vectors are usually lower case. But either way it's in strong conflict with how Java does it, and we should respect Java idioms.", "author": "Craigacp", "createdAt": "2020-04-27T14:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NjczOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTkwOTI0NA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415909244", "bodyText": "I've changed the docs to use features, labels, featureBatch, labelBatch, etc.", "author": "dhruvrajan", "createdAt": "2020-04-27T15:24:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NjczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NzIxMA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415397210", "bodyText": "should be List<Operand<?>> according to the documentation", "author": "karllessard", "createdAt": "2020-04-26T20:46:30Z", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/data/DatasetIterator.java", "diffHunk": "@@ -0,0 +1,242 @@\n+package org.tensorflow.framework.data;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Graph;\n+import org.tensorflow.Operand;\n+import org.tensorflow.Output;\n+import org.tensorflow.op.Op;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.tools.Shape;\n+\n+import java.util.List;\n+\n+/**\n+ * Represents the state of an iteration through\n+ * a tf.data Datset. DatasetIterator is not\n+ * a java.util.Iterator. In eager mode, `Dataset`\n+ * can be used as an Iterable, returning dataset\n+ * elements each iteration.\n+ *\n+ * <p>\n+ * Example: Iteration in graph mode.\n+ *\n+ * <pre>{@code\n+ *  // Create input tensors\n+ *  Operand<?> XTensor = tf.constant( ... );\n+ *  Operand<?> yTensor = tf.constant( ... );\n+ *\n+ *\n+ *  Dataset dataset = Dataset\n+ *          .fromTensorSlices(XTensor, yTensor);\n+ *          .batch(BATCH_SIZE);\n+ *\n+ *  DatasetIterator iterator = dataset.makeIterator();\n+ *  List<Output<?>> components = iterator.getNext();\n+ *  Operand<?> XBatch = components.get(0);\n+ *  Operand<?> yBatch = components.get(1);\n+ *\n+ *  // Build a TensorFlow graph that does something on each element.\n+ *  loss = computeModelLoss(X, y);\n+ *\n+ *  optimizer = ... // create an optimizer\n+ *  trainOp = optimizer.minimize(loss);\n+ *\n+ *  try (Session session = new Session(graph) {\n+ *      try {\n+ *          session.run(trainOp);\n+ *          ...\n+ *      } catch (IndexOutOfBoundsException e) {\n+ *          System.out.println(\"finished iterating.\");\n+ *          break;\n+ *      }\n+ *  }\n+ *\n+ * }</pre>\n+ * <p>\n+ * Example: Iteration in eager mode.\n+ *\n+ * <pre>{@code\n+ *  // Create input tensors\n+ *  Operand<?> XTensor = tf.constant( ... );\n+ *  Operand<?> yTensor = tf.constant( ... );\n+ *\n+ *  int BATCH_SIZE = ...\n+ *\n+ *  Dataset dataset = Dataset\n+ *          .fromTensorSlices(XTensor, yTensor)\n+ *          .batch(BATCH_SIZE);\n+ *  DatasetIterator iterator = dataset.makeIterator();\n+ *\n+ *  Optimizer optimizer = ... // create an optimizer\n+ *\n+ *  for (List<Output<?>> components : dataset) {\n+ *      Operand<?> XBatch = components.get(0);\n+ *      Operand<?> yBatch = components.get(1);\n+ *\n+ *      loss = computeModelLoss(X, y);\n+ *      trainOp = optimizer.minimize(loss);\n+ *  }\n+ * }</pre>\n+ */\n+public class DatasetIterator {\n+  public static final String EMPTY_SHARED_NAME = \"\";\n+\n+  private Ops tf;\n+\n+  private Operand<?> iteratorResource;\n+  private Op initializer;\n+\n+  private List<DataType<?>> outputTypes;\n+  private List<Shape> outputShapes;\n+\n+  /**\n+   * @param tf               Ops accessor corresponding to the same `ExecutionEnvironment`\n+   *                         as the `iteratorResource`.\n+   * @param iteratorResource An Operand representing the iterator\n+   *                         (e.g. constructed from `tf.data.iterator` or\n+   *                         `tf.data.anonymousIterator`)\n+   * @param initializer      An `Op` that should be run to initialize this iterator\n+   * @param outputTypes      A list of `DataType` objects corresponding to the\n+   *                         types of each component of a dataset element.\n+   * @param outputShapes     A list of `Shape` objects corresponding to the\n+   *                         shapes of each componenet of a dataset element.\n+   */\n+  private DatasetIterator(Ops tf, Operand<?> iteratorResource,\n+                          Op initializer,\n+                          List<DataType<?>> outputTypes,\n+                          List<Shape> outputShapes) {\n+\n+    this.tf = tf;\n+    this.iteratorResource = iteratorResource;\n+    this.initializer = initializer;\n+    this.outputTypes = outputTypes;\n+    this.outputShapes = outputShapes;\n+  }\n+\n+  private DatasetIterator(Ops tf, Operand<?> iteratorResource,\n+                          List<DataType<?>> outputTypes,\n+                          List<Shape> outputShapes) {\n+    this.tf = tf;\n+    this.iteratorResource = iteratorResource;\n+    this.outputTypes = outputTypes;\n+    this.outputShapes = outputShapes;\n+  }\n+\n+  /**\n+   * Returns a list of `Operand<?>` representing the components of the\n+   * next dataset element.\n+   * <p>\n+   * In graph mode, call this method once, and use its result as input\n+   * to another computation. Then in the training loop, on successive calls\n+   * to session.run(), successive dataset elements will be retrieved through\n+   * these components.\n+   * <p>\n+   * In eager mode, each time this method is called, the next dataset\n+   * element will be returned. (This is done automatically by iterating\n+   * through `Dataset` as a Java `Iterable`).\n+   *\n+   * @return A `List<Operand<?>>` representing dataset element components.\n+   */\n+  public List<Output<?>> getNext() {", "originalCommit": "41d1b563c857107b549c80bc16a3c2cdf52a275f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQzMjEzMA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415432130", "bodyText": "These should be List<Output<?>>. We could change them all to List<Operand<?>> if we modify the IteratorGetNext classes; since these are generated I wasn't sure how to do that.\nThink that change would be worth it?", "author": "dhruvrajan", "createdAt": "2020-04-26T23:57:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NzIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTkwOTUzMg==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415909532", "bodyText": "These all have been changed to List<Operand<?>>", "author": "dhruvrajan", "createdAt": "2020-04-27T15:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NzIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NzQwNg==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415397406", "bodyText": "Wrong doc, this is a copy of getNext()", "author": "karllessard", "createdAt": "2020-04-26T20:47:37Z", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/data/DatasetIterator.java", "diffHunk": "@@ -0,0 +1,242 @@\n+package org.tensorflow.framework.data;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Graph;\n+import org.tensorflow.Operand;\n+import org.tensorflow.Output;\n+import org.tensorflow.op.Op;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.tools.Shape;\n+\n+import java.util.List;\n+\n+/**\n+ * Represents the state of an iteration through\n+ * a tf.data Datset. DatasetIterator is not\n+ * a java.util.Iterator. In eager mode, `Dataset`\n+ * can be used as an Iterable, returning dataset\n+ * elements each iteration.\n+ *\n+ * <p>\n+ * Example: Iteration in graph mode.\n+ *\n+ * <pre>{@code\n+ *  // Create input tensors\n+ *  Operand<?> XTensor = tf.constant( ... );\n+ *  Operand<?> yTensor = tf.constant( ... );\n+ *\n+ *\n+ *  Dataset dataset = Dataset\n+ *          .fromTensorSlices(XTensor, yTensor);\n+ *          .batch(BATCH_SIZE);\n+ *\n+ *  DatasetIterator iterator = dataset.makeIterator();\n+ *  List<Output<?>> components = iterator.getNext();\n+ *  Operand<?> XBatch = components.get(0);\n+ *  Operand<?> yBatch = components.get(1);\n+ *\n+ *  // Build a TensorFlow graph that does something on each element.\n+ *  loss = computeModelLoss(X, y);\n+ *\n+ *  optimizer = ... // create an optimizer\n+ *  trainOp = optimizer.minimize(loss);\n+ *\n+ *  try (Session session = new Session(graph) {\n+ *      try {\n+ *          session.run(trainOp);\n+ *          ...\n+ *      } catch (IndexOutOfBoundsException e) {\n+ *          System.out.println(\"finished iterating.\");\n+ *          break;\n+ *      }\n+ *  }\n+ *\n+ * }</pre>\n+ * <p>\n+ * Example: Iteration in eager mode.\n+ *\n+ * <pre>{@code\n+ *  // Create input tensors\n+ *  Operand<?> XTensor = tf.constant( ... );\n+ *  Operand<?> yTensor = tf.constant( ... );\n+ *\n+ *  int BATCH_SIZE = ...\n+ *\n+ *  Dataset dataset = Dataset\n+ *          .fromTensorSlices(XTensor, yTensor)\n+ *          .batch(BATCH_SIZE);\n+ *  DatasetIterator iterator = dataset.makeIterator();\n+ *\n+ *  Optimizer optimizer = ... // create an optimizer\n+ *\n+ *  for (List<Output<?>> components : dataset) {\n+ *      Operand<?> XBatch = components.get(0);\n+ *      Operand<?> yBatch = components.get(1);\n+ *\n+ *      loss = computeModelLoss(X, y);\n+ *      trainOp = optimizer.minimize(loss);\n+ *  }\n+ * }</pre>\n+ */\n+public class DatasetIterator {\n+  public static final String EMPTY_SHARED_NAME = \"\";\n+\n+  private Ops tf;\n+\n+  private Operand<?> iteratorResource;\n+  private Op initializer;\n+\n+  private List<DataType<?>> outputTypes;\n+  private List<Shape> outputShapes;\n+\n+  /**\n+   * @param tf               Ops accessor corresponding to the same `ExecutionEnvironment`\n+   *                         as the `iteratorResource`.\n+   * @param iteratorResource An Operand representing the iterator\n+   *                         (e.g. constructed from `tf.data.iterator` or\n+   *                         `tf.data.anonymousIterator`)\n+   * @param initializer      An `Op` that should be run to initialize this iterator\n+   * @param outputTypes      A list of `DataType` objects corresponding to the\n+   *                         types of each component of a dataset element.\n+   * @param outputShapes     A list of `Shape` objects corresponding to the\n+   *                         shapes of each componenet of a dataset element.\n+   */\n+  private DatasetIterator(Ops tf, Operand<?> iteratorResource,\n+                          Op initializer,\n+                          List<DataType<?>> outputTypes,\n+                          List<Shape> outputShapes) {\n+\n+    this.tf = tf;\n+    this.iteratorResource = iteratorResource;\n+    this.initializer = initializer;\n+    this.outputTypes = outputTypes;\n+    this.outputShapes = outputShapes;\n+  }\n+\n+  private DatasetIterator(Ops tf, Operand<?> iteratorResource,\n+                          List<DataType<?>> outputTypes,\n+                          List<Shape> outputShapes) {\n+    this.tf = tf;\n+    this.iteratorResource = iteratorResource;\n+    this.outputTypes = outputTypes;\n+    this.outputShapes = outputShapes;\n+  }\n+\n+  /**\n+   * Returns a list of `Operand<?>` representing the components of the\n+   * next dataset element.\n+   * <p>\n+   * In graph mode, call this method once, and use its result as input\n+   * to another computation. Then in the training loop, on successive calls\n+   * to session.run(), successive dataset elements will be retrieved through\n+   * these components.\n+   * <p>\n+   * In eager mode, each time this method is called, the next dataset\n+   * element will be returned. (This is done automatically by iterating\n+   * through `Dataset` as a Java `Iterable`).\n+   *\n+   * @return A `List<Operand<?>>` representing dataset element components.\n+   */\n+  public List<Output<?>> getNext() {\n+    return tf.data.iteratorGetNext(getIteratorResource(),\n+        getOutputTypes(), getOutputShapes()).components();\n+  }\n+\n+  /**\n+   * Returns a list of `Operand<?>` representing the components of the\n+   * next dataset element.\n+   * <p>\n+   * In graph mode, call this method once, and use its result as input\n+   * to another computation. Then in the training loop, on successive calls\n+   * to session.run(), successive dataset elements will be retrieved through\n+   * these components.\n+   * <p>\n+   * In eager mode, each time this method is called, the next dataset\n+   * element will be returned. (This is done automatically by iterating\n+   * through `Dataset` as a Java `Iterable`).\n+   *\n+   * @return A `List<Operand<?>>` representing dataset element components.\n+   */", "originalCommit": "41d1b563c857107b549c80bc16a3c2cdf52a275f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQzMjE2Nw==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415432167", "bodyText": "Added DatasetOptional docs here.", "author": "dhruvrajan", "createdAt": "2020-04-26T23:57:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NzQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NzUxMQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415397511", "bodyText": "extra line", "author": "karllessard", "createdAt": "2020-04-26T20:48:32Z", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/data/DatasetIterator.java", "diffHunk": "@@ -0,0 +1,242 @@\n+package org.tensorflow.framework.data;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Graph;\n+import org.tensorflow.Operand;\n+import org.tensorflow.Output;\n+import org.tensorflow.op.Op;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.tools.Shape;\n+\n+import java.util.List;\n+\n+/**\n+ * Represents the state of an iteration through\n+ * a tf.data Datset. DatasetIterator is not\n+ * a java.util.Iterator. In eager mode, `Dataset`\n+ * can be used as an Iterable, returning dataset\n+ * elements each iteration.\n+ *\n+ * <p>\n+ * Example: Iteration in graph mode.\n+ *\n+ * <pre>{@code\n+ *  // Create input tensors\n+ *  Operand<?> XTensor = tf.constant( ... );\n+ *  Operand<?> yTensor = tf.constant( ... );\n+ *\n+ *\n+ *  Dataset dataset = Dataset\n+ *          .fromTensorSlices(XTensor, yTensor);\n+ *          .batch(BATCH_SIZE);\n+ *\n+ *  DatasetIterator iterator = dataset.makeIterator();\n+ *  List<Output<?>> components = iterator.getNext();\n+ *  Operand<?> XBatch = components.get(0);\n+ *  Operand<?> yBatch = components.get(1);\n+ *\n+ *  // Build a TensorFlow graph that does something on each element.\n+ *  loss = computeModelLoss(X, y);\n+ *\n+ *  optimizer = ... // create an optimizer\n+ *  trainOp = optimizer.minimize(loss);\n+ *\n+ *  try (Session session = new Session(graph) {\n+ *      try {\n+ *          session.run(trainOp);\n+ *          ...\n+ *      } catch (IndexOutOfBoundsException e) {\n+ *          System.out.println(\"finished iterating.\");\n+ *          break;\n+ *      }\n+ *  }\n+ *\n+ * }</pre>\n+ * <p>\n+ * Example: Iteration in eager mode.\n+ *\n+ * <pre>{@code\n+ *  // Create input tensors\n+ *  Operand<?> XTensor = tf.constant( ... );\n+ *  Operand<?> yTensor = tf.constant( ... );\n+ *\n+ *  int BATCH_SIZE = ...\n+ *\n+ *  Dataset dataset = Dataset\n+ *          .fromTensorSlices(XTensor, yTensor)\n+ *          .batch(BATCH_SIZE);\n+ *  DatasetIterator iterator = dataset.makeIterator();\n+ *\n+ *  Optimizer optimizer = ... // create an optimizer\n+ *\n+ *  for (List<Output<?>> components : dataset) {\n+ *      Operand<?> XBatch = components.get(0);\n+ *      Operand<?> yBatch = components.get(1);\n+ *\n+ *      loss = computeModelLoss(X, y);\n+ *      trainOp = optimizer.minimize(loss);\n+ *  }\n+ * }</pre>\n+ */\n+public class DatasetIterator {\n+  public static final String EMPTY_SHARED_NAME = \"\";\n+\n+  private Ops tf;\n+\n+  private Operand<?> iteratorResource;\n+  private Op initializer;\n+\n+  private List<DataType<?>> outputTypes;\n+  private List<Shape> outputShapes;\n+\n+  /**\n+   * @param tf               Ops accessor corresponding to the same `ExecutionEnvironment`\n+   *                         as the `iteratorResource`.\n+   * @param iteratorResource An Operand representing the iterator\n+   *                         (e.g. constructed from `tf.data.iterator` or\n+   *                         `tf.data.anonymousIterator`)\n+   * @param initializer      An `Op` that should be run to initialize this iterator\n+   * @param outputTypes      A list of `DataType` objects corresponding to the\n+   *                         types of each component of a dataset element.\n+   * @param outputShapes     A list of `Shape` objects corresponding to the\n+   *                         shapes of each componenet of a dataset element.\n+   */\n+  private DatasetIterator(Ops tf, Operand<?> iteratorResource,\n+                          Op initializer,\n+                          List<DataType<?>> outputTypes,\n+                          List<Shape> outputShapes) {\n+\n+    this.tf = tf;\n+    this.iteratorResource = iteratorResource;\n+    this.initializer = initializer;\n+    this.outputTypes = outputTypes;\n+    this.outputShapes = outputShapes;\n+  }\n+\n+  private DatasetIterator(Ops tf, Operand<?> iteratorResource,\n+                          List<DataType<?>> outputTypes,\n+                          List<Shape> outputShapes) {\n+    this.tf = tf;\n+    this.iteratorResource = iteratorResource;\n+    this.outputTypes = outputTypes;\n+    this.outputShapes = outputShapes;\n+  }\n+\n+  /**\n+   * Returns a list of `Operand<?>` representing the components of the\n+   * next dataset element.\n+   * <p>\n+   * In graph mode, call this method once, and use its result as input\n+   * to another computation. Then in the training loop, on successive calls\n+   * to session.run(), successive dataset elements will be retrieved through\n+   * these components.\n+   * <p>\n+   * In eager mode, each time this method is called, the next dataset\n+   * element will be returned. (This is done automatically by iterating\n+   * through `Dataset` as a Java `Iterable`).\n+   *\n+   * @return A `List<Operand<?>>` representing dataset element components.\n+   */\n+  public List<Output<?>> getNext() {\n+    return tf.data.iteratorGetNext(getIteratorResource(),\n+        getOutputTypes(), getOutputShapes()).components();\n+  }\n+\n+  /**\n+   * Returns a list of `Operand<?>` representing the components of the\n+   * next dataset element.\n+   * <p>\n+   * In graph mode, call this method once, and use its result as input\n+   * to another computation. Then in the training loop, on successive calls\n+   * to session.run(), successive dataset elements will be retrieved through\n+   * these components.\n+   * <p>\n+   * In eager mode, each time this method is called, the next dataset\n+   * element will be returned. (This is done automatically by iterating\n+   * through `Dataset` as a Java `Iterable`).\n+   *\n+   * @return A `List<Operand<?>>` representing dataset element components.\n+   */\n+  public DatasetOptional getNextAsOptional() {\n+    Operand<?> optionalVariant = tf.data.iteratorGetNextAsOptional(\n+        getIteratorResource(),\n+        getOutputTypes(),\n+        getOutputShapes()).optional();\n+    return new DatasetOptional(tf, optionalVariant, outputTypes,\n+        outputShapes);\n+  }\n+\n+  /**\n+   * Creates and returns a TF `Op` that can be run to initialize\n+   * this iterator on a dataset. The dataset must have a structure\n+   * (outputTypes, outputShapes) that match this iterator, and\n+   * share the same ExecutionEnvironment as this iterator.\n+   * <p>\n+   * When this `Op` is run, this iterator will be \"re-initialized\" at\n+   * the first element of the input dataset.\n+   * <p>\n+   * In eager mode, the op will be run automatically as part of\n+   * a call to `makeIterator`.\n+   *\n+   * @param dataset An `org.tensorflow.data.Dataset` to initialize this\n+   *                iterator on.\n+   * @return A TF `Op` that can be used to initialize this iterator on the\n+   * dataset.\n+   * @throws IllegalArgumentException if the dataset's ExecutionEnvironment or\n+   *                                  structure doesn't match this iterator.\n+   */\n+  public Op makeInitializer(Dataset dataset) {\n+    if (tf.scope().env() != dataset.tf.scope().env()) {\n+      throw new IllegalArgumentException(\"Dataset must share the same\" +\n+          \"ExecutionEnvironment as this iterator.\");\n+    }\n+\n+    if (!dataset.getOutputShapes().equals(getOutputShapes())\n+        || !dataset.getOutputTypes().equals(getOutputTypes())) {\n+", "originalCommit": "41d1b563c857107b549c80bc16a3c2cdf52a275f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQzMjIxOA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415432218", "bodyText": "Fixed, I think with google java formatting.", "author": "dhruvrajan", "createdAt": "2020-04-26T23:57:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NzUxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxOTY3OQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r417019679", "bodyText": "extra-line is still there but whatever, not important  :)", "author": "karllessard", "createdAt": "2020-04-29T01:29:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NzUxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NzczNA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415397734", "bodyText": "Missing copyrights (and for all new files in this PR)", "author": "karllessard", "createdAt": "2020-04-26T20:49:32Z", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/data/DatasetIterator.java", "diffHunk": "@@ -0,0 +1,242 @@\n+package org.tensorflow.framework.data;", "originalCommit": "41d1b563c857107b549c80bc16a3c2cdf52a275f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQzMjMwNA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415432304", "bodyText": "Added copyrights to all the files! Let me know if it's done right", "author": "dhruvrajan", "createdAt": "2020-04-26T23:58:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5NzczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5OTI4OQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415399289", "bodyText": "Where in the code do you use this new constructor? is it really required?", "author": "karllessard", "createdAt": "2020-04-26T20:57:17Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/Shape.java", "diffHunk": "@@ -61,6 +65,15 @@ public static Shape of(long... dimensionSizes) {\n     return new Shape(dimensionSizes);\n   }\n \n+  public static Shape of(long firstDimensionSize, long[] otherDimensionSizes) {\n+    long[] dimensionSizes = new long[otherDimensionSizes.length + 1];\n+    dimensionSizes[0] = firstDimensionSize;\n+    System.arraycopy(\n+        otherDimensionSizes, 0, dimensionSizes, 1, otherDimensionSizes.length);\n+\n+    return Shape.of(dimensionSizes);\n+  }", "originalCommit": "41d1b563c857107b549c80bc16a3c2cdf52a275f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQzNTMxNg==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r415435316", "bodyText": "I'm using it in Dataset.batch. It's just a bit of a convenience so that you can append to the beginning of an existing Shape.\nI currently have this statement:\nList<Shape> batchOutputShapes =\n        outputShapes.stream().map(s -> Shape.of(-1, s.asArray())).collect(Collectors.toList());\n\nwhich we could replace with something like this, if we remove the constructor:\nList<Shape> batchOutputShapes =\n        outputShapes.stream()\n            .map(\n                shape -> {\n                  long[] newShape = new long[shape.numDimensions() + 1];\n                  newShape[0] = -1;\n                  System.arraycopy(shape.asArray(), 0, newShape, 1, shape.numDimensions());\n                  return Shape.of(newShape);\n                })\n            .collect(Collectors.toList());", "author": "dhruvrajan", "createdAt": "2020-04-27T00:13:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5OTI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTE4Mg==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r417021182", "bodyText": "But if the main reason is to add an extra dimension to an existing shape, I would prefer having a method called Shape prepend(dimensionSizes) or something like that than a new constructor.\nWe should be able also to \"reshape\" a shape ultimately (i.e. changing [2, 3, 2] to [2, 1, 2, 3]) with a utility called Shape reshape(dimensionsSizes)... but it sounds that in your case, prepend would be a better pick? Like you did with head and tail?", "author": "karllessard", "createdAt": "2020-04-29T01:35:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5OTI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ4NDk2OA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r417484968", "bodyText": "Makes sense, prepend() is pretty nice, I replaced the constructor.", "author": "dhruvrajan", "createdAt": "2020-04-29T17:24:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5OTI4OQ=="}], "type": "inlineReview"}, {"oid": "27531333ac3d3664b02b73fe904d0bb96e74de46", "url": "https://github.com/tensorflow/java/commit/27531333ac3d3664b02b73fe904d0bb96e74de46", "message": ":wqremove unnecessary files, add copyrights, format with google java style, update documentation", "committedDate": "2020-04-26T23:31:03Z", "type": "forcePushed"}, {"oid": "3fd9b3f555b9ffa32362feb0d8ddc5bc0839a909", "url": "https://github.com/tensorflow/java/commit/3fd9b3f555b9ffa32362feb0d8ddc5bc0839a909", "message": ":wqremove unnecessary files, add copyrights, format with google java style, update documentation", "committedDate": "2020-04-27T00:32:00Z", "type": "forcePushed"}, {"oid": "48fd49ea88f354386efdce776560dda8f5b1f677", "url": "https://github.com/tensorflow/java/commit/48fd49ea88f354386efdce776560dda8f5b1f677", "message": ":wqremove unnecessary files, add copyrights, format with google java style, update documentation", "committedDate": "2020-04-27T00:33:13Z", "type": "forcePushed"}, {"oid": "43f6be7a74403c3c4cb9d42beed089b325b0bb46", "url": "https://github.com/tensorflow/java/commit/43f6be7a74403c3c4cb9d42beed089b325b0bb46", "message": ":wqremove unnecessary files, add copyrights, format with google java style, update documentation", "committedDate": "2020-04-27T00:35:05Z", "type": "forcePushed"}, {"oid": "a5fdab794291a33048fad1ddea3c0113209b0dad", "url": "https://github.com/tensorflow/java/commit/a5fdab794291a33048fad1ddea3c0113209b0dad", "message": "Convert batches from List<Output<?>> to List<Operand<?>>", "committedDate": "2020-04-27T00:56:59Z", "type": "forcePushed"}, {"oid": "dc662469d9eb52a8cc835bf15f98ff24b0a5dd50", "url": "https://github.com/tensorflow/java/commit/dc662469d9eb52a8cc835bf15f98ff24b0a5dd50", "message": "Convert batches from List<Output<?>> to List<Operand<?>>", "committedDate": "2020-04-27T15:22:29Z", "type": "forcePushed"}, {"oid": "a7d4d0e992c6ff0525f2cada08d34cd4b20d3cdc", "url": "https://github.com/tensorflow/java/commit/a7d4d0e992c6ff0525f2cada08d34cd4b20d3cdc", "message": "Convert batches from List<Output<?>> to List<Operand<?>>", "committedDate": "2020-04-27T15:23:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxODY3MQ==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r417018671", "bodyText": "Just noticed this, if we auto-close tensors resulting from a run, we should allow the user to retain a reference to one or more of them so the tensor will survive beyond the life of Run if needed.\nThis could be done by adding a utility method like Tensor.retain() which will call tensorHandle.retainReference() internally... or we remove this change from this actual PR and do it later, your choice.", "author": "karllessard", "createdAt": "2020-04-29T01:24:48Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Session.java", "diffHunk": "@@ -485,6 +475,26 @@ public void run(Op op) {\n      * this field may be replaced by more type-safe equivalents at any time.\n      */\n     public RunMetadata metadata;\n+\n+    Run(List<Tensor<?>> outputs, RunMetadata metadata) {\n+      this.outputs = outputs;\n+      this.metadata = metadata;\n+    }\n+\n+    Run(List<Tensor<?>> outputs) {\n+      this.outputs = outputs;\n+    }\n+\n+    public Tensor<?> get(int index) {\n+      return this.outputs.get(index);\n+    }\n+\n+    @Override\n+    public void close() {\n+      for (Tensor<?> tensor : this.outputs) {\n+        tensor.close();", "originalCommit": "a7d4d0e992c6ff0525f2cada08d34cd4b20d3cdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzNjQ2Nw==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r417436467", "bodyText": "Great point! I think it makes sense to handle this outside this PR, as this functionality isn't used here. I reverted Session.java to the (new) master.", "author": "dhruvrajan", "createdAt": "2020-04-29T16:10:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxODY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxOTMxMw==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r417019313", "bodyText": "AFAIK, you don't work at Oracle :)\nI suggest you change all copyrights to Copyright 2020 The TensorFlow Authors. All Rights Reserved., like most of the files in the core module, that is what I'm using too.", "author": "karllessard", "createdAt": "2020-04-29T01:27:30Z", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/data/Dataset.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\r\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\r", "originalCommit": "a7d4d0e992c6ff0525f2cada08d34cd4b20d3cdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzODIwNA==", "url": "https://github.com/tensorflow/java/pull/30#discussion_r417438204", "bodyText": "Thanks for catching! I'll make that change.", "author": "dhruvrajan", "createdAt": "2020-04-29T16:12:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxOTMxMw=="}], "type": "inlineReview"}, {"oid": "b806fcb067d2bf42e03a16ae81fd00f13ebd36e0", "url": "https://github.com/tensorflow/java/commit/b806fcb067d2bf42e03a16ae81fd00f13ebd36e0", "message": "initial tf.data mvn project", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "ab1d31fc14beee53eaa9c8aab2677d7ed6ed25fc", "url": "https://github.com/tensorflow/java/commit/ab1d31fc14beee53eaa9c8aab2677d7ed6ed25fc", "message": "make relevant data ops visible", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "89bd94fd6e2bb1e9cb7c3c6398581975339b3db5", "url": "https://github.com/tensorflow/java/commit/89bd94fd6e2bb1e9cb7c3c6398581975339b3db5", "message": "TensorFlow Data examples with batching working in graph / eager mode", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "2bb5e528669bc7fc8cdd298052e02e25f553ea60", "url": "https://github.com/tensorflow/java/commit/2bb5e528669bc7fc8cdd298052e02e25f553ea60", "message": "adding take and skip dataset", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "27bb08152a254e657b5552458be980053c8c86b0", "url": "https://github.com/tensorflow/java/commit/27bb08152a254e657b5552458be980053c8c86b0", "message": "added tests for tf dataset iteration", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "f51b52ec3a9df57f3aa9a2ea5ee1cda5c9c1f3db", "url": "https://github.com/tensorflow/java/commit/f51b52ec3a9df57f3aa9a2ea5ee1cda5c9c1f3db", "message": "added tests for all dataset types (skip, take, batch)", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "a5054cf6fbc44a2d4ddff9b227f8f3fe2abb5e5e", "url": "https://github.com/tensorflow/java/commit/a5054cf6fbc44a2d4ddff9b227f8f3fe2abb5e5e", "message": "adding readme for tf data", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "bc11142e55a3aed127db4e819299f68707cf7c45", "url": "https://github.com/tensorflow/java/commit/bc11142e55a3aed127db4e819299f68707cf7c45", "message": "adding readme for tf data", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "a94ff974ec291ec2e7c2a8043de38accdd557496", "url": "https://github.com/tensorflow/java/commit/a94ff974ec291ec2e7c2a8043de38accdd557496", "message": "oneshotiterator class", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "107e2b45f51657294b446d15bea50ee03f3924e3", "url": "https://github.com/tensorflow/java/commit/107e2b45f51657294b446d15bea50ee03f3924e3", "message": "updated .gitignore for vs code", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "7e727b7c5cdbe5914e8e3740853d5a5e93852344", "url": "https://github.com/tensorflow/java/commit/7e727b7c5cdbe5914e8e3740853d5a5e93852344", "message": "revert pom.xml files to master version", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "2a8a2c1dd7085fdb0d865afcd84dba0a76574cc0", "url": "https://github.com/tensorflow/java/commit/2a8a2c1dd7085fdb0d865afcd84dba0a76574cc0", "message": "committing pom", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "83e1f893b3ffceb2777c2d616a00d26b62320b7e", "url": "https://github.com/tensorflow/java/commit/83e1f893b3ffceb2777c2d616a00d26b62320b7e", "message": "remove target from .gitignore", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "2b74d96cfbf223b7b2a94c9347a15f1d268fac87", "url": "https://github.com/tensorflow/java/commit/2b74d96cfbf223b7b2a94c9347a15f1d268fac87", "message": "tf data finds jni resource", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "17c56426601258b4b6dd3e21883d6b8e553b9fd5", "url": "https://github.com/tensorflow/java/commit/17c56426601258b4b6dd3e21883d6b8e553b9fd5", "message": "make dataset ops visible", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "0dfa0ae7a092e5ea45f4ba072c6ec30ad4fc7b00", "url": "https://github.com/tensorflow/java/commit/0dfa0ae7a092e5ea45f4ba072c6ec30ad4fc7b00", "message": "fix dataset issues; comment keras files", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "c357b2178b56427e68913ad4fdd2529f82304c67", "url": "https://github.com/tensorflow/java/commit/c357b2178b56427e68913ad4fdd2529f82304c67", "message": "tf data tests pass", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "37c82617e778c84a88b48553ef031dc327ecc298", "url": "https://github.com/tensorflow/java/commit/37c82617e778c84a88b48553ef031dc327ecc298", "message": "working tests in vscode", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "39e53c2a66ecbc53a6fa84a419d629fe9924d4c5", "url": "https://github.com/tensorflow/java/commit/39e53c2a66ecbc53a6fa84a419d629fe9924d4c5", "message": "add range dataset", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "0773496a0eb5d5563d595f6bca6daad6a6a05f5c", "url": "https://github.com/tensorflow/java/commit/0773496a0eb5d5563d595f6bca6daad6a6a05f5c", "message": "refactor mnist data loader", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "ef8419aa4a73a14bb301175c8b9682cd6aa881e3", "url": "https://github.com/tensorflow/java/commit/ef8419aa4a73a14bb301175c8b9682cd6aa881e3", "message": "add 'expect' method to Output object", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "8ee7759665640efbc8b711eaa8f7c817d58f3b44", "url": "https://github.com/tensorflow/java/commit/8ee7759665640efbc8b711eaa8f7c817d58f3b44", "message": "refactor", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "64df39b650b0a08771b70092c34de79c19cf5dc0", "url": "https://github.com/tensorflow/java/commit/64df39b650b0a08771b70092c34de79c19cf5dc0", "message": "revert change to base tensorfow file", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "919a31c63b527f5bd378fdd0f5a857f5d004b280", "url": "https://github.com/tensorflow/java/commit/919a31c63b527f5bd378fdd0f5a857f5d004b280", "message": "working on data readme", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "e6dc8eaa9e311a5b974c21e96f989723155c56ec", "url": "https://github.com/tensorflow/java/commit/e6dc8eaa9e311a5b974c21e96f989723155c56ec", "message": "updated tf.data README", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "62b5050af817a9a2fe5752ef7433814901bc5087", "url": "https://github.com/tensorflow/java/commit/62b5050af817a9a2fe5752ef7433814901bc5087", "message": "move pair and tuple2 to utils", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "41f3c294bb986da1c55e7060c75d12a28b3bf7db", "url": "https://github.com/tensorflow/java/commit/41f3c294bb986da1c55e7060c75d12a28b3bf7db", "message": "utils pom files", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "0920e56fa6721d85d781817c87f4fb7ed3c61f63", "url": "https://github.com/tensorflow/java/commit/0920e56fa6721d85d781817c87f4fb7ed3c61f63", "message": "Fix pom structure, add back oneshotiterator", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "f03419b54f71a7732fad4a19bd2595ad2215026a", "url": "https://github.com/tensorflow/java/commit/f03419b54f71a7732fad4a19bd2595ad2215026a", "message": "updated README", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "2811294fa7652ead1ce1ac441af925811db39c11", "url": "https://github.com/tensorflow/java/commit/2811294fa7652ead1ce1ac441af925811db39c11", "message": "remove shuffle and range dataset", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "844b223989bda6670279917616aeb9c02aa0f5a9", "url": "https://github.com/tensorflow/java/commit/844b223989bda6670279917616aeb9c02aa0f5a9", "message": "rebase on new tensorflow commit", "committedDate": "2020-04-29T15:48:23Z", "type": "commit"}, {"oid": "6e6e763717a5fed3fd762735e0cc1a331541bf8e", "url": "https://github.com/tensorflow/java/commit/6e6e763717a5fed3fd762735e0cc1a331541bf8e", "message": "fixed mvn compile", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "ed9b405a921a8d9d142aaa9b45c8bda4287ef80f", "url": "https://github.com/tensorflow/java/commit/ed9b405a921a8d9d142aaa9b45c8bda4287ef80f", "message": "make relevant data ops visible", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "fca73ff129ca67a9f920bac64b5e9e34301c4e08", "url": "https://github.com/tensorflow/java/commit/fca73ff129ca67a9f920bac64b5e9e34301c4e08", "message": "TensorFlow Data examples with batching working in graph / eager mode", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "47fd5c43c4832b4129f06b8f317d2f95a68c5f65", "url": "https://github.com/tensorflow/java/commit/47fd5c43c4832b4129f06b8f317d2f95a68c5f65", "message": "adding take and skip dataset", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "16c75dd1a825bf47dc72ae4a226b4ea0b94c1a3e", "url": "https://github.com/tensorflow/java/commit/16c75dd1a825bf47dc72ae4a226b4ea0b94c1a3e", "message": "added tests for tf dataset iteration", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "219bb69cf4eacc7937f76576caf39322e81be694", "url": "https://github.com/tensorflow/java/commit/219bb69cf4eacc7937f76576caf39322e81be694", "message": "added tests for all dataset types (skip, take, batch)", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "62a96ac19f766652ee7a16981312895519312abc", "url": "https://github.com/tensorflow/java/commit/62a96ac19f766652ee7a16981312895519312abc", "message": "oneshotiterator class", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "94362d9a08f5ef8ac3fdf4c723e90999204c7a37", "url": "https://github.com/tensorflow/java/commit/94362d9a08f5ef8ac3fdf4c723e90999204c7a37", "message": "tf data finds jni resource", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "77de569c20b7565df12dc63e2c63d736b8575b95", "url": "https://github.com/tensorflow/java/commit/77de569c20b7565df12dc63e2c63d736b8575b95", "message": "fix dataset issues; comment keras files", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "26c51706a8dd418d4f4de141fe9a0738c8e12202", "url": "https://github.com/tensorflow/java/commit/26c51706a8dd418d4f4de141fe9a0738c8e12202", "message": "tf data tests pass", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "2baf8ca4bcd5eecac8eb88f4bdc02c4dce2d401e", "url": "https://github.com/tensorflow/java/commit/2baf8ca4bcd5eecac8eb88f4bdc02c4dce2d401e", "message": "working tests in vscode", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "0a19df75032c9960f8ae6a2643eb31a579dfdc58", "url": "https://github.com/tensorflow/java/commit/0a19df75032c9960f8ae6a2643eb31a579dfdc58", "message": "add range dataset", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "d9a1e47a731127061364620bea099b900598657d", "url": "https://github.com/tensorflow/java/commit/d9a1e47a731127061364620bea099b900598657d", "message": "refactor mnist data loader", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "1959618bad4d3c02ca39da4dd9fb8025900668f4", "url": "https://github.com/tensorflow/java/commit/1959618bad4d3c02ca39da4dd9fb8025900668f4", "message": "refactor", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "5c02d03b8ace2b3628ad0ea54bd8f48c98c7bdd4", "url": "https://github.com/tensorflow/java/commit/5c02d03b8ace2b3628ad0ea54bd8f48c98c7bdd4", "message": "revert change to base tensorfow file", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "20e637390a22beb606b3756a5d4b269d3a268e5a", "url": "https://github.com/tensorflow/java/commit/20e637390a22beb606b3756a5d4b269d3a268e5a", "message": "working on data readme", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "db2cbf8116e1e140ed41cd43bad298054d76087e", "url": "https://github.com/tensorflow/java/commit/db2cbf8116e1e140ed41cd43bad298054d76087e", "message": "updated tf.data README", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "9637b9655b7e895bd903a455ffcb283e801a8e75", "url": "https://github.com/tensorflow/java/commit/9637b9655b7e895bd903a455ffcb283e801a8e75", "message": "move pair and tuple2 to utils", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "593810f6e4ea19a260a879fcfd2551c6ec1226e9", "url": "https://github.com/tensorflow/java/commit/593810f6e4ea19a260a879fcfd2551c6ec1226e9", "message": "utils pom files", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "db82c3375202faa9f181be10f9f9d731bb3a42a9", "url": "https://github.com/tensorflow/java/commit/db82c3375202faa9f181be10f9f9d731bb3a42a9", "message": "Fix pom structure, add back oneshotiterator", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "9c270b45da3212cf6f6e45902b818fb7bbf0a0e8", "url": "https://github.com/tensorflow/java/commit/9c270b45da3212cf6f6e45902b818fb7bbf0a0e8", "message": "remove shuffle and range dataset", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "439af82f902003610d279d8066deda57d2b8794d", "url": "https://github.com/tensorflow/java/commit/439af82f902003610d279d8066deda57d2b8794d", "message": "rebase on new tensorflow commit", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "950d258f5d2563dbed78e665a6811ee47b219e9d", "url": "https://github.com/tensorflow/java/commit/950d258f5d2563dbed78e665a6811ee47b219e9d", "message": "ensure tests pass, rebase on newest changes", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "782601ccccae1ad6711ec2320d0aa9bbbae738e4", "url": "https://github.com/tensorflow/java/commit/782601ccccae1ad6711ec2320d0aa9bbbae738e4", "message": "refactor", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "5ddba23ef65d94963214e6bdef643f073f28d1a0", "url": "https://github.com/tensorflow/java/commit/5ddba23ef65d94963214e6bdef643f073f28d1a0", "message": "remove tensorflow utils", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "23d87dbfe038de8f3256ba1566477fd5f1bd4bd5", "url": "https://github.com/tensorflow/java/commit/23d87dbfe038de8f3256ba1566477fd5f1bd4bd5", "message": "fix compilation", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "9f64c2e37d178c78f3d516431b425878bd8506f8", "url": "https://github.com/tensorflow/java/commit/9f64c2e37d178c78f3d516431b425878bd8506f8", "message": "fix compilation", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "8e70d331f93192d2789d1a9072b9d6771fd9d354", "url": "https://github.com/tensorflow/java/commit/8e70d331f93192d2789d1a9072b9d6771fd9d354", "message": "add Iterator class for iterating over datasets in eager and graph  mode.", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "9b79be345591f4cb71b37a73abf22de68ead468d", "url": "https://github.com/tensorflow/java/commit/9b79be345591f4cb71b37a73abf22de68ead468d", "message": "add javadoc for tf.data", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "2b91aa31531b7f38b308a7dbf7f5ffbbd3a157db", "url": "https://github.com/tensorflow/java/commit/2b91aa31531b7f38b308a7dbf7f5ffbbd3a157db", "message": "Using NdArray in tests", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "84d9b7e47e58ab7a7a3b1b5a55df96b3d7c04efd", "url": "https://github.com/tensorflow/java/commit/84d9b7e47e58ab7a7a3b1b5a55df96b3d7c04efd", "message": "use try-with-resources for test tensors", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "f33f02bbbe32043b59bd875a34bbd8fe597511ac", "url": "https://github.com/tensorflow/java/commit/f33f02bbbe32043b59bd875a34bbd8fe597511ac", "message": "update readme to match RFC", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "7e7c1bfaba7c725cd981f74e981ae365a3b787d7", "url": "https://github.com/tensorflow/java/commit/7e7c1bfaba7c725cd981f74e981ae365a3b787d7", "message": "update readme", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "b08f8d89e3a2921b1f0013e0f650c02fbb2f91ba", "url": "https://github.com/tensorflow/java/commit/b08f8d89e3a2921b1f0013e0f650c02fbb2f91ba", "message": "Dataset return type from fromTensorSlices", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "048e1221f8fb65f0ea9474b279c72a3a577aefde", "url": "https://github.com/tensorflow/java/commit/048e1221f8fb65f0ea9474b279c72a3a577aefde", "message": "update readme", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "b0059362d74b61e2d809d61038cbb13d1f3a468f", "url": "https://github.com/tensorflow/java/commit/b0059362d74b61e2d809d61038cbb13d1f3a468f", "message": "add head() and tail() to Shape class", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "e4a2431f06b5f4c63f7c0238650371dd60c89721", "url": "https://github.com/tensorflow/java/commit/e4a2431f06b5f4c63f7c0238650371dd60c89721", "message": "refactoring", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "08041de037c8477a90debd512c32f1fc4ff5b77e", "url": "https://github.com/tensorflow/java/commit/08041de037c8477a90debd512c32f1fc4ff5b77e", "message": "add dataset optional to improve eager iteration", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "abaa1f7a7bb5b4635cecaf8904ee174d33d9250c", "url": "https://github.com/tensorflow/java/commit/abaa1f7a7bb5b4635cecaf8904ee174d33d9250c", "message": "update README", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}, {"oid": "fa8f5d593423ea7beb6b18c83f73e87baffefb18", "url": "https://github.com/tensorflow/java/commit/fa8f5d593423ea7beb6b18c83f73e87baffefb18", "message": "use 2-space indentation", "committedDate": "2020-04-29T15:48:24Z", "type": "commit"}]}