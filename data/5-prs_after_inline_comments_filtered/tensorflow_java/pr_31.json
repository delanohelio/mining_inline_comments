{"pr_number": 31, "pr_title": "NdArrays and DataBuffers equality and hash codes", "pr_createdAt": "2020-03-10T13:24:00Z", "pr_url": "https://github.com/tensorflow/java/pull/31", "timeline": [{"oid": "88e1b019acc84c236e9a833590cf35753233540b", "url": "https://github.com/tensorflow/java/commit/88e1b019acc84c236e9a833590cf35753233540b", "message": "NdArrays and DataBuffers equality", "committedDate": "2020-03-10T13:11:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1MTMxMA==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392351310", "bodyText": "I'd refer to this as providing a view on the same memory, which is the terminology that java.nio.ByteBuffer uses for the equivalent operation.", "author": "Craigacp", "createdAt": "2020-03-13T16:53:01Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/ByteDataBuffer.java", "diffHunk": "@@ -132,6 +132,72 @@ default ByteDataBuffer write(byte[] src) {\n    */\n   ByteDataBuffer write(byte[] src, int offset, int length);\n \n+  /**\n+   * Return this byte buffer as a buffer of ints.\n+   *\n+   * <p>The returned buffer shares the same memory as the original one, meaning that changing a value", "originalCommit": "88e1b019acc84c236e9a833590cf35753233540b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1MjAyOA==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392352028", "bodyText": "type -> types", "author": "Craigacp", "createdAt": "2020-03-13T16:54:19Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBuffer.java", "diffHunk": "@@ -223,4 +223,37 @@\n    * @throws IllegalArgumentException if size value do not pass validation checks\n    */\n   DataBuffer<T> narrow(long size);\n+\n+  /**\n+   * Visits the backing storage of this buffer.\n+   *\n+   * <p>The buffer implementation is responsible of passing back a reference to the actual data\n+   * storage to the provided visitor. The visitor does not have to handle all possible type of", "originalCommit": "88e1b019acc84c236e9a833590cf35753233540b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1MzMzMw==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392353333", "bodyText": "Does this equals also depend on the type of the buffer? i.e. if I do byteDataBuffer.equals(byteDataBuffer.asInts()) what happens? Either way is fine, but it should be documented.", "author": "Craigacp", "createdAt": "2020-03-13T16:56:29Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBuffer.java", "diffHunk": "@@ -223,4 +223,37 @@\n    * @throws IllegalArgumentException if size value do not pass validation checks\n    */\n   DataBuffer<T> narrow(long size);\n+\n+  /**\n+   * Visits the backing storage of this buffer.\n+   *\n+   * <p>The buffer implementation is responsible of passing back a reference to the actual data\n+   * storage to the provided visitor. The visitor does not have to handle all possible type of\n+   * data storage and can override only methods for storage it is actually interested in. For any\n+   * other type of storage, the call will fallback to {@link DataStorageVisitor#otherwise()} so the\n+   * visitor can handle it as a general case.\n+   *\n+   * @param visitor visits the data storage of this buffer\n+   * @param <R> type of value returned by the visitor\n+   * @return the same value returned by the visitor\n+   */\n+  default <R> R accept(DataStorageVisitor<R> visitor) {\n+    return visitor.otherwise();\n+  }\n+\n+  /**\n+   * Checks equality between data buffers.\n+   *\n+   * <p>A data buffer is equal to another object if this object is another {@link DataBuffer} of the", "originalCommit": "88e1b019acc84c236e9a833590cf35753233540b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYzMjcyNQ==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392632725", "bodyText": "It does depend on the type as well, that was missing in the doc, I'll add it", "author": "karllessard", "createdAt": "2020-03-15T01:22:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1MzMzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1NTA0MQ==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392355041", "bodyText": "Maybe this could be called defaultVisit or something more indicative? What kinds of behaviour would it perform?", "author": "Craigacp", "createdAt": "2020-03-13T16:59:35Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataStorageVisitor.java", "diffHunk": "@@ -0,0 +1,147 @@\n+package org.tensorflow.tools.buffer;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.DoubleBuffer;\n+import java.nio.FloatBuffer;\n+import java.nio.IntBuffer;\n+import java.nio.LongBuffer;\n+import java.nio.ShortBuffer;\n+import java.util.BitSet;\n+\n+/**\n+ * Visit the backing storage of {@link DataBuffer} instances.\n+ *\n+ * @param <R> value type returned by the visitor\n+ */\n+public interface DataStorageVisitor<R> {\n+\n+  /**\n+   * Visit the {@link ByteBuffer} backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param buffer underlying buffer\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(ByteBuffer buffer) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the {@link ShortBuffer} backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param buffer underlying buffer\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(ShortBuffer buffer) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the {@link IntBuffer} backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param buffer underlying buffer\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(IntBuffer buffer) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the {@link LongBuffer} backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param buffer underlying buffer\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(LongBuffer buffer) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the {@link FloatBuffer} backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param buffer underlying buffer\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(FloatBuffer buffer) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the {@link DoubleBuffer} backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param buffer underlying buffer\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(DoubleBuffer buffer) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the boolean array backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param array underlying array\n+   * @param offset offset of the buffer within the array\n+   * @param length length of the buffer within the array\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(boolean[] array, int offset, int length) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the bit set backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param bitSet underlying bit set\n+   * @param offset offset of the buffer within the bit set\n+   * @param numBits number of bits used to represent the buffer within the bit set\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(BitSet bitSet, int offset, long numBits) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the object array backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param array underlying array\n+   * @param offset offset of the buffer within the array\n+   * @param length length of the buffer within the array\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(Object[] array, int offset, int length) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the raw memory segment of a given instance of a {@link DataBuffer}\n+   *\n+   * @param address native address of the buffer\n+   * @param length length of the buffer\n+   * @param scale number of bytes required to store a single value of this buffer\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(long address, long length, long scale) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Fallback method called if the visitor implementation does not support the type of backing storage\n+   * for a given {@link DataBuffer}\n+   *\n+   * <p>The implementor of this interface must override the {@code visit} methods for type of storage\n+   * it supports. If {@link DataBuffer#accept(DataStorageVisitor)} is called on a buffer\n+   * using a different type of storage, the invocation will fallback to this method.\n+   *\n+   * @return any value\n+   */\n+  R otherwise();", "originalCommit": "88e1b019acc84c236e9a833590cf35753233540b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYzMzA4NA==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392633084", "bodyText": "This method is called when the visitor does not handle a given type of data storage, so that it can fallback to a generic task if needed. I still prefer otherwise() to defaultVisit() because basically when this method is called, it means that you are not visiting any data storage. I used it for example like this:\n    return otherBuffer.accept(new DataStorageVisitor<Boolean>() {\n\n      @Override\n      public Boolean visit(DoubleBuffer otherStorage) {\n        return myStorage.equals(otherStorage);\n      }\n\n      @Override\n      public Boolean otherwise() {\n        for (int idx = 0; idx < size(); ++idx) {\n          if (otherBuffer.getDouble(idx) != getDouble(idx)) {\n            return false;\n          }\n        }\n        return true;\n      }\n    });\nSo when otherwise() is call, I can only build a routine using the public API of a DataBuffer and nothing internal like other visit() methods can do.", "author": "karllessard", "createdAt": "2020-03-15T01:31:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1NTA0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5MTg5Mw==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r393091893", "bodyText": "I'd still consider that to be visiting every index in the storage, but I don't write that many visitors to be honest. Maybe fallback? The name otherwise to me suggests there should be some condition that makes it go down that path that the user could control, or is data dependent. The use case here seems to be type dependent (in that it'll be chosen statically at compile time).", "author": "Craigacp", "createdAt": "2020-03-16T15:03:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1NTA0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE5MjY1Ng==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r393192656", "bodyText": "Ok no problem for \"fallback\", as long as it is not \"visit\" I'm fine.", "author": "karllessard", "createdAt": "2020-03-16T17:27:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1NTA0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1NzA4OQ==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392357089", "bodyText": "Can we stash these lambdas in static variables?", "author": "Craigacp", "createdAt": "2020-03-13T17:03:24Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/impl/AbstractDataBuffer.java", "diffHunk": "@@ -38,9 +41,145 @@\n     return this;\n   }\n \n-  protected void slowCopyTo(DataBuffer<T> dst, long size) {\n-    for (long idx = 0; idx < size; ++idx) {\n+  @Override\n+  public DataBuffer<T> copyTo(DataBuffer<T> dst, long size) {\n+    Validator.copyToArgs(this, dst, size);\n+    for (long idx = 0L; idx < size; ++idx) {\n+      dst.setObject(getObject(idx), idx);\n+    }\n+    return this;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    // This hash code computation is generic to all types of data buffers and accurate but not optimized\n+    // for performances, it needs to be improved if there is a present use case for such hash codes.\n+    return slowHashCode();\n+  }\n+\n+  @Override\n+  public boolean equals(Object obj) {\n+    if (this == obj) {\n+      return true;\n+    }\n+    if (!(obj instanceof DataBuffer)) {\n+      return false;\n+    }\n+    return slowEquals((DataBuffer<?>)obj);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  protected <U extends DataBuffer<T>> U slowCopyTo(DataBuffer<T> dst, long size) {\n+    Validator.copyToArgs(this, dst, size);\n+    for (long idx = 0L; idx < size; ++idx) {\n       dst.setObject(getObject(idx), idx);\n     }\n+    return (U)this;\n+  }\n+\n+  protected int slowHashCode() {\n+    final int prime = 31;\n+    int result = 1;\n+\n+    // First check from the first non-null element if we are dealing with a buffer of arrays\n+    long idx = 0L;\n+    for (; idx < size(); ++idx) {\n+      T o = getObject(idx);\n+      if (o != null) {\n+        if (o.getClass().isArray()) {\n+          result = prime * result + arrayHashCode(idx, o.getClass()); // compute hash codes based on array elements\n+          return result;\n+        }\n+        result = prime * result + o.hashCode();\n+        break;  // continue hash code computation without array type check\n+      }\n+      result = prime * result;\n+    }\n+    while (++idx < size()) {\n+      result = prime * result + Objects.hashCode(getObject(idx));\n+    }\n+    return result;\n+  }\n+\n+  protected boolean slowEquals(DataBuffer<?> other) {\n+    if (other.size() != size()) {\n+      return false;\n+    }\n+    long idx = 0L;\n+    for (; idx < size(); ++idx) {\n+      Object thisObject = getObject(idx);\n+      if (thisObject != null) {\n+        if (thisObject.getClass().isArray()) {\n+          return arrayEquals(idx, thisObject.getClass(), other);\n+        }\n+        if (!Objects.equals(other.getObject(idx), thisObject)) {\n+          return false;\n+        }\n+        break;  // continue equality comparison without array type check\n+      }\n+      if (other.getObject(idx) != null) {\n+        return false;\n+      }\n+    }\n+    while (++idx < size()) {\n+      if (!Objects.equals(other.getObject(idx), getObject(idx))) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private int arrayHashCode(long startIdx, Class<?> arrayClass) {\n+    Function<Long, Integer> hashCoder;", "originalCommit": "88e1b019acc84c236e9a833590cf35753233540b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1ODU0Ng==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392358546", "bodyText": "Might be best to hoist the cast out of the for loop in case the JIT doesn't figure it out. Pity we can't use the pattern matching from JDK 14 yet.", "author": "Craigacp", "createdAt": "2020-03-13T17:06:05Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/impl/adapter/DoubleDataBufferAdapter.java", "diffHunk": "@@ -56,16 +56,48 @@ public DoubleDataBuffer write(double[] src, int offset, int length) {\n     return this;\n   }\n \n+  @Override\n+  public DoubleDataBuffer copyTo(DataBuffer<Double> dst, long size) {\n+    Validator.copyToArgs(this, dst, size);\n+    if (dst instanceof DoubleDataBuffer) {\n+      for (long idx = 0L; idx < size; ++idx) {\n+        ((DoubleDataBuffer)dst).setDouble(getDouble(idx), idx);", "originalCommit": "88e1b019acc84c236e9a833590cf35753233540b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM2MjM2OA==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392362368", "bodyText": "This should probably note \"the same shape, type and the elements are equal and in the same order\".", "author": "Craigacp", "createdAt": "2020-03-13T17:13:45Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/NdArray.java", "diffHunk": "@@ -293,4 +291,20 @@ default long size() {\n    * @see DataBuffer#size()\n    */\n   NdArray<T> write(DataBuffer<T> src);\n+\n+  /**\n+   * Checks equality between n-dimensional arrays.\n+   *\n+   * <p>An array is equal to another object if this object is another {@link NdArray} of the", "originalCommit": "88e1b019acc84c236e9a833590cf35753233540b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "929acaf56f551bd9500b2b592a893139eb923aed", "url": "https://github.com/tensorflow/java/commit/929acaf56f551bd9500b2b592a893139eb923aed", "message": "Improve Javadoc and fix few bugs", "committedDate": "2020-03-15T14:52:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5NDY1Mg==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r393094652", "bodyText": "This is disappointing, is there no way to make equals and hashCode just look at the view without having to actually perform an operation on them?", "author": "Craigacp", "createdAt": "2020-03-16T15:07:06Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/impl/dense/AbstractDenseNdArray.java", "diffHunk": "@@ -110,6 +113,18 @@ protected AbstractDenseNdArray(DimensionalSpace dimensions) {\n \n   abstract protected DataBuffer<T> buffer();\n \n+  protected DataBuffer<T> trimBuffer() {", "originalCommit": "929acaf56f551bd9500b2b592a893139eb923aed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE5NTQzNw==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r393195437", "bodyText": "We could avoid it by trimming the buffer every time we slice the array but this function is more on the critical path for performances and I was hesitating changing it only to support equals/hashCode, which should be used less frequently.\nTrimming the buffer when the array is not segmented (caused by the usage of some of the Index classes) is quite easy to do but substantial changes need to be performed in the other case.\nI'm not too happy with this last-minute discovery as well so would you be comfortable if we keep it like that and I'll add a TODO notice to take a deeper look at how to improve this aspect later?", "author": "karllessard", "createdAt": "2020-03-16T17:31:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5NDY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI1MDg0OQ==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r393250849", "bodyText": "Yeah, I'm fine with it staying as is with a note to fix it later.", "author": "Craigacp", "createdAt": "2020-03-16T19:03:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5NDY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI1MTMzMA==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r393251330", "bodyText": "Maybe we could add a flag on the NdArray noting it's not continuous in it's backing store, then have equals and hashcode fall back to something slower?", "author": "Craigacp", "createdAt": "2020-03-16T19:04:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5NDY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMyOTA4OQ==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r393329089", "bodyText": "Oh, we already have this flag (dimensions.isSegmented()), so I would now assume the buffer is trimmed if this flag is not set? I think it is better but still not perfect, I'll do this but still leave a note to review for later.", "author": "karllessard", "createdAt": "2020-03-16T21:49:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5NDY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzcwODc5MQ==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r393708791", "bodyText": "Ok @Craigacp , I just pushed new substantial changes, this was required if I wanted to limit the impact on performances when slicing an array. So I added a new DataBuffer.slice() method, instead of using the double-allocating DataBuffer.offset(i).narrow(s) (running NdArrayBenchmark show a significative improvement by doing this).", "author": "karllessard", "createdAt": "2020-03-17T14:13:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5NDY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg4MTc2MA==", "url": "https://github.com/tensorflow/java/pull/31#discussion_r393881760", "bodyText": "Looks like some unnecessary imports got dragged in.", "author": "Craigacp", "createdAt": "2020-03-17T18:21:31Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/impl/nio/FloatNioDataBuffer.java", "diffHunk": "@@ -17,9 +17,11 @@\n \n package org.tensorflow.tools.buffer.impl.nio;\n \n+import java.nio.DoubleBuffer;\n import java.nio.FloatBuffer;\n import org.tensorflow.tools.buffer.DataBuffer;\n import org.tensorflow.tools.buffer.DataStorageVisitor;\n+import org.tensorflow.tools.buffer.DoubleDataBuffer;", "originalCommit": "656d771863e75d929698e4be9a0c2a8edf256342", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bf2067530031d08c9488e7d1b4d8ae25b405498e", "url": "https://github.com/tensorflow/java/commit/bf2067530031d08c9488e7d1b4d8ae25b405498e", "message": "Trim array buffers when slicing", "committedDate": "2020-03-18T00:45:07Z", "type": "commit"}, {"oid": "bf2067530031d08c9488e7d1b4d8ae25b405498e", "url": "https://github.com/tensorflow/java/commit/bf2067530031d08c9488e7d1b4d8ae25b405498e", "message": "Trim array buffers when slicing", "committedDate": "2020-03-18T00:45:07Z", "type": "forcePushed"}]}