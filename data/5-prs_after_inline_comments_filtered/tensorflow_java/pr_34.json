{"pr_number": 34, "pr_title": "Cleanup tensor factories and methods", "pr_createdAt": "2020-03-19T13:57:47Z", "pr_url": "https://github.com/tensorflow/java/pull/34", "timeline": [{"oid": "b270f2051042f8c93d4b0a54e49c99953cc0e12b", "url": "https://github.com/tensorflow/java/commit/b270f2051042f8c93d4b0a54e49c99953cc0e12b", "message": "Cleanup tensor factories and methods", "committedDate": "2020-03-19T13:41:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2MTQxNw==", "url": "https://github.com/tensorflow/java/pull/34#discussion_r396561417", "bodyText": "This class is probably not a great idea. For one it allows a user to add elements to it after it's been closed. The way I got around it in the onnx runtime API was by returning a carrier class that was AutoCloseable, but also immutable. See https://github.com/microsoft/onnxruntime/blob/57468c651c5b9bfc9a0f37c548203891e088f71a/java/src/main/java/ai/onnxruntime/OrtSession.java#L613", "author": "Craigacp", "createdAt": "2020-03-23T15:58:26Z", "path": "tensorflow-core/tensorflow-core-api/src/test/java/org/tensorflow/AutoCloseableList.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package org.tensorflow;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+public final class AutoCloseableList<E extends AutoCloseable> extends ArrayList<E>", "originalCommit": "b270f2051042f8c93d4b0a54e49c99953cc0e12b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYzNTA3NA==", "url": "https://github.com/tensorflow/java/pull/34#discussion_r396635074", "bodyText": "This class is only used for unit tests and I just moved it from its previous location in TestUtil, as it was the only utility remaining", "author": "karllessard", "createdAt": "2020-03-23T17:40:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2MTQxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY3MDg2MA==", "url": "https://github.com/tensorflow/java/pull/34#discussion_r396670860", "bodyText": "Ah ok, I'd missed it was in the test code. We might want to consider doing something for the return value of session.run anyway as it is a bit irritating. Not that I'm too happy with how it turned out for onnxruntime, but it does work and it's safe.", "author": "Craigacp", "createdAt": "2020-03-23T18:32:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2MTQxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY3MzMwNw==", "url": "https://github.com/tensorflow/java/pull/34#discussion_r396673307", "bodyText": "I agree, it is irritating. We should address that but let\u2019s do it in another PR", "author": "karllessard", "createdAt": "2020-03-23T18:36:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2MTQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MjI5Ng==", "url": "https://github.com/tensorflow/java/pull/34#discussion_r396572296", "bodyText": "Does this call check that the size is larger than the required size for the shape & dtype?", "author": "Craigacp", "createdAt": "2020-03-23T16:12:43Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Tensor.java", "diffHunk": "@@ -82,241 +39,142 @@\n  * try-with-resources block:\n  *\n  * <pre>{@code\n- * try (Tensor t = Tensor.create(...)) {\n+ * try (Tensor t = Tensor.of(...)) {\n  *   doSomethingWith(t);\n  * }\n  * }</pre>\n  */\n public final class Tensor<T extends TType> implements AutoCloseable {\n \n   /**\n-   * Creates a Tensor from a Java object.\n+   * Allocates a tensor of a given datatype and shape.\n    *\n-   * <p>A {@code Tensor} is a multi-dimensional array of elements of a limited set of types. Not all\n-   * Java objects can be converted to a {@code Tensor}. In particular, the argument {@code obj} must\n-   * be either a primitive (float, double, int, long, boolean, byte) or a multi-dimensional array of\n-   * one of those primitives. The argument {@code type} specifies how to interpret the first\n-   * argument as a TensorFlow type. For example:\n+   * <p>The amount of memory to allocate is derived from the datatype and the shape of the tensor.\n+   * Memory is left uninitialized after this method returns, so it is the responsibility of the\n+   * caller to initialize the tensor data before it is used, via the {@link #data()} accessor.\n+   * For example:\n    *\n    * <pre>{@code\n-   * // Valid: A 64-bit integer scalar.\n-   * Tensor<Long> s = Tensor.create(42L, Long.class);\n-   *\n-   * // Valid: A 3x2 matrix of floats.\n-   * float[][] matrix = new float[3][2];\n-   * Tensor<Float> m = Tensor.create(matrix, Float.class);\n-   *\n-   * // Invalid: Will throw an IllegalArgumentException as an arbitrary Object\n-   * // does not fit into the TensorFlow type system.\n-   * Tensor<?> o = Tensor.create(new Object())\n-   *\n-   * // Invalid: Will throw an IllegalArgumentException since there are\n-   * // a differing number of elements in each row of this 2-D array.\n-   * int[][] twoD = new int[2][];\n-   * twoD[0] = new int[1];\n-   * twoD[1] = new int[2];\n-   * Tensor<Integer> x = Tensor.create(twoD, Integer.class);\n-   * }</pre>\n-   *\n-   * {@link String}-typed Tensors are multi-dimensional arrays of arbitrary byte sequences, so can\n-   * be initialized from arrays of {@code byte[]} elements. For example:\n-   *\n-   * <pre>{@code\n-   * // Valid: A String tensor.\n-   * Tensor<String> s = Tensor.create(new byte[]{1, 2, 3}, String.class);\n-   *\n-   * // Java Strings will need to be encoded into a byte-sequence.\n-   * String mystring = \"foo\";\n-   * Tensor<String> s = Tensor.create(mystring.getBytes(\"UTF-8\"), String.class);\n-   *\n-   * // Valid: Matrix of String tensors.\n-   * // Each element might have a different length.\n-   * byte[][][] matrix = new byte[2][2][];\n-   * matrix[0][0] = \"this\".getBytes(\"UTF-8\");\n-   * matrix[0][1] = \"is\".getBytes(\"UTF-8\");\n-   * matrix[1][0] = \"a\".getBytes(\"UTF-8\");\n-   * matrix[1][1] = \"matrix\".getBytes(\"UTF-8\");\n-   * Tensor<String> m = Tensor.create(matrix, String.class);\n+   * FloatNdArray data = ...\n+   * try (Tensor<TFloat32> t = Tensor.of(TFloat32.DTYPE, Shape.of(2, 2))) {\n+   *   data.copyTo(t.data());\n+   *   ...\n+   * }\n    * }</pre>\n    *\n-   * @param obj The object to convert to a {@code Tensor<T>}. Note that whether it is compatible\n-   *     with the type T is not checked by the type system. For type-safe creation of tensors, use\n-   *     {@link Tensors}.\n-   * @param dtype The tensor element data type\n-   * @throws IllegalArgumentException if {@code obj} is not compatible with the TensorFlow type\n-   *     system.\n+   * @param <T> the tensor element type\n+   * @param dtype datatype of the tensor\n+   * @param shape shape of the tensor\n+   * @return an allocated but uninitialized tensor\n    */\n-  public static <T extends TType> Tensor<T> create(Object obj, DataType<T> dtype) {\n-    if (!objectCompatWithType(obj, dtype)) {\n-      throw new IllegalArgumentException(\n-          \"DataType of object does not match T (expected \"\n-              + dtype\n-              + \", got \"\n-              + dataTypeOf(obj)\n-              + \")\");\n-    }\n-    long[] dimSizes = new long[numDimensions(obj, dtype)];\n-    fillShape(obj, 0, dimSizes);\n-    Tensor<T> t = new Tensor<>(dtype, Shape.of(dimSizes));\n-    TF_Tensor nativeHandle;\n-    if (t.dtype != TString.DTYPE) {\n-      long byteSize = elemByteSize(t.dtype) * t.shape.size();\n-      nativeHandle = allocate(t.dtype.nativeCode(), dimSizes, byteSize);\n-      setValue(nativeHandle, obj);\n-    } else if (t.shape.numDimensions() != 0) {\n-      nativeHandle = allocateNonScalarBytes(dimSizes, (Object[]) obj);\n-    } else {\n-      nativeHandle = allocateScalarBytes((byte[]) obj);\n-    }\n-    t.nativeRef = new NativeReference(nativeHandle);\n-    return t;\n+  public static <T extends TType> Tensor<T> of(DataType<T> dtype, Shape shape) {\n+    return of(dtype, shape, shape.size() * dtype.byteSize());\n   }\n \n   /**\n-   * Creates a tensor from an object whose class is inspected to figure out what the underlying data\n-   * type should be.\n+   * Allocates a tensor of a given datatype, shape and size.\n    *\n-   * @throws IllegalArgumentException if {@code obj} is not compatible with the TensorFlow type\n-   *     system.\n-   */\n-  public static Tensor<?> create(Object obj) {\n-    return create(obj, dataTypeOf(obj));\n-  }\n-\n-  /**\n-   * Create a {@link Integer} Tensor with data from the given buffer.\n+   * <p>This method is identical to {@link #of(DataType, Shape)}, except that the final size of the\n+   * tensor is explicitly set instead of computing it from the datatype and shape.\n    *\n-   * <p>Creates a Tensor with the given shape by copying elements from the buffer (starting from its\n-   * current position) into the tensor. For example, if {@code shape = {2,3} } (which represents a\n-   * 2x3 matrix) then the buffer must have 6 elements remaining, which will be consumed by this\n-   * method.\n+   * <p>This could be useful for tensor types that stores data but also metadata in the tensor memory,\n+   * like {@link org.tensorflow.types.TString TString}.\n    *\n-   * @param shape the tensor shape.\n-   * @param data a buffer containing the tensor data.\n-   * @throws IllegalArgumentException If the tensor shape is not compatible with the buffer\n+   * @param <T> the tensor element type\n+   * @param dtype datatype of the tensor\n+   * @param shape shape of the tensor\n+   * @param size size, in bytes, of the tensor\n+   * @return an allocated but uninitialized tensor\n+   * @see #of(DataType, Shape)\n    */\n-  public static Tensor<TInt32> create(long[] shape, IntBuffer data) {\n-    Tensor<TInt32> t = allocateForBuffer(TInt32.DTYPE, shape, data.remaining());\n-    t.buffer().asIntBuffer().put(data);\n+  public static <T extends TType> Tensor<T> of(DataType<T> dtype, Shape shape, long size) {\n+    Tensor<T> t = new Tensor<>(dtype, shape);\n+    TF_Tensor nativeHandle = allocate(t.dtype.nativeCode(), shape.asArray(), size);", "originalCommit": "b270f2051042f8c93d4b0a54e49c99953cc0e12b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0MDE1MQ==", "url": "https://github.com/tensorflow/java/pull/34#discussion_r396640151", "bodyText": "I think the native part validate it but I can add a unit test to confirm this", "author": "karllessard", "createdAt": "2020-03-23T17:47:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MjI5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE0MjE5MQ==", "url": "https://github.com/tensorflow/java/pull/34#discussion_r397142191", "bodyText": "Ok, so after some investigation, I can see that the native call returns null if the buffer is smaller than the required size (a larger buffer is accepted though so we should preserve that behaviour) or if it fails to allocate the tensor for any other reason.\nIn TF 1.15, a NullPointerException was explicitly thrown in such case, which was a bit odd. @saudet changed it to a IllegalStateException in the JavaCPP version, which is better, but still misleading in case the mistake comes from a user-provided parameter (there is actually no way to know it from the native call).\nSo I've added an explicit check on the minimum tensor size requirement and now throw an IllegalArgumentException if that check does not pass. This is only possible with fixed-length datatypes, as we don't know the size of the elements for variable-length datatypes (TString factories will take care of this).", "author": "karllessard", "createdAt": "2020-03-24T13:15:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MjI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4MTMxOA==", "url": "https://github.com/tensorflow/java/pull/34#discussion_r396581318", "bodyText": "This one is missing the @Endpoint(name = \"val\").", "author": "Craigacp", "createdAt": "2020-03-23T16:24:28Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/Constant.java", "diffHunk": "@@ -515,22 +502,15 @@\n   /**\n    * Create a {@link TFloat64} constant with data from the given buffer.\n    *\n-   * <p>Creates a constant with the given shape by copying elements from the buffer (starting from\n-   * its current position) into the tensor. For example, if {@code shape = {2,3} } (which represents\n-   * a 2x3 matrix) then the buffer must have 6 elements remaining, which will be consumed by this\n-   * method.\n-   *\n    * @param scope is a scope used to add the underlying operation.\n    * @param shape the tensor shape.\n    * @param data a buffer containing the tensor data.\n    * @return a double constant\n    * @throws IllegalArgumentException If the tensor shape is not compatible with the buffer\n-   * @deprecated use {@link Ops#val(Tensor) Ops.constant(Tensor&lt;TFloat64>)} instead\n    */\n   @Endpoint", "originalCommit": "b270f2051042f8c93d4b0a54e49c99953cc0e12b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5e73cba9e9d10d2dea6b2defa9a9477bcd81dc4f", "url": "https://github.com/tensorflow/java/commit/5e73cba9e9d10d2dea6b2defa9a9477bcd81dc4f", "message": "Mimimum tensor size safety check", "committedDate": "2020-03-24T13:15:28Z", "type": "commit"}, {"oid": "5e73cba9e9d10d2dea6b2defa9a9477bcd81dc4f", "url": "https://github.com/tensorflow/java/commit/5e73cba9e9d10d2dea6b2defa9a9477bcd81dc4f", "message": "Mimimum tensor size safety check", "committedDate": "2020-03-24T13:15:28Z", "type": "forcePushed"}]}