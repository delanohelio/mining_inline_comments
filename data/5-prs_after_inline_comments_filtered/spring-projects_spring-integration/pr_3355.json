{"pr_number": 3355, "pr_title": "INT-3045: Add `ZeroMqChannel` support", "pr_createdAt": "2020-08-03T21:33:23Z", "pr_url": "https://github.com/spring-projects/spring-integration/pull/3355", "timeline": [{"oid": "351f2706e8800ae0e2284e25cb55d0cc19b201fb", "url": "https://github.com/spring-projects/spring-integration/commit/351f2706e8800ae0e2284e25cb55d0cc19b201fb", "message": "* Fix subscriber scheduler name\n* Optimize socket create logic\n* Add PUSH/PULL over TCP test\n* Implement PUB/SUB over TCP", "committedDate": "2020-08-06T20:46:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4NDcwOQ==", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r467184709", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /**\n          \n          \n            \n             * This class encapsulates a logic to configure and manage ZeroMQ proxy.\n          \n          \n            \n             * It binds frontend and backend sockets over TCP on all the available network interfaces\n          \n          \n            \n             * with provided ports or randomly selected otherwise.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * The {@link ZeroMqProxy.Type} dictates which pair of ZeroMQ sockets to bind with this proxy\n          \n          \n            \n             * to implement any possible patterns for ZeroMQ intermediary. Defaults to @link {@link ZeroMqProxy.Type#PULL_PUSH}.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * The control socket is exposed as a {@link SocketType#PAIR} with an inter-thread transport\n          \n          \n            \n             * on tne {@code \"inproc://\" + beanName + \".control\"} address - can be obtained via {@link #getControlAddress()}.\n          \n          \n            \n             * Should be used with the same application from {@link SocketType#PAIR} socket to send\n          \n          \n            \n             * {@link zmq.ZMQ#PROXY_TERMINATE}, {@link zmq.ZMQ#PROXY_PAUSE} and/or {@link zmq.ZMQ#PROXY_RESUME} commands.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * If proxy cannot be started for some reason, the error message is logged respectively and this component is\n          \n          \n            \n             * left in the non-starting state.\n          \n          \n            \n            /**\n          \n          \n            \n             * This class encapsulates the logic to configure and manage a ZeroMQ proxy.\n          \n          \n            \n             * It binds frontend and backend sockets over TCP on all the available network interfaces\n          \n          \n            \n             * with either provided or randomly selected ports.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * The {@link ZeroMqProxy.Type} dictates which pair of ZeroMQ sockets to bind with this proxy\n          \n          \n            \n             * to implement any possible patterns for ZeroMQ intermediary. Defaults to @link {@link ZeroMqProxy.Type#PULL_PUSH}.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * The control socket is exposed as a {@link SocketType#PAIR} with an inter-thread transport\n          \n          \n            \n             * on tne {@code \"inproc://\" + beanName + \".control\"} address; it can be obtained via {@link #getControlAddress()}.\n          \n          \n            \n             * Should be used with the same application from {@link SocketType#PAIR} socket to send\n          \n          \n            \n             * {@link zmq.ZMQ#PROXY_TERMINATE}, {@link zmq.ZMQ#PROXY_PAUSE} and/or {@link zmq.ZMQ#PROXY_RESUME} commands.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * If the proxy cannot be started for some reason, an error message is logged and this component is\n          \n          \n            \n             * left in the non-started state.", "author": "garyrussell", "createdAt": "2020-08-07T17:50:18Z", "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.zeromq;\n+\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.zeromq.SocketType;\n+import org.zeromq.ZContext;\n+import org.zeromq.ZMQ;\n+\n+import org.springframework.beans.factory.BeanNameAware;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.context.SmartLifecycle;\n+import org.springframework.lang.Nullable;\n+import org.springframework.scheduling.concurrent.CustomizableThreadFactory;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * This class encapsulates a logic to configure and manage ZeroMQ proxy.\n+ * It binds frontend and backend sockets over TCP on all the available network interfaces\n+ * with provided ports or randomly selected otherwise.\n+ * <p>\n+ * The {@link ZeroMqProxy.Type} dictates which pair of ZeroMQ sockets to bind with this proxy\n+ * to implement any possible patterns for ZeroMQ intermediary. Defaults to @link {@link ZeroMqProxy.Type#PULL_PUSH}.\n+ * <p>\n+ * The control socket is exposed as a {@link SocketType#PAIR} with an inter-thread transport\n+ * on tne {@code \"inproc://\" + beanName + \".control\"} address - can be obtained via {@link #getControlAddress()}.\n+ * Should be used with the same application from {@link SocketType#PAIR} socket to send\n+ * {@link zmq.ZMQ#PROXY_TERMINATE}, {@link zmq.ZMQ#PROXY_PAUSE} and/or {@link zmq.ZMQ#PROXY_RESUME} commands.\n+ * <p>\n+ * If proxy cannot be started for some reason, the error message is logged respectively and this component is\n+ * left in the non-starting state.", "originalCommit": "eec1ff14146553e7e03d2842232d05c770884183", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4NTYzMw==", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r467185633", "bodyText": "Needs DisposableBean to shut down the internal executor, if any.", "author": "garyrussell", "createdAt": "2020-08-07T17:52:14Z", "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.zeromq;\n+\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.zeromq.SocketType;\n+import org.zeromq.ZContext;\n+import org.zeromq.ZMQ;\n+\n+import org.springframework.beans.factory.BeanNameAware;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.context.SmartLifecycle;\n+import org.springframework.lang.Nullable;\n+import org.springframework.scheduling.concurrent.CustomizableThreadFactory;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * This class encapsulates a logic to configure and manage ZeroMQ proxy.\n+ * It binds frontend and backend sockets over TCP on all the available network interfaces\n+ * with provided ports or randomly selected otherwise.\n+ * <p>\n+ * The {@link ZeroMqProxy.Type} dictates which pair of ZeroMQ sockets to bind with this proxy\n+ * to implement any possible patterns for ZeroMQ intermediary. Defaults to @link {@link ZeroMqProxy.Type#PULL_PUSH}.\n+ * <p>\n+ * The control socket is exposed as a {@link SocketType#PAIR} with an inter-thread transport\n+ * on tne {@code \"inproc://\" + beanName + \".control\"} address - can be obtained via {@link #getControlAddress()}.\n+ * Should be used with the same application from {@link SocketType#PAIR} socket to send\n+ * {@link zmq.ZMQ#PROXY_TERMINATE}, {@link zmq.ZMQ#PROXY_PAUSE} and/or {@link zmq.ZMQ#PROXY_RESUME} commands.\n+ * <p>\n+ * If proxy cannot be started for some reason, the error message is logged respectively and this component is\n+ * left in the non-starting state.\n+ *\n+ * @author Artem Bilan\n+ *\n+ * @since 5.4\n+ *\n+ * @see ZMQ#proxy(ZMQ.Socket, ZMQ.Socket, ZMQ.Socket)\n+ */\n+public class ZeroMqProxy implements InitializingBean, SmartLifecycle, BeanNameAware {", "originalCommit": "eec1ff14146553e7e03d2842232d05c770884183", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MzU0MQ==", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r467193541", "bodyText": "I thought about that, but probably it is harmless since Executors.newSingleThreadExecutor() is a FinalizableDelegatedExecutorService.\nAlthough you might mean to still clean up the resource we don't hold any more...", "author": "artembilan", "createdAt": "2020-08-07T18:08:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4NTYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4NzE3OQ==", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r467187179", "bodyText": "Need Meters?\nWhat about send failures?", "author": "garyrussell", "createdAt": "2020-08-07T17:55:23Z", "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.zeromq.channel;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import org.zeromq.SocketType;\n+import org.zeromq.ZContext;\n+import org.zeromq.ZMQ;\n+\n+import org.springframework.integration.channel.AbstractMessageChannel;\n+import org.springframework.integration.mapping.BytesMessageMapper;\n+import org.springframework.integration.support.json.EmbeddedJsonHeadersMessageMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.messaging.Message;\n+import org.springframework.messaging.MessageHandler;\n+import org.springframework.messaging.SubscribableChannel;\n+import org.springframework.util.Assert;\n+\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+/**\n+ * @author Artem Bilan\n+ *\n+ * @since 5.4\n+ */\n+public class ZeroMqChannel extends AbstractMessageChannel implements SubscribableChannel {\n+\n+\tprivate final Map<MessageHandler, Disposable> subscribers = new HashMap<>();\n+\n+\tprivate final Scheduler publisherScheduler = Schedulers.newSingle(\"publisherScheduler\");\n+\n+\tprivate final Scheduler subscriberScheduler = Schedulers.newSingle(\"subscriberScheduler\");\n+\n+\tprivate final ZContext context;\n+\n+\tprivate final boolean pubSub;\n+\n+\tprivate final Mono<ZMQ.Socket> sendSocket;\n+\n+\tprivate final Mono<ZMQ.Socket> subscribeSocket;\n+\n+\tprivate final Flux<? extends Message<?>> subscriberData;\n+\n+\tprivate BytesMessageMapper messageMapper = new EmbeddedJsonHeadersMessageMapper();\n+\n+\t@Nullable\n+\tprivate volatile String connectSendUrl;\n+\n+\t@Nullable\n+\tprivate volatile String connectSubscribeUrl;\n+\n+\t@Nullable\n+\tprivate volatile Disposable subscriberDataDisposable;\n+\n+\tprivate volatile boolean initialized;\n+\n+\tpublic ZeroMqChannel(ZContext context) {\n+\t\tthis(context, false);\n+\t}\n+\n+\tpublic ZeroMqChannel(ZContext context, boolean pubSub) {\n+\t\tAssert.notNull(context, \"'context' must not be null\");\n+\t\tthis.context = context;\n+\t\tthis.pubSub = pubSub;\n+\n+\t\tSupplier<String> localPairConnection = () -> \"inproc://\" + getComponentName() + \".pair\";\n+\n+\t\tthis.sendSocket =\n+\t\t\t\tMono.fromCallable(() ->\n+\t\t\t\t\t\tthis.context.createSocket(\n+\t\t\t\t\t\t\t\tthis.connectSendUrl == null\n+\t\t\t\t\t\t\t\t\t\t? SocketType.PAIR\n+\t\t\t\t\t\t\t\t\t\t: (this.pubSub ? SocketType.XPUB : SocketType.PUSH))\n+\t\t\t\t)\n+\t\t\t\t\t\t.publishOn(this.publisherScheduler)\n+\t\t\t\t\t\t.doOnNext((socket) ->\n+\t\t\t\t\t\t\t\tsocket.connect(this.connectSendUrl != null\n+\t\t\t\t\t\t\t\t\t\t? this.connectSendUrl\n+\t\t\t\t\t\t\t\t\t\t: localPairConnection.get()))\n+\t\t\t\t\t\t.delayUntil((socket) -> (this.pubSub && this.connectSendUrl != null)\n+\t\t\t\t\t\t\t\t? Mono.just(socket).map(ZMQ.Socket::recv)\n+\t\t\t\t\t\t\t\t: Mono.empty())\n+\t\t\t\t\t\t.cache();\n+\n+\t\tthis.subscribeSocket =\n+\t\t\t\tMono.fromCallable(() ->\n+\t\t\t\t\t\tthis.context.createSocket(\n+\t\t\t\t\t\t\t\tthis.connectSubscribeUrl == null\n+\t\t\t\t\t\t\t\t\t\t? SocketType.PAIR\n+\t\t\t\t\t\t\t\t\t\t: (this.pubSub ? SocketType.SUB : SocketType.PULL)))\n+\t\t\t\t\t\t.publishOn(this.subscriberScheduler)\n+\t\t\t\t\t\t.doOnNext((socket) -> {\n+\t\t\t\t\t\t\tif (this.connectSubscribeUrl != null) {\n+\t\t\t\t\t\t\t\tsocket.connect(this.connectSubscribeUrl);\n+\t\t\t\t\t\t\t\tif (this.pubSub) {\n+\t\t\t\t\t\t\t\t\tsocket.subscribe(ZMQ.SUBSCRIPTION_ALL);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t\tsocket.bind(localPairConnection.get());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t})\n+\t\t\t\t\t\t.cache();\n+\n+\t\tFlux<? extends Message<?>> receiveData =\n+\t\t\t\tthis.subscribeSocket\n+\t\t\t\t\t\t.flatMap((socket) -> {\n+\t\t\t\t\t\t\tif (this.initialized) {\n+\t\t\t\t\t\t\t\tbyte[] data = socket.recv(ZMQ.NOBLOCK);\n+\t\t\t\t\t\t\t\tif (data != null) {\n+\t\t\t\t\t\t\t\t\treturn Mono.just(data);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\treturn Mono.empty();\n+\t\t\t\t\t\t})\n+\t\t\t\t\t\t.publishOn(Schedulers.parallel())\n+\t\t\t\t\t\t.map(this.messageMapper::toMessage)\n+\t\t\t\t\t\t.doOnError((error) -> logger.error(\"Error processing ZeroMQ message\", error))\n+\t\t\t\t\t\t.repeatWhenEmpty((repeat) ->\n+\t\t\t\t\t\t\t\tthis.initialized\n+\t\t\t\t\t\t\t\t\t\t? repeat.delayElements(Duration.ofMillis(100))\n+\t\t\t\t\t\t\t\t\t\t: repeat)\n+\t\t\t\t\t\t.repeat(() -> this.initialized);\n+\n+\t\tif (this.pubSub) {\n+\t\t\treceiveData = receiveData.publish()\n+\t\t\t\t\t.autoConnect(1, (disposable) -> this.subscriberDataDisposable = disposable);\n+\t\t}\n+\n+\t\tthis.subscriberData = receiveData;\n+\n+\t}\n+\n+\tpublic void setConnectUrl(@Nullable String connectUrl) {\n+\t\tif (connectUrl != null) {\n+\t\t\tthis.connectSendUrl = connectUrl.substring(0, connectUrl.lastIndexOf(':'));\n+\t\t\tthis.connectSubscribeUrl =\n+\t\t\t\t\tthis.connectSendUrl.substring(0, this.connectSendUrl.lastIndexOf(':'))\n+\t\t\t\t\t\t\t+ connectUrl.substring(connectUrl.lastIndexOf(':'));\n+\t\t}\n+\t}\n+\n+\tpublic void setMessageMapper(BytesMessageMapper messageMapper) {\n+\t\tAssert.notNull(messageMapper, \"'messageMapper' must not be null\");\n+\t\tthis.messageMapper = messageMapper;\n+\t}\n+\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\tthis.sendSocket.subscribe();\n+\t\tthis.initialized = true;\n+\t}\n+\n+\t@Override\n+\tprotected boolean doSend(Message<?> message, long timeout) {\n+\t\tAssert.state(this.initialized, \"the channel is not initialized yet or already destroyed\");\n+\n+\t\tbyte[] data = this.messageMapper.fromMessage(message);\n+\t\tAssert.state(data != null, () -> \"The '\" + this.messageMapper + \"' returned null for '\" + message + '\\'');\n+\n+\t\tMono<Boolean> sendMono = this.sendSocket.map((socket) -> socket.send(data));\n+\t\tBoolean sent =\n+\t\t\t\ttimeout > 0\n+\t\t\t\t\t\t? sendMono.block(Duration.ofMillis(timeout))\n+\t\t\t\t\t\t: sendMono.block();\n+", "originalCommit": "eec1ff14146553e7e03d2842232d05c770884183", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MjUxMQ==", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r467192511", "bodyText": "Send failure is going to be bubbled from this block as an exception.\nnot sure what you mean with meters.\nThis is doSend() impl. I think AbstractMessageChannel covers us with them...", "author": "artembilan", "createdAt": "2020-08-07T18:06:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4NzE3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk0NTU3NQ==", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r467945575", "bodyText": "Oh; right - I was thinking about amqp and jms having meters - but that's for pollable channels.", "author": "garyrussell", "createdAt": "2020-08-10T14:31:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4NzE3OQ=="}], "type": "inlineReview"}, {"oid": "e2454e13593e24f37639fcdd5e3bfeda43f24090", "url": "https://github.com/spring-projects/spring-integration/commit/e2454e13593e24f37639fcdd5e3bfeda43f24090", "message": "* Fix Checkstyle\n* Apply docs polishing\n* Expose a capture socket on the proxy\n* Implement `DisposableBean` in the `ZeroMqProxy` to destroy an internal executor service\n* Add JavaDocs to `ZeroMqChannel`\n* Add one more `ZeroMqChannel` to TCP test to be sure that proxy distribution works well", "committedDate": "2020-08-07T22:04:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU0NTY0NQ==", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r467545645", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * on tne {@code \"inproc://\" + beanName + \".control\"} address; it can be obtained via {@link #getControlAddress()}.\n          \n          \n            \n             * on the {@code \"inproc://\" + beanName + \".control\"} address; it can be obtained via {@link #getControlAddress()}.", "author": "oli-ver", "createdAt": "2020-08-09T06:56:00Z", "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java", "diffHunk": "@@ -0,0 +1,341 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.zeromq;\n+\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.zeromq.SocketType;\n+import org.zeromq.ZContext;\n+import org.zeromq.ZMQ;\n+\n+import org.springframework.beans.factory.BeanNameAware;\n+import org.springframework.beans.factory.DisposableBean;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.context.SmartLifecycle;\n+import org.springframework.lang.Nullable;\n+import org.springframework.scheduling.concurrent.CustomizableThreadFactory;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * This class encapsulates the logic to configure and manage a ZeroMQ proxy.\n+ * It binds frontend and backend sockets over TCP on all the available network interfaces\n+ * with either provided or randomly selected ports.\n+ * <p>\n+ * The {@link ZeroMqProxy.Type} dictates which pair of ZeroMQ sockets to bind with this proxy\n+ * to implement any possible patterns for ZeroMQ intermediary. Defaults to @link {@link ZeroMqProxy.Type#PULL_PUSH}.\n+ * <p>\n+ * The control socket is exposed as a {@link SocketType#PAIR} with an inter-thread transport\n+ * on tne {@code \"inproc://\" + beanName + \".control\"} address; it can be obtained via {@link #getControlAddress()}.", "originalCommit": "e5e3ec53931af67b8c15a833721162f70e276855", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU0NjAxOQ==", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r467546019", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * This way a sending and receiving operations on this channel are similar to interaction over a messaging broker.\n          \n          \n            \n             * This way sending and receiving operations on this channel are similar to interaction over a messaging broker.", "author": "oli-ver", "createdAt": "2020-08-09T07:00:33Z", "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.zeromq.channel;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import org.zeromq.SocketType;\n+import org.zeromq.ZContext;\n+import org.zeromq.ZMQ;\n+\n+import org.springframework.integration.channel.AbstractMessageChannel;\n+import org.springframework.integration.mapping.BytesMessageMapper;\n+import org.springframework.integration.support.json.EmbeddedJsonHeadersMessageMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.messaging.Message;\n+import org.springframework.messaging.MessageHandler;\n+import org.springframework.messaging.SubscribableChannel;\n+import org.springframework.util.Assert;\n+\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+/**\n+ * The {@link SubscribableChannel} implementation over ZeroMQ sockets.\n+ * It can work in two messaging models:\n+ * - {@code push-pull}, where sent messages are distributed to subscribers in a round-robin manner\n+ * according a respective ZeroMQ {@link SocketType#PUSH} and {@link SocketType#PULL} socket types logic;\n+ * - {@code pub-sub}, where sent messages are distributed to all subscribers;\n+ * <p>\n+ * This message channel can work in local mode, when a pair of ZeroMQ sockets of {@link SocketType#PAIR} type\n+ * are connected between publisher (send operation) and subscriber using inter-thread transport binding.\n+ * <p>\n+ * In distributed mode this channel has to be connected to an externally managed ZeroMQ proxy.\n+ * The {@link #setConnectUrl(String)} has to be as a standard ZeroMQ connect string, but with an extra port\n+ * over the colon - representing a frontend and backend sockets pair on ZeroMQ proxy.\n+ * For example: {@code tcp://localhost:6001:6002}.\n+ * This way a sending and receiving operations on this channel are similar to interaction over a messaging broker.", "originalCommit": "e5e3ec53931af67b8c15a833721162f70e276855", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dc37be3c6ec2631e9cce12d7f37cbca621a75c6d", "url": "https://github.com/spring-projects/spring-integration/commit/dc37be3c6ec2631e9cce12d7f37cbca621a75c6d", "message": "* Add more JavaDocs to `ZeroMqProxy` and `ZeroMqChannel`\n* Expose `ZeroMqChannel.setZeroMqProxy()` option for easier\nconfiguration within the same application context\n* Make `ZeroMqChannel` sockets configuration and connection\ndependant on provided `ZeroMqProxy` (if any)\n* Add `Consumer<ZMQ.Socket>` configuration callbacks to the `ZeroMqChannel`\n* Expose `ZeroMqChannel.consumeDelay` option", "committedDate": "2020-08-10T15:14:38Z", "type": "forcePushed"}, {"oid": "20e962cbc46ab3a484e8fee845bc2e49cacc6863", "url": "https://github.com/spring-projects/spring-integration/commit/20e962cbc46ab3a484e8fee845bc2e49cacc6863", "message": "* Add more JavaDocs to `ZeroMqProxy` and `ZeroMqChannel`\n* Expose `ZeroMqChannel.setZeroMqProxy()` option for easier\nconfiguration within the same application context\n* Make `ZeroMqChannel` sockets configuration and connection\ndependant on provided `ZeroMqProxy` (if any)\n* Add `Consumer<ZMQ.Socket>` configuration callbacks to the `ZeroMqChannel`\n* Expose `ZeroMqChannel.consumeDelay` option", "committedDate": "2020-08-10T20:31:52Z", "type": "forcePushed"}, {"oid": "a47b49849fbe2a08247bc916a95d55065090c26a", "url": "https://github.com/spring-projects/spring-integration/commit/a47b49849fbe2a08247bc916a95d55065090c26a", "message": "INT-3045: Add `ZeroMqChannel` support\n\nJIRA: https://jira.spring.io/browse/INT-3045\n\nProvide a `SubscribableChannel` implementation for ZeroMQ\n\nThe general idea is to let to have a distributed channel implementation\nwhere every client can connect to a single server backed by the channel.\n\nThe logic in the channel is fully transparent for end-user and there is just\nenough to send message to it and subscribe for receiving on the other side.\nIf PUB/SUB model is used, all the subscribes (even over the network) going to\nreceive the same published message.\nIn case of PUSH/PULL only one subscriber in the whole cluster is going to get\nthe published message\n\n* Use Reactor for better threading control\n* JeroMQ is not interruptible-friendly: use control sockets to stop proxy loop\n* Name Reactor's schedulers to avoid daemon threads", "committedDate": "2020-08-11T13:55:31Z", "type": "commit"}, {"oid": "c8bf4152f8be63de83f739f7bf7b77e36af81bc6", "url": "https://github.com/spring-projects/spring-integration/commit/c8bf4152f8be63de83f739f7bf7b77e36af81bc6", "message": "* Use try-catch-with-resource to close sockets automatically\n* Fix Checkstyle violations\n* Use `Mono.handle()` to receive data from the socket", "committedDate": "2020-08-11T13:55:31Z", "type": "commit"}, {"oid": "19c194b0888a8dc1128feb700c3439749902d434", "url": "https://github.com/spring-projects/spring-integration/commit/19c194b0888a8dc1128feb700c3439749902d434", "message": "* Optimize local for just a couple of PAIR sockets\n* Implement TCP binding\n* Add PUB/SUB tests", "committedDate": "2020-08-11T13:55:31Z", "type": "commit"}, {"oid": "df58afe07e8e5e2c227c9cef8a6eb24f0c09a527", "url": "https://github.com/spring-projects/spring-integration/commit/df58afe07e8e5e2c227c9cef8a6eb24f0c09a527", "message": "* Fix subscriber scheduler name\n* Optimize socket create logic\n* Add PUSH/PULL over TCP test", "committedDate": "2020-08-11T13:55:31Z", "type": "commit"}, {"oid": "7cc4c45a4fb0b004fc71f11b09deb329c84c23da", "url": "https://github.com/spring-projects/spring-integration/commit/7cc4c45a4fb0b004fc71f11b09deb329c84c23da", "message": "* Fix subscriber scheduler name\n* Optimize socket create logic\n* Add PUSH/PULL over TCP test\n* Implement PUB/SUB over TCP", "committedDate": "2020-08-11T13:55:31Z", "type": "commit"}, {"oid": "dc4f8c7fded4b8f4154d385df32dbf4dff201533", "url": "https://github.com/spring-projects/spring-integration/commit/dc4f8c7fded4b8f4154d385df32dbf4dff201533", "message": "* Introduce `ZeroMqProxy` - Spring-friendly component to configure and manage ZeroMq proxy\n* Use this `ZeroMqProxy` logic as an external component for `ZeroMqChannel` testing", "committedDate": "2020-08-11T13:55:31Z", "type": "commit"}, {"oid": "1cc2b3fd6ca54edd5f4475383251fbbd61496015", "url": "https://github.com/spring-projects/spring-integration/commit/1cc2b3fd6ca54edd5f4475383251fbbd61496015", "message": "* Fix Checkstyle\n* Apply docs polishing\n* Expose a capture socket on the proxy\n* Implement `DisposableBean` in the `ZeroMqProxy` to destroy an internal executor service\n* Add JavaDocs to `ZeroMqChannel`\n* Add one more `ZeroMqChannel` to TCP test to be sure that proxy distribution works well", "committedDate": "2020-08-11T13:55:31Z", "type": "commit"}, {"oid": "a71f11bebb38e1d6409c2facf28f3bb2a7b321fe", "url": "https://github.com/spring-projects/spring-integration/commit/a71f11bebb38e1d6409c2facf28f3bb2a7b321fe", "message": "* Add `hamcrest-core` dependency for Awatility", "committedDate": "2020-08-11T13:55:31Z", "type": "commit"}, {"oid": "b8c0291d441c6cc09299d5d4d60e3c558f6eddc0", "url": "https://github.com/spring-projects/spring-integration/commit/b8c0291d441c6cc09299d5d4d60e3c558f6eddc0", "message": "* Add more JavaDocs to `ZeroMqProxy` and `ZeroMqChannel`\n* Expose `ZeroMqChannel.setZeroMqProxy()` option for easier\nconfiguration within the same application context\n* Make `ZeroMqChannel` sockets configuration and connection\ndependant on provided `ZeroMqProxy` (if any)\n* Add `Consumer<ZMQ.Socket>` configuration callbacks to the `ZeroMqChannel`\n* Expose `ZeroMqChannel.consumeDelay` option", "committedDate": "2020-08-11T13:55:31Z", "type": "commit"}, {"oid": "411232586565cb8459e0c03d013311d61467bffa", "url": "https://github.com/spring-projects/spring-integration/commit/411232586565cb8459e0c03d013311d61467bffa", "message": "* Add docs for ZeroMQ\n* Some additions into a `reactive-streams.adoc`\n* Fix typo in the `xmpp.adoc`", "committedDate": "2020-08-11T13:55:31Z", "type": "commit"}, {"oid": "95499c0e6e82bb9ded1eda37c901599d0dd732c4", "url": "https://github.com/spring-projects/spring-integration/commit/95499c0e6e82bb9ded1eda37c901599d0dd732c4", "message": "* Add `optional` `jackson-databind` since `ZeroMqChannel` uses it by default\n* More words into docs", "committedDate": "2020-08-11T13:55:31Z", "type": "commit"}, {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d", "url": "https://github.com/spring-projects/spring-integration/commit/642247cbf31fd5010e5fff2082f7786c66912f5d", "message": "* Fix language in docs according review", "committedDate": "2020-08-11T14:10:32Z", "type": "commit"}, {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d", "url": "https://github.com/spring-projects/spring-integration/commit/642247cbf31fd5010e5fff2082f7786c66912f5d", "message": "* Fix language in docs according review", "committedDate": "2020-08-11T14:10:32Z", "type": "forcePushed"}, {"oid": "9e5e23ca35f8b8feb4d0138298c2ed2c0be9c1c5", "url": "https://github.com/spring-projects/spring-integration/commit/9e5e23ca35f8b8feb4d0138298c2ed2c0be9c1c5", "message": "Fix language in docs according review\n\nCo-authored-by: Gary Russell <grussell@vmware.com>", "committedDate": "2020-08-11T16:04:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY1NDU4Nw==", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468654587", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Configure an executor to perform a a ZeroMQ proxy loop.\n          \n          \n            \n            \t * Configure an executor to perform a ZeroMQ proxy loop.", "author": "oli-ver", "createdAt": "2020-08-11T15:07:57Z", "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java", "diffHunk": "@@ -100,28 +101,53 @@\n \n \tprivate int phase;\n \n+\t/**\n+\t * Create a {@link ZeroMqProxy} instance based on the provided {@link ZContext}\n+\t * and {@link Type#PULL_PUSH} as default mode.\n+\t * @param context the {@link ZContext} to use\n+\t */\n \tpublic ZeroMqProxy(ZContext context) {\n \t\tthis(context, Type.PULL_PUSH);\n \t}\n \n+\t/**\n+\t * Create a {@link ZeroMqProxy} instance based on the provided {@link ZContext}\n+\t * and {@link Type}.\n+\t * @param context the {@link ZContext} to use\n+\t * @param type the {@link Type} to use.\n+\t */\n \tpublic ZeroMqProxy(ZContext context, Type type) {\n \t\tAssert.notNull(context, \"'context' must not be null\");\n \t\tAssert.notNull(type, \"'type' must not be null\");\n \t\tthis.context = context;\n \t\tthis.type = type;\n \t}\n \n+\t/**\n+\t * Configure an executor to perform a a ZeroMQ proxy loop.", "originalCommit": "b8c0291d441c6cc09299d5d4d60e3c558f6eddc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY1NTI1Nw==", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468655257", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * frontend and backend ports are evaluated from this proxy and respective connection string is built from them.\n          \n          \n            \n             * frontend and backend ports are evaluated from this proxy and the respective connection string is built from them.", "author": "oli-ver", "createdAt": "2020-08-11T15:08:54Z", "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -55,7 +57,10 @@\n  * The {@link #setConnectUrl(String)} has to be as a standard ZeroMQ connect string, but with an extra port\n  * over the colon - representing a frontend and backend sockets pair on ZeroMQ proxy.\n  * For example: {@code tcp://localhost:6001:6002}.\n- * This way a sending and receiving operations on this channel are similar to interaction over a messaging broker.\n+ * Another option is to provide a reference to the {@link ZeroMqProxy} instance managed in the same application:\n+ * frontend and backend ports are evaluated from this proxy and respective connection string is built from them.", "originalCommit": "b8c0291d441c6cc09299d5d4d60e3c558f6eddc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2MDUzOA==", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468660538", "bodyText": "I think you could use the consumeDelay also here.", "author": "oli-ver", "createdAt": "2020-08-11T15:16:10Z", "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -107,30 +123,51 @@ public ZeroMqChannel(ZContext context, boolean pubSub) {\n \n \t\tSupplier<String> localPairConnection = () -> \"inproc://\" + getComponentName() + \".pair\";\n \n+\t\tMono<?> proxyMono =\n+\t\t\t\tMono.defer(() -> {\n+\t\t\t\t\tif (this.zeroMqProxy != null) {\n+\t\t\t\t\t\treturn Mono.just(this.zeroMqProxy.getBackendPort())\n+\t\t\t\t\t\t\t\t.filter((port) -> port > 0)\n+\t\t\t\t\t\t\t\t.repeatWhenEmpty((repeat) -> repeat.delayElements(Duration.ofMillis(100))) // NOSONAR", "originalCommit": "b8c0291d441c6cc09299d5d4d60e3c558f6eddc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2MTE5Nw==", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468661197", "bodyText": "Ah wait: It's another delay, only 100 millis. Perhaps worth another repeatDelay variable?", "author": "oli-ver", "createdAt": "2020-08-11T15:17:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2MDUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcwNzcxOQ==", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468707719", "bodyText": "Yeah... I don't think so. This is really just busy-spin until the proxy is started with selected port.\nIt is fully not related to the end-user logic.", "author": "artembilan", "createdAt": "2020-08-11T16:25:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2MDUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2NTg4MQ==", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468665881", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\"Or 'zeroMqProxy' or 'connectUrl' can be provided (or none), but not both.\");\n          \n          \n            \n            \t\t\t\t\"A 'zeroMqProxy' or 'connectUrl' can be provided (or none), but not both.\");", "author": "oli-ver", "createdAt": "2020-08-11T15:23:07Z", "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -182,13 +225,40 @@ public void setConnectUrl(@Nullable String connectUrl) {\n \t\t}\n \t}\n \n+\t/**\n+\t * Specify a reference to a {@link ZeroMqProxy} instance in the same application\n+\t * to rely on its ports configuration and make a natural lifecycle dependency without guessing\n+\t * when the proxy is started. Mutually exclusive with the {@link #setConnectUrl(String)}.\n+\t * @param zeroMqProxy the {@link ZeroMqProxy} instance to use\n+\t */\n+\tpublic void setZeroMqProxy(@Nullable ZeroMqProxy zeroMqProxy) {\n+\t\tthis.zeroMqProxy = zeroMqProxy;\n+\t}\n+\n+\tpublic void setConsumeDelay(Duration consumeDelay) {\n+\t\tAssert.notNull(consumeDelay, \"'consumeDelay' must not be null\");\n+\t\tthis.consumeDelay = consumeDelay;\n+\t}\n+\n \tpublic void setMessageMapper(BytesMessageMapper messageMapper) {\n \t\tAssert.notNull(messageMapper, \"'messageMapper' must not be null\");\n \t\tthis.messageMapper = messageMapper;\n \t}\n \n+\tpublic void setSendSocketConfigurer(Consumer<ZMQ.Socket> sendSocketConfigurer) {\n+\t\tAssert.notNull(sendSocketConfigurer, \"'sendSocketConfigurer' must not be null\");\n+\t\tthis.sendSocketConfigurer = sendSocketConfigurer;\n+\t}\n+\n+\tpublic void setSubscribeSocketConfigurer(Consumer<ZMQ.Socket> subscribeSocketConfigurer) {\n+\t\tAssert.notNull(subscribeSocketConfigurer, \"'subscribeSocketConfigurer' must not be null\");\n+\t\tthis.subscribeSocketConfigurer = subscribeSocketConfigurer;\n+\t}\n+\n \t@Override\n \tprotected void onInit() {\n+\t\tAssert.state(this.zeroMqProxy == null || this.connectSendUrl == null,\n+\t\t\t\t\"Or 'zeroMqProxy' or 'connectUrl' can be provided (or none), but not both.\");", "originalCommit": "b8c0291d441c6cc09299d5d4d60e3c558f6eddc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY5MjcwNA==", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468692704", "bodyText": "Should this perhaps be handeled by an Assertstatement? This way it's just silently ignored when someone tries to set the connectUrl to null.", "author": "oli-ver", "createdAt": "2020-08-11T16:01:56Z", "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.zeromq.channel;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import org.zeromq.SocketType;\n+import org.zeromq.ZContext;\n+import org.zeromq.ZMQ;\n+\n+import org.springframework.integration.channel.AbstractMessageChannel;\n+import org.springframework.integration.mapping.BytesMessageMapper;\n+import org.springframework.integration.support.json.EmbeddedJsonHeadersMessageMapper;\n+import org.springframework.integration.zeromq.ZeroMqProxy;\n+import org.springframework.lang.Nullable;\n+import org.springframework.messaging.Message;\n+import org.springframework.messaging.MessageHandler;\n+import org.springframework.messaging.SubscribableChannel;\n+import org.springframework.util.Assert;\n+\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+/**\n+ * The {@link SubscribableChannel} implementation over ZeroMQ sockets.\n+ * It can work in two messaging models:\n+ * - {@code push-pull}, where sent messages are distributed to subscribers in a round-robin manner\n+ * according a respective ZeroMQ {@link SocketType#PUSH} and {@link SocketType#PULL} socket types logic;\n+ * - {@code pub-sub}, where sent messages are distributed to all subscribers;\n+ * <p>\n+ * This message channel can work in local mode, when a pair of ZeroMQ sockets of {@link SocketType#PAIR} type\n+ * are connected between publisher (send operation) and subscriber using inter-thread transport binding.\n+ * <p>\n+ * In distributed mode this channel has to be connected to an externally managed ZeroMQ proxy.\n+ * The {@link #setConnectUrl(String)} has to be as a standard ZeroMQ connect string, but with an extra port\n+ * over the colon - representing a frontend and backend sockets pair on ZeroMQ proxy.\n+ * For example: {@code tcp://localhost:6001:6002}.\n+ * Another option is to provide a reference to the {@link ZeroMqProxy} instance managed in the same application:\n+ * frontend and backend ports are evaluated from this proxy and respective connection string is built from them.\n+ * <p>\n+ * This way sending and receiving operations on this channel are similar to interaction over a messaging broker.\n+ * <p>\n+ * An internal logic of this message channel implementation is based on the project Reactor using its\n+ * {@link Mono}, {@link Flux} and {@link Scheduler} API for better thead model and flow control to avoid\n+ * concurrency primitives for multi-publisher(subscriber) communication within the same application.\n+ *\n+ * @author Artem Bilan\n+ *\n+ * @since 5.4\n+ */\n+public class ZeroMqChannel extends AbstractMessageChannel implements SubscribableChannel {\n+\n+\tpublic static final Duration DEFAULT_CONSUME_DELAY = Duration.ofSeconds(1);\n+\n+\tprivate final Map<MessageHandler, Disposable> subscribers = new HashMap<>();\n+\n+\tprivate final Scheduler publisherScheduler = Schedulers.newSingle(\"publisherScheduler\");\n+\n+\tprivate final Scheduler subscriberScheduler = Schedulers.newSingle(\"subscriberScheduler\");\n+\n+\tprivate final ZContext context;\n+\n+\tprivate final boolean pubSub;\n+\n+\tprivate final Mono<ZMQ.Socket> sendSocket;\n+\n+\tprivate final Mono<ZMQ.Socket> subscribeSocket;\n+\n+\tprivate final Flux<? extends Message<?>> subscriberData;\n+\n+\tprivate Duration consumeDelay = DEFAULT_CONSUME_DELAY;\n+\n+\tprivate BytesMessageMapper messageMapper = new EmbeddedJsonHeadersMessageMapper();\n+\n+\tprivate Consumer<ZMQ.Socket> sendSocketConfigurer = (socket) -> { };\n+\n+\tprivate Consumer<ZMQ.Socket> subscribeSocketConfigurer = (socket) -> { };\n+\n+\t@Nullable\n+\tprivate ZeroMqProxy zeroMqProxy;\n+\n+\t@Nullable\n+\tprivate volatile String connectSendUrl;\n+\n+\t@Nullable\n+\tprivate volatile String connectSubscribeUrl;\n+\n+\t@Nullable\n+\tprivate volatile Disposable subscriberDataDisposable;\n+\n+\tprivate volatile boolean initialized;\n+\n+\tpublic ZeroMqChannel(ZContext context) {\n+\t\tthis(context, false);\n+\t}\n+\n+\tpublic ZeroMqChannel(ZContext context, boolean pubSub) {\n+\t\tAssert.notNull(context, \"'context' must not be null\");\n+\t\tthis.context = context;\n+\t\tthis.pubSub = pubSub;\n+\n+\t\tSupplier<String> localPairConnection = () -> \"inproc://\" + getComponentName() + \".pair\";\n+\n+\t\tMono<?> proxyMono =\n+\t\t\t\tMono.defer(() -> {\n+\t\t\t\t\tif (this.zeroMqProxy != null) {\n+\t\t\t\t\t\treturn Mono.just(this.zeroMqProxy.getBackendPort())\n+\t\t\t\t\t\t\t\t.filter((port) -> port > 0)\n+\t\t\t\t\t\t\t\t.repeatWhenEmpty((repeat) -> repeat.delayElements(Duration.ofMillis(100))) // NOSONAR\n+\t\t\t\t\t\t\t\t.doOnNext((port) ->\n+\t\t\t\t\t\t\t\t\t\tsetConnectUrl(\"tcp://localhost:\" + this.zeroMqProxy.getFrontendPort() +\n+\t\t\t\t\t\t\t\t\t\t\t\t':' + this.zeroMqProxy.getBackendPort()));\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\treturn Mono.empty();\n+\t\t\t\t\t}\n+\t\t\t\t})\n+\t\t\t\t\t\t.cache();\n+\n+\t\tthis.sendSocket =\n+\t\t\t\tproxyMono\n+\t\t\t\t\t\t.publishOn(this.publisherScheduler)\n+\t\t\t\t\t\t.then(Mono.fromCallable(() ->\n+\t\t\t\t\t\t\t\tthis.context.createSocket(\n+\t\t\t\t\t\t\t\t\t\tthis.connectSendUrl == null\n+\t\t\t\t\t\t\t\t\t\t\t\t? SocketType.PAIR\n+\t\t\t\t\t\t\t\t\t\t\t\t: (this.pubSub ? SocketType.XPUB : SocketType.PUSH))\n+\t\t\t\t\t\t))\n+\t\t\t\t\t\t.doOnNext(this.sendSocketConfigurer)\n+\t\t\t\t\t\t.doOnNext((socket) ->\n+\t\t\t\t\t\t\t\tsocket.connect(this.connectSendUrl != null\n+\t\t\t\t\t\t\t\t\t\t? this.connectSendUrl\n+\t\t\t\t\t\t\t\t\t\t: localPairConnection.get()))\n+\t\t\t\t\t\t.delayUntil((socket) ->\n+\t\t\t\t\t\t\t\t(this.pubSub && this.connectSendUrl != null)\n+\t\t\t\t\t\t\t\t\t\t? Mono.just(socket).map(ZMQ.Socket::recv)\n+\t\t\t\t\t\t\t\t\t\t: Mono.empty())\n+\t\t\t\t\t\t.cache();\n+\n+\t\tthis.subscribeSocket =\n+\t\t\t\tproxyMono\n+\t\t\t\t\t\t.publishOn(this.subscriberScheduler)\n+\t\t\t\t\t\t.then(Mono.fromCallable(() ->\n+\t\t\t\t\t\t\t\tthis.context.createSocket(\n+\t\t\t\t\t\t\t\t\t\tthis.connectSubscribeUrl == null\n+\t\t\t\t\t\t\t\t\t\t\t\t? SocketType.PAIR\n+\t\t\t\t\t\t\t\t\t\t\t\t: (this.pubSub ? SocketType.SUB : SocketType.PULL))))\n+\t\t\t\t\t\t.doOnNext(this.subscribeSocketConfigurer)\n+\t\t\t\t\t\t.doOnNext((socket) -> {\n+\t\t\t\t\t\t\tif (this.connectSubscribeUrl != null) {\n+\t\t\t\t\t\t\t\tsocket.connect(this.connectSubscribeUrl);\n+\t\t\t\t\t\t\t\tif (this.pubSub) {\n+\t\t\t\t\t\t\t\t\tsocket.subscribe(ZMQ.SUBSCRIPTION_ALL);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t\tsocket.bind(localPairConnection.get());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t})\n+\t\t\t\t\t\t.cache();\n+\n+\t\tFlux<? extends Message<?>> receiveData =\n+\t\t\t\tthis.subscribeSocket\n+\t\t\t\t\t\t.flatMap((socket) -> {\n+\t\t\t\t\t\t\tif (this.initialized) {\n+\t\t\t\t\t\t\t\tbyte[] data = socket.recv(ZMQ.NOBLOCK);\n+\t\t\t\t\t\t\t\tif (data != null) {\n+\t\t\t\t\t\t\t\t\treturn Mono.just(data);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\treturn Mono.empty();\n+\t\t\t\t\t\t})\n+\t\t\t\t\t\t.publishOn(Schedulers.parallel())\n+\t\t\t\t\t\t.map(this.messageMapper::toMessage)\n+\t\t\t\t\t\t.doOnError((error) -> logger.error(\"Error processing ZeroMQ message\", error))\n+\t\t\t\t\t\t.repeatWhenEmpty((repeat) ->\n+\t\t\t\t\t\t\t\tthis.initialized\n+\t\t\t\t\t\t\t\t\t\t? repeat.delayElements(this.consumeDelay)\n+\t\t\t\t\t\t\t\t\t\t: repeat)\n+\t\t\t\t\t\t.repeat(() -> this.initialized);\n+\n+\t\tif (this.pubSub) {\n+\t\t\treceiveData = receiveData.publish()\n+\t\t\t\t\t.autoConnect(1, (disposable) -> this.subscriberDataDisposable = disposable);\n+\t\t}\n+\n+\t\tthis.subscriberData = receiveData;\n+\n+\t}\n+\n+\t/**\n+\t * Configure a connection to the ZeroMQ proxy with the pair of ports over colon\n+\t * for proxy frontend and backend sockets. Mutually exclusive with the {@link #setZeroMqProxy(ZeroMqProxy)}.\n+\t * @param connectUrl the connection string in format {@code PROTOCOL://HOST:FRONTEND_PORT:BACKEND_PORT},\n+\t *                    e.g. {@code tcp://localhost:6001:6002}\n+\t */\n+\tpublic void setConnectUrl(@Nullable String connectUrl) {\n+\t\tif (connectUrl != null) {", "originalCommit": "642247cbf31fd5010e5fff2082f7786c66912f5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxNjIwNA==", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468716204", "bodyText": "I don't think so. This option really can be as a null.\nImagine a Spring Boot configuration property when you just propagate it into this setter.\nIn one environment it can be empty (or missed) and will make this channel in a local mode, e.g. for testing.\nIn another env it is going to have some reasonable value for connection to the proxy.\nIndependently of the env your code around this channel configuration is going to be the same.", "author": "artembilan", "createdAt": "2020-08-11T16:38:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY5MjcwNA=="}], "type": "inlineReview"}, {"oid": "cafc55c858e29e541e311d1ba8cba437a1c61319", "url": "https://github.com/spring-projects/spring-integration/commit/cafc55c858e29e541e311d1ba8cba437a1c61319", "message": "Apply suggestions from code review\n\nCo-authored-by: Oliver <oli-ver@users.noreply.github.com>", "committedDate": "2020-08-11T16:39:09Z", "type": "commit"}, {"oid": "0a656cc16fac20779baf41ea6a504a446541a6fd", "url": "https://github.com/spring-projects/spring-integration/commit/0a656cc16fac20779baf41ea6a504a446541a6fd", "message": "* Fix threading using a `publishOn()` for specific scheduler after `cache()`", "committedDate": "2020-08-11T17:48:00Z", "type": "commit"}, {"oid": "624714550ddd330aedf551f16a4371e73643ea57", "url": "https://github.com/spring-projects/spring-integration/commit/624714550ddd330aedf551f16a4371e73643ea57", "message": "* Remove unused import", "committedDate": "2020-08-11T17:55:19Z", "type": "commit"}, {"oid": "bff5d8df71fa53fae6cb309c6afc1be52dcc3edf", "url": "https://github.com/spring-projects/spring-integration/commit/bff5d8df71fa53fae6cb309c6afc1be52dcc3edf", "message": "* Change proxy port check from static `Mono.just()` to `Mono.fromCallable()`\nto really evaluate the current port state on every repeat\n* Add finite `100` repeat number to avoid infinite blocking when proxy is not started at all\n* Add `doOnError()` for proxy `Mono` to log `ERROR` when repeat is exhausted", "committedDate": "2020-08-11T18:37:45Z", "type": "commit"}, {"oid": "afff1d317311648bfeb9db87565985ab2f87b331", "url": "https://github.com/spring-projects/spring-integration/commit/afff1d317311648bfeb9db87565985ab2f87b331", "message": "* Fix Checkstyle violation", "committedDate": "2020-08-11T18:54:23Z", "type": "commit"}]}