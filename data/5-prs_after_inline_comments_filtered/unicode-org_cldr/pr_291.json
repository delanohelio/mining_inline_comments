{"pr_number": 291, "pr_title": "CLDR-13488 add unit conversions", "pr_createdAt": "2020-01-09T14:13:33Z", "pr_url": "https://github.com/unicode-org/cldr/pull/291", "timeline": [{"oid": "96e135148e57ed44ce04bd745b7eae04cf9e8a03", "url": "https://github.com/unicode-org/cldr/commit/96e135148e57ed44ce04bd745b7eae04cf9e8a03", "message": "CLDR-13488 add unit conversions\n\nSee #291", "committedDate": "2020-01-10T14:56:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTA4MjA3Nw==", "url": "https://github.com/unicode-org/cldr/pull/291#discussion_r371082077", "bodyText": "\"pow\"?", "author": "sffc", "createdAt": "2020-01-27T06:47:12Z", "path": "tools/java/org/unicode/cldr/util/UnitConverter.java", "diffHunk": "@@ -0,0 +1,553 @@\n+package org.unicode.cldr.util;\n+\n+import java.math.MathContext;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import org.unicode.cldr.util.Rational.RationalParser;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.TreeMultimap;\n+import com.ibm.icu.util.Freezable;\n+import com.ibm.icu.util.Output;\n+\n+public class UnitConverter implements Freezable<UnitConverter> {\n+\n+    static final Splitter BAR_SPLITTER = Splitter.on('-');\n+\n+    final RationalParser rationalParser;\n+\n+    Map<String, Map<String,UnitInfo>> sourceToTargetToInfo = new TreeMap<>();\n+    Map<String, String> toBaseUnit = new TreeMap<>();\n+    Set<String> baseUnits;\n+    Multimap<String, Continuation> continuations = TreeMultimap.create();\n+\n+    private boolean frozen = false;\n+\n+    @Override\n+    public boolean isFrozen() {\n+        return frozen;\n+    }\n+\n+    @Override\n+    public UnitConverter freeze() {\n+        frozen = true;\n+        rationalParser.freeze();\n+        sourceToTargetToInfo = ImmutableMap.copyOf(sourceToTargetToInfo);\n+        toBaseUnit = ImmutableMap.copyOf(toBaseUnit);\n+        baseUnits = ImmutableSet.<String>builder()\n+            .addAll(BASE_UNITS)\n+            .addAll(toBaseUnit.values())\n+            .build();\n+        continuations = ImmutableMultimap.copyOf(continuations);\n+        return this;\n+    }\n+\n+    @Override\n+    public UnitConverter cloneAsThawed() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+\n+    public static final class UnitInfo {\n+        public final Rational factor;\n+        public final Rational offset;\n+        public final boolean reciprocal;\n+\n+        static final UnitInfo IDENTITY = new UnitInfo(Rational.ONE, Rational.ZERO, false);\n+\n+        public UnitInfo(Rational factor, Rational offset, boolean reciprocal) {\n+            this.factor = factor;\n+            this.offset = offset;\n+            this.reciprocal = reciprocal;\n+        }\n+\n+        /** For now, just convert with doubles */\n+        public Rational convert(Rational source) {\n+            if (reciprocal) {\n+                source = source.reciprocal();\n+            }\n+            return source.multiply(factor).add(offset);\n+        }\n+\n+        public UnitInfo invert() {\n+            Rational factor2 = factor.reciprocal();\n+            Rational offset2 = offset.equals(Rational.ZERO) ? Rational.ZERO : offset.divide(factor).negate();\n+            return new UnitInfo(factor2, offset2, reciprocal);\n+            // TODO fix reciprocal\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return factor \n+                + (reciprocal ? \" / x\" : \" * x\") \n+                + (offset.equals(Rational.ZERO) ? \"\" : \n+                    (offset.compareTo(Rational.ZERO) < 0 ? \" - \" : \" - \")\n+                    + offset.abs());\n+        }\n+\n+        public String toDecimal() {\n+            return factor.toBigDecimal(MathContext.DECIMAL64) \n+                + (reciprocal ? \" / x\" : \" * x\") \n+                + (offset.equals(Rational.ZERO) ? \"\" : \n+                    (offset.compareTo(Rational.ZERO) < 0 ? \" - \" : \" - \")\n+                    + offset.toBigDecimal(MathContext.DECIMAL64).abs());\n+        }\n+    }\n+\n+    static class Continuation implements Comparable<Continuation> {\n+        public final List<String> remainder;\n+        public final String result;\n+\n+        public static void addIfNeeded(String source, Multimap<String, Continuation> data) {\n+            List<String> sourceParts = BAR_SPLITTER.splitToList(source);\n+            if (sourceParts.size() > 1) {\n+                Continuation continuation = new Continuation(ImmutableList.copyOf(sourceParts.subList(1, sourceParts.size())), source);\n+                data.put(sourceParts.get(0), continuation);\n+            }\n+        }\n+        private Continuation(List<String> remainder, String source) {\n+            this.remainder = remainder;\n+            this.result = source;\n+        }\n+        /**\n+         * The ordering is designed to have longest continuation first so that matching works.\n+         * Otherwise the ordering doesn't matter, so we just use the result.\n+         */\n+        @Override\n+        public int compareTo(Continuation other) {\n+            int diff = other.remainder.size() - remainder.size();\n+            if (diff < 0) {\n+                return diff;\n+            }\n+            return result.compareTo(other.result);\n+        }\n+\n+        public boolean match(List<String> parts, final int startIndex) {\n+            if (remainder.size() > parts.size() - startIndex) {\n+                return false;\n+            }\n+            int i = startIndex;\n+            for (String unitPart : remainder) {\n+                if (!unitPart.equals(parts.get(i++))) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return remainder + \" \ud83e\udca3 \" + result;\n+        }\n+\n+        public static Iterable<String> split(String derivedUnit, Multimap<String, Continuation> continuations) {\n+            return new UnitIterator(derivedUnit, continuations);\n+        }\n+\n+        public static class UnitIterator implements Iterable<String>, Iterator<String> {\n+            final List<String> parts;\n+            final Multimap<String, Continuation> continuations;\n+            int nextIndex = 0;\n+\n+            public UnitIterator(String derivedUnit, Multimap<String, Continuation> continuations) {\n+                parts = BAR_SPLITTER.splitToList(derivedUnit);\n+                this.continuations = continuations;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                return nextIndex < parts.size();\n+            }\n+\n+            @Override\n+            public String next() {\n+                String result = parts.get(nextIndex++);\n+                Collection<Continuation> continuationOptions = continuations.get(result);\n+                for (Continuation option : continuationOptions) {\n+                    if (option.match(parts, nextIndex)) {\n+                        nextIndex += option.remainder.size();\n+                        return option.result;\n+                    }\n+                }\n+                return result;\n+            }\n+\n+            @Override\n+            public Iterator<String> iterator() {\n+                return this;\n+            }\n+\n+        }\n+    }\n+\n+    public UnitConverter(RationalParser rationalParser) {\n+        this.rationalParser = rationalParser;\n+    }\n+\n+    public void addRaw(String source, String target, String factor, String offset, String reciprocal) {\n+        UnitInfo info = new UnitInfo(\n+            factor == null ? Rational.ONE : rationalParser.parse(factor), \n+                offset == null ? Rational.ZERO : rationalParser.parse(offset), \n+                    reciprocal == null ? false : reciprocal.equalsIgnoreCase(\"true\") ? true : false);\n+\n+        addToSourceToTarget(source, target, info);\n+        addToSourceToTarget(target, source, info.invert());\n+        toBaseUnit.put(source, target);\n+        Continuation.addIfNeeded(source, continuations);\n+    }\n+\n+    private void addToSourceToTarget(String source, String target, UnitInfo info) {\n+        Map<String, UnitInfo> targetToInfo = sourceToTargetToInfo.get(source);\n+        if (targetToInfo == null) {\n+            sourceToTargetToInfo.put(source, targetToInfo = new TreeMap<>());\n+        }\n+        if (targetToInfo.containsKey(target)) {\n+            throw new IllegalArgumentException(\"Duplicate source/target: \" + source + \", \" + target);\n+        }\n+        targetToInfo.put(target, info);\n+    }\n+\n+    public Set<String> canConvertBetween(String unit) {\n+        Set<String> result = new TreeSet<>();\n+        Map<String, UnitInfo> targetToInfo = sourceToTargetToInfo.get(unit);\n+        if (targetToInfo == null) {\n+            return Collections.emptySet();\n+        }\n+        result.addAll(targetToInfo.keySet());\n+        for (String pivot : targetToInfo.keySet()) {\n+            Map<String, UnitInfo> pivotToInfo = sourceToTargetToInfo.get(pivot);\n+            result.addAll(pivotToInfo.keySet());\n+        }\n+        return result;\n+    }\n+\n+    public Set<String> canConvert() {\n+        return sourceToTargetToInfo.keySet();\n+    }\n+\n+    public Map<String, String> simpleToBaseUnits() {\n+        return toBaseUnit;\n+    }\n+\n+\n+    public Rational convert(Rational source, String sourceUnit, String targetUnit) {\n+        Map<String, UnitInfo> targetToInfo = sourceToTargetToInfo.get(sourceUnit);\n+        if (targetToInfo == null) {\n+            return Rational.NaN;\n+        }\n+        UnitInfo info = targetToInfo.get(targetUnit); \n+        if (info != null) {\n+            return info.convert(source);\n+        }\n+        // try pivot\n+        Map<String, UnitInfo> sourceToInfo = sourceToTargetToInfo.get(targetUnit);\n+        if (sourceToInfo == null) {\n+            return Rational.NaN;\n+        }\n+        HashSet<String> pivots = new HashSet<>(targetToInfo.keySet());\n+        pivots.retainAll(sourceToInfo.keySet());\n+        if (pivots.isEmpty()) {\n+            return Rational.NaN;\n+        }\n+        String pivot = pivots.iterator().next();\n+        info = targetToInfo.get(pivot);\n+        Rational temp = info.convert(source);\n+\n+        Map<String, UnitInfo> pivotToInfo = sourceToTargetToInfo.get(pivot);\n+        UnitInfo info2 = pivotToInfo.get(targetUnit);\n+        return info2.convert(temp);\n+    }\n+\n+    // TODO fix to guarantee single mapping\n+\n+    public UnitInfo getUnitInfo(String sourceUnit, Output<String> baseUnit) {\n+        if (isBaseUnit(sourceUnit)) {\n+            return null;\n+        }\n+        Map<String, UnitInfo> targetToInfo = sourceToTargetToInfo.get(sourceUnit);\n+        if (targetToInfo == null) {\n+            return null;\n+        }\n+        Entry<String, UnitInfo> data = targetToInfo.entrySet().iterator().next();\n+        baseUnit.value = data.getKey();\n+        return data.getValue();\n+    }\n+\n+    static final ImmutableMap<String, String> FIX_DENORMALIZED = ImmutableMap.of(\n+        \"meter-per-second-squared\", \"meter-per-square-second\",\n+        \"liter-per-100kilometers\", \"liter-per-100-kilometer\",\n+        \"pound-foot\", \"pound-force-foot\",\n+        \"pound-per-square-inch\", \"pound-force-per-square-inch\");\n+\n+    /**\n+     * Takes a derived unit id, and produces the equivalent derived base unit id and UnitInfo to convert to it\n+     * @author markdavis\n+     *\n+     */\n+    public UnitInfo parseUnitId (String derivedUnit, Output<String> metricUnit) {\n+        metricUnit.value = null;\n+\n+        if (derivedUnit.equals(\"liter-per-100kilometers\")) {\n+            int debug = 0;\n+        }\n+        UnitId outputUnit = new UnitId();\n+        Rational numerator = Rational.ONE;\n+        Rational denominator = Rational.ONE;\n+        boolean inNumerator = true;\n+        int power = 1;\n+\n+        Output<Rational> deprefix = new Output<>();\n+\n+        String fixed = FIX_DENORMALIZED.get(derivedUnit);\n+        if (fixed != null) {\n+            derivedUnit = fixed;\n+        }\n+\n+        for (String unit : Continuation.split(derivedUnit, continuations)) {\n+\n+            if (unit.equals(\"square\")) {\n+                if (power != 1) {\n+                    throw new IllegalArgumentException(\"Can't have power of \" + unit);\n+                }\n+                power = 2;\n+            } else if (unit.equals(\"cubic\")) {\n+                if (power != 1) {\n+                    throw new IllegalArgumentException(\"Can't have power of \" + unit);\n+                }\n+                power = 3;\n+            } else if (unit.startsWith(\"pow\")) {", "originalCommit": "b840e1019ca7577600fcf6c8808742639d5b1420", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTA4MjM2NQ==", "url": "https://github.com/unicode-org/cldr/pull/291#discussion_r371082365", "bodyText": "We still need to discuss putting rationals into the unit identifier", "author": "sffc", "createdAt": "2020-01-27T06:48:53Z", "path": "tools/java/org/unicode/cldr/util/UnitConverter.java", "diffHunk": "@@ -0,0 +1,553 @@\n+package org.unicode.cldr.util;\n+\n+import java.math.MathContext;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import org.unicode.cldr.util.Rational.RationalParser;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.TreeMultimap;\n+import com.ibm.icu.util.Freezable;\n+import com.ibm.icu.util.Output;\n+\n+public class UnitConverter implements Freezable<UnitConverter> {\n+\n+    static final Splitter BAR_SPLITTER = Splitter.on('-');\n+\n+    final RationalParser rationalParser;\n+\n+    Map<String, Map<String,UnitInfo>> sourceToTargetToInfo = new TreeMap<>();\n+    Map<String, String> toBaseUnit = new TreeMap<>();\n+    Set<String> baseUnits;\n+    Multimap<String, Continuation> continuations = TreeMultimap.create();\n+\n+    private boolean frozen = false;\n+\n+    @Override\n+    public boolean isFrozen() {\n+        return frozen;\n+    }\n+\n+    @Override\n+    public UnitConverter freeze() {\n+        frozen = true;\n+        rationalParser.freeze();\n+        sourceToTargetToInfo = ImmutableMap.copyOf(sourceToTargetToInfo);\n+        toBaseUnit = ImmutableMap.copyOf(toBaseUnit);\n+        baseUnits = ImmutableSet.<String>builder()\n+            .addAll(BASE_UNITS)\n+            .addAll(toBaseUnit.values())\n+            .build();\n+        continuations = ImmutableMultimap.copyOf(continuations);\n+        return this;\n+    }\n+\n+    @Override\n+    public UnitConverter cloneAsThawed() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+\n+    public static final class UnitInfo {\n+        public final Rational factor;\n+        public final Rational offset;\n+        public final boolean reciprocal;\n+\n+        static final UnitInfo IDENTITY = new UnitInfo(Rational.ONE, Rational.ZERO, false);\n+\n+        public UnitInfo(Rational factor, Rational offset, boolean reciprocal) {\n+            this.factor = factor;\n+            this.offset = offset;\n+            this.reciprocal = reciprocal;\n+        }\n+\n+        /** For now, just convert with doubles */\n+        public Rational convert(Rational source) {\n+            if (reciprocal) {\n+                source = source.reciprocal();\n+            }\n+            return source.multiply(factor).add(offset);\n+        }\n+\n+        public UnitInfo invert() {\n+            Rational factor2 = factor.reciprocal();\n+            Rational offset2 = offset.equals(Rational.ZERO) ? Rational.ZERO : offset.divide(factor).negate();\n+            return new UnitInfo(factor2, offset2, reciprocal);\n+            // TODO fix reciprocal\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return factor \n+                + (reciprocal ? \" / x\" : \" * x\") \n+                + (offset.equals(Rational.ZERO) ? \"\" : \n+                    (offset.compareTo(Rational.ZERO) < 0 ? \" - \" : \" - \")\n+                    + offset.abs());\n+        }\n+\n+        public String toDecimal() {\n+            return factor.toBigDecimal(MathContext.DECIMAL64) \n+                + (reciprocal ? \" / x\" : \" * x\") \n+                + (offset.equals(Rational.ZERO) ? \"\" : \n+                    (offset.compareTo(Rational.ZERO) < 0 ? \" - \" : \" - \")\n+                    + offset.toBigDecimal(MathContext.DECIMAL64).abs());\n+        }\n+    }\n+\n+    static class Continuation implements Comparable<Continuation> {\n+        public final List<String> remainder;\n+        public final String result;\n+\n+        public static void addIfNeeded(String source, Multimap<String, Continuation> data) {\n+            List<String> sourceParts = BAR_SPLITTER.splitToList(source);\n+            if (sourceParts.size() > 1) {\n+                Continuation continuation = new Continuation(ImmutableList.copyOf(sourceParts.subList(1, sourceParts.size())), source);\n+                data.put(sourceParts.get(0), continuation);\n+            }\n+        }\n+        private Continuation(List<String> remainder, String source) {\n+            this.remainder = remainder;\n+            this.result = source;\n+        }\n+        /**\n+         * The ordering is designed to have longest continuation first so that matching works.\n+         * Otherwise the ordering doesn't matter, so we just use the result.\n+         */\n+        @Override\n+        public int compareTo(Continuation other) {\n+            int diff = other.remainder.size() - remainder.size();\n+            if (diff < 0) {\n+                return diff;\n+            }\n+            return result.compareTo(other.result);\n+        }\n+\n+        public boolean match(List<String> parts, final int startIndex) {\n+            if (remainder.size() > parts.size() - startIndex) {\n+                return false;\n+            }\n+            int i = startIndex;\n+            for (String unitPart : remainder) {\n+                if (!unitPart.equals(parts.get(i++))) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return remainder + \" \ud83e\udca3 \" + result;\n+        }\n+\n+        public static Iterable<String> split(String derivedUnit, Multimap<String, Continuation> continuations) {\n+            return new UnitIterator(derivedUnit, continuations);\n+        }\n+\n+        public static class UnitIterator implements Iterable<String>, Iterator<String> {\n+            final List<String> parts;\n+            final Multimap<String, Continuation> continuations;\n+            int nextIndex = 0;\n+\n+            public UnitIterator(String derivedUnit, Multimap<String, Continuation> continuations) {\n+                parts = BAR_SPLITTER.splitToList(derivedUnit);\n+                this.continuations = continuations;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                return nextIndex < parts.size();\n+            }\n+\n+            @Override\n+            public String next() {\n+                String result = parts.get(nextIndex++);\n+                Collection<Continuation> continuationOptions = continuations.get(result);\n+                for (Continuation option : continuationOptions) {\n+                    if (option.match(parts, nextIndex)) {\n+                        nextIndex += option.remainder.size();\n+                        return option.result;\n+                    }\n+                }\n+                return result;\n+            }\n+\n+            @Override\n+            public Iterator<String> iterator() {\n+                return this;\n+            }\n+\n+        }\n+    }\n+\n+    public UnitConverter(RationalParser rationalParser) {\n+        this.rationalParser = rationalParser;\n+    }\n+\n+    public void addRaw(String source, String target, String factor, String offset, String reciprocal) {\n+        UnitInfo info = new UnitInfo(\n+            factor == null ? Rational.ONE : rationalParser.parse(factor), \n+                offset == null ? Rational.ZERO : rationalParser.parse(offset), \n+                    reciprocal == null ? false : reciprocal.equalsIgnoreCase(\"true\") ? true : false);\n+\n+        addToSourceToTarget(source, target, info);\n+        addToSourceToTarget(target, source, info.invert());\n+        toBaseUnit.put(source, target);\n+        Continuation.addIfNeeded(source, continuations);\n+    }\n+\n+    private void addToSourceToTarget(String source, String target, UnitInfo info) {\n+        Map<String, UnitInfo> targetToInfo = sourceToTargetToInfo.get(source);\n+        if (targetToInfo == null) {\n+            sourceToTargetToInfo.put(source, targetToInfo = new TreeMap<>());\n+        }\n+        if (targetToInfo.containsKey(target)) {\n+            throw new IllegalArgumentException(\"Duplicate source/target: \" + source + \", \" + target);\n+        }\n+        targetToInfo.put(target, info);\n+    }\n+\n+    public Set<String> canConvertBetween(String unit) {\n+        Set<String> result = new TreeSet<>();\n+        Map<String, UnitInfo> targetToInfo = sourceToTargetToInfo.get(unit);\n+        if (targetToInfo == null) {\n+            return Collections.emptySet();\n+        }\n+        result.addAll(targetToInfo.keySet());\n+        for (String pivot : targetToInfo.keySet()) {\n+            Map<String, UnitInfo> pivotToInfo = sourceToTargetToInfo.get(pivot);\n+            result.addAll(pivotToInfo.keySet());\n+        }\n+        return result;\n+    }\n+\n+    public Set<String> canConvert() {\n+        return sourceToTargetToInfo.keySet();\n+    }\n+\n+    public Map<String, String> simpleToBaseUnits() {\n+        return toBaseUnit;\n+    }\n+\n+\n+    public Rational convert(Rational source, String sourceUnit, String targetUnit) {\n+        Map<String, UnitInfo> targetToInfo = sourceToTargetToInfo.get(sourceUnit);\n+        if (targetToInfo == null) {\n+            return Rational.NaN;\n+        }\n+        UnitInfo info = targetToInfo.get(targetUnit); \n+        if (info != null) {\n+            return info.convert(source);\n+        }\n+        // try pivot\n+        Map<String, UnitInfo> sourceToInfo = sourceToTargetToInfo.get(targetUnit);\n+        if (sourceToInfo == null) {\n+            return Rational.NaN;\n+        }\n+        HashSet<String> pivots = new HashSet<>(targetToInfo.keySet());\n+        pivots.retainAll(sourceToInfo.keySet());\n+        if (pivots.isEmpty()) {\n+            return Rational.NaN;\n+        }\n+        String pivot = pivots.iterator().next();\n+        info = targetToInfo.get(pivot);\n+        Rational temp = info.convert(source);\n+\n+        Map<String, UnitInfo> pivotToInfo = sourceToTargetToInfo.get(pivot);\n+        UnitInfo info2 = pivotToInfo.get(targetUnit);\n+        return info2.convert(temp);\n+    }\n+\n+    // TODO fix to guarantee single mapping\n+\n+    public UnitInfo getUnitInfo(String sourceUnit, Output<String> baseUnit) {\n+        if (isBaseUnit(sourceUnit)) {\n+            return null;\n+        }\n+        Map<String, UnitInfo> targetToInfo = sourceToTargetToInfo.get(sourceUnit);\n+        if (targetToInfo == null) {\n+            return null;\n+        }\n+        Entry<String, UnitInfo> data = targetToInfo.entrySet().iterator().next();\n+        baseUnit.value = data.getKey();\n+        return data.getValue();\n+    }\n+\n+    static final ImmutableMap<String, String> FIX_DENORMALIZED = ImmutableMap.of(\n+        \"meter-per-second-squared\", \"meter-per-square-second\",\n+        \"liter-per-100kilometers\", \"liter-per-100-kilometer\",\n+        \"pound-foot\", \"pound-force-foot\",\n+        \"pound-per-square-inch\", \"pound-force-per-square-inch\");\n+\n+    /**\n+     * Takes a derived unit id, and produces the equivalent derived base unit id and UnitInfo to convert to it\n+     * @author markdavis\n+     *\n+     */\n+    public UnitInfo parseUnitId (String derivedUnit, Output<String> metricUnit) {\n+        metricUnit.value = null;\n+\n+        if (derivedUnit.equals(\"liter-per-100kilometers\")) {\n+            int debug = 0;\n+        }\n+        UnitId outputUnit = new UnitId();\n+        Rational numerator = Rational.ONE;\n+        Rational denominator = Rational.ONE;\n+        boolean inNumerator = true;\n+        int power = 1;\n+\n+        Output<Rational> deprefix = new Output<>();\n+\n+        String fixed = FIX_DENORMALIZED.get(derivedUnit);\n+        if (fixed != null) {\n+            derivedUnit = fixed;\n+        }\n+\n+        for (String unit : Continuation.split(derivedUnit, continuations)) {\n+\n+            if (unit.equals(\"square\")) {\n+                if (power != 1) {\n+                    throw new IllegalArgumentException(\"Can't have power of \" + unit);\n+                }\n+                power = 2;\n+            } else if (unit.equals(\"cubic\")) {\n+                if (power != 1) {\n+                    throw new IllegalArgumentException(\"Can't have power of \" + unit);\n+                }\n+                power = 3;\n+            } else if (unit.startsWith(\"pow\")) {\n+                if (power != 1) {\n+                    throw new IllegalArgumentException(\"Can't have power of \" + unit);\n+                }\n+                power = Integer.parseInt(unit.substring(3));\n+            } else if (unit.equals(\"per\")) {\n+                if (power != 1) {\n+                    throw new IllegalArgumentException(\"Can't have power of per\");\n+                }\n+                inNumerator = false; // ignore multiples\n+            } else if ('9' >= unit.charAt(0)) {\n+                if (power != 1) {\n+                    throw new IllegalArgumentException(\"Can't have power of \" + unit);\n+                }\n+                Rational factor = Rational.of(Integer.parseInt(unit));", "originalCommit": "b840e1019ca7577600fcf6c8808742639d5b1420", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1bb416eb98600ca0cdefc5c4e0596cf3f92925b1", "url": "https://github.com/unicode-org/cldr/commit/1bb416eb98600ca0cdefc5c4e0596cf3f92925b1", "message": "CLDR-13488 add unit conversions\n\nSee #291", "committedDate": "2020-01-30T22:02:31Z", "type": "forcePushed"}, {"oid": "cb1253249298711af824a01bddd8059da2c971a1", "url": "https://github.com/unicode-org/cldr/commit/cb1253249298711af824a01bddd8059da2c971a1", "message": "CLDR-13488 add unit conversions\n\nSee #291", "committedDate": "2020-02-09T01:56:31Z", "type": "forcePushed"}, {"oid": "c1245046fddf0d4d1fcf6084649da7078633c680", "url": "https://github.com/unicode-org/cldr/commit/c1245046fddf0d4d1fcf6084649da7078633c680", "message": "CLDR-13488 add unit conversions\n\nSee #291", "committedDate": "2020-02-10T07:46:01Z", "type": "forcePushed"}, {"oid": "fbf9472dbca89d6f590017440d859a01f6f29f0d", "url": "https://github.com/unicode-org/cldr/commit/fbf9472dbca89d6f590017440d859a01f6f29f0d", "message": "CLDR-13488 add unit conversions\n\nSee #291", "committedDate": "2020-02-10T07:48:10Z", "type": "forcePushed"}, {"oid": "975b1180492c779d81f671595238c5ab1a389115", "url": "https://github.com/unicode-org/cldr/commit/975b1180492c779d81f671595238c5ab1a389115", "message": "CLDR-13488 add unit conversions\n\nSee #291", "committedDate": "2020-02-10T07:48:35Z", "type": "commit"}, {"oid": "975b1180492c779d81f671595238c5ab1a389115", "url": "https://github.com/unicode-org/cldr/commit/975b1180492c779d81f671595238c5ab1a389115", "message": "CLDR-13488 add unit conversions\n\nSee #291", "committedDate": "2020-02-10T07:48:35Z", "type": "forcePushed"}]}