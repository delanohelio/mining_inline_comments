{"pr_number": 594, "pr_title": "CLDR-14016 fix alias rules", "pr_createdAt": "2020-07-30T01:15:23Z", "pr_url": "https://github.com/unicode-org/cldr/pull/594", "timeline": [{"oid": "88c7325f4e22788f9d1a0bffb5a811f1faf0d440", "url": "https://github.com/unicode-org/cldr/commit/88c7325f4e22788f9d1a0bffb5a811f1faf0d440", "message": "CLDR-14016 fix alias rules", "committedDate": "2020-08-21T23:32:39Z", "type": "forcePushed"}, {"oid": "46cd038d971c2bef8549c73952e558b71e2b35e0", "url": "https://github.com/unicode-org/cldr/commit/46cd038d971c2bef8549c73952e558b71e2b35e0", "message": "CLDR-14016 fix alias rules\n\nSee #594", "committedDate": "2020-08-24T19:19:07Z", "type": "forcePushed"}, {"oid": "d81604b90d199ff6219139c291cf212ff0732bf7", "url": "https://github.com/unicode-org/cldr/commit/d81604b90d199ff6219139c291cf212ff0732bf7", "message": "CLDR-14016 Clean up tests", "committedDate": "2020-08-25T00:25:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3NzU1Ng==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r475877556", "bodyText": "This is a new class that uses the canonicalization of the LSRV part of a locale identifier to verify correctness of the algorithm and test data.", "author": "macchiati", "createdAt": "2020-08-24T20:34:10Z", "path": "tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.unicode.cldr.unittest;", "originalCommit": "46cd038d971c2bef8549c73952e558b71e2b35e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxNTE3Mg==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476415172", "bodyText": "JavaDoc or link to a design doc?", "author": "hagbard", "createdAt": "2020-08-25T12:38:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3NzU1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU5MzIwOA==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476593208", "bodyText": "Added to javadoc", "author": "macchiati", "createdAt": "2020-08-25T16:50:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3NzU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3ODIyMw==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r475878223", "bodyText": "A new class that generates the test data above.", "author": "macchiati", "createdAt": "2020-08-24T20:35:25Z", "path": "tools/java/org/unicode/cldr/tool/GenerateLocaleTestData.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.unicode.cldr.tool;", "originalCommit": "46cd038d971c2bef8549c73952e558b71e2b35e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3ODc5Ng==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r475878796", "bodyText": "Some small tweaks to add enum values for other elements used in validity (really for other tickets).", "author": "macchiati", "createdAt": "2020-08-24T20:36:25Z", "path": "tools/java/org/unicode/cldr/util/StandardCodes.java", "diffHunk": "@@ -1036,7 +1036,9 @@ private void add(CodeType type, String code, List<String> otherData) {\n         /** specialized codes for validity; TODO: rename LstrType **/\n         currency(false, true, \"XXX\"),\n         subdivision(false, true),\n-        unit(false, true);\n+        unit(false, true),", "originalCommit": "46cd038d971c2bef8549c73952e558b71e2b35e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3OTIzNg==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r475879236", "bodyText": "Utility to account for some older code and data structures using 'territory' instead of 'region'.", "author": "macchiati", "createdAt": "2020-08-24T20:37:14Z", "path": "tools/java/org/unicode/cldr/util/StandardCodes.java", "diffHunk": "@@ -1073,6 +1075,17 @@ boolean isWellFormed(String candidate) {\n         public String toCompatString() {\n             return this == region ? \"territory\" : toString();\n         }\n+\n+        public static LstrType fromString(String rawType) {", "originalCommit": "46cd038d971c2bef8549c73952e558b71e2b35e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMTk2Ng==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476411966", "bodyText": "Please comment this to say how it conflates \"territory\" as an alternate identifier for region.", "author": "hagbard", "createdAt": "2020-08-25T12:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3OTIzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU5NDg4Mg==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476594882", "bodyText": "done", "author": "macchiati", "createdAt": "2020-08-25T16:52:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3OTIzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg4MDExMA==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r475880110", "bodyText": "This is used in matching a ReplacementRule. It is here instead of on ReplacementRule so we can use in the denormalization utility used in testing.", "author": "macchiati", "createdAt": "2020-08-24T20:38:57Z", "path": "tools/java/org/unicode/cldr/util/LsrvCanonicalizer.java", "diffHunk": "@@ -0,0 +1,529 @@\n+package org.unicode.cldr.util;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import org.unicode.cldr.util.StandardCodes.LstrType;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Objects;\n+import com.google.common.collect.ComparisonChain;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.TreeMultimap;\n+import com.ibm.icu.impl.Row.R2;\n+\n+/**\n+ * Provides Unicode Language Identifier canonicalization for use in testing.\n+ * The implementation is designed to be simple, and is not at all optimized for production use.\n+ */\n+public class LsrvCanonicalizer {\n+\n+    public static final Set<LstrType> LSRV = ImmutableSet.of(LstrType.language, LstrType.script, LstrType.region, LstrType.variant);\n+    public static final Joiner UNDERBAR_JOINER = Joiner.on('_');\n+\n+    /**\n+     * A representation of a Unicode Language Identifier in a format that makes it simple to process.\n+     * The LSRV fields are represented as multimaps, though the LSR fields restricted to have only have 0 or 1 element.\n+     */\n+    public static class XLanguageTag {\n+        final Multimap<LstrType, String> data;\n+\n+        private XLanguageTag(Multimap<LstrType, String> result) {\n+            data = ImmutableMultimap.copyOf(result);\n+        }\n+        public Set<LstrType> keys() {\n+            return data.keySet();\n+        }\n+        public Collection<String> get(LstrType lstrType) {\n+            return data.get(lstrType);\n+        }\n+        public String toLocaleString() {\n+            StringBuilder buffer = new StringBuilder();\n+            final Collection<String> region = data.get(LstrType.language);\n+            if (!region.isEmpty()) {\n+                buffer.append(UNDERBAR_JOINER.join(region));\n+            } else {\n+                buffer.append(\"und\");\n+            }\n+            addItem(buffer, LstrType.script, \"\", \"_\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.region, \"\", \"_\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.variant, \"\", \"_\", UNDERBAR_JOINER);\n+\n+            return buffer.toString();\n+        }\n+        @Override\n+        public String toString() {\n+            StringBuilder buffer = new StringBuilder();\n+            addItem(buffer, LstrType.language, \"\", \"L:\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.script, \";\", \"S:\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.region, \";\", \"R:\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.variant, \";\", \"V:\", UNDERBAR_JOINER);\n+            return buffer.toString();\n+        }\n+\n+        public void addItem(StringBuilder buffer, LstrType lstrType, String separator, String prefix, final Joiner dashJoiner) {\n+            final Collection<String> region = data.get(lstrType);\n+            if (!region.isEmpty()) {\n+                if (buffer.length() > 0) {\n+                    buffer.append(separator);\n+                }\n+                buffer.append(prefix).append(dashJoiner.join(region));\n+            }\n+        }\n+\n+        public static XLanguageTag fromTag(LstrType lstrType, String tag) {\n+            Multimap<LstrType,String> result = TreeMultimap.create();\n+            LanguageTagParser source = new LanguageTagParser();\n+            final boolean isLanguage = lstrType == LstrType.language;\n+            String prefix = isLanguage ? \"\" : \"und_\";\n+            try {\n+                source.set(prefix + tag);\n+            } catch (Exception e) {\n+                return null;  // skip ill-formed for now\n+//                if (lstrType == LstrType.region && tag.length() == 3) {\n+//                    //result.put(LstrType.language, \"und\");\n+//                    result.put(LstrType.region, tag);\n+//                } else {\n+//                    result.put(LstrType.language, tag);\n+//                }\n+//                //System.out.println(\"ILLEGAL SOURCE\\t\" + lstrType + \":\\t\" + tag + \" \u21d2 \" + result); // for debugging\n+//                return new XLanguageTag(result);\n+            }\n+            if (!source.getLanguage().isEmpty()\n+                && !source.getLanguage().contains(\"und\")) {\n+                result.put(LstrType.language, source.getLanguage());\n+            }\n+            if (!source.getScript().isEmpty()) {\n+                result.put(LstrType.script, source.getScript());\n+            }\n+            if (!source.getRegion().isEmpty()) {\n+                result.put(LstrType.region, source.getRegion());\n+            }\n+            if (!source.getVariants().isEmpty()) {\n+                result.putAll(LstrType.variant, source.getVariants());\n+            }\n+            return new XLanguageTag(result);\n+        }\n+        @Override\n+        public boolean equals(Object obj) {\n+            return data.equals(((XLanguageTag)obj).data);\n+        }\n+        @Override\n+        public int hashCode() {\n+            return data.hashCode();\n+        }\n+        public XLanguageTag set(LstrType lstrType, String string) {\n+            Multimap<LstrType,String> result = TreeMultimap.create(data);\n+            if (lstrType != LstrType.variant) {\n+                result.removeAll(lstrType);\n+            }\n+            result.put(lstrType, string);\n+            return new XLanguageTag(result);\n+        }\n+\n+        public boolean containsAll(XLanguageTag type) {", "originalCommit": "46cd038d971c2bef8549c73952e558b71e2b35e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg4MTI3Ng==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r475881276", "bodyText": "This actually does the replacement. Also here instead of on ReplacementRule so we can use in the denormalization utility used in testing.", "author": "macchiati", "createdAt": "2020-08-24T20:41:22Z", "path": "tools/java/org/unicode/cldr/util/LsrvCanonicalizer.java", "diffHunk": "@@ -0,0 +1,529 @@\n+package org.unicode.cldr.util;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import org.unicode.cldr.util.StandardCodes.LstrType;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Objects;\n+import com.google.common.collect.ComparisonChain;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.TreeMultimap;\n+import com.ibm.icu.impl.Row.R2;\n+\n+/**\n+ * Provides Unicode Language Identifier canonicalization for use in testing.\n+ * The implementation is designed to be simple, and is not at all optimized for production use.\n+ */\n+public class LsrvCanonicalizer {\n+\n+    public static final Set<LstrType> LSRV = ImmutableSet.of(LstrType.language, LstrType.script, LstrType.region, LstrType.variant);\n+    public static final Joiner UNDERBAR_JOINER = Joiner.on('_');\n+\n+    /**\n+     * A representation of a Unicode Language Identifier in a format that makes it simple to process.\n+     * The LSRV fields are represented as multimaps, though the LSR fields restricted to have only have 0 or 1 element.\n+     */\n+    public static class XLanguageTag {\n+        final Multimap<LstrType, String> data;\n+\n+        private XLanguageTag(Multimap<LstrType, String> result) {\n+            data = ImmutableMultimap.copyOf(result);\n+        }\n+        public Set<LstrType> keys() {\n+            return data.keySet();\n+        }\n+        public Collection<String> get(LstrType lstrType) {\n+            return data.get(lstrType);\n+        }\n+        public String toLocaleString() {\n+            StringBuilder buffer = new StringBuilder();\n+            final Collection<String> region = data.get(LstrType.language);\n+            if (!region.isEmpty()) {\n+                buffer.append(UNDERBAR_JOINER.join(region));\n+            } else {\n+                buffer.append(\"und\");\n+            }\n+            addItem(buffer, LstrType.script, \"\", \"_\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.region, \"\", \"_\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.variant, \"\", \"_\", UNDERBAR_JOINER);\n+\n+            return buffer.toString();\n+        }\n+        @Override\n+        public String toString() {\n+            StringBuilder buffer = new StringBuilder();\n+            addItem(buffer, LstrType.language, \"\", \"L:\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.script, \";\", \"S:\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.region, \";\", \"R:\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.variant, \";\", \"V:\", UNDERBAR_JOINER);\n+            return buffer.toString();\n+        }\n+\n+        public void addItem(StringBuilder buffer, LstrType lstrType, String separator, String prefix, final Joiner dashJoiner) {\n+            final Collection<String> region = data.get(lstrType);\n+            if (!region.isEmpty()) {\n+                if (buffer.length() > 0) {\n+                    buffer.append(separator);\n+                }\n+                buffer.append(prefix).append(dashJoiner.join(region));\n+            }\n+        }\n+\n+        public static XLanguageTag fromTag(LstrType lstrType, String tag) {\n+            Multimap<LstrType,String> result = TreeMultimap.create();\n+            LanguageTagParser source = new LanguageTagParser();\n+            final boolean isLanguage = lstrType == LstrType.language;\n+            String prefix = isLanguage ? \"\" : \"und_\";\n+            try {\n+                source.set(prefix + tag);\n+            } catch (Exception e) {\n+                return null;  // skip ill-formed for now\n+//                if (lstrType == LstrType.region && tag.length() == 3) {\n+//                    //result.put(LstrType.language, \"und\");\n+//                    result.put(LstrType.region, tag);\n+//                } else {\n+//                    result.put(LstrType.language, tag);\n+//                }\n+//                //System.out.println(\"ILLEGAL SOURCE\\t\" + lstrType + \":\\t\" + tag + \" \u21d2 \" + result); // for debugging\n+//                return new XLanguageTag(result);\n+            }\n+            if (!source.getLanguage().isEmpty()\n+                && !source.getLanguage().contains(\"und\")) {\n+                result.put(LstrType.language, source.getLanguage());\n+            }\n+            if (!source.getScript().isEmpty()) {\n+                result.put(LstrType.script, source.getScript());\n+            }\n+            if (!source.getRegion().isEmpty()) {\n+                result.put(LstrType.region, source.getRegion());\n+            }\n+            if (!source.getVariants().isEmpty()) {\n+                result.putAll(LstrType.variant, source.getVariants());\n+            }\n+            return new XLanguageTag(result);\n+        }\n+        @Override\n+        public boolean equals(Object obj) {\n+            return data.equals(((XLanguageTag)obj).data);\n+        }\n+        @Override\n+        public int hashCode() {\n+            return data.hashCode();\n+        }\n+        public XLanguageTag set(LstrType lstrType, String string) {\n+            Multimap<LstrType,String> result = TreeMultimap.create(data);\n+            if (lstrType != LstrType.variant) {\n+                result.removeAll(lstrType);\n+            }\n+            result.put(lstrType, string);\n+            return new XLanguageTag(result);\n+        }\n+\n+        public boolean containsAll(XLanguageTag type) {\n+            for (LstrType lstrType : LSRV) {\n+                final Collection<String> sources = get(lstrType);\n+                final Collection<String> types = type.get(lstrType);\n+                if (!sources.containsAll(types)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+        public XLanguageTag replacePartsFrom(XLanguageTag typeParts, XLanguageTag replacementParts) {", "originalCommit": "46cd038d971c2bef8549c73952e558b71e2b35e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b73c6b164b9e8c2c73a377c4bdc4eff7be9c238d", "url": "https://github.com/unicode-org/cldr/commit/b73c6b164b9e8c2c73a377c4bdc4eff7be9c238d", "message": "CLDR-14016 fix alias rules\n\nSee #594", "committedDate": "2020-08-25T00:44:04Z", "type": "forcePushed"}, {"oid": "414fff6e0ec586b0e09e08d394e6daa578f4476b", "url": "https://github.com/unicode-org/cldr/commit/414fff6e0ec586b0e09e08d394e6daa578f4476b", "message": "CLDR-14016 fix attribute test", "committedDate": "2020-08-25T01:08:59Z", "type": "forcePushed"}, {"oid": "60b3b0972d4b939cc8501d0fab44059b4b76af7e", "url": "https://github.com/unicode-org/cldr/commit/60b3b0972d4b939cc8501d0fab44059b4b76af7e", "message": "CLDR-14016 fix alias rules\n\nSee #594", "committedDate": "2020-08-25T01:11:32Z", "type": "forcePushed"}, {"oid": "d3c89c38d85fea2f76b4685371dba74230a9c0f1", "url": "https://github.com/unicode-org/cldr/commit/d3c89c38d85fea2f76b4685371dba74230a9c0f1", "message": "CLDR-14016 fix cel_gaulish", "committedDate": "2020-08-25T01:37:02Z", "type": "forcePushed"}, {"oid": "b4c35c12e85464a5024e08cc6a280504a521e3d1", "url": "https://github.com/unicode-org/cldr/commit/b4c35c12e85464a5024e08cc6a280504a521e3d1", "message": "CLDR-14016 fix alias rules\n\nSee #594", "committedDate": "2020-08-25T03:39:46Z", "type": "forcePushed"}, {"oid": "d3c89c38d85fea2f76b4685371dba74230a9c0f1", "url": "https://github.com/unicode-org/cldr/commit/d3c89c38d85fea2f76b4685371dba74230a9c0f1", "message": "CLDR-14016 fix cel_gaulish", "committedDate": "2020-08-25T01:37:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwODQ5MA==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476408490", "bodyText": "Adding immediately commented out code without any comments declaring its intent is weird.\nI mean yes it's sort of clear it's a debug thing, but there's a DEBUG flag above and this is test code anyway, so why not leave it in guarded by the debug flag? At least that way it won't rot over time with successive refactorings of the code around it.", "author": "hagbard", "createdAt": "2020-08-25T12:27:07Z", "path": "tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.unicode.cldr.unittest;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.unicode.cldr.util.LsrvCanonicalizer;\n+import org.unicode.cldr.util.LsrvCanonicalizer.ReplacementRule;\n+import org.unicode.cldr.util.LsrvCanonicalizer.TestDataTypes;\n+import org.unicode.cldr.util.LsrvCanonicalizer.XLanguageTag;\n+import org.unicode.cldr.util.StandardCodes.LstrType;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Objects;\n+import com.ibm.icu.dev.test.TestFmwk;\n+\n+public class TestLsrvCanonicalizer extends TestFmwk {\n+\n+    static final LsrvCanonicalizer rrs = LsrvCanonicalizer.getInstance();\n+    private static final boolean DEBUG = false;\n+\n+    public static void main(String[] args) {\n+        final TestLsrvCanonicalizer testLocaleCanonicalizer = new TestLsrvCanonicalizer();\n+        testLocaleCanonicalizer.run(args);\n+    }\n+\n+    public void TestCases() {\n+        if (DEBUG) {\n+//          System.out.println(Joiner.on('\\n').join(rrs.filter(LstrType.variant, null)));\n+            System.out.println(Joiner.on('\\n').join(rrs.filter(LstrType.language, \"no\")));\n+        }\n+\n+        List<ReplacementRule> rules = new ArrayList<>();\n+        for (Entry<TestDataTypes, Map<String, String>> mainEntry : rrs.getTestData(null).entrySet()) {\n+            TestDataTypes type = mainEntry.getKey();\n+            for (Entry<String, String> entry : mainEntry.getValue().entrySet()) {\n+                String toTest = entry.getKey();\n+                String expected = entry.getValue();\n+                final XLanguageTag source2 = XLanguageTag.fromTag(LstrType.language, toTest);\n+                XLanguageTag newTag = rrs.canonicalizeToX(source2, rules);\n+                String actual = newTag.toLocaleString();\n+                if (DEBUG && rules.size() > 1) {\n+                    System.out.println(\n+                        \"source: \" + toTest\n+                        + \", expected: \" + expected\n+                        + \", actual: \" + actual\n+                        + \", rules: \" + rules\n+                        );\n+                }\n+                if (!Objects.equal(expected, actual)) {\n+                    errln(\"Error: \"\n+                        + \"source: \" + toTest\n+                        + \", expected: \" + expected\n+                        + \", actual: \" + actual\n+                        + \", rules: \" + rules\n+                        );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\n+//            if (!rule.regular) {\n+//                System.out.println(\n+//                    rule.lstrType + \"\\t\u2795\\t\" + rule.typeParts + \"\\t\u21d2\\t\"+rule.replacementParts + \"\\t\u2795\\t\" + rule.reason + \"\\t\" + diff(rule.typeParts, rule.replacementParts));\n+//            }\n+//        }\n+//    }\n+\n+\n+\n+//    private static String diff(XLanguageTag tagParts, XLanguageTag replacementParts) {", "originalCommit": "d3c89c38d85fea2f76b4685371dba74230a9c0f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njg1MDc3MA==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476850770", "bodyText": "It's gone.", "author": "macchiati", "createdAt": "2020-08-25T23:23:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwODQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwOTMyMw==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476409323", "bodyText": "\"oo\" doesn't seem like a particularly clear variable name to me. Maybe \"outputOpts\" ?", "author": "hagbard", "createdAt": "2020-08-25T12:28:37Z", "path": "tools/java/org/unicode/cldr/util/LanguageTagCanonicalizer.java", "diffHunk": "@@ -52,6 +52,9 @@ public LanguageTagCanonicalizer(LstrType lstrType) {\n     // TODO, handle variants\n     @Override\n     public synchronized String transform(String locale) {\n+        return transform (locale, OutputOption.ICU_LCVARIANT);\n+    }\n+    public synchronized String transform(String locale, OutputOption oo) {", "originalCommit": "d3c89c38d85fea2f76b4685371dba74230a9c0f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njg1MTk3MQ==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476851971", "bodyText": "I'd like to clean this up later. To much to do right now, and I don't want another cycle.", "author": "macchiati", "createdAt": "2020-08-25T23:24:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwOTMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMTY1Mg==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476411652", "bodyText": "Do the if check first and just don't have a try-catch block.\nvalueOf() is defined to only throw IllegalArgumentException or NullPointerException and I think you want to complain if you're given null anyway (it's a very different type of failure mode).", "author": "hagbard", "createdAt": "2020-08-25T12:32:39Z", "path": "tools/java/org/unicode/cldr/util/StandardCodes.java", "diffHunk": "@@ -1073,6 +1075,17 @@ boolean isWellFormed(String candidate) {\n         public String toCompatString() {\n             return this == region ? \"territory\" : toString();\n         }\n+\n+        public static LstrType fromString(String rawType) {\n+            try {\n+                return valueOf(rawType);\n+            } catch (Exception e) {", "originalCommit": "d3c89c38d85fea2f76b4685371dba74230a9c0f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMjc1Nw==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476412757", "bodyText": "Another way to do this is to store the compat string as a field, but either way it would be nice to see a comment on this public method explaining its not the enum name.", "author": "hagbard", "createdAt": "2020-08-25T12:34:36Z", "path": "tools/java/org/unicode/cldr/util/StandardCodes.java", "diffHunk": "@@ -1073,6 +1075,17 @@ boolean isWellFormed(String candidate) {\n         public String toCompatString() {\n             return this == region ? \"territory\" : toString();", "originalCommit": "d3c89c38d85fea2f76b4685371dba74230a9c0f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njg1MjU1OA==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476852558", "bodyText": "done (the doc, and some other changes)", "author": "macchiati", "createdAt": "2020-08-25T23:25:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMjc1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxNDI5NA==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476414294", "bodyText": "JavaDoc?", "author": "hagbard", "createdAt": "2020-08-25T12:37:10Z", "path": "tools/java/org/unicode/cldr/tool/GenerateLocaleIDTestData.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.unicode.cldr.tool;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.unicode.cldr.util.CLDRPaths;\n+import org.unicode.cldr.util.CldrUtility;\n+import org.unicode.cldr.util.LsrvCanonicalizer;\n+import org.unicode.cldr.util.LsrvCanonicalizer.TestDataTypes;\n+import org.unicode.cldr.util.StandardCodes.LstrType;\n+import org.unicode.cldr.util.TempPrintWriter;\n+\n+public class GenerateLocaleIDTestData {", "originalCommit": "d3c89c38d85fea2f76b4685371dba74230a9c0f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njg1MTI5MQ==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476851291", "bodyText": "done", "author": "macchiati", "createdAt": "2020-08-25T23:23:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxNDI5NA=="}], "type": "inlineReview"}, {"oid": "9191edd4650528b9c03f63719ae27a61326046a2", "url": "https://github.com/unicode-org/cldr/commit/9191edd4650528b9c03f63719ae27a61326046a2", "message": "CLDR-14016 fix alias rules\n\nSee #594", "committedDate": "2020-08-26T00:14:20Z", "type": "commit"}, {"oid": "9191edd4650528b9c03f63719ae27a61326046a2", "url": "https://github.com/unicode-org/cldr/commit/9191edd4650528b9c03f63719ae27a61326046a2", "message": "CLDR-14016 fix alias rules\n\nSee #594", "committedDate": "2020-08-26T00:14:20Z", "type": "forcePushed"}]}