{"pr_number": 7079, "pr_title": "Allow multiple source columns in main window", "pr_createdAt": "2020-06-09T22:36:06Z", "pr_url": "https://github.com/rstudio/rstudio/pull/7079", "timeline": [{"oid": "8bac7532132a45828129a17e2383a46ca99a8e33", "url": "https://github.com/rstudio/rstudio/commit/8bac7532132a45828129a17e2383a46ca99a8e33", "message": "add display list class", "committedDate": "2020-05-14T17:37:34Z", "type": "commit"}, {"oid": "058194733874d753168973134ba9e3e131b8b993", "url": "https://github.com/rstudio/rstudio/commit/058194733874d753168973134ba9e3e131b8b993", "message": "add user pref for source columns", "committedDate": "2020-05-14T17:38:13Z", "type": "commit"}, {"oid": "52fb6a4ec07e805d8468a7ec1ac49b2609b1fb82", "url": "https://github.com/rstudio/rstudio/commit/52fb6a4ec07e805d8468a7ec1ac49b2609b1fb82", "message": "set up pane configuration to be able to make mulitple source columns", "committedDate": "2020-05-14T17:41:49Z", "type": "commit"}, {"oid": "e1debb632208db37860db4709e42c15c13ca0f6f", "url": "https://github.com/rstudio/rstudio/commit/e1debb632208db37860db4709e42c15c13ca0f6f", "message": "allow for an extra source column to be created, refactor code, move code from Source to SourceShim", "committedDate": "2020-05-14T17:45:05Z", "type": "commit"}, {"oid": "6de97083e41c743a20065ff175c4fe9945e840b9", "url": "https://github.com/rstudio/rstudio/commit/6de97083e41c743a20065ff175c4fe9945e840b9", "message": "refactoring\n- remove debug code\n- remove unnecessary imports, comments\n- clean up PaneManager code\n- no longer using SourceDisplayManager", "committedDate": "2020-05-14T17:47:21Z", "type": "commit"}, {"oid": "66d63ec977b805eee892ef44f06f0946ec57d666", "url": "https://github.com/rstudio/rstudio/commit/66d63ec977b805eee892ef44f06f0946ec57d666", "message": "generate unique display names in main source window", "committedDate": "2020-05-14T17:47:24Z", "type": "commit"}, {"oid": "3aef1e0d9cd22371d1863be0bd6da1d6199651c8", "url": "https://github.com/rstudio/rstudio/commit/3aef1e0d9cd22371d1863be0bd6da1d6199651c8", "message": "begin implementing drag and drop events for multiple main displays", "committedDate": "2020-05-14T17:47:48Z", "type": "commit"}, {"oid": "4c35ccc770d30591a20b7bdec30fedef348571a0", "url": "https://github.com/rstudio/rstudio/commit/4c35ccc770d30591a20b7bdec30fedef348571a0", "message": "pass display in required events", "committedDate": "2020-05-14T17:49:12Z", "type": "commit"}, {"oid": "eff672d2b168fc5e39237c59f1d06921b685bf99", "url": "https://github.com/rstudio/rstudio/commit/eff672d2b168fc5e39237c59f1d06921b685bf99", "message": "add temporary button to add source columns", "committedDate": "2020-05-14T18:06:56Z", "type": "commit"}, {"oid": "b8ac76404ea2a11ebc20e2561135ebdf197d6a54", "url": "https://github.com/rstudio/rstudio/commit/b8ac76404ea2a11ebc20e2561135ebdf197d6a54", "message": "move closing source tabs code from to the Display\n\ncontinue migrating events", "committedDate": "2020-05-14T18:06:56Z", "type": "commit"}, {"oid": "25eda7c195a8a9de7382728d8f71e9ef03d84090", "url": "https://github.com/rstudio/rstudio/commit/25eda7c195a8a9de7382728d8f71e9ef03d84090", "message": "allow drag and drop between multiple source columns in the main window and from/to satellite windows", "committedDate": "2020-05-14T18:07:18Z", "type": "commit"}, {"oid": "ae993fa75eeb0b1bb25a9c2f949dc465105768ea", "url": "https://github.com/rstudio/rstudio/commit/ae993fa75eeb0b1bb25a9c2f949dc465105768ea", "message": "reorder Source.Display and SourcePane methods, remove unused functions and comments, update icons", "committedDate": "2020-05-14T18:07:18Z", "type": "commit"}, {"oid": "3b7aa2573ba6e9243c01a91775a0b7d3afcc6771", "url": "https://github.com/rstudio/rstudio/commit/3b7aa2573ba6e9243c01a91775a0b7d3afcc6771", "message": "hide feature", "committedDate": "2020-05-14T18:07:49Z", "type": "commit"}, {"oid": "146f64ee5bc3305605c6dfce318668322e6b1bd7", "url": "https://github.com/rstudio/rstudio/commit/146f64ee5bc3305605c6dfce318668322e6b1bd7", "message": "fix error that should only happen when prefs are improperly manually manipulated", "committedDate": "2020-05-14T18:07:49Z", "type": "commit"}, {"oid": "bd8748c330a24ea8ebd208bc48ccc1745c959b72", "url": "https://github.com/rstudio/rstudio/commit/bd8748c330a24ea8ebd208bc48ccc1745c959b72", "message": "fix issue where corrent number of columns wasn't displayed", "committedDate": "2020-05-14T18:07:49Z", "type": "commit"}, {"oid": "6cd8b0a21c42715e7338de6aa1b3251a4224514b", "url": "https://github.com/rstudio/rstudio/commit/6cd8b0a21c42715e7338de6aa1b3251a4224514b", "message": "properly sync closing tabs between source columns", "committedDate": "2020-05-14T21:22:40Z", "type": "commit"}, {"oid": "b25965799f620b66c66b8fb7088149892638d79b", "url": "https://github.com/rstudio/rstudio/commit/b25965799f620b66c66b8fb7088149892638d79b", "message": "add null guards for dragging between empty source panes", "committedDate": "2020-05-14T23:11:59Z", "type": "commit"}, {"oid": "c3bd315cc6c655fd939f3d8167b0725401c58809", "url": "https://github.com/rstudio/rstudio/commit/c3bd315cc6c655fd939f3d8167b0725401c58809", "message": "remove source pane when the last tab is closed", "committedDate": "2020-05-14T23:55:12Z", "type": "commit"}, {"oid": "64ac30fb50db57e1fbded5d9e6abbce5faf6aa27", "url": "https://github.com/rstudio/rstudio/commit/64ac30fb50db57e1fbded5d9e6abbce5faf6aa27", "message": "only write the number of extra source columns to file", "committedDate": "2020-05-15T00:25:07Z", "type": "commit"}, {"oid": "c4f76e8ebed4986450805f52af7954955b010114", "url": "https://github.com/rstudio/rstudio/commit/c4f76e8ebed4986450805f52af7954955b010114", "message": "rename extra_sources preference to additional_source_columns and add feature flag", "committedDate": "2020-05-18T18:13:16Z", "type": "commit"}, {"oid": "7e13afd3d15d3b84985f7deb0df7b80091f62c7e", "url": "https://github.com/rstudio/rstudio/commit/7e13afd3d15d3b84985f7deb0df7b80091f62c7e", "message": "remove debug code and make split panel persist state for multiple columns", "committedDate": "2020-05-19T00:36:05Z", "type": "commit"}, {"oid": "a5240b647de8e743f55a04aad93cac2b0d674c49", "url": "https://github.com/rstudio/rstudio/commit/a5240b647de8e743f55a04aad93cac2b0d674c49", "message": "restore source docs in correct views", "committedDate": "2020-05-19T21:21:34Z", "type": "commit"}, {"oid": "e629c4aca34f28163d155271e65fcb829f127599", "url": "https://github.com/rstudio/rstudio/commit/e629c4aca34f28163d155271e65fcb829f127599", "message": "start enabling display buttons", "committedDate": "2020-05-19T21:59:32Z", "type": "commit"}, {"oid": "e7631be0b36c758fd71f47183abdca10356f17a2", "url": "https://github.com/rstudio/rstudio/commit/e7631be0b36c758fd71f47183abdca10356f17a2", "message": "assign events properly on restore with multiple columns", "committedDate": "2020-05-20T01:14:32Z", "type": "commit"}, {"oid": "c363e9f673c0386e657ed2f480a95900996d71ad", "url": "https://github.com/rstudio/rstudio/commit/c363e9f673c0386e657ed2f480a95900996d71ad", "message": "properly set activeEditor on tab selection", "committedDate": "2020-05-20T19:00:56Z", "type": "commit"}, {"oid": "be2c5d72ddb6af4a7fe67f164e16a0e942748f33", "url": "https://github.com/rstudio/rstudio/commit/be2c5d72ddb6af4a7fe67f164e16a0e942748f33", "message": "remove debug statements", "committedDate": "2020-05-20T19:49:02Z", "type": "commit"}, {"oid": "fcc85338d4567365a7461736d7350b9639fc8e00", "url": "https://github.com/rstudio/rstudio/commit/fcc85338d4567365a7461736d7350b9639fc8e00", "message": "begin moving add tabs to SourcePane", "committedDate": "2020-05-20T22:49:23Z", "type": "commit"}, {"oid": "91055f7df3e46d16e925f7c7ea0e978718b76551", "url": "https://github.com/rstudio/rstudio/commit/91055f7df3e46d16e925f7c7ea0e978718b76551", "message": "begin moving functionality to column manager (WIP) DOES NOT COMPILE", "committedDate": "2020-05-21T02:13:52Z", "type": "commit"}, {"oid": "91b6ee06cc56af6c542b24bdb6e63ce835afed79", "url": "https://github.com/rstudio/rstudio/commit/91b6ee06cc56af6c542b24bdb6e63ce835afed79", "message": "update PaneManager to use SourceColumnManager, continue migrating code to SourceColumnManager", "committedDate": "2020-05-22T02:13:45Z", "type": "commit"}, {"oid": "97eddbe8a25f6b54bb910fe9703052bb12efde0f", "url": "https://github.com/rstudio/rstudio/commit/97eddbe8a25f6b54bb910fe9703052bb12efde0f", "message": "pull logic from Source to create a SourceColumn class and SourceColumnManager class\nto hold and manage additional source columns", "committedDate": "2020-05-23T00:58:23Z", "type": "commit"}, {"oid": "02193f73e31aa6f786b2d07b1a64a0c176d54012", "url": "https://github.com/rstudio/rstudio/commit/02193f73e31aa6f786b2d07b1a64a0c176d54012", "message": "reformat", "committedDate": "2020-05-26T17:33:02Z", "type": "commit"}, {"oid": "25802daf75dce70a540d5f948a80c9bb0bc4c884", "url": "https://github.com/rstudio/rstudio/commit/25802daf75dce70a540d5f948a80c9bb0bc4c884", "message": "inject SourceColumns, renable drag & drop, fix jsni code,\ncontinue migrating source code to SourceColumn/Manager", "committedDate": "2020-05-26T23:15:09Z", "type": "commit"}, {"oid": "b4aa7719fa1042d6151479dc111fedca120e9bdf", "url": "https://github.com/rstudio/rstudio/commit/b4aa7719fa1042d6151479dc111fedca120e9bdf", "message": "remove unnecessary imports, properly assign Untitled numbers and manage editor commands", "committedDate": "2020-05-27T21:42:10Z", "type": "commit"}, {"oid": "f36e52ca302d8c3d3fa04990ce5521f114c82049", "url": "https://github.com/rstudio/rstudio/commit/f36e52ca302d8c3d3fa04990ce5521f114c82049", "message": "standardize set activeEditor code", "committedDate": "2020-05-27T22:47:08Z", "type": "commit"}, {"oid": "d5d6cfcbf0e3b5859c552f6997a5bd0715f0071f", "url": "https://github.com/rstudio/rstudio/commit/d5d6cfcbf0e3b5859c552f6997a5bd0715f0071f", "message": "Merge branch 'master' into feature/source-columns\n\n# Conflicts:\n#\tsrc/gwt/src/org/rstudio/studio/client/workbench/ui/PaneManager.java\n#\tsrc/gwt/src/org/rstudio/studio/client/workbench/views/source/Source.java", "committedDate": "2020-05-27T23:56:15Z", "type": "commit"}, {"oid": "29ab246060f23296d28e8e105be209c40205d867", "url": "https://github.com/rstudio/rstudio/commit/29ab246060f23296d28e8e105be209c40205d867", "message": "handle column consolidation based on user pref, migrate logic from Source to SourceColumnManager", "committedDate": "2020-05-28T01:41:53Z", "type": "commit"}, {"oid": "0f1748d525c17dbb9b4021d3cb65b3784e7e0c68", "url": "https://github.com/rstudio/rstudio/commit/0f1748d525c17dbb9b4021d3cb65b3784e7e0c68", "message": "move applicable code from Source to SourceColumnManager", "committedDate": "2020-05-29T00:12:11Z", "type": "commit"}, {"oid": "9484252433810ac79cc940c4ef041bf2e5d8adee", "url": "https://github.com/rstudio/rstudio/commit/9484252433810ac79cc940c4ef041bf2e5d8adee", "message": "clean up style and remove unused variables", "committedDate": "2020-05-29T00:45:27Z", "type": "commit"}, {"oid": "228ffb0872acf69343d6d728bc7fd0f4272ead1b", "url": "https://github.com/rstudio/rstudio/commit/228ffb0872acf69343d6d728bc7fd0f4272ead1b", "message": "add null guards and remove redundant code", "committedDate": "2020-05-29T01:06:52Z", "type": "commit"}, {"oid": "f55bd12114837c81c8d9df808e78e99a995c76a0", "url": "https://github.com/rstudio/rstudio/commit/f55bd12114837c81c8d9df808e78e99a995c76a0", "message": "revert accidental removal of Run_Client.xml", "committedDate": "2020-05-29T01:17:50Z", "type": "commit"}, {"oid": "49b7be014426e31119b32bf54fdfc6c1e73d6edb", "url": "https://github.com/rstudio/rstudio/commit/49b7be014426e31119b32bf54fdfc6c1e73d6edb", "message": "persist state of additional columns", "committedDate": "2020-06-02T15:04:17Z", "type": "commit"}, {"oid": "f873149c131d416466115dfc5ffb8723dd7e33d8", "url": "https://github.com/rstudio/rstudio/commit/f873149c131d416466115dfc5ffb8723dd7e33d8", "message": "fix issue when loading without prefs", "committedDate": "2020-06-02T20:02:23Z", "type": "commit"}, {"oid": "ad059def1039efdf16e7c4a6743ef25c9727d68d", "url": "https://github.com/rstudio/rstudio/commit/ad059def1039efdf16e7c4a6743ef25c9727d68d", "message": "remove unneeded code", "committedDate": "2020-06-02T22:33:09Z", "type": "commit"}, {"oid": "ed7255b86bbb1ece2ea3ef828370e5b0d4a93c72", "url": "https://github.com/rstudio/rstudio/commit/ed7255b86bbb1ece2ea3ef828370e5b0d4a93c72", "message": "properly initiate state on desktop mode", "committedDate": "2020-06-02T23:38:53Z", "type": "commit"}, {"oid": "4e68f65d6d3c1e0b9a60a0278f1643c893167a9b", "url": "https://github.com/rstudio/rstudio/commit/4e68f65d6d3c1e0b9a60a0278f1643c893167a9b", "message": "change columnMap to a columnList, pane layout preferences UI things", "committedDate": "2020-06-05T17:24:17Z", "type": "commit"}, {"oid": "6ce1e819e2ca07bcfeaef5b1b97608981ea17599", "url": "https://github.com/rstudio/rstudio/commit/6ce1e819e2ca07bcfeaef5b1b97608981ea17599", "message": "fix issue with start up", "committedDate": "2020-06-05T19:46:04Z", "type": "commit"}, {"oid": "7c09468f672135dbe73b18f734c98406c9a554fd", "url": "https://github.com/rstudio/rstudio/commit/7c09468f672135dbe73b18f734c98406c9a554fd", "message": "fix bugs with moving files between windows", "committedDate": "2020-06-05T21:48:46Z", "type": "commit"}, {"oid": "55dc4cd6757baaa517bd63984f95d0cb16b6618d", "url": "https://github.com/rstudio/rstudio/commit/55dc4cd6757baaa517bd63984f95d0cb16b6618d", "message": "more accurately set the active column and editor", "committedDate": "2020-06-06T01:07:21Z", "type": "commit"}, {"oid": "f6e891472bc11975be1a4b87406a286d1fe50dd9", "url": "https://github.com/rstudio/rstudio/commit/f6e891472bc11975be1a4b87406a286d1fe50dd9", "message": "initialize state", "committedDate": "2020-06-09T00:10:30Z", "type": "commit"}, {"oid": "fc633d679895c4225b00743d8cf589e732ba5845", "url": "https://github.com/rstudio/rstudio/commit/fc633d679895c4225b00743d8cf589e732ba5845", "message": "rename state to prevent attempting to use different parent class", "committedDate": "2020-06-09T20:44:06Z", "type": "commit"}, {"oid": "2e7020ca7ef21b96dd1b4e1424f56feb6d5b7f0f", "url": "https://github.com/rstudio/rstudio/commit/2e7020ca7ef21b96dd1b4e1424f56feb6d5b7f0f", "message": "remove outdates comments and debug code. reset imports changed by the IDE.", "committedDate": "2020-06-09T22:20:31Z", "type": "commit"}, {"oid": "ec4b2fc5d1c26a9efd257cf3f52eb6a4c3009888", "url": "https://github.com/rstudio/rstudio/commit/ec4b2fc5d1c26a9efd257cf3f52eb6a4c3009888", "message": "user option to display Console error/message/warning output in normal color (#7030)\n\n* user option to display Console error/message/warning output in normal color\r\n\r\n- Fixes #7029, motivated by more difficult request in #2574\r\n\r\n* change capitalization of Console to lowercase console\r\n\r\n* fix variable name from prefix underscore to suffix underscore\r\n\r\n* change stderr to error in preference label", "committedDate": "2020-06-10T17:56:10Z", "type": "commit"}, {"oid": "8ad93ac44043cf7eabb65c49a8e143f30a793cdf", "url": "https://github.com/rstudio/rstudio/commit/8ad93ac44043cf7eabb65c49a8e143f30a793cdf", "message": "move console-related preferences to their own pane (#7052)\n\n* move console-related preferences to their own pane\n\n- Fixes #7047\n- Included the sources for the new icons in GIMP format (GNU Image Manipulation Program)\n- Put back spacing in Code / Display panel previously removed due to crowding\n\n* update NEWS\n\n* eliminate handling of R versions without source references", "committedDate": "2020-06-10T17:57:05Z", "type": "commit"}, {"oid": "ebc3178e9e6c463ef4bdca79e22105a352c53bfd", "url": "https://github.com/rstudio/rstudio/commit/ebc3178e9e6c463ef4bdca79e22105a352c53bfd", "message": "Merge pull request #7043 from rstudio/feature/command-palette-settings\n\nAdd settings to command palette", "committedDate": "2020-06-10T18:39:47Z", "type": "commit"}, {"oid": "036a734acc1b087eb923fc19c49f6fc5af6bb808", "url": "https://github.com/rstudio/rstudio/commit/036a734acc1b087eb923fc19c49f6fc5af6bb808", "message": "whitespace cleanup", "committedDate": "2020-06-10T19:00:32Z", "type": "commit"}, {"oid": "b05e15e98d5dec936f440319aa15d74615743fc3", "url": "https://github.com/rstudio/rstudio/commit/b05e15e98d5dec936f440319aa15d74615743fc3", "message": "Merge branch 'master' of https://github.com/rstudio/rstudio into feature/source-columns", "committedDate": "2020-06-10T20:22:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxMjY0NA==", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438412644", "bodyText": "Did you intend to leave this in? If you remove it also remove the related import.", "author": "gtritchie", "createdAt": "2020-06-10T21:15:31Z", "path": "src/gwt/src/org/rstudio/core/client/theme/DocTabLayoutPanel.java", "diffHunk": "@@ -1003,6 +1010,7 @@ public void endDrag(final Event evt, int action)\n                      events_.fireEvent(new PopoutDocInitiatedEvent(\n                            initDragParams_.getDocId(), Point.create(\n                                  evt.getScreenX(), evt.getScreenY())));\n+                     Debug.logToConsole(\"initiating event from DocTabLayoutPanel for: \" + initDragParams_.getDocId());", "originalCommit": "b05e15e98d5dec936f440319aa15d74615743fc3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0ODg4OA==", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438448888", "bodyText": "Should this be ===?", "author": "gtritchie", "createdAt": "2020-06-10T22:48:18Z", "path": "src/gwt/src/org/rstudio/studio/client/workbench/ui/MainSplitPanel.java", "diffHunk": "@@ -41,14 +43,14 @@\n       protected State() {}\n \n       public native final boolean hasSplitterPos() /*-{\n-         return typeof(this.splitterpos) != 'undefined';\n+         return this.splitterpos == 0;", "originalCommit": "b05e15e98d5dec936f440319aa15d74615743fc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5MjExMQ==", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438492111", "bodyText": "This line isn't doing what it's supposed to, I've fixed it.", "author": "melissa-barca", "createdAt": "2020-06-11T01:23:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0ODg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1MzQwMg==", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438453402", "bodyText": "Might as well comment it!!!", "author": "gtritchie", "createdAt": "2020-06-10T23:02:27Z", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/Source.java", "diffHunk": "@@ -627,7 +495,16 @@ else if (userPrefs_.editorKeybindings().getValue() == UserPrefs.EDITOR_KEYBINDIN\n          ShortcutManager.INSTANCE.setEditorMode(KeyboardShortcut.MODE_SUBLIME);\n       else\n          ShortcutManager.INSTANCE.setEditorMode(KeyboardShortcut.MODE_DEFAULT);\n-   \n+\n+      initialized_ = true;\n+\n+      // !!! comment why this is needed", "originalCommit": "b05e15e98d5dec936f440319aa15d74615743fc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUwMjY5NA==", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438502694", "bodyText": "If I remembered :( I did some testing without the event and didn't notice anything breaking. I will continue to test but for now I've removed it.", "author": "melissa-barca", "createdAt": "2020-06-11T02:05:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1MzQwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1ODAxMw==", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438458013", "bodyText": "spelling: availability", "author": "gtritchie", "createdAt": "2020-06-10T23:17:10Z", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/SourceColumn.java", "diffHunk": "@@ -0,0 +1,1215 @@\n+/*\n+ * SourceColumn.java\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+package org.rstudio.studio.client.workbench.views.source;\n+\n+import com.google.gwt.core.client.JsArrayString;\n+import com.google.gwt.core.client.Scheduler;\n+import com.google.gwt.event.logical.shared.SelectionEvent;\n+import com.google.gwt.event.logical.shared.SelectionHandler;\n+import com.google.gwt.user.client.Command;\n+import com.google.gwt.user.client.Timer;\n+import com.google.gwt.user.client.ui.Widget;\n+import com.google.inject.Inject;\n+import org.rstudio.core.client.Debug;\n+import org.rstudio.core.client.JsArrayUtil;\n+import org.rstudio.core.client.ResultCallback;\n+import org.rstudio.core.client.StringUtil;\n+import org.rstudio.core.client.command.AppCommand;\n+import org.rstudio.core.client.command.CommandBinder;\n+import org.rstudio.core.client.events.*;\n+import org.rstudio.core.client.files.FileSystemItem;\n+import org.rstudio.core.client.js.JsObject;\n+import org.rstudio.core.client.js.JsUtil;\n+import org.rstudio.core.client.theme.DocTabSelectionEvent;\n+import org.rstudio.core.client.widget.OperationWithInput;\n+import org.rstudio.studio.client.RStudioGinjector;\n+import org.rstudio.studio.client.application.events.EventBus;\n+import org.rstudio.studio.client.common.SimpleRequestCallback;\n+import org.rstudio.studio.client.common.filetypes.EditableFileType;\n+import org.rstudio.studio.client.common.filetypes.FileIcon;\n+import org.rstudio.studio.client.common.filetypes.FileTypeRegistry;\n+import org.rstudio.studio.client.common.filetypes.TextFileType;\n+import org.rstudio.studio.client.common.synctex.events.SynctexStatusChangedEvent;\n+import org.rstudio.studio.client.server.ServerError;\n+import org.rstudio.studio.client.server.ServerRequestCallback;\n+import org.rstudio.studio.client.server.VoidServerRequestCallback;\n+import org.rstudio.studio.client.workbench.commands.Commands;\n+import org.rstudio.studio.client.workbench.model.RemoteFileSystemContext;\n+import org.rstudio.studio.client.workbench.model.SessionUtils;\n+import org.rstudio.studio.client.workbench.model.UnsavedChangesTarget;\n+import org.rstudio.studio.client.workbench.ui.unsaved.UnsavedChangesDialog;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTargetSource;\n+import org.rstudio.studio.client.workbench.views.source.editors.codebrowser.CodeBrowserEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.TextEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.FileTypeChangedEvent;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.SourceOnSaveChangedEvent;\n+import org.rstudio.studio.client.workbench.views.source.events.*;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceDocument;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceNavigation;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceServerOperations;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class SourceColumn implements SelectionHandler<Integer>,\n+                                     TabClosingHandler,\n+                                     TabCloseHandler,\n+                                     TabClosedHandler,\n+                                     TabReorderHandler\n+{\n+   interface Binder extends CommandBinder<Commands, SourceColumn>\n+   {\n+   }\n+\n+   SourceColumn()\n+   {\n+      RStudioGinjector.INSTANCE.injectMembers(this);\n+   }\n+\n+   @Inject\n+   public void initialize(Binder binder,\n+                          Commands commands,\n+                          EventBus events,\n+                          EditingTargetSource editingTargetSource,\n+                          RemoteFileSystemContext fileContext,\n+                          SourceServerOperations sourceServerOperations)\n+   {\n+      commands_ = commands;\n+      binder.bind(commands_, this);\n+\n+      events_ = events;\n+      editingTargetSource_ = editingTargetSource;\n+      fileContext_ = fileContext;\n+      server_ = sourceServerOperations;\n+\n+\n+      events_.addHandler(FileTypeChangedEvent.TYPE, event -> manageCommands(false));\n+      events_.addHandler(SourceOnSaveChangedEvent.TYPE, event -> manageSaveCommands());\n+      events_.addHandler(SynctexStatusChangedEvent.TYPE, event -> manageSynctexCommands());\n+\n+      initialized_ = true;\n+   }\n+\n+   public void loadDisplay(String name,\n+                           Source.Display display,\n+                           SourceColumnManager manager)\n+   {\n+      name_ = name;\n+      display_ = display;\n+      manager_ = manager;\n+\n+      display_.addSelectionHandler(this);\n+      display_.addTabClosingHandler(this);\n+      display_.addTabCloseHandler(this);\n+      display_.addTabClosedHandler(this);\n+      display_.addTabReorderHandler(this);\n+\n+      ensureVisible(false);\n+   }\n+\n+   public String getName()\n+   {\n+      return name_;\n+   }\n+\n+   public EditingTarget getActiveEditor()\n+   {\n+      return activeEditor_;\n+   }\n+\n+   public ArrayList<EditingTarget> getEditors()\n+   {\n+      return editors_;\n+   }\n+\n+   public ArrayList<EditingTarget> getDirtyEditors(final EditingTarget excludeEditor)\n+   {\n+      ArrayList<EditingTarget> dirtyEditors = new ArrayList<>();\n+      for (EditingTarget target : editors_)\n+      {\n+         if (excludeEditor != null && target == excludeEditor)\n+            continue;\n+         if (target.dirtyState().getValue())\n+            dirtyEditors.add(target);\n+      }\n+      return dirtyEditors;\n+   }\n+\n+   public ArrayList<EditingTarget> getUnsavedEditors(int type, Set<String> ids)\n+   {\n+      ArrayList<EditingTarget> unsavedEditors = new ArrayList<>();\n+      for (EditingTarget target : editors_)\n+      {\n+         if (!isUnsavedTarget(target, type))\n+            continue;\n+         if (ids != null && !ids.contains(target.getId()))\n+            continue;\n+         unsavedEditors.add(target);\n+      }\n+      return unsavedEditors;\n+   }\n+\n+   public ArrayList<Integer> getTabOrder()\n+   {\n+      return tabOrder_;\n+   }\n+\n+   public Widget asWidget()\n+   {\n+      return display_.asWidget();\n+   }\n+\n+   // Display wrapper methods\n+   public void cancelTabDrag()\n+   {\n+      display_.cancelTabDrag();\n+   }\n+   \n+   public void closeTab(Widget child, boolean interactive)\n+   {\n+      display_.closeTab(child, interactive);\n+   }\n+\n+   public void closeTab(Widget child, boolean interactive, Command onClosed)\n+   {\n+      display_.closeTab(child, interactive, onClosed);\n+   }\n+   \n+   public void closeTab(int index, boolean interactive)\n+   {\n+      display_.closeTab(index, interactive);\n+   }\n+\n+   public void closeTab(int index, boolean interactive, Command onClosed)\n+   {\n+\t   display_.closeTab(index, interactive, onClosed);\n+   }\n+\n+   public void closeAllLocalSourceDocs()\n+   {\n+      // TODO\n+   }\n+\n+   public int getTabCount()\n+   {\n+      return display_.getTabCount();\n+   }\n+   \n+   public void manageChevronVisibility()\n+   {\n+\t   display_.manageChevronVisibility();\n+   }\n+   \n+   public void moveTab(int index, int delta)\n+   {\n+\t   display_.moveTab(index, delta);\n+   }\n+   \n+   public void selectTab(Widget widget)\n+   {\n+\t   display_.selectTab(widget);\n+   }\n+   \n+   public void showOverflowPopout()\n+   {\n+\t   display_.showOverflowPopup();\n+   }\n+   \n+   public void showUnsavedChangesDialog(\n+         String title,\n+         ArrayList<UnsavedChangesTarget> dirtyTargets,\n+         OperationWithInput<UnsavedChangesDialog.Result> saveOperation,\n+         Command onCancelled)\n+   {\n+      display_.showUnsavedChangesDialog(title, dirtyTargets, saveOperation, onCancelled);\n+   }\n+   \n+   public void initialSelect(int index)\n+   {\n+      if (index >= 0 && display_.getTabCount() > index)\n+         display_.selectTab(index);\n+      if (display_.getTabCount() > 0 && display_.getActiveTabIndex() >= 0)\n+         editors_.get(index).onInitiallyLoaded();\n+   }\n+\n+   /**\n+    * @param isNewTabPending True if a new tab is about to be created. (If\n+    *    false and there are no tabs already, then a new source doc might\n+    *    be created to make sure we don't end up with a source pane showing\n+    *    with no tabs in it.)\n+    */\n+   public void ensureVisible(boolean isNewTabPending)\n+   {\n+      newTabPending_++;\n+      try\n+      {\n+         display_.ensureVisible();\n+      }\n+      finally\n+      {\n+         newTabPending_--;\n+      }\n+   }\n+\n+   // when tabs have been reordered in the session, the physical layout of the\n+   // tabs doesn't match the logical order of editors_. it's occasionally\n+   // necessary to get or set the tabs by their physical order.\n+   public int getPhysicalTabIndex()\n+   {\n+      int idx = display_.getActiveTabIndex();\n+      if (idx < tabOrder_.size())\n+      {\n+         idx = tabOrder_.indexOf(idx);\n+      }\n+      return idx;\n+   }\n+\n+   public void setPhysicalTabIndex(int idx)\n+   {\n+      if (idx < tabOrder_.size())\n+      {\n+         idx = tabOrder_.get(idx);\n+      }\n+      display_.selectTab(idx);\n+   }\n+\n+   private void onActivate(EditingTarget target)\n+   {\n+       // return if we're already set properly\n+       if (activeEditor_ != null && activeEditor_ == target)\n+          return;\n+\n+       // deactivate prior active editor\n+       if (activeEditor_ != null)\n+          activeEditor_.onDeactivate();\n+\n+       // set and active editor\n+       activeEditor_ = target;\n+       if (activeEditor_ != null)\n+          activeEditor_.onActivate();\n+       manageCommands();\n+   }\n+\n+   void setActiveEditor()\n+   {\n+       if (activeEditor_ == null &&\n+           editors_.size() > display_.getActiveTabIndex())\n+          onActivate(editors_.get(display_.getActiveTabIndex()));\n+   }\n+\n+   EditingTarget setActiveEditor(String docId)\n+   {\n+      if (StringUtil.isNullOrEmpty(docId) &&\n+          activeEditor_ != null)\n+      {\n+         activeEditor_.onDeactivate();\n+         activeEditor_ = null;\n+         return null;\n+      }\n+\n+      for (EditingTarget target : editors_)\n+      {\n+         if (target.getId().equals(docId))\n+         {\n+             onActivate(target);\n+            return target;\n+         }\n+      }\n+      return null;\n+   }\n+\n+   public void setActiveEditor(EditingTarget target)\n+   {\n+      // This should never happen\n+      if (!editors_.contains(target))\n+      {\n+         Debug.logWarning(\"Attempting to set active editor to an unknown target.\");\n+         return;\n+      }\n+      onActivate(target);\n+   }\n+\n+   private void syncTabOrder()\n+   {\n+      // ensure the tab order is synced to the list of editors\n+      for (int i = tabOrder_.size(); i < editors_.size(); i++)\n+      {\n+         tabOrder_.add(i);\n+      }\n+      for (int i = editors_.size(); i < tabOrder_.size(); i++)\n+      {\n+         tabOrder_.remove(i);\n+      }\n+   }\n+\n+   public void fireDocTabsChanged()\n+   {\n+      if (!initialized_)\n+         return;\n+\n+      // ensure we have a tab order (we want the popup list to match the order\n+      // of the tabs)\n+      syncTabOrder();\n+\n+      ArrayList<EditingTarget> editors = editors_;\n+      String[] ids = new String[editors.size()];\n+      FileIcon[] icons = new FileIcon[editors.size()];\n+      String[] names = new String[editors.size()];\n+      String[] paths = new String[editors.size()];\n+      for (int i = 0; i < ids.length; i++)\n+      {\n+         EditingTarget target = editors.get(getTabOrder().get(i));\n+         ids[i] = target.getId();\n+         icons[i] = target.getIcon();\n+         names[i] = target.getName().getValue();\n+         paths[i] = target.getPath();\n+      }\n+\n+      String activeId = (activeEditor_ != null)\n+            ? activeEditor_.getId()\n+            : null;\n+\n+      events_.fireEvent(new DocTabsChangedEvent(activeId, ids, icons, names, paths));\n+\n+      manageChevronVisibility();\n+   }\n+\n+   public boolean hasDoc(String docId)\n+   {\n+      for (EditingTarget target : editors_)\n+      {\n+         if (StringUtil.equals(docId, target.getId()))\n+            return true;\n+      }\n+      return false;\n+   }\n+\n+   public boolean hasDoc()\n+   {\n+      return editors_.size() > 0;\n+   }\n+\n+   public boolean isSaveCommandActive()\n+   {\n+      for (EditingTarget target : editors_)\n+      {\n+         if (target.isSaveCommandActive())\n+            return true;\n+      }\n+      return false;\n+   }\n+\n+   public EditingTarget getDoc(String docId)\n+   {\n+      for (EditingTarget target : editors_)\n+      {\n+         if (StringUtil.equals(docId, target.getId()))\n+            return target;\n+      }\n+      return null;\n+   }\n+\n+   public boolean hasDocWithPath(String path)\n+   {\n+      for (EditingTarget target : editors_)\n+      {\n+         if (StringUtil.equals(path, target.getPath()))\n+            return true;\n+      }\n+      return false;\n+   }\n+\n+   public EditingTarget getEditorWithPath(String path)\n+   {\n+      for (EditingTarget target : editors_)\n+      {\n+         if (StringUtil.equals(path, target.getPath()))\n+            return target;\n+      }\n+      return null;\n+   }\n+\n+   private Widget createWidget(EditingTarget target)\n+   {\n+      return target.asWidget();\n+   }\n+   \n+   public EditingTarget addTab(SourceDocument doc, int mode)\n+   {\n+      return addTab(doc, false, mode);\n+   }\n+   \n+   public EditingTarget addTab(SourceDocument doc, boolean atEnd,\n+         int mode)\n+   {\n+      // by default, add at the tab immediately after the current tab\n+      return addTab(doc, atEnd ? null : getPhysicalTabIndex() + 1,\n+            mode);\n+   }\n+\n+   public EditingTarget addTab(SourceDocument doc, Integer position, int mode)\n+   {\n+      final String defaultNamePrefix = editingTargetSource_.getDefaultNamePrefix(doc);\n+      final EditingTarget target = editingTargetSource_.getEditingTarget(\n+            doc, fileContext_, () -> getNextDefaultName(defaultNamePrefix));\n+      final Widget widget = createWidget(target);\n+\n+      if (position == null)\n+      {\n+         editors_.add(target);\n+      }\n+      else\n+      {\n+         // we're inserting into an existing permuted tabset -- push aside\n+         // any tabs physically to the right of this tab\n+         editors_.add(position, target);\n+         for (int i = 0; i < tabOrder_.size(); i++)\n+         {\n+            int pos = tabOrder_.get(i);\n+            if (pos >= position)\n+               tabOrder_.set(i, pos + 1);\n+         }\n+\n+         // add this tab in its \"natural\" position\n+         tabOrder_.add(position, position);\n+      }\n+\n+      display_.addTab(widget,\n+                      target.getIcon(),\n+                      target.getId(),\n+                      target.getName().getValue(),\n+                      target.getTabTooltip(), // used as tooltip, if non-null\n+                      position,\n+                      true);\n+      fireDocTabsChanged();\n+\n+      target.getName().addValueChangeHandler(event -> {\n+         display_.renameTab(widget,\n+                            target.getIcon(),\n+                            event.getValue(),\n+                            target.getPath());\n+         fireDocTabsChanged();\n+      });\n+\n+      display_.setDirty(widget, target.dirtyState().getValue());\n+      target.dirtyState().addValueChangeHandler(event -> {\n+         display_.setDirty(widget, event.getValue());\n+         manageCommands(false);\n+      });\n+\n+      target.addEnsureVisibleHandler(new EnsureVisibleHandler()\n+      {\n+         @Override\n+         public void onEnsureVisible(EnsureVisibleEvent event)\n+         {\n+            display_.selectTab(widget);\n+         }\n+      });\n+\n+      target.addCloseHandler(voidCloseEvent -> closeTab(widget, false));\n+\n+      events_.fireEvent(new SourceDocAddedEvent(doc, mode, getName()));\n+\n+      if (target instanceof TextEditingTarget && doc.isReadOnly())\n+      {\n+         ((TextEditingTarget) target).setIntendedAsReadOnly(\n+            JsUtil.toList(doc.getReadOnlyAlternatives()));\n+      }\n+\n+      // adding a tab may enable commands that are only available when\n+      // multiple documents are open; if this is the second document, go check\n+      if (editors_.size() == 2)\n+         manageMultiTabCommands();\n+\n+      // if the target had an editing session active, attempt to resume it\n+      if (doc.getCollabParams() != null)\n+         target.beginCollabSession(doc.getCollabParams());\n+\n+      return target;\n+   }\n+\n+   public void addTab(Widget widget,\n+                      FileIcon icon,\n+                      String id,\n+                      String value,\n+                      String tabTooltip,\n+                      Integer position,\n+                      boolean switchToTab)\n+   {\n+      display_.addTab(widget, icon, id, value, tabTooltip, position, switchToTab);\n+   }\n+\n+   public void closeDoc(String docId)\n+   {\n+      suspendDocumentClose_ = true;\n+      for (int i = 0; i < editors_.size(); i++)\n+      {\n+         if (editors_.get(i).getId().equals(docId))\n+         {\n+            display_.closeTab(i, false);\n+            break;\n+         }\n+      }\n+      suspendDocumentClose_ = false;\n+   }\n+\n+   public void closeTabs(JsArrayString ids)\n+   {\n+      for (EditingTarget target : editors_)\n+      {\n+         if (JsArrayUtil.jsArrayStringContains(ids, target.getId()))\n+         {\n+            closeTab(target.asWidget(), false /* non interactive */);\n+         }\n+      }\n+   }\n+\n+   public void setPendingDebugSelection()\n+   {\n+      if (!isDebugSelectionPending())\n+      {\n+         debugSelectionTimer_ = new Timer()\n+         {\n+            public void run()\n+            {\n+               debugSelectionTimer_ = null;\n+            }\n+         };\n+         debugSelectionTimer_.schedule(250);\n+      }\n+   }\n+\n+   public boolean insertCode(String code, boolean isBlock)\n+   {\n+      if (activeEditor_ != null &&\n+          activeEditor_ instanceof TextEditingTarget &&\n+          commands_.executeCode().isEnabled())\n+      {\n+         TextEditingTarget textEditor = (TextEditingTarget) activeEditor_;\n+         textEditor.insertCode(code, isBlock);\n+         return true;\n+      }\n+      return false;\n+   }\n+\n+   public void incrementNewTabPending()\n+   {\n+       newTabPending_++;\n+   }\n+\n+   public void decrementNewTabPending()\n+   {\n+      newTabPending_--;\n+   }\n+\n+   public int getUntitledNum(String prefix)\n+   {\n+      int max = 0;\n+      for (EditingTarget target : editors_)\n+      {\n+         String name = target.getName().getValue();\n+         max = Math.max(max, manager_.getUntitledNum(name, prefix));\n+      }\n+      return max;\n+   }\n+\n+   private String getNextDefaultName(String defaultNamePrefix)\n+   {\n+      if (StringUtil.isNullOrEmpty(defaultNamePrefix))\n+         defaultNamePrefix = \"Untitled\";\n+\n+      int max = manager_.getUntitledNum(defaultNamePrefix);\n+      return defaultNamePrefix + (max + 1);\n+   }\n+\n+   private boolean isDebugSelectionPending()\n+   {\n+      return debugSelectionTimer_ != null;\n+   }\n+\n+   private boolean isUnsavedTarget(EditingTarget target, int type)\n+   {\n+      boolean fileBacked = target.getPath() != null;\n+      return target.dirtyState().getValue() &&\n+         ((type == Source.TYPE_FILE_BACKED &&  fileBacked) ||\n+            (type == Source.TYPE_UNTITLED    && !fileBacked));\n+   }\n+\n+   private void clearPendingDebugSelection()\n+   {\n+      if (debugSelectionTimer_ != null)\n+      {\n+         debugSelectionTimer_.cancel();\n+         debugSelectionTimer_ = null;\n+      }\n+   }\n+\n+   public void manageCommands(boolean forceSync)\n+   {\n+      boolean hasDocs = hasDoc();\n+\n+      commands_.newSourceDoc().setEnabled(true);\n+      commands_.closeSourceDoc().setEnabled(hasDocs);\n+      commands_.closeAllSourceDocs().setEnabled(hasDocs);\n+      commands_.nextTab().setEnabled(hasDocs);\n+      commands_.previousTab().setEnabled(hasDocs);\n+      commands_.firstTab().setEnabled(hasDocs);\n+      commands_.lastTab().setEnabled(hasDocs);\n+      commands_.switchToTab().setEnabled(hasDocs);\n+      commands_.setWorkingDirToActiveDoc().setEnabled(hasDocs);\n+\n+      HashSet<AppCommand> newCommands = activeEditor_ != null\n+              ? activeEditor_.getSupportedCommands()\n+              : new HashSet<>();\n+\n+      if (forceSync)\n+      {\n+         for (AppCommand command : activeCommands_)\n+         {\n+            command.setEnabled(false);\n+            command.setVisible(false);\n+         }\n+\n+         for (AppCommand command : newCommands)\n+         {\n+            command.setEnabled(true);\n+            command.setVisible(true);\n+         }\n+      }\n+      else\n+      {\n+         HashSet<AppCommand> commandsToEnable = new HashSet<>(newCommands);\n+         commandsToEnable.removeAll(activeCommands_);\n+\n+         HashSet<AppCommand> commandsToDisable = new HashSet<>(activeCommands_);\n+         commandsToDisable.removeAll(newCommands);\n+\n+         for (AppCommand command : commandsToEnable)\n+         {\n+            command.setEnabled(true);\n+            command.setVisible(true);\n+         }\n+\n+         for (AppCommand command : commandsToDisable)\n+         {\n+            command.setEnabled(false);\n+            command.setVisible(false);\n+         }\n+      }\n+\n+      // commands which should always be visible even when disabled\n+      commands_.saveSourceDoc().setVisible(true);\n+      commands_.saveSourceDocAs().setVisible(true);\n+      commands_.printSourceDoc().setVisible(true);\n+      commands_.setWorkingDirToActiveDoc().setVisible(true);\n+      commands_.debugBreakpoint().setVisible(true);\n+\n+      // manage synctex commands\n+      manageSynctexCommands();\n+\n+      // manage vcs commands\n+      manageVcsCommands();\n+\n+      // manage save and save all\n+      manageSaveCommands();\n+\n+      // manage source navigation\n+      manageSourceNavigationCommands();\n+\n+      // manage RSConnect commands\n+      manageRSConnectCommands();\n+\n+      // manage R Markdown commands\n+      manageRMarkdownCommands();\n+\n+      // manage multi-tab commands\n+      manageMultiTabCommands();\n+\n+      manageTerminalCommands();\n+\n+      activeCommands_ = newCommands;\n+\n+      // give the active editor a chance to manage commands\n+      if (activeEditor_ != null)\n+         activeEditor_.manageCommands();\n+\n+      assert verifyNoUnsupportedCommands(newCommands)\n+              : \"Unsupported commands detected (please add to SourceColumnManager.getDynamicCommands())\";\n+   }\n+\n+   private void manageSynctexCommands()\n+   {\n+      // synctex commands are enabled if we have synctex for the active editor\n+      boolean synctexAvailable = manager_.getSynctex().isSynctexAvailable();\n+      if (synctexAvailable)\n+      {\n+         if ((activeEditor_ != null) &&\n+                 (activeEditor_.getPath() != null) &&\n+                 activeEditor_.canCompilePdf())\n+         {\n+            synctexAvailable = manager_.getSynctex().isSynctexAvailable();\n+         }\n+         else\n+         {\n+            synctexAvailable = false;\n+         }\n+      }\n+\n+      manager_.getSynctex().enableCommands(synctexAvailable);\n+   }\n+\n+   private void manageVcsCommands()\n+   {\n+      // manage availablity of vcs commands", "originalCommit": "b05e15e98d5dec936f440319aa15d74615743fc3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1ODE5MQ==", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438458191", "bodyText": "nit: could use lambda", "author": "gtritchie", "createdAt": "2020-06-10T23:17:48Z", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/SourceColumn.java", "diffHunk": "@@ -0,0 +1,1215 @@\n+/*\n+ * SourceColumn.java\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+package org.rstudio.studio.client.workbench.views.source;\n+\n+import com.google.gwt.core.client.JsArrayString;\n+import com.google.gwt.core.client.Scheduler;\n+import com.google.gwt.event.logical.shared.SelectionEvent;\n+import com.google.gwt.event.logical.shared.SelectionHandler;\n+import com.google.gwt.user.client.Command;\n+import com.google.gwt.user.client.Timer;\n+import com.google.gwt.user.client.ui.Widget;\n+import com.google.inject.Inject;\n+import org.rstudio.core.client.Debug;\n+import org.rstudio.core.client.JsArrayUtil;\n+import org.rstudio.core.client.ResultCallback;\n+import org.rstudio.core.client.StringUtil;\n+import org.rstudio.core.client.command.AppCommand;\n+import org.rstudio.core.client.command.CommandBinder;\n+import org.rstudio.core.client.events.*;\n+import org.rstudio.core.client.files.FileSystemItem;\n+import org.rstudio.core.client.js.JsObject;\n+import org.rstudio.core.client.js.JsUtil;\n+import org.rstudio.core.client.theme.DocTabSelectionEvent;\n+import org.rstudio.core.client.widget.OperationWithInput;\n+import org.rstudio.studio.client.RStudioGinjector;\n+import org.rstudio.studio.client.application.events.EventBus;\n+import org.rstudio.studio.client.common.SimpleRequestCallback;\n+import org.rstudio.studio.client.common.filetypes.EditableFileType;\n+import org.rstudio.studio.client.common.filetypes.FileIcon;\n+import org.rstudio.studio.client.common.filetypes.FileTypeRegistry;\n+import org.rstudio.studio.client.common.filetypes.TextFileType;\n+import org.rstudio.studio.client.common.synctex.events.SynctexStatusChangedEvent;\n+import org.rstudio.studio.client.server.ServerError;\n+import org.rstudio.studio.client.server.ServerRequestCallback;\n+import org.rstudio.studio.client.server.VoidServerRequestCallback;\n+import org.rstudio.studio.client.workbench.commands.Commands;\n+import org.rstudio.studio.client.workbench.model.RemoteFileSystemContext;\n+import org.rstudio.studio.client.workbench.model.SessionUtils;\n+import org.rstudio.studio.client.workbench.model.UnsavedChangesTarget;\n+import org.rstudio.studio.client.workbench.ui.unsaved.UnsavedChangesDialog;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTargetSource;\n+import org.rstudio.studio.client.workbench.views.source.editors.codebrowser.CodeBrowserEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.TextEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.FileTypeChangedEvent;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.SourceOnSaveChangedEvent;\n+import org.rstudio.studio.client.workbench.views.source.events.*;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceDocument;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceNavigation;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceServerOperations;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class SourceColumn implements SelectionHandler<Integer>,\n+                                     TabClosingHandler,\n+                                     TabCloseHandler,\n+                                     TabClosedHandler,\n+                                     TabReorderHandler\n+{\n+   interface Binder extends CommandBinder<Commands, SourceColumn>\n+   {\n+   }\n+\n+   SourceColumn()\n+   {\n+      RStudioGinjector.INSTANCE.injectMembers(this);\n+   }\n+\n+   @Inject\n+   public void initialize(Binder binder,\n+                          Commands commands,\n+                          EventBus events,\n+                          EditingTargetSource editingTargetSource,\n+                          RemoteFileSystemContext fileContext,\n+                          SourceServerOperations sourceServerOperations)\n+   {\n+      commands_ = commands;\n+      binder.bind(commands_, this);\n+\n+      events_ = events;\n+      editingTargetSource_ = editingTargetSource;\n+      fileContext_ = fileContext;\n+      server_ = sourceServerOperations;\n+\n+\n+      events_.addHandler(FileTypeChangedEvent.TYPE, event -> manageCommands(false));\n+      events_.addHandler(SourceOnSaveChangedEvent.TYPE, event -> manageSaveCommands());\n+      events_.addHandler(SynctexStatusChangedEvent.TYPE, event -> manageSynctexCommands());\n+\n+      initialized_ = true;\n+   }\n+\n+   public void loadDisplay(String name,\n+                           Source.Display display,\n+                           SourceColumnManager manager)\n+   {\n+      name_ = name;\n+      display_ = display;\n+      manager_ = manager;\n+\n+      display_.addSelectionHandler(this);\n+      display_.addTabClosingHandler(this);\n+      display_.addTabCloseHandler(this);\n+      display_.addTabClosedHandler(this);\n+      display_.addTabReorderHandler(this);\n+\n+      ensureVisible(false);\n+   }\n+\n+   public String getName()\n+   {\n+      return name_;\n+   }\n+\n+   public EditingTarget getActiveEditor()\n+   {\n+      return activeEditor_;\n+   }\n+\n+   public ArrayList<EditingTarget> getEditors()\n+   {\n+      return editors_;\n+   }\n+\n+   public ArrayList<EditingTarget> getDirtyEditors(final EditingTarget excludeEditor)\n+   {\n+      ArrayList<EditingTarget> dirtyEditors = new ArrayList<>();\n+      for (EditingTarget target : editors_)\n+      {\n+         if (excludeEditor != null && target == excludeEditor)\n+            continue;\n+         if (target.dirtyState().getValue())\n+            dirtyEditors.add(target);\n+      }\n+      return dirtyEditors;\n+   }\n+\n+   public ArrayList<EditingTarget> getUnsavedEditors(int type, Set<String> ids)\n+   {\n+      ArrayList<EditingTarget> unsavedEditors = new ArrayList<>();\n+      for (EditingTarget target : editors_)\n+      {\n+         if (!isUnsavedTarget(target, type))\n+            continue;\n+         if (ids != null && !ids.contains(target.getId()))\n+            continue;\n+         unsavedEditors.add(target);\n+      }\n+      return unsavedEditors;\n+   }\n+\n+   public ArrayList<Integer> getTabOrder()\n+   {\n+      return tabOrder_;\n+   }\n+\n+   public Widget asWidget()\n+   {\n+      return display_.asWidget();\n+   }\n+\n+   // Display wrapper methods\n+   public void cancelTabDrag()\n+   {\n+      display_.cancelTabDrag();\n+   }\n+   \n+   public void closeTab(Widget child, boolean interactive)\n+   {\n+      display_.closeTab(child, interactive);\n+   }\n+\n+   public void closeTab(Widget child, boolean interactive, Command onClosed)\n+   {\n+      display_.closeTab(child, interactive, onClosed);\n+   }\n+   \n+   public void closeTab(int index, boolean interactive)\n+   {\n+      display_.closeTab(index, interactive);\n+   }\n+\n+   public void closeTab(int index, boolean interactive, Command onClosed)\n+   {\n+\t   display_.closeTab(index, interactive, onClosed);\n+   }\n+\n+   public void closeAllLocalSourceDocs()\n+   {\n+      // TODO\n+   }\n+\n+   public int getTabCount()\n+   {\n+      return display_.getTabCount();\n+   }\n+   \n+   public void manageChevronVisibility()\n+   {\n+\t   display_.manageChevronVisibility();\n+   }\n+   \n+   public void moveTab(int index, int delta)\n+   {\n+\t   display_.moveTab(index, delta);\n+   }\n+   \n+   public void selectTab(Widget widget)\n+   {\n+\t   display_.selectTab(widget);\n+   }\n+   \n+   public void showOverflowPopout()\n+   {\n+\t   display_.showOverflowPopup();\n+   }\n+   \n+   public void showUnsavedChangesDialog(\n+         String title,\n+         ArrayList<UnsavedChangesTarget> dirtyTargets,\n+         OperationWithInput<UnsavedChangesDialog.Result> saveOperation,\n+         Command onCancelled)\n+   {\n+      display_.showUnsavedChangesDialog(title, dirtyTargets, saveOperation, onCancelled);\n+   }\n+   \n+   public void initialSelect(int index)\n+   {\n+      if (index >= 0 && display_.getTabCount() > index)\n+         display_.selectTab(index);\n+      if (display_.getTabCount() > 0 && display_.getActiveTabIndex() >= 0)\n+         editors_.get(index).onInitiallyLoaded();\n+   }\n+\n+   /**\n+    * @param isNewTabPending True if a new tab is about to be created. (If\n+    *    false and there are no tabs already, then a new source doc might\n+    *    be created to make sure we don't end up with a source pane showing\n+    *    with no tabs in it.)\n+    */\n+   public void ensureVisible(boolean isNewTabPending)\n+   {\n+      newTabPending_++;\n+      try\n+      {\n+         display_.ensureVisible();\n+      }\n+      finally\n+      {\n+         newTabPending_--;\n+      }\n+   }\n+\n+   // when tabs have been reordered in the session, the physical layout of the\n+   // tabs doesn't match the logical order of editors_. it's occasionally\n+   // necessary to get or set the tabs by their physical order.\n+   public int getPhysicalTabIndex()\n+   {\n+      int idx = display_.getActiveTabIndex();\n+      if (idx < tabOrder_.size())\n+      {\n+         idx = tabOrder_.indexOf(idx);\n+      }\n+      return idx;\n+   }\n+\n+   public void setPhysicalTabIndex(int idx)\n+   {\n+      if (idx < tabOrder_.size())\n+      {\n+         idx = tabOrder_.get(idx);\n+      }\n+      display_.selectTab(idx);\n+   }\n+\n+   private void onActivate(EditingTarget target)\n+   {\n+       // return if we're already set properly\n+       if (activeEditor_ != null && activeEditor_ == target)\n+          return;\n+\n+       // deactivate prior active editor\n+       if (activeEditor_ != null)\n+          activeEditor_.onDeactivate();\n+\n+       // set and active editor\n+       activeEditor_ = target;\n+       if (activeEditor_ != null)\n+          activeEditor_.onActivate();\n+       manageCommands();\n+   }\n+\n+   void setActiveEditor()\n+   {\n+       if (activeEditor_ == null &&\n+           editors_.size() > display_.getActiveTabIndex())\n+          onActivate(editors_.get(display_.getActiveTabIndex()));\n+   }\n+\n+   EditingTarget setActiveEditor(String docId)\n+   {\n+      if (StringUtil.isNullOrEmpty(docId) &&\n+          activeEditor_ != null)\n+      {\n+         activeEditor_.onDeactivate();\n+         activeEditor_ = null;\n+         return null;\n+      }\n+\n+      for (EditingTarget target : editors_)\n+      {\n+         if (target.getId().equals(docId))\n+         {\n+             onActivate(target);\n+            return target;\n+         }\n+      }\n+      return null;\n+   }\n+\n+   public void setActiveEditor(EditingTarget target)\n+   {\n+      // This should never happen\n+      if (!editors_.contains(target))\n+      {\n+         Debug.logWarning(\"Attempting to set active editor to an unknown target.\");\n+         return;\n+      }\n+      onActivate(target);\n+   }\n+\n+   private void syncTabOrder()\n+   {\n+      // ensure the tab order is synced to the list of editors\n+      for (int i = tabOrder_.size(); i < editors_.size(); i++)\n+      {\n+         tabOrder_.add(i);\n+      }\n+      for (int i = editors_.size(); i < tabOrder_.size(); i++)\n+      {\n+         tabOrder_.remove(i);\n+      }\n+   }\n+\n+   public void fireDocTabsChanged()\n+   {\n+      if (!initialized_)\n+         return;\n+\n+      // ensure we have a tab order (we want the popup list to match the order\n+      // of the tabs)\n+      syncTabOrder();\n+\n+      ArrayList<EditingTarget> editors = editors_;\n+      String[] ids = new String[editors.size()];\n+      FileIcon[] icons = new FileIcon[editors.size()];\n+      String[] names = new String[editors.size()];\n+      String[] paths = new String[editors.size()];\n+      for (int i = 0; i < ids.length; i++)\n+      {\n+         EditingTarget target = editors.get(getTabOrder().get(i));\n+         ids[i] = target.getId();\n+         icons[i] = target.getIcon();\n+         names[i] = target.getName().getValue();\n+         paths[i] = target.getPath();\n+      }\n+\n+      String activeId = (activeEditor_ != null)\n+            ? activeEditor_.getId()\n+            : null;\n+\n+      events_.fireEvent(new DocTabsChangedEvent(activeId, ids, icons, names, paths));\n+\n+      manageChevronVisibility();\n+   }\n+\n+   public boolean hasDoc(String docId)\n+   {\n+      for (EditingTarget target : editors_)\n+      {\n+         if (StringUtil.equals(docId, target.getId()))\n+            return true;\n+      }\n+      return false;\n+   }\n+\n+   public boolean hasDoc()\n+   {\n+      return editors_.size() > 0;\n+   }\n+\n+   public boolean isSaveCommandActive()\n+   {\n+      for (EditingTarget target : editors_)\n+      {\n+         if (target.isSaveCommandActive())\n+            return true;\n+      }\n+      return false;\n+   }\n+\n+   public EditingTarget getDoc(String docId)\n+   {\n+      for (EditingTarget target : editors_)\n+      {\n+         if (StringUtil.equals(docId, target.getId()))\n+            return target;\n+      }\n+      return null;\n+   }\n+\n+   public boolean hasDocWithPath(String path)\n+   {\n+      for (EditingTarget target : editors_)\n+      {\n+         if (StringUtil.equals(path, target.getPath()))\n+            return true;\n+      }\n+      return false;\n+   }\n+\n+   public EditingTarget getEditorWithPath(String path)\n+   {\n+      for (EditingTarget target : editors_)\n+      {\n+         if (StringUtil.equals(path, target.getPath()))\n+            return target;\n+      }\n+      return null;\n+   }\n+\n+   private Widget createWidget(EditingTarget target)\n+   {\n+      return target.asWidget();\n+   }\n+   \n+   public EditingTarget addTab(SourceDocument doc, int mode)\n+   {\n+      return addTab(doc, false, mode);\n+   }\n+   \n+   public EditingTarget addTab(SourceDocument doc, boolean atEnd,\n+         int mode)\n+   {\n+      // by default, add at the tab immediately after the current tab\n+      return addTab(doc, atEnd ? null : getPhysicalTabIndex() + 1,\n+            mode);\n+   }\n+\n+   public EditingTarget addTab(SourceDocument doc, Integer position, int mode)\n+   {\n+      final String defaultNamePrefix = editingTargetSource_.getDefaultNamePrefix(doc);\n+      final EditingTarget target = editingTargetSource_.getEditingTarget(\n+            doc, fileContext_, () -> getNextDefaultName(defaultNamePrefix));\n+      final Widget widget = createWidget(target);\n+\n+      if (position == null)\n+      {\n+         editors_.add(target);\n+      }\n+      else\n+      {\n+         // we're inserting into an existing permuted tabset -- push aside\n+         // any tabs physically to the right of this tab\n+         editors_.add(position, target);\n+         for (int i = 0; i < tabOrder_.size(); i++)\n+         {\n+            int pos = tabOrder_.get(i);\n+            if (pos >= position)\n+               tabOrder_.set(i, pos + 1);\n+         }\n+\n+         // add this tab in its \"natural\" position\n+         tabOrder_.add(position, position);\n+      }\n+\n+      display_.addTab(widget,\n+                      target.getIcon(),\n+                      target.getId(),\n+                      target.getName().getValue(),\n+                      target.getTabTooltip(), // used as tooltip, if non-null\n+                      position,\n+                      true);\n+      fireDocTabsChanged();\n+\n+      target.getName().addValueChangeHandler(event -> {\n+         display_.renameTab(widget,\n+                            target.getIcon(),\n+                            event.getValue(),\n+                            target.getPath());\n+         fireDocTabsChanged();\n+      });\n+\n+      display_.setDirty(widget, target.dirtyState().getValue());\n+      target.dirtyState().addValueChangeHandler(event -> {\n+         display_.setDirty(widget, event.getValue());\n+         manageCommands(false);\n+      });\n+\n+      target.addEnsureVisibleHandler(new EnsureVisibleHandler()", "originalCommit": "b05e15e98d5dec936f440319aa15d74615743fc3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1ODQ3Mw==", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438458473", "bodyText": "Is this intentionally left as \"TODO\"?", "author": "gtritchie", "createdAt": "2020-06-10T23:18:46Z", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/SourceColumn.java", "diffHunk": "@@ -0,0 +1,1215 @@\n+/*\n+ * SourceColumn.java\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+package org.rstudio.studio.client.workbench.views.source;\n+\n+import com.google.gwt.core.client.JsArrayString;\n+import com.google.gwt.core.client.Scheduler;\n+import com.google.gwt.event.logical.shared.SelectionEvent;\n+import com.google.gwt.event.logical.shared.SelectionHandler;\n+import com.google.gwt.user.client.Command;\n+import com.google.gwt.user.client.Timer;\n+import com.google.gwt.user.client.ui.Widget;\n+import com.google.inject.Inject;\n+import org.rstudio.core.client.Debug;\n+import org.rstudio.core.client.JsArrayUtil;\n+import org.rstudio.core.client.ResultCallback;\n+import org.rstudio.core.client.StringUtil;\n+import org.rstudio.core.client.command.AppCommand;\n+import org.rstudio.core.client.command.CommandBinder;\n+import org.rstudio.core.client.events.*;\n+import org.rstudio.core.client.files.FileSystemItem;\n+import org.rstudio.core.client.js.JsObject;\n+import org.rstudio.core.client.js.JsUtil;\n+import org.rstudio.core.client.theme.DocTabSelectionEvent;\n+import org.rstudio.core.client.widget.OperationWithInput;\n+import org.rstudio.studio.client.RStudioGinjector;\n+import org.rstudio.studio.client.application.events.EventBus;\n+import org.rstudio.studio.client.common.SimpleRequestCallback;\n+import org.rstudio.studio.client.common.filetypes.EditableFileType;\n+import org.rstudio.studio.client.common.filetypes.FileIcon;\n+import org.rstudio.studio.client.common.filetypes.FileTypeRegistry;\n+import org.rstudio.studio.client.common.filetypes.TextFileType;\n+import org.rstudio.studio.client.common.synctex.events.SynctexStatusChangedEvent;\n+import org.rstudio.studio.client.server.ServerError;\n+import org.rstudio.studio.client.server.ServerRequestCallback;\n+import org.rstudio.studio.client.server.VoidServerRequestCallback;\n+import org.rstudio.studio.client.workbench.commands.Commands;\n+import org.rstudio.studio.client.workbench.model.RemoteFileSystemContext;\n+import org.rstudio.studio.client.workbench.model.SessionUtils;\n+import org.rstudio.studio.client.workbench.model.UnsavedChangesTarget;\n+import org.rstudio.studio.client.workbench.ui.unsaved.UnsavedChangesDialog;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTargetSource;\n+import org.rstudio.studio.client.workbench.views.source.editors.codebrowser.CodeBrowserEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.TextEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.FileTypeChangedEvent;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.SourceOnSaveChangedEvent;\n+import org.rstudio.studio.client.workbench.views.source.events.*;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceDocument;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceNavigation;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceServerOperations;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class SourceColumn implements SelectionHandler<Integer>,\n+                                     TabClosingHandler,\n+                                     TabCloseHandler,\n+                                     TabClosedHandler,\n+                                     TabReorderHandler\n+{\n+   interface Binder extends CommandBinder<Commands, SourceColumn>\n+   {\n+   }\n+\n+   SourceColumn()\n+   {\n+      RStudioGinjector.INSTANCE.injectMembers(this);\n+   }\n+\n+   @Inject\n+   public void initialize(Binder binder,\n+                          Commands commands,\n+                          EventBus events,\n+                          EditingTargetSource editingTargetSource,\n+                          RemoteFileSystemContext fileContext,\n+                          SourceServerOperations sourceServerOperations)\n+   {\n+      commands_ = commands;\n+      binder.bind(commands_, this);\n+\n+      events_ = events;\n+      editingTargetSource_ = editingTargetSource;\n+      fileContext_ = fileContext;\n+      server_ = sourceServerOperations;\n+\n+\n+      events_.addHandler(FileTypeChangedEvent.TYPE, event -> manageCommands(false));\n+      events_.addHandler(SourceOnSaveChangedEvent.TYPE, event -> manageSaveCommands());\n+      events_.addHandler(SynctexStatusChangedEvent.TYPE, event -> manageSynctexCommands());\n+\n+      initialized_ = true;\n+   }\n+\n+   public void loadDisplay(String name,\n+                           Source.Display display,\n+                           SourceColumnManager manager)\n+   {\n+      name_ = name;\n+      display_ = display;\n+      manager_ = manager;\n+\n+      display_.addSelectionHandler(this);\n+      display_.addTabClosingHandler(this);\n+      display_.addTabCloseHandler(this);\n+      display_.addTabClosedHandler(this);\n+      display_.addTabReorderHandler(this);\n+\n+      ensureVisible(false);\n+   }\n+\n+   public String getName()\n+   {\n+      return name_;\n+   }\n+\n+   public EditingTarget getActiveEditor()\n+   {\n+      return activeEditor_;\n+   }\n+\n+   public ArrayList<EditingTarget> getEditors()\n+   {\n+      return editors_;\n+   }\n+\n+   public ArrayList<EditingTarget> getDirtyEditors(final EditingTarget excludeEditor)\n+   {\n+      ArrayList<EditingTarget> dirtyEditors = new ArrayList<>();\n+      for (EditingTarget target : editors_)\n+      {\n+         if (excludeEditor != null && target == excludeEditor)\n+            continue;\n+         if (target.dirtyState().getValue())\n+            dirtyEditors.add(target);\n+      }\n+      return dirtyEditors;\n+   }\n+\n+   public ArrayList<EditingTarget> getUnsavedEditors(int type, Set<String> ids)\n+   {\n+      ArrayList<EditingTarget> unsavedEditors = new ArrayList<>();\n+      for (EditingTarget target : editors_)\n+      {\n+         if (!isUnsavedTarget(target, type))\n+            continue;\n+         if (ids != null && !ids.contains(target.getId()))\n+            continue;\n+         unsavedEditors.add(target);\n+      }\n+      return unsavedEditors;\n+   }\n+\n+   public ArrayList<Integer> getTabOrder()\n+   {\n+      return tabOrder_;\n+   }\n+\n+   public Widget asWidget()\n+   {\n+      return display_.asWidget();\n+   }\n+\n+   // Display wrapper methods\n+   public void cancelTabDrag()\n+   {\n+      display_.cancelTabDrag();\n+   }\n+   \n+   public void closeTab(Widget child, boolean interactive)\n+   {\n+      display_.closeTab(child, interactive);\n+   }\n+\n+   public void closeTab(Widget child, boolean interactive, Command onClosed)\n+   {\n+      display_.closeTab(child, interactive, onClosed);\n+   }\n+   \n+   public void closeTab(int index, boolean interactive)\n+   {\n+      display_.closeTab(index, interactive);\n+   }\n+\n+   public void closeTab(int index, boolean interactive, Command onClosed)\n+   {\n+\t   display_.closeTab(index, interactive, onClosed);\n+   }\n+\n+   public void closeAllLocalSourceDocs()\n+   {\n+      // TODO", "originalCommit": "b05e15e98d5dec936f440319aa15d74615743fc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5MjA4MQ==", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438492081", "bodyText": "No, I remove this and added an option to SouceColumnManager's closeAllLocalSourceDocs function to accept a single column.", "author": "melissa-barca", "createdAt": "2020-06-11T01:23:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1ODQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1OTI4Ng==", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438459286", "bodyText": "Is this right? At first glance seems like this won't work but I might be misunderstanding.", "author": "gtritchie", "createdAt": "2020-06-10T23:21:21Z", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/SourceColumn.java", "diffHunk": "@@ -0,0 +1,1215 @@\n+/*\n+ * SourceColumn.java\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+package org.rstudio.studio.client.workbench.views.source;\n+\n+import com.google.gwt.core.client.JsArrayString;\n+import com.google.gwt.core.client.Scheduler;\n+import com.google.gwt.event.logical.shared.SelectionEvent;\n+import com.google.gwt.event.logical.shared.SelectionHandler;\n+import com.google.gwt.user.client.Command;\n+import com.google.gwt.user.client.Timer;\n+import com.google.gwt.user.client.ui.Widget;\n+import com.google.inject.Inject;\n+import org.rstudio.core.client.Debug;\n+import org.rstudio.core.client.JsArrayUtil;\n+import org.rstudio.core.client.ResultCallback;\n+import org.rstudio.core.client.StringUtil;\n+import org.rstudio.core.client.command.AppCommand;\n+import org.rstudio.core.client.command.CommandBinder;\n+import org.rstudio.core.client.events.*;\n+import org.rstudio.core.client.files.FileSystemItem;\n+import org.rstudio.core.client.js.JsObject;\n+import org.rstudio.core.client.js.JsUtil;\n+import org.rstudio.core.client.theme.DocTabSelectionEvent;\n+import org.rstudio.core.client.widget.OperationWithInput;\n+import org.rstudio.studio.client.RStudioGinjector;\n+import org.rstudio.studio.client.application.events.EventBus;\n+import org.rstudio.studio.client.common.SimpleRequestCallback;\n+import org.rstudio.studio.client.common.filetypes.EditableFileType;\n+import org.rstudio.studio.client.common.filetypes.FileIcon;\n+import org.rstudio.studio.client.common.filetypes.FileTypeRegistry;\n+import org.rstudio.studio.client.common.filetypes.TextFileType;\n+import org.rstudio.studio.client.common.synctex.events.SynctexStatusChangedEvent;\n+import org.rstudio.studio.client.server.ServerError;\n+import org.rstudio.studio.client.server.ServerRequestCallback;\n+import org.rstudio.studio.client.server.VoidServerRequestCallback;\n+import org.rstudio.studio.client.workbench.commands.Commands;\n+import org.rstudio.studio.client.workbench.model.RemoteFileSystemContext;\n+import org.rstudio.studio.client.workbench.model.SessionUtils;\n+import org.rstudio.studio.client.workbench.model.UnsavedChangesTarget;\n+import org.rstudio.studio.client.workbench.ui.unsaved.UnsavedChangesDialog;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTargetSource;\n+import org.rstudio.studio.client.workbench.views.source.editors.codebrowser.CodeBrowserEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.TextEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.FileTypeChangedEvent;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.SourceOnSaveChangedEvent;\n+import org.rstudio.studio.client.workbench.views.source.events.*;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceDocument;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceNavigation;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceServerOperations;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class SourceColumn implements SelectionHandler<Integer>,\n+                                     TabClosingHandler,\n+                                     TabCloseHandler,\n+                                     TabClosedHandler,\n+                                     TabReorderHandler\n+{\n+   interface Binder extends CommandBinder<Commands, SourceColumn>\n+   {\n+   }\n+\n+   SourceColumn()\n+   {\n+      RStudioGinjector.INSTANCE.injectMembers(this);\n+   }\n+\n+   @Inject\n+   public void initialize(Binder binder,\n+                          Commands commands,\n+                          EventBus events,\n+                          EditingTargetSource editingTargetSource,\n+                          RemoteFileSystemContext fileContext,\n+                          SourceServerOperations sourceServerOperations)\n+   {\n+      commands_ = commands;\n+      binder.bind(commands_, this);\n+\n+      events_ = events;\n+      editingTargetSource_ = editingTargetSource;\n+      fileContext_ = fileContext;\n+      server_ = sourceServerOperations;\n+\n+\n+      events_.addHandler(FileTypeChangedEvent.TYPE, event -> manageCommands(false));\n+      events_.addHandler(SourceOnSaveChangedEvent.TYPE, event -> manageSaveCommands());\n+      events_.addHandler(SynctexStatusChangedEvent.TYPE, event -> manageSynctexCommands());\n+\n+      initialized_ = true;\n+   }\n+\n+   public void loadDisplay(String name,\n+                           Source.Display display,\n+                           SourceColumnManager manager)\n+   {\n+      name_ = name;\n+      display_ = display;\n+      manager_ = manager;\n+\n+      display_.addSelectionHandler(this);\n+      display_.addTabClosingHandler(this);\n+      display_.addTabCloseHandler(this);\n+      display_.addTabClosedHandler(this);\n+      display_.addTabReorderHandler(this);\n+\n+      ensureVisible(false);\n+   }\n+\n+   public String getName()\n+   {\n+      return name_;\n+   }\n+\n+   public EditingTarget getActiveEditor()\n+   {\n+      return activeEditor_;\n+   }\n+\n+   public ArrayList<EditingTarget> getEditors()\n+   {\n+      return editors_;\n+   }\n+\n+   public ArrayList<EditingTarget> getDirtyEditors(final EditingTarget excludeEditor)\n+   {\n+      ArrayList<EditingTarget> dirtyEditors = new ArrayList<>();\n+      for (EditingTarget target : editors_)\n+      {\n+         if (excludeEditor != null && target == excludeEditor)\n+            continue;\n+         if (target.dirtyState().getValue())\n+            dirtyEditors.add(target);\n+      }\n+      return dirtyEditors;\n+   }\n+\n+   public ArrayList<EditingTarget> getUnsavedEditors(int type, Set<String> ids)\n+   {\n+      ArrayList<EditingTarget> unsavedEditors = new ArrayList<>();\n+      for (EditingTarget target : editors_)\n+      {\n+         if (!isUnsavedTarget(target, type))\n+            continue;\n+         if (ids != null && !ids.contains(target.getId()))\n+            continue;\n+         unsavedEditors.add(target);\n+      }\n+      return unsavedEditors;\n+   }\n+\n+   public ArrayList<Integer> getTabOrder()\n+   {\n+      return tabOrder_;\n+   }\n+\n+   public Widget asWidget()\n+   {\n+      return display_.asWidget();\n+   }\n+\n+   // Display wrapper methods\n+   public void cancelTabDrag()\n+   {\n+      display_.cancelTabDrag();\n+   }\n+   \n+   public void closeTab(Widget child, boolean interactive)\n+   {\n+      display_.closeTab(child, interactive);\n+   }\n+\n+   public void closeTab(Widget child, boolean interactive, Command onClosed)\n+   {\n+      display_.closeTab(child, interactive, onClosed);\n+   }\n+   \n+   public void closeTab(int index, boolean interactive)\n+   {\n+      display_.closeTab(index, interactive);\n+   }\n+\n+   public void closeTab(int index, boolean interactive, Command onClosed)\n+   {\n+\t   display_.closeTab(index, interactive, onClosed);\n+   }\n+\n+   public void closeAllLocalSourceDocs()\n+   {\n+      // TODO\n+   }\n+\n+   public int getTabCount()\n+   {\n+      return display_.getTabCount();\n+   }\n+   \n+   public void manageChevronVisibility()\n+   {\n+\t   display_.manageChevronVisibility();\n+   }\n+   \n+   public void moveTab(int index, int delta)\n+   {\n+\t   display_.moveTab(index, delta);\n+   }\n+   \n+   public void selectTab(Widget widget)\n+   {\n+\t   display_.selectTab(widget);\n+   }\n+   \n+   public void showOverflowPopout()\n+   {\n+\t   display_.showOverflowPopup();\n+   }\n+   \n+   public void showUnsavedChangesDialog(\n+         String title,\n+         ArrayList<UnsavedChangesTarget> dirtyTargets,\n+         OperationWithInput<UnsavedChangesDialog.Result> saveOperation,\n+         Command onCancelled)\n+   {\n+      display_.showUnsavedChangesDialog(title, dirtyTargets, saveOperation, onCancelled);\n+   }\n+   \n+   public void initialSelect(int index)\n+   {\n+      if (index >= 0 && display_.getTabCount() > index)\n+         display_.selectTab(index);\n+      if (display_.getTabCount() > 0 && display_.getActiveTabIndex() >= 0)\n+         editors_.get(index).onInitiallyLoaded();\n+   }\n+\n+   /**\n+    * @param isNewTabPending True if a new tab is about to be created. (If\n+    *    false and there are no tabs already, then a new source doc might\n+    *    be created to make sure we don't end up with a source pane showing\n+    *    with no tabs in it.)\n+    */\n+   public void ensureVisible(boolean isNewTabPending)\n+   {\n+      newTabPending_++;\n+      try\n+      {\n+         display_.ensureVisible();\n+      }\n+      finally\n+      {\n+         newTabPending_--;\n+      }\n+   }\n+\n+   // when tabs have been reordered in the session, the physical layout of the\n+   // tabs doesn't match the logical order of editors_. it's occasionally\n+   // necessary to get or set the tabs by their physical order.\n+   public int getPhysicalTabIndex()\n+   {\n+      int idx = display_.getActiveTabIndex();\n+      if (idx < tabOrder_.size())\n+      {\n+         idx = tabOrder_.indexOf(idx);\n+      }\n+      return idx;\n+   }\n+\n+   public void setPhysicalTabIndex(int idx)\n+   {\n+      if (idx < tabOrder_.size())\n+      {\n+         idx = tabOrder_.get(idx);\n+      }\n+      display_.selectTab(idx);\n+   }\n+\n+   private void onActivate(EditingTarget target)\n+   {\n+       // return if we're already set properly\n+       if (activeEditor_ != null && activeEditor_ == target)\n+          return;\n+\n+       // deactivate prior active editor\n+       if (activeEditor_ != null)\n+          activeEditor_.onDeactivate();\n+\n+       // set and active editor\n+       activeEditor_ = target;\n+       if (activeEditor_ != null)\n+          activeEditor_.onActivate();\n+       manageCommands();\n+   }\n+\n+   void setActiveEditor()\n+   {\n+       if (activeEditor_ == null &&\n+           editors_.size() > display_.getActiveTabIndex())\n+          onActivate(editors_.get(display_.getActiveTabIndex()));\n+   }\n+\n+   EditingTarget setActiveEditor(String docId)\n+   {\n+      if (StringUtil.isNullOrEmpty(docId) &&\n+          activeEditor_ != null)\n+      {\n+         activeEditor_.onDeactivate();\n+         activeEditor_ = null;\n+         return null;\n+      }\n+\n+      for (EditingTarget target : editors_)\n+      {\n+         if (target.getId().equals(docId))\n+         {\n+             onActivate(target);\n+            return target;\n+         }\n+      }\n+      return null;\n+   }\n+\n+   public void setActiveEditor(EditingTarget target)\n+   {\n+      // This should never happen\n+      if (!editors_.contains(target))\n+      {\n+         Debug.logWarning(\"Attempting to set active editor to an unknown target.\");\n+         return;\n+      }\n+      onActivate(target);\n+   }\n+\n+   private void syncTabOrder()\n+   {\n+      // ensure the tab order is synced to the list of editors\n+      for (int i = tabOrder_.size(); i < editors_.size(); i++)\n+      {\n+         tabOrder_.add(i);\n+      }\n+      for (int i = editors_.size(); i < tabOrder_.size(); i++)\n+      {\n+         tabOrder_.remove(i);", "originalCommit": "b05e15e98d5dec936f440319aa15d74615743fc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3NjA5OQ==", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438476099", "bodyText": "Yes, because each time we are only modifying tabOrder. This is taken from today's Source.java https://github.com/rstudio/rstudio/blob/master/src/gwt/src/org/rstudio/studio/client/workbench/views/source/Source.java#L3818-L3829", "author": "melissa-barca", "createdAt": "2020-06-11T00:20:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1OTI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDM0Mg==", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438460342", "bodyText": "Could replace with:\n         ArrayList<UnsavedChangesTarget> unsavedTargets = new ArrayList<>(editingTargets);", "author": "gtritchie", "createdAt": "2020-06-10T23:24:58Z", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/SourceColumnManager.java", "diffHunk": "@@ -0,0 +1,2377 @@\n+/*\n+ * SourceColumnManager.java\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+package org.rstudio.studio.client.workbench.views.source;\n+\n+import com.google.gwt.core.client.GWT;\n+import com.google.gwt.core.client.JavaScriptObject;\n+import com.google.gwt.core.client.JsArray;\n+import com.google.gwt.core.client.JsArrayString;\n+import com.google.gwt.event.dom.client.ChangeEvent;\n+import com.google.gwt.event.dom.client.ChangeHandler;\n+import com.google.gwt.json.client.JSONString;\n+import com.google.gwt.json.client.JSONValue;\n+import com.google.gwt.user.client.Command;\n+import com.google.gwt.user.client.ui.Widget;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.Singleton;\n+import org.rstudio.core.client.*;\n+import org.rstudio.core.client.command.AppCommand;\n+import org.rstudio.core.client.command.Handler;\n+import org.rstudio.core.client.files.FileSystemItem;\n+import org.rstudio.core.client.js.JsObject;\n+import org.rstudio.core.client.js.JsUtil;\n+import org.rstudio.core.client.widget.Operation;\n+import org.rstudio.core.client.widget.OperationWithInput;\n+import org.rstudio.core.client.widget.ProgressIndicator;\n+import org.rstudio.studio.client.RStudioGinjector;\n+import org.rstudio.studio.client.application.events.EventBus;\n+import org.rstudio.studio.client.common.FilePathUtils;\n+import org.rstudio.studio.client.common.GlobalDisplay;\n+import org.rstudio.studio.client.common.GlobalProgressDelayer;\n+import org.rstudio.studio.client.common.SimpleRequestCallback;\n+import org.rstudio.studio.client.common.dependencies.DependencyManager;\n+import org.rstudio.studio.client.common.filetypes.*;\n+import org.rstudio.studio.client.common.synctex.Synctex;\n+import org.rstudio.studio.client.events.GetEditorContextEvent;\n+import org.rstudio.studio.client.palette.model.CommandPaletteEntrySource;\n+import org.rstudio.studio.client.palette.model.CommandPaletteItem;\n+import org.rstudio.studio.client.rmarkdown.model.RmdChosenTemplate;\n+import org.rstudio.studio.client.rmarkdown.model.RmdFrontMatter;\n+import org.rstudio.studio.client.rmarkdown.model.RmdOutputFormat;\n+import org.rstudio.studio.client.rmarkdown.model.RmdTemplateData;\n+import org.rstudio.studio.client.server.ServerError;\n+import org.rstudio.studio.client.server.ServerRequestCallback;\n+import org.rstudio.studio.client.server.VoidServerRequestCallback;\n+import org.rstudio.studio.client.workbench.FileMRUList;\n+import org.rstudio.studio.client.workbench.commands.Commands;\n+import org.rstudio.studio.client.workbench.events.SessionInitEvent;\n+import org.rstudio.studio.client.workbench.events.SessionInitHandler;\n+import org.rstudio.studio.client.workbench.model.ClientState;\n+import org.rstudio.studio.client.workbench.model.Session;\n+import org.rstudio.studio.client.workbench.model.UnsavedChangesTarget;\n+import org.rstudio.studio.client.workbench.model.helper.JSObjectStateValue;\n+import org.rstudio.studio.client.workbench.prefs.model.UserPrefs;\n+import org.rstudio.studio.client.workbench.prefs.model.UserState;\n+import org.rstudio.studio.client.workbench.ui.unsaved.UnsavedChangesDialog;\n+import org.rstudio.studio.client.workbench.views.environment.events.DebugModeChangedEvent;\n+import org.rstudio.studio.client.workbench.views.output.find.events.FindInFilesEvent;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTargetSource;\n+import org.rstudio.studio.client.workbench.views.source.editors.codebrowser.CodeBrowserEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.data.DataEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.explorer.ObjectExplorerEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.explorer.model.ObjectExplorerHandle;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.AceEditor;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.DocDisplay;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.TextEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.TextEditingTargetRMarkdownHelper;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.ace.Position;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.ace.Range;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.ace.Selection;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.EditingTargetSelectedEvent;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.ui.NewRMarkdownDialog;\n+import org.rstudio.studio.client.workbench.views.source.events.*;\n+import org.rstudio.studio.client.workbench.views.source.model.*;\n+\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+@Singleton\n+public class SourceColumnManager implements SessionInitHandler,\n+                                            CommandPaletteEntrySource,\n+                                            SourceExtendedTypeDetectedEvent.Handler,\n+                                            DebugModeChangedEvent.Handler\n+{\n+   public interface CPSEditingTargetCommand\n+   {\n+      void execute(EditingTarget editingTarget, Command continuation);\n+   }\n+\n+   public static class State extends JavaScriptObject\n+   {\n+      public static native State createState(JsArrayString names) /*-{\n+         return {\n+            names: names\n+         }\n+      }-*/;\n+\n+      protected State()\n+      {}\n+\n+      public final String[] getNames()\n+      {\n+         return JsUtil.toStringArray(getNamesNative());\n+      }\n+\n+      private native JsArrayString getNamesNative() /*-{\n+          return this.names;\n+      }-*/;\n+   }\n+\n+   @Inject\n+   public SourceColumnManager(Source.Display display,\n+                              SourceServerOperations server,\n+                              GlobalDisplay globalDisplay,\n+                              Commands commands,\n+                              EditingTargetSource editingTargetSource,\n+                              FileTypeRegistry fileTypeRegistry,\n+                              EventBus events,\n+                              DependencyManager dependencyManager,\n+                              final Session session,\n+                              Synctex synctex,\n+                              UserPrefs userPrefs,\n+                              UserState userState,\n+                              Provider<FileMRUList> pMruList,\n+                              Provider<SourceWindowManager> pWindowManager)\n+   {\n+      SourceColumn column = GWT.create(SourceColumn.class);\n+      column.loadDisplay(MAIN_SOURCE_NAME, display, this);\n+      columnList_.add(column);\n+      setActive(column.getName());\n+\n+      server_ = server;\n+      commands_ = commands;\n+      globalDisplay_ = globalDisplay;\n+      editingTargetSource_ = editingTargetSource;\n+      fileTypeRegistry_ = fileTypeRegistry;\n+      events_ = events;\n+      dependencyManager_ = dependencyManager;\n+      session_ = session;\n+      synctex_ = synctex;\n+      userPrefs_ = userPrefs;\n+      userState_ = userState;\n+      pMruList_ = pMruList;\n+      pWindowManager_ = pWindowManager;\n+\n+      rmarkdown_ = new TextEditingTargetRMarkdownHelper();\n+      vimCommands_ = new SourceVimCommands();\n+      columnState_ = null;\n+      initDynamicCommands();\n+\n+      events_.addHandler(SourceExtendedTypeDetectedEvent.TYPE, this);\n+      events_.addHandler(DebugModeChangedEvent.TYPE, this);\n+\n+      events_.addHandler(SessionInitEvent.TYPE,this);\n+\n+      events_.addHandler(EditingTargetSelectedEvent.TYPE, new EditingTargetSelectedEvent.Handler()\n+      {\n+         @Override\n+         public void onEditingTargetSelected(EditingTargetSelectedEvent event)\n+         {\n+            setActive(event.getTarget());\n+         }\n+      });\n+\n+      events_.addHandler(SourceFileSavedEvent.TYPE, new SourceFileSavedHandler()\n+      {\n+         public void onSourceFileSaved(SourceFileSavedEvent event)\n+         {\n+            pMruList_.get().add(event.getPath());\n+         }\n+      });\n+\n+      events_.addHandler(DocTabActivatedEvent.TYPE, new DocTabActivatedEvent.Handler()\n+      {\n+         public void onDocTabActivated(DocTabActivatedEvent event)\n+         {\n+            setActiveDocId(event.getId());\n+         }\n+      });\n+\n+      sourceNavigationHistory_.addChangeHandler(new ChangeHandler()\n+      {\n+\n+         @Override\n+         public void onChange(ChangeEvent event)\n+         {\n+            columnList_.forEach((column) ->\n+               column.manageSourceNavigationCommands());\n+         }\n+      });\n+   }\n+\n+   public String add()\n+   {\n+      Source.Display display = GWT.create(SourcePane.class);\n+      return add(display, false);\n+   }\n+\n+   public String add(Source.Display display)\n+   {\n+      return add(display, false);\n+   }\n+\n+   public String add(String name, boolean updateState)\n+   {\n+      return add(name, false, updateState);\n+   }\n+\n+   public String add (String name, boolean activate, boolean updateState)\n+   {\n+      Source.Display display = GWT.create(SourcePane.class);\n+      return add(name, display, activate, updateState);\n+   }\n+\n+   public String add(Source.Display display, boolean activate)\n+   {\n+      return add(display, activate, true);\n+   }\n+\n+   public String add(Source.Display display, boolean activate, boolean updateState)\n+   {\n+      return add(COLUMN_PREFIX + StringUtil.makeRandomId(12),\n+                  display,\n+                  activate,\n+                  updateState);\n+   }\n+\n+   public String add(String name, Source.Display display, boolean activate, boolean updateState)\n+   {\n+      if (contains(name))\n+         return \"\";\n+\n+      SourceColumn column = GWT.create(SourceColumn.class);\n+      column.loadDisplay(name, display, this);\n+      columnList_.add(column);\n+\n+      if (activate || activeColumn_ == null)\n+         activeColumn_ = column;\n+\n+      if (updateState)\n+         columnState_ = State.createState(JsUtil.toJsArrayString(getNames(false)));\n+      return column.getName();\n+   }\n+\n+   public void initialSelect(int index)\n+   {\n+      getActive().initialSelect(index);\n+   }\n+\n+   public void setActive(String name)\n+   {\n+      if (StringUtil.isNullOrEmpty(name))\n+      {\n+         activeColumn_.setActiveEditor(\"\");\n+         activeColumn_ = null;\n+         return;\n+      }\n+\n+      String prevColumn = activeColumn_ == null ? \"\" : activeColumn_.getName();\n+      activeColumn_ = getByName(name);\n+\n+      // If the active column changed, we need to update the active editor\n+      if (!StringUtil.isNullOrEmpty(prevColumn) && !StringUtil.equals(name, prevColumn))\n+      {\n+         SourceColumn column = getByName(prevColumn);\n+         if (column == null)\n+            return;\n+         if (!hasActiveEditor())\n+         {\n+            Debug.logWarning(\"Setting to random editor.\");\n+            column.setActiveEditor();\n+         }\n+      }\n+   }\n+\n+   public void setActive(EditingTarget target)\n+   {\n+      activeColumn_ = findByDocument(target.getId());\n+      activeColumn_.setActiveEditor(target);\n+   }\n+\n+   public void setActiveDocId(String docId)\n+   {\n+      for (SourceColumn column : columnList_)\n+      {\n+         EditingTarget target = column.setActiveEditor(docId);\n+         if (target != null)\n+         {\n+            setActive(target);\n+            return;\n+         }\n+      }\n+      Debug.logWarning(\"Attempted to set unknown doc to active \" + docId);\n+   }\n+\n+   public void setOpeningForSourceNavigation(boolean value)\n+   {\n+      openingForSourceNavigation_ = value;\n+   }\n+\n+   public void activateColumns(final Command afterActivation)\n+   {\n+      if (!hasActiveEditor())\n+      {\n+         if (activeColumn_ == null)\n+            setActive(MAIN_SOURCE_NAME);\n+         newDoc(FileTypeRegistry.R, new ResultCallback<EditingTarget, ServerError>()\n+         {\n+            @Override\n+            public void onSuccess(EditingTarget target)\n+            {\n+               setActive(target);\n+               doActivateSource(afterActivation);\n+            }\n+         });\n+      } else\n+      {\n+         doActivateSource(afterActivation);\n+      }\n+   }\n+\n+   // This method sets activeColumn_ to the main column if it is null. It should be used in cases\n+   // where it is better for the column to be the main column than null.\n+   public SourceColumn getActive()\n+   {\n+      if (activeColumn_ != null)\n+         return activeColumn_;\n+      setActive(MAIN_SOURCE_NAME);\n+\n+      return activeColumn_;\n+   }\n+\n+   public String getActiveDocId()\n+   {\n+      if (hasActiveEditor())\n+         return activeColumn_.getActiveEditor().getId();\n+      return null;\n+   }\n+\n+   public String getActiveDocPath()\n+   {\n+      if (hasActiveEditor())\n+         return activeColumn_.getActiveEditor().getPath();\n+      return null;\n+   }\n+\n+   public boolean hasActiveEditor()\n+   {\n+      return activeColumn_ != null && activeColumn_.getActiveEditor() != null;\n+   }\n+\n+   public boolean isActiveEditor(EditingTarget editingTarget)\n+   {\n+      return hasActiveEditor() && activeColumn_.getActiveEditor() == editingTarget;\n+   }\n+\n+   // see if there are additional command pallette items made available\n+   // by the active editor\n+   public List<CommandPaletteItem> getCommandPaletteItems()\n+   {\n+      if (!hasActiveEditor())\n+         return null;\n+\n+      return activeColumn_.getActiveEditor().getCommandPaletteItems();\n+   }\n+\n+   public int getTabCount()\n+   {\n+      return activeColumn_.getTabCount();\n+   }\n+\n+   public int getPhysicalTabIndex()\n+   {\n+      return activeColumn_.getPhysicalTabIndex();\n+   }\n+\n+   public ArrayList<String> getNames(boolean excludeMain)\n+   {\n+      ArrayList<String> result = new ArrayList<>();\n+      columnList_.forEach((column) ->{\n+         if (!excludeMain || !StringUtil.equals(column.getName(), MAIN_SOURCE_NAME))\n+            result.add(column.getName());\n+      });\n+      return result;\n+   }\n+\n+   public ArrayList<Widget> getWidgets(boolean excludeMain)\n+   {\n+      ArrayList<Widget> result = new ArrayList<Widget>();\n+      for (SourceColumn column : columnList_)\n+      {\n+         if (!excludeMain || !StringUtil.equals(column.getName(), MAIN_SOURCE_NAME))\n+            result.add(column.asWidget());\n+      }\n+      return result;\n+   }\n+\n+   public ArrayList<SourceColumn> getColumnList()\n+   {\n+      return columnList_;\n+   }\n+\n+   public Widget getWidget(String name)\n+   {\n+      return getByName(name) == null ? null : getByName(name).asWidget();\n+   }\n+\n+   public Session getSession()\n+   {\n+      return session_;\n+   }\n+\n+   public SourceNavigationHistory getSourceNavigationHistory()\n+   {\n+      return sourceNavigationHistory_;\n+   }\n+\n+   public void recordCurrentNavigationHistoryPosition()\n+   {\n+      if (hasActiveEditor())\n+         activeColumn_.getActiveEditor().recordCurrentNavigationPosition();\n+   }\n+\n+   public String getEditorPositionString()\n+   {\n+      if (hasActiveEditor())\n+         return activeColumn_.getActiveEditor().getCurrentStatus();\n+      return \"No document tabs open\";\n+   }\n+\n+   public Synctex getSynctex()\n+   {\n+      return synctex_;\n+   }\n+\n+   public UserState getUserState()\n+   {\n+      return userState_;\n+   }\n+\n+   public int getSize()\n+   {\n+      return columnList_.size();\n+   }\n+\n+   public int getUntitledNum(String prefix)\n+   {\n+      AtomicInteger max = new AtomicInteger();\n+      columnList_.forEach((column) ->\n+          max.set(Math.max(max.get(), column.getUntitledNum(prefix))));\n+      return max.intValue();\n+   }\n+\n+   public native final int getUntitledNum(String name, String prefix) /*-{\n+       var match = (new RegExp(\"^\" + prefix + \"([0-9]{1,5})$\")).exec(name);\n+       if (!match)\n+           return 0;\n+       return parseInt(match[1]);\n+   }-*/;\n+\n+   public void clearSourceNavigationHistory()\n+   {\n+      if (!hasDoc())\n+         sourceNavigationHistory_.clear();\n+   }\n+\n+   public void manageCommands(boolean forceSync)\n+   {\n+      columnList_.forEach((column) -> column.manageCommands(forceSync));\n+   }\n+\n+   public EditingTarget addTab(SourceDocument doc, int mode, SourceColumn column)\n+   {\n+      if (column == null)\n+         column = activeColumn_;\n+      return column.addTab(doc, mode);\n+   }\n+\n+   public EditingTarget addTab(SourceDocument doc, boolean atEnd,\n+                               int mode, SourceColumn column)\n+   {\n+      if (column == null)\n+         column = activeColumn_;\n+      return column.addTab(doc, atEnd, mode);\n+   }\n+\n+   public EditingTarget findEditor(String docId)\n+   {\n+      for (SourceColumn column : columnList_)\n+      {\n+         EditingTarget target = column.getDoc(docId);\n+         if (target != null)\n+            return target;\n+      }\n+      return null;\n+   }\n+\n+   public EditingTarget findEditorByPath(String path)\n+   {\n+      if (StringUtil.isNullOrEmpty(path))\n+         return null;\n+\n+      for (SourceColumn column : columnList_)\n+      {\n+         EditingTarget target = column.getEditorWithPath(path);\n+         if (target != null)\n+            return target;\n+      }\n+      return null;\n+   }\n+\n+   public SourceColumn findByDocument(String docId)\n+   {\n+      for (SourceColumn column : columnList_)\n+      {\n+         if (column.hasDoc(docId))\n+            return column;\n+      }\n+      return null;\n+   }\n+\n+   public SourceColumn findByName(String name)\n+   {\n+      return getByName(name);\n+   }\n+\n+   public SourceColumn findByPosition(int x)\n+   {\n+      for (SourceColumn column : columnList_)\n+      {\n+\n+         Widget w = column.asWidget();\n+         int left = w.getAbsoluteLeft();\n+         int right = w.getAbsoluteLeft() + w.getOffsetWidth();\n+\n+         if (x > left && x < right)\n+            return column;\n+      }\n+      return null;\n+   }\n+\n+   public boolean isEmpty(String name)\n+   {\n+      return getByName(name) == null || getByName(name).getTabCount() == 0;\n+   }\n+\n+   public boolean areSourceWindowsOpen()\n+   {\n+      return pWindowManager_.get().areSourceWindowsOpen();\n+   }\n+\n+   public boolean attemptTextEditorActivate()\n+   {\n+      if (!(hasActiveEditor() ||\n+            activeColumn_.getActiveEditor() instanceof TextEditingTarget))\n+         return false;\n+\n+      TextEditingTarget editingTarget = (TextEditingTarget) activeColumn_.getActiveEditor();\n+      editingTarget.ensureTextEditorActive(() -> {\n+         getEditorContext(\n+            editingTarget.getId(),\n+            editingTarget.getPath(),\n+            editingTarget.getDocDisplay()\n+         );\n+      });\n+      return true;\n+   }\n+\n+\n+   public void activateCodeBrowser(\n+      final String codeBrowserPath,\n+      boolean replaceIfActive,\n+      final ResultCallback<CodeBrowserEditingTarget, ServerError> callback)\n+   {\n+      // first check to see if this request can be fulfilled with an existing\n+      // code browser tab\n+      EditingTarget target = selectTabWithDocPath(codeBrowserPath);\n+      if (target != null)\n+      {\n+         callback.onSuccess((CodeBrowserEditingTarget) target);\n+         return;\n+      }\n+\n+      // then check to see if the active editor is a code browser -- if it is,\n+      // we'll use it as is, replacing its contents\n+      if (replaceIfActive &&\n+          hasActiveEditor() &&\n+          activeColumn_.getActiveEditor() instanceof CodeBrowserEditingTarget)\n+      {\n+         events_.fireEvent(new CodeBrowserCreatedEvent(activeColumn_.getActiveEditor().getId(),\n+            codeBrowserPath));\n+         callback.onSuccess((CodeBrowserEditingTarget) activeColumn_.getActiveEditor());\n+         return;\n+      }\n+\n+      // create a new one\n+      newDoc(FileTypeRegistry.CODEBROWSER,\n+         new ResultCallback<EditingTarget, ServerError>()\n+         {\n+            @Override\n+            public void onSuccess(EditingTarget arg)\n+            {\n+               events_.fireEvent(new CodeBrowserCreatedEvent(\n+                  arg.getId(), codeBrowserPath));\n+               callback.onSuccess((CodeBrowserEditingTarget) arg);\n+            }\n+\n+            @Override\n+            public void onFailure(ServerError error)\n+            {\n+               callback.onFailure(error);\n+            }\n+\n+            @Override\n+            public void onCancelled()\n+            {\n+               callback.onCancelled();\n+            }\n+\n+         });\n+   }\n+\n+   public void activateObjectExplorer(ObjectExplorerHandle handle)\n+   {\n+      columnList_.forEach((column) -> {\n+         for (EditingTarget target : column.getEditors())\n+         {\n+            // bail if this isn't an object explorer filetype\n+            FileType fileType = target.getFileType();\n+            if (!(fileType instanceof ObjectExplorerFileType))\n+               continue;\n+\n+            // check for identical titles\n+            if (handle.getTitle() == target.getTitle())\n+            {\n+               ((ObjectExplorerEditingTarget) target).update(handle);\n+               ensureVisible(false);\n+               column.selectTab(target.asWidget());\n+               return;\n+            }\n+         }\n+      });\n+\n+      ensureVisible(true);\n+      server_.newDocument(\n+         FileTypeRegistry.OBJECT_EXPLORER.getTypeId(),\n+         null,\n+         (JsObject) handle.cast(),\n+         new SimpleRequestCallback<SourceDocument>(\"Show Object Explorer\")\n+         {\n+            @Override\n+            public void onResponseReceived(SourceDocument response)\n+            {\n+               activeColumn_.addTab(response, Source.OPEN_INTERACTIVE);\n+            }\n+         });\n+   }\n+\n+   public void showOverflowPopout()\n+   {\n+      ensureVisible(false);\n+      activeColumn_.showOverflowPopout();\n+   }\n+\n+   public void showDataItem(DataItem data)\n+   {\n+      columnList_.forEach((column) -> {\n+         for (EditingTarget target : column.getEditors())\n+         {\n+            String path = target.getPath();\n+            if (path != null && path.equals(data.getURI()))\n+            {\n+               ((DataEditingTarget) target).updateData(data);\n+\n+               ensureVisible(false);\n+               column.selectTab(target.asWidget());\n+               return;\n+            }\n+         }\n+      });\n+\n+      ensureVisible(true);\n+      server_.newDocument(\n+         FileTypeRegistry.DATAFRAME.getTypeId(),\n+         null,\n+         (JsObject) data.cast(),\n+         new SimpleRequestCallback<SourceDocument>(\"Show Data Frame\")\n+         {\n+            @Override\n+            public void onResponseReceived(SourceDocument response)\n+            {\n+               activeColumn_.addTab(response, Source.OPEN_INTERACTIVE);\n+            }\n+         });\n+   }\n+\n+   public void showUnsavedChangesDialog(\n+      String title,\n+      ArrayList<UnsavedChangesTarget> dirtyTargets,\n+      OperationWithInput<UnsavedChangesDialog.Result> saveOperation,\n+      Command onCancelled)\n+   {\n+      activeColumn_.showUnsavedChangesDialog(title, dirtyTargets, saveOperation, onCancelled);\n+   }\n+\n+   public boolean insertSource(String code, boolean isBlock)\n+   {\n+      if (!hasActiveEditor())\n+         return false;\n+      return activeColumn_.insertCode(code, isBlock);\n+   }\n+\n+   @Handler\n+   public void onMoveTabRight()\n+   {\n+      activeColumn_.moveTab(activeColumn_.getPhysicalTabIndex(), 1);\n+   }\n+\n+   @Handler\n+   public void onMoveTabLeft()\n+   {\n+      activeColumn_.moveTab(activeColumn_.getPhysicalTabIndex(), -1);\n+   }\n+\n+   @Handler\n+   public void onMoveTabToFirst()\n+   {\n+      activeColumn_.moveTab(activeColumn_.getPhysicalTabIndex(),\n+         activeColumn_.getPhysicalTabIndex() * -1);\n+   }\n+\n+   @Handler\n+   public void onMoveTabToLast()\n+   {\n+      activeColumn_.moveTab(activeColumn_.getPhysicalTabIndex(),\n+         (activeColumn_.getTabCount() -\n+            activeColumn_.getPhysicalTabIndex()) - 1);\n+   }\n+\n+   @Handler\n+   public void onSwitchToTab()\n+   {\n+      if (activeColumn_.getTabCount() == 0)\n+         return;\n+      showOverflowPopout();\n+   }\n+\n+   @Handler\n+   public void onFirstTab()\n+   {\n+      if (activeColumn_.getTabCount() == 0)\n+         return;\n+\n+      ensureVisible(false);\n+      if (activeColumn_.getTabCount() > 0)\n+         activeColumn_.setPhysicalTabIndex(0);\n+   }\n+\n+   @Handler\n+   public void onPreviousTab()\n+   {\n+      switchToTab(-1, userPrefs_.wrapTabNavigation().getValue());\n+   }\n+\n+   @Handler\n+   public void onNextTab()\n+   {\n+      switchToTab(1, userPrefs_.wrapTabNavigation().getValue());\n+   }\n+\n+   @Handler\n+   public void onLastTab()\n+   {\n+      if (activeColumn_.getTabCount() == 0)\n+         return;\n+\n+      activeColumn_.ensureVisible(false);\n+      if (activeColumn_.getTabCount() > 0)\n+         activeColumn_.setPhysicalTabIndex(activeColumn_.getTabCount() - 1);\n+   }\n+\n+   @Handler\n+   public void onCloseSourceDoc()\n+   {\n+      closeSourceDoc(true);\n+   }\n+\n+   @Handler\n+   public void onFindInFiles()\n+   {\n+      String searchPattern = \"\";\n+      if (hasActiveEditor() && activeColumn_.getActiveEditor() instanceof TextEditingTarget)\n+      {\n+         TextEditingTarget textEditor = (TextEditingTarget) activeColumn_.getActiveEditor();\n+         String selection = textEditor.getSelectedText();\n+         boolean multiLineSelection = selection.indexOf('\\n') != -1;\n+\n+         if ((selection.length() != 0) && !multiLineSelection)\n+            searchPattern = selection;\n+      }\n+\n+      events_.fireEvent(new FindInFilesEvent(searchPattern));\n+   }\n+\n+   @Override\n+   public void onDebugModeChanged(DebugModeChangedEvent evt)\n+   {\n+      // when debugging ends, always disengage any active debug highlights\n+      if (!evt.debugging() && hasActiveEditor())\n+      {\n+         activeColumn_.getActiveEditor().endDebugHighlighting();\n+      }\n+   }\n+\n+   @Override\n+   public void onSessionInit(SessionInitEvent event)\n+   {\n+      new JSObjectStateValue(\n+         \"source-column-manager\",\n+         \"column-info\",\n+         ClientState.PROJECT_PERSISTENT,\n+         session_.getSessionInfo().getClientState(),\n+         false)\n+      {\n+         @Override\n+         protected void onInit(JsObject value)\n+         {\n+            if (value == null)\n+            {\n+               columnState_ = State.createState(JsUtil.toJsArrayString(getNames(false)));\n+               return;\n+            }\n+            columnState_ = value.cast();\n+            ArrayList<String> names = getNames(false);\n+            for (int i = 0;\n+                 i < columnState_.getNames().length && getSize()< columnState_.getNames().length;\n+                 i++)\n+            {\n+               String name = columnState_.getNames()[i];\n+               if (getByName(name) == null)\n+                  add(name, false);\n+               else\n+                  names.remove(name);\n+            }\n+         }\n+\n+         @Override\n+         protected JsObject getValue()\n+         {\n+            if (columnState_ != null)\n+               return columnState_.cast();\n+\n+            columnState_ = State.createState(JsUtil.toJsArrayString(getNames(false)));\n+            JsObject object = columnState_.<JsObject>cast().clone();\n+            return object;\n+         }\n+      };\n+   }\n+\n+   @Override\n+   public void onSourceExtendedTypeDetected(SourceExtendedTypeDetectedEvent e)\n+   {\n+      // set the extended type of the specified source file\n+\n+      EditingTarget target = findEditor(e.getDocId());\n+      if (target != null)\n+         target.adaptToExtendedFileType(e.getExtendedType());\n+   }\n+\n+   public void nextTabWithWrap()\n+   {\n+      switchToTab(1, true);\n+   }\n+\n+   public void prevTabWithWrap()\n+   {\n+      switchToTab(-1, true);\n+   }\n+\n+   private void switchToTab(int delta, boolean wrap)\n+   {\n+      if (getActive().getTabCount() == 0)\n+         return;\n+\n+      activeColumn_.ensureVisible(false);\n+\n+      int targetIndex = activeColumn_.getPhysicalTabIndex() + delta;\n+      if (targetIndex > (activeColumn_.getTabCount() - 1))\n+      {\n+         if (wrap)\n+            targetIndex = 0;\n+         else\n+            return;\n+      } else if (targetIndex < 0)\n+      {\n+         if (wrap)\n+            targetIndex = activeColumn_.getTabCount() - 1;\n+         else\n+            return;\n+      }\n+      activeColumn_.setPhysicalTabIndex(targetIndex);\n+   }\n+\n+   private void doActivateSource(final Command afterActivation)\n+   {\n+      activeColumn_.ensureVisible(false);\n+      if (hasActiveEditor())\n+      {\n+         activeColumn_.getActiveEditor().focus();\n+         activeColumn_.getActiveEditor().ensureCursorVisible();\n+      }\n+\n+      if (afterActivation != null)\n+         afterActivation.execute();\n+   }\n+\n+   // new doc functions\n+\n+   public void newRMarkdownV1Doc()\n+   {\n+      newSourceDocWithTemplate(FileTypeRegistry.RMARKDOWN,\n+         \"\",\n+         \"v1.Rmd\",\n+         Position.create(3, 0));\n+   }\n+\n+   public void newRMarkdownV2Doc()\n+   {\n+      rmarkdown_.showNewRMarkdownDialog(\n+         new OperationWithInput<NewRMarkdownDialog.Result>()\n+         {\n+            @Override\n+            public void execute(final NewRMarkdownDialog.Result result)\n+            {\n+               if (result == null)\n+               {\n+                  // No document chosen, just create an empty one\n+                  newSourceDocWithTemplate(FileTypeRegistry.RMARKDOWN, \"\", \"default.Rmd\");\n+               } else if (result.isNewDocument())\n+               {\n+                  NewRMarkdownDialog.RmdNewDocument doc =\n+                     result.getNewDocument();\n+                  String author = doc.getAuthor();\n+                  if (author.length() > 0)\n+                  {\n+                     userPrefs_.documentAuthor().setGlobalValue(author);\n+                     userPrefs_.writeUserPrefs();\n+                  }\n+                  newRMarkdownV2Doc(doc);\n+               } else\n+               {\n+                  newDocFromRmdTemplate(result);\n+               }\n+            }\n+         });\n+   }\n+\n+   private void newDocFromRmdTemplate(final NewRMarkdownDialog.Result result)\n+   {\n+      final RmdChosenTemplate template = result.getFromTemplate();\n+      if (template.createDir())\n+      {\n+         rmarkdown_.createDraftFromTemplate(template);\n+         return;\n+      }\n+\n+      rmarkdown_.getTemplateContent(template,\n+         new OperationWithInput<String>()\n+         {\n+            @Override\n+            public void execute(final String content)\n+            {\n+               if (content.length() == 0)\n+                  globalDisplay_.showErrorMessage(\"Template Content Missing\",\n+                     \"The template at \" + template.getTemplatePath() +\n+                        \" is missing.\");\n+               newDoc(FileTypeRegistry.RMARKDOWN, content, null);\n+            }\n+         });\n+   }\n+\n+\n+   private void newRMarkdownV2Doc(\n+      final NewRMarkdownDialog.RmdNewDocument doc)\n+   {\n+      rmarkdown_.frontMatterToYAML((RmdFrontMatter) doc.getJSOResult().cast(),\n+         null,\n+         new CommandWithArg<String>()\n+         {\n+            @Override\n+            public void execute(final String yaml)\n+            {\n+               String template = \"\";\n+               // select a template appropriate to the document type we're creating\n+               if (doc.getTemplate().equals(RmdTemplateData.PRESENTATION_TEMPLATE))\n+                  template = \"presentation.Rmd\";\n+               else if (doc.isShiny())\n+               {\n+                  if (doc.getFormat().endsWith(\n+                     RmdOutputFormat.OUTPUT_PRESENTATION_SUFFIX))\n+                     template = \"shiny_presentation.Rmd\";\n+                  else\n+                     template = \"shiny.Rmd\";\n+               } else\n+                  template = \"document.Rmd\";\n+               newSourceDocWithTemplate(FileTypeRegistry.RMARKDOWN,\n+                  \"\",\n+                  template,\n+                  Position.create(1, 0),\n+                  null,\n+                  new TransformerCommand<String>()\n+                  {\n+                     @Override\n+                     public String transform(String input)\n+                     {\n+                        return RmdFrontMatter.FRONTMATTER_SEPARATOR +\n+                           yaml +\n+                           RmdFrontMatter.FRONTMATTER_SEPARATOR + \"\\n\" +\n+                           input;\n+                     }\n+                  });\n+            }\n+         });\n+   }\n+\n+   public void newSourceDocWithTemplate(final TextFileType fileType,\n+                                        String name,\n+                                        String template)\n+   {\n+      newSourceDocWithTemplate(fileType, name, template, null);\n+   }\n+\n+   public void newSourceDocWithTemplate(final TextFileType fileType,\n+                                        String name,\n+                                        String template,\n+                                        final Position cursorPosition)\n+   {\n+      newSourceDocWithTemplate(fileType, name, template, cursorPosition, null);\n+   }\n+\n+   public void newSourceDocWithTemplate(\n+      final TextFileType fileType,\n+      String name,\n+      String template,\n+      final Position cursorPosition,\n+      final CommandWithArg<EditingTarget> onSuccess)\n+   {\n+      newSourceDocWithTemplate(fileType, name, template, cursorPosition, onSuccess, null);\n+   }\n+\n+   public void startDebug()\n+   {\n+      activeColumn_.setPendingDebugSelection();\n+   }\n+\n+   private EditingTarget selectTabWithDocPath(String path)\n+   {\n+      for (SourceColumn column : columnList_)\n+      {\n+         EditingTarget editor = column.getEditorWithPath(path);\n+         if (editor != null)\n+         {\n+            column.selectTab(editor.asWidget());\n+            return editor;\n+         }\n+      }\n+      return null;\n+   }\n+\n+   private void newSourceDocWithTemplate(\n+      final TextFileType fileType,\n+      String name,\n+      String template,\n+      final Position cursorPosition,\n+      final CommandWithArg<EditingTarget> onSuccess,\n+      final TransformerCommand<String> contentTransformer)\n+   {\n+      final ProgressIndicator indicator = new GlobalProgressDelayer(\n+         globalDisplay_, 500, \"Creating new document...\").getIndicator();\n+\n+      server_.getSourceTemplate(name,\n+         template,\n+         new ServerRequestCallback<String>()\n+         {\n+            @Override\n+            public void onResponseReceived(String templateContents)\n+            {\n+               indicator.onCompleted();\n+\n+               if (contentTransformer != null)\n+                  templateContents = contentTransformer.transform(templateContents);\n+\n+               newDoc(fileType,\n+                  templateContents,\n+                  new ResultCallback<EditingTarget, ServerError>()\n+                  {\n+                     @Override\n+                     public void onSuccess(EditingTarget target)\n+                     {\n+                        if (cursorPosition != null)\n+                           target.setCursorPosition(cursorPosition);\n+\n+                        if (onSuccess != null)\n+                           onSuccess.execute(target);\n+                     }\n+                  });\n+            }\n+\n+            @Override\n+            public void onError(ServerError error)\n+            {\n+               indicator.onError(error.getUserMessage());\n+            }\n+         });\n+   }\n+\n+   public void newDoc(EditableFileType fileType,\n+                      ResultCallback<EditingTarget, ServerError> callback)\n+   {\n+      getActive().newDoc(fileType, callback);\n+   }\n+\n+   public void newDoc(EditableFileType fileType,\n+                      final String contents,\n+                      final ResultCallback<EditingTarget, ServerError> resultCallback)\n+   {\n+      getActive().newDoc(fileType, contents, resultCallback);\n+   }\n+\n+   public void disownDoc(String docId)\n+   {\n+      SourceColumn column = findByDocument(docId);\n+      column.closeDoc(docId);\n+   }\n+\n+   // When dragging between columns/windows, we need to be specific about which column we're\n+   // removing the document from as it may exist in more than one column. If the column is null,\n+   // it is assumed that we are a satellite window and do now have multiple displays.\n+   public void disownDocOnDrag(String docId, SourceColumn column)\n+   {\n+      if (column == null)\n+      {\n+         if (getSize() > 1)\n+            Debug.logWarning(\"Warning: No column was provided to remove the doc from.\");\n+         column = getActive();\n+      }\n+      column.closeDoc(docId);\n+      column.cancelTabDrag();\n+   }\n+\n+   public void selectTab(EditingTarget target)\n+   {\n+      SourceColumn column = findByDocument(target.getId());\n+      column.ensureVisible(false);\n+      column.selectTab(target.asWidget());\n+   }\n+\n+   public void closeTabs(JsArrayString ids)\n+   {\n+      if (ids != null)\n+         columnList_.forEach((column) -> column.closeTabs(ids));\n+   }\n+\n+   public void closeTabWithPath(String path, boolean interactive)\n+   {\n+      EditingTarget target = findEditorByPath(path);\n+      closeTab(target, interactive);\n+   }\n+\n+   public void closeTab(boolean interactive)\n+   {\n+      closeTab(activeColumn_.getActiveEditor(), interactive);\n+   }\n+\n+   public void closeTab(EditingTarget target, boolean interactive)\n+   {\n+      findByDocument(target.getId()).closeTab(target.asWidget(), interactive, null);\n+   }\n+\n+   public void closeTab(EditingTarget target, boolean interactive, Command onClosed)\n+   {\n+      findByDocument(target.getId()).closeTab(\n+         target.asWidget(), interactive, onClosed);\n+   }\n+\n+   public void closeAllTabs(boolean excludeActive, boolean excludeMain)\n+   {\n+      columnList_.forEach((column) -> {\n+         if (!excludeMain || !StringUtil.equals(column.getName(), MAIN_SOURCE_NAME))\n+         {\n+            cpsExecuteForEachEditor(column.getEditors(),\n+               new CPSEditingTargetCommand()\n+               {\n+                  @Override\n+                  public void execute(EditingTarget target, Command continuation)\n+                  {\n+                     if (excludeActive && target == activeColumn_.getActiveEditor())\n+                     {\n+                        continuation.execute();\n+                        return;\n+                     } else\n+                     {\n+                        column.closeTab(target.asWidget(), false, continuation);\n+                     }\n+                  }\n+               });\n+         }\n+      });\n+   }\n+\n+   void closeSourceDoc(boolean interactive)\n+   {\n+      if (activeColumn_.getTabCount() == 0)\n+         return;\n+\n+      closeTab(interactive);\n+   }\n+\n+   public void saveAllSourceDocs()\n+   {\n+      columnList_.forEach((column) -> cpsExecuteForEachEditor(\n+          column.getEditors(),\n+          (editingTarget, continuation) -> {\n+             if (editingTarget.dirtyState().getValue())\n+             {\n+                editingTarget.save(continuation);\n+             } else\n+             {\n+                continuation.execute();\n+             }\n+          }));\n+   }\n+\n+   public void revertUnsavedTargets(Command onCompleted)\n+   {\n+      ArrayList<EditingTarget> unsavedTargets = new ArrayList<>();\n+      columnList_.forEach((column) -> unsavedTargets.addAll(\n+          column.getUnsavedEditors(Source.TYPE_FILE_BACKED, null)));\n+\n+      // revert all of them\n+      cpsExecuteForEachEditor(\n+\n+         // targets the user chose not to save\n+         unsavedTargets,\n+\n+         // save each editor\n+          (saveTarget, continuation) -> {\n+             if (saveTarget.getPath() != null)\n+             {\n+                // file backed document -- revert it\n+                saveTarget.revertChanges(continuation);\n+             } else\n+             {\n+                // untitled document -- just close the tab non-interactively\n+                closeTab(saveTarget, false, continuation);\n+             }\n+          },\n+\n+         // onCompleted at the end\n+         onCompleted\n+      );\n+   }\n+\n+   public void closeAllLocalSourceDocs(String caption,\n+                                       Command onCompleted,\n+                                       final boolean excludeActive)\n+   {\n+      // save active editor for exclusion (it changes as we close tabs)\n+      final EditingTarget excludeEditor = (excludeActive) ? activeColumn_.getActiveEditor() :\n+         null;\n+\n+      // collect up a list of dirty documents\n+      ArrayList<EditingTarget> dirtyTargets = new ArrayList<>();\n+      columnList_.forEach((column) ->\n+          dirtyTargets.addAll(column.getDirtyEditors(excludeEditor)));\n+\n+      // create a command used to close all tabs\n+      final Command closeAllTabsCommand = () -> closeAllTabs(excludeActive, false);\n+\n+      saveEditingTargetsWithPrompt(caption,\n+         dirtyTargets,\n+         CommandUtil.join(closeAllTabsCommand,\n+            onCompleted),\n+         null);\n+   }\n+\n+   public ArrayList<Widget> consolidateColumns(int num)\n+   {\n+      // We are only removing the column from the column manager's knowledge.\n+      // Its widget still needs to be removed from the display so we return the widgets to be removed.\n+      ArrayList<Widget> result = new ArrayList<>();\n+      if (num >= columnList_.size() || num < 1)\n+         return result;\n+\n+      for (SourceColumn column : columnList_)\n+      {\n+         if (!column.hasDoc())\n+         {\n+            if (column == activeColumn_)\n+               setActive(\"\");\n+            result.add(column.asWidget());\n+            columnList_.remove(column);\n+            if (num >= columnList_.size() || num == 1)\n+               break;\n+         }\n+      }\n+\n+      ArrayList<EditingTarget> moveEditors = new ArrayList<>();\n+      // if we could not remove empty columns to get to the desired amount, consolidate editors\n+      for (SourceColumn column : columnList_)\n+      {\n+         if (!StringUtil.equals(column.getName(), MAIN_SOURCE_NAME))\n+         {\n+            moveEditors.addAll(column.getEditors());\n+            column.closeAllLocalSourceDocs();\n+            closeColumn(column.getName());\n+            if (columnList_.size() >= num || num == 1)\n+               break;\n+         }\n+      }\n+\n+      SourceColumn column = getByName(MAIN_SOURCE_NAME);\n+      assert(column != null);\n+      for (EditingTarget target : moveEditors)\n+      {\n+         column.addTab(\n+            target.asWidget(),\n+            target.getIcon(),\n+            target.getId(),\n+            target.getName().getValue(),\n+            target.getTabTooltip(), // used as tooltip, if non-null\n+            null,\n+            true);\n+      }\n+\n+      return result;\n+   }\n+\n+   public void closeAllColumns()\n+   {\n+      columnList_.forEach((column) -> closeColumn(column.getName()));\n+      Debug.logToConsole(\"closed all columns, new size: \" + getSize());\n+      assert getSize() == 0;\n+   }\n+\n+   public void closeColumn(String name)\n+   {\n+      SourceColumn column = getByName(name);\n+      if (column.getTabCount() > 0)\n+         return;\n+      if (column == activeColumn_)\n+         setActive(\"\");\n+\n+      columnList_.remove(getByName(name));\n+   }\n+\n+   public void ensureVisible(boolean newTabPending)\n+   {\n+      activeColumn_.ensureVisible(newTabPending);\n+   }\n+\n+   public void openFile(FileSystemItem file)\n+   {\n+      openFile(file, fileTypeRegistry_.getTextTypeForFile(file));\n+   }\n+\n+   public void openFile(FileSystemItem file, TextFileType fileType)\n+   {\n+      openFile(file,\n+         fileType,\n+         new CommandWithArg<EditingTarget>()\n+         {\n+            @Override\n+            public void execute(EditingTarget arg)\n+            {\n+\n+            }\n+         });\n+   }\n+\n+   public void openFile(final FileSystemItem file,\n+                        final TextFileType fileType,\n+                        final CommandWithArg<EditingTarget> executeOnSuccess)\n+   {\n+      // add this work to the queue\n+      openFileQueue_.add(new OpenFileEntry(file, fileType, executeOnSuccess));\n+\n+      // begin queue processing if it's the only work in the queue\n+      if (openFileQueue_.size() == 1)\n+         processOpenFileQueue();\n+   }\n+\n+   private void editFile(final String path)\n+   {\n+      server_.ensureFileExists(\n+         path,\n+         new ServerRequestCallback<Boolean>()\n+         {\n+            @Override\n+            public void onResponseReceived(Boolean success)\n+            {\n+               if (success)\n+               {\n+                  FileSystemItem file = FileSystemItem.createFile(path);\n+                  openFile(file);\n+               }\n+            }\n+\n+            @Override\n+            public void onError(ServerError error)\n+            {\n+               Debug.logError(error);\n+            }\n+         });\n+   }\n+\n+   public void openProjectDocs(final Session session, boolean mainColumn)\n+   {\n+      if (mainColumn && activeColumn_ != getByName(MAIN_SOURCE_NAME))\n+         setActive(MAIN_SOURCE_NAME);\n+\n+      JsArrayString openDocs = session.getSessionInfo().getProjectOpenDocs();\n+      if (openDocs.length() > 0)\n+      {\n+         // set new tab pending for the duration of the continuation\n+         activeColumn_.incrementNewTabPending();\n+\n+         // create a continuation for opening the source docs\n+         SerializedCommandQueue openCommands = new SerializedCommandQueue();\n+\n+         for (int i = 0; i < openDocs.length(); i++)\n+         {\n+            String doc = openDocs.get(i);\n+            final FileSystemItem fsi = FileSystemItem.createFile(doc);\n+\n+            openCommands.addCommand(new SerializedCommand()\n+            {\n+\n+               @Override\n+               public void onExecute(final Command continuation)\n+               {\n+                  openFile(fsi,\n+                     fileTypeRegistry_.getTextTypeForFile(fsi),\n+                     new CommandWithArg<EditingTarget>()\n+                     {\n+                        @Override\n+                        public void execute(EditingTarget arg)\n+                        {\n+                           continuation.execute();\n+                        }\n+                     });\n+               }\n+            });\n+         }\n+\n+         // decrement newTabPending and select first tab when done\n+         openCommands.addCommand(new SerializedCommand()\n+         {\n+\n+            @Override\n+            public void onExecute(Command continuation)\n+            {\n+               activeColumn_.decrementNewTabPending();\n+               onFirstTab();\n+               continuation.execute();\n+            }\n+         });\n+\n+         // execute the continuation\n+         openCommands.run();\n+      }\n+   }\n+\n+   public void fireDocTabsChanged()\n+   {\n+      activeColumn_.fireDocTabsChanged();\n+   }\n+\n+   private boolean hasDoc()\n+   {\n+      for (SourceColumn column : columnList_)\n+      {\n+         if (column.hasDoc())\n+            return true;\n+      }\n+      return false;\n+   }\n+\n+   private void vimSetTabIndex(int index)\n+   {\n+      int tabCount = activeColumn_.getTabCount();\n+      if (index >= tabCount)\n+         return;\n+      activeColumn_.setPhysicalTabIndex(index);\n+   }\n+\n+   private void processOpenFileQueue()\n+   {\n+      // no work to do\n+      if (openFileQueue_.isEmpty())\n+         return;\n+\n+      // find the first work unit\n+      final OpenFileEntry entry = openFileQueue_.peek();\n+\n+      // define command to advance queue\n+      final Command processNextEntry = new Command()\n+      {\n+         @Override\n+         public void execute()\n+         {\n+            openFileQueue_.remove();\n+            if (!openFileQueue_.isEmpty())\n+               processOpenFileQueue();\n+\n+         }\n+      };\n+      openFile(\n+         entry.file,\n+         entry.fileType,\n+         new ResultCallback<EditingTarget, ServerError>()\n+         {\n+            @Override\n+            public void onSuccess(EditingTarget target)\n+            {\n+               processNextEntry.execute();\n+               if (entry.executeOnSuccess != null)\n+                  entry.executeOnSuccess.execute(target);\n+            }\n+\n+            @Override\n+            public void onCancelled()\n+            {\n+               super.onCancelled();\n+               processNextEntry.execute();\n+            }\n+\n+            @Override\n+            public void onFailure(ServerError error)\n+            {\n+               String message = error.getUserMessage();\n+\n+               // see if a special message was provided\n+               JSONValue errValue = error.getClientInfo();\n+               if (errValue != null)\n+               {\n+                  JSONString errMsg = errValue.isString();\n+                  if (errMsg != null)\n+                     message = errMsg.stringValue();\n+               }\n+\n+               globalDisplay_.showMessage(GlobalDisplay.MSG_ERROR,\n+                  \"Error while opening file\",\n+                  message);\n+\n+               processNextEntry.execute();\n+            }\n+         });\n+   }\n+\n+   // top-level wrapper for opening files. takes care of:\n+   //  - making sure the view is visible\n+   //  - checking whether it is already open and re-selecting its tab\n+   //  - prohibit opening very large files (>500KB)\n+   //  - confirmation of opening large files (>100KB)\n+   //  - finally, actually opening the file from the server\n+   //    via the call to the lower level openFile method\n+   public void openFile(final FileSystemItem file,\n+                        final TextFileType fileType,\n+                        final ResultCallback<EditingTarget, ServerError> resultCallback)\n+   {\n+      activeColumn_.ensureVisible(true);\n+\n+      if (fileType.isRNotebook())\n+      {\n+         openNotebook(file, fileType, resultCallback);\n+         return;\n+      }\n+\n+      if (file == null)\n+      {\n+         newDoc(fileType, resultCallback);\n+         return;\n+      }\n+\n+      if (openFileAlreadyOpen(file, resultCallback))\n+         return;\n+\n+      EditingTarget target = editingTargetSource_.getEditingTarget(fileType);\n+\n+      if (file.getLength() > target.getFileSizeLimit())\n+      {\n+         if (resultCallback != null)\n+            resultCallback.onCancelled();\n+         showFileTooLargeWarning(file, target.getFileSizeLimit());\n+      } else if (file.getLength() > target.getLargeFileSize())\n+      {\n+         confirmOpenLargeFile(file, new Operation()\n+         {\n+            public void execute()\n+            {\n+               openFileFromServer(file, fileType, resultCallback);\n+            }\n+         }, new Operation()\n+         {\n+            public void execute()\n+            {\n+               // user (wisely) cancelled\n+               if (resultCallback != null)\n+                  resultCallback.onCancelled();\n+            }\n+         });\n+      } else\n+      {\n+         openFileFromServer(file, fileType, resultCallback);\n+      }\n+   }\n+\n+   public void openNotebook(\n+      final FileSystemItem rmdFile,\n+      final SourceDocumentResult doc,\n+      final ResultCallback<EditingTarget, ServerError> resultCallback)\n+   {\n+      if (!StringUtil.isNullOrEmpty(doc.getDocPath()))\n+      {\n+         // this happens if we created the R Markdown file, or if the R Markdown\n+         // file on disk matched the one inside the notebook\n+         openFileFromServer(rmdFile,\n+            FileTypeRegistry.RMARKDOWN, resultCallback);\n+      } else if (!StringUtil.isNullOrEmpty(doc.getDocId()))\n+      {\n+         // this happens when we have to open an untitled buffer for the the\n+         // notebook (usually because the of a conflict between the Rmd on disk\n+         // and the one in the .nb.html file)\n+         server_.getSourceDocument(doc.getDocId(),\n+            new ServerRequestCallback<SourceDocument>()\n+            {\n+               @Override\n+               public void onResponseReceived(SourceDocument doc)\n+               {\n+                  // create the editor\n+                  EditingTarget target = getActive().addTab(doc, Source.OPEN_INTERACTIVE);\n+\n+                  // show a warning bar\n+                  if (target instanceof TextEditingTarget)\n+                  {\n+                     ((TextEditingTarget) target).showWarningMessage(\n+                        \"This notebook has the same name as an R Markdown \" +\n+                           \"file, but doesn't match it.\");\n+                  }\n+                  resultCallback.onSuccess(target);\n+               }\n+\n+               @Override\n+               public void onError(ServerError error)\n+               {\n+                  globalDisplay_.showErrorMessage(\n+                     \"Notebook Open Failed\",\n+                     \"This notebook could not be opened. \" +\n+                        \"If the error persists, try removing the \" +\n+                        \"accompanying R Markdown file. \\n\\n\" +\n+                        error.getMessage());\n+                  resultCallback.onFailure(error);\n+               }\n+            });\n+      }\n+   }\n+\n+   public void beforeShow()\n+   {\n+      columnList_.forEach((column) -> column.onBeforeShow());\n+   }\n+\n+   public void beforeShow(String name)\n+   {\n+      SourceColumn column = getByName(name);\n+      if (column == null)\n+      {\n+         Debug.logWarning(\"WARNING: Unknown column \" + name);\n+         return;\n+      }\n+      column.onBeforeShow();\n+   }\n+\n+   public void inEditorForId(String id, OperationWithInput<EditingTarget> onEditorLocated)\n+   {\n+      EditingTarget editor = findEditor(id);\n+      if (editor != null)\n+         onEditorLocated.execute(editor);\n+   }\n+\n+   public void inEditorForPath(String path, OperationWithInput<EditingTarget> onEditorLocated)\n+   {\n+      EditingTarget editor = findEditorByPath(path);\n+      if (editor != null)\n+         onEditorLocated.execute(editor);\n+   }\n+\n+   public void withTarget(String id, CommandWithArg<TextEditingTarget> command)\n+   {\n+      withTarget(id, command, null);\n+   }\n+\n+   public void withTarget(String id,\n+                          CommandWithArg<TextEditingTarget> command,\n+                          Command onFailure)\n+   {\n+      EditingTarget target = StringUtil.isNullOrEmpty(id)\n+         ? activeColumn_.getActiveEditor()\n+         : findEditor(id);\n+\n+      if (target == null)\n+      {\n+         if (onFailure != null)\n+            onFailure.execute();\n+         return;\n+      }\n+\n+      if (!(target instanceof TextEditingTarget))\n+      {\n+         if (onFailure != null)\n+            onFailure.execute();\n+         return;\n+      }\n+\n+      command.execute((TextEditingTarget) target);\n+   }\n+\n+   public HashSet<AppCommand> getDynamicCommands()\n+   {\n+      return dynamicCommands_;\n+   }\n+\n+   private void getEditorContext(String id, String path, DocDisplay docDisplay)\n+   {\n+      getEditorContext(id, path, docDisplay, server_);\n+   }\n+\n+   public static void getEditorContext(String id, String path, DocDisplay docDisplay,\n+                                       SourceServerOperations server)\n+   {\n+      AceEditor editor = (AceEditor) docDisplay;\n+      Selection selection = editor.getNativeSelection();\n+      Range[] ranges = selection.getAllRanges();\n+\n+      // clamp ranges to document boundaries\n+      for (Range range : ranges)\n+      {\n+         Position start = range.getStart();\n+         start.setRow(MathUtil.clamp(start.getRow(), 0, editor.getRowCount()));\n+         start.setColumn(MathUtil.clamp(start.getColumn(), 0, editor.getLine(start.getRow()).length()));\n+\n+         Position end = range.getEnd();\n+         end.setRow(MathUtil.clamp(end.getRow(), 0, editor.getRowCount()));\n+         end.setColumn(MathUtil.clamp(end.getColumn(), 0, editor.getLine(end.getRow()).length()));\n+      }\n+\n+      JsArray<GetEditorContextEvent.DocumentSelection> docSelections = JavaScriptObject.createArray().cast();\n+      for (Range range : ranges)\n+      {\n+         docSelections.push(GetEditorContextEvent.DocumentSelection.create(\n+            range,\n+            editor.getTextForRange(range)));\n+      }\n+\n+      id = StringUtil.notNull(id);\n+      path = StringUtil.notNull(path);\n+\n+      GetEditorContextEvent.SelectionData data =\n+         GetEditorContextEvent.SelectionData.create(id, path, editor.getCode(), docSelections);\n+\n+      server.getEditorContextCompleted(data, new VoidServerRequestCallback());\n+   }\n+\n+   private void initDynamicCommands()\n+   {\n+      dynamicCommands_ = new HashSet<AppCommand>();\n+      dynamicCommands_.add(commands_.saveSourceDoc());\n+      dynamicCommands_.add(commands_.reopenSourceDocWithEncoding());\n+      dynamicCommands_.add(commands_.saveSourceDocAs());\n+      dynamicCommands_.add(commands_.saveSourceDocWithEncoding());\n+      dynamicCommands_.add(commands_.printSourceDoc());\n+      dynamicCommands_.add(commands_.vcsFileLog());\n+      dynamicCommands_.add(commands_.vcsFileDiff());\n+      dynamicCommands_.add(commands_.vcsFileRevert());\n+      dynamicCommands_.add(commands_.executeCode());\n+      dynamicCommands_.add(commands_.executeCodeWithoutFocus());\n+      dynamicCommands_.add(commands_.executeAllCode());\n+      dynamicCommands_.add(commands_.executeToCurrentLine());\n+      dynamicCommands_.add(commands_.executeFromCurrentLine());\n+      dynamicCommands_.add(commands_.executeCurrentFunction());\n+      dynamicCommands_.add(commands_.executeCurrentSection());\n+      dynamicCommands_.add(commands_.executeLastCode());\n+      dynamicCommands_.add(commands_.insertChunk());\n+      dynamicCommands_.add(commands_.insertSection());\n+      dynamicCommands_.add(commands_.executeSetupChunk());\n+      dynamicCommands_.add(commands_.executePreviousChunks());\n+      dynamicCommands_.add(commands_.executeSubsequentChunks());\n+      dynamicCommands_.add(commands_.executeCurrentChunk());\n+      dynamicCommands_.add(commands_.executeNextChunk());\n+      dynamicCommands_.add(commands_.previewJS());\n+      dynamicCommands_.add(commands_.previewSql());\n+      dynamicCommands_.add(commands_.sourceActiveDocument());\n+      dynamicCommands_.add(commands_.sourceActiveDocumentWithEcho());\n+      dynamicCommands_.add(commands_.knitDocument());\n+      dynamicCommands_.add(commands_.toggleRmdVisualMode());\n+      dynamicCommands_.add(commands_.enableProsemirrorDevTools());\n+      dynamicCommands_.add(commands_.previewHTML());\n+      dynamicCommands_.add(commands_.compilePDF());\n+      dynamicCommands_.add(commands_.compileNotebook());\n+      dynamicCommands_.add(commands_.synctexSearch());\n+      dynamicCommands_.add(commands_.popoutDoc());\n+      dynamicCommands_.add(commands_.returnDocToMain());\n+      dynamicCommands_.add(commands_.findReplace());\n+      dynamicCommands_.add(commands_.findNext());\n+      dynamicCommands_.add(commands_.findPrevious());\n+      dynamicCommands_.add(commands_.findFromSelection());\n+      dynamicCommands_.add(commands_.replaceAndFind());\n+      dynamicCommands_.add(commands_.extractFunction());\n+      dynamicCommands_.add(commands_.extractLocalVariable());\n+      dynamicCommands_.add(commands_.commentUncomment());\n+      dynamicCommands_.add(commands_.reindent());\n+      dynamicCommands_.add(commands_.reflowComment());\n+      dynamicCommands_.add(commands_.jumpTo());\n+      dynamicCommands_.add(commands_.jumpToMatching());\n+      dynamicCommands_.add(commands_.goToHelp());\n+      dynamicCommands_.add(commands_.goToDefinition());\n+      dynamicCommands_.add(commands_.setWorkingDirToActiveDoc());\n+      dynamicCommands_.add(commands_.debugDumpContents());\n+      dynamicCommands_.add(commands_.debugImportDump());\n+      dynamicCommands_.add(commands_.goToLine());\n+      dynamicCommands_.add(commands_.checkSpelling());\n+      dynamicCommands_.add(commands_.wordCount());\n+      dynamicCommands_.add(commands_.codeCompletion());\n+      dynamicCommands_.add(commands_.findUsages());\n+      dynamicCommands_.add(commands_.debugBreakpoint());\n+      dynamicCommands_.add(commands_.vcsViewOnGitHub());\n+      dynamicCommands_.add(commands_.vcsBlameOnGitHub());\n+      dynamicCommands_.add(commands_.editRmdFormatOptions());\n+      dynamicCommands_.add(commands_.reformatCode());\n+      dynamicCommands_.add(commands_.showDiagnosticsActiveDocument());\n+      dynamicCommands_.add(commands_.renameInScope());\n+      dynamicCommands_.add(commands_.insertRoxygenSkeleton());\n+      dynamicCommands_.add(commands_.expandSelection());\n+      dynamicCommands_.add(commands_.shrinkSelection());\n+      dynamicCommands_.add(commands_.toggleDocumentOutline());\n+      dynamicCommands_.add(commands_.knitWithParameters());\n+      dynamicCommands_.add(commands_.clearKnitrCache());\n+      dynamicCommands_.add(commands_.goToNextSection());\n+      dynamicCommands_.add(commands_.goToPrevSection());\n+      dynamicCommands_.add(commands_.goToNextChunk());\n+      dynamicCommands_.add(commands_.goToPrevChunk());\n+      dynamicCommands_.add(commands_.profileCode());\n+      dynamicCommands_.add(commands_.profileCodeWithoutFocus());\n+      dynamicCommands_.add(commands_.saveProfileAs());\n+      dynamicCommands_.add(commands_.restartRClearOutput());\n+      dynamicCommands_.add(commands_.restartRRunAllChunks());\n+      dynamicCommands_.add(commands_.notebookCollapseAllOutput());\n+      dynamicCommands_.add(commands_.notebookExpandAllOutput());\n+      dynamicCommands_.add(commands_.notebookClearOutput());\n+      dynamicCommands_.add(commands_.notebookClearAllOutput());\n+      dynamicCommands_.add(commands_.notebookToggleExpansion());\n+      dynamicCommands_.add(commands_.sendToTerminal());\n+      dynamicCommands_.add(commands_.openNewTerminalAtEditorLocation());\n+      dynamicCommands_.add(commands_.sendFilenameToTerminal());\n+      dynamicCommands_.add(commands_.renameSourceDoc());\n+      dynamicCommands_.add(commands_.sourceAsLauncherJob());\n+      dynamicCommands_.add(commands_.sourceAsJob());\n+      dynamicCommands_.add(commands_.runSelectionAsJob());\n+      dynamicCommands_.add(commands_.runSelectionAsLauncherJob());\n+      dynamicCommands_.add(commands_.toggleSoftWrapMode());\n+      for (AppCommand command : dynamicCommands_)\n+      {\n+         command.setVisible(false);\n+         command.setEnabled(false);\n+      }\n+   }\n+\n+   public void initVimCommands()\n+   {\n+      vimCommands_.save(this);\n+      vimCommands_.selectTabIndex(this);\n+      vimCommands_.selectNextTab(this);\n+      vimCommands_.selectPreviousTab(this);\n+      vimCommands_.closeActiveTab(this);\n+      vimCommands_.closeAllTabs(this);\n+      vimCommands_.createNewDocument(this);\n+      vimCommands_.saveAndCloseActiveTab(this);\n+      vimCommands_.readFile(this, userPrefs_.defaultEncoding().getValue());\n+      vimCommands_.runRScript(this);\n+      vimCommands_.reflowText(this);\n+      vimCommands_.showVimHelp(\n+          RStudioGinjector.INSTANCE.getShortcutViewer());\n+      vimCommands_.showHelpAtCursor(this);\n+      vimCommands_.reindent(this);\n+      vimCommands_.expandShrinkSelection(this);\n+      vimCommands_.openNextFile(this);\n+      vimCommands_.openPreviousFile(this);\n+      vimCommands_.addStarRegister();\n+   }\n+\n+   private void openNotebook(final FileSystemItem rnbFile,\n+                             final TextFileType fileType,\n+                             final ResultCallback<EditingTarget, ServerError> resultCallback)\n+   {\n+      // construct path to .Rmd\n+      final String rnbPath = rnbFile.getPath();\n+      final String rmdPath = FilePathUtils.filePathSansExtension(rnbPath) + \".Rmd\";\n+      final FileSystemItem rmdFile = FileSystemItem.createFile(rmdPath);\n+\n+      // if we already have associated .Rmd file open, then just edit it\n+      // TODO: should we perform conflict resolution here as well?\n+      if (openFileAlreadyOpen(rmdFile, resultCallback))\n+         return;\n+\n+      // ask the server to extract the .Rmd, then open that\n+      Command extractRmdCommand = new Command()\n+      {\n+         @Override\n+         public void execute()\n+         {\n+            server_.extractRmdFromNotebook(\n+                  rnbPath,\n+                  new ServerRequestCallback<SourceDocumentResult>()\n+                  {\n+                     @Override\n+                     public void onResponseReceived(SourceDocumentResult doc)\n+                     {\n+                        openNotebook(rmdFile, doc, resultCallback);\n+                     }\n+\n+                     @Override\n+                     public void onError(ServerError error)\n+                     {\n+                        globalDisplay_.showErrorMessage(\"Notebook Open Failed\",\n+                              \"This notebook could not be opened. \\n\\n\" +\n+                              error.getMessage());\n+                        resultCallback.onFailure(error);\n+                     }\n+                  });\n+         }\n+      };\n+\n+      dependencyManager_.withRMarkdown(\"R Notebook\", \"Using R Notebooks\", extractRmdCommand);\n+   }\n+\n+   private void openFileFromServer(\n+         final FileSystemItem file,\n+         final TextFileType fileType,\n+         final ResultCallback<EditingTarget, ServerError> resultCallback)\n+   {\n+      final Command dismissProgress = globalDisplay_.showProgress(\n+                                                         \"Opening file...\");\n+\n+      server_.openDocument(\n+            file.getPath(),\n+            fileType.getTypeId(),\n+            userPrefs_.defaultEncoding().getValue(),\n+            new ServerRequestCallback<SourceDocument>()\n+            {\n+               @Override\n+               public void onError(ServerError error)\n+               {\n+                  dismissProgress.execute();\n+                  pMruList_.get().remove(file.getPath());\n+                  Debug.logError(error);\n+                  if (resultCallback != null)\n+                     resultCallback.onFailure(error);\n+               }\n+\n+               @Override\n+               public void onResponseReceived(SourceDocument document)\n+               {\n+                  // if we are opening for a source navigation then we\n+                  // need to force Rmds into source mode\n+                  if (openingForSourceNavigation_)\n+                  {\n+                     document.getProperties()._setBoolean(\n+                        TextEditingTarget.RMD_VISUAL_MODE,\n+                        false\n+                     );\n+                  }\n+\n+                  dismissProgress.execute();\n+                  pMruList_.get().add(document.getPath());\n+                  EditingTarget target = getActive().addTab(document, Source.OPEN_INTERACTIVE);\n+                  if (resultCallback != null)\n+                     resultCallback.onSuccess(target);\n+               }\n+            });\n+   }\n+\n+   private boolean openFileAlreadyOpen(final FileSystemItem file,\n+                                       final ResultCallback<EditingTarget, ServerError> resultCallback)\n+   {\n+      for (SourceColumn column : columnList_)\n+      {\n+         // check to see if any local editors have the file open\n+         for (int i = 0; i < column.getEditors().size(); i++)\n+         {\n+            EditingTarget target = column.getEditors().get(i);\n+            String thisPath = target.getPath();\n+            if (thisPath != null\n+                && thisPath.equalsIgnoreCase(file.getPath()))\n+            {\n+               column.selectTab(target.asWidget());\n+               pMruList_.get().add(thisPath);\n+               if (resultCallback != null)\n+                  resultCallback.onSuccess(target);\n+               return true;\n+            }\n+         }\n+      }\n+      return false;\n+   }\n+\n+   private void showFileTooLargeWarning(FileSystemItem file,\n+                                        long sizeLimit)\n+   {\n+      StringBuilder msg = new StringBuilder();\n+      msg.append(\"The file '\" + file.getName() + \"' is too \");\n+      msg.append(\"large to open in the source editor (the file is \");\n+      msg.append(StringUtil.formatFileSize(file.getLength()) + \" and the \");\n+      msg.append(\"maximum file size is \");\n+      msg.append(StringUtil.formatFileSize(sizeLimit) + \")\");\n+\n+      globalDisplay_.showMessage(GlobalDisplay.MSG_WARNING,\n+                                 \"Selected File Too Large\",\n+                                 msg.toString());\n+   }\n+\n+   private void confirmOpenLargeFile(FileSystemItem file,\n+                                     Operation openOperation,\n+                                     Operation noOperation)\n+   {\n+      StringBuilder msg = new StringBuilder();\n+      msg.append(\"The source file '\" + file.getName() + \"' is large (\");\n+      msg.append(StringUtil.formatFileSize(file.getLength()) + \") \");\n+      msg.append(\"and may take some time to open. \");\n+      msg.append(\"Are you sure you want to continue opening it?\");\n+      globalDisplay_.showYesNoMessage(GlobalDisplay.MSG_WARNING,\n+                                      \"Confirm Open\",\n+                                      msg.toString(),\n+                                      false, // Don't include cancel\n+                                      openOperation,\n+                                      noOperation,\n+                                      false);   // 'No' is default\n+   }\n+\n+   private void saveEditingTargetsWithPrompt(\n+      String title,\n+      ArrayList<EditingTarget> editingTargets,\n+      final Command onCompleted,\n+      final Command onCancelled)\n+   {\n+      // execute on completed right away if the list is empty\n+      if (editingTargets.size() ==  0)\n+      {\n+         onCompleted.execute();\n+      }\n+\n+      // if there is just one thing dirty then go straight to the save dialog\n+      else if (editingTargets.size() == 1)\n+      {\n+         editingTargets.get(0).saveWithPrompt(onCompleted, onCancelled);\n+      }\n+\n+      // otherwise use the multi save changes dialog\n+      else\n+      {\n+         // convert to UnsavedChangesTarget collection\n+         ArrayList<UnsavedChangesTarget> unsavedTargets =\n+            new ArrayList<UnsavedChangesTarget>();\n+         unsavedTargets.addAll(editingTargets);", "originalCommit": "b05e15e98d5dec936f440319aa15d74615743fc3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDk2Ng==", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438460966", "bodyText": "spelling: palette", "author": "gtritchie", "createdAt": "2020-06-10T23:27:09Z", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/SourceColumnManager.java", "diffHunk": "@@ -0,0 +1,2377 @@\n+/*\n+ * SourceColumnManager.java\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+package org.rstudio.studio.client.workbench.views.source;\n+\n+import com.google.gwt.core.client.GWT;\n+import com.google.gwt.core.client.JavaScriptObject;\n+import com.google.gwt.core.client.JsArray;\n+import com.google.gwt.core.client.JsArrayString;\n+import com.google.gwt.event.dom.client.ChangeEvent;\n+import com.google.gwt.event.dom.client.ChangeHandler;\n+import com.google.gwt.json.client.JSONString;\n+import com.google.gwt.json.client.JSONValue;\n+import com.google.gwt.user.client.Command;\n+import com.google.gwt.user.client.ui.Widget;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.Singleton;\n+import org.rstudio.core.client.*;\n+import org.rstudio.core.client.command.AppCommand;\n+import org.rstudio.core.client.command.Handler;\n+import org.rstudio.core.client.files.FileSystemItem;\n+import org.rstudio.core.client.js.JsObject;\n+import org.rstudio.core.client.js.JsUtil;\n+import org.rstudio.core.client.widget.Operation;\n+import org.rstudio.core.client.widget.OperationWithInput;\n+import org.rstudio.core.client.widget.ProgressIndicator;\n+import org.rstudio.studio.client.RStudioGinjector;\n+import org.rstudio.studio.client.application.events.EventBus;\n+import org.rstudio.studio.client.common.FilePathUtils;\n+import org.rstudio.studio.client.common.GlobalDisplay;\n+import org.rstudio.studio.client.common.GlobalProgressDelayer;\n+import org.rstudio.studio.client.common.SimpleRequestCallback;\n+import org.rstudio.studio.client.common.dependencies.DependencyManager;\n+import org.rstudio.studio.client.common.filetypes.*;\n+import org.rstudio.studio.client.common.synctex.Synctex;\n+import org.rstudio.studio.client.events.GetEditorContextEvent;\n+import org.rstudio.studio.client.palette.model.CommandPaletteEntrySource;\n+import org.rstudio.studio.client.palette.model.CommandPaletteItem;\n+import org.rstudio.studio.client.rmarkdown.model.RmdChosenTemplate;\n+import org.rstudio.studio.client.rmarkdown.model.RmdFrontMatter;\n+import org.rstudio.studio.client.rmarkdown.model.RmdOutputFormat;\n+import org.rstudio.studio.client.rmarkdown.model.RmdTemplateData;\n+import org.rstudio.studio.client.server.ServerError;\n+import org.rstudio.studio.client.server.ServerRequestCallback;\n+import org.rstudio.studio.client.server.VoidServerRequestCallback;\n+import org.rstudio.studio.client.workbench.FileMRUList;\n+import org.rstudio.studio.client.workbench.commands.Commands;\n+import org.rstudio.studio.client.workbench.events.SessionInitEvent;\n+import org.rstudio.studio.client.workbench.events.SessionInitHandler;\n+import org.rstudio.studio.client.workbench.model.ClientState;\n+import org.rstudio.studio.client.workbench.model.Session;\n+import org.rstudio.studio.client.workbench.model.UnsavedChangesTarget;\n+import org.rstudio.studio.client.workbench.model.helper.JSObjectStateValue;\n+import org.rstudio.studio.client.workbench.prefs.model.UserPrefs;\n+import org.rstudio.studio.client.workbench.prefs.model.UserState;\n+import org.rstudio.studio.client.workbench.ui.unsaved.UnsavedChangesDialog;\n+import org.rstudio.studio.client.workbench.views.environment.events.DebugModeChangedEvent;\n+import org.rstudio.studio.client.workbench.views.output.find.events.FindInFilesEvent;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTargetSource;\n+import org.rstudio.studio.client.workbench.views.source.editors.codebrowser.CodeBrowserEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.data.DataEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.explorer.ObjectExplorerEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.explorer.model.ObjectExplorerHandle;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.AceEditor;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.DocDisplay;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.TextEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.TextEditingTargetRMarkdownHelper;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.ace.Position;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.ace.Range;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.ace.Selection;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.EditingTargetSelectedEvent;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.ui.NewRMarkdownDialog;\n+import org.rstudio.studio.client.workbench.views.source.events.*;\n+import org.rstudio.studio.client.workbench.views.source.model.*;\n+\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+@Singleton\n+public class SourceColumnManager implements SessionInitHandler,\n+                                            CommandPaletteEntrySource,\n+                                            SourceExtendedTypeDetectedEvent.Handler,\n+                                            DebugModeChangedEvent.Handler\n+{\n+   public interface CPSEditingTargetCommand\n+   {\n+      void execute(EditingTarget editingTarget, Command continuation);\n+   }\n+\n+   public static class State extends JavaScriptObject\n+   {\n+      public static native State createState(JsArrayString names) /*-{\n+         return {\n+            names: names\n+         }\n+      }-*/;\n+\n+      protected State()\n+      {}\n+\n+      public final String[] getNames()\n+      {\n+         return JsUtil.toStringArray(getNamesNative());\n+      }\n+\n+      private native JsArrayString getNamesNative() /*-{\n+          return this.names;\n+      }-*/;\n+   }\n+\n+   @Inject\n+   public SourceColumnManager(Source.Display display,\n+                              SourceServerOperations server,\n+                              GlobalDisplay globalDisplay,\n+                              Commands commands,\n+                              EditingTargetSource editingTargetSource,\n+                              FileTypeRegistry fileTypeRegistry,\n+                              EventBus events,\n+                              DependencyManager dependencyManager,\n+                              final Session session,\n+                              Synctex synctex,\n+                              UserPrefs userPrefs,\n+                              UserState userState,\n+                              Provider<FileMRUList> pMruList,\n+                              Provider<SourceWindowManager> pWindowManager)\n+   {\n+      SourceColumn column = GWT.create(SourceColumn.class);\n+      column.loadDisplay(MAIN_SOURCE_NAME, display, this);\n+      columnList_.add(column);\n+      setActive(column.getName());\n+\n+      server_ = server;\n+      commands_ = commands;\n+      globalDisplay_ = globalDisplay;\n+      editingTargetSource_ = editingTargetSource;\n+      fileTypeRegistry_ = fileTypeRegistry;\n+      events_ = events;\n+      dependencyManager_ = dependencyManager;\n+      session_ = session;\n+      synctex_ = synctex;\n+      userPrefs_ = userPrefs;\n+      userState_ = userState;\n+      pMruList_ = pMruList;\n+      pWindowManager_ = pWindowManager;\n+\n+      rmarkdown_ = new TextEditingTargetRMarkdownHelper();\n+      vimCommands_ = new SourceVimCommands();\n+      columnState_ = null;\n+      initDynamicCommands();\n+\n+      events_.addHandler(SourceExtendedTypeDetectedEvent.TYPE, this);\n+      events_.addHandler(DebugModeChangedEvent.TYPE, this);\n+\n+      events_.addHandler(SessionInitEvent.TYPE,this);\n+\n+      events_.addHandler(EditingTargetSelectedEvent.TYPE, new EditingTargetSelectedEvent.Handler()\n+      {\n+         @Override\n+         public void onEditingTargetSelected(EditingTargetSelectedEvent event)\n+         {\n+            setActive(event.getTarget());\n+         }\n+      });\n+\n+      events_.addHandler(SourceFileSavedEvent.TYPE, new SourceFileSavedHandler()\n+      {\n+         public void onSourceFileSaved(SourceFileSavedEvent event)\n+         {\n+            pMruList_.get().add(event.getPath());\n+         }\n+      });\n+\n+      events_.addHandler(DocTabActivatedEvent.TYPE, new DocTabActivatedEvent.Handler()\n+      {\n+         public void onDocTabActivated(DocTabActivatedEvent event)\n+         {\n+            setActiveDocId(event.getId());\n+         }\n+      });\n+\n+      sourceNavigationHistory_.addChangeHandler(new ChangeHandler()\n+      {\n+\n+         @Override\n+         public void onChange(ChangeEvent event)\n+         {\n+            columnList_.forEach((column) ->\n+               column.manageSourceNavigationCommands());\n+         }\n+      });\n+   }\n+\n+   public String add()\n+   {\n+      Source.Display display = GWT.create(SourcePane.class);\n+      return add(display, false);\n+   }\n+\n+   public String add(Source.Display display)\n+   {\n+      return add(display, false);\n+   }\n+\n+   public String add(String name, boolean updateState)\n+   {\n+      return add(name, false, updateState);\n+   }\n+\n+   public String add (String name, boolean activate, boolean updateState)\n+   {\n+      Source.Display display = GWT.create(SourcePane.class);\n+      return add(name, display, activate, updateState);\n+   }\n+\n+   public String add(Source.Display display, boolean activate)\n+   {\n+      return add(display, activate, true);\n+   }\n+\n+   public String add(Source.Display display, boolean activate, boolean updateState)\n+   {\n+      return add(COLUMN_PREFIX + StringUtil.makeRandomId(12),\n+                  display,\n+                  activate,\n+                  updateState);\n+   }\n+\n+   public String add(String name, Source.Display display, boolean activate, boolean updateState)\n+   {\n+      if (contains(name))\n+         return \"\";\n+\n+      SourceColumn column = GWT.create(SourceColumn.class);\n+      column.loadDisplay(name, display, this);\n+      columnList_.add(column);\n+\n+      if (activate || activeColumn_ == null)\n+         activeColumn_ = column;\n+\n+      if (updateState)\n+         columnState_ = State.createState(JsUtil.toJsArrayString(getNames(false)));\n+      return column.getName();\n+   }\n+\n+   public void initialSelect(int index)\n+   {\n+      getActive().initialSelect(index);\n+   }\n+\n+   public void setActive(String name)\n+   {\n+      if (StringUtil.isNullOrEmpty(name))\n+      {\n+         activeColumn_.setActiveEditor(\"\");\n+         activeColumn_ = null;\n+         return;\n+      }\n+\n+      String prevColumn = activeColumn_ == null ? \"\" : activeColumn_.getName();\n+      activeColumn_ = getByName(name);\n+\n+      // If the active column changed, we need to update the active editor\n+      if (!StringUtil.isNullOrEmpty(prevColumn) && !StringUtil.equals(name, prevColumn))\n+      {\n+         SourceColumn column = getByName(prevColumn);\n+         if (column == null)\n+            return;\n+         if (!hasActiveEditor())\n+         {\n+            Debug.logWarning(\"Setting to random editor.\");\n+            column.setActiveEditor();\n+         }\n+      }\n+   }\n+\n+   public void setActive(EditingTarget target)\n+   {\n+      activeColumn_ = findByDocument(target.getId());\n+      activeColumn_.setActiveEditor(target);\n+   }\n+\n+   public void setActiveDocId(String docId)\n+   {\n+      for (SourceColumn column : columnList_)\n+      {\n+         EditingTarget target = column.setActiveEditor(docId);\n+         if (target != null)\n+         {\n+            setActive(target);\n+            return;\n+         }\n+      }\n+      Debug.logWarning(\"Attempted to set unknown doc to active \" + docId);\n+   }\n+\n+   public void setOpeningForSourceNavigation(boolean value)\n+   {\n+      openingForSourceNavigation_ = value;\n+   }\n+\n+   public void activateColumns(final Command afterActivation)\n+   {\n+      if (!hasActiveEditor())\n+      {\n+         if (activeColumn_ == null)\n+            setActive(MAIN_SOURCE_NAME);\n+         newDoc(FileTypeRegistry.R, new ResultCallback<EditingTarget, ServerError>()\n+         {\n+            @Override\n+            public void onSuccess(EditingTarget target)\n+            {\n+               setActive(target);\n+               doActivateSource(afterActivation);\n+            }\n+         });\n+      } else\n+      {\n+         doActivateSource(afterActivation);\n+      }\n+   }\n+\n+   // This method sets activeColumn_ to the main column if it is null. It should be used in cases\n+   // where it is better for the column to be the main column than null.\n+   public SourceColumn getActive()\n+   {\n+      if (activeColumn_ != null)\n+         return activeColumn_;\n+      setActive(MAIN_SOURCE_NAME);\n+\n+      return activeColumn_;\n+   }\n+\n+   public String getActiveDocId()\n+   {\n+      if (hasActiveEditor())\n+         return activeColumn_.getActiveEditor().getId();\n+      return null;\n+   }\n+\n+   public String getActiveDocPath()\n+   {\n+      if (hasActiveEditor())\n+         return activeColumn_.getActiveEditor().getPath();\n+      return null;\n+   }\n+\n+   public boolean hasActiveEditor()\n+   {\n+      return activeColumn_ != null && activeColumn_.getActiveEditor() != null;\n+   }\n+\n+   public boolean isActiveEditor(EditingTarget editingTarget)\n+   {\n+      return hasActiveEditor() && activeColumn_.getActiveEditor() == editingTarget;\n+   }\n+\n+   // see if there are additional command pallette items made available", "originalCommit": "b05e15e98d5dec936f440319aa15d74615743fc3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MjEyNQ==", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438462125", "bodyText": "not used", "author": "gtritchie", "createdAt": "2020-06-10T23:30:54Z", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/editors/text/TextEditingTargetVisualMode.java", "diffHunk": "@@ -47,6 +47,7 @@\n import org.rstudio.studio.client.panmirror.PanmirrorWidget;\n import org.rstudio.studio.client.panmirror.PanmirrorWidget.FormatSource;\n import org.rstudio.studio.client.panmirror.PanmirrorWriterOptions;\n+import org.rstudio.studio.client.panmirror.command.PanmirrorCommandUI;", "originalCommit": "b05e15e98d5dec936f440319aa15d74615743fc3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MjI3NQ==", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438462275", "bodyText": "This source file needs our standard comment block header.", "author": "gtritchie", "createdAt": "2020-06-10T23:31:28Z", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/editors/text/events/EditingTargetSelectedEvent.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package org.rstudio.studio.client.workbench.views.source.editors.text.events;", "originalCommit": "b05e15e98d5dec936f440319aa15d74615743fc3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6ca49e0a732d2f127b10ffbdf23ba78c39ee87d4", "url": "https://github.com/rstudio/rstudio/commit/6ca49e0a732d2f127b10ffbdf23ba78c39ee87d4", "message": "remove debug, fix spelling typos, add rstudio header, tidy code", "committedDate": "2020-06-11T00:25:12Z", "type": "commit"}, {"oid": "42a8c6a26c24776f4eb0f75170f9f3a26cd5daa5", "url": "https://github.com/rstudio/rstudio/commit/42a8c6a26c24776f4eb0f75170f9f3a26cd5daa5", "message": "fix bug with pane splitters,\nadd method so the column manager can close all tabs for a specified colum", "committedDate": "2020-06-11T01:21:31Z", "type": "commit"}, {"oid": "55b1fabe5fd8169f4c361c796a36b6074506ce59", "url": "https://github.com/rstudio/rstudio/commit/55b1fabe5fd8169f4c361c796a36b6074506ce59", "message": "remove unnecessary event call", "committedDate": "2020-06-11T02:04:24Z", "type": "commit"}, {"oid": "894958e74f1999d5bfefe09cd96051918da553cb", "url": "https://github.com/rstudio/rstudio/commit/894958e74f1999d5bfefe09cd96051918da553cb", "message": "revert change that broke persistent state", "committedDate": "2020-06-11T19:52:55Z", "type": "commit"}, {"oid": "8bc8a43b18ee18668c2e243dbeafbb44a3149d6f", "url": "https://github.com/rstudio/rstudio/commit/8bc8a43b18ee18668c2e243dbeafbb44a3149d6f", "message": "code cleanup", "committedDate": "2020-06-11T20:53:48Z", "type": "commit"}, {"oid": "6525ffeaaf8cae4376ae88dddc9253e320590261", "url": "https://github.com/rstudio/rstudio/commit/6525ffeaaf8cae4376ae88dddc9253e320590261", "message": "add title to Enable Additional Columns pref", "committedDate": "2020-06-15T19:10:53Z", "type": "commit"}, {"oid": "32c05c613ca73032b7650c5a6ab24470afed4446", "url": "https://github.com/rstudio/rstudio/commit/32c05c613ca73032b7650c5a6ab24470afed4446", "message": "fix issue where state equality wasn't properly handled", "committedDate": "2020-06-15T19:19:11Z", "type": "commit"}]}