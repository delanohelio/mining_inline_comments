{"pr_number": 12990, "pr_title": "opponentinfo: make health bar more active", "pr_createdAt": "2020-12-29T01:39:48Z", "pr_url": "https://github.com/runelite/runelite/pull/12990", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjA3MDcxMw==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r556070713", "bodyText": "Reverse these indentation changes\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tname = \"Opponent Information\",\n          \n          \n            \n            \t\tdescription = \"Show name and hitpoints information about the NPC you are fighting\",\n          \n          \n            \n            \t\ttags = {\"combat\", \"health\", \"hitpoints\", \"npcs\", \"overlay\"}\n          \n          \n            \n            \tname = \"Opponent Information\",\n          \n          \n            \n            \tdescription = \"Show name and hitpoints information about the NPC you are fighting\",\n          \n          \n            \n            \ttags = {\"combat\", \"health\", \"hitpoints\", \"npcs\", \"overlay\"}", "author": "Nightfirecat", "createdAt": "2021-01-12T20:31:44Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -51,9 +51,9 @@\n import net.runelite.http.api.hiscore.HiscoreEndpoint;\n \n @PluginDescriptor(\n-\tname = \"Opponent Information\",\n-\tdescription = \"Show name and hitpoints information about the NPC you are fighting\",\n-\ttags = {\"combat\", \"health\", \"hitpoints\", \"npcs\", \"overlay\"}\n+\t\tname = \"Opponent Information\",\n+\t\tdescription = \"Show name and hitpoints information about the NPC you are fighting\",\n+\t\ttags = {\"combat\", \"health\", \"hitpoints\", \"npcs\", \"overlay\"}", "originalCommit": "1ed1619d24f5443c64f12d680c9dea3cc269eda4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjA3MjE3OA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r556072178", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t|| !menuEntryAdded.getOption().equals(\"Attack\")\n          \n          \n            \n            \t\t\t\t|| !config.showOpponentsInMenu())\n          \n          \n            \n            \t\t\t|| !menuEntryAdded.getOption().equals(\"Attack\")\n          \n          \n            \n            \t\t\t|| !config.showOpponentsInMenu())", "author": "Nightfirecat", "createdAt": "2021-01-12T20:33:50Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -134,42 +134,55 @@ else if (worldType.contains(WorldType.LEAGUE))\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tif (event.getSource() != client.getLocalPlayer())\n-\t\t{\n-\t\t\treturn;\n-\t\t}\n+\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n \n-\t\tActor opponent = event.getTarget();\n-\n-\t\tif (opponent == null)\n+\t\tif (source == player)\n \t\t{\n-\t\t\tlastTime = Instant.now();\n-\t\t\treturn;\n+\t\t\tif (target != null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = target;\n+\t\t\t\tlastTime = null;\n+\t\t\t}\n+\t\t\telse if (lastOpponent != null\n+\t\t\t\t\t&& lastOpponent.getInteracting() != player)\n+\t\t\t{\n+\t\t\t\tlastTime = Instant.now();\n+\t\t\t}\n \t\t}\n+\t\telse if (target == player\n+\t\t\t\t|| source == lastOpponent)\n+\t\t{\n+\t\t\tActor opponent = player.getInteracting();\n \n-\t\tlastOpponent = opponent;\n+\t\t\tif (target != null && opponent == null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = source;\n+\t\t\t\tlastTime = null;\n+\t\t\t}\n+\t\t\telse if (opponent != lastOpponent)\n+\t\t\t{\n+\t\t\t\tlastTime = Instant.now();\n+\t\t\t}\n+\t\t}\n \t}\n \n \t@Subscribe\n \tpublic void onGameTick(GameTick gameTick)\n \t{\n-\t\tif (lastOpponent != null\n-\t\t\t&& lastTime != null\n-\t\t\t&& client.getLocalPlayer().getInteracting() == null)\n+\t\tif (lastTime != null \n+\t\t\t&& Duration.between(lastTime, Instant.now()).compareTo(WAIT) > 0)\n \t\t{\n-\t\t\tif (Duration.between(lastTime, Instant.now()).compareTo(WAIT) > 0)\n-\t\t\t{\n-\t\t\t\tlastOpponent = null;\n-\t\t\t}\n+\t\t\tlastOpponent = null;\n+\t\t\tlastTime = null;\n \t\t}\n \t}\n \n \t@Subscribe\n \tpublic void onMenuEntryAdded(MenuEntryAdded menuEntryAdded)\n \t{\n \t\tif (menuEntryAdded.getType() != MenuAction.NPC_SECOND_OPTION.getId()\n-\t\t\t|| !menuEntryAdded.getOption().equals(\"Attack\")\n-\t\t\t|| !config.showOpponentsInMenu())\n+\t\t\t\t|| !menuEntryAdded.getOption().equals(\"Attack\")\n+\t\t\t\t|| !config.showOpponentsInMenu())", "originalCommit": "1ed1619d24f5443c64f12d680c9dea3cc269eda4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjA3ODgzMg==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r556078832", "bodyText": "Indent by only one level\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t|| source == lastOpponent)\n          \n          \n            \n            \t\t\t|| source == lastOpponent)", "author": "Nightfirecat", "createdAt": "2021-01-12T20:44:30Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -134,42 +134,55 @@ else if (worldType.contains(WorldType.LEAGUE))\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tif (event.getSource() != client.getLocalPlayer())\n-\t\t{\n-\t\t\treturn;\n-\t\t}\n+\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n \n-\t\tActor opponent = event.getTarget();\n-\n-\t\tif (opponent == null)\n+\t\tif (source == player)\n \t\t{\n-\t\t\tlastTime = Instant.now();\n-\t\t\treturn;\n+\t\t\tif (target != null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = target;\n+\t\t\t\tlastTime = null;\n+\t\t\t}\n+\t\t\telse if (lastOpponent != null\n+\t\t\t\t\t&& lastOpponent.getInteracting() != player)\n+\t\t\t{\n+\t\t\t\tlastTime = Instant.now();\n+\t\t\t}\n \t\t}\n+\t\telse if (target == player\n+\t\t\t\t|| source == lastOpponent)", "originalCommit": "1ed1619d24f5443c64f12d680c9dea3cc269eda4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjA3OTE5Mg==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r556079192", "bodyText": "Indent by only one level\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t&& lastOpponent.getInteracting() != player)\n          \n          \n            \n            \t\t\t\t&& lastOpponent.getInteracting() != player)", "author": "Nightfirecat", "createdAt": "2021-01-12T20:44:49Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -134,42 +134,55 @@ else if (worldType.contains(WorldType.LEAGUE))\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tif (event.getSource() != client.getLocalPlayer())\n-\t\t{\n-\t\t\treturn;\n-\t\t}\n+\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n \n-\t\tActor opponent = event.getTarget();\n-\n-\t\tif (opponent == null)\n+\t\tif (source == player)\n \t\t{\n-\t\t\tlastTime = Instant.now();\n-\t\t\treturn;\n+\t\t\tif (target != null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = target;\n+\t\t\t\tlastTime = null;\n+\t\t\t}\n+\t\t\telse if (lastOpponent != null\n+\t\t\t\t\t&& lastOpponent.getInteracting() != player)", "originalCommit": "1ed1619d24f5443c64f12d680c9dea3cc269eda4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjA3OTQ4OA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r556079488", "bodyText": "The trailing space here is causing the CI failure\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tif (lastTime != null \n          \n          \n            \n            \t\tif (lastTime != null", "author": "Nightfirecat", "createdAt": "2021-01-12T20:45:05Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -134,42 +134,55 @@ else if (worldType.contains(WorldType.LEAGUE))\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tif (event.getSource() != client.getLocalPlayer())\n-\t\t{\n-\t\t\treturn;\n-\t\t}\n+\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n \n-\t\tActor opponent = event.getTarget();\n-\n-\t\tif (opponent == null)\n+\t\tif (source == player)\n \t\t{\n-\t\t\tlastTime = Instant.now();\n-\t\t\treturn;\n+\t\t\tif (target != null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = target;\n+\t\t\t\tlastTime = null;\n+\t\t\t}\n+\t\t\telse if (lastOpponent != null\n+\t\t\t\t\t&& lastOpponent.getInteracting() != player)\n+\t\t\t{\n+\t\t\t\tlastTime = Instant.now();\n+\t\t\t}\n \t\t}\n+\t\telse if (target == player\n+\t\t\t\t|| source == lastOpponent)\n+\t\t{\n+\t\t\tActor opponent = player.getInteracting();\n \n-\t\tlastOpponent = opponent;\n+\t\t\tif (target != null && opponent == null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = source;\n+\t\t\t\tlastTime = null;\n+\t\t\t}\n+\t\t\telse if (opponent != lastOpponent)\n+\t\t\t{\n+\t\t\t\tlastTime = Instant.now();\n+\t\t\t}\n+\t\t}\n \t}\n \n \t@Subscribe\n \tpublic void onGameTick(GameTick gameTick)\n \t{\n-\t\tif (lastOpponent != null\n-\t\t\t&& lastTime != null\n-\t\t\t&& client.getLocalPlayer().getInteracting() == null)\n+\t\tif (lastTime != null ", "originalCommit": "1ed1619d24f5443c64f12d680c9dea3cc269eda4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjEwOTE1OA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r556109158", "bodyText": "Why is this nulled here now?", "author": "Nightfirecat", "createdAt": "2021-01-12T21:33:13Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -134,42 +134,55 @@ else if (worldType.contains(WorldType.LEAGUE))\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tif (event.getSource() != client.getLocalPlayer())\n-\t\t{\n-\t\t\treturn;\n-\t\t}\n+\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n \n-\t\tActor opponent = event.getTarget();\n-\n-\t\tif (opponent == null)\n+\t\tif (source == player)\n \t\t{\n-\t\t\tlastTime = Instant.now();\n-\t\t\treturn;\n+\t\t\tif (target != null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = target;\n+\t\t\t\tlastTime = null;\n+\t\t\t}\n+\t\t\telse if (lastOpponent != null\n+\t\t\t\t\t&& lastOpponent.getInteracting() != player)\n+\t\t\t{\n+\t\t\t\tlastTime = Instant.now();\n+\t\t\t}\n \t\t}\n+\t\telse if (target == player\n+\t\t\t\t|| source == lastOpponent)\n+\t\t{\n+\t\t\tActor opponent = player.getInteracting();\n \n-\t\tlastOpponent = opponent;\n+\t\t\tif (target != null && opponent == null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = source;\n+\t\t\t\tlastTime = null;\n+\t\t\t}\n+\t\t\telse if (opponent != lastOpponent)\n+\t\t\t{\n+\t\t\t\tlastTime = Instant.now();\n+\t\t\t}\n+\t\t}\n \t}\n \n \t@Subscribe\n \tpublic void onGameTick(GameTick gameTick)\n \t{\n-\t\tif (lastOpponent != null\n-\t\t\t&& lastTime != null\n-\t\t\t&& client.getLocalPlayer().getInteracting() == null)\n+\t\tif (lastTime != null \n+\t\t\t&& Duration.between(lastTime, Instant.now()).compareTo(WAIT) > 0)\n \t\t{\n-\t\t\tif (Duration.between(lastTime, Instant.now()).compareTo(WAIT) > 0)\n-\t\t\t{\n-\t\t\t\tlastOpponent = null;\n-\t\t\t}\n+\t\t\tlastOpponent = null;\n+\t\t\tlastTime = null;", "originalCommit": "1ed1619d24f5443c64f12d680c9dea3cc269eda4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzAzOTI4MA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r557039280", "bodyText": "Hello, so, in the current version of the plugin, it checks whether the player is interacting with an NPC on line 158 as part of determining whether to hide the health bar after WAIT time has passed or not.  Since my goal is to have the health bar visible while the player isn't technically interacting with the NPC but is still damaging it with recoil/cannon, I instead made lastTime null when it hasn't been set to a value in onInteractingChanged.  Otherwise, it would hide the health bar every tick after the initial WAIT time has passed.", "author": "chaticon", "createdAt": "2021-01-14T04:38:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjEwOTE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjEwOTIwNQ==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r556109205", "bodyText": "Why is this nulled here now?", "author": "Nightfirecat", "createdAt": "2021-01-12T21:33:19Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -134,42 +134,55 @@ else if (worldType.contains(WorldType.LEAGUE))\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tif (event.getSource() != client.getLocalPlayer())\n-\t\t{\n-\t\t\treturn;\n-\t\t}\n+\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n \n-\t\tActor opponent = event.getTarget();\n-\n-\t\tif (opponent == null)\n+\t\tif (source == player)\n \t\t{\n-\t\t\tlastTime = Instant.now();\n-\t\t\treturn;\n+\t\t\tif (target != null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = target;\n+\t\t\t\tlastTime = null;\n+\t\t\t}\n+\t\t\telse if (lastOpponent != null\n+\t\t\t\t\t&& lastOpponent.getInteracting() != player)\n+\t\t\t{\n+\t\t\t\tlastTime = Instant.now();\n+\t\t\t}\n \t\t}\n+\t\telse if (target == player\n+\t\t\t\t|| source == lastOpponent)\n+\t\t{\n+\t\t\tActor opponent = player.getInteracting();\n \n-\t\tlastOpponent = opponent;\n+\t\t\tif (target != null && opponent == null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = source;\n+\t\t\t\tlastTime = null;", "originalCommit": "1ed1619d24f5443c64f12d680c9dea3cc269eda4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwMTE4Nw==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561601187", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            import java.time.Clock;", "author": "Nightfirecat", "createdAt": "2021-01-21T04:52:05Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -26,6 +26,8 @@\n package net.runelite.client.plugins.opponentinfo;\n \n import com.google.inject.Provides;\n+\n+import java.time.Clock;", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwMTM3Nw==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561601377", "bodyText": "This should be @VisibleForTesting as the getter should not be used otherwise.", "author": "Nightfirecat", "createdAt": "2021-01-21T04:52:47Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -80,6 +82,7 @@\n \t@Getter(AccessLevel.PACKAGE)\n \tprivate Actor lastOpponent;\n \n+\t@Getter(AccessLevel.PACKAGE)\n \tprivate Instant lastTime;", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwMTkyNg==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561601926", "bodyText": "This will be clearer with each definition on its own line.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n          \n          \n            \n            \t\tfinal Player player = client.getLocalPlayer();\n          \n          \n            \n            \t\tfinal Actor source = event.getSource();\n          \n          \n            \n            \t\tfinal Actor target = event.getTarget();", "author": "Nightfirecat", "createdAt": "2021-01-21T04:55:00Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -134,33 +137,46 @@ else if (worldType.contains(WorldType.LEAGUE))\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tif (event.getSource() != client.getLocalPlayer())\n-\t\t{\n-\t\t\treturn;\n-\t\t}\n+\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwMjMwMg==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561602302", "bodyText": "This is missing copyright header", "author": "Nightfirecat", "createdAt": "2021-01-21T04:56:21Z", "path": "runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package net.runelite.client.plugins.opponentinfo;", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwMjU4MA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561602580", "bodyText": "Imports should be ordered alphabetically and have no empty lines (don't separate static and non-static imports). Also, don't use star imports: https://github.com/runelite/runelite/wiki/Code-Conventions#imports", "author": "Nightfirecat", "createdAt": "2021-01-21T04:57:24Z", "path": "runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package net.runelite.client.plugins.opponentinfo;\n+\n+import com.google.inject.Guice;\n+import com.google.inject.Inject;\n+import com.google.inject.testing.fieldbinder.Bind;\n+import com.google.inject.testing.fieldbinder.BoundFieldModule;\n+import net.runelite.api.*;\n+import net.runelite.api.events.InteractingChanged;\n+import net.runelite.client.ui.overlay.OverlayManager;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwMjgxNg==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561602816", "bodyText": "Refer to our code conventions--we use tabs for indentation rather than spaces. Our code conventions page provides a brief guide for setting up auto-formatting with IntelliJ.", "author": "Nightfirecat", "createdAt": "2021-01-21T04:58:03Z", "path": "runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package net.runelite.client.plugins.opponentinfo;\n+\n+import com.google.inject.Guice;\n+import com.google.inject.Inject;\n+import com.google.inject.testing.fieldbinder.Bind;\n+import com.google.inject.testing.fieldbinder.BoundFieldModule;\n+import net.runelite.api.*;\n+import net.runelite.api.events.InteractingChanged;\n+import net.runelite.client.ui.overlay.OverlayManager;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class OpponentInfoPluginTest\n+{\n+    @Mock", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwNDA4NA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561604084", "bodyText": "We generally use the name localPlayer for the local player\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n          \n          \n            \n                    Player localPlayer = mock(Player.class), otherPlayer = mock(Player.class);", "author": "Nightfirecat", "createdAt": "2021-01-21T05:02:41Z", "path": "runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package net.runelite.client.plugins.opponentinfo;\n+\n+import com.google.inject.Guice;\n+import com.google.inject.Inject;\n+import com.google.inject.testing.fieldbinder.Bind;\n+import com.google.inject.testing.fieldbinder.BoundFieldModule;\n+import net.runelite.api.*;\n+import net.runelite.api.events.InteractingChanged;\n+import net.runelite.client.ui.overlay.OverlayManager;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class OpponentInfoPluginTest\n+{\n+    @Mock\n+    @Bind\n+    Client client;\n+\n+    @Mock\n+    @Bind\n+    OverlayManager overlayManager;\n+\n+    @Mock\n+    @Bind\n+    OpponentInfoConfig opponentInfoConfig;\n+\n+    @Mock\n+    @Bind\n+    OpponentInfoOverlay opponentInfoOverlay;\n+\n+    @Mock\n+    @Bind\n+    PlayerComparisonOverlay playerComparisonOverlay;\n+\n+    @Inject\n+    OpponentInfoPlugin opponentInfoPlugin;\n+\n+    @Before\n+    public void before()\n+    {\n+        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n+    }\n+\n+    /*\n+     * Verify that the current opponent in multi is always the npc that the player is attacking\n+     */\n+    @Test\n+    public void testAttackingEnemyInMulti() {\n+        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwNDY2NQ==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561604665", "bodyText": "Shouldn't there be another assert between these verifying attacked is now the last opponent?", "author": "Nightfirecat", "createdAt": "2021-01-21T05:05:01Z", "path": "runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package net.runelite.client.plugins.opponentinfo;\n+\n+import com.google.inject.Guice;\n+import com.google.inject.Inject;\n+import com.google.inject.testing.fieldbinder.Bind;\n+import com.google.inject.testing.fieldbinder.BoundFieldModule;\n+import net.runelite.api.*;\n+import net.runelite.api.events.InteractingChanged;\n+import net.runelite.client.ui.overlay.OverlayManager;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class OpponentInfoPluginTest\n+{\n+    @Mock\n+    @Bind\n+    Client client;\n+\n+    @Mock\n+    @Bind\n+    OverlayManager overlayManager;\n+\n+    @Mock\n+    @Bind\n+    OpponentInfoConfig opponentInfoConfig;\n+\n+    @Mock\n+    @Bind\n+    OpponentInfoOverlay opponentInfoOverlay;\n+\n+    @Mock\n+    @Bind\n+    PlayerComparisonOverlay playerComparisonOverlay;\n+\n+    @Inject\n+    OpponentInfoPlugin opponentInfoPlugin;\n+\n+    @Before\n+    public void before()\n+    {\n+        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n+    }\n+\n+    /*\n+     * Verify that the current opponent in multi is always the npc that the player is attacking\n+     */\n+    @Test\n+    public void testAttackingEnemyInMulti() {\n+        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+        NPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n+        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\n+        // verify that there is currently no opponent\n+        assertNull(opponentInfoPlugin.getLastOpponent());\n+\n+        // some npc attacks the player\n+        InteractingChanged aggroEnemy = new InteractingChanged(aggro, thePlayer);\n+        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\n+        // verify that the current opponent is the aggressive npc\n+        assertSame(opponentInfoPlugin.getLastOpponent(), aggro);\n+\n+        // the player attacks a different npc\n+        when(thePlayer.getInteracting()).thenReturn(attacked);\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, attacked));\n+        // the npc attacks them back\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, thePlayer));", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwOTU2MA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561609560", "bodyText": "It looks like this line is not covered in the added tests. What case does this cover?", "author": "Nightfirecat", "createdAt": "2021-01-21T05:21:54Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -134,33 +137,46 @@ else if (worldType.contains(WorldType.LEAGUE))\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tif (event.getSource() != client.getLocalPlayer())\n-\t\t{\n-\t\t\treturn;\n-\t\t}\n+\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n \n-\t\tActor opponent = event.getTarget();\n-\n-\t\tif (opponent == null)\n+\t\tif (source == player)\n \t\t{\n-\t\t\tlastTime = Instant.now();\n-\t\t\treturn;\n+\t\t\tif (target != null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = target;\n+\t\t\t\tlastTime = null;\n+\t\t\t}\n+\t\t\telse if (lastOpponent != null\n+\t\t\t\t&& lastOpponent.getInteracting() != player)\n+\t\t\t{\n+\t\t\t\tlastTime = Instant.now();", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzQxOTIyMA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r563419220", "bodyText": "This prevents the hp bar disappearing in the case where the player attacks an npc, then stops attacking anything, but the npc hasn't stopped attacking the player.  There actually is a test for it on line 184.  (Now line 219 as of today)", "author": "chaticon", "createdAt": "2021-01-25T01:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwOTU2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTExMTU3MQ==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r569111571", "bodyText": "That isn't what this condition is written to be though, nor is it what that test is testing.\nThis condition, combined with all the parent conditions, works out to be:\nif (source == player && target == null && lastOpponent != null && lastOpponent.getInteracting() != player)\nThat is, when the player stops interacting with an NPC which is not attacking the player. That is why, despite the test being written to test the scenario you described, this line is not being covered by tests. I highly recommend running the tests in IntelliJ using the \"Run Test with Coverage\" button and checking to see which lines of the plugin (most importantly the changed lines) have test coverage. That is how I identified that this lastTime = Instant.now(); call is never executed by the tests.", "author": "Nightfirecat", "createdAt": "2021-02-03T03:45:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwOTU2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTkwNjI1MA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r569906250", "bodyText": "Sorry, I explained poorly.  What I meant was exactly what you described, I was just explaining what happens when the condition is false.  It is designed so that in the case I mentioned, where the player stops attacking an npc, but the npc is still attacking the player, the condition is false, so the hp bar stays visible.  That's why when\u2014as you've described\u2014the player stops interacting with an npc that isn't attacking the player, the condition is true.  The result of that is, as you would expect, the hp bar is set to disappear after WAIT time.  In the test, I was testing that case where the condition is false.  I've added a test where the condition is true now.", "author": "chaticon", "createdAt": "2021-02-04T02:42:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwOTU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYxMDgwNw==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561610807", "bodyText": "Same here, shouldn't there be another assert between these verifying playerNPC is now the last opponent?", "author": "Nightfirecat", "createdAt": "2021-01-21T05:26:07Z", "path": "runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package net.runelite.client.plugins.opponentinfo;\n+\n+import com.google.inject.Guice;\n+import com.google.inject.Inject;\n+import com.google.inject.testing.fieldbinder.Bind;\n+import com.google.inject.testing.fieldbinder.BoundFieldModule;\n+import net.runelite.api.*;\n+import net.runelite.api.events.InteractingChanged;\n+import net.runelite.client.ui.overlay.OverlayManager;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class OpponentInfoPluginTest\n+{\n+    @Mock\n+    @Bind\n+    Client client;\n+\n+    @Mock\n+    @Bind\n+    OverlayManager overlayManager;\n+\n+    @Mock\n+    @Bind\n+    OpponentInfoConfig opponentInfoConfig;\n+\n+    @Mock\n+    @Bind\n+    OpponentInfoOverlay opponentInfoOverlay;\n+\n+    @Mock\n+    @Bind\n+    PlayerComparisonOverlay playerComparisonOverlay;\n+\n+    @Inject\n+    OpponentInfoPlugin opponentInfoPlugin;\n+\n+    @Before\n+    public void before()\n+    {\n+        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n+    }\n+\n+    /*\n+     * Verify that the current opponent in multi is always the npc that the player is attacking\n+     */\n+    @Test\n+    public void testAttackingEnemyInMulti() {\n+        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+        NPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n+        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\n+        // verify that there is currently no opponent\n+        assertNull(opponentInfoPlugin.getLastOpponent());\n+\n+        // some npc attacks the player\n+        InteractingChanged aggroEnemy = new InteractingChanged(aggro, thePlayer);\n+        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\n+        // verify that the current opponent is the aggressive npc\n+        assertSame(opponentInfoPlugin.getLastOpponent(), aggro);\n+\n+        // the player attacks a different npc\n+        when(thePlayer.getInteracting()).thenReturn(attacked);\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, attacked));\n+        // the npc attacks them back\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, thePlayer));\n+\n+        // verify that the current opponent is now the attacked npc\n+        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\n+        // the player is attacked by an aggressive npc while attacking a different npc\n+        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\n+        // verify that the current opponent is still the npc the player is attacking\n+        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\n+        // the npc attacking the player that is not the current opponent attacks a different player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggro, otherPlayer));\n+\n+        // verify that the current opponent is still the npc the player is attacking\n+        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\n+        // the npc the player is attacking, the current opponent, attacks a different player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, otherPlayer));\n+\n+        // verify that the current opponent is still the npc the player is attacking\n+        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+    }\n+\n+    /*\n+     * Verify that the current opponent is the expected npc while the player is not attacking anything\n+     */\n+    @Test\n+    public void testIdleInMulti() {\n+        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+        NPC aggroFirst = mock(NPC.class), aggroRecent = mock(NPC.class);\n+        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\n+        // verify that there is currently no opponent\n+        assertNull(opponentInfoPlugin.getLastOpponent());\n+\n+        // some npc attacks the player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, thePlayer));\n+\n+        // verify that the current opponent is the aggressive npc\n+        assertSame(opponentInfoPlugin.getLastOpponent(), aggroFirst);\n+\n+        // the player is attacked by a different npc\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, thePlayer));\n+\n+        // verify that the current opponent is the most recent aggressor\n+        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\n+        // an npc that is not the current opponent targets another player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, otherPlayer));\n+\n+        // verify that the current opponent is still the most recent aggressor\n+        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\n+        // the current opponent switches targets to another player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, otherPlayer));\n+\n+        // verify that there is no longer an opponent\n+        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+    }\n+\n+    /*\n+     * Verify that the current opponent is the expected npc in singles\n+     */\n+    @Test\n+    public void testSingles() {\n+        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+        NPC playerNPC = mock(NPC.class);\n+        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\n+        // verify that there is currently no opponent\n+        assertNull(opponentInfoPlugin.getLastOpponent());\n+\n+        // some npc attacks the player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, thePlayer));\n+\n+        // verify that the attacking npc is the current opponent\n+        assertSame(opponentInfoPlugin.getLastOpponent(), playerNPC);\n+\n+        // the npc stops attacking the player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, null));\n+\n+        // verify that there is no longer an opponent\n+        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\n+        // the player attacks the npc\n+        when(thePlayer.getInteracting()).thenReturn(playerNPC);\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, playerNPC));\n+        // the npc attacks them back\n+        when(playerNPC.getInteracting()).thenReturn(thePlayer);\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, thePlayer));", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYxMDg2NA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561610864", "bodyText": "This is a very confusing var name. Couldn't we just call this npc?", "author": "Nightfirecat", "createdAt": "2021-01-21T05:26:22Z", "path": "runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package net.runelite.client.plugins.opponentinfo;\n+\n+import com.google.inject.Guice;\n+import com.google.inject.Inject;\n+import com.google.inject.testing.fieldbinder.Bind;\n+import com.google.inject.testing.fieldbinder.BoundFieldModule;\n+import net.runelite.api.*;\n+import net.runelite.api.events.InteractingChanged;\n+import net.runelite.client.ui.overlay.OverlayManager;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class OpponentInfoPluginTest\n+{\n+    @Mock\n+    @Bind\n+    Client client;\n+\n+    @Mock\n+    @Bind\n+    OverlayManager overlayManager;\n+\n+    @Mock\n+    @Bind\n+    OpponentInfoConfig opponentInfoConfig;\n+\n+    @Mock\n+    @Bind\n+    OpponentInfoOverlay opponentInfoOverlay;\n+\n+    @Mock\n+    @Bind\n+    PlayerComparisonOverlay playerComparisonOverlay;\n+\n+    @Inject\n+    OpponentInfoPlugin opponentInfoPlugin;\n+\n+    @Before\n+    public void before()\n+    {\n+        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n+    }\n+\n+    /*\n+     * Verify that the current opponent in multi is always the npc that the player is attacking\n+     */\n+    @Test\n+    public void testAttackingEnemyInMulti() {\n+        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+        NPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n+        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\n+        // verify that there is currently no opponent\n+        assertNull(opponentInfoPlugin.getLastOpponent());\n+\n+        // some npc attacks the player\n+        InteractingChanged aggroEnemy = new InteractingChanged(aggro, thePlayer);\n+        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\n+        // verify that the current opponent is the aggressive npc\n+        assertSame(opponentInfoPlugin.getLastOpponent(), aggro);\n+\n+        // the player attacks a different npc\n+        when(thePlayer.getInteracting()).thenReturn(attacked);\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, attacked));\n+        // the npc attacks them back\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, thePlayer));\n+\n+        // verify that the current opponent is now the attacked npc\n+        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\n+        // the player is attacked by an aggressive npc while attacking a different npc\n+        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\n+        // verify that the current opponent is still the npc the player is attacking\n+        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\n+        // the npc attacking the player that is not the current opponent attacks a different player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggro, otherPlayer));\n+\n+        // verify that the current opponent is still the npc the player is attacking\n+        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\n+        // the npc the player is attacking, the current opponent, attacks a different player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, otherPlayer));\n+\n+        // verify that the current opponent is still the npc the player is attacking\n+        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+    }\n+\n+    /*\n+     * Verify that the current opponent is the expected npc while the player is not attacking anything\n+     */\n+    @Test\n+    public void testIdleInMulti() {\n+        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+        NPC aggroFirst = mock(NPC.class), aggroRecent = mock(NPC.class);\n+        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\n+        // verify that there is currently no opponent\n+        assertNull(opponentInfoPlugin.getLastOpponent());\n+\n+        // some npc attacks the player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, thePlayer));\n+\n+        // verify that the current opponent is the aggressive npc\n+        assertSame(opponentInfoPlugin.getLastOpponent(), aggroFirst);\n+\n+        // the player is attacked by a different npc\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, thePlayer));\n+\n+        // verify that the current opponent is the most recent aggressor\n+        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\n+        // an npc that is not the current opponent targets another player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, otherPlayer));\n+\n+        // verify that the current opponent is still the most recent aggressor\n+        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\n+        // the current opponent switches targets to another player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, otherPlayer));\n+\n+        // verify that there is no longer an opponent\n+        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+    }\n+\n+    /*\n+     * Verify that the current opponent is the expected npc in singles\n+     */\n+    @Test\n+    public void testSingles() {\n+        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+        NPC playerNPC = mock(NPC.class);", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzQyNTYzMQ==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r563425631", "bodyText": "You're right, at one point I was using two npcs and I just never changed the name when I removed one of them.", "author": "chaticon", "createdAt": "2021-01-25T01:59:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYxMDg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYxMzMxNA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561613314", "bodyText": "FYI, the argument order for assertions is assertSame(expected, actual), so every assertion has the parameters in reverse order.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertSame(opponentInfoPlugin.getLastOpponent(), aggro);\n          \n          \n            \n                    assertSame(opponentInfoPlugin.getLastOpponent(), aggro);", "author": "Nightfirecat", "createdAt": "2021-01-21T05:34:45Z", "path": "runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package net.runelite.client.plugins.opponentinfo;\n+\n+import com.google.inject.Guice;\n+import com.google.inject.Inject;\n+import com.google.inject.testing.fieldbinder.Bind;\n+import com.google.inject.testing.fieldbinder.BoundFieldModule;\n+import net.runelite.api.*;\n+import net.runelite.api.events.InteractingChanged;\n+import net.runelite.client.ui.overlay.OverlayManager;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class OpponentInfoPluginTest\n+{\n+    @Mock\n+    @Bind\n+    Client client;\n+\n+    @Mock\n+    @Bind\n+    OverlayManager overlayManager;\n+\n+    @Mock\n+    @Bind\n+    OpponentInfoConfig opponentInfoConfig;\n+\n+    @Mock\n+    @Bind\n+    OpponentInfoOverlay opponentInfoOverlay;\n+\n+    @Mock\n+    @Bind\n+    PlayerComparisonOverlay playerComparisonOverlay;\n+\n+    @Inject\n+    OpponentInfoPlugin opponentInfoPlugin;\n+\n+    @Before\n+    public void before()\n+    {\n+        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n+    }\n+\n+    /*\n+     * Verify that the current opponent in multi is always the npc that the player is attacking\n+     */\n+    @Test\n+    public void testAttackingEnemyInMulti() {\n+        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+        NPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n+        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\n+        // verify that there is currently no opponent\n+        assertNull(opponentInfoPlugin.getLastOpponent());\n+\n+        // some npc attacks the player\n+        InteractingChanged aggroEnemy = new InteractingChanged(aggro, thePlayer);\n+        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\n+        // verify that the current opponent is the aggressive npc\n+        assertSame(opponentInfoPlugin.getLastOpponent(), aggro);", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "687ed3f416090ccc3cada49910416cd658b8ca89", "url": "https://github.com/runelite/runelite/commit/687ed3f416090ccc3cada49910416cd658b8ca89", "message": "opponentinfo: Show health bar of actors attacking the player", "committedDate": "2021-02-03T03:45:51Z", "type": "forcePushed"}, {"oid": "ec074325d9962ad9d890634c44b037e476301614", "url": "https://github.com/runelite/runelite/commit/ec074325d9962ad9d890634c44b037e476301614", "message": "opponent info: Add simple interaction tests", "committedDate": "2021-02-10T06:58:27Z", "type": "commit"}, {"oid": "4537d451d0bf6fe6e79468a2376eba5494360bd8", "url": "https://github.com/runelite/runelite/commit/4537d451d0bf6fe6e79468a2376eba5494360bd8", "message": "opponentinfo: Show health bar of actors attacking the player", "committedDate": "2021-02-10T07:09:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTQ1MTI1OA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r581451258", "bodyText": "These tests aren't quite right; they test the behaviour of the current OpponentInfo, but not this one.  This one continues to track the lastOpponent for as long as the player is attacking or being attacked.  So, in testNpcInteractions for example, line 91 should be assertSame(npc, plugin.getLastOpponent()), because the player is being attacked by npc.  Then, on lines 96-97, the last opponent is being remembered for 5 seconds.  Finally, on line 113, even though the player has stopped attacking npc, npc is still attacking the player, so plugin.getLastTime() should be null.", "author": "chaticon", "createdAt": "2021-02-23T22:58:24Z", "path": "runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright (c) 2021, Jordan Atwood <jordan.atwood423@gmail.com>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this\n+ *    list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright notice,\n+ *    this list of conditions and the following disclaimer in the documentation\n+ *    and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package net.runelite.client.plugins.opponentinfo;\n+\n+import com.google.inject.Guice;\n+import com.google.inject.Inject;\n+import com.google.inject.testing.fieldbinder.Bind;\n+import com.google.inject.testing.fieldbinder.BoundFieldModule;\n+import net.runelite.api.Actor;\n+import net.runelite.api.Client;\n+import net.runelite.api.events.InteractingChanged;\n+import net.runelite.api.NPC;\n+import net.runelite.api.Player;\n+import net.runelite.client.ui.overlay.OverlayManager;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import org.junit.Before;\n+import org.junit.runner.RunWith;\n+import org.junit.Test;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import org.mockito.Mock;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class OpponentInfoPluginTest\n+{\n+\t@Mock\n+\t@Bind\n+\tClient client;\n+\n+\t@Mock\n+\t@Bind\n+\tOverlayManager overlayManager;\n+\n+\t@Mock\n+\t@Bind\n+\tOpponentInfoConfig config;\n+\n+\t@Mock\n+\t@Bind\n+\tOpponentInfoOverlay opponentInfoOverlay;\n+\n+\t@Mock\n+\t@Bind\n+\tPlayerComparisonOverlay playerComparisonOverlay;\n+\n+\t@Inject\n+\tOpponentInfoPlugin plugin;\n+\n+\tprivate final Player localPlayer = mock(Player.class);\n+\n+\t@Before\n+\tpublic void before()\n+\t{\n+\t\tGuice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n+\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n+\t}\n+\n+\t@Test\n+\tpublic void testNpcInteractions()\n+\t{\n+\t\tfinal NPC npc = mock(NPC.class);\n+\n+\t\tinteractingChanged(npc, localPlayer);\n+\n+\t\tassertNull(plugin.getLastOpponent());", "originalCommit": "ec074325d9962ad9d890634c44b037e476301614", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDE1NTcxOA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r584155718", "bodyText": "Can the case of target == player && opponent != null && opponent != lastOpponent ever happen? You have 4 different paths here:\n\ntarget == player && opponent == null\ntarget == player && opponent != null && opponent != lastOpponent <-- does this happen?\ntarget != player && source == lastOpponent && target == player ... obviously this cannot happen\ntarget != player && source == lastOpponent && opponent != lastOpponent\n\nI think this can't happen because it would require something to attack you while you were attacking something that also wasn't your opponent. And I don't think you can be attacking something which isn't your opponent.\nIf so, this can just be split I think into two separate ifs\nif (target == player && opponent == null) {\n// Case of something attacking you when you aren't in combat\n}\nelse if (source == lastOpponent && opponent != lastOpponent) {\n// Case of something attacking you switching off while you are not attacking it\n}", "author": "Adam-", "createdAt": "2021-02-27T16:45:14Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -134,33 +138,48 @@ else if (worldType.contains(WorldType.LEAGUE))\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tif (event.getSource() != client.getLocalPlayer())\n-\t\t{\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tActor opponent = event.getTarget();\n+\t\tfinal Actor player = client.getLocalPlayer();\n+\t\tfinal Actor source = event.getSource();\n+\t\tfinal Actor target = event.getTarget();\n \n-\t\tif (opponent == null)\n+\t\tif (source == player)\n \t\t{\n-\t\t\tlastTime = Instant.now();\n-\t\t\treturn;\n+\t\t\tif (target != null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = target;\n+\t\t\t\tlastTime = null;\n+\t\t\t}\n+\t\t\telse if (lastOpponent != null\n+\t\t\t\t&& lastOpponent.getInteracting() != player)\n+\t\t\t{\n+\t\t\t\tlastTime = Instant.now();\n+\t\t\t}\n \t\t}\n+\t\telse if (target == player", "originalCommit": "4537d451d0bf6fe6e79468a2376eba5494360bd8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6dc0e901cc5f3ee43846797a3399fa064492c38c", "url": "https://github.com/runelite/runelite/commit/6dc0e901cc5f3ee43846797a3399fa064492c38c", "message": "opponentinfo: Show health bar of actors attacking the player", "committedDate": "2021-03-02T06:57:47Z", "type": "forcePushed"}, {"oid": "8311eeb0e3b066b81cdde3b9958bab15a5e8fef2", "url": "https://github.com/runelite/runelite/commit/8311eeb0e3b066b81cdde3b9958bab15a5e8fef2", "message": "opponentinfo: Show health bar of actors attacking the player", "committedDate": "2021-03-02T07:01:37Z", "type": "commit"}, {"oid": "8311eeb0e3b066b81cdde3b9958bab15a5e8fef2", "url": "https://github.com/runelite/runelite/commit/8311eeb0e3b066b81cdde3b9958bab15a5e8fef2", "message": "opponentinfo: Show health bar of actors attacking the player", "committedDate": "2021-03-02T07:01:37Z", "type": "forcePushed"}]}