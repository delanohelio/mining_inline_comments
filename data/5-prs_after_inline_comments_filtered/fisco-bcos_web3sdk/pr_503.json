{"pr_number": 503, "pr_title": "Optimized signature algorithm  (#501)", "pr_createdAt": "2020-02-11T11:37:13Z", "pr_url": "https://github.com/FISCO-BCOS/web3sdk/pull/503", "timeline": [{"oid": "22ea83d7b87b45cb90df66c76d38fd86167d1349", "url": "https://github.com/FISCO-BCOS/web3sdk/commit/22ea83d7b87b45cb90df66c76d38fd86167d1349", "message": "Optimized signature algorithm  (#501)\n\n* add sign transfer tx test.\r\n\r\n* optimize ecdsa sign method.\r\n\r\nfix opt code.\r\n\r\nupdate opcode\r\n\r\nupdate opt ecdsa sign.\r\n\r\nupdate\r\n\r\nadd ECDSASigner.java\r\n\r\nadd x,y,r,s log info\r\n\r\n== to !=\r\n\r\nadd log info\r\n\r\nupdate\r\n\r\n* annotate the code for the test\r\n\r\n* optimize sm2 sign method.\r\n\r\n* add cache for SM2Signer object\r\n\r\n* fix ci\r\n\r\n* Add code comments", "committedDate": "2020-02-11T11:34:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU4MzE1MQ==", "url": "https://github.com/FISCO-BCOS/web3sdk/pull/503#discussion_r377583151", "bodyText": "Issue found: Use one line for each declaration, it enhances code readability.", "author": "bxq2011hust", "createdAt": "2020-02-11T11:39:16Z", "path": "src/main/java/org/fisco/bcos/web3j/crypto/ECDSASigner.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package org.fisco.bcos.web3j.crypto;\n+\n+import java.math.BigInteger;\n+import java.security.SecureRandom;\n+import org.bouncycastle.crypto.CipherParameters;\n+import org.bouncycastle.crypto.CryptoServicesRegistrar;\n+import org.bouncycastle.crypto.DSA;\n+import org.bouncycastle.crypto.params.ECDomainParameters;\n+import org.bouncycastle.crypto.params.ECKeyParameters;\n+import org.bouncycastle.crypto.params.ECPrivateKeyParameters;\n+import org.bouncycastle.crypto.params.ECPublicKeyParameters;\n+import org.bouncycastle.crypto.params.ParametersWithRandom;\n+import org.bouncycastle.crypto.signers.DSAKCalculator;\n+import org.bouncycastle.crypto.signers.RandomDSAKCalculator;\n+import org.bouncycastle.math.ec.ECAlgorithms;\n+import org.bouncycastle.math.ec.ECConstants;\n+import org.bouncycastle.math.ec.ECCurve;\n+import org.bouncycastle.math.ec.ECFieldElement;\n+import org.bouncycastle.math.ec.ECMultiplier;\n+import org.bouncycastle.math.ec.ECPoint;\n+import org.bouncycastle.math.ec.FixedPointCombMultiplier;\n+\n+/**\n+ * Copy from bc library, file: org.bouncycastle.crypto.signers.ECDSASigner Only simple\n+ * modifications(Add generateSignature2 method) were made to optimize the the calculation of recvId\n+ */\n+\n+/** EC-DSA as described in X9.62 */\n+public class ECDSASigner implements ECConstants, DSA {\n+    private final DSAKCalculator kCalculator;\n+\n+    private ECKeyParameters key;\n+    private SecureRandom random;\n+\n+    /** Default configuration, random K values. */\n+    public ECDSASigner() {\n+        this.kCalculator = new RandomDSAKCalculator();\n+    }\n+\n+    /**\n+     * Configuration with an alternate, possibly deterministic calculator of K.\n+     *\n+     * @param kCalculator a K value calculator.\n+     */\n+    public ECDSASigner(DSAKCalculator kCalculator) {\n+        this.kCalculator = kCalculator;\n+    }\n+\n+    @Override\n+    public void init(boolean forSigning, CipherParameters param) {\n+        SecureRandom providedRandom = null;\n+\n+        if (forSigning) {\n+            if (param instanceof ParametersWithRandom) {\n+                ParametersWithRandom rParam = (ParametersWithRandom) param;\n+\n+                this.key = (ECPrivateKeyParameters) rParam.getParameters();\n+                providedRandom = rParam.getRandom();\n+            } else {\n+                this.key = (ECPrivateKeyParameters) param;\n+            }\n+        } else {\n+            this.key = (ECPublicKeyParameters) param;\n+        }\n+\n+        this.random =\n+                initSecureRandom(forSigning && !kCalculator.isDeterministic(), providedRandom);\n+    }\n+\n+    // 5.3 pg 28\n+    /**\n+     * generate a signature for the given message using the key we were initialised with. For\n+     * conventional DSA the message should be a SHA-1 hash of the message of interest.\n+     *\n+     * @param message the message that will be verified later.\n+     */\n+    @Override\n+    public BigInteger[] generateSignature(byte[] message) {\n+        ECDomainParameters ec = key.getParameters();\n+        BigInteger n = ec.getN();\n+        BigInteger e = calculateE(n, message);\n+        BigInteger d = ((ECPrivateKeyParameters) key).getD();\n+\n+        if (kCalculator.isDeterministic()) {\n+            kCalculator.init(n, d, message);\n+        } else {\n+            kCalculator.init(n, random);\n+        }\n+\n+        BigInteger r, s;\n+\n+        ECMultiplier basePointMultiplier = createBasePointMultiplier();\n+\n+        // 5.3.2\n+        do // generate s\n+        {\n+            BigInteger k;\n+            do // generate r\n+            {\n+                k = kCalculator.nextK();\n+\n+                ECPoint p = basePointMultiplier.multiply(ec.getG(), k).normalize();\n+\n+                // 5.3.3\n+                r = p.getAffineXCoord().toBigInteger().mod(n);\n+            } while (r.equals(ZERO));\n+\n+            s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);\n+        } while (s.equals(ZERO));\n+\n+        return new BigInteger[] {r, s};\n+    }\n+\n+    /**\n+     * The same generateSignature with the temporary variable ECPoint P generated by the signature\n+     * process is also returned together\n+     *\n+     * @param message the message that will be verified later.\n+     */\n+    public Object[] generateSignature2(byte[] message) {\n+        ECDomainParameters ec = key.getParameters();\n+        BigInteger n = ec.getN();\n+        BigInteger e = calculateE(n, message);\n+        BigInteger d = ((ECPrivateKeyParameters) key).getD();\n+\n+        if (kCalculator.isDeterministic()) {\n+            kCalculator.init(n, d, message);\n+        } else {\n+            kCalculator.init(n, random);\n+        }\n+\n+        BigInteger r, s;", "originalCommit": "22ea83d7b87b45cb90df66c76d38fd86167d1349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU4MzE2MQ==", "url": "https://github.com/FISCO-BCOS/web3sdk/pull/503#discussion_r377583161", "bodyText": "Issue found: Possible unsafe assignment to a non-final static field in a constructor.", "author": "bxq2011hust", "createdAt": "2020-02-11T11:39:17Z", "path": "src/test/java/org/fisco/bcos/channel/test/parallel/precompile/PerformanceDTTest.java", "diffHunk": "@@ -59,6 +60,10 @@\n         initialize(groupId);\n     }\n \n+    public PerformanceDTTest() throws Exception {\n+        groupId = \"\";", "originalCommit": "22ea83d7b87b45cb90df66c76d38fd86167d1349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU4MzE2Ng==", "url": "https://github.com/FISCO-BCOS/web3sdk/pull/503#discussion_r377583166", "bodyText": "Issue found: Avoid unused local variables such as 'encryptType'.", "author": "bxq2011hust", "createdAt": "2020-02-11T11:39:19Z", "path": "src/test/java/org/fisco/bcos/channel/test/parallel/precompile/transferSign.java", "diffHunk": "@@ -0,0 +1,62 @@\n+package org.fisco.bcos.channel.test.parallel.precompile;\n+\n+import java.math.BigInteger;\n+import org.fisco.bcos.web3j.crypto.EncryptType;\n+import org.fisco.bcos.web3j.crypto.gm.sm2.SM2Sign;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** create and sign tx pressure test */\n+public class transferSign {\n+    private static Logger logger = LoggerFactory.getLogger(transferSign.class);\n+\n+    public static void Usage() {\n+        System.out.println(\" Usage:\");\n+        System.out.println(\n+                \" \\t java -cp conf/:lib/*:apps/* org.fisco.bcos.channel.test.parallel.parallelok.transferSign txCount ThreadCount GMOrNot CacheOrNot.\");\n+        System.exit(0);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length < 2) {\n+            Usage();\n+        }\n+\n+        try {\n+            BigInteger count = new BigInteger(args[0]);\n+            BigInteger threadCount = new BigInteger(args[1]);\n+            if (args.length > 2 && args[2].equals(\"gm\")) {\n+                EncryptType encryptType = new EncryptType(1);", "originalCommit": "22ea83d7b87b45cb90df66c76d38fd86167d1349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU4MzE3Mw==", "url": "https://github.com/FISCO-BCOS/web3sdk/pull/503#discussion_r377583173", "bodyText": "Issue found: Avoid reassigning parameters such as 'r'", "author": "bxq2011hust", "createdAt": "2020-02-11T11:39:20Z", "path": "src/main/java/org/fisco/bcos/web3j/crypto/ECDSASigner.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package org.fisco.bcos.web3j.crypto;\n+\n+import java.math.BigInteger;\n+import java.security.SecureRandom;\n+import org.bouncycastle.crypto.CipherParameters;\n+import org.bouncycastle.crypto.CryptoServicesRegistrar;\n+import org.bouncycastle.crypto.DSA;\n+import org.bouncycastle.crypto.params.ECDomainParameters;\n+import org.bouncycastle.crypto.params.ECKeyParameters;\n+import org.bouncycastle.crypto.params.ECPrivateKeyParameters;\n+import org.bouncycastle.crypto.params.ECPublicKeyParameters;\n+import org.bouncycastle.crypto.params.ParametersWithRandom;\n+import org.bouncycastle.crypto.signers.DSAKCalculator;\n+import org.bouncycastle.crypto.signers.RandomDSAKCalculator;\n+import org.bouncycastle.math.ec.ECAlgorithms;\n+import org.bouncycastle.math.ec.ECConstants;\n+import org.bouncycastle.math.ec.ECCurve;\n+import org.bouncycastle.math.ec.ECFieldElement;\n+import org.bouncycastle.math.ec.ECMultiplier;\n+import org.bouncycastle.math.ec.ECPoint;\n+import org.bouncycastle.math.ec.FixedPointCombMultiplier;\n+\n+/**\n+ * Copy from bc library, file: org.bouncycastle.crypto.signers.ECDSASigner Only simple\n+ * modifications(Add generateSignature2 method) were made to optimize the the calculation of recvId\n+ */\n+\n+/** EC-DSA as described in X9.62 */\n+public class ECDSASigner implements ECConstants, DSA {\n+    private final DSAKCalculator kCalculator;\n+\n+    private ECKeyParameters key;\n+    private SecureRandom random;\n+\n+    /** Default configuration, random K values. */\n+    public ECDSASigner() {\n+        this.kCalculator = new RandomDSAKCalculator();\n+    }\n+\n+    /**\n+     * Configuration with an alternate, possibly deterministic calculator of K.\n+     *\n+     * @param kCalculator a K value calculator.\n+     */\n+    public ECDSASigner(DSAKCalculator kCalculator) {\n+        this.kCalculator = kCalculator;\n+    }\n+\n+    @Override\n+    public void init(boolean forSigning, CipherParameters param) {\n+        SecureRandom providedRandom = null;\n+\n+        if (forSigning) {\n+            if (param instanceof ParametersWithRandom) {\n+                ParametersWithRandom rParam = (ParametersWithRandom) param;\n+\n+                this.key = (ECPrivateKeyParameters) rParam.getParameters();\n+                providedRandom = rParam.getRandom();\n+            } else {\n+                this.key = (ECPrivateKeyParameters) param;\n+            }\n+        } else {\n+            this.key = (ECPublicKeyParameters) param;\n+        }\n+\n+        this.random =\n+                initSecureRandom(forSigning && !kCalculator.isDeterministic(), providedRandom);\n+    }\n+\n+    // 5.3 pg 28\n+    /**\n+     * generate a signature for the given message using the key we were initialised with. For\n+     * conventional DSA the message should be a SHA-1 hash of the message of interest.\n+     *\n+     * @param message the message that will be verified later.\n+     */\n+    @Override\n+    public BigInteger[] generateSignature(byte[] message) {\n+        ECDomainParameters ec = key.getParameters();\n+        BigInteger n = ec.getN();\n+        BigInteger e = calculateE(n, message);\n+        BigInteger d = ((ECPrivateKeyParameters) key).getD();\n+\n+        if (kCalculator.isDeterministic()) {\n+            kCalculator.init(n, d, message);\n+        } else {\n+            kCalculator.init(n, random);\n+        }\n+\n+        BigInteger r, s;\n+\n+        ECMultiplier basePointMultiplier = createBasePointMultiplier();\n+\n+        // 5.3.2\n+        do // generate s\n+        {\n+            BigInteger k;\n+            do // generate r\n+            {\n+                k = kCalculator.nextK();\n+\n+                ECPoint p = basePointMultiplier.multiply(ec.getG(), k).normalize();\n+\n+                // 5.3.3\n+                r = p.getAffineXCoord().toBigInteger().mod(n);\n+            } while (r.equals(ZERO));\n+\n+            s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);\n+        } while (s.equals(ZERO));\n+\n+        return new BigInteger[] {r, s};\n+    }\n+\n+    /**\n+     * The same generateSignature with the temporary variable ECPoint P generated by the signature\n+     * process is also returned together\n+     *\n+     * @param message the message that will be verified later.\n+     */\n+    public Object[] generateSignature2(byte[] message) {\n+        ECDomainParameters ec = key.getParameters();\n+        BigInteger n = ec.getN();\n+        BigInteger e = calculateE(n, message);\n+        BigInteger d = ((ECPrivateKeyParameters) key).getD();\n+\n+        if (kCalculator.isDeterministic()) {\n+            kCalculator.init(n, d, message);\n+        } else {\n+            kCalculator.init(n, random);\n+        }\n+\n+        BigInteger r, s;\n+\n+        /** */\n+        ECPoint p;\n+\n+        ECMultiplier basePointMultiplier = createBasePointMultiplier();\n+\n+        // 5.3.2\n+        do // generate s\n+        {\n+            BigInteger k;\n+            do // generate r\n+            {\n+                k = kCalculator.nextK();\n+\n+                p = basePointMultiplier.multiply(ec.getG(), k).normalize();\n+\n+                // 5.3.3\n+                r = p.getAffineXCoord().toBigInteger().mod(n);\n+            } while (r.equals(ZERO));\n+\n+            s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);\n+        } while (s.equals(ZERO));\n+\n+        return new Object[] {r, s, p};\n+    }\n+\n+    // 5.4 pg 29\n+    /**\n+     * return true if the value r and s represent a DSA signature for the passed in message (for\n+     * standard DSA the message should be a SHA-1 hash of the real message to be verified).\n+     */\n+    @Override\n+    public boolean verifySignature(byte[] message, BigInteger r, BigInteger s) {", "originalCommit": "22ea83d7b87b45cb90df66c76d38fd86167d1349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU4MzE4NA==", "url": "https://github.com/FISCO-BCOS/web3sdk/pull/503#discussion_r377583184", "bodyText": "Issue found: Avoid unused local variables such as 'signedTransaction'.", "author": "bxq2011hust", "createdAt": "2020-02-11T11:39:21Z", "path": "src/test/java/org/fisco/bcos/channel/test/parallel/precompile/PerformanceDTTest.java", "diffHunk": "@@ -286,44 +291,148 @@\n         }\n     }\n \n+    /**\n+     * Stress tests that create tx and sign them\n+     *\n+     * @param totalSignedTxCount\n+     * @param threadC\n+     * @throws InterruptedException\n+     */\n+    public void userTransferSignTxPerfTest(BigInteger totalSignedTxCount, int threadC)\n+            throws InterruptedException {\n+\n+        ThreadPoolTaskExecutor threadPool = new ThreadPoolTaskExecutor();\n+\n+        threadPool.setCorePoolSize(threadC > 0 ? threadC : 10);\n+        threadPool.setMaxPoolSize(threadC > 0 ? threadC : 10);\n+        threadPool.setQueueCapacity(threadC > 0 ? threadC : 10);\n+        threadPool.initialize();\n+\n+        Credentials credentials = GenCredential.create();\n+\n+        TransferSignTransactionManager extendedRawTransactionManager =\n+                new TransferSignTransactionManager(\n+                        null, credentials, BigInteger.ONE, BigInteger.ONE);\n+\n+        dagTransfer =\n+                DagTransfer.load(\n+                        dagTransferAddr,\n+                        null,\n+                        extendedRawTransactionManager,\n+                        new StaticGasProvider(\n+                                new BigInteger(\"30000000\"), new BigInteger(\"30000000\")));\n+\n+        AtomicLong signed = new AtomicLong(0);\n+\n+        long startTime = System.currentTimeMillis();\n+        System.out.println(\" => \" + dateFormat.format(new Date()));\n+\n+        for (int i = 0; i < threadC; i++) {\n+            threadPool.execute(\n+                    new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            while (true) {\n+\n+                                long index = signed.incrementAndGet();\n+                                if (index > totalSignedTxCount.intValue()) {\n+                                    break;\n+                                }\n+                                DagTransferUser from = dagUserMgr.getFrom((int) index);\n+                                DagTransferUser to = dagUserMgr.getTo((int) index);\n+\n+                                Random random = new Random();\n+                                int r = random.nextInt(100) + 1;\n+                                BigInteger amount = BigInteger.valueOf(r);\n+\n+                                try {\n+                                    String signedTransaction =", "originalCommit": "22ea83d7b87b45cb90df66c76d38fd86167d1349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU4MzE5NA==", "url": "https://github.com/FISCO-BCOS/web3sdk/pull/503#discussion_r377583194", "bodyText": "Issue found: The static method name 'Usage' doesn't match '[a-z][a-zA-Z0-9]*'", "author": "bxq2011hust", "createdAt": "2020-02-11T11:39:22Z", "path": "src/test/java/org/fisco/bcos/channel/test/parallel/precompile/transferSign.java", "diffHunk": "@@ -0,0 +1,62 @@\n+package org.fisco.bcos.channel.test.parallel.precompile;\n+\n+import java.math.BigInteger;\n+import org.fisco.bcos.web3j.crypto.EncryptType;\n+import org.fisco.bcos.web3j.crypto.gm.sm2.SM2Sign;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** create and sign tx pressure test */\n+public class transferSign {\n+    private static Logger logger = LoggerFactory.getLogger(transferSign.class);\n+\n+    public static void Usage() {", "originalCommit": "22ea83d7b87b45cb90df66c76d38fd86167d1349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU4MzIwMA==", "url": "https://github.com/FISCO-BCOS/web3sdk/pull/503#discussion_r377583200", "bodyText": "Issue found: Avoid throwing raw exception types.", "author": "bxq2011hust", "createdAt": "2020-02-11T11:39:23Z", "path": "src/main/java/org/fisco/bcos/web3j/crypto/gm/sm2/SM2Sign.java", "diffHunk": "@@ -19,9 +26,90 @@\n public class SM2Sign implements SignInterface {\n     static Logger logger = LoggerFactory.getLogger(SM2Sign.class);\n \n+    /** Whether to cache objects, improve object reuse, reduce new objects */\n+    private static boolean openSM2SignerCache = false;\n+    /** SM2Signer cache list */\n+    private static ConcurrentLinkedDeque<SM2Signer> sM2SignerCache =\n+            new ConcurrentLinkedDeque<SM2Signer>();\n+\n+    private static final ECDomainParameters eCDomainParameters =\n+            new ECDomainParameters(SM2Algorithm.sm2Curve, SM2Algorithm.sm2Point, SM2Algorithm.n);\n+    private static final byte[] identValue =\n+            org.bouncycastle.util.encoders.Hex.decode(\"31323334353637383132333435363738\");\n+\n+    private static SM2Signer getSM2SM2SignerFromCache() {\n+        SM2Signer sm2Signer = null;\n+        try {\n+            sm2Signer = sM2SignerCache.pop();\n+        } catch (Exception e) {\n+            // list empty?\n+        }\n+\n+        return sm2Signer;\n+    }\n+\n+    private static void addSM2SignerToCache(SM2Signer sm2Signer) {\n+        sM2SignerCache.addLast(sm2Signer);\n+    }\n+\n     @Override\n     public Sign.SignatureData signMessage(byte[] message, ECKeyPair keyPair) {\n-        return sign(message, keyPair);\n+        return sign2(message, keyPair);\n+    }\n+\n+    /**\n+     * The new sm2 signature algorithm with better performance\n+     *\n+     * @param message\n+     * @param ecKeyPair\n+     * @return\n+     */\n+    public static Sign.SignatureData sign2(byte[] message, ECKeyPair ecKeyPair) {\n+\n+        SM2Signer sm2Signer = null;\n+        if (openSM2SignerCache) {\n+            sm2Signer = getSM2SM2SignerFromCache();\n+        }\n+\n+        if (Objects.isNull(sm2Signer)) {\n+            sm2Signer = new SM2Signer();\n+        }\n+\n+        ECPrivateKeyParameters eCPrivateKeyParameters =\n+                new ECPrivateKeyParameters(ecKeyPair.getPrivateKey(), eCDomainParameters);\n+\n+        sm2Signer.initWithCache(\n+                true,\n+                new ParametersWithID(new ParametersWithRandom(eCPrivateKeyParameters), identValue));\n+\n+        org.bouncycastle.crypto.digests.SM3Digest sm3Digest =\n+                new org.bouncycastle.crypto.digests.SM3Digest();\n+\n+        byte[] md = new byte[sm3Digest.getDigestSize()];\n+        sm3Digest.update(message, 0, message.length);\n+        sm3Digest.doFinal(md, 0);\n+\n+        sm2Signer.update(md, 0, md.length);\n+\n+        byte[] r = null;\n+        byte[] s = null;\n+        byte[] pub = null;\n+\n+        try {\n+            BigInteger[] bigIntegers = sm2Signer.generateSignature2();\n+\n+            pub = Numeric.toBytesPadded(ecKeyPair.getPublicKey(), 64);\n+            r = SM2Algorithm.getEncoded(bigIntegers[0]);\n+            s = SM2Algorithm.getEncoded(bigIntegers[1]);\n+        } catch (CryptoException e) {\n+            throw new RuntimeException(e);", "originalCommit": "22ea83d7b87b45cb90df66c76d38fd86167d1349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU4MzIxMQ==", "url": "https://github.com/FISCO-BCOS/web3sdk/pull/503#discussion_r377583211", "bodyText": "Issue found: Use one line for each declaration, it enhances code readability.", "author": "bxq2011hust", "createdAt": "2020-02-11T11:39:24Z", "path": "src/main/java/org/fisco/bcos/web3j/crypto/gm/sm2/SM2Signer.java", "diffHunk": "@@ -0,0 +1,397 @@\n+package org.fisco.bcos.web3j.crypto.gm.sm2;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.bouncycastle.asn1.ASN1EncodableVector;\n+import org.bouncycastle.asn1.ASN1Encoding;\n+import org.bouncycastle.asn1.ASN1Integer;\n+import org.bouncycastle.asn1.ASN1Primitive;\n+import org.bouncycastle.asn1.ASN1Sequence;\n+import org.bouncycastle.asn1.DERSequence;\n+import org.bouncycastle.crypto.CipherParameters;\n+import org.bouncycastle.crypto.CryptoException;\n+import org.bouncycastle.crypto.CryptoServicesRegistrar;\n+import org.bouncycastle.crypto.Digest;\n+import org.bouncycastle.crypto.Signer;\n+import org.bouncycastle.crypto.digests.SM3Digest;\n+import org.bouncycastle.crypto.params.ECDomainParameters;\n+import org.bouncycastle.crypto.params.ECKeyParameters;\n+import org.bouncycastle.crypto.params.ECPrivateKeyParameters;\n+import org.bouncycastle.crypto.params.ECPublicKeyParameters;\n+import org.bouncycastle.crypto.params.ParametersWithID;\n+import org.bouncycastle.crypto.params.ParametersWithRandom;\n+import org.bouncycastle.crypto.signers.DSAKCalculator;\n+import org.bouncycastle.crypto.signers.RandomDSAKCalculator;\n+import org.bouncycastle.math.ec.ECAlgorithms;\n+import org.bouncycastle.math.ec.ECConstants;\n+import org.bouncycastle.math.ec.ECFieldElement;\n+import org.bouncycastle.math.ec.ECMultiplier;\n+import org.bouncycastle.math.ec.ECPoint;\n+import org.bouncycastle.math.ec.FixedPointCombMultiplier;\n+import org.bouncycastle.util.Arrays;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Copy from bc library, file: org.bouncycastle.crypto.signers.SM2Signer Only simple\n+ * modifications(Add initWithCache method) were made to optimize the optimize the calculation of z\n+ */\n+\n+/** The SM2 Digital Signature algorithm. */\n+public class SM2Signer implements Signer, ECConstants {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(SM2Signer.class);\n+\n+    private final DSAKCalculator kCalculator = new RandomDSAKCalculator();\n+    private final SM3Digest digest = new SM3Digest();\n+\n+    private ECDomainParameters ecParams;\n+    private ECPoint pubPoint;\n+    private ECKeyParameters ecKey;\n+    private byte[] z;\n+\n+    /** z value cache. key: privateKey value: z value */\n+    private static Map<BigInteger, byte[]> zValueCache = new ConcurrentHashMap<>();\n+\n+    @Override\n+    public void init(boolean forSigning, CipherParameters param) {\n+        CipherParameters baseParam;\n+        byte[] userID;\n+\n+        if (param instanceof ParametersWithID) {\n+            baseParam = ((ParametersWithID) param).getParameters();\n+            userID = ((ParametersWithID) param).getID();\n+        } else {\n+            baseParam = param;\n+            userID = Hex.decode(\"31323334353637383132333435363738\"); // the default value\n+        }\n+\n+        if (forSigning) {\n+            if (baseParam instanceof ParametersWithRandom) {\n+                ParametersWithRandom rParam = (ParametersWithRandom) baseParam;\n+\n+                ecKey = (ECKeyParameters) rParam.getParameters();\n+                ecParams = ecKey.getParameters();\n+                kCalculator.init(ecParams.getN(), rParam.getRandom());\n+            } else {\n+                ecKey = (ECKeyParameters) baseParam;\n+                ecParams = ecKey.getParameters();\n+                kCalculator.init(ecParams.getN(), CryptoServicesRegistrar.getSecureRandom());\n+            }\n+\n+            pubPoint =\n+                    createBasePointMultiplier()\n+                            .multiply(ecParams.getG(), ((ECPrivateKeyParameters) ecKey).getD())\n+                            .normalize();\n+        } else {\n+            ecKey = (ECKeyParameters) baseParam;\n+            ecParams = ecKey.getParameters();\n+            pubPoint = ((ECPublicKeyParameters) ecKey).getQ();\n+        }\n+\n+        z = getZ(userID);\n+\n+        digest.update(z, 0, z.length);\n+    }\n+\n+    /**\n+     * The same as init method with better performance by adding the cache for the z value\n+     * corresponding to the privateKey value\n+     *\n+     * @param forSigning\n+     * @param param\n+     */\n+    public void initWithCache(boolean forSigning, CipherParameters param) {\n+        CipherParameters baseParam;\n+        byte[] userID;\n+\n+        if (param instanceof ParametersWithID) {\n+            baseParam = ((ParametersWithID) param).getParameters();\n+            userID = ((ParametersWithID) param).getID();\n+        } else {\n+            baseParam = param;\n+            userID = Hex.decode(\"31323334353637383132333435363738\"); // the default value\n+        }\n+\n+        if (forSigning) {\n+            if (baseParam instanceof ParametersWithRandom) {\n+                ParametersWithRandom rParam = (ParametersWithRandom) baseParam;\n+\n+                ecKey = (ECKeyParameters) rParam.getParameters();\n+                ecParams = ecKey.getParameters();\n+                kCalculator.init(ecParams.getN(), rParam.getRandom());\n+            } else {\n+                ecKey = (ECKeyParameters) baseParam;\n+                ecParams = ecKey.getParameters();\n+                kCalculator.init(ecParams.getN(), CryptoServicesRegistrar.getSecureRandom());\n+            }\n+\n+            BigInteger privateKey = ((ECPrivateKeyParameters) ecKey).getD();\n+            /** First find z value from zValueCache */\n+            z = zValueCache.get(privateKey);\n+\n+            if (Objects.isNull(z)) {\n+                // z value of privateKey not exist, calculate it and set it to the cache\n+                pubPoint =\n+                        createBasePointMultiplier()\n+                                .multiply(ecParams.getG(), ((ECPrivateKeyParameters) ecKey).getD())\n+                                .normalize();\n+                z = getZ(userID);\n+                zValueCache.put(privateKey, z);\n+                logger.info(\n+                        \" privateKey: {} z value not exist, caculate z: {}\",\n+                        privateKey,\n+                        Hex.toHexString(z));\n+            } else {\n+                if (logger.isDebugEnabled()) {\n+                    logger.debug(\" privateKey: {} z value, z: {}\", privateKey, Hex.toHexString(z));\n+                }\n+            }\n+\n+            digest.update(z, 0, z.length);\n+        } else {\n+            ecKey = (ECKeyParameters) baseParam;\n+            ecParams = ecKey.getParameters();\n+            pubPoint = ((ECPublicKeyParameters) ecKey).getQ();\n+            z = getZ(userID);\n+\n+            digest.update(z, 0, z.length);\n+        }\n+    }\n+\n+    @Override\n+    public void update(byte b) {\n+        digest.update(b);\n+    }\n+\n+    @Override\n+    public void update(byte[] in, int off, int len) {\n+        digest.update(in, off, len);\n+    }\n+\n+    public void updateMessage(byte[] in, int off, int len) {\n+        digest.reset();\n+        digest.update(in, 0, in.length);\n+        byte[] md = digestDoFinal();\n+        digest.update(z, 0, z.length);\n+        digest.update(md, 0, md.length);\n+    }\n+\n+    @Override\n+    public boolean verifySignature(byte[] signature) {\n+        try {\n+            BigInteger[] rs = derDecode(signature);\n+            if (rs != null) {\n+                return verifySignature(rs[0], rs[1]);\n+            }\n+        } catch (IOException e) {\n+        }\n+\n+        return false;\n+    }\n+\n+    @Override\n+    public void reset() {\n+        digest.reset();\n+\n+        if (z != null) {\n+            digest.update(z, 0, z.length);\n+        }\n+    }\n+\n+    @Override\n+    public byte[] generateSignature() throws CryptoException {\n+        byte[] eHash = digestDoFinal();\n+\n+        BigInteger n = ecParams.getN();\n+        BigInteger e = calculateE(eHash);\n+        BigInteger d = ((ECPrivateKeyParameters) ecKey).getD();\n+\n+        BigInteger r, s;\n+\n+        ECMultiplier basePointMultiplier = createBasePointMultiplier();\n+\n+        // 5.2.1 Draft RFC:  SM2 Public Key Algorithms\n+        do // generate s\n+        {\n+            BigInteger k;\n+            do // generate r\n+            {\n+                // A3\n+                k = kCalculator.nextK();\n+\n+                // A4\n+                ECPoint p = basePointMultiplier.multiply(ecParams.getG(), k).normalize();\n+\n+                // A5\n+                r = e.add(p.getAffineXCoord().toBigInteger()).mod(n);\n+            } while (r.equals(ZERO) || r.add(k).equals(n));\n+\n+            // A6\n+            BigInteger dPlus1ModN = d.add(ONE).modInverse(n);\n+\n+            s = k.subtract(r.multiply(d)).mod(n);\n+            s = dPlus1ModN.multiply(s).mod(n);\n+        } while (s.equals(ZERO));\n+\n+        // A7\n+        try {\n+            return derEncode(r, s);\n+        } catch (IOException ex) {\n+            throw new CryptoException(\"unable to encode signature: \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    public BigInteger[] generateSignature2() throws CryptoException {\n+        byte[] eHash = digestDoFinal();\n+\n+        BigInteger n = ecParams.getN();\n+        BigInteger e = calculateE(eHash);\n+        BigInteger d = ((ECPrivateKeyParameters) ecKey).getD();\n+\n+        BigInteger r, s;", "originalCommit": "22ea83d7b87b45cb90df66c76d38fd86167d1349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU4MzIxOA==", "url": "https://github.com/FISCO-BCOS/web3sdk/pull/503#discussion_r377583218", "bodyText": "Issue found: System.exit() should not be used in J2EE/JEE apps", "author": "bxq2011hust", "createdAt": "2020-02-11T11:39:25Z", "path": "src/test/java/org/fisco/bcos/channel/test/parallel/precompile/transferSign.java", "diffHunk": "@@ -0,0 +1,62 @@\n+package org.fisco.bcos.channel.test.parallel.precompile;\n+\n+import java.math.BigInteger;\n+import org.fisco.bcos.web3j.crypto.EncryptType;\n+import org.fisco.bcos.web3j.crypto.gm.sm2.SM2Sign;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** create and sign tx pressure test */\n+public class transferSign {\n+    private static Logger logger = LoggerFactory.getLogger(transferSign.class);\n+\n+    public static void Usage() {\n+        System.out.println(\" Usage:\");\n+        System.out.println(\n+                \" \\t java -cp conf/:lib/*:apps/* org.fisco.bcos.channel.test.parallel.parallelok.transferSign txCount ThreadCount GMOrNot CacheOrNot.\");\n+        System.exit(0);", "originalCommit": "22ea83d7b87b45cb90df66c76d38fd86167d1349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU4MzIyNQ==", "url": "https://github.com/FISCO-BCOS/web3sdk/pull/503#discussion_r377583225", "bodyText": "Issue found: The class name 'transferSign' doesn't match '[A-Z][a-zA-Z0-9]*'", "author": "bxq2011hust", "createdAt": "2020-02-11T11:39:26Z", "path": "src/test/java/org/fisco/bcos/channel/test/parallel/precompile/transferSign.java", "diffHunk": "@@ -0,0 +1,62 @@\n+package org.fisco.bcos.channel.test.parallel.precompile;\n+\n+import java.math.BigInteger;\n+import org.fisco.bcos.web3j.crypto.EncryptType;\n+import org.fisco.bcos.web3j.crypto.gm.sm2.SM2Sign;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** create and sign tx pressure test */\n+public class transferSign {", "originalCommit": "22ea83d7b87b45cb90df66c76d38fd86167d1349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU4MzIzOQ==", "url": "https://github.com/FISCO-BCOS/web3sdk/pull/503#discussion_r377583239", "bodyText": "Issue found: Class Fan-Out Complexity is 24 (max allowed is 20).", "author": "bxq2011hust", "createdAt": "2020-02-11T11:39:27Z", "path": "src/main/java/org/fisco/bcos/web3j/crypto/gm/sm2/SM2Signer.java", "diffHunk": "@@ -0,0 +1,397 @@\n+package org.fisco.bcos.web3j.crypto.gm.sm2;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.bouncycastle.asn1.ASN1EncodableVector;\n+import org.bouncycastle.asn1.ASN1Encoding;\n+import org.bouncycastle.asn1.ASN1Integer;\n+import org.bouncycastle.asn1.ASN1Primitive;\n+import org.bouncycastle.asn1.ASN1Sequence;\n+import org.bouncycastle.asn1.DERSequence;\n+import org.bouncycastle.crypto.CipherParameters;\n+import org.bouncycastle.crypto.CryptoException;\n+import org.bouncycastle.crypto.CryptoServicesRegistrar;\n+import org.bouncycastle.crypto.Digest;\n+import org.bouncycastle.crypto.Signer;\n+import org.bouncycastle.crypto.digests.SM3Digest;\n+import org.bouncycastle.crypto.params.ECDomainParameters;\n+import org.bouncycastle.crypto.params.ECKeyParameters;\n+import org.bouncycastle.crypto.params.ECPrivateKeyParameters;\n+import org.bouncycastle.crypto.params.ECPublicKeyParameters;\n+import org.bouncycastle.crypto.params.ParametersWithID;\n+import org.bouncycastle.crypto.params.ParametersWithRandom;\n+import org.bouncycastle.crypto.signers.DSAKCalculator;\n+import org.bouncycastle.crypto.signers.RandomDSAKCalculator;\n+import org.bouncycastle.math.ec.ECAlgorithms;\n+import org.bouncycastle.math.ec.ECConstants;\n+import org.bouncycastle.math.ec.ECFieldElement;\n+import org.bouncycastle.math.ec.ECMultiplier;\n+import org.bouncycastle.math.ec.ECPoint;\n+import org.bouncycastle.math.ec.FixedPointCombMultiplier;\n+import org.bouncycastle.util.Arrays;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Copy from bc library, file: org.bouncycastle.crypto.signers.SM2Signer Only simple\n+ * modifications(Add initWithCache method) were made to optimize the optimize the calculation of z\n+ */\n+\n+/** The SM2 Digital Signature algorithm. */\n+public class SM2Signer implements Signer, ECConstants {", "originalCommit": "22ea83d7b87b45cb90df66c76d38fd86167d1349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU4MzI0NQ==", "url": "https://github.com/FISCO-BCOS/web3sdk/pull/503#discussion_r377583245", "bodyText": "Issue found: Avoid unused private fields such as 'logger'.", "author": "bxq2011hust", "createdAt": "2020-02-11T11:39:29Z", "path": "src/main/java/org/fisco/bcos/web3j/crypto/ECDSASign.java", "diffHunk": "@@ -5,12 +5,23 @@\n import java.math.BigInteger;\n import org.bouncycastle.crypto.digests.SHA256Digest;\n import org.bouncycastle.crypto.params.ECPrivateKeyParameters;\n-import org.bouncycastle.crypto.signers.ECDSASigner;\n import org.bouncycastle.crypto.signers.HMacDSAKCalculator;\n+import org.bouncycastle.math.ec.ECPoint;\n+import org.bouncycastle.util.encoders.Hex;\n import org.fisco.bcos.web3j.utils.Numeric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-/** Created by websterchen on 2018/4/25. */\n public class ECDSASign implements SignInterface {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(ECDSASign.class);", "originalCommit": "22ea83d7b87b45cb90df66c76d38fd86167d1349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU4MzI1Mw==", "url": "https://github.com/FISCO-BCOS/web3sdk/pull/503#discussion_r377583253", "bodyText": "Issue found: The method 'userTransferSignTxPerfTest(BigInteger, int)' has an NPath complexity of 256", "author": "bxq2011hust", "createdAt": "2020-02-11T11:39:30Z", "path": "src/test/java/org/fisco/bcos/channel/test/parallel/precompile/PerformanceDTTest.java", "diffHunk": "@@ -286,44 +291,148 @@\n         }\n     }\n \n+    /**\n+     * Stress tests that create tx and sign them\n+     *\n+     * @param totalSignedTxCount\n+     * @param threadC\n+     * @throws InterruptedException\n+     */\n+    public void userTransferSignTxPerfTest(BigInteger totalSignedTxCount, int threadC)", "originalCommit": "22ea83d7b87b45cb90df66c76d38fd86167d1349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU4MzI1OA==", "url": "https://github.com/FISCO-BCOS/web3sdk/pull/503#discussion_r377583258", "bodyText": "Issue found: System.exit() should not be used in J2EE/JEE apps", "author": "bxq2011hust", "createdAt": "2020-02-11T11:39:31Z", "path": "src/test/java/org/fisco/bcos/channel/test/parallel/precompile/PerformanceDTTest.java", "diffHunk": "@@ -286,44 +291,148 @@\n         }\n     }\n \n+    /**\n+     * Stress tests that create tx and sign them\n+     *\n+     * @param totalSignedTxCount\n+     * @param threadC\n+     * @throws InterruptedException\n+     */\n+    public void userTransferSignTxPerfTest(BigInteger totalSignedTxCount, int threadC)\n+            throws InterruptedException {\n+\n+        ThreadPoolTaskExecutor threadPool = new ThreadPoolTaskExecutor();\n+\n+        threadPool.setCorePoolSize(threadC > 0 ? threadC : 10);\n+        threadPool.setMaxPoolSize(threadC > 0 ? threadC : 10);\n+        threadPool.setQueueCapacity(threadC > 0 ? threadC : 10);\n+        threadPool.initialize();\n+\n+        Credentials credentials = GenCredential.create();\n+\n+        TransferSignTransactionManager extendedRawTransactionManager =\n+                new TransferSignTransactionManager(\n+                        null, credentials, BigInteger.ONE, BigInteger.ONE);\n+\n+        dagTransfer =\n+                DagTransfer.load(\n+                        dagTransferAddr,\n+                        null,\n+                        extendedRawTransactionManager,\n+                        new StaticGasProvider(\n+                                new BigInteger(\"30000000\"), new BigInteger(\"30000000\")));\n+\n+        AtomicLong signed = new AtomicLong(0);\n+\n+        long startTime = System.currentTimeMillis();\n+        System.out.println(\" => \" + dateFormat.format(new Date()));\n+\n+        for (int i = 0; i < threadC; i++) {\n+            threadPool.execute(\n+                    new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            while (true) {\n+\n+                                long index = signed.incrementAndGet();\n+                                if (index > totalSignedTxCount.intValue()) {\n+                                    break;\n+                                }\n+                                DagTransferUser from = dagUserMgr.getFrom((int) index);\n+                                DagTransferUser to = dagUserMgr.getTo((int) index);\n+\n+                                Random random = new Random();\n+                                int r = random.nextInt(100) + 1;\n+                                BigInteger amount = BigInteger.valueOf(r);\n+\n+                                try {\n+                                    String signedTransaction =\n+                                            dagTransfer.userTransferSeq(\n+                                                    from.getUser(), to.getUser(), amount);\n+\n+                                    if (index % (totalSignedTxCount.longValue() / 10) == 0) {\n+                                        System.out.println(\n+                                                \"Signed transaction: \"\n+                                                        + String.valueOf(\n+                                                                index\n+                                                                        * 100\n+                                                                        / totalSignedTxCount\n+                                                                                .longValue())\n+                                                        + \"%\");\n+                                    }\n+                                } catch (Exception e) {\n+                                    e.printStackTrace();\n+                                    System.exit(-1);", "originalCommit": "22ea83d7b87b45cb90df66c76d38fd86167d1349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU4MzI2Nw==", "url": "https://github.com/FISCO-BCOS/web3sdk/pull/503#discussion_r377583267", "bodyText": "Issue found: Avoid unused local variables such as 'encryptType'.", "author": "bxq2011hust", "createdAt": "2020-02-11T11:39:32Z", "path": "src/test/java/org/fisco/bcos/channel/test/parallel/precompile/transferSign.java", "diffHunk": "@@ -0,0 +1,62 @@\n+package org.fisco.bcos.channel.test.parallel.precompile;\n+\n+import java.math.BigInteger;\n+import org.fisco.bcos.web3j.crypto.EncryptType;\n+import org.fisco.bcos.web3j.crypto.gm.sm2.SM2Sign;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** create and sign tx pressure test */\n+public class transferSign {\n+    private static Logger logger = LoggerFactory.getLogger(transferSign.class);\n+\n+    public static void Usage() {\n+        System.out.println(\" Usage:\");\n+        System.out.println(\n+                \" \\t java -cp conf/:lib/*:apps/* org.fisco.bcos.channel.test.parallel.parallelok.transferSign txCount ThreadCount GMOrNot CacheOrNot.\");\n+        System.exit(0);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length < 2) {\n+            Usage();\n+        }\n+\n+        try {\n+            BigInteger count = new BigInteger(args[0]);\n+            BigInteger threadCount = new BigInteger(args[1]);\n+            if (args.length > 2 && args[2].equals(\"gm\")) {\n+                EncryptType encryptType = new EncryptType(1);\n+            } else {\n+                EncryptType encryptType = new EncryptType(0);", "originalCommit": "22ea83d7b87b45cb90df66c76d38fd86167d1349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU4MzI3Mw==", "url": "https://github.com/FISCO-BCOS/web3sdk/pull/503#discussion_r377583273", "bodyText": "Issue found: Avoid reassigning parameters such as 'userCount'", "author": "bxq2011hust", "createdAt": "2020-02-11T11:39:33Z", "path": "src/test/java/org/fisco/bcos/channel/test/parallel/precompile/DagUserMgr.java", "diffHunk": "@@ -54,6 +55,24 @@ public DagTransferUser getNext(int idx) {\n         return userList.get((idx + 1) % userList.size());\n     }\n \n+    /**\n+     * Create the specified number of users\n+     *\n+     * @param userCount\n+     */\n+    public void createUser(int userCount) {", "originalCommit": "22ea83d7b87b45cb90df66c76d38fd86167d1349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}