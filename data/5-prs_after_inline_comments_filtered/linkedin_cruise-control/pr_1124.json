{"pr_number": 1124, "pr_title": "Skip replication factor self-healing if topic's minISR is larger than target replication factor.", "pr_createdAt": "2020-02-28T20:54:38Z", "pr_url": "https://github.com/linkedin/cruise-control/pull/1124", "timeline": [{"oid": "dd835bc64f153e56b280453b54236fc33435a0ff", "url": "https://github.com/linkedin/cruise-control/commit/dd835bc64f153e56b280453b54236fc33435a0ff", "message": "Skip replication factor self-healing if topic's minISR is larger than target replication factor.", "committedDate": "2020-02-28T22:16:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk5MjgzNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r385992835", "bodyText": "Nit: The name _badTopicsByFixability is not clear -- can we rename it to represent what bad means?", "author": "efeg", "createdAt": "2020-02-29T02:24:34Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java", "diffHunk": "@@ -31,11 +31,14 @@\n  */\n public class TopicReplicationFactorAnomaly extends TopicAnomaly {\n   protected Short _targetReplicationFactor;\n-  protected Set<String> _topicsWithBadReplicationFactor;\n+  protected Map<Boolean, Set<String>> _badTopicsByFixability;", "originalCommit": "dd835bc64f153e56b280453b54236fc33435a0ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk5MzA0NA==", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r385993044", "bodyText": "When is this expected to happen? Should we instead throw illegal state exception here?", "author": "efeg", "createdAt": "2020-02-29T02:27:27Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java", "diffHunk": "@@ -31,11 +31,14 @@\n  */\n public class TopicReplicationFactorAnomaly extends TopicAnomaly {\n   protected Short _targetReplicationFactor;\n-  protected Set<String> _topicsWithBadReplicationFactor;\n+  protected Map<Boolean, Set<String>> _badTopicsByFixability;\n   protected UpdateTopicConfigurationRunnable _updateTopicConfigurationRunnable;\n \n   @Override\n   public boolean fix() throws Exception {\n+    if (_updateTopicConfigurationRunnable == null) {\n+      return false;\n+    }", "originalCommit": "dd835bc64f153e56b280453b54236fc33435a0ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU1MDI4OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r386550289", "bodyText": "This will happen if all the topic are unfixable, i.e. target RF is smaller than minISR\nIn this case, only alert will be sent out.", "author": "kidkun", "createdAt": "2020-03-02T17:52:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk5MzA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk5MzMxMA==", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r385993310", "bodyText": "Nit: -> Short.parseShort(entry.getValue().get().get(TopicConfig.MIN_IN_SYNC_REPLICAS_CONFIG).value());", "author": "efeg", "createdAt": "2020-02-29T02:31:31Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -61,17 +76,35 @@\n       }\n     }\n     if (!topicsWithBadReplicationFactor.isEmpty()) {\n-      return Collections.singleton(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+      Map<Boolean, Set<String>> topicsByFixability = new HashMap<>(2);\n+      List<ConfigResource> topicResourcesToCheck = new ArrayList<>(topicsWithBadReplicationFactor.size());\n+      topicsWithBadReplicationFactor.forEach(t -> topicResourcesToCheck.add(new ConfigResource(ConfigResource.Type.TOPIC, t)));\n+      for (Map.Entry<ConfigResource, KafkaFuture<Config>> entry: _adminClient.describeConfigs(topicResourcesToCheck).values().entrySet()) {\n+        try {\n+          short topicMinISR = Short.valueOf(entry.getValue().get().get(TopicConfig.MIN_IN_SYNC_REPLICAS_CONFIG).value());", "originalCommit": "dd835bc64f153e56b280453b54236fc33435a0ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk5MzQ3OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r385993479", "bodyText": "Can we move this logic to a smaller function for ease of readiblity?", "author": "efeg", "createdAt": "2020-02-29T02:33:47Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -61,17 +76,35 @@\n       }\n     }\n     if (!topicsWithBadReplicationFactor.isEmpty()) {\n-      return Collections.singleton(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+      Map<Boolean, Set<String>> topicsByFixability = new HashMap<>(2);\n+      List<ConfigResource> topicResourcesToCheck = new ArrayList<>(topicsWithBadReplicationFactor.size());\n+      topicsWithBadReplicationFactor.forEach(t -> topicResourcesToCheck.add(new ConfigResource(ConfigResource.Type.TOPIC, t)));\n+      for (Map.Entry<ConfigResource, KafkaFuture<Config>> entry: _adminClient.describeConfigs(topicResourcesToCheck).values().entrySet()) {\n+        try {\n+          short topicMinISR = Short.valueOf(entry.getValue().get().get(TopicConfig.MIN_IN_SYNC_REPLICAS_CONFIG).value());\n+          if (topicMinISR > _targetReplicationFactor) {\n+            topicsByFixability.putIfAbsent(false, new HashSet<>());\n+            topicsByFixability.get(false).add(entry.getKey().name());\n+          } else {\n+            topicsByFixability.putIfAbsent(true, new HashSet<>());\n+            topicsByFixability.get(true).add(entry.getKey().name());\n+          }\n+        } catch (InterruptedException | ExecutionException e) {\n+          LOG.warn(\"Skip attempt to fix topic {}'s replication factor due to unable to retrieve its minISR config.\",\n+                   entry.getKey().name());\n+        }", "originalCommit": "dd835bc64f153e56b280453b54236fc33435a0ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU2Njk5MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r386566991", "bodyText": "I extract the logic to retrieve and cache(for following comment) minISR into a separate method", "author": "kidkun", "createdAt": "2020-03-02T18:24:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk5MzQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk5MzY3Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r385993673", "bodyText": "Ideally, we should adopt a solution that avoids calling describeConfigs every time.\nCan we cache this once, and call again only when needed? -- e.g. when new topics are added, if the cache is invalidated after a predefined timeout, or if the user explicitly invalidates the cache via admin endpoint maybe?", "author": "efeg", "createdAt": "2020-02-29T02:36:56Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -61,17 +76,35 @@\n       }\n     }\n     if (!topicsWithBadReplicationFactor.isEmpty()) {\n-      return Collections.singleton(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+      Map<Boolean, Set<String>> topicsByFixability = new HashMap<>(2);\n+      List<ConfigResource> topicResourcesToCheck = new ArrayList<>(topicsWithBadReplicationFactor.size());\n+      topicsWithBadReplicationFactor.forEach(t -> topicResourcesToCheck.add(new ConfigResource(ConfigResource.Type.TOPIC, t)));\n+      for (Map.Entry<ConfigResource, KafkaFuture<Config>> entry: _adminClient.describeConfigs(topicResourcesToCheck).values().entrySet()) {", "originalCommit": "dd835bc64f153e56b280453b54236fc33435a0ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk5MzcyNw==", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r385993727", "bodyText": "This get() on future should have a timeout to avoid blocking.", "author": "efeg", "createdAt": "2020-02-29T02:38:04Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -61,17 +76,35 @@\n       }\n     }\n     if (!topicsWithBadReplicationFactor.isEmpty()) {\n-      return Collections.singleton(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+      Map<Boolean, Set<String>> topicsByFixability = new HashMap<>(2);\n+      List<ConfigResource> topicResourcesToCheck = new ArrayList<>(topicsWithBadReplicationFactor.size());\n+      topicsWithBadReplicationFactor.forEach(t -> topicResourcesToCheck.add(new ConfigResource(ConfigResource.Type.TOPIC, t)));\n+      for (Map.Entry<ConfigResource, KafkaFuture<Config>> entry: _adminClient.describeConfigs(topicResourcesToCheck).values().entrySet()) {\n+        try {\n+          short topicMinISR = Short.valueOf(entry.getValue().get().get(TopicConfig.MIN_IN_SYNC_REPLICAS_CONFIG).value());", "originalCommit": "dd835bc64f153e56b280453b54236fc33435a0ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYxNDA3OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r386614079", "bodyText": "Nit: Not sure if we should call it METADATA_FETCH_TIMEOUT_MS. Doesn't this timeout correspond to describe config retrieval -- i.e. not metadata?", "author": "efeg", "createdAt": "2020-03-02T19:52:15Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -53,11 +62,19 @@\n   public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n   public static final Class<?> DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS = TopicReplicationFactorAnomaly.class;\n   public static final String TOPICS_WITH_BAD_REPLICATION_FACTOR_BY_FIXABILITY_CONFIG = \"topics.with.bad.replication.factor.by.fixability\";\n+  public static final String TOPIC_REPLICATION_FACTOR_MARGIN_CONFIG = \"topic.replication.factor.margin\";\n+  public static final short DEFAULT_TOPIC_REPLICATION_FACTOR_MARGIN = 1;\n+  public static final String TOPIC_MIN_ISR_RECORD_RETENTION_TIME_MS_CONFIG = \"topic.min.isr.record.retention.time.ms\";\n+  public static final long DEFAULT_TOPIC_MIN_ISR_RECORD_RETENTION_TIME_MS = 12 * 60 * 60 * 1000;\n+  private static final long METADATA_FETCH_TIMEOUT_MS = 100000L;", "originalCommit": "b886ed40bb66c3188861c38c481c937c4b17b66c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyODMyMA==", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r386728320", "bodyText": "(Applies to similar usage above) Can we avoid this extra checks and the following length-pruning by (1) ensuring that  _topicsWithBadReplicationFactorByFixability is created with an empty collection in case no unfixable / fixable topics exist and (2) using StringJoiner joiner = new StringJoiner(\",\"); as we do in GoalViolations#toString()?", "author": "efeg", "createdAt": "2020-03-03T00:13:31Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java", "diffHunk": "@@ -90,13 +90,13 @@ public String toString() {\n     sb.append(\"{Detected following topics which have at least one partition with replication factor other than \")\n       .append(_targetReplicationFactor)\n       .append(\" : {fixable : [\");\n-    if (_badTopicsByFixability.get(true) != null && !_badTopicsByFixability.get(true).isEmpty()) {\n-      _badTopicsByFixability.get(true).forEach(t -> sb.append(t).append(\", \"));\n+    if (_topicsWithBadReplicationFactorByFixability.get(true) != null && !_topicsWithBadReplicationFactorByFixability.get(true).isEmpty()) {\n+      _topicsWithBadReplicationFactorByFixability.get(true).forEach(t -> sb.append(t).append(\", \"));\n       sb.setLength(sb.length() - 2);\n     }\n     sb.append(\"], unfixable : [\");\n-    if (_badTopicsByFixability.get(false) != null && !_badTopicsByFixability.get(false).isEmpty()) {\n-      _badTopicsByFixability.get(false).forEach(t -> sb.append(t).append(\", \"));\n+    if (_topicsWithBadReplicationFactorByFixability.get(false) != null && !_topicsWithBadReplicationFactorByFixability.get(false).isEmpty()) {", "originalCommit": "b886ed40bb66c3188861c38c481c937c4b17b66c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyOTQ1OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r386729459", "bodyText": "Can we move this to a function? -- It seems to have a specific role of checking for minIsr.", "author": "efeg", "createdAt": "2020-03-03T00:17:18Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -75,23 +92,20 @@\n         }\n       }\n     }\n+    refreshTopicMinISRCache();\n     if (!topicsWithBadReplicationFactor.isEmpty()) {\n+      maybeRetrieveAndCacheTopicMinISR(topicsWithBadReplicationFactor);\n       Map<Boolean, Set<String>> topicsByFixability = new HashMap<>(2);\n-      List<ConfigResource> topicResourcesToCheck = new ArrayList<>(topicsWithBadReplicationFactor.size());\n-      topicsWithBadReplicationFactor.forEach(t -> topicResourcesToCheck.add(new ConfigResource(ConfigResource.Type.TOPIC, t)));\n-      for (Map.Entry<ConfigResource, KafkaFuture<Config>> entry: _adminClient.describeConfigs(topicResourcesToCheck).values().entrySet()) {\n-        try {\n-          short topicMinISR = Short.valueOf(entry.getValue().get().get(TopicConfig.MIN_IN_SYNC_REPLICAS_CONFIG).value());\n-          if (topicMinISR > _targetReplicationFactor) {\n+      for (String topic : topicsWithBadReplicationFactor) {\n+        if (_cachedTopicMinISR.containsKey(topic)) {\n+          short topicMinISR = _cachedTopicMinISR.get(topic).minISR();\n+          if (_targetReplicationFactor < topicMinISR + _topicReplicationFactorMargin) {\n             topicsByFixability.putIfAbsent(false, new HashSet<>());\n-            topicsByFixability.get(false).add(entry.getKey().name());\n+            topicsByFixability.get(false).add(topic);\n           } else {\n             topicsByFixability.putIfAbsent(true, new HashSet<>());\n-            topicsByFixability.get(true).add(entry.getKey().name());\n+            topicsByFixability.get(true).add(topic);", "originalCommit": "b886ed40bb66c3188861c38c481c937c4b17b66c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyOTc2OA==", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r386729768", "bodyText": "Nit: I am curious whether List is necessary here -- i.e. do we need ordering?", "author": "efeg", "createdAt": "2020-03-03T00:18:19Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -100,6 +114,42 @@\n     return Collections.emptySet();\n   }\n \n+  /**\n+   * Retrieve topic minISR config information if it is not cached locally.\n+   * @param topicsToCheck Set of topics to check.\n+   */\n+  private void maybeRetrieveAndCacheTopicMinISR(Set<String> topicsToCheck) {\n+    List<ConfigResource> topicResourcesToCheck = new ArrayList<>(topicsToCheck.size());", "originalCommit": "b886ed40bb66c3188861c38c481c937c4b17b66c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczMDU1Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r386730557", "bodyText": "Nit (just personal style note -- please feel free to ignore): I usually prefer the format X of Y rather than Y's X, which makes it easier to parse logs and JavaDoc.", "author": "efeg", "createdAt": "2020-03-03T00:20:52Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -100,6 +114,42 @@\n     return Collections.emptySet();\n   }\n \n+  /**\n+   * Retrieve topic minISR config information if it is not cached locally.\n+   * @param topicsToCheck Set of topics to check.\n+   */\n+  private void maybeRetrieveAndCacheTopicMinISR(Set<String> topicsToCheck) {\n+    List<ConfigResource> topicResourcesToCheck = new ArrayList<>(topicsToCheck.size());\n+    topicsToCheck.stream().filter(t -> !_cachedTopicMinISR.containsKey(t))\n+                          .forEach(t -> topicResourcesToCheck.add(new ConfigResource(ConfigResource.Type.TOPIC, t)));\n+    for (Map.Entry<ConfigResource, KafkaFuture<Config>> entry : _adminClient.describeConfigs(topicResourcesToCheck).values().entrySet()) {\n+      try {\n+        short topicMinISR = Short.parseShort(entry.getValue().get(METADATA_FETCH_TIMEOUT_MS, TimeUnit.MILLISECONDS)\n+                                                  .get(TopicConfig.MIN_IN_SYNC_REPLICAS_CONFIG).value());\n+        _cachedTopicMinISR.put(entry.getKey().name(), new TopicMinISREntry(topicMinISR, System.currentTimeMillis()));\n+      } catch (TimeoutException | InterruptedException | ExecutionException e) {\n+        LOG.warn(\"Skip attempt to fix topic {}'s replication factor due to unable to retrieve its minISR config.\",", "originalCommit": "b886ed40bb66c3188861c38c481c937c4b17b66c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczNDI0Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r386734247", "bodyText": "Nit: Missing space before is", "author": "efeg", "createdAt": "2020-03-03T00:33:07Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -83,11 +166,12 @@ public void configure(Map<String, ?> configs) {\n     if (_kafkaCruiseControl == null) {\n       throw new IllegalArgumentException(\"Topic replication factor anomaly finder is missing \" + KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);\n     }\n-    Short targetReplicationFactor = (Short) configs.get(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG);\n-    if (targetReplicationFactor == null) {\n-      throw new IllegalArgumentException(\"Topic replication factor anomaly finder is missing \" + SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG);\n+    try {\n+      _targetReplicationFactor = Short.parseShort((String) configs.get(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG));\n+    } catch (NumberFormatException e) {\n+      throw new IllegalArgumentException(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG +\n+                                         \"is missing or misconfigured for topic replication factor anomaly finder.\");", "originalCommit": "b886ed40bb66c3188861c38c481c937c4b17b66c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczNDUwNA==", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r386734504", "bodyText": "Should we have a sanity check here regarding the acceptable range of values in the MARGIN?", "author": "efeg", "createdAt": "2020-03-03T00:34:01Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -103,5 +187,40 @@ public void configure(Map<String, ?> configs) {\n               TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG, _topicReplicationTopicAnomalyClass));\n       }\n     }\n+    try {\n+      _topicReplicationFactorMargin = Short.parseShort((String) configs.get(TOPIC_REPLICATION_FACTOR_MARGIN_CONFIG));", "originalCommit": "b886ed40bb66c3188861c38c481c937c4b17b66c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczNTE3Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r386735176", "bodyText": "What if topicResourcesToCheck is empty -- do we need a call to adminClient in this case?", "author": "efeg", "createdAt": "2020-03-03T00:36:12Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -60,18 +92,69 @@\n         }\n       }\n     }\n+    refreshTopicMinISRCache();\n     if (!topicsWithBadReplicationFactor.isEmpty()) {\n-      return Collections.singleton(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+      maybeRetrieveAndCacheTopicMinISR(topicsWithBadReplicationFactor);\n+      Map<Boolean, Set<String>> topicsByFixability = new HashMap<>(2);\n+      for (String topic : topicsWithBadReplicationFactor) {\n+        if (_cachedTopicMinISR.containsKey(topic)) {\n+          short topicMinISR = _cachedTopicMinISR.get(topic).minISR();\n+          if (_targetReplicationFactor < topicMinISR + _topicReplicationFactorMargin) {\n+            topicsByFixability.putIfAbsent(false, new HashSet<>());\n+            topicsByFixability.get(false).add(topic);\n+          } else {\n+            topicsByFixability.putIfAbsent(true, new HashSet<>());\n+            topicsByFixability.get(true).add(topic);\n+          }\n+        }\n+      }\n+      return Collections.singleton(createTopicReplicationFactorAnomaly(topicsByFixability,\n                                                                        _targetReplicationFactor));\n     }\n     return Collections.emptySet();\n   }\n \n-  private TopicAnomaly createTopicReplicationFactorAnomaly(Set<String> topicsWithBadReplicationFactor,\n-                                                           int targetReplicationFactor) {\n+  /**\n+   * Retrieve topic minISR config information if it is not cached locally.\n+   * @param topicsToCheck Set of topics to check.\n+   */\n+  private void maybeRetrieveAndCacheTopicMinISR(Set<String> topicsToCheck) {\n+    List<ConfigResource> topicResourcesToCheck = new ArrayList<>(topicsToCheck.size());\n+    topicsToCheck.stream().filter(t -> !_cachedTopicMinISR.containsKey(t))\n+                          .forEach(t -> topicResourcesToCheck.add(new ConfigResource(ConfigResource.Type.TOPIC, t)));\n+    for (Map.Entry<ConfigResource, KafkaFuture<Config>> entry : _adminClient.describeConfigs(topicResourcesToCheck).values().entrySet()) {", "originalCommit": "b886ed40bb66c3188861c38c481c937c4b17b66c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2b9923a6f2369096405997206c685d2589ad6359", "url": "https://github.com/linkedin/cruise-control/commit/2b9923a6f2369096405997206c685d2589ad6359", "message": "Skip replication factor self-healing if topic's minISR is larger than target replication factor.", "committedDate": "2020-03-03T01:21:41Z", "type": "commit"}, {"oid": "99b0383d3f92d3282d9130edf10d0c9a21baee49", "url": "https://github.com/linkedin/cruise-control/commit/99b0383d3f92d3282d9130edf10d0c9a21baee49", "message": "Address the feedback.", "committedDate": "2020-03-03T01:21:41Z", "type": "commit"}, {"oid": "e69997b7ccae097ac425860975c2c5756aa7135f", "url": "https://github.com/linkedin/cruise-control/commit/e69997b7ccae097ac425860975c2c5756aa7135f", "message": "Address the feedback.", "committedDate": "2020-03-03T01:21:41Z", "type": "commit"}, {"oid": "e69997b7ccae097ac425860975c2c5756aa7135f", "url": "https://github.com/linkedin/cruise-control/commit/e69997b7ccae097ac425860975c2c5756aa7135f", "message": "Address the feedback.", "committedDate": "2020-03-03T01:21:41Z", "type": "forcePushed"}]}