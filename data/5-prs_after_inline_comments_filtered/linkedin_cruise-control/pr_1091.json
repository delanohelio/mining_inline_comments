{"pr_number": 1091, "pr_title": "JWT Authentication", "pr_createdAt": "2020-02-07T08:59:19Z", "pr_url": "https://github.com/linkedin/cruise-control/pull/1091", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQwMjk2NA==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r376402964", "bodyText": "nit: maybe it might be better to remove the space in BEARER variable and trim here: authorizationHeader.substring(BEARER.length()).trim()", "author": "in-park", "createdAt": "2020-02-07T13:58:35Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.nimbusds.jwt.SignedJWT;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.security.ServerAuthException;\n+import org.eclipse.jetty.security.UserAuthentication;\n+import org.eclipse.jetty.security.authentication.LoginAuthenticator;\n+import org.eclipse.jetty.server.Authentication;\n+import org.eclipse.jetty.server.UserIdentity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.function.Function;\n+\n+/**\n+ * <p>The {@link JwtAuthenticator} adds SSO capabilites to Cruise Control. The expected token is a Json Web Token (JWT).\n+ * This class should be used with {@link JwtLoginService} as the token check is carried out by that one. This class\n+ * handles redirects for unauthenticated requests and CORS preflight requests.</p>\n+ * <p>The workflow can be described with the following diagram:\n+ * <pre>\n+ *       Client -----1., 4.----> Cruise Control\n+ *        |  ^                        |\n+ *        |  |________2.______________|\n+ *        |\n+ *        |\n+ *        |------3.------------> Authentication\n+ *                                 provider\n+ * </pre>\n+ * <ol>\n+ * <li>The client makes an initial call to Cruise Control\n+ * <li>If the request doesn't have a JWT cookie by the specified cookie name, it will be redirected to the authentication\n+ *     service to obtain it. If the request is an OPTIONS request we presume it's a CORS preflight request so it'll skip\n+ *     the authentication (if the user is authenticated at this point we'll use the existing credentials).\n+ * <li>The client authenticates with the provider and obtains the SSO token.\n+ * <li>The client can present the JWT cookie to Cruise Control. Cruise Control will validate the cookie with the\n+ *    {@link JwtLoginService} by checking its signature, audience and expiration.\n+ * </ol>\n+ * </p>\n+ */\n+public class JwtAuthenticator extends LoginAuthenticator {\n+\n+  public static final String JWT_TOKEN_REQUEST_ATTRIBUTE = \"com.linkedin.kafka.cruisecontrol.JwtTokenAttribute\";\n+  static final Logger JWT_LOGGER = LoggerFactory.getLogger(\"kafka.cruisecontrol.jwt.logger\");\n+\n+  private static final String METHOD = \"JWT\";\n+  private static final String BEARER = \"Bearer \";\n+\n+  private final String _cookieName;\n+  private final Function<HttpServletRequest, String> _authenticationProviderUrlGenerator;\n+\n+  /**\n+   * Creates a new {@link JwtAuthenticator} instance with a custom authentication provider url and a cookie name that\n+   * will be populated by the authentication service with the JWT token.\n+   * @param authenticationProviderUrl is the HTTP(S) address of the authentication service. It will be used to create\n+   *                                  the redirection url. For instance <code>https://www.my-auth-service.com/websso?origin={redirectUrl}</code>\n+   *                                  will generate <code>https://www.my-auth-service.com/websso?origin=https://www.cruise-control.cc/state</code>\n+   *                                  which should redirect from <code>my-auth-service.com</code> to <code>cruise-control.cc/state</code>\n+   *                                  after obtaining the JWT token.\n+   * @param cookieName is the cookie name which will contain the cookie obtained from the authentication service.\n+   *                   <code>null</code> is an acceptable value when the token is always returned\n+   */\n+  public JwtAuthenticator(String authenticationProviderUrl, String cookieName) {\n+    _cookieName = cookieName;\n+    Function<String, Function<HttpServletRequest, String>> urlGen =\n+        url -> req -> url.replace(\"{redirectUrl}\", req.getRequestURL().toString() + getOriginalQueryString(req));\n+    _authenticationProviderUrlGenerator = urlGen.apply(authenticationProviderUrl);\n+  }\n+\n+  @Override\n+  public String getAuthMethod() {\n+    return METHOD;\n+  }\n+\n+  @Override\n+  public void prepareRequest(ServletRequest request) {\n+\n+  }\n+\n+  @Override\n+  public Authentication validateRequest(ServletRequest request, ServletResponse response, boolean mandatory) throws ServerAuthException {\n+    JWT_LOGGER.trace(\"Authentication request received for \" + request.toString());\n+    if (!(request instanceof HttpServletRequest) && !(response instanceof HttpServletResponse)) {\n+      return Authentication.UNAUTHENTICATED;\n+    }\n+\n+    String serializedJWT;\n+    HttpServletRequest req = (HttpServletRequest) request;\n+    // we'll skip the authentication for CORS preflight requests\n+    if (HttpMethod.OPTIONS.name().toLowerCase().equals(req.getMethod().toLowerCase())) {\n+      return Authentication.NOT_CHECKED;\n+    }\n+    serializedJWT = getJwtFromBearerAuthorization(req);\n+    if (serializedJWT == null) {\n+      serializedJWT = getJwtFromCookie(req);\n+    }\n+    if (serializedJWT == null) {\n+      String loginURL = _authenticationProviderUrlGenerator.apply(req);\n+      JWT_LOGGER.info(\"No JWT token found, sending redirect to \" + loginURL);\n+      try {\n+        ((HttpServletResponse) response).sendRedirect(loginURL);\n+        return Authentication.SEND_CONTINUE;\n+      } catch (IOException e) {\n+        JWT_LOGGER.error(\"Couldn't authenticate request\", e);\n+        throw new ServerAuthException(e);\n+      }\n+    } else {\n+      try {\n+        SignedJWT jwtToken = SignedJWT.parse(serializedJWT);\n+        String userName = jwtToken.getJWTClaimsSet().getSubject();\n+        request.setAttribute(JWT_TOKEN_REQUEST_ATTRIBUTE, serializedJWT);\n+        UserIdentity identity = login(userName, jwtToken, request);\n+        return new UserAuthentication(getAuthMethod(), identity);\n+      } catch (ParseException pe) {\n+        String loginURL = _authenticationProviderUrlGenerator.apply(req);\n+        JWT_LOGGER.warn(\"Unable to parse the JWT token, redirecting back to the login page\", pe);\n+        try {\n+          ((HttpServletResponse) response).sendRedirect(loginURL);\n+        } catch (IOException e) {\n+          throw new ServerAuthException(e);\n+        }\n+      }\n+    }\n+\n+    return Authentication.SEND_FAILURE;\n+  }\n+\n+  @Override\n+  public boolean secureResponse(ServletRequest request, ServletResponse response, boolean mandatory, Authentication.User validatedUser) {\n+    return true;\n+  }\n+\n+  String getJwtFromCookie(HttpServletRequest req) {\n+    String serializedJWT = null;\n+    Cookie[] cookies = req.getCookies();\n+    if (cookies != null) {\n+      for (Cookie cookie : cookies) {\n+        if (_cookieName != null && _cookieName.equals(cookie.getName())) {\n+          JWT_LOGGER.trace(_cookieName + \" cookie has been found and is being processed\");\n+          serializedJWT = cookie.getValue();\n+          break;\n+        }\n+      }\n+    }\n+    return serializedJWT;\n+  }\n+\n+  String getJwtFromBearerAuthorization(HttpServletRequest req) {\n+    String authorizationHeader = req.getHeader(HttpHeader.AUTHORIZATION.asString());\n+    if (authorizationHeader == null || !authorizationHeader.startsWith(BEARER)) {\n+      return null;\n+    } else {\n+      return authorizationHeader.substring(BEARER.length());", "originalCommit": "82ec99a3fb9e9e58f2c2d0c8fb3e049739cd7fc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA1MDgxOA==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r377050818", "bodyText": "Makes sense, will update this.", "author": "viktorsomogyi", "createdAt": "2020-02-10T13:07:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQwMjk2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQxMTMzOQ==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r376411339", "bodyText": "I am wondering if something must be done here. Isn't this needed to prevent unneccesary renewals when the UserIdentity is still valid?", "author": "in-park", "createdAt": "2020-02-07T14:16:07Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.linkedin.kafka.cruisecontrol.servlet.security.UserStoreAuthorizationService;\n+import com.nimbusds.jose.JOSEException;\n+import com.nimbusds.jose.JWSObject;\n+import com.nimbusds.jose.JWSVerifier;\n+import com.nimbusds.jose.crypto.RSASSAVerifier;\n+import com.nimbusds.jwt.SignedJWT;\n+import org.eclipse.jetty.security.DefaultIdentityService;\n+import org.eclipse.jetty.security.IdentityService;\n+import org.eclipse.jetty.security.LoginService;\n+import org.eclipse.jetty.security.authentication.AuthorizationService;\n+import org.eclipse.jetty.server.UserIdentity;\n+import org.eclipse.jetty.util.component.AbstractLifeCycle;\n+import org.eclipse.jetty.util.component.LifeCycle;\n+\n+import javax.security.auth.Subject;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.RSAPublicKey;\n+import java.text.ParseException;\n+import java.util.Date;\n+import java.util.List;\n+\n+import static com.linkedin.kafka.cruisecontrol.servlet.security.jwt.JwtAuthenticator.JWT_LOGGER;\n+\n+/**\n+ * <p>This class validates a JWT token. The token must be cryptographically encrypted an It uses an RSA public key for\n+ * validation that is expected to be stored in a PEM formatted file.</p>\n+ * <p>This class implements {@link AbstractLifeCycle} which means it is a managed bean, its lifecycle will be managed\n+ * by Jetty. It's {@link AuthorizationService} can also be an {@link AbstractLifeCycle} in which case it delegates to\n+ * this class, so opening and closing connections should be done by implementing the {@link AbstractLifeCycle} interface's\n+ * {@link #doStart()} and {@link #doStop()} methods respectively. For a simple example see\n+ * {@link UserStoreAuthorizationService}.</p>\n+ */\n+public class JwtLoginService extends AbstractLifeCycle implements LoginService {\n+\n+  private final AuthorizationService _authorizationService;\n+  private IdentityService _identityService = new DefaultIdentityService();\n+  private final RSAPublicKey _publicKey;\n+  private final List<String> _audiences;\n+\n+  public JwtLoginService(AuthorizationService authorizationService, String publicKeyLocation, List<String> audiences)\n+      throws IOException, CertificateException {\n+    this(authorizationService, readPublicKey(publicKeyLocation), audiences);\n+  }\n+\n+  public JwtLoginService(AuthorizationService authorizationService, RSAPublicKey publicKey, List<String> audiences) {\n+    _authorizationService = authorizationService;\n+    _publicKey = publicKey;\n+    _audiences = audiences;\n+  }\n+\n+  @Override\n+  protected void doStart() throws Exception {\n+    super.doStart();\n+    // The authorization service might want to start a connection or access a file\n+    if (_authorizationService instanceof LifeCycle) {\n+      ((LifeCycle) _authorizationService).start();\n+    }\n+  }\n+\n+  @Override\n+  protected void doStop() throws Exception {\n+    if (_authorizationService instanceof LifeCycle) {\n+      ((LifeCycle) _authorizationService).stop();\n+    }\n+    super.doStop();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return null;\n+  }\n+\n+  @Override\n+  public UserIdentity login(String username, Object credentials, ServletRequest request) {\n+    if (!(credentials instanceof SignedJWT)) {\n+      return null;\n+    }\n+    if (!(request instanceof HttpServletRequest)) {\n+      return null;\n+    }\n+\n+    SignedJWT jwtToken = (SignedJWT) credentials;\n+    boolean valid;\n+    try {\n+      valid = validateToken(jwtToken, username);\n+    } catch (ParseException e) {\n+      JWT_LOGGER.warn(String.format(\"%s: Couldn't parse a JWT token\", username), e);\n+      return null;\n+    }\n+    if (valid) {\n+      String serializedToken = (String) request.getAttribute(JwtAuthenticator.JWT_TOKEN_REQUEST_ATTRIBUTE);\n+      UserIdentity rolesDelegate = _authorizationService.getUserIdentity((HttpServletRequest) request, username);\n+      return getUserIdentity(jwtToken, serializedToken, username, rolesDelegate);\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public boolean validate(UserIdentity user) {", "originalCommit": "82ec99a3fb9e9e58f2c2d0c8fb3e049739cd7fc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA1MDAyMg==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r377050022", "bodyText": "Hmm, good question. On a second thought probably it would make sense to check the expiry (as audiences and signature doesn't change for an authenticated user). I'll update this.", "author": "viktorsomogyi", "createdAt": "2020-02-10T13:06:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQxMTMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQxMzQ1Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r376413453", "bodyText": "Is it ok to leave this empty? I am wondering if the framework makes use of this method to invalidate tokens.", "author": "in-park", "createdAt": "2020-02-07T14:19:57Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.linkedin.kafka.cruisecontrol.servlet.security.UserStoreAuthorizationService;\n+import com.nimbusds.jose.JOSEException;\n+import com.nimbusds.jose.JWSObject;\n+import com.nimbusds.jose.JWSVerifier;\n+import com.nimbusds.jose.crypto.RSASSAVerifier;\n+import com.nimbusds.jwt.SignedJWT;\n+import org.eclipse.jetty.security.DefaultIdentityService;\n+import org.eclipse.jetty.security.IdentityService;\n+import org.eclipse.jetty.security.LoginService;\n+import org.eclipse.jetty.security.authentication.AuthorizationService;\n+import org.eclipse.jetty.server.UserIdentity;\n+import org.eclipse.jetty.util.component.AbstractLifeCycle;\n+import org.eclipse.jetty.util.component.LifeCycle;\n+\n+import javax.security.auth.Subject;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.RSAPublicKey;\n+import java.text.ParseException;\n+import java.util.Date;\n+import java.util.List;\n+\n+import static com.linkedin.kafka.cruisecontrol.servlet.security.jwt.JwtAuthenticator.JWT_LOGGER;\n+\n+/**\n+ * <p>This class validates a JWT token. The token must be cryptographically encrypted an It uses an RSA public key for\n+ * validation that is expected to be stored in a PEM formatted file.</p>\n+ * <p>This class implements {@link AbstractLifeCycle} which means it is a managed bean, its lifecycle will be managed\n+ * by Jetty. It's {@link AuthorizationService} can also be an {@link AbstractLifeCycle} in which case it delegates to\n+ * this class, so opening and closing connections should be done by implementing the {@link AbstractLifeCycle} interface's\n+ * {@link #doStart()} and {@link #doStop()} methods respectively. For a simple example see\n+ * {@link UserStoreAuthorizationService}.</p>\n+ */\n+public class JwtLoginService extends AbstractLifeCycle implements LoginService {\n+\n+  private final AuthorizationService _authorizationService;\n+  private IdentityService _identityService = new DefaultIdentityService();\n+  private final RSAPublicKey _publicKey;\n+  private final List<String> _audiences;\n+\n+  public JwtLoginService(AuthorizationService authorizationService, String publicKeyLocation, List<String> audiences)\n+      throws IOException, CertificateException {\n+    this(authorizationService, readPublicKey(publicKeyLocation), audiences);\n+  }\n+\n+  public JwtLoginService(AuthorizationService authorizationService, RSAPublicKey publicKey, List<String> audiences) {\n+    _authorizationService = authorizationService;\n+    _publicKey = publicKey;\n+    _audiences = audiences;\n+  }\n+\n+  @Override\n+  protected void doStart() throws Exception {\n+    super.doStart();\n+    // The authorization service might want to start a connection or access a file\n+    if (_authorizationService instanceof LifeCycle) {\n+      ((LifeCycle) _authorizationService).start();\n+    }\n+  }\n+\n+  @Override\n+  protected void doStop() throws Exception {\n+    if (_authorizationService instanceof LifeCycle) {\n+      ((LifeCycle) _authorizationService).stop();\n+    }\n+    super.doStop();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return null;\n+  }\n+\n+  @Override\n+  public UserIdentity login(String username, Object credentials, ServletRequest request) {\n+    if (!(credentials instanceof SignedJWT)) {\n+      return null;\n+    }\n+    if (!(request instanceof HttpServletRequest)) {\n+      return null;\n+    }\n+\n+    SignedJWT jwtToken = (SignedJWT) credentials;\n+    boolean valid;\n+    try {\n+      valid = validateToken(jwtToken, username);\n+    } catch (ParseException e) {\n+      JWT_LOGGER.warn(String.format(\"%s: Couldn't parse a JWT token\", username), e);\n+      return null;\n+    }\n+    if (valid) {\n+      String serializedToken = (String) request.getAttribute(JwtAuthenticator.JWT_TOKEN_REQUEST_ATTRIBUTE);\n+      UserIdentity rolesDelegate = _authorizationService.getUserIdentity((HttpServletRequest) request, username);\n+      return getUserIdentity(jwtToken, serializedToken, username, rolesDelegate);\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public boolean validate(UserIdentity user) {\n+    return false;\n+  }\n+\n+  @Override\n+  public IdentityService getIdentityService() {\n+    return _identityService;\n+  }\n+\n+  @Override\n+  public void setIdentityService(IdentityService service) {\n+    _identityService = service;\n+  }\n+\n+  @Override\n+  public void logout(UserIdentity user) {\n+", "originalCommit": "82ec99a3fb9e9e58f2c2d0c8fb3e049739cd7fc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA0ODcxOQ==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r377048719", "bodyText": "This logout method I think is mostly used to implement the user initiated logout (when they click on the button) and is common with session based authentications. In this case this is a bit different because the token is issued by a third party so we need to call that to invalidate the token. Unfortunately Knox doesn't really provide a solid way for this. There is a proposal for this KIP-10 and some traces of this in their code but it doesn't seem to be a public and documented API so I didn't want to make a generic implementation based on that.", "author": "viktorsomogyi", "createdAt": "2020-02-10T13:03:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQxMzQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE3NTE3OA==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r377175178", "bodyText": "One more addition: reading up on it, JWTs can't be easily expired as they're stateless. On the provider side it's possible to set an expiration time for the cookie.\nA good article I found here: https://medium.com/devgorilla/how-to-log-out-when-using-jwt-a8c7823e8a6", "author": "viktorsomogyi", "createdAt": "2020-02-10T16:33:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQxMzQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5NTg4Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r377495882", "bodyText": "I see, cool :)", "author": "in-park", "createdAt": "2020-02-11T08:34:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQxMzQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQzMzY4Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r376433682", "bodyText": "nit:2020?", "author": "in-park", "createdAt": "2020-02-07T14:57:24Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserIdentity.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2019 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.", "originalCommit": "82ec99a3fb9e9e58f2c2d0c8fb3e049739cd7fc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQzMzgwNg==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r376433806", "bodyText": "nit:2020?", "author": "in-park", "createdAt": "2020-02-07T14:57:37Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserPrincipal.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * Copyright 2019 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.", "originalCommit": "82ec99a3fb9e9e58f2c2d0c8fb3e049739cd7fc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ1MDA0NA==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r376450044", "bodyText": "I am curious why BouncyCastle was used. Was there limitation in generating self-signed certificates with classes provided with JDK (for example CertAndKeyGen class)?", "author": "in-park", "createdAt": "2020-02-07T15:25:55Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtSecurityProviderIntegrationTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.linkedin.kafka.cruisecontrol.CruiseControlIntegrationTestHarness;\n+import com.linkedin.kafka.cruisecontrol.config.constants.WebServerConfig;\n+import org.bouncycastle.asn1.x500.X500Name;\n+import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter;\n+import org.bouncycastle.cert.jcajce.JcaX509v3CertificateBuilder;\n+import org.bouncycastle.jce.provider.BouncyCastleProvider;\n+import org.bouncycastle.operator.ContentSigner;\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.security.HashLoginService;\n+import org.eclipse.jetty.server.Request;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.UserIdentity;\n+import org.eclipse.jetty.server.handler.AbstractHandler;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.math.BigInteger;\n+import java.net.HttpURLConnection;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.cert.X509Certificate;\n+import java.util.Base64;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static com.linkedin.kafka.cruisecontrol.servlet.CruiseControlEndPoint.STATE;\n+import static org.junit.Assert.assertEquals;\n+\n+public class JwtSecurityProviderIntegrationTest extends CruiseControlIntegrationTestHarness {\n+\n+  private static final String CRUISE_CONTROL_STATE_ENDPOINT = \"kafkacruisecontrol/\" + STATE;\n+  private static final String TEST_USERNAME_KEY = \"username\";\n+  private static final String TEST_PASSWORD_KEY = \"password\";\n+  private static final String TEST_USERNAME = \"ccTestUser\";\n+  private static final String TEST_PASSWORD = \"TestPwd123\";\n+  private static final String ORIGIN = \"origin\";\n+  public static final String JWT_TOKEN_COOKIE_NAME = \"jwt_token\";\n+\n+  private final TokenGenerator.TokenAndKeys _tokenAndKeys;\n+  private final Server _tokenProviderServer;\n+  private final File _publicKeyFile;\n+\n+  class TestAuthenticatorHandler extends AbstractHandler {\n+\n+    HashLoginService _loginService;\n+\n+    TestAuthenticatorHandler() {\n+      _loginService = new HashLoginService();\n+      _loginService.setConfig(\n+          Objects.requireNonNull(this.getClass().getClassLoader().getResource(\"basic-auth.credentials\")).getPath());\n+    }\n+\n+    @Override\n+    public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException {\n+      String username = request.getParameter(TEST_USERNAME_KEY);\n+      String password = request.getParameter(TEST_PASSWORD_KEY);\n+\n+      String cruiseControlUrl = request.getParameter(ORIGIN);\n+\n+      System.out.println(String.format(\"Handling login: %s %s %s\", username, password, cruiseControlUrl));\n+      UserIdentity identity = _loginService.login(username, password, request);\n+      if (identity != null) {\n+        response.addCookie(new Cookie(JWT_TOKEN_COOKIE_NAME, _tokenAndKeys.token()));\n+      } else {\n+        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n+      }\n+    }\n+\n+    @Override\n+    protected void doStart() throws Exception {\n+      super.doStart();\n+      _loginService.start();\n+    }\n+\n+    @Override\n+    protected void doStop() throws Exception {\n+      _loginService.stop();\n+      super.doStop();\n+    }\n+  }\n+\n+  public JwtSecurityProviderIntegrationTest() throws Exception {\n+    _tokenAndKeys = TokenGenerator.generateToken(TEST_USERNAME);\n+    _publicKeyFile = createCertificate(_tokenAndKeys);\n+    _tokenProviderServer = new Server(0);\n+    _tokenProviderServer.setHandler(new TestAuthenticatorHandler());\n+  }\n+\n+  /**\n+   * Starts the token provider and the Kafka environment before test\n+   * @throws Exception\n+   */\n+  @Before\n+  public void setup() throws Exception {\n+    _tokenProviderServer.start();\n+    super.start();\n+  }\n+\n+  /**\n+   * Stops the token provider and the Kafka environment after test\n+   * @throws Exception\n+   */\n+  @After\n+  public void teardown() throws Exception {\n+    super.stop();\n+    _tokenProviderServer.stop();\n+  }\n+\n+  @Override\n+  protected Map<String, Object> withConfigs() {\n+    Map<String, Object> securityConfigs = new HashMap<>();\n+    securityConfigs.put(WebServerConfig.WEBSERVER_SECURITY_ENABLE_CONFIG, true);\n+    securityConfigs.put(WebServerConfig.WEBSERVER_SECURITY_PROVIDER_CONFIG, JwtSecurityProvider.class);\n+    securityConfigs.put(WebServerConfig.JWT_AUTHENTICATION_PROVIDER_URL_CONFIG,\n+        _tokenProviderServer.getURI().toString() + \"?\" +\n+            TEST_USERNAME_KEY + \"=\" + TEST_USERNAME +\n+            \"&\" + TEST_PASSWORD_KEY + \"=\" + TEST_PASSWORD +\n+            \"&origin={redirectUrl}\");\n+    securityConfigs.put(WebServerConfig.WEBSERVER_AUTH_CREDENTIALS_FILE_CONFIG,\n+        Objects.requireNonNull(this.getClass().getClassLoader().getResource(\"jwt-auth.credentials\")).getPath());\n+    securityConfigs.put(WebServerConfig.JWT_COOKIE_NAME_CONFIG, JWT_TOKEN_COOKIE_NAME);\n+    securityConfigs.put(WebServerConfig.JWT_AUTH_CERTIFICATE_LOCATION_CONFIG, _publicKeyFile.getAbsolutePath());\n+\n+    return securityConfigs;\n+  }\n+\n+  @Test\n+  public void testSuccessfulLogin() throws Exception {\n+    HttpURLConnection stateEndpointConnection = (HttpURLConnection) new URI(_app.serverUrl())\n+        .resolve(CRUISE_CONTROL_STATE_ENDPOINT).toURL().openConnection();\n+    String cookie = stateEndpointConnection.getHeaderField(HttpHeader.SET_COOKIE.asString());\n+    stateEndpointConnection = (HttpURLConnection) new URI(_app.serverUrl())\n+        .resolve(CRUISE_CONTROL_STATE_ENDPOINT).toURL().openConnection();\n+    stateEndpointConnection.setRequestProperty(HttpHeader.COOKIE.asString(), cookie);\n+    assertEquals(HttpServletResponse.SC_OK, stateEndpointConnection.getResponseCode());\n+  }\n+\n+  private File createCertificate(TokenGenerator.TokenAndKeys tokenAndKeys) throws Exception {\n+    String subjectDN = \"C=US, ST=California, L=Santa Clara, O=LinkedIn, CN=localhost\";\n+    Provider bcProvider = new BouncyCastleProvider();", "originalCommit": "82ec99a3fb9e9e58f2c2d0c8fb3e049739cd7fc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzAzMTU2NA==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r377031564", "bodyText": "There aren't really good classes in plain Java to work with on this level (as far as I saw). CertAndKeyGen is unfortunately in a Sun package and therefore belongs to Oracle so I think we should avoid it as it isn't compatible with OpenJDK.\nAdditionally to this, BouncyCastle was already a dependency of the metrics reporter tests so I thought it's not a too big leap to use this here.", "author": "viktorsomogyi", "createdAt": "2020-02-10T12:25:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ1MDA0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5NjEyNw==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r377496127", "bodyText": "Ah ok, understood.", "author": "in-park", "createdAt": "2020-02-11T08:35:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ1MDA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYwNjczOA==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383606738", "bodyText": "Can we add missing public static final String DEFAULT_XXX for each config? -- please see the HEAD version of this file.", "author": "efeg", "createdAt": "2020-02-25T01:11:20Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/WebServerConfig.java", "diffHunk": "@@ -220,6 +220,38 @@ private WebServerConfig() {\n   public static final String WEBSERVER_SSL_PROTOCOL_CONFIG = \"webserver.ssl.protocol\";\n   private static final String WEBSERVER_SSL_PROTOCOL_DOC = \"Sets the SSL protocol to use. By default it's TLS.\";\n \n+  /**\n+   * <code>jwt.authentication.provider.url</code>\n+   */\n+  public static final String JWT_AUTHENTICATION_PROVIDER_URL_CONFIG = \"jwt.authentication.provider.url\";\n+  private static final String JWT_AUTHENTICATION_PROVIDER_URL_DOCS = \"This is an endpoint of the token issuer. \" +\n+      \"Requests without tokens will be redirected to this endpoint for authentication. The given url can contain \" +\n+      \"the {redirectUrl} string which is an instruction to the authentication service to redirect to the original \" +\n+      \"Cruise Control URL after a successful login. For instance www.my-auth.service.com/websso?origin={redirectUrl}.\";\n+\n+  /**\n+   * <code>jwt.cookie.name</code>\n+   */\n+  public static final String JWT_COOKIE_NAME_CONFIG = \"jwt.cookie.name\";\n+  private static final String JWT_COOKIE_NAME_DOCS = \"Cruise Control expects issued tokens to be forwarded in a cookie. \" +\n+      \"This config specifies which one will contain the token.\";\n+\n+  /**\n+   * <code>jwt.auth.certificate.location</code>\n+   */\n+  public static final String JWT_AUTH_CERTIFICATE_LOCATION_CONFIG = \"jwt.auth.certificate.location\";\n+  private static final String JWT_AUTH_CERTIFICATE_LOCATION_DOCS = \"A private key is used to sign the JWT token by the \" +\n+      \"authentication service and its public key pair is used to validate the signature in the token. This config points \" +\n+      \"to the location of the file containing that public key.\";\n+\n+  /**\n+   * <code>jwt.expected.audiences</code>\n+   */\n+  public static final String JWT_EXPECTED_AUDIENCES_CONFIG = \"jwt.expected.audiences\";\n+  private static final String JWT_EXPECTED_AUDIENCES_DOCS = \"A comma separated list of audiences that Cruise Control accepts. \" +\n+      \"Audience is a way for the issuer to indicate what entities the token is intended for. The default value is null, \" +\n+      \"which means all audiences are accepted.\";\n+", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYwNzE0Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383607142", "bodyText": "Nit: For consistency, can we change XXX_DOCS to XXX_DOC?", "author": "efeg", "createdAt": "2020-02-25T01:12:47Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/WebServerConfig.java", "diffHunk": "@@ -220,6 +220,38 @@ private WebServerConfig() {\n   public static final String WEBSERVER_SSL_PROTOCOL_CONFIG = \"webserver.ssl.protocol\";\n   private static final String WEBSERVER_SSL_PROTOCOL_DOC = \"Sets the SSL protocol to use. By default it's TLS.\";\n \n+  /**\n+   * <code>jwt.authentication.provider.url</code>\n+   */\n+  public static final String JWT_AUTHENTICATION_PROVIDER_URL_CONFIG = \"jwt.authentication.provider.url\";\n+  private static final String JWT_AUTHENTICATION_PROVIDER_URL_DOCS = \"This is an endpoint of the token issuer. \" +\n+      \"Requests without tokens will be redirected to this endpoint for authentication. The given url can contain \" +\n+      \"the {redirectUrl} string which is an instruction to the authentication service to redirect to the original \" +\n+      \"Cruise Control URL after a successful login. For instance www.my-auth.service.com/websso?origin={redirectUrl}.\";\n+\n+  /**\n+   * <code>jwt.cookie.name</code>\n+   */\n+  public static final String JWT_COOKIE_NAME_CONFIG = \"jwt.cookie.name\";\n+  private static final String JWT_COOKIE_NAME_DOCS = \"Cruise Control expects issued tokens to be forwarded in a cookie. \" +\n+      \"This config specifies which one will contain the token.\";\n+\n+  /**\n+   * <code>jwt.auth.certificate.location</code>\n+   */\n+  public static final String JWT_AUTH_CERTIFICATE_LOCATION_CONFIG = \"jwt.auth.certificate.location\";\n+  private static final String JWT_AUTH_CERTIFICATE_LOCATION_DOCS = \"A private key is used to sign the JWT token by the \" +\n+      \"authentication service and its public key pair is used to validate the signature in the token. This config points \" +\n+      \"to the location of the file containing that public key.\";\n+\n+  /**\n+   * <code>jwt.expected.audiences</code>\n+   */\n+  public static final String JWT_EXPECTED_AUDIENCES_CONFIG = \"jwt.expected.audiences\";\n+  private static final String JWT_EXPECTED_AUDIENCES_DOCS = \"A comma separated list of audiences that Cruise Control accepts. \" +", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyMTE4NA==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383621184", "bodyText": "It is not clear why (1) BasicSecurityProvider, (2) DefaultRoleSecurityProvider, or (3) JwtSecurityProvider have throws ServletException in their method signature.", "author": "efeg", "createdAt": "2020-02-25T02:07:21Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/BasicSecurityProvider.java", "diffHunk": "@@ -20,9 +22,9 @@\n   private String _userCredentialsFile;\n \n   @Override\n-  public void init(KafkaCruiseControlConfig config) {\n+  public void init(KafkaCruiseControlConfig config) throws ServletException {", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY0NDMwNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r385644305", "bodyText": "Fair thought, they shouldn't.", "author": "viktorsomogyi", "createdAt": "2020-02-28T11:24:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyMTE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyMTY2Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383621662", "bodyText": "Nit: low amount of users -> low number of users", "author": "efeg", "createdAt": "2020-02-25T02:09:20Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/UserStoreAuthorizationService.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security;\n+\n+import org.eclipse.jetty.security.PropertyUserStore;\n+import org.eclipse.jetty.security.UserStore;\n+import org.eclipse.jetty.security.authentication.AuthorizationService;\n+import org.eclipse.jetty.server.UserIdentity;\n+import org.eclipse.jetty.util.component.AbstractLifeCycle;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * Can be used for authorization scenarios where a file can be created in a secure location with a relatively\n+ * low amount of users. It follows the <code>username: password [,rolename ...]</code> format which corresponds to", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyMjI5OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383622299", "bodyText": "Typo: SSO capabilites -> SSO capabilities", "author": "efeg", "createdAt": "2020-02-25T02:12:08Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.nimbusds.jwt.SignedJWT;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.security.ServerAuthException;\n+import org.eclipse.jetty.security.UserAuthentication;\n+import org.eclipse.jetty.security.authentication.LoginAuthenticator;\n+import org.eclipse.jetty.server.Authentication;\n+import org.eclipse.jetty.server.UserIdentity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.function.Function;\n+\n+/**\n+ * <p>The {@link JwtAuthenticator} adds SSO capabilites to Cruise Control. The expected token is a Json Web Token (JWT).", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyMzQxNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383623415", "bodyText": "Nit: Can we move the hardcoded String (i.e. \"{redirectUrl}\") to a static variable?", "author": "efeg", "createdAt": "2020-02-25T02:16:33Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.nimbusds.jwt.SignedJWT;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.security.ServerAuthException;\n+import org.eclipse.jetty.security.UserAuthentication;\n+import org.eclipse.jetty.security.authentication.LoginAuthenticator;\n+import org.eclipse.jetty.server.Authentication;\n+import org.eclipse.jetty.server.UserIdentity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.function.Function;\n+\n+/**\n+ * <p>The {@link JwtAuthenticator} adds SSO capabilites to Cruise Control. The expected token is a Json Web Token (JWT).\n+ * This class should be used with {@link JwtLoginService} as the token check is carried out by that one. This class\n+ * handles redirects for unauthenticated requests and CORS preflight requests.</p>\n+ * <p>The workflow can be described with the following diagram:\n+ * <pre>\n+ *       Client -----1., 4.----> Cruise Control\n+ *        |  ^                        |\n+ *        |  |________2.______________|\n+ *        |\n+ *        |\n+ *        |------3.------------> Authentication\n+ *                                 provider\n+ * </pre>\n+ * <ol>\n+ * <li>The client makes an initial call to Cruise Control\n+ * <li>If the request doesn't have a JWT cookie by the specified cookie name, it will be redirected to the authentication\n+ *     service to obtain it. If the request is an OPTIONS request we presume it's a CORS preflight request so it'll skip\n+ *     the authentication (if the user is authenticated at this point we'll use the existing credentials).\n+ * <li>The client authenticates with the provider and obtains the SSO token.\n+ * <li>The client can present the JWT cookie to Cruise Control. Cruise Control will validate the cookie with the\n+ *    {@link JwtLoginService} by checking its signature, audience and expiration.\n+ * </ol>\n+ * </p>\n+ */\n+public class JwtAuthenticator extends LoginAuthenticator {\n+\n+  public static final String JWT_TOKEN_REQUEST_ATTRIBUTE = \"com.linkedin.kafka.cruisecontrol.JwtTokenAttribute\";\n+  static final Logger JWT_LOGGER = LoggerFactory.getLogger(\"kafka.cruisecontrol.jwt.logger\");\n+\n+  private static final String METHOD = \"JWT\";\n+  private static final String BEARER = \"Bearer\";\n+\n+  private final String _cookieName;\n+  private final Function<HttpServletRequest, String> _authenticationProviderUrlGenerator;\n+\n+  /**\n+   * Creates a new {@link JwtAuthenticator} instance with a custom authentication provider url and a cookie name that\n+   * will be populated by the authentication service with the JWT token.\n+   * @param authenticationProviderUrl is the HTTP(S) address of the authentication service. It will be used to create\n+   *                                  the redirection url. For instance <code>https://www.my-auth-service.com/websso?origin={redirectUrl}</code>\n+   *                                  will generate <code>https://www.my-auth-service.com/websso?origin=https://www.cruise-control.cc/state</code>\n+   *                                  which should redirect from <code>my-auth-service.com</code> to <code>cruise-control.cc/state</code>\n+   *                                  after obtaining the JWT token.\n+   * @param cookieName is the cookie name which will contain the cookie obtained from the authentication service.\n+   *                   <code>null</code> is an acceptable value when the token is always returned\n+   */\n+  public JwtAuthenticator(String authenticationProviderUrl, String cookieName) {\n+    _cookieName = cookieName;\n+    Function<String, Function<HttpServletRequest, String>> urlGen =\n+        url -> req -> url.replace(\"{redirectUrl}\", req.getRequestURL().toString() + getOriginalQueryString(req));", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyNDg2Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383624862", "bodyText": "encrypted an It uses  -> broken sentence.", "author": "efeg", "createdAt": "2020-02-25T02:22:33Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.linkedin.kafka.cruisecontrol.servlet.security.UserStoreAuthorizationService;\n+import com.nimbusds.jose.JOSEException;\n+import com.nimbusds.jose.JWSObject;\n+import com.nimbusds.jose.JWSVerifier;\n+import com.nimbusds.jose.crypto.RSASSAVerifier;\n+import com.nimbusds.jwt.JWTClaimsSet;\n+import com.nimbusds.jwt.SignedJWT;\n+import org.eclipse.jetty.security.DefaultIdentityService;\n+import org.eclipse.jetty.security.IdentityService;\n+import org.eclipse.jetty.security.LoginService;\n+import org.eclipse.jetty.security.authentication.AuthorizationService;\n+import org.eclipse.jetty.server.UserIdentity;\n+import org.eclipse.jetty.util.component.AbstractLifeCycle;\n+import org.eclipse.jetty.util.component.LifeCycle;\n+\n+import javax.security.auth.Subject;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.RSAPublicKey;\n+import java.text.ParseException;\n+import java.time.Clock;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static com.linkedin.kafka.cruisecontrol.servlet.security.jwt.JwtAuthenticator.JWT_LOGGER;\n+\n+/**\n+ * <p>This class validates a JWT token. The token must be cryptographically encrypted an It uses an RSA public key for", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyNTI2Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383625267", "bodyText": "Nit: For code style consistency, can we move this initialization to the constructor?", "author": "efeg", "createdAt": "2020-02-25T02:24:16Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.linkedin.kafka.cruisecontrol.servlet.security.UserStoreAuthorizationService;\n+import com.nimbusds.jose.JOSEException;\n+import com.nimbusds.jose.JWSObject;\n+import com.nimbusds.jose.JWSVerifier;\n+import com.nimbusds.jose.crypto.RSASSAVerifier;\n+import com.nimbusds.jwt.JWTClaimsSet;\n+import com.nimbusds.jwt.SignedJWT;\n+import org.eclipse.jetty.security.DefaultIdentityService;\n+import org.eclipse.jetty.security.IdentityService;\n+import org.eclipse.jetty.security.LoginService;\n+import org.eclipse.jetty.security.authentication.AuthorizationService;\n+import org.eclipse.jetty.server.UserIdentity;\n+import org.eclipse.jetty.util.component.AbstractLifeCycle;\n+import org.eclipse.jetty.util.component.LifeCycle;\n+\n+import javax.security.auth.Subject;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.RSAPublicKey;\n+import java.text.ParseException;\n+import java.time.Clock;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static com.linkedin.kafka.cruisecontrol.servlet.security.jwt.JwtAuthenticator.JWT_LOGGER;\n+\n+/**\n+ * <p>This class validates a JWT token. The token must be cryptographically encrypted an It uses an RSA public key for\n+ * validation that is expected to be stored in a PEM formatted file.</p>\n+ * <p>This class implements {@link AbstractLifeCycle} which means it is a managed bean, its lifecycle will be managed\n+ * by Jetty. It's {@link AuthorizationService} can also be an {@link AbstractLifeCycle} in which case it delegates to\n+ * this class, so opening and closing connections should be done by implementing the {@link AbstractLifeCycle} interface's\n+ * {@link #doStart()} and {@link #doStop()} methods respectively. For a simple example see\n+ * {@link UserStoreAuthorizationService}.</p>\n+ * <p>The login service also validates expiration time of the token and it expects the token to contain the expiration\n+ * in Unix epoch time format in UTC.</p>\n+ */\n+public class JwtLoginService extends AbstractLifeCycle implements LoginService {\n+\n+  private final AuthorizationService _authorizationService;\n+  private IdentityService _identityService = new DefaultIdentityService();", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY1NzY4Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r385657687", "bodyText": "Sure", "author": "viktorsomogyi", "createdAt": "2020-02-28T11:58:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyNTI2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyNjA0Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383626047", "bodyText": "Nit: Can we move the certificate type to a static variable?", "author": "efeg", "createdAt": "2020-02-25T02:27:24Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtLoginService.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.linkedin.kafka.cruisecontrol.servlet.security.UserStoreAuthorizationService;\n+import com.nimbusds.jose.JOSEException;\n+import com.nimbusds.jose.JWSObject;\n+import com.nimbusds.jose.JWSVerifier;\n+import com.nimbusds.jose.crypto.RSASSAVerifier;\n+import com.nimbusds.jwt.JWTClaimsSet;\n+import com.nimbusds.jwt.SignedJWT;\n+import org.eclipse.jetty.security.DefaultIdentityService;\n+import org.eclipse.jetty.security.IdentityService;\n+import org.eclipse.jetty.security.LoginService;\n+import org.eclipse.jetty.security.authentication.AuthorizationService;\n+import org.eclipse.jetty.server.UserIdentity;\n+import org.eclipse.jetty.util.component.AbstractLifeCycle;\n+import org.eclipse.jetty.util.component.LifeCycle;\n+\n+import javax.security.auth.Subject;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.RSAPublicKey;\n+import java.text.ParseException;\n+import java.time.Clock;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static com.linkedin.kafka.cruisecontrol.servlet.security.jwt.JwtAuthenticator.JWT_LOGGER;\n+\n+/**\n+ * <p>This class validates a JWT token. The token must be cryptographically encrypted an It uses an RSA public key for\n+ * validation that is expected to be stored in a PEM formatted file.</p>\n+ * <p>This class implements {@link AbstractLifeCycle} which means it is a managed bean, its lifecycle will be managed\n+ * by Jetty. It's {@link AuthorizationService} can also be an {@link AbstractLifeCycle} in which case it delegates to\n+ * this class, so opening and closing connections should be done by implementing the {@link AbstractLifeCycle} interface's\n+ * {@link #doStart()} and {@link #doStop()} methods respectively. For a simple example see\n+ * {@link UserStoreAuthorizationService}.</p>\n+ * <p>The login service also validates expiration time of the token and it expects the token to contain the expiration\n+ * in Unix epoch time format in UTC.</p>\n+ */\n+public class JwtLoginService extends AbstractLifeCycle implements LoginService {\n+\n+  private final AuthorizationService _authorizationService;\n+  private IdentityService _identityService = new DefaultIdentityService();\n+  private final RSAPublicKey _publicKey;\n+  private final List<String> _audiences;\n+  private Clock _clock;\n+\n+  public JwtLoginService(AuthorizationService authorizationService, String publicKeyLocation, List<String> audiences)\n+      throws IOException, CertificateException {\n+    this(authorizationService, readPublicKey(publicKeyLocation), audiences);\n+  }\n+\n+  public JwtLoginService(AuthorizationService authorizationService, RSAPublicKey publicKey, List<String> audiences) {\n+    this(authorizationService, publicKey, audiences, Clock.systemUTC());\n+  }\n+\n+  public JwtLoginService(AuthorizationService authorizationService, RSAPublicKey publicKey, List<String> audiences, Clock clock) {\n+    _authorizationService = authorizationService;\n+    _publicKey = publicKey;\n+    _audiences = audiences;\n+    _clock = clock;\n+  }\n+\n+  @Override\n+  protected void doStart() throws Exception {\n+    super.doStart();\n+    // The authorization service might want to start a connection or access a file\n+    if (_authorizationService instanceof LifeCycle) {\n+      ((LifeCycle) _authorizationService).start();\n+    }\n+  }\n+\n+  @Override\n+  protected void doStop() throws Exception {\n+    if (_authorizationService instanceof LifeCycle) {\n+      ((LifeCycle) _authorizationService).stop();\n+    }\n+    super.doStop();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return null;\n+  }\n+\n+  @Override\n+  public UserIdentity login(String username, Object credentials, ServletRequest request) {\n+    if (!(credentials instanceof SignedJWT)) {\n+      return null;\n+    }\n+    if (!(request instanceof HttpServletRequest)) {\n+      return null;\n+    }\n+\n+    SignedJWT jwtToken = (SignedJWT) credentials;\n+    JWTClaimsSet claimsSet;\n+    boolean valid;\n+    try {\n+      claimsSet = jwtToken.getJWTClaimsSet();\n+      valid = validateToken(jwtToken, claimsSet, username);\n+    } catch (ParseException e) {\n+      JWT_LOGGER.warn(String.format(\"%s: Couldn't parse a JWT token\", username), e);\n+      return null;\n+    }\n+    if (valid) {\n+      String serializedToken = (String) request.getAttribute(JwtAuthenticator.JWT_TOKEN_REQUEST_ATTRIBUTE);\n+      UserIdentity rolesDelegate = _authorizationService.getUserIdentity((HttpServletRequest) request, username);\n+      return getUserIdentity(jwtToken, claimsSet, serializedToken, username, rolesDelegate);\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public boolean validate(UserIdentity user) {\n+    Set<JWTClaimsSet> claims = user.getSubject().getPrivateCredentials(JWTClaimsSet.class);\n+    return !claims.isEmpty() && claims.stream().allMatch(this::validateExpiration);\n+  }\n+\n+  @Override\n+  public IdentityService getIdentityService() {\n+    return _identityService;\n+  }\n+\n+  @Override\n+  public void setIdentityService(IdentityService service) {\n+    _identityService = service;\n+  }\n+\n+  @Override\n+  public void logout(UserIdentity user) {\n+\n+  }\n+\n+  // visible for testing\n+  void setClock(Clock newClock) {\n+    _clock = newClock;\n+  }\n+\n+  private boolean validateToken(SignedJWT jwtToken, JWTClaimsSet claimsSet, String username) {\n+    boolean sigValid = validateSignature(jwtToken);\n+    if (!sigValid) {\n+      JWT_LOGGER.warn(String.format(\"%s: Signature could not be verified\", username));\n+    }\n+    boolean audValid = validateAudiences(claimsSet);\n+    if (!audValid) {\n+      JWT_LOGGER.warn(String.format(\"%s: Audience validation failed\", username));\n+    }\n+    boolean expValid = validateExpiration(claimsSet);\n+    if (!expValid) {\n+      JWT_LOGGER.warn(String.format(\"%s: Expiration validation failed\", username));\n+    }\n+\n+    return sigValid && audValid && expValid;\n+  }\n+\n+  private boolean validateSignature(SignedJWT jwtToken) {\n+    if (JWSObject.State.SIGNED != jwtToken.getState() || jwtToken.getSignature() == null) {\n+      return false;\n+    }\n+    JWSVerifier verifier = new RSASSAVerifier(_publicKey);\n+    try {\n+      return jwtToken.verify(verifier);\n+    } catch (JOSEException e) {\n+      JWT_LOGGER.warn(\"Couldn't verify the signature of a token\", e);\n+      return false;\n+    }\n+  }\n+\n+  private boolean validateAudiences(JWTClaimsSet claimsSet) {\n+    if (_audiences == null) {\n+      return true;\n+    }\n+    List<String> tokenAudienceList = claimsSet.getAudience();\n+    for (String aud : tokenAudienceList) {\n+      if (_audiences.contains(aud)) {\n+        JWT_LOGGER.trace(\"JWT token audience has been successfully validated\");\n+        return true;\n+      }\n+    }\n+    JWT_LOGGER.trace(\"Couldn't find a valid audience\");\n+    return false;\n+  }\n+\n+  private boolean validateExpiration(JWTClaimsSet claimsSet) {\n+    Date expires = claimsSet.getExpirationTime();\n+    return expires == null || _clock.instant().isBefore(expires.toInstant());\n+  }\n+\n+  private static RSAPublicKey readPublicKey(String location) throws CertificateException, IOException {\n+    byte[] publicKeyBytes = Files.readAllBytes(Paths.get(location));\n+    CertificateFactory fact = CertificateFactory.getInstance(\"X.509\");", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyNzA0Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383627046", "bodyText": "Should we add any sanity checks regarding the value of these configs -- e.g. maybe under KafkaCruiseControlConfig#sanityCheckSecurity?", "author": "efeg", "createdAt": "2020-02-25T02:30:41Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtSecurityProvider.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.WebServerConfig;\n+import com.linkedin.kafka.cruisecontrol.servlet.security.DefaultRoleSecurityProvider;\n+import com.linkedin.kafka.cruisecontrol.servlet.security.UserStoreAuthorizationService;\n+import org.eclipse.jetty.security.Authenticator;\n+import org.eclipse.jetty.security.LoginService;\n+import org.eclipse.jetty.security.authentication.AuthorizationService;\n+\n+import javax.servlet.ServletException;\n+import java.io.IOException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+\n+/**\n+ * A security provider implementation for JWT based authentication. It has to be configured with\n+ * <ul>\n+ *   <li>{@link WebServerConfig#JWT_AUTHENTICATION_PROVIDER_URL_CONFIG} that is the url of the token issuer,\n+ *   <li>{@link WebServerConfig#JWT_COOKIE_NAME_CONFIG} that is the name of the cookie that contains the issued token\n+ *   <li>{@link WebServerConfig#JWT_AUTH_CERTIFICATE_LOCATION_CONFIG} which is shared by the issuer to validate tokens\n+ *   <li>{@link WebServerConfig#JWT_EXPECTED_AUDIENCES_CONFIG} which is the expected audiences of the token (so a token\n+ *   will be rejected if it contains anything other than what is listed here)\n+ *   <li>{@link WebServerConfig#WEBSERVER_AUTH_CREDENTIALS_FILE_CONFIG} which contains the username-role associations\n+ *   without any passwords.\n+ * </ul>\n+ */\n+public class JwtSecurityProvider extends DefaultRoleSecurityProvider {\n+\n+  private String _authenticationProviderUrl;\n+  private String _cookieName;\n+  private String _publicKeyLocation;\n+  private String _privilegesFilePath;\n+  private List<String> _audiences;\n+\n+  @Override\n+  public void init(KafkaCruiseControlConfig config) throws ServletException {\n+    super.init(config);\n+    _authenticationProviderUrl = config.getString(WebServerConfig.JWT_AUTHENTICATION_PROVIDER_URL_CONFIG);\n+    _cookieName = config.getString(WebServerConfig.JWT_COOKIE_NAME_CONFIG);\n+    _publicKeyLocation = config.getString(WebServerConfig.JWT_AUTH_CERTIFICATE_LOCATION_CONFIG);\n+    _audiences = config.getList(WebServerConfig.JWT_EXPECTED_AUDIENCES_CONFIG);\n+    _privilegesFilePath = config.getString(WebServerConfig.WEBSERVER_AUTH_CREDENTIALS_FILE_CONFIG);", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyODM5NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383628395", "bodyText": "Is null an acceptable value for authenticationProviderUrl? -- e.g. JwtSecurityProvider#authenticator() may set its value to null.", "author": "efeg", "createdAt": "2020-02-25T02:36:32Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticator.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.nimbusds.jwt.SignedJWT;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.security.ServerAuthException;\n+import org.eclipse.jetty.security.UserAuthentication;\n+import org.eclipse.jetty.security.authentication.LoginAuthenticator;\n+import org.eclipse.jetty.server.Authentication;\n+import org.eclipse.jetty.server.UserIdentity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.function.Function;\n+\n+/**\n+ * <p>The {@link JwtAuthenticator} adds SSO capabilites to Cruise Control. The expected token is a Json Web Token (JWT).\n+ * This class should be used with {@link JwtLoginService} as the token check is carried out by that one. This class\n+ * handles redirects for unauthenticated requests and CORS preflight requests.</p>\n+ * <p>The workflow can be described with the following diagram:\n+ * <pre>\n+ *       Client -----1., 4.----> Cruise Control\n+ *        |  ^                        |\n+ *        |  |________2.______________|\n+ *        |\n+ *        |\n+ *        |------3.------------> Authentication\n+ *                                 provider\n+ * </pre>\n+ * <ol>\n+ * <li>The client makes an initial call to Cruise Control\n+ * <li>If the request doesn't have a JWT cookie by the specified cookie name, it will be redirected to the authentication\n+ *     service to obtain it. If the request is an OPTIONS request we presume it's a CORS preflight request so it'll skip\n+ *     the authentication (if the user is authenticated at this point we'll use the existing credentials).\n+ * <li>The client authenticates with the provider and obtains the SSO token.\n+ * <li>The client can present the JWT cookie to Cruise Control. Cruise Control will validate the cookie with the\n+ *    {@link JwtLoginService} by checking its signature, audience and expiration.\n+ * </ol>\n+ * </p>\n+ */\n+public class JwtAuthenticator extends LoginAuthenticator {\n+\n+  public static final String JWT_TOKEN_REQUEST_ATTRIBUTE = \"com.linkedin.kafka.cruisecontrol.JwtTokenAttribute\";\n+  static final Logger JWT_LOGGER = LoggerFactory.getLogger(\"kafka.cruisecontrol.jwt.logger\");\n+\n+  private static final String METHOD = \"JWT\";\n+  private static final String BEARER = \"Bearer\";\n+\n+  private final String _cookieName;\n+  private final Function<HttpServletRequest, String> _authenticationProviderUrlGenerator;\n+\n+  /**\n+   * Creates a new {@link JwtAuthenticator} instance with a custom authentication provider url and a cookie name that\n+   * will be populated by the authentication service with the JWT token.\n+   * @param authenticationProviderUrl is the HTTP(S) address of the authentication service. It will be used to create\n+   *                                  the redirection url. For instance <code>https://www.my-auth-service.com/websso?origin={redirectUrl}</code>\n+   *                                  will generate <code>https://www.my-auth-service.com/websso?origin=https://www.cruise-control.cc/state</code>\n+   *                                  which should redirect from <code>my-auth-service.com</code> to <code>cruise-control.cc/state</code>\n+   *                                  after obtaining the JWT token.", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyODcxMA==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383628710", "bodyText": "Nit: Can we set these fields to final?", "author": "efeg", "createdAt": "2020-02-25T02:37:50Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserIdentity.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import org.eclipse.jetty.server.UserIdentity;\n+\n+import javax.security.auth.Subject;\n+import java.security.Principal;\n+\n+public class JwtUserIdentity implements UserIdentity {\n+\n+  private Subject _subject;\n+  private Principal _principal;\n+  private UserIdentity _roleDelegate;", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyOTQ2OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383629469", "bodyText": "Is there an implicit assumption that subject and roleDelegate cannot be null? -- e.g. JwtUserIdentity#getSubject() is accessed w/o a null check, which may potentially yield an NPE?", "author": "efeg", "createdAt": "2020-02-25T02:40:59Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserIdentity.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import org.eclipse.jetty.server.UserIdentity;\n+\n+import javax.security.auth.Subject;\n+import java.security.Principal;\n+\n+public class JwtUserIdentity implements UserIdentity {\n+\n+  private Subject _subject;\n+  private Principal _principal;\n+  private UserIdentity _roleDelegate;\n+\n+  JwtUserIdentity(Subject subject, Principal principal, UserIdentity roleDelegate) {\n+    _subject = subject;\n+    _principal = principal;", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcyNTE5NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r385725195", "bodyText": "Good catch. In fact it could happen that in JwtLoginService.login null is returned by the\nUserIdentity rolesDelegate = _authorizationService.getUserIdentity((HttpServletRequest) request, username);\ncall. In this case we should return with an unauthenticated identity and handle that case as an unsuccessful login. Otherwise if the login was successful then the subject and roleDelegate shouldn't be null.", "author": "viktorsomogyi", "createdAt": "2020-02-28T14:29:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyOTQ2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyOTY1MA==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383629650", "bodyText": "Nit: Can we set these fields to final?", "author": "efeg", "createdAt": "2020-02-25T02:41:41Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtUserPrincipal.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import java.security.Principal;\n+\n+public class JwtUserPrincipal implements Principal {\n+\n+  private String _username;\n+  private String _serializedToken;", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYzMDg0MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383630841", "bodyText": "(Applies to similar uses in JwtLoginServiceTest) Nit: Can we move hardcoded String, \"USER\", to a static variable?", "author": "efeg", "createdAt": "2020-02-25T02:46:39Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/JwtAuthenticatorTest.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.linkedin.kafka.cruisecontrol.servlet.security.UserStoreAuthorizationService;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.security.Authenticator;\n+import org.eclipse.jetty.security.DefaultIdentityService;\n+import org.eclipse.jetty.security.ServerAuthException;\n+import org.eclipse.jetty.security.UserAuthentication;\n+import org.eclipse.jetty.security.UserStore;\n+import org.eclipse.jetty.server.Authentication;\n+import org.eclipse.jetty.server.Request;\n+import org.junit.Test;\n+\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.IOException;\n+\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.expectLastCall;\n+import static org.easymock.EasyMock.mock;\n+import static org.easymock.EasyMock.niceMock;\n+import static org.easymock.EasyMock.replay;\n+import static org.easymock.EasyMock.verify;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+public class JwtAuthenticatorTest {\n+\n+  private static final String TEST_USER = \"testUser\";\n+  private static final String JWT_TOKEN = \"jwt_token\";\n+  private static final String EXPECTED_TOKEN = \"token\";\n+  private static final String RANDOM_COOKIE_NAME = \"random_cookie_name\";\n+  private static final String TOKEN_PROVIDER = \"http://mytokenprovider.com?origin={redirectUrl}\";\n+  private static final String CRUISE_CONTROL_ENDPOINT = \"http://cruisecontrol.mycompany.com/state\";\n+\n+  @Test\n+  public void testParseTokenFromAuthHeader() {\n+    JwtAuthenticator authenticator = new JwtAuthenticator(TOKEN_PROVIDER, JWT_TOKEN);\n+    HttpServletRequest request = mock(HttpServletRequest.class);\n+    expect(request.getHeader(HttpHeader.AUTHORIZATION.asString())).andReturn(\"Bearer \" + EXPECTED_TOKEN);\n+    replay(request);\n+    String actualToken = authenticator.getJwtFromBearerAuthorization(request);\n+    verify(request);\n+    assertEquals(EXPECTED_TOKEN, actualToken);\n+  }\n+\n+  @Test\n+  public void testParseTokenFromAuthHeaderNoBearer() {\n+    JwtAuthenticator authenticator = new JwtAuthenticator(TOKEN_PROVIDER, JWT_TOKEN);\n+    HttpServletRequest request = mock(HttpServletRequest.class);\n+    expect(request.getHeader(HttpHeader.AUTHORIZATION.asString())).andReturn(\"Basic \" + EXPECTED_TOKEN);\n+    replay(request);\n+    String actualToken = authenticator.getJwtFromBearerAuthorization(request);\n+    verify(request);\n+    assertNull(actualToken);\n+  }\n+\n+  @Test\n+  public void testParseTokenFromCookie() {\n+    JwtAuthenticator authenticator = new JwtAuthenticator(TOKEN_PROVIDER, JWT_TOKEN);\n+    HttpServletRequest request = mock(HttpServletRequest.class);\n+    expect(request.getCookies()).andReturn(new Cookie[] {new Cookie(JWT_TOKEN, EXPECTED_TOKEN)});\n+    replay(request);\n+    String actualToken = authenticator.getJwtFromCookie(request);\n+    verify(request);\n+    assertEquals(EXPECTED_TOKEN, actualToken);\n+  }\n+\n+  @Test\n+  public void testParseTokenFromCookieNoJwtCookie() {\n+    JwtAuthenticator authenticator = new JwtAuthenticator(TOKEN_PROVIDER, JWT_TOKEN);\n+    HttpServletRequest request = mock(HttpServletRequest.class);\n+    expect(request.getCookies()).andReturn(new Cookie[] {new Cookie(RANDOM_COOKIE_NAME, \"\")});\n+    replay(request);\n+    String actualToken = authenticator.getJwtFromCookie(request);\n+    verify(request);\n+    assertNull(actualToken);\n+  }\n+\n+  @Test\n+  public void testRedirect() throws IOException, ServerAuthException {\n+    JwtAuthenticator authenticator = new JwtAuthenticator(TOKEN_PROVIDER, JWT_TOKEN);\n+\n+    HttpServletRequest request = mock(HttpServletRequest.class);\n+    expect(request.getMethod()).andReturn(HttpMethod.GET.asString());\n+    expect(request.getQueryString()).andReturn(null);\n+    expect(request.getHeader(HttpHeader.AUTHORIZATION.asString())).andReturn(null);\n+    expect(request.getCookies()).andReturn(new Cookie[] {});\n+    expect(request.getRequestURL()).andReturn(new StringBuffer(CRUISE_CONTROL_ENDPOINT));\n+\n+    HttpServletResponse response = mock(HttpServletResponse.class);\n+    response.sendRedirect(TOKEN_PROVIDER.replace(\"{redirectUrl}\", CRUISE_CONTROL_ENDPOINT));\n+    expectLastCall().andVoid();\n+\n+    replay(request, response);\n+    Authentication actualAuthentication = authenticator.validateRequest(request, response, true);\n+    verify(request, response);\n+    assertEquals(Authentication.SEND_CONTINUE, actualAuthentication);\n+  }\n+\n+  @Test\n+  public void testSuccessfulLogin() throws Exception {\n+    UserStore testUserStore = new UserStore();\n+    testUserStore.addUser(TEST_USER, null, new String[] {\"USER\"});", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYzMTQ4Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r383631483", "bodyText": "Nit: Can we set these fields to final?", "author": "efeg", "createdAt": "2020-02-25T02:49:16Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/servlet/security/jwt/TokenGenerator.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.servlet.security.jwt;\n+\n+import com.nimbusds.jose.JOSEException;\n+import com.nimbusds.jose.JOSEObjectType;\n+import com.nimbusds.jose.JWSAlgorithm;\n+import com.nimbusds.jose.JWSHeader;\n+import com.nimbusds.jose.crypto.RSASSASigner;\n+import com.nimbusds.jose.jwk.RSAKey;\n+import com.nimbusds.jose.jwk.gen.RSAKeyGenerator;\n+import com.nimbusds.jwt.JWTClaimsSet;\n+import com.nimbusds.jwt.SignedJWT;\n+\n+import java.security.interfaces.RSAPrivateKey;\n+import java.security.interfaces.RSAPublicKey;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.List;\n+\n+class TokenGenerator {\n+\n+  static class TokenAndKeys {\n+    private String _token;\n+    private RSAPrivateKey _privateKey;\n+    private RSAPublicKey _publicKey;\n+", "originalCommit": "dd3fddc783fd8e6f5c33ae5f4efcb89a15805198", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "url": "https://github.com/linkedin/cruise-control/commit/10faa73059ef21277dcb03f193ed69d6adfb0a98", "message": "Address review comments", "committedDate": "2020-03-02T10:20:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUzMTc0Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1091#discussion_r386531742", "bodyText": "Nit: Missing dot at the end.", "author": "efeg", "createdAt": "2020-03-02T17:17:35Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfig.java", "diffHunk": "@@ -320,15 +321,35 @@ void sanityCheckSecurity() { // visible for testing\n         throw new ConfigException(String.format(\"If webserver security is enabled, a valid security provider must be set \" +\n             \"that is an implementation of %s.\", SecurityProvider.class.getName()));\n       }\n-      String basicAuthCredentialsFile = getString(WebServerConfig.WEBSERVER_AUTH_CREDENTIALS_FILE_CONFIG);\n-      if (BasicSecurityProvider.class.isAssignableFrom(securityProvider) && (basicAuthCredentialsFile == null\n-          || !Files.exists(Paths.get(basicAuthCredentialsFile)))) {\n+      String authCredentialsFile = getString(WebServerConfig.WEBSERVER_AUTH_CREDENTIALS_FILE_CONFIG);\n+      if (BasicSecurityProvider.class == securityProvider && !fileExists(authCredentialsFile)) {\n         throw new ConfigException(String.format(\"If %s is used, an existing credentials file must be set.\",\n             BasicSecurityProvider.class.getName()));\n       }\n+      if (JwtSecurityProvider.class == securityProvider) {\n+        String providerUrl = getString(WebServerConfig.JWT_AUTHENTICATION_PROVIDER_URL_CONFIG);\n+        if (providerUrl == null || providerUrl.isEmpty()) {\n+          throw new ConfigException(String.format(\"When %s is used, %s must be set\",", "originalCommit": "10faa73059ef21277dcb03f193ed69d6adfb0a98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b854f08d491445a6a37dbd5c4da27c87bd7360cb", "url": "https://github.com/linkedin/cruise-control/commit/b854f08d491445a6a37dbd5c4da27c87bd7360cb", "message": "JWT Authentication", "committedDate": "2020-03-03T10:34:02Z", "type": "commit"}, {"oid": "63a4d04e106f55c9c37243c977b15e16b2e0c2f9", "url": "https://github.com/linkedin/cruise-control/commit/63a4d04e106f55c9c37243c977b15e16b2e0c2f9", "message": "Update the user guide", "committedDate": "2020-03-03T10:34:02Z", "type": "commit"}, {"oid": "1165cbb154993b308023420a1bf4784f49868b69", "url": "https://github.com/linkedin/cruise-control/commit/1165cbb154993b308023420a1bf4784f49868b69", "message": "Emphasize demo purposes in docs", "committedDate": "2020-03-03T10:34:02Z", "type": "commit"}, {"oid": "965fd5c752b24aee6a0bf6b39af369b7466135ad", "url": "https://github.com/linkedin/cruise-control/commit/965fd5c752b24aee6a0bf6b39af369b7466135ad", "message": "Minor doc fix", "committedDate": "2020-03-03T10:34:02Z", "type": "commit"}, {"oid": "51961d3fc02f30cbfb10398840cd7c5f264d2626", "url": "https://github.com/linkedin/cruise-control/commit/51961d3fc02f30cbfb10398840cd7c5f264d2626", "message": "Minor fixes", "committedDate": "2020-03-03T10:34:02Z", "type": "commit"}, {"oid": "dbc907b3222aa2dc73ccd41d118cc4d2174e3224", "url": "https://github.com/linkedin/cruise-control/commit/dbc907b3222aa2dc73ccd41d118cc4d2174e3224", "message": "Trim the token instead of Bearer", "committedDate": "2020-03-03T10:34:02Z", "type": "commit"}, {"oid": "fe1fdc24f63399a6284e5b94cf4a2c8ef03c744b", "url": "https://github.com/linkedin/cruise-control/commit/fe1fdc24f63399a6284e5b94cf4a2c8ef03c744b", "message": "Add token revalidation capability", "committedDate": "2020-03-03T10:34:02Z", "type": "commit"}, {"oid": "d158f9f898fdbc9a6ae2e311013fdb22363ee4a0", "url": "https://github.com/linkedin/cruise-control/commit/d158f9f898fdbc9a6ae2e311013fdb22363ee4a0", "message": "Address review comments", "committedDate": "2020-03-03T10:34:02Z", "type": "commit"}, {"oid": "8ac11ff190be9fcac9945606b7509af5f0163a2c", "url": "https://github.com/linkedin/cruise-control/commit/8ac11ff190be9fcac9945606b7509af5f0163a2c", "message": "Add dot", "committedDate": "2020-03-03T10:35:09Z", "type": "commit"}, {"oid": "8ac11ff190be9fcac9945606b7509af5f0163a2c", "url": "https://github.com/linkedin/cruise-control/commit/8ac11ff190be9fcac9945606b7509af5f0163a2c", "message": "Add dot", "committedDate": "2020-03-03T10:35:09Z", "type": "forcePushed"}, {"oid": "819cd3b0ea4ac61c8030b83bdd607eb9219e3cd5", "url": "https://github.com/linkedin/cruise-control/commit/819cd3b0ea4ac61c8030b83bdd607eb9219e3cd5", "message": "Set status to 401 explicitly on failed authentication", "committedDate": "2020-03-03T13:08:05Z", "type": "commit"}]}