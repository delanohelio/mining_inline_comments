{"pr_number": 1345, "pr_title": "Add a new hard goal that evenly distributes replicas over racks", "pr_createdAt": "2020-10-13T02:27:10Z", "pr_url": "https://github.com/linkedin/cruise-control/pull/1345", "timeline": [{"oid": "10909347c0d0917ca6d45aa0a14c3b0b0d1507d7", "url": "https://github.com/linkedin/cruise-control/commit/10909347c0d0917ca6d45aa0a14c3b0b0d1507d7", "message": "Add a new hard goal that evenly distributes replicas over racks", "committedDate": "2020-10-13T02:25:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk2MDY2Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1345#discussion_r504960667", "bodyText": "failIfCanNotMove is kind of misleading or this log line is misleading since this logs \"failure\", but failIfCanNotMove must be false at this point so it's not a failure.", "author": "smccauliff", "createdAt": "2020-10-14T20:43:56Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/AbstractRackAwareGoal.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.function.Function;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.BROKER_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * An abstract class for custom rack aware goals.\n+ */\n+public abstract class AbstractRackAwareGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(AbstractRackAwareGoal.class);\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Get brokers that the rebalance process will go over to apply balancing actions to replicas they contain.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @return A collection of brokers that the rebalance process will go over to apply balancing actions to replicas\n+   * they contain.\n+   */\n+  @Override\n+  protected SortedSet<Broker> brokersToBalance(ClusterModel clusterModel) {\n+    return clusterModel.brokers();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    return true;\n+  }\n+\n+  @Override\n+  public void finish() {\n+    _finished = true;\n+  }\n+\n+  /**\n+   * Check whether the given action is acceptable by this goal. The following actions are acceptable:\n+   * <ul>\n+   *   <li>All leadership moves</li>\n+   *   <li>Replica moves that do not violate {@link #doesReplicaMoveViolateActionAcceptance(ClusterModel, Function, Function)}</li>\n+   *   <li>Swaps that do not violate {@link #doesReplicaMoveViolateActionAcceptance(ClusterModel, Function, Function)}\n+   *   in both direction</li>\n+   * </ul>\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   * {@link ActionAcceptance#BROKER_REJECT} if the action is rejected due to violating rack awareness in the destination\n+   * broker after moving source replica to destination broker, {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+        return ACCEPT;\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+      case INTER_BROKER_REPLICA_SWAP:\n+        if (doesReplicaMoveViolateActionAcceptance(clusterModel,\n+                                                   c -> c.broker(action.sourceBrokerId()).replica(action.topicPartition()),\n+                                                   c -> c.broker(action.destinationBrokerId()))) {\n+          return BROKER_REJECT;\n+        }\n+\n+        if (action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP\n+            && doesReplicaMoveViolateActionAcceptance(clusterModel,\n+                                                      c -> c.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition()),\n+                                                      c -> c.broker(action.sourceBrokerId()))) {\n+          return REPLICA_REJECT;\n+        }\n+        return ACCEPT;\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  protected abstract boolean doesReplicaMoveViolateActionAcceptance(ClusterModel clusterModel,\n+                                                                    Function<ClusterModel, Replica> sourceReplicaFunction,\n+                                                                    Function<ClusterModel, Broker> destinationBrokerFunction);\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of this custom rack aware goal and optimized goals.\n+   *\n+   * @param broker Broker to be balanced.\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   * @param failIfCannotMove {@code true} to throw an {@link OptimizationFailureException} in case a required balancing\n+   * action for a replica fails for all rack-aware eligible brokers, {@code false} to just log the failure and return.\n+   * this parameter enables selected goals fail early in case the unsatisfiability of a goal can be determined early.\n+   */\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions,\n+                                    boolean failIfCannotMove)\n+      throws OptimizationFailureException {\n+    for (Replica replica : broker.trackedSortedReplicas(replicaSortName(this, false, false)).sortedReplicas(true)) {\n+      if (broker.isAlive() && !broker.currentOfflineReplicas().contains(replica) && shouldKeepInTheCurrentRack(replica, clusterModel)) {\n+        continue;\n+      }\n+      // The relevant rack awareness condition is violated. Move replica to an eligible broker\n+      SortedSet<Broker> eligibleBrokers = rackAwareEligibleBrokers(replica, clusterModel);\n+      if (maybeApplyBalancingAction(clusterModel, replica, eligibleBrokers,\n+                                    ActionType.INTER_BROKER_REPLICA_MOVEMENT, optimizedGoals, optimizationOptions) == null) {\n+        if (failIfCannotMove) {\n+          throw new OptimizationFailureException(String.format(\"Failed to move replica %s to any broker in %s\", replica, eligibleBrokers));\n+        }\n+        LOG.debug(\"Failed to move replica {} to any broker in {}\", replica, eligibleBrokers);", "originalCommit": "10909347c0d0917ca6d45aa0a14c3b0b0d1507d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc3MTEyMw==", "url": "https://github.com/linkedin/cruise-control/pull/1345#discussion_r505771123", "bodyText": "Agreed.\n\nRenamed the parameter: failIfCannotMove -> throwExceptionIfCannotMove\nUpdated the log line and exception message for consistency with the parameter: Failed to move ... -> Cannot move ...", "author": "efeg", "createdAt": "2020-10-15T18:57:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk2MDY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk2MTUwMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1345#discussion_r504961501", "bodyText": "Presumably this gets logged somewhere.  Do the people that read the log care about the consequences of not being able to move, for example the replica is being moved because the broker is not alive vs.  the repilca is not failed but is being moved to achieve better rack diversity.", "author": "smccauliff", "createdAt": "2020-10-14T20:45:28Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/AbstractRackAwareGoal.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.function.Function;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.BROKER_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * An abstract class for custom rack aware goals.\n+ */\n+public abstract class AbstractRackAwareGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(AbstractRackAwareGoal.class);\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Get brokers that the rebalance process will go over to apply balancing actions to replicas they contain.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @return A collection of brokers that the rebalance process will go over to apply balancing actions to replicas\n+   * they contain.\n+   */\n+  @Override\n+  protected SortedSet<Broker> brokersToBalance(ClusterModel clusterModel) {\n+    return clusterModel.brokers();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    return true;\n+  }\n+\n+  @Override\n+  public void finish() {\n+    _finished = true;\n+  }\n+\n+  /**\n+   * Check whether the given action is acceptable by this goal. The following actions are acceptable:\n+   * <ul>\n+   *   <li>All leadership moves</li>\n+   *   <li>Replica moves that do not violate {@link #doesReplicaMoveViolateActionAcceptance(ClusterModel, Function, Function)}</li>\n+   *   <li>Swaps that do not violate {@link #doesReplicaMoveViolateActionAcceptance(ClusterModel, Function, Function)}\n+   *   in both direction</li>\n+   * </ul>\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   * {@link ActionAcceptance#BROKER_REJECT} if the action is rejected due to violating rack awareness in the destination\n+   * broker after moving source replica to destination broker, {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+        return ACCEPT;\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+      case INTER_BROKER_REPLICA_SWAP:\n+        if (doesReplicaMoveViolateActionAcceptance(clusterModel,\n+                                                   c -> c.broker(action.sourceBrokerId()).replica(action.topicPartition()),\n+                                                   c -> c.broker(action.destinationBrokerId()))) {\n+          return BROKER_REJECT;\n+        }\n+\n+        if (action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP\n+            && doesReplicaMoveViolateActionAcceptance(clusterModel,\n+                                                      c -> c.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition()),\n+                                                      c -> c.broker(action.sourceBrokerId()))) {\n+          return REPLICA_REJECT;\n+        }\n+        return ACCEPT;\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  protected abstract boolean doesReplicaMoveViolateActionAcceptance(ClusterModel clusterModel,\n+                                                                    Function<ClusterModel, Replica> sourceReplicaFunction,\n+                                                                    Function<ClusterModel, Broker> destinationBrokerFunction);\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of this custom rack aware goal and optimized goals.\n+   *\n+   * @param broker Broker to be balanced.\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   * @param failIfCannotMove {@code true} to throw an {@link OptimizationFailureException} in case a required balancing\n+   * action for a replica fails for all rack-aware eligible brokers, {@code false} to just log the failure and return.\n+   * this parameter enables selected goals fail early in case the unsatisfiability of a goal can be determined early.\n+   */\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions,\n+                                    boolean failIfCannotMove)\n+      throws OptimizationFailureException {\n+    for (Replica replica : broker.trackedSortedReplicas(replicaSortName(this, false, false)).sortedReplicas(true)) {\n+      if (broker.isAlive() && !broker.currentOfflineReplicas().contains(replica) && shouldKeepInTheCurrentRack(replica, clusterModel)) {\n+        continue;\n+      }\n+      // The relevant rack awareness condition is violated. Move replica to an eligible broker\n+      SortedSet<Broker> eligibleBrokers = rackAwareEligibleBrokers(replica, clusterModel);\n+      if (maybeApplyBalancingAction(clusterModel, replica, eligibleBrokers,\n+                                    ActionType.INTER_BROKER_REPLICA_MOVEMENT, optimizedGoals, optimizationOptions) == null) {\n+        if (failIfCannotMove) {\n+          throw new OptimizationFailureException(String.format(\"Failed to move replica %s to any broker in %s\", replica, eligibleBrokers));", "originalCommit": "10909347c0d0917ca6d45aa0a14c3b0b0d1507d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc3MTA5OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1345#discussion_r505771099", "bodyText": "Good question -- yes the user is made aware of the specific failure with details on how they may resolve them.\n--\nAn OptimizationFailureException causes the optimization process for requests, such as rebalance, remove_broker, or add_broker, to fail.\nSuch failures and their relevant root cause (e.g. Insufficient disk capacity / number of racks, failure to move the offline replica to an alive broker) are logged and returned in response along with a generic potential mitigation strategy so that the user would know what likely action may help in resolving them (see GoalUtils#mitigationForOptimizationFailures(OptimizationOptions)).", "author": "efeg", "createdAt": "2020-10-15T18:57:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk2MTUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk2MzE1Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1345#discussion_r504963153", "bodyText": "Does making every object equals each other have some side effect.  For example if ClusterModelStats is the key for some TreeMap using this comparator reduces the tree to a linked list which often has bad performance.", "author": "smccauliff", "createdAt": "2020-10-14T20:48:38Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/GoalUtils.java", "diffHunk": "@@ -46,6 +47,22 @@ private GoalUtils() {\n \n   }\n \n+  /**\n+   * A convenience {@link com.linkedin.kafka.cruisecontrol.analyzer.goals.Goal.ClusterModelStatsComparator} for typical hard goals.\n+   */\n+  public static class HardGoalStatsComparator implements Goal.ClusterModelStatsComparator {\n+    @Override\n+    public int compare(ClusterModelStats stats1, ClusterModelStats stats2) {\n+      // Stats are irrelevant to a hard goal. The optimization would already fail if the goal requirements are not met.\n+      return 0;\n+    }", "originalCommit": "10909347c0d0917ca6d45aa0a14c3b0b0d1507d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc3MTA1MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1345#discussion_r505771051", "bodyText": "This comparator enables comparison of given cluster model stats for a given goal. It is not really intended to be used as a comparator of sorted collections -- i.e. this comparator imposes orderings that are inconsistent with equals; hence, sorted collections can behave strangely (source). Added the following recommended note to the JavaDoc of the ClusterModelStatsComparator interface: Note: this comparator imposes orderings that are inconsistent with equals.\nThe typical use-case of it is to ensure that the optimization of a goal does not make the cluster more imbalanced w.r.t. the requirements of the goal.", "author": "efeg", "createdAt": "2020-10-15T18:57:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk2MzE1Mw=="}], "type": "inlineReview"}, {"oid": "c662079c771771e8f2706d06674b39659301ed8a", "url": "https://github.com/linkedin/cruise-control/commit/c662079c771771e8f2706d06674b39659301ed8a", "message": "Address the feedback.", "committedDate": "2020-10-15T18:57:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc4MzY5NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1345#discussion_r505783695", "bodyText": "Why are functions ClusterModel -> replica and ClusterModel -> Broker passed in here rather than the return value of the function?  There is only one parameter for each of these functions and that parameter is also passed into doesReplicaMoveViolateActionAcceptance.  So the method could be\n(ClusterModel clusterModel, Replica sourceReplica, Broker destinationBroker)  No?\nThese functions are also only called once.", "author": "smccauliff", "createdAt": "2020-10-15T19:21:06Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/RackAwareDistributionGoal.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.function.Function;\n+\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+import static java.util.Collections.max;\n+import static java.util.Collections.min;\n+\n+\n+/**\n+ * HARD GOAL: Generate replica movement proposals to evenly distribute replicas over racks.\n+ *\n+ * This is a relaxed version of {@link RackAwareGoal}. Contrary to {@link RackAwareGoal}, as long as replicas of each\n+ * partition can achieve a perfectly even distribution across the racks, this goal lets placement of multiple replicas\n+ * of a partition into a single rack.\n+ *\n+ * <p>\n+ *   For example, suppose a topic with 1 partition has 4 replicas in a cluster with 2 racks. Then the following\n+ *   distribution will be acceptable by this goal (but would be unacceptable by {@link RackAwareGoal}):\n+ * </p>\n+ *\n+ * <pre>\n+ * Rack A                    | Rack B\n+ * -----------------------------------------------------\n+ * Broker1-rack A  replica-0 | Broker2-rack B\n+ * Broker3-rack A            | Broker4-rack B replica-1\n+ * Broker5-rack A  replica-2 | Broker6-rack B\n+ * Broker7-rack A            | Broker8-rack B replica-3\n+ * </pre>\n+ *\n+ * <p>\n+ *   However, this goal will yield an {@link OptimizationFailureException} for the same partition in the following\n+ *   cluster due to the lack of a second broker to place a replica of this partition in {@code Rack B}:\n+ * </p>\n+ *\n+ * <pre>\n+ * Rack A                    | Rack B\n+ * -----------------------------------------------------\n+ * Broker1-rack A  replica-0 | Broker2-rack B replica-1\n+ * Broker3-rack A  replica-3 |\n+ * Broker5-rack A  replica-2 |\n+ * </pre>\n+ */\n+public class RackAwareDistributionGoal extends AbstractRackAwareGoal {\n+  private BalanceLimit _balanceLimit;\n+\n+  /**\n+   * Constructor for Rack Aware Distribution Goal.\n+   */\n+  public RackAwareDistributionGoal() {\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  RackAwareDistributionGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  protected boolean doesReplicaMoveViolateActionAcceptance(ClusterModel clusterModel,\n+                                                           Function<ClusterModel, Replica> sourceReplicaFunction,\n+                                                           Function<ClusterModel, Broker> destinationBrokerFunction) {", "originalCommit": "c662079c771771e8f2706d06674b39659301ed8a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg1MDcyMA==", "url": "https://github.com/linkedin/cruise-control/pull/1345#discussion_r505850720", "bodyText": "Indeed there is no need for this extra complexity -- thanks!", "author": "efeg", "createdAt": "2020-10-15T21:05:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc4MzY5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5NDY0OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1345#discussion_r505794649", "bodyText": "TODO:  look at SortedReplicasHelper to see what it does.", "author": "smccauliff", "createdAt": "2020-10-15T19:41:37Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/RackAwareDistributionGoal.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.function.Function;\n+\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+import static java.util.Collections.max;\n+import static java.util.Collections.min;\n+\n+\n+/**\n+ * HARD GOAL: Generate replica movement proposals to evenly distribute replicas over racks.\n+ *\n+ * This is a relaxed version of {@link RackAwareGoal}. Contrary to {@link RackAwareGoal}, as long as replicas of each\n+ * partition can achieve a perfectly even distribution across the racks, this goal lets placement of multiple replicas\n+ * of a partition into a single rack.\n+ *\n+ * <p>\n+ *   For example, suppose a topic with 1 partition has 4 replicas in a cluster with 2 racks. Then the following\n+ *   distribution will be acceptable by this goal (but would be unacceptable by {@link RackAwareGoal}):\n+ * </p>\n+ *\n+ * <pre>\n+ * Rack A                    | Rack B\n+ * -----------------------------------------------------\n+ * Broker1-rack A  replica-0 | Broker2-rack B\n+ * Broker3-rack A            | Broker4-rack B replica-1\n+ * Broker5-rack A  replica-2 | Broker6-rack B\n+ * Broker7-rack A            | Broker8-rack B replica-3\n+ * </pre>\n+ *\n+ * <p>\n+ *   However, this goal will yield an {@link OptimizationFailureException} for the same partition in the following\n+ *   cluster due to the lack of a second broker to place a replica of this partition in {@code Rack B}:\n+ * </p>\n+ *\n+ * <pre>\n+ * Rack A                    | Rack B\n+ * -----------------------------------------------------\n+ * Broker1-rack A  replica-0 | Broker2-rack B replica-1\n+ * Broker3-rack A  replica-3 |\n+ * Broker5-rack A  replica-2 |\n+ * </pre>\n+ */\n+public class RackAwareDistributionGoal extends AbstractRackAwareGoal {\n+  private BalanceLimit _balanceLimit;\n+\n+  /**\n+   * Constructor for Rack Aware Distribution Goal.\n+   */\n+  public RackAwareDistributionGoal() {\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  RackAwareDistributionGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  protected boolean doesReplicaMoveViolateActionAcceptance(ClusterModel clusterModel,\n+                                                           Function<ClusterModel, Replica> sourceReplicaFunction,\n+                                                           Function<ClusterModel, Broker> destinationBrokerFunction) {\n+    Replica sourceReplica = sourceReplicaFunction.apply(clusterModel);\n+    String destinationRackId = destinationBrokerFunction.apply(clusterModel).rack().id();\n+    String sourceRackId = sourceReplica.broker().rack().id();\n+\n+    if (sourceRackId.equals(destinationRackId)) {\n+      // A replica move within the same rack cannot violate rack aware distribution.\n+      return false;\n+    }\n+\n+    // The replica move shall not increase the replica distribution imbalance of the partition across racks.\n+    Set<Broker> partitionBrokers = clusterModel.partition(sourceReplica.topicPartition()).partitionBrokers();\n+    Map<String, Integer> numReplicasByRack = numPartitionReplicasByRackId(partitionBrokers);\n+\n+    return numReplicasByRack.getOrDefault(destinationRackId, 0) >= numReplicasByRack.getOrDefault(sourceRackId, 0);\n+  }\n+\n+  /**\n+   * Given the brokers that host replicas of a partition, retrieves a map containing number of replicas by the id of the\n+   * rack they reside in.\n+   *\n+   * @param partitionBrokers Brokers that host replicas of some partition\n+   * @return A map containing the number of replicas by rack id that these replicas reside in.\n+   */\n+  private static Map<String, Integer> numPartitionReplicasByRackId(Set<Broker> partitionBrokers) {\n+    Map<String, Integer> numPartitionReplicasByRackId = new HashMap<>(partitionBrokers.size());\n+    for (Broker broker : partitionBrokers) {\n+      numPartitionReplicasByRackId.merge(broker.rack().id(), 1, Integer::sum);\n+    }\n+    return numPartitionReplicasByRackId;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return RackAwareDistributionGoal.class.getSimpleName();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions) {\n+    _balanceLimit = new BalanceLimit(clusterModel);\n+    Set<String> excludedTopics = optimizationOptions.excludedTopics();\n+\n+    // Filter out some replicas based on optimization options.\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(),\n+                                                     optimizationOptions.onlyMoveImmigrantReplicas())\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnExcludedTopics(excludedTopics))\n+                              .trackSortedReplicasFor(replicaSortName(this, false, false), clusterModel);", "originalCommit": "c662079c771771e8f2706d06674b39659301ed8a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5NjY3Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1345#discussion_r505796672", "bodyText": "TODO:  what does this do?", "author": "smccauliff", "createdAt": "2020-10-15T19:44:55Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/RackAwareDistributionGoal.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.function.Function;\n+\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+import static java.util.Collections.max;\n+import static java.util.Collections.min;\n+\n+\n+/**\n+ * HARD GOAL: Generate replica movement proposals to evenly distribute replicas over racks.\n+ *\n+ * This is a relaxed version of {@link RackAwareGoal}. Contrary to {@link RackAwareGoal}, as long as replicas of each\n+ * partition can achieve a perfectly even distribution across the racks, this goal lets placement of multiple replicas\n+ * of a partition into a single rack.\n+ *\n+ * <p>\n+ *   For example, suppose a topic with 1 partition has 4 replicas in a cluster with 2 racks. Then the following\n+ *   distribution will be acceptable by this goal (but would be unacceptable by {@link RackAwareGoal}):\n+ * </p>\n+ *\n+ * <pre>\n+ * Rack A                    | Rack B\n+ * -----------------------------------------------------\n+ * Broker1-rack A  replica-0 | Broker2-rack B\n+ * Broker3-rack A            | Broker4-rack B replica-1\n+ * Broker5-rack A  replica-2 | Broker6-rack B\n+ * Broker7-rack A            | Broker8-rack B replica-3\n+ * </pre>\n+ *\n+ * <p>\n+ *   However, this goal will yield an {@link OptimizationFailureException} for the same partition in the following\n+ *   cluster due to the lack of a second broker to place a replica of this partition in {@code Rack B}:\n+ * </p>\n+ *\n+ * <pre>\n+ * Rack A                    | Rack B\n+ * -----------------------------------------------------\n+ * Broker1-rack A  replica-0 | Broker2-rack B replica-1\n+ * Broker3-rack A  replica-3 |\n+ * Broker5-rack A  replica-2 |\n+ * </pre>\n+ */\n+public class RackAwareDistributionGoal extends AbstractRackAwareGoal {\n+  private BalanceLimit _balanceLimit;\n+\n+  /**\n+   * Constructor for Rack Aware Distribution Goal.\n+   */\n+  public RackAwareDistributionGoal() {\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  RackAwareDistributionGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  protected boolean doesReplicaMoveViolateActionAcceptance(ClusterModel clusterModel,\n+                                                           Function<ClusterModel, Replica> sourceReplicaFunction,\n+                                                           Function<ClusterModel, Broker> destinationBrokerFunction) {\n+    Replica sourceReplica = sourceReplicaFunction.apply(clusterModel);\n+    String destinationRackId = destinationBrokerFunction.apply(clusterModel).rack().id();\n+    String sourceRackId = sourceReplica.broker().rack().id();\n+\n+    if (sourceRackId.equals(destinationRackId)) {\n+      // A replica move within the same rack cannot violate rack aware distribution.\n+      return false;\n+    }\n+\n+    // The replica move shall not increase the replica distribution imbalance of the partition across racks.\n+    Set<Broker> partitionBrokers = clusterModel.partition(sourceReplica.topicPartition()).partitionBrokers();\n+    Map<String, Integer> numReplicasByRack = numPartitionReplicasByRackId(partitionBrokers);\n+\n+    return numReplicasByRack.getOrDefault(destinationRackId, 0) >= numReplicasByRack.getOrDefault(sourceRackId, 0);\n+  }\n+\n+  /**\n+   * Given the brokers that host replicas of a partition, retrieves a map containing number of replicas by the id of the\n+   * rack they reside in.\n+   *\n+   * @param partitionBrokers Brokers that host replicas of some partition\n+   * @return A map containing the number of replicas by rack id that these replicas reside in.\n+   */\n+  private static Map<String, Integer> numPartitionReplicasByRackId(Set<Broker> partitionBrokers) {\n+    Map<String, Integer> numPartitionReplicasByRackId = new HashMap<>(partitionBrokers.size());\n+    for (Broker broker : partitionBrokers) {\n+      numPartitionReplicasByRackId.merge(broker.rack().id(), 1, Integer::sum);\n+    }\n+    return numPartitionReplicasByRackId;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return RackAwareDistributionGoal.class.getSimpleName();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions) {\n+    _balanceLimit = new BalanceLimit(clusterModel);\n+    Set<String> excludedTopics = optimizationOptions.excludedTopics();\n+\n+    // Filter out some replicas based on optimization options.\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(),\n+                                                     optimizationOptions.onlyMoveImmigrantReplicas())\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnExcludedTopics(excludedTopics))\n+                              .trackSortedReplicasFor(replicaSortName(this, false, false), clusterModel);\n+  }\n+\n+  /**\n+   * Update goal state.\n+   * Sanity check: After completion of balancing / self-healing, confirm that replicas of each partition are evenly\n+   * distributed across the racks.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // One pass is sufficient to satisfy or alert impossibility of this goal.\n+    // Sanity check to confirm that replicas of each partition are evenly distributed across the racks\n+    ensureRackAwareDistribution(clusterModel, optimizationOptions);\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    finish();\n+  }\n+\n+  @Override\n+  public void finish() {\n+    super.finish();\n+    // Clean up the memory\n+    _balanceLimit.clear();\n+  }\n+\n+  /**\n+   * Violations of rack-aware distribution can be resolved with replica movements.\n+   *\n+   * @param broker Broker to be balanced.\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    rebalanceForBroker(broker, clusterModel, optimizedGoals, optimizationOptions, false);\n+  }\n+\n+  /**\n+   * Get a list of eligible brokers for moving the given replica in the given cluster to satisfy the specific\n+   * requirements of the custom rack aware goal.\n+   * A broker is rack aware distribution eligible for a given replica if it is in a rack\n+   * <ul>\n+   *   <li>that needs more replicas -- i.e. has fewer than base limit replicas</li>\n+   *   <li>with at most as many as base limit replicas, and the number of racks with at least one more replica over the\n+   *   base limit is fewer than the allowed number of such racks</li>\n+   * </ul>\n+   *\n+   * @param replica Replica for which a set of rack aware eligible brokers are requested.\n+   * @param clusterModel The state of the cluster.\n+   * @return A list of rack aware eligible brokers for the given replica in the given cluster.\n+   */\n+  @Override\n+  protected SortedSet<Broker> rackAwareEligibleBrokers(Replica replica, ClusterModel clusterModel) {\n+    Set<Broker> partitionBrokers = clusterModel.partition(replica.topicPartition()).partitionBrokers();\n+    Map<String, Integer> numReplicasByRack = numPartitionReplicasByRackId(partitionBrokers);\n+\n+    // Decrement the number of replicas in this rack.\n+    numReplicasByRack.merge(replica.broker().rack().id(), -1, Integer::sum);\n+\n+    int baseLimit = _balanceLimit.baseLimitByRF(partitionBrokers.size());", "originalCommit": "c662079c771771e8f2706d06674b39659301ed8a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5ODYzNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1345#discussion_r505798635", "bodyText": "I'm wondering if this is going end up moving replicas to lower numbered brokers preferentially rather than a more even distribution.", "author": "smccauliff", "createdAt": "2020-10-15T19:48:47Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/RackAwareDistributionGoal.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.function.Function;\n+\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+import static java.util.Collections.max;\n+import static java.util.Collections.min;\n+\n+\n+/**\n+ * HARD GOAL: Generate replica movement proposals to evenly distribute replicas over racks.\n+ *\n+ * This is a relaxed version of {@link RackAwareGoal}. Contrary to {@link RackAwareGoal}, as long as replicas of each\n+ * partition can achieve a perfectly even distribution across the racks, this goal lets placement of multiple replicas\n+ * of a partition into a single rack.\n+ *\n+ * <p>\n+ *   For example, suppose a topic with 1 partition has 4 replicas in a cluster with 2 racks. Then the following\n+ *   distribution will be acceptable by this goal (but would be unacceptable by {@link RackAwareGoal}):\n+ * </p>\n+ *\n+ * <pre>\n+ * Rack A                    | Rack B\n+ * -----------------------------------------------------\n+ * Broker1-rack A  replica-0 | Broker2-rack B\n+ * Broker3-rack A            | Broker4-rack B replica-1\n+ * Broker5-rack A  replica-2 | Broker6-rack B\n+ * Broker7-rack A            | Broker8-rack B replica-3\n+ * </pre>\n+ *\n+ * <p>\n+ *   However, this goal will yield an {@link OptimizationFailureException} for the same partition in the following\n+ *   cluster due to the lack of a second broker to place a replica of this partition in {@code Rack B}:\n+ * </p>\n+ *\n+ * <pre>\n+ * Rack A                    | Rack B\n+ * -----------------------------------------------------\n+ * Broker1-rack A  replica-0 | Broker2-rack B replica-1\n+ * Broker3-rack A  replica-3 |\n+ * Broker5-rack A  replica-2 |\n+ * </pre>\n+ */\n+public class RackAwareDistributionGoal extends AbstractRackAwareGoal {\n+  private BalanceLimit _balanceLimit;\n+\n+  /**\n+   * Constructor for Rack Aware Distribution Goal.\n+   */\n+  public RackAwareDistributionGoal() {\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  RackAwareDistributionGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  protected boolean doesReplicaMoveViolateActionAcceptance(ClusterModel clusterModel,\n+                                                           Function<ClusterModel, Replica> sourceReplicaFunction,\n+                                                           Function<ClusterModel, Broker> destinationBrokerFunction) {\n+    Replica sourceReplica = sourceReplicaFunction.apply(clusterModel);\n+    String destinationRackId = destinationBrokerFunction.apply(clusterModel).rack().id();\n+    String sourceRackId = sourceReplica.broker().rack().id();\n+\n+    if (sourceRackId.equals(destinationRackId)) {\n+      // A replica move within the same rack cannot violate rack aware distribution.\n+      return false;\n+    }\n+\n+    // The replica move shall not increase the replica distribution imbalance of the partition across racks.\n+    Set<Broker> partitionBrokers = clusterModel.partition(sourceReplica.topicPartition()).partitionBrokers();\n+    Map<String, Integer> numReplicasByRack = numPartitionReplicasByRackId(partitionBrokers);\n+\n+    return numReplicasByRack.getOrDefault(destinationRackId, 0) >= numReplicasByRack.getOrDefault(sourceRackId, 0);\n+  }\n+\n+  /**\n+   * Given the brokers that host replicas of a partition, retrieves a map containing number of replicas by the id of the\n+   * rack they reside in.\n+   *\n+   * @param partitionBrokers Brokers that host replicas of some partition\n+   * @return A map containing the number of replicas by rack id that these replicas reside in.\n+   */\n+  private static Map<String, Integer> numPartitionReplicasByRackId(Set<Broker> partitionBrokers) {\n+    Map<String, Integer> numPartitionReplicasByRackId = new HashMap<>(partitionBrokers.size());\n+    for (Broker broker : partitionBrokers) {\n+      numPartitionReplicasByRackId.merge(broker.rack().id(), 1, Integer::sum);\n+    }\n+    return numPartitionReplicasByRackId;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return RackAwareDistributionGoal.class.getSimpleName();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions) {\n+    _balanceLimit = new BalanceLimit(clusterModel);\n+    Set<String> excludedTopics = optimizationOptions.excludedTopics();\n+\n+    // Filter out some replicas based on optimization options.\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(),\n+                                                     optimizationOptions.onlyMoveImmigrantReplicas())\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnExcludedTopics(excludedTopics))\n+                              .trackSortedReplicasFor(replicaSortName(this, false, false), clusterModel);\n+  }\n+\n+  /**\n+   * Update goal state.\n+   * Sanity check: After completion of balancing / self-healing, confirm that replicas of each partition are evenly\n+   * distributed across the racks.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // One pass is sufficient to satisfy or alert impossibility of this goal.\n+    // Sanity check to confirm that replicas of each partition are evenly distributed across the racks\n+    ensureRackAwareDistribution(clusterModel, optimizationOptions);\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    finish();\n+  }\n+\n+  @Override\n+  public void finish() {\n+    super.finish();\n+    // Clean up the memory\n+    _balanceLimit.clear();\n+  }\n+\n+  /**\n+   * Violations of rack-aware distribution can be resolved with replica movements.\n+   *\n+   * @param broker Broker to be balanced.\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    rebalanceForBroker(broker, clusterModel, optimizedGoals, optimizationOptions, false);\n+  }\n+\n+  /**\n+   * Get a list of eligible brokers for moving the given replica in the given cluster to satisfy the specific\n+   * requirements of the custom rack aware goal.\n+   * A broker is rack aware distribution eligible for a given replica if it is in a rack\n+   * <ul>\n+   *   <li>that needs more replicas -- i.e. has fewer than base limit replicas</li>\n+   *   <li>with at most as many as base limit replicas, and the number of racks with at least one more replica over the\n+   *   base limit is fewer than the allowed number of such racks</li>\n+   * </ul>\n+   *\n+   * @param replica Replica for which a set of rack aware eligible brokers are requested.\n+   * @param clusterModel The state of the cluster.\n+   * @return A list of rack aware eligible brokers for the given replica in the given cluster.\n+   */\n+  @Override\n+  protected SortedSet<Broker> rackAwareEligibleBrokers(Replica replica, ClusterModel clusterModel) {\n+    Set<Broker> partitionBrokers = clusterModel.partition(replica.topicPartition()).partitionBrokers();\n+    Map<String, Integer> numReplicasByRack = numPartitionReplicasByRackId(partitionBrokers);\n+\n+    // Decrement the number of replicas in this rack.\n+    numReplicasByRack.merge(replica.broker().rack().id(), -1, Integer::sum);\n+\n+    int baseLimit = _balanceLimit.baseLimitByRF(partitionBrokers.size());\n+\n+    // An replica is allowed to be moved to a rack at the base limit only if the number of racks with at least one more\n+    // replica over the base limit is fewer than the allowed number of such racks\n+    boolean canMoveToRacksAtBaseLimit = false;\n+    int numRacksWithOneMoreReplicaLimit = _balanceLimit.numRacksWithOneMoreReplicaByRF(partitionBrokers.size());\n+    int numRacksWithAtLeastOneMoreReplica = (int) numReplicasByRack.values().stream().filter(r -> r > baseLimit).count();\n+    if (numRacksWithAtLeastOneMoreReplica < numRacksWithOneMoreReplicaLimit) {\n+      canMoveToRacksAtBaseLimit = true;\n+    }\n+\n+    // Prefer brokers whose rack has fewer replicas from the partition\n+    SortedSet<Broker> rackAwareDistributionEligibleBrokers = new TreeSet<>(\n+        Comparator.comparingInt((Broker b) -> numReplicasByRack.getOrDefault(b.rack().id(), 0))\n+                  .thenComparingInt(Broker::id));", "originalCommit": "c662079c771771e8f2706d06674b39659301ed8a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg1MDY4NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1345#discussion_r505850685", "bodyText": "That is correct and intentional.\nBalanced replica distribution across brokers is not an objective of this goal -- i.e. there is already another goal to achieve that. The second order preference w.r.t. broker ids simply ensures consistent / deterministic output with the given cluster model.", "author": "efeg", "createdAt": "2020-10-15T21:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5ODYzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg5MzEzMw==", "url": "https://github.com/linkedin/cruise-control/pull/1345#discussion_r505893133", "bodyText": "Yeah.  Good point.", "author": "smccauliff", "createdAt": "2020-10-15T22:10:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5ODYzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgwMTQ2NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1345#discussion_r505801465", "bodyText": "Can an example be added in the comments that illustrates this case?", "author": "smccauliff", "createdAt": "2020-10-15T19:54:09Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/RackAwareDistributionGoal.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.function.Function;\n+\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+import static java.util.Collections.max;\n+import static java.util.Collections.min;\n+\n+\n+/**\n+ * HARD GOAL: Generate replica movement proposals to evenly distribute replicas over racks.\n+ *\n+ * This is a relaxed version of {@link RackAwareGoal}. Contrary to {@link RackAwareGoal}, as long as replicas of each\n+ * partition can achieve a perfectly even distribution across the racks, this goal lets placement of multiple replicas\n+ * of a partition into a single rack.\n+ *\n+ * <p>\n+ *   For example, suppose a topic with 1 partition has 4 replicas in a cluster with 2 racks. Then the following\n+ *   distribution will be acceptable by this goal (but would be unacceptable by {@link RackAwareGoal}):\n+ * </p>\n+ *\n+ * <pre>\n+ * Rack A                    | Rack B\n+ * -----------------------------------------------------\n+ * Broker1-rack A  replica-0 | Broker2-rack B\n+ * Broker3-rack A            | Broker4-rack B replica-1\n+ * Broker5-rack A  replica-2 | Broker6-rack B\n+ * Broker7-rack A            | Broker8-rack B replica-3\n+ * </pre>\n+ *\n+ * <p>\n+ *   However, this goal will yield an {@link OptimizationFailureException} for the same partition in the following\n+ *   cluster due to the lack of a second broker to place a replica of this partition in {@code Rack B}:\n+ * </p>\n+ *\n+ * <pre>\n+ * Rack A                    | Rack B\n+ * -----------------------------------------------------\n+ * Broker1-rack A  replica-0 | Broker2-rack B replica-1\n+ * Broker3-rack A  replica-3 |\n+ * Broker5-rack A  replica-2 |\n+ * </pre>\n+ */\n+public class RackAwareDistributionGoal extends AbstractRackAwareGoal {\n+  private BalanceLimit _balanceLimit;\n+\n+  /**\n+   * Constructor for Rack Aware Distribution Goal.\n+   */\n+  public RackAwareDistributionGoal() {\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  RackAwareDistributionGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  protected boolean doesReplicaMoveViolateActionAcceptance(ClusterModel clusterModel,\n+                                                           Function<ClusterModel, Replica> sourceReplicaFunction,\n+                                                           Function<ClusterModel, Broker> destinationBrokerFunction) {\n+    Replica sourceReplica = sourceReplicaFunction.apply(clusterModel);\n+    String destinationRackId = destinationBrokerFunction.apply(clusterModel).rack().id();\n+    String sourceRackId = sourceReplica.broker().rack().id();\n+\n+    if (sourceRackId.equals(destinationRackId)) {\n+      // A replica move within the same rack cannot violate rack aware distribution.\n+      return false;\n+    }\n+\n+    // The replica move shall not increase the replica distribution imbalance of the partition across racks.\n+    Set<Broker> partitionBrokers = clusterModel.partition(sourceReplica.topicPartition()).partitionBrokers();\n+    Map<String, Integer> numReplicasByRack = numPartitionReplicasByRackId(partitionBrokers);\n+\n+    return numReplicasByRack.getOrDefault(destinationRackId, 0) >= numReplicasByRack.getOrDefault(sourceRackId, 0);\n+  }\n+\n+  /**\n+   * Given the brokers that host replicas of a partition, retrieves a map containing number of replicas by the id of the\n+   * rack they reside in.\n+   *\n+   * @param partitionBrokers Brokers that host replicas of some partition\n+   * @return A map containing the number of replicas by rack id that these replicas reside in.\n+   */\n+  private static Map<String, Integer> numPartitionReplicasByRackId(Set<Broker> partitionBrokers) {\n+    Map<String, Integer> numPartitionReplicasByRackId = new HashMap<>(partitionBrokers.size());\n+    for (Broker broker : partitionBrokers) {\n+      numPartitionReplicasByRackId.merge(broker.rack().id(), 1, Integer::sum);\n+    }\n+    return numPartitionReplicasByRackId;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return RackAwareDistributionGoal.class.getSimpleName();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions) {\n+    _balanceLimit = new BalanceLimit(clusterModel);\n+    Set<String> excludedTopics = optimizationOptions.excludedTopics();\n+\n+    // Filter out some replicas based on optimization options.\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(),\n+                                                     optimizationOptions.onlyMoveImmigrantReplicas())\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnExcludedTopics(excludedTopics))\n+                              .trackSortedReplicasFor(replicaSortName(this, false, false), clusterModel);\n+  }\n+\n+  /**\n+   * Update goal state.\n+   * Sanity check: After completion of balancing / self-healing, confirm that replicas of each partition are evenly\n+   * distributed across the racks.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // One pass is sufficient to satisfy or alert impossibility of this goal.\n+    // Sanity check to confirm that replicas of each partition are evenly distributed across the racks\n+    ensureRackAwareDistribution(clusterModel, optimizationOptions);\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    finish();\n+  }\n+\n+  @Override\n+  public void finish() {\n+    super.finish();\n+    // Clean up the memory\n+    _balanceLimit.clear();\n+  }\n+\n+  /**\n+   * Violations of rack-aware distribution can be resolved with replica movements.\n+   *\n+   * @param broker Broker to be balanced.\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    rebalanceForBroker(broker, clusterModel, optimizedGoals, optimizationOptions, false);\n+  }\n+\n+  /**\n+   * Get a list of eligible brokers for moving the given replica in the given cluster to satisfy the specific\n+   * requirements of the custom rack aware goal.\n+   * A broker is rack aware distribution eligible for a given replica if it is in a rack\n+   * <ul>\n+   *   <li>that needs more replicas -- i.e. has fewer than base limit replicas</li>\n+   *   <li>with at most as many as base limit replicas, and the number of racks with at least one more replica over the\n+   *   base limit is fewer than the allowed number of such racks</li>\n+   * </ul>\n+   *\n+   * @param replica Replica for which a set of rack aware eligible brokers are requested.\n+   * @param clusterModel The state of the cluster.\n+   * @return A list of rack aware eligible brokers for the given replica in the given cluster.\n+   */\n+  @Override\n+  protected SortedSet<Broker> rackAwareEligibleBrokers(Replica replica, ClusterModel clusterModel) {\n+    Set<Broker> partitionBrokers = clusterModel.partition(replica.topicPartition()).partitionBrokers();\n+    Map<String, Integer> numReplicasByRack = numPartitionReplicasByRackId(partitionBrokers);\n+\n+    // Decrement the number of replicas in this rack.\n+    numReplicasByRack.merge(replica.broker().rack().id(), -1, Integer::sum);\n+\n+    int baseLimit = _balanceLimit.baseLimitByRF(partitionBrokers.size());\n+\n+    // An replica is allowed to be moved to a rack at the base limit only if the number of racks with at least one more\n+    // replica over the base limit is fewer than the allowed number of such racks", "originalCommit": "c662079c771771e8f2706d06674b39659301ed8a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg1MDY2Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1345#discussion_r505850667", "bodyText": "Sure -- added an example.", "author": "efeg", "createdAt": "2020-10-15T21:05:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgwMTQ2NQ=="}], "type": "inlineReview"}, {"oid": "f2ad76b9a1ee10778c9681cc6849f80ce16e2ddf", "url": "https://github.com/linkedin/cruise-control/commit/f2ad76b9a1ee10778c9681cc6849f80ce16e2ddf", "message": "Address the feedback", "committedDate": "2020-10-15T21:05:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkwMTUwNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1345#discussion_r505901505", "bodyText": "Should this be:\n  int upperLimit = baseLimit + (numRacksWithOneMoreReplicaLimit == 0 ? 0 : 1);", "author": "smccauliff", "createdAt": "2020-10-15T22:33:22Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/RackAwareDistributionGoal.java", "diffHunk": "@@ -0,0 +1,354 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+import static java.util.Collections.max;\n+import static java.util.Collections.min;\n+\n+\n+/**\n+ * HARD GOAL: Generate replica movement proposals to evenly distribute replicas over racks.\n+ *\n+ * This is a relaxed version of {@link RackAwareGoal}. Contrary to {@link RackAwareGoal}, as long as replicas of each\n+ * partition can achieve a perfectly even distribution across the racks, this goal lets placement of multiple replicas\n+ * of a partition into a single rack.\n+ *\n+ * <p>\n+ *   For example, suppose a topic with 1 partition has 4 replicas in a cluster with 2 racks. Then the following\n+ *   distribution will be acceptable by this goal (but would be unacceptable by {@link RackAwareGoal}):\n+ * </p>\n+ *\n+ * <pre>\n+ * Rack A                    | Rack B\n+ * -----------------------------------------------------\n+ * Broker1-rack A  replica-0 | Broker2-rack B\n+ * Broker3-rack A            | Broker4-rack B replica-1\n+ * Broker5-rack A  replica-2 | Broker6-rack B\n+ * Broker7-rack A            | Broker8-rack B replica-3\n+ * </pre>\n+ *\n+ * <p>\n+ *   However, this goal will yield an {@link OptimizationFailureException} for the same partition in the following\n+ *   cluster due to the lack of a second broker to place a replica of this partition in {@code Rack B}:\n+ * </p>\n+ *\n+ * <pre>\n+ * Rack A                    | Rack B\n+ * -----------------------------------------------------\n+ * Broker1-rack A  replica-0 | Broker2-rack B replica-1\n+ * Broker3-rack A  replica-3 |\n+ * Broker5-rack A  replica-2 |\n+ * </pre>\n+ */\n+public class RackAwareDistributionGoal extends AbstractRackAwareGoal {\n+  private BalanceLimit _balanceLimit;\n+\n+  /**\n+   * Constructor for Rack Aware Distribution Goal.\n+   */\n+  public RackAwareDistributionGoal() {\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  RackAwareDistributionGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  protected boolean doesReplicaMoveViolateActionAcceptance(ClusterModel clusterModel, Replica sourceReplica, Broker destinationBroker) {\n+    String destinationRackId = destinationBroker.rack().id();\n+    String sourceRackId = sourceReplica.broker().rack().id();\n+\n+    if (sourceRackId.equals(destinationRackId)) {\n+      // A replica move within the same rack cannot violate rack aware distribution.\n+      return false;\n+    }\n+\n+    // The replica move shall not increase the replica distribution imbalance of the partition across racks.\n+    Set<Broker> partitionBrokers = clusterModel.partition(sourceReplica.topicPartition()).partitionBrokers();\n+    Map<String, Integer> numReplicasByRack = numPartitionReplicasByRackId(partitionBrokers);\n+\n+    return numReplicasByRack.getOrDefault(destinationRackId, 0) >= numReplicasByRack.getOrDefault(sourceRackId, 0);\n+  }\n+\n+  /**\n+   * Given the brokers that host replicas of a partition, retrieves a map containing number of replicas by the id of the\n+   * rack they reside in.\n+   *\n+   * @param partitionBrokers Brokers that host replicas of some partition\n+   * @return A map containing the number of replicas by rack id that these replicas reside in.\n+   */\n+  private static Map<String, Integer> numPartitionReplicasByRackId(Set<Broker> partitionBrokers) {\n+    Map<String, Integer> numPartitionReplicasByRackId = new HashMap<>(partitionBrokers.size());\n+    for (Broker broker : partitionBrokers) {\n+      numPartitionReplicasByRackId.merge(broker.rack().id(), 1, Integer::sum);\n+    }\n+    return numPartitionReplicasByRackId;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return RackAwareDistributionGoal.class.getSimpleName();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions) {\n+    _balanceLimit = new BalanceLimit(clusterModel);\n+    Set<String> excludedTopics = optimizationOptions.excludedTopics();\n+\n+    // Filter out some replicas based on optimization options.\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(),\n+                                                     optimizationOptions.onlyMoveImmigrantReplicas())\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnExcludedTopics(excludedTopics))\n+                              .trackSortedReplicasFor(replicaSortName(this, false, false), clusterModel);\n+  }\n+\n+  /**\n+   * Update goal state.\n+   * Sanity check: After completion of balancing / self-healing, confirm that replicas of each partition are evenly\n+   * distributed across the racks.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // One pass is sufficient to satisfy or alert impossibility of this goal.\n+    // Sanity check to confirm that replicas of each partition are evenly distributed across the racks\n+    ensureRackAwareDistribution(clusterModel, optimizationOptions);\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    finish();\n+  }\n+\n+  @Override\n+  public void finish() {\n+    super.finish();\n+    // Clean up the memory\n+    _balanceLimit.clear();\n+  }\n+\n+  /**\n+   * Violations of rack-aware distribution can be resolved with replica movements.\n+   *\n+   * @param broker Broker to be balanced.\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    rebalanceForBroker(broker, clusterModel, optimizedGoals, optimizationOptions, false);\n+  }\n+\n+  /**\n+   * Get a list of eligible brokers for moving the given replica in the given cluster to satisfy the specific\n+   * requirements of the custom rack aware goal.\n+   * A broker is rack aware distribution eligible for a given replica if it is in a rack\n+   * <ul>\n+   *   <li>that needs more replicas -- i.e. has fewer than base limit replicas</li>\n+   *   <li>with at most as many as base limit replicas, and the number of racks with at least one more replica over the\n+   *   base limit is fewer than the allowed number of such racks</li>\n+   * </ul>\n+   *\n+   * @param replica Replica for which a set of rack aware eligible brokers are requested.\n+   * @param clusterModel The state of the cluster.\n+   * @return A list of rack aware eligible brokers for the given replica in the given cluster.\n+   */\n+  @Override\n+  protected SortedSet<Broker> rackAwareEligibleBrokers(Replica replica, ClusterModel clusterModel) {\n+    Set<Broker> partitionBrokers = clusterModel.partition(replica.topicPartition()).partitionBrokers();\n+    Map<String, Integer> numReplicasByRack = numPartitionReplicasByRackId(partitionBrokers);\n+\n+    // Decrement the number of replicas in this rack.\n+    numReplicasByRack.merge(replica.broker().rack().id(), -1, Integer::sum);\n+\n+    int baseLimit = _balanceLimit.baseLimitByRF(partitionBrokers.size());\n+\n+    // A replica is allowed to be moved to a rack at the base limit only if the number of racks with at least one more\n+    // replica over the base limit is fewer than the allowed number of such racks.\n+    // For example, suppose a partition has 5 replicas in a cluster with 3 racks. In the ideal distribution, 2 racks has\n+    // 2 replicas and the other rack has 1 replica from the partition. Suppose that in the current distribution, Rack-1\n+    // has 1 offline and 1 online replica, Rack-2 has 2 online replicas, and Rack-3 has 1 online replica. In this scenario,\n+    // we can place the offline replica to an alive broker in either Rack-1 or Rack-3, because the cluster has only one\n+    // rack with at least one more replica over the base limit and we know that the ideal distribution allows 2 such racks.\n+    boolean canMoveToRacksAtBaseLimit = false;\n+    int numRacksWithOneMoreReplicaLimit = _balanceLimit.numRacksWithOneMoreReplicaByRF(partitionBrokers.size());\n+    int numRacksWithAtLeastOneMoreReplica = (int) numReplicasByRack.values().stream().filter(r -> r > baseLimit).count();\n+    if (numRacksWithAtLeastOneMoreReplica < numRacksWithOneMoreReplicaLimit) {\n+      canMoveToRacksAtBaseLimit = true;\n+    }\n+\n+    // Prefer brokers whose rack has fewer replicas from the partition\n+    SortedSet<Broker> rackAwareDistributionEligibleBrokers = new TreeSet<>(\n+        Comparator.comparingInt((Broker b) -> numReplicasByRack.getOrDefault(b.rack().id(), 0))\n+                  .thenComparingInt(Broker::id));\n+\n+    for (Broker destinationBroker : clusterModel.aliveBrokers()) {\n+      int numReplicasInThisRack = numReplicasByRack.getOrDefault(destinationBroker.rack().id(), 0);\n+      if ((numReplicasInThisRack < baseLimit) || (canMoveToRacksAtBaseLimit && (numReplicasInThisRack == baseLimit))) {\n+        // Either the (1) destination rack needs more replicas or (2) the replica is allowed to be moved to a rack at\n+        // the base limit and the destination broker is in a rack at the base limit\n+        if (!partitionBrokers.contains(destinationBroker)) {\n+          rackAwareDistributionEligibleBrokers.add(destinationBroker);\n+        }\n+      }\n+    }\n+\n+    // Return eligible brokers\n+    return rackAwareDistributionEligibleBrokers;\n+  }\n+\n+  @Override\n+  protected boolean shouldKeepInTheCurrentRack(Replica replica, ClusterModel clusterModel) {\n+    // Rack aware distribution requires perfectly even distribution for replicas of each partition across the racks.\n+    // This permits placement of multiple replicas of a partition into a single rack.\n+    Set<Broker> partitionBrokers = clusterModel.partition(replica.topicPartition()).partitionBrokers();\n+    int replicationFactor = partitionBrokers.size();\n+    Map<String, Integer> numReplicasByRack = numPartitionReplicasByRackId(partitionBrokers);\n+\n+    int baseLimit = _balanceLimit.baseLimitByRF(replicationFactor);\n+    int numRacksWithOneMoreReplicaLimit = _balanceLimit.numRacksWithOneMoreReplicaByRF(replicationFactor);\n+    int upperLimit = baseLimit + numRacksWithOneMoreReplicaLimit == 0 ? 0 : 1;", "originalCommit": "f2ad76b9a1ee10778c9681cc6849f80ce16e2ddf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkwODA5Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1345#discussion_r505908092", "bodyText": "Thanks for catching that!", "author": "efeg", "createdAt": "2020-10-15T22:51:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkwMTUwNQ=="}], "type": "inlineReview"}, {"oid": "f7cef65a5a28b73e41308ee9166b65d080020bd9", "url": "https://github.com/linkedin/cruise-control/commit/f7cef65a5a28b73e41308ee9166b65d080020bd9", "message": "Fix the bug in setting upper limit.", "committedDate": "2020-10-15T22:50:31Z", "type": "commit"}]}