{"pr_number": 1391, "pr_title": "Calculate balance lower bound for resource distribution lower bound with low utilization threshold", "pr_createdAt": "2020-11-20T05:38:42Z", "pr_url": "https://github.com/linkedin/cruise-control/pull/1391", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc2MzI1Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r529763256", "bodyText": "Can we avoid using wildcard import?", "author": "efeg", "createdAt": "2020-11-24T17:44:48Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/analyzer/LowResourceUtilizationTest.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+package com.linkedin.kafka.cruisecontrol.analyzer;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.ResourceDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.common.DeterministicCluster;\n+import com.linkedin.kafka.cruisecontrol.common.Resource;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.ExecutorConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.MonitorConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.executor.ExecutionProposal;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaPlacementInfo;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.kafka.common.TopicPartition;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.junit.Assert.*;", "originalCommit": "bd5498ccfdc58b41a2cebf216a0ec45d08950662", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc3MTEzOQ==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r529771139", "bodyText": "This does not look right.\n--\nSuppose the cluster has 3 brokers.\nOne broker has a resource utilization under LowUtilizationThreshold, and\nthe other two are within the balance upper and lower limits.\nWhile this load distribution is clearly not balanced, the resource distribution goal will report a false positive -- i.e. _succeeded will be true.\nThis function should answer the following question:\n\nDo all brokers have a resource utilization under LowUtilizationThreshold?\n1.1. If answer to 1 is true, then this goal returns success,\n1.2. otherwise, continue checking for lower/upper limits using the existing logic.", "author": "efeg", "createdAt": "2020-11-24T17:57:14Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/ResourceDistributionGoal.java", "diffHunk": "@@ -260,6 +260,10 @@ protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions op\n     // Log broker Ids over balancing limit.\n     // While proposals exclude the excludedTopics, the balance still considers utilization of the excludedTopic replicas.\n     for (Broker broker : clusterModel.aliveBrokers()) {\n+      if (isLoadUnderLowUtilizationThreshold(broker)) {\n+        continue;\n+      }\n+", "originalCommit": "bd5498ccfdc58b41a2cebf216a0ec45d08950662", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc5NzM1Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r529797357", "bodyText": "Looks like actionAcceptance implementation above does not take low utilization threshold into account. It should ensure that if all brokers were already under the low threshold, anything under low threshold is acceptable. Am I missing something?", "author": "efeg", "createdAt": "2020-11-24T18:39:17Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/ResourceDistributionGoal.java", "diffHunk": "@@ -260,6 +260,10 @@ protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions op\n     // Log broker Ids over balancing limit.", "originalCommit": "bd5498ccfdc58b41a2cebf216a0ec45d08950662", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDExMTA0OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r530111049", "bodyText": "What exactly do you mean by It should ensure that if all brokers were already under the low threshold, anything under low threshold is acceptable?\nI think it should be that after the proposed action, if the load is not within the range of [lowerLimit, upperLimit], instead of rejecting the action right away, we check whether the load is under the low threshold. If it is, we accept the action and vice versa. Is it correct?", "author": "Lincong", "createdAt": "2020-11-25T05:07:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc5NzM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU1OTIxMA==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r530559210", "bodyText": "What exactly do you mean by It should ensure that if all brokers were already under the low threshold, anything under low threshold is acceptable?\n\nWhen actionAcceptance is called, suppose the cluster has 3 brokers: broker B1 has a resource (e.g. disk resource) utilization under LowUtilizationThreshold, and brokers B2 and B3 are above LowUtilizationThreshold. This is an example cluster, where not all brokers were already under the low threshold -- i.e. B2 and B3 are above it. Hence, LowUtilizationThreshold does not apply to any broker in the cluster because of how this threshold is defined in its documentation:\n\n  \n    \n      cruise-control/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnalyzerConfig.java\n    \n    \n        Lines 141 to 147\n      in\n      5ed774e\n    \n    \n    \n    \n\n        \n          \n             /** \n        \n\n        \n          \n              * <code>disk.low.utilization.threshold</code> \n        \n\n        \n          \n              */ \n        \n\n        \n          \n             public static final String DISK_LOW_UTILIZATION_THRESHOLD_CONFIG = \"disk.low.utilization.threshold\"; \n        \n\n        \n          \n             public static final String DISK_LOW_UTILIZATION_THRESHOLD_DOC = \"The threshold for Kafka Cruise Control to define the \" \n        \n\n        \n          \n                 + \"utilization of DISK is low enough that rebalance is not worthwhile. The cluster will only be in a low \" \n        \n\n        \n          \n                 + \"utilization state when all the brokers are below the low utilization threshold. The threshold is in percentage.\"; \n        \n    \n  \n\n\n\nI think it should be that after the proposed action, if the load is not within the range of [lowerLimit, upperLimit], instead of rejecting the action right away, we check whether the load is under the low threshold. If it is, we accept the action and vice versa. Is it correct?\n\nNo, because we should apply only the relevant limits. If the cluster has brokers above the lower threshold, then LowUtilizationThreshold is irrelevant. Similarly, if all brokers are under the threshold, we use [0, LowUtilizationThreshold] as the acceptable limits as described above.", "author": "efeg", "createdAt": "2020-11-25T18:04:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc5NzM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcyNTIzMw==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r530725233", "bodyText": "We discussed offline -- see #1391 (comment)", "author": "efeg", "createdAt": "2020-11-26T01:38:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc5NzM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc5OTI2Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r529799266", "bodyText": "If all brokers are under low utilization threshold, shouldn't we update the following in initGoalState function to make sure that balancing limits are set properly?\n  private double _balanceUpperThreshold;\n  private double _balanceLowerThreshold;", "author": "efeg", "createdAt": "2020-11-24T18:42:20Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/ResourceDistributionGoal.java", "diffHunk": "@@ -260,6 +260,10 @@ protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions op\n     // Log broker Ids over balancing limit.\n     // While proposals exclude the excludedTopics, the balance still considers utilization of the excludedTopic replicas.", "originalCommit": "bd5498ccfdc58b41a2cebf216a0ec45d08950662", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwODA5MA==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r530608090", "bodyText": "After some offline discussion, we decided to only look at the overall cluster resource utilization over brokers that are not excluded for replica move instead of whether all brokers are under the low utilization threshold. The reason is that suppose we have a cluster of 3 broker A, B, and C where A and B have no resource utilization and C has some resource utilization that is slightly over the low utilization threshold. In this case, we adjust the lower/upper thresholds basing on the low utilization threshold instead of using the thresholds calculated from the original resource utilization percentage given in the config. This way, the rebalance might involve fewer operations.\nIn general, the gist is to set more lenient and reasonable values to the balance upper/lower threshold parameters instead of avoiding rebalance completely.", "author": "Lincong", "createdAt": "2020-11-25T19:47:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc5OTI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwMDg5NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r529800895", "bodyText": "What if there are dead disks -- i.e. broker is alive, but there are dead disks on alive brokers?\nWouldn't this cause us to drop JBOD support when there are offline disks?", "author": "efeg", "createdAt": "2020-11-24T18:45:05Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/ResourceDistributionGoal.java", "diffHunk": "@@ -329,6 +333,11 @@ protected void rebalanceForBroker(Broker broker,\n                                     ClusterModel clusterModel,\n                                     Set<Goal> optimizedGoals,\n                                     OptimizationOptions optimizationOptions) {\n+\n+    if (clusterModel.deadBrokers().isEmpty() && allAliveBrokersBalanced(clusterModel, optimizationOptions)) {\n+      return;\n+    }\n+", "originalCommit": "bd5498ccfdc58b41a2cebf216a0ec45d08950662", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2NjEzOA==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r530166138", "bodyText": "Do you mean that if there is any alive broker having bad disks, we should continue with the normal rebalance process instead of returning here?", "author": "Lincong", "createdAt": "2020-11-25T07:50:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwMDg5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU2NjU5Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r530566596", "bodyText": "Yes. If we terminate early due to this new if statement, after the goal optimization we would end up with offline replicas on dead disks, don't we?\nBut adding this if statement causes other issues. In particular, brokers excluded for replica move no longer give away their replicas to other available brokers. Let's discuss a potential approach to resolve this issues offline.", "author": "efeg", "createdAt": "2020-11-25T18:19:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwMDg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwMjY5NA==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r529802694", "bodyText": "Above you are checking whether _brokersAllowedReplicaMove are having utilization over lowUtilizationThreshold or not. Here you are claiming that all alive brokers are balanced. Which one is it?", "author": "efeg", "createdAt": "2020-11-24T18:48:31Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/model/ClusterModelStats.java", "diffHunk": "@@ -279,13 +282,23 @@ private void utilizationForResources(ClusterModel clusterModel, OptimizationOpti\n           double capacity = resource.isHostResource() ? broker.host().capacityFor(resource)\n                                                       : broker.capacityFor(resource);\n           double utilizationPercentage = utilization / capacity;\n+          if (utilizationPercentage > lowUtilizationThreshold) {\n+            allBrokersBelowLowUtilizationThreshold = false;\n+          }\n+\n           if (utilizationPercentage >= balanceLowerThreshold && utilizationPercentage <= balanceUpperThreshold) {\n             numBalancedBrokersInBrokersAllowedReplicaMove++;\n           }\n           varianceSum += Math.pow(utilization - avgUtilizationPercentage * capacity, 2);\n         }\n       }\n-      _numBalancedBrokersByResource.put(resource, numBalancedBrokersInBrokersAllowedReplicaMove);\n+\n+      if (allBrokersBelowLowUtilizationThreshold) {\n+        // All alive brokers are balanced\n+        _numBalancedBrokersByResource.put(resource, clusterModel.aliveBrokers().size());", "originalCommit": "bd5498ccfdc58b41a2cebf216a0ec45d08950662", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcxNjA3MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r530716071", "bodyText": "After offline discussion, this logic is not needed", "author": "Lincong", "createdAt": "2020-11-26T01:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwMjY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwNDc2NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r529804765", "bodyText": "What if the lowUtilizationThreshold and utilizationPercentage are both 0? Wouldn't >= be a sufficient condition?", "author": "efeg", "createdAt": "2020-11-24T18:51:50Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/model/ClusterModelStats.java", "diffHunk": "@@ -279,13 +282,23 @@ private void utilizationForResources(ClusterModel clusterModel, OptimizationOpti\n           double capacity = resource.isHostResource() ? broker.host().capacityFor(resource)\n                                                       : broker.capacityFor(resource);\n           double utilizationPercentage = utilization / capacity;\n+          if (utilizationPercentage > lowUtilizationThreshold) {", "originalCommit": "bd5498ccfdc58b41a2cebf216a0ec45d08950662", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2OTc0MA==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r530169740", "bodyText": "Right", "author": "Lincong", "createdAt": "2020-11-25T07:57:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwNDc2NQ=="}], "type": "inlineReview"}, {"oid": "31ac3c0371bef7765e236fdc6c5783dedc7a1ce1", "url": "https://github.com/linkedin/cruise-control/commit/31ac3c0371bef7765e236fdc6c5783dedc7a1ce1", "message": "Fixed some issues", "committedDate": "2020-11-25T08:05:21Z", "type": "forcePushed"}, {"oid": "c75c51970820f50ffaff6488c18a9c779b309aac", "url": "https://github.com/linkedin/cruise-control/commit/c75c51970820f50ffaff6488c18a9c779b309aac", "message": "Fixed PR issues", "committedDate": "2020-11-26T02:36:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY4MTQxNg==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r533681416", "bodyText": "Typo: ... -> @param balancingConstraint Balancing constraint.", "author": "efeg", "createdAt": "2020-12-01T19:54:17Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/GoalUtils.java", "diffHunk": "@@ -486,4 +487,67 @@ public static String mitigationForOptimizationFailures(OptimizationOptions optim\n \n     return sb.toString();\n   }\n+\n+  /**\n+   * Compute the utilization upper/lower threshold in percent for the given type of resource\n+   *\n+   * @param avgUtilizationPercentage Average cluster utilization that excludes the capacity of brokers excluded for replica moves.\n+   * @param resource {@link Resource}\n+   * @param balancingConstraint balancing contraints", "originalCommit": "0111f5dca716caddf672e6581b6c176add204eeb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY4MjM4Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r533682382", "bodyText": "(Applies to other classes in this PR -- e.g. GoalUtilsTest) Bad indentation -- please see https://github.com/linkedin/cruise-control/blob/master/docs/code-style.xml", "author": "efeg", "createdAt": "2020-12-01T19:55:47Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/GoalUtils.java", "diffHunk": "@@ -486,4 +487,67 @@ public static String mitigationForOptimizationFailures(OptimizationOptions optim\n \n     return sb.toString();\n   }\n+\n+  /**\n+   * Compute the utilization upper/lower threshold in percent for the given type of resource\n+   *\n+   * @param avgUtilizationPercentage Average cluster utilization that excludes the capacity of brokers excluded for replica moves.\n+   * @param resource {@link Resource}\n+   * @param balancingConstraint balancing contraints\n+   * @param isTriggeredByGoalViolation Options to adjust balance percentage with margin in case goal optimization is triggered\n+   * by goal violation detector.\n+   * @param balanceMargin resource distribution goal balance margin\n+   * @param isLowerThreshold whether this method calculates resource utilization threshold upper bound or lower bound\n+   * @return The utilization upper/lower threshold in percent for the given type of resource\n+   */\n+  public static double computeResourceUtilizationBalanceThreshold(double avgUtilizationPercentage,\n+                                                                  Resource resource,\n+                                                                  BalancingConstraint balancingConstraint,\n+                                                                  boolean isTriggeredByGoalViolation,\n+                                                                  double balanceMargin,\n+                                                                  boolean isLowerThreshold) {\n+\n+    if (balanceMargin >= 1) {\n+      throw new IllegalArgumentException(\"Balance margin must be less than 1.0. Got: \" + balanceMargin);\n+    }\n+    boolean isLowUtilization = avgUtilizationPercentage <= balancingConstraint.lowUtilizationThreshold(resource);\n+\n+    if (isLowerThreshold) {\n+      if (isLowUtilization) {\n+        return 0.0;\n+      }\n+      double balancePercentageWithMargin =\n+          balancePercentageWithMargin(isTriggeredByGoalViolation, balancingConstraint, resource, balanceMargin);\n+      return avgUtilizationPercentage * Math.max(0, (1 - balancePercentageWithMargin));\n+\n+    } else {\n+      if (isLowUtilization) {\n+        return balancingConstraint.lowUtilizationThreshold(resource) * balanceMargin;\n+      }\n+      double balancePercentageWithMargin =\n+          balancePercentageWithMargin(isTriggeredByGoalViolation, balancingConstraint, resource, balanceMargin);\n+      return avgUtilizationPercentage * (1 + balancePercentageWithMargin);\n+    }\n+  }\n+\n+  /**\n+   * To avoid churns, we add a balance margin to the user specified rebalance threshold. e.g. when user sets the\n+   * threshold to be resourceBalancePercentage, we use (resourceBalancePercentage-1)*balanceMargin instead.\n+   *\n+   * @param isTriggeredByGoalViolation Options to adjust balance percentage with margin in case goal optimization is triggered\n+   * by goal violation detector.\n+   * @return The rebalance threshold with a margin.\n+   */\n+  private static double balancePercentageWithMargin(boolean isTriggeredByGoalViolation,\n+      BalancingConstraint balancingConstraint,\n+      Resource resource,\n+      double balanceMargin) {", "originalCommit": "0111f5dca716caddf672e6581b6c176add204eeb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY4NTk0MA==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r533685940", "bodyText": "Nit: Redundant space.", "author": "efeg", "createdAt": "2020-12-01T20:01:37Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/ResourceDistributionGoal.java", "diffHunk": "@@ -329,6 +340,7 @@ protected void rebalanceForBroker(Broker broker,\n                                     ClusterModel clusterModel,\n                                     Set<Goal> optimizedGoals,\n                                     OptimizationOptions optimizationOptions) {\n+", "originalCommit": "0111f5dca716caddf672e6581b6c176add204eeb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY4OTU3Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r533689573", "bodyText": "The method has 4 parameters, but only one of them is documented in the JavaDoc.\nCan we document the missing parameters?", "author": "efeg", "createdAt": "2020-12-01T20:08:25Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/GoalUtils.java", "diffHunk": "@@ -486,4 +487,67 @@ public static String mitigationForOptimizationFailures(OptimizationOptions optim\n \n     return sb.toString();\n   }\n+\n+  /**\n+   * Compute the utilization upper/lower threshold in percent for the given type of resource\n+   *\n+   * @param avgUtilizationPercentage Average cluster utilization that excludes the capacity of brokers excluded for replica moves.\n+   * @param resource {@link Resource}\n+   * @param balancingConstraint balancing contraints\n+   * @param isTriggeredByGoalViolation Options to adjust balance percentage with margin in case goal optimization is triggered\n+   * by goal violation detector.\n+   * @param balanceMargin resource distribution goal balance margin\n+   * @param isLowerThreshold whether this method calculates resource utilization threshold upper bound or lower bound\n+   * @return The utilization upper/lower threshold in percent for the given type of resource\n+   */\n+  public static double computeResourceUtilizationBalanceThreshold(double avgUtilizationPercentage,\n+                                                                  Resource resource,\n+                                                                  BalancingConstraint balancingConstraint,\n+                                                                  boolean isTriggeredByGoalViolation,\n+                                                                  double balanceMargin,\n+                                                                  boolean isLowerThreshold) {\n+\n+    if (balanceMargin >= 1) {\n+      throw new IllegalArgumentException(\"Balance margin must be less than 1.0. Got: \" + balanceMargin);\n+    }\n+    boolean isLowUtilization = avgUtilizationPercentage <= balancingConstraint.lowUtilizationThreshold(resource);\n+\n+    if (isLowerThreshold) {\n+      if (isLowUtilization) {\n+        return 0.0;\n+      }\n+      double balancePercentageWithMargin =\n+          balancePercentageWithMargin(isTriggeredByGoalViolation, balancingConstraint, resource, balanceMargin);\n+      return avgUtilizationPercentage * Math.max(0, (1 - balancePercentageWithMargin));\n+\n+    } else {\n+      if (isLowUtilization) {\n+        return balancingConstraint.lowUtilizationThreshold(resource) * balanceMargin;\n+      }\n+      double balancePercentageWithMargin =\n+          balancePercentageWithMargin(isTriggeredByGoalViolation, balancingConstraint, resource, balanceMargin);\n+      return avgUtilizationPercentage * (1 + balancePercentageWithMargin);\n+    }\n+  }\n+\n+  /**\n+   * To avoid churns, we add a balance margin to the user specified rebalance threshold. e.g. when user sets the\n+   * threshold to be resourceBalancePercentage, we use (resourceBalancePercentage-1)*balanceMargin instead.\n+   *\n+   * @param isTriggeredByGoalViolation Options to adjust balance percentage with margin in case goal optimization is triggered\n+   * by goal violation detector.\n+   * @return The rebalance threshold with a margin.\n+   */", "originalCommit": "0111f5dca716caddf672e6581b6c176add204eeb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5MDUzNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r533690535", "bodyText": "The definition of this parameters seems incorrect.", "author": "efeg", "createdAt": "2020-12-01T20:09:58Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/GoalUtils.java", "diffHunk": "@@ -486,4 +487,67 @@ public static String mitigationForOptimizationFailures(OptimizationOptions optim\n \n     return sb.toString();\n   }\n+\n+  /**\n+   * Compute the utilization upper/lower threshold in percent for the given type of resource\n+   *\n+   * @param avgUtilizationPercentage Average cluster utilization that excludes the capacity of brokers excluded for replica moves.\n+   * @param resource {@link Resource}\n+   * @param balancingConstraint balancing contraints\n+   * @param isTriggeredByGoalViolation Options to adjust balance percentage with margin in case goal optimization is triggered\n+   * by goal violation detector.\n+   * @param balanceMargin resource distribution goal balance margin\n+   * @param isLowerThreshold whether this method calculates resource utilization threshold upper bound or lower bound\n+   * @return The utilization upper/lower threshold in percent for the given type of resource\n+   */\n+  public static double computeResourceUtilizationBalanceThreshold(double avgUtilizationPercentage,\n+                                                                  Resource resource,\n+                                                                  BalancingConstraint balancingConstraint,\n+                                                                  boolean isTriggeredByGoalViolation,\n+                                                                  double balanceMargin,\n+                                                                  boolean isLowerThreshold) {\n+\n+    if (balanceMargin >= 1) {\n+      throw new IllegalArgumentException(\"Balance margin must be less than 1.0. Got: \" + balanceMargin);\n+    }\n+    boolean isLowUtilization = avgUtilizationPercentage <= balancingConstraint.lowUtilizationThreshold(resource);\n+\n+    if (isLowerThreshold) {\n+      if (isLowUtilization) {\n+        return 0.0;\n+      }\n+      double balancePercentageWithMargin =\n+          balancePercentageWithMargin(isTriggeredByGoalViolation, balancingConstraint, resource, balanceMargin);\n+      return avgUtilizationPercentage * Math.max(0, (1 - balancePercentageWithMargin));\n+\n+    } else {\n+      if (isLowUtilization) {\n+        return balancingConstraint.lowUtilizationThreshold(resource) * balanceMargin;\n+      }\n+      double balancePercentageWithMargin =\n+          balancePercentageWithMargin(isTriggeredByGoalViolation, balancingConstraint, resource, balanceMargin);\n+      return avgUtilizationPercentage * (1 + balancePercentageWithMargin);\n+    }\n+  }\n+\n+  /**\n+   * To avoid churns, we add a balance margin to the user specified rebalance threshold. e.g. when user sets the\n+   * threshold to be resourceBalancePercentage, we use (resourceBalancePercentage-1)*balanceMargin instead.\n+   *\n+   * @param isTriggeredByGoalViolation Options to adjust balance percentage with margin in case goal optimization is triggered\n+   * by goal violation detector.", "originalCommit": "0111f5dca716caddf672e6581b6c176add204eeb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI3ODExMA==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r534278110", "bodyText": "Thanks for pointing it out. I'll change it to whether this computation is triggered by goal violation", "author": "Lincong", "createdAt": "2020-12-02T15:54:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5MDUzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5MzMyMw==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r533693323", "bodyText": "Can we update the JavaDoc to explain how this function computes the value it returns?", "author": "efeg", "createdAt": "2020-12-01T20:15:00Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/GoalUtils.java", "diffHunk": "@@ -486,4 +487,67 @@ public static String mitigationForOptimizationFailures(OptimizationOptions optim\n \n     return sb.toString();\n   }\n+\n+  /**\n+   * Compute the utilization upper/lower threshold in percent for the given type of resource\n+   *\n+   * @param avgUtilizationPercentage Average cluster utilization that excludes the capacity of brokers excluded for replica moves.\n+   * @param resource {@link Resource}\n+   * @param balancingConstraint balancing contraints\n+   * @param isTriggeredByGoalViolation Options to adjust balance percentage with margin in case goal optimization is triggered\n+   * by goal violation detector.\n+   * @param balanceMargin resource distribution goal balance margin\n+   * @param isLowerThreshold whether this method calculates resource utilization threshold upper bound or lower bound\n+   * @return The utilization upper/lower threshold in percent for the given type of resource\n+   */\n+  public static double computeResourceUtilizationBalanceThreshold(double avgUtilizationPercentage,\n+                                                                  Resource resource,\n+                                                                  BalancingConstraint balancingConstraint,\n+                                                                  boolean isTriggeredByGoalViolation,\n+                                                                  double balanceMargin,\n+                                                                  boolean isLowerThreshold) {\n+\n+    if (balanceMargin >= 1) {\n+      throw new IllegalArgumentException(\"Balance margin must be less than 1.0. Got: \" + balanceMargin);\n+    }\n+    boolean isLowUtilization = avgUtilizationPercentage <= balancingConstraint.lowUtilizationThreshold(resource);", "originalCommit": "0111f5dca716caddf672e6581b6c176add204eeb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5NjM5OA==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r533696398", "bodyText": "The definition of this parameters seems incorrect.", "author": "efeg", "createdAt": "2020-12-01T20:20:32Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/GoalUtils.java", "diffHunk": "@@ -486,4 +487,67 @@ public static String mitigationForOptimizationFailures(OptimizationOptions optim\n \n     return sb.toString();\n   }\n+\n+  /**\n+   * Compute the utilization upper/lower threshold in percent for the given type of resource\n+   *\n+   * @param avgUtilizationPercentage Average cluster utilization that excludes the capacity of brokers excluded for replica moves.\n+   * @param resource {@link Resource}\n+   * @param balancingConstraint balancing contraints\n+   * @param isTriggeredByGoalViolation Options to adjust balance percentage with margin in case goal optimization is triggered\n+   * by goal violation detector.", "originalCommit": "0111f5dca716caddf672e6581b6c176add204eeb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5NzcxOQ==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r533697719", "bodyText": "Nit: Redundant space", "author": "efeg", "createdAt": "2020-12-01T20:23:04Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/model/ClusterModelStats.java", "diffHunk": "@@ -262,13 +263,27 @@ private void utilizationForResources(ClusterModel clusterModel, OptimizationOpti\n     for (Resource resource : Resource.cachedValues()) {\n       double resourceUtilization = clusterModel.load().expectedUtilizationFor(resource);\n       double avgUtilizationPercentage = resourceUtilization / clusterModel.capacityWithAllowedReplicaMovesFor(resource, optimizationOptions);\n-      double balanceUpperThreshold = avgUtilizationPercentage * _balancingConstraint.resourceBalancePercentage(resource);\n-      double balanceLowerThreshold = avgUtilizationPercentage * Math.max(0, (2 - _balancingConstraint.resourceBalancePercentage(resource)));\n+\n+      double balanceUpperThreshold = GoalUtils.computeResourceUtilizationBalanceThreshold(avgUtilizationPercentage,\n+                                                                                          resource,\n+                                                                                          _balancingConstraint,\n+                                                                                          optimizationOptions.isTriggeredByGoalViolation(),\n+                                                                                          ResourceDistributionGoal.BALANCE_MARGIN,\n+                                                                          false);\n+\n+      double balanceLowerThreshold = GoalUtils.computeResourceUtilizationBalanceThreshold(avgUtilizationPercentage,\n+                                                                                          resource,\n+                                                                                          _balancingConstraint,\n+                                                                                          optimizationOptions.isTriggeredByGoalViolation(),\n+                                                                                          ResourceDistributionGoal.BALANCE_MARGIN,\n+                                                                          true);\n+\n       // Maximum, minimum, and standard deviation utilization for the resource.\n       double hottestBrokerUtilization = 0.0;\n       double coldestBrokerUtilization = Double.MAX_VALUE;\n       double varianceSum = 0.0;\n       int numBalancedBrokersInBrokersAllowedReplicaMove = 0;\n+", "originalCommit": "0111f5dca716caddf672e6581b6c176add204eeb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5Nzc1Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r533697756", "bodyText": "Nit: Redundant space", "author": "efeg", "createdAt": "2020-12-01T20:23:09Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/model/ClusterModelStats.java", "diffHunk": "@@ -285,6 +300,7 @@ private void utilizationForResources(ClusterModel clusterModel, OptimizationOpti\n           varianceSum += Math.pow(utilization - avgUtilizationPercentage * capacity, 2);\n         }\n       }\n+", "originalCommit": "0111f5dca716caddf672e6581b6c176add204eeb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5ODc2MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r533698761", "bodyText": "new HashMap<Resource, Double> -> new HashMap<>", "author": "efeg", "createdAt": "2020-12-01T20:24:57Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/analyzer/LowResourceUtilizationTest.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+package com.linkedin.kafka.cruisecontrol.analyzer;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.ResourceDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.common.DeterministicCluster;\n+import com.linkedin.kafka.cruisecontrol.common.Resource;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.ExecutorConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.MonitorConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.executor.ExecutionProposal;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaPlacementInfo;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.kafka.common.TopicPartition;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+\n+/**\n+ * Unit test for testing low utilization threshold taking effect to prevent rebalance for resource distribution goals\n+ */\n+@RunWith(Parameterized.class)\n+public class LowResourceUtilizationTest {\n+\n+  private static final Map<Resource, Double> BROKER_CAPACITY = new HashMap<Resource, Double>() {{", "originalCommit": "0111f5dca716caddf672e6581b6c176add204eeb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI5NjIxNw==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r534296217", "bodyText": "There would be a syntax error cannot use \"<>\" with anonymous inner classes if we do not specify types in <> in this form", "author": "Lincong", "createdAt": "2020-12-02T16:16:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5ODc2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ4Nzg4NA==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r534487884", "bodyText": "This is supported in Java 9 and above source. Since, CC is compiled with Java 11, diamond notation should work.\n@Lincong I assume you were building with Java 8? I am ok to leave it as is to maintain build compatibility with Java 8.", "author": "efeg", "createdAt": "2020-12-02T21:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5ODc2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5OTc4OA==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r533699788", "bodyText": "Nit: Why is expectRebalance a Boolean? -- i.e. is it expected to get a null value?", "author": "efeg", "createdAt": "2020-12-01T20:26:47Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/analyzer/LowResourceUtilizationTest.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+package com.linkedin.kafka.cruisecontrol.analyzer;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.ResourceDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.common.DeterministicCluster;\n+import com.linkedin.kafka.cruisecontrol.common.Resource;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.ExecutorConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.MonitorConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.executor.ExecutionProposal;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaPlacementInfo;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.kafka.common.TopicPartition;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+\n+/**\n+ * Unit test for testing low utilization threshold taking effect to prevent rebalance for resource distribution goals\n+ */\n+@RunWith(Parameterized.class)\n+public class LowResourceUtilizationTest {\n+\n+  private static final Map<Resource, Double> BROKER_CAPACITY = new HashMap<Resource, Double>() {{\n+    put(Resource.CPU, 200.0);\n+    put(Resource.DISK, 1000.0);\n+    put(Resource.NW_IN, 2000.0);\n+    put(Resource.NW_OUT, 2000.0);\n+  }};\n+\n+  private final ClusterModel _clusterModel;\n+  private final ResourceDistributionGoal _resourceDistributionGoal;\n+  private final Map<String, Object> _goalConfigs;\n+  private final Boolean _expectRebalance;\n+\n+  public LowResourceUtilizationTest(ClusterModel clusterModel,\n+                                    ResourceDistributionGoal resourceDistributionGoal,\n+                                    Map<String, Object> goalConfigs,\n+                                    Boolean expectRebalance) {", "originalCommit": "0111f5dca716caddf672e6581b6c176add204eeb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI4NzA3Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r534287077", "bodyText": "It is not expected to be null. I will change it to boolean", "author": "Lincong", "createdAt": "2020-12-02T16:05:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5OTc4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcwNDcyNg==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r533704726", "bodyText": "I wonder if we really need to call getDefaultGoalConfigs() before each test?\nCan't we call it once and use goalConfigs.put(XXX); to override the relevant config afterwards?", "author": "efeg", "createdAt": "2020-12-01T20:35:43Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/analyzer/LowResourceUtilizationTest.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+package com.linkedin.kafka.cruisecontrol.analyzer;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.ResourceDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.common.DeterministicCluster;\n+import com.linkedin.kafka.cruisecontrol.common.Resource;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.ExecutorConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.MonitorConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.executor.ExecutionProposal;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaPlacementInfo;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.kafka.common.TopicPartition;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+\n+/**\n+ * Unit test for testing low utilization threshold taking effect to prevent rebalance for resource distribution goals\n+ */\n+@RunWith(Parameterized.class)\n+public class LowResourceUtilizationTest {\n+\n+  private static final Map<Resource, Double> BROKER_CAPACITY = new HashMap<Resource, Double>() {{\n+    put(Resource.CPU, 200.0);\n+    put(Resource.DISK, 1000.0);\n+    put(Resource.NW_IN, 2000.0);\n+    put(Resource.NW_OUT, 2000.0);\n+  }};\n+\n+  private final ClusterModel _clusterModel;\n+  private final ResourceDistributionGoal _resourceDistributionGoal;\n+  private final Map<String, Object> _goalConfigs;\n+  private final Boolean _expectRebalance;\n+\n+  public LowResourceUtilizationTest(ClusterModel clusterModel,\n+                                    ResourceDistributionGoal resourceDistributionGoal,\n+                                    Map<String, Object> goalConfigs,\n+                                    Boolean expectRebalance) {\n+\n+    _clusterModel = clusterModel;\n+    _resourceDistributionGoal = resourceDistributionGoal;\n+    _goalConfigs = goalConfigs;\n+    _expectRebalance = expectRebalance;\n+  }\n+\n+  /**\n+   * Populate parameters to test rebalance with low utilization threshold. All brokers are alive.\n+   *\n+   * @return Parameters to test rebalance with low utilization threshold.\n+   */\n+  @Parameterized.Parameters\n+  public static Collection<Object[]> data() {\n+    Collection<Object[]> p = new ArrayList<>();\n+\n+    // Expect rebalance on CPU usage distribution goal since one broker's CPU usage is above the low CPU utilization threshold\n+    ClusterModel clusterModel = createSmallClusterModel();\n+    Map<String, Object> goalConfigs = getDefaultGoalConfigs();\n+    goalConfigs.put(AnalyzerConfig.CPU_LOW_UTILIZATION_THRESHOLD_CONFIG, 0.3474);\n+    p.add(params(clusterModel, new CpuUsageDistributionGoal(), goalConfigs, true));\n+\n+    // Expect no rebalance on CPU usage distribution goal since all brokers' CPU usage is below the low CPU utilization threshold\n+    clusterModel = createSmallClusterModel();\n+    goalConfigs = getDefaultGoalConfigs();\n+    goalConfigs.put(AnalyzerConfig.CPU_LOW_UTILIZATION_THRESHOLD_CONFIG, 0.3862);\n+    p.add(params(clusterModel, new CpuUsageDistributionGoal(), goalConfigs, false));\n+\n+    // Expect rebalance on disk usage distribution goal since one broker's disk usage is above the low disk utilization threshold\n+    clusterModel = createSmallClusterModel();\n+    goalConfigs = getDefaultGoalConfigs();\n+    goalConfigs.put(AnalyzerConfig.DISK_LOW_UTILIZATION_THRESHOLD_CONFIG, 0.27);\n+    p.add(params(clusterModel, new DiskUsageDistributionGoal(), goalConfigs, true));\n+\n+    // Expect no rebalance on disk usage distribution goal since all brokers' disk usage is below the low disk utilization threshold\n+    clusterModel = createSmallClusterModel();\n+    goalConfigs = getDefaultGoalConfigs();\n+    goalConfigs.put(AnalyzerConfig.DISK_LOW_UTILIZATION_THRESHOLD_CONFIG, 0.3223);\n+    p.add(params(clusterModel, new DiskUsageDistributionGoal(), goalConfigs, false));\n+\n+    // Expect rebalance on network inbound usage distribution goal since one broker's network inbound usage is\n+    // above the low network inbound utilization threshold\n+    clusterModel = createSmallClusterModel();\n+    goalConfigs = getDefaultGoalConfigs();\n+    goalConfigs.put(AnalyzerConfig.NETWORK_INBOUND_LOW_UTILIZATION_THRESHOLD_CONFIG, 0.12);\n+    p.add(params(clusterModel, new NetworkInboundUsageDistributionGoal(), goalConfigs, true));\n+\n+    // Expect no rebalance on network inbound usage distribution goal since all brokers' network inbound usage is\n+    // below the low network inbound utilization threshold\n+    clusterModel = createSmallClusterModel();\n+    goalConfigs = getDefaultGoalConfigs();\n+    goalConfigs.put(AnalyzerConfig.NETWORK_INBOUND_LOW_UTILIZATION_THRESHOLD_CONFIG, 0.14445);\n+    p.add(params(clusterModel, new NetworkInboundUsageDistributionGoal(), goalConfigs, false));\n+\n+\n+    // Expect rebalance on network outbound usage distribution goal since one broker's network outbound usage is\n+    // above the low network outbound utilization threshold\n+    clusterModel = createSmallClusterModel();\n+    goalConfigs = getDefaultGoalConfigs();\n+    goalConfigs.put(AnalyzerConfig.NETWORK_OUTBOUND_LOW_UTILIZATION_THRESHOLD_CONFIG, 0.14);\n+    p.add(params(clusterModel, new NetworkOutboundUsageDistributionGoal(), goalConfigs, true));\n+\n+    // Expect no rebalance on network outbound usage distribution goal since all brokers' network outbound usage is\n+    // below the low network outbound utilization threshold\n+    clusterModel = createSmallClusterModel();\n+    goalConfigs = getDefaultGoalConfigs();\n+    goalConfigs.put(AnalyzerConfig.NETWORK_OUTBOUND_LOW_UTILIZATION_THRESHOLD_CONFIG, 0.1639);\n+    p.add(params(clusterModel, new NetworkOutboundUsageDistributionGoal(), goalConfigs, false));", "originalCommit": "0111f5dca716caddf672e6581b6c176add204eeb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM1MjMyOQ==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r534352329", "bodyText": "No, I don't see how that can work and what that would buy us. We need a new set of default configs with relevant configs overridden for each test case. This is the most straightforward way of doing it.", "author": "Lincong", "createdAt": "2020-12-02T17:32:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcwNDcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwMTE5NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r534501195", "bodyText": "@Lincong Here is what I mean:\n/*\n * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n */\npackage com.linkedin.kafka.cruisecontrol.analyzer;\n\nimport com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuUsageDistributionGoal;\nimport com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskUsageDistributionGoal;\nimport com.linkedin.kafka.cruisecontrol.analyzer.goals.Goal;\nimport com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundUsageDistributionGoal;\nimport com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundUsageDistributionGoal;\nimport com.linkedin.kafka.cruisecontrol.analyzer.goals.ResourceDistributionGoal;\nimport com.linkedin.kafka.cruisecontrol.common.DeterministicCluster;\nimport com.linkedin.kafka.cruisecontrol.common.Resource;\nimport com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\nimport com.linkedin.kafka.cruisecontrol.config.constants.ExecutorConfig;\nimport com.linkedin.kafka.cruisecontrol.config.constants.MonitorConfig;\nimport com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\nimport com.linkedin.kafka.cruisecontrol.executor.ExecutionProposal;\nimport com.linkedin.kafka.cruisecontrol.model.ClusterModel;\nimport com.linkedin.kafka.cruisecontrol.model.ReplicaPlacementInfo;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport org.apache.kafka.common.TopicPartition;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\nimport static com.linkedin.kafka.cruisecontrol.analyzer.AnalyzerUnitTestUtils.goal;\n\n/**\n * Unit test for testing low utilization threshold taking effect to prevent rebalance for resource distribution goals\n */\n@RunWith(Parameterized.class)\npublic class LowResourceUtilizationTest {\n\n  private static final Map<Resource, Double> BROKER_CAPACITY = new HashMap<Resource, Double>() {{\n    put(Resource.CPU, 200.0);\n    put(Resource.DISK, 1000.0);\n    put(Resource.NW_IN, 2000.0);\n    put(Resource.NW_OUT, 2000.0);\n  }};\n\n  private final ResourceDistributionGoal _resourceDistributionGoal;\n  private final boolean _expectRebalance;\n\n  public LowResourceUtilizationTest(ResourceDistributionGoal resourceDistributionGoal, boolean expectRebalance) {\n    _resourceDistributionGoal = resourceDistributionGoal;\n    _expectRebalance = expectRebalance;\n  }\n\n  /**\n   * Populate parameters to test rebalance with low utilization threshold. All brokers are alive.\n   *\n   * @return Parameters to test rebalance with low utilization threshold.\n   */\n  @Parameterized.Parameters\n  public static Collection<Object[]> data() throws Exception {\n    Collection<Object[]> p = new ArrayList<>();\n    final double maxCpuUtilizationRatio = 0.3475;\n    final double maxDiskUtilizationRatio = 0.28;\n    final double maxNetworkInUtilizationRatio = 0.13;\n    final double maxNetworkOutUtilizationRatio = 0.1475;\n    final double balanceMargin = 0.9;\n\n    // Expect rebalance on CPU usage distribution goal since one broker's CPU usage is above the low CPU utilization threshold\n    Properties configOverrides = new Properties();\n    configOverrides.put(AnalyzerConfig.CPU_LOW_UTILIZATION_THRESHOLD_CONFIG, onePercentSmaller(maxCpuUtilizationRatio));\n    p.add(params(goal(CpuUsageDistributionGoal.class, configOverrides), true));\n\n    // Expect no rebalance on CPU usage distribution goal since all brokers' CPU usage is below the low CPU utilization threshold\n    configOverrides.put(AnalyzerConfig.CPU_LOW_UTILIZATION_THRESHOLD_CONFIG,\n                    onePercentGreater(maxCpuUtilizationRatio / balanceMargin));\n    p.add(params(goal(CpuUsageDistributionGoal.class, configOverrides), false));\n\n    // Expect rebalance on disk usage distribution goal since one broker's disk usage is above the low disk utilization threshold\n    configOverrides.put(AnalyzerConfig.DISK_LOW_UTILIZATION_THRESHOLD_CONFIG, onePercentSmaller(maxDiskUtilizationRatio));\n    p.add(params(goal(DiskUsageDistributionGoal.class, configOverrides), true));\n\n    // Expect no rebalance on disk usage distribution goal since all brokers' disk usage is below the low disk utilization threshold\n    configOverrides.put(AnalyzerConfig.DISK_LOW_UTILIZATION_THRESHOLD_CONFIG,\n                    onePercentGreater(maxDiskUtilizationRatio / balanceMargin));\n    p.add(params(goal(DiskUsageDistributionGoal.class, configOverrides), false));\n\n    // Expect rebalance on network inbound usage distribution goal since one broker's network inbound usage is\n    // above the low network inbound utilization threshold\n    configOverrides.put(AnalyzerConfig.NETWORK_INBOUND_LOW_UTILIZATION_THRESHOLD_CONFIG,\n                    onePercentSmaller(maxNetworkInUtilizationRatio));\n    p.add(params(goal(NetworkInboundUsageDistributionGoal.class, configOverrides), true));\n\n    // Expect no rebalance on network inbound usage distribution goal since all brokers' network inbound usage is\n    // below the low network inbound utilization threshold\n    configOverrides.put(AnalyzerConfig.NETWORK_INBOUND_LOW_UTILIZATION_THRESHOLD_CONFIG,\n                    onePercentGreater(maxNetworkInUtilizationRatio / balanceMargin));\n    p.add(params(goal(NetworkInboundUsageDistributionGoal.class, configOverrides), false));\n\n    // Expect rebalance on network outbound usage distribution goal since one broker's network outbound usage is\n    // above the low network outbound utilization threshold\n    configOverrides.put(AnalyzerConfig.NETWORK_OUTBOUND_LOW_UTILIZATION_THRESHOLD_CONFIG, onePercentSmaller(maxNetworkOutUtilizationRatio));\n    p.add(params(goal(NetworkOutboundUsageDistributionGoal.class, configOverrides), true));\n\n    // Expect no rebalance on network outbound usage distribution goal since all brokers' network outbound usage is\n    // below the low network outbound utilization threshold\n    configOverrides.put(AnalyzerConfig.NETWORK_OUTBOUND_LOW_UTILIZATION_THRESHOLD_CONFIG,\n                    onePercentGreater(maxNetworkOutUtilizationRatio / balanceMargin));\n    p.add(params(goal(NetworkOutboundUsageDistributionGoal.class, configOverrides), false));\n\n    return p;\n  }\n\n  private static Map<String, Object> getDefaultGoalConfigs() {\n    return new HashMap<String, Object>() {{\n      put(MonitorConfig.BOOTSTRAP_SERVERS_CONFIG, \"bootstrap.servers\");\n      put(ExecutorConfig.ZOOKEEPER_CONNECT_CONFIG, \"connect:1234\");\n    }};\n  }\n\n  private static String onePercentGreater(double value) {\n    return Double.toString(value * 1.01);\n  }\n\n  private static String onePercentSmaller(double value) {\n    return Double.toString(value * 0.99);\n  }\n\n  /**\n   * Creates a small cluster model with broker resource utilization percentage shown below:\n   *    Broker-0:\n   *      CPU:    34.75%\n   *      Disk:   28%\n   *      NW_IN:  13%\n   *      NW_OUT: 14.75%\n   *\n   *    Broker-1:\n   *      CPU:    14%\n   *      Disk:   15.5%\n   *      NW_IN:  7%\n   *      NW_OUT: 5.8%\n   *\n   *    Broker-2:\n   *      CPU:    9.75%\n   *      Disk:   13.5%\n   *      NW_IN:  6.5%\n   *      NW_OUT: 0%\n   *\n   * @return cluster model\n   */\n  private static ClusterModel createSmallClusterModel() {\n    return DeterministicCluster.smallClusterModel(BROKER_CAPACITY);\n  }\n\n  private static Object[] params(Goal resourceDistributionGoal, Boolean expectRebalance) {\n    return new Object[]{resourceDistributionGoal, expectRebalance};\n  }\n\n  @Test\n  public void test() throws OptimizationFailureException {\n    ClusterModel clusterModel = createSmallClusterModel();\n    Map<TopicPartition, List<ReplicaPlacementInfo>> initReplicaDistribution = clusterModel.getReplicaDistribution();\n    Map<TopicPartition, ReplicaPlacementInfo> initLeaderDistribution = clusterModel.getLeaderDistribution();\n\n    assertTrue(\"Failed to optimize \" + _resourceDistributionGoal.name(),\n        _resourceDistributionGoal.optimize(clusterModel, Collections.emptySet(), new OptimizationOptions(Collections.emptySet())));\n\n    Set<ExecutionProposal> goalProposals =\n        AnalyzerUtils.getDiff(initReplicaDistribution, initLeaderDistribution, clusterModel);\n\n    if (_expectRebalance) {\n      assertFalse(goalProposals.isEmpty());\n    } else {\n      assertTrue(goalProposals.isEmpty());\n    }\n  }\n}", "author": "efeg", "createdAt": "2020-12-02T21:43:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcwNDcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwMTg1MA==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r534501850", "bodyText": "@Lincong Now you can also drop the following from the above as it is no longer used:\n  private static Map<String, Object> getDefaultGoalConfigs() {\n    return new HashMap<String, Object>() {{\n      put(MonitorConfig.BOOTSTRAP_SERVERS_CONFIG, \"bootstrap.servers\");\n      put(ExecutorConfig.ZOOKEEPER_CONNECT_CONFIG, \"connect:1234\");\n    }};\n  }", "author": "efeg", "createdAt": "2020-12-02T21:45:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcwNDcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUyNzcyOA==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r534527728", "bodyText": "I see. I did not realize that using com.linkedin.kafka.cruisecontrol.analyzer.AnalyzerUnitTestUtils.goal with config overrides does not require specifying default goal configs. Thanks", "author": "Lincong", "createdAt": "2020-12-02T22:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcwNDcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcwNjk0OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r533706949", "bodyText": "Looks like we always create and pass the same cluster model here.\nWhy don't we create it inside public void test() throws OptimizationFailureException {...}?", "author": "efeg", "createdAt": "2020-12-01T20:39:58Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/analyzer/LowResourceUtilizationTest.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+package com.linkedin.kafka.cruisecontrol.analyzer;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.ResourceDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.common.DeterministicCluster;\n+import com.linkedin.kafka.cruisecontrol.common.Resource;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.ExecutorConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.MonitorConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.executor.ExecutionProposal;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaPlacementInfo;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.kafka.common.TopicPartition;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+\n+/**\n+ * Unit test for testing low utilization threshold taking effect to prevent rebalance for resource distribution goals\n+ */\n+@RunWith(Parameterized.class)\n+public class LowResourceUtilizationTest {\n+\n+  private static final Map<Resource, Double> BROKER_CAPACITY = new HashMap<Resource, Double>() {{\n+    put(Resource.CPU, 200.0);\n+    put(Resource.DISK, 1000.0);\n+    put(Resource.NW_IN, 2000.0);\n+    put(Resource.NW_OUT, 2000.0);\n+  }};\n+\n+  private final ClusterModel _clusterModel;\n+  private final ResourceDistributionGoal _resourceDistributionGoal;\n+  private final Map<String, Object> _goalConfigs;\n+  private final Boolean _expectRebalance;\n+\n+  public LowResourceUtilizationTest(ClusterModel clusterModel,\n+                                    ResourceDistributionGoal resourceDistributionGoal,\n+                                    Map<String, Object> goalConfigs,\n+                                    Boolean expectRebalance) {\n+\n+    _clusterModel = clusterModel;", "originalCommit": "0111f5dca716caddf672e6581b6c176add204eeb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM0NTM1Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r534345353", "bodyText": "Good idea", "author": "Lincong", "createdAt": "2020-12-02T17:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcwNjk0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcwNzkxMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r533707911", "bodyText": "If this assert statement fails, then initReplicaDistribution and initLeaderDistribution are computed for no reason.\nShould we move them after the assert statement?", "author": "efeg", "createdAt": "2020-12-01T20:41:41Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/analyzer/LowResourceUtilizationTest.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+package com.linkedin.kafka.cruisecontrol.analyzer;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.ResourceDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.common.DeterministicCluster;\n+import com.linkedin.kafka.cruisecontrol.common.Resource;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.ExecutorConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.MonitorConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.executor.ExecutionProposal;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaPlacementInfo;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.kafka.common.TopicPartition;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+\n+/**\n+ * Unit test for testing low utilization threshold taking effect to prevent rebalance for resource distribution goals\n+ */\n+@RunWith(Parameterized.class)\n+public class LowResourceUtilizationTest {\n+\n+  private static final Map<Resource, Double> BROKER_CAPACITY = new HashMap<Resource, Double>() {{\n+    put(Resource.CPU, 200.0);\n+    put(Resource.DISK, 1000.0);\n+    put(Resource.NW_IN, 2000.0);\n+    put(Resource.NW_OUT, 2000.0);\n+  }};\n+\n+  private final ClusterModel _clusterModel;\n+  private final ResourceDistributionGoal _resourceDistributionGoal;\n+  private final Map<String, Object> _goalConfigs;\n+  private final Boolean _expectRebalance;\n+\n+  public LowResourceUtilizationTest(ClusterModel clusterModel,\n+                                    ResourceDistributionGoal resourceDistributionGoal,\n+                                    Map<String, Object> goalConfigs,\n+                                    Boolean expectRebalance) {\n+\n+    _clusterModel = clusterModel;\n+    _resourceDistributionGoal = resourceDistributionGoal;\n+    _goalConfigs = goalConfigs;\n+    _expectRebalance = expectRebalance;\n+  }\n+\n+  /**\n+   * Populate parameters to test rebalance with low utilization threshold. All brokers are alive.\n+   *\n+   * @return Parameters to test rebalance with low utilization threshold.\n+   */\n+  @Parameterized.Parameters\n+  public static Collection<Object[]> data() {\n+    Collection<Object[]> p = new ArrayList<>();\n+\n+    // Expect rebalance on CPU usage distribution goal since one broker's CPU usage is above the low CPU utilization threshold\n+    ClusterModel clusterModel = createSmallClusterModel();\n+    Map<String, Object> goalConfigs = getDefaultGoalConfigs();\n+    goalConfigs.put(AnalyzerConfig.CPU_LOW_UTILIZATION_THRESHOLD_CONFIG, 0.3474);\n+    p.add(params(clusterModel, new CpuUsageDistributionGoal(), goalConfigs, true));\n+\n+    // Expect no rebalance on CPU usage distribution goal since all brokers' CPU usage is below the low CPU utilization threshold\n+    clusterModel = createSmallClusterModel();\n+    goalConfigs = getDefaultGoalConfigs();\n+    goalConfigs.put(AnalyzerConfig.CPU_LOW_UTILIZATION_THRESHOLD_CONFIG, 0.3862);\n+    p.add(params(clusterModel, new CpuUsageDistributionGoal(), goalConfigs, false));\n+\n+    // Expect rebalance on disk usage distribution goal since one broker's disk usage is above the low disk utilization threshold\n+    clusterModel = createSmallClusterModel();\n+    goalConfigs = getDefaultGoalConfigs();\n+    goalConfigs.put(AnalyzerConfig.DISK_LOW_UTILIZATION_THRESHOLD_CONFIG, 0.27);\n+    p.add(params(clusterModel, new DiskUsageDistributionGoal(), goalConfigs, true));\n+\n+    // Expect no rebalance on disk usage distribution goal since all brokers' disk usage is below the low disk utilization threshold\n+    clusterModel = createSmallClusterModel();\n+    goalConfigs = getDefaultGoalConfigs();\n+    goalConfigs.put(AnalyzerConfig.DISK_LOW_UTILIZATION_THRESHOLD_CONFIG, 0.3223);\n+    p.add(params(clusterModel, new DiskUsageDistributionGoal(), goalConfigs, false));\n+\n+    // Expect rebalance on network inbound usage distribution goal since one broker's network inbound usage is\n+    // above the low network inbound utilization threshold\n+    clusterModel = createSmallClusterModel();\n+    goalConfigs = getDefaultGoalConfigs();\n+    goalConfigs.put(AnalyzerConfig.NETWORK_INBOUND_LOW_UTILIZATION_THRESHOLD_CONFIG, 0.12);\n+    p.add(params(clusterModel, new NetworkInboundUsageDistributionGoal(), goalConfigs, true));\n+\n+    // Expect no rebalance on network inbound usage distribution goal since all brokers' network inbound usage is\n+    // below the low network inbound utilization threshold\n+    clusterModel = createSmallClusterModel();\n+    goalConfigs = getDefaultGoalConfigs();\n+    goalConfigs.put(AnalyzerConfig.NETWORK_INBOUND_LOW_UTILIZATION_THRESHOLD_CONFIG, 0.14445);\n+    p.add(params(clusterModel, new NetworkInboundUsageDistributionGoal(), goalConfigs, false));\n+\n+\n+    // Expect rebalance on network outbound usage distribution goal since one broker's network outbound usage is\n+    // above the low network outbound utilization threshold\n+    clusterModel = createSmallClusterModel();\n+    goalConfigs = getDefaultGoalConfigs();\n+    goalConfigs.put(AnalyzerConfig.NETWORK_OUTBOUND_LOW_UTILIZATION_THRESHOLD_CONFIG, 0.14);\n+    p.add(params(clusterModel, new NetworkOutboundUsageDistributionGoal(), goalConfigs, true));\n+\n+    // Expect no rebalance on network outbound usage distribution goal since all brokers' network outbound usage is\n+    // below the low network outbound utilization threshold\n+    clusterModel = createSmallClusterModel();\n+    goalConfigs = getDefaultGoalConfigs();\n+    goalConfigs.put(AnalyzerConfig.NETWORK_OUTBOUND_LOW_UTILIZATION_THRESHOLD_CONFIG, 0.1639);\n+    p.add(params(clusterModel, new NetworkOutboundUsageDistributionGoal(), goalConfigs, false));\n+\n+    return p;\n+  }\n+\n+  private static Map<String, Object> getDefaultGoalConfigs() {\n+    return new HashMap<String, Object>() {{\n+      put(MonitorConfig.BOOTSTRAP_SERVERS_CONFIG, \"bootstrap.servers\");\n+      put(ExecutorConfig.ZOOKEEPER_CONNECT_CONFIG, \"connect:1234\");\n+    }};\n+  }\n+\n+  /**\n+   * Creates a small cluster model with broker resource utilization percentage shown below:\n+   *    Broker-0:\n+   *      CPU:    34.75%\n+   *      Disk:   28%\n+   *      NW_IN:  13%\n+   *      NW_OUT: 14.75%\n+   *\n+   *    Broker-1:\n+   *      CPU:    14%\n+   *      Disk:   15.5%\n+   *      NW_IN:  7%\n+   *      NW_OUT: 5.8%\n+   *\n+   *    Broker-2:\n+   *      CPU:    9.75%\n+   *      Disk:   13.5%\n+   *      NW_IN:  6.5%\n+   *      NW_OUT: 0%\n+   *\n+   * @return cluster model\n+   */\n+  private static ClusterModel createSmallClusterModel() {\n+    return DeterministicCluster.smallClusterModel(BROKER_CAPACITY);\n+  }\n+\n+  private static Object[] params(ClusterModel clusterModel,\n+                                 ResourceDistributionGoal resourceDistributionGoal,\n+                                 Map<String, Object> goalConfigs,\n+                                 Boolean expectRebalance) {\n+    return new Object[]{clusterModel, resourceDistributionGoal, goalConfigs, expectRebalance};\n+  }\n+\n+  @Test\n+  public void test() throws OptimizationFailureException {\n+    Map<TopicPartition, List<ReplicaPlacementInfo>> initReplicaDistribution = _clusterModel.getReplicaDistribution();\n+    Map<TopicPartition, ReplicaPlacementInfo> initLeaderDistribution = _clusterModel.getLeaderDistribution();\n+\n+    _resourceDistributionGoal.configure(_goalConfigs);\n+    assertTrue(\"Failed to optimize \" + _resourceDistributionGoal.name(),\n+        _resourceDistributionGoal.optimize(_clusterModel, Collections.emptySet(), new OptimizationOptions(Collections.emptySet())));", "originalCommit": "0111f5dca716caddf672e6581b6c176add204eeb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM0NjYxNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r534346615", "bodyText": "We cannot do that since _resourceDistributionGoal.optimize(_clusterModel, ..) changed the _clusterModel and the values of initReplicaDistribution and initLeaderDistribution would be different if we calculate them after the optimization", "author": "Lincong", "createdAt": "2020-12-02T17:23:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcwNzkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcxMjgxMw==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r533712813", "bodyText": "In CC, goals are instantiated by reflection and need to take configuration parameters.\nHence, instantiating CC goals this way is not the expected use-pattern -- can we use the AnalyzerUnitTestUtils#goal API?", "author": "efeg", "createdAt": "2020-12-01T20:50:31Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/analyzer/LowResourceUtilizationTest.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+package com.linkedin.kafka.cruisecontrol.analyzer;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.ResourceDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.common.DeterministicCluster;\n+import com.linkedin.kafka.cruisecontrol.common.Resource;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.ExecutorConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.MonitorConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.executor.ExecutionProposal;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaPlacementInfo;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.kafka.common.TopicPartition;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+\n+/**\n+ * Unit test for testing low utilization threshold taking effect to prevent rebalance for resource distribution goals\n+ */\n+@RunWith(Parameterized.class)\n+public class LowResourceUtilizationTest {\n+\n+  private static final Map<Resource, Double> BROKER_CAPACITY = new HashMap<Resource, Double>() {{\n+    put(Resource.CPU, 200.0);\n+    put(Resource.DISK, 1000.0);\n+    put(Resource.NW_IN, 2000.0);\n+    put(Resource.NW_OUT, 2000.0);\n+  }};\n+\n+  private final ClusterModel _clusterModel;\n+  private final ResourceDistributionGoal _resourceDistributionGoal;\n+  private final Map<String, Object> _goalConfigs;\n+  private final Boolean _expectRebalance;\n+\n+  public LowResourceUtilizationTest(ClusterModel clusterModel,\n+                                    ResourceDistributionGoal resourceDistributionGoal,\n+                                    Map<String, Object> goalConfigs,\n+                                    Boolean expectRebalance) {\n+\n+    _clusterModel = clusterModel;\n+    _resourceDistributionGoal = resourceDistributionGoal;\n+    _goalConfigs = goalConfigs;\n+    _expectRebalance = expectRebalance;\n+  }\n+\n+  /**\n+   * Populate parameters to test rebalance with low utilization threshold. All brokers are alive.\n+   *\n+   * @return Parameters to test rebalance with low utilization threshold.\n+   */\n+  @Parameterized.Parameters\n+  public static Collection<Object[]> data() {\n+    Collection<Object[]> p = new ArrayList<>();\n+\n+    // Expect rebalance on CPU usage distribution goal since one broker's CPU usage is above the low CPU utilization threshold\n+    ClusterModel clusterModel = createSmallClusterModel();\n+    Map<String, Object> goalConfigs = getDefaultGoalConfigs();\n+    goalConfigs.put(AnalyzerConfig.CPU_LOW_UTILIZATION_THRESHOLD_CONFIG, 0.3474);\n+    p.add(params(clusterModel, new CpuUsageDistributionGoal(), goalConfigs, true));", "originalCommit": "0111f5dca716caddf672e6581b6c176add204eeb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyNDkzNA==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r533724934", "bodyText": "Can we explain in comments how we came up with these numbers? Looks like 0.3862 is much higher than the highest broker utilization (i.e. 34.75). Why do we add this additional buffer?", "author": "efeg", "createdAt": "2020-12-01T21:13:32Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/analyzer/LowResourceUtilizationTest.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+package com.linkedin.kafka.cruisecontrol.analyzer;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundUsageDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.ResourceDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.common.DeterministicCluster;\n+import com.linkedin.kafka.cruisecontrol.common.Resource;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.ExecutorConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.MonitorConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.executor.ExecutionProposal;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaPlacementInfo;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.kafka.common.TopicPartition;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+\n+/**\n+ * Unit test for testing low utilization threshold taking effect to prevent rebalance for resource distribution goals\n+ */\n+@RunWith(Parameterized.class)\n+public class LowResourceUtilizationTest {\n+\n+  private static final Map<Resource, Double> BROKER_CAPACITY = new HashMap<Resource, Double>() {{\n+    put(Resource.CPU, 200.0);\n+    put(Resource.DISK, 1000.0);\n+    put(Resource.NW_IN, 2000.0);\n+    put(Resource.NW_OUT, 2000.0);\n+  }};\n+\n+  private final ClusterModel _clusterModel;\n+  private final ResourceDistributionGoal _resourceDistributionGoal;\n+  private final Map<String, Object> _goalConfigs;\n+  private final Boolean _expectRebalance;\n+\n+  public LowResourceUtilizationTest(ClusterModel clusterModel,\n+                                    ResourceDistributionGoal resourceDistributionGoal,\n+                                    Map<String, Object> goalConfigs,\n+                                    Boolean expectRebalance) {\n+\n+    _clusterModel = clusterModel;\n+    _resourceDistributionGoal = resourceDistributionGoal;\n+    _goalConfigs = goalConfigs;\n+    _expectRebalance = expectRebalance;\n+  }\n+\n+  /**\n+   * Populate parameters to test rebalance with low utilization threshold. All brokers are alive.\n+   *\n+   * @return Parameters to test rebalance with low utilization threshold.\n+   */\n+  @Parameterized.Parameters\n+  public static Collection<Object[]> data() {\n+    Collection<Object[]> p = new ArrayList<>();\n+\n+    // Expect rebalance on CPU usage distribution goal since one broker's CPU usage is above the low CPU utilization threshold\n+    ClusterModel clusterModel = createSmallClusterModel();\n+    Map<String, Object> goalConfigs = getDefaultGoalConfigs();\n+    goalConfigs.put(AnalyzerConfig.CPU_LOW_UTILIZATION_THRESHOLD_CONFIG, 0.3474);\n+    p.add(params(clusterModel, new CpuUsageDistributionGoal(), goalConfigs, true));\n+\n+    // Expect no rebalance on CPU usage distribution goal since all brokers' CPU usage is below the low CPU utilization threshold\n+    clusterModel = createSmallClusterModel();\n+    goalConfigs = getDefaultGoalConfigs();\n+    goalConfigs.put(AnalyzerConfig.CPU_LOW_UTILIZATION_THRESHOLD_CONFIG, 0.3862);", "originalCommit": "0111f5dca716caddf672e6581b6c176add204eeb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3Njk1Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r534376952", "bodyText": "I changed the implementation so that the calculation process of these numbers are clear", "author": "Lincong", "createdAt": "2020-12-02T18:09:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyNDkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyNTY2OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r533725669", "bodyText": "Is EasyMock.verify(XXX) missing intentionally?", "author": "efeg", "createdAt": "2020-12-01T21:14:57Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/GoalUtilsTest.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.common.Resource;\n+import org.easymock.EasyMock;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class GoalUtilsTest {\n+\n+  @Test\n+  public void testComputeResourceUtilizationBalanceThreshold() {\n+    Resource resource = Resource.CPU;\n+\n+    // Verify 1: Low utilization and compute balance threshold lower bound\n+    verifyComputingResourceUtilizationBalanceThreshold(0.3,\n+                                                       resource,\n+                                                       ResourceDistributionGoal.BALANCE_MARGIN,\n+                                                       true,\n+                                                       true,\n+                                                       0.4,\n+                                                       1.3,\n+                                                       1.2,\n+                                                       0.0);\n+\n+    // Verify 2: Low utilization and compute balance threshold upper bound\n+    verifyComputingResourceUtilizationBalanceThreshold(0.3,\n+                                                       resource,\n+                                                       ResourceDistributionGoal.BALANCE_MARGIN,\n+                                                       false,\n+                                                       true,\n+                                                       0.4,\n+                                                       1.3,\n+                                                       1.2,\n+                                                       0.4 * ResourceDistributionGoal.BALANCE_MARGIN);\n+\n+    // Verify 3: Not low utilization and compute balance threshold lower bound\n+    verifyComputingResourceUtilizationBalanceThreshold(0.3,\n+                                                       resource,\n+                                                       ResourceDistributionGoal.BALANCE_MARGIN,\n+                                                       true,\n+                                                       true,\n+                                                       0.2,\n+                                                       1.3,\n+                                                       1.2,\n+                                                       0.3 * (1 - ((1.3 * 1.2) - 1) * ResourceDistributionGoal.BALANCE_MARGIN));\n+\n+    // Verify 4: Not low utilization and compute balance threshold upper bound\n+    verifyComputingResourceUtilizationBalanceThreshold(0.3,\n+                                                       resource,\n+                                                       ResourceDistributionGoal.BALANCE_MARGIN,\n+                                                       false,\n+                                                       true,\n+                                                       0.2,\n+                                                       1.3,\n+                                                       1.2,\n+                                                       0.3 * (1 + ((1.3 * 1.2) - 1) * ResourceDistributionGoal.BALANCE_MARGIN));\n+\n+  }\n+\n+  private void verifyComputingResourceUtilizationBalanceThreshold(double avgUtilizationPercentage,\n+                                                                  Resource resource,\n+                                                                  double balanceMargin,\n+                                                                  boolean isLowerThreshold,\n+                                                                  boolean isTriggeredByGoalViolation,\n+                                                                  double lowUtilizationThreshold,\n+                                                                  double resourceBalancePercentage,\n+                                                                  double goalViolationDistributionThresholdMultiplier,\n+                                                                  double expectedComputedBalanceThreshold) {\n+\n+    BalancingConstraint mockBalanceConstraint = EasyMock.mock(BalancingConstraint.class);\n+    EasyMock.expect(mockBalanceConstraint.lowUtilizationThreshold(resource)).andReturn(lowUtilizationThreshold).anyTimes();\n+    EasyMock.expect(mockBalanceConstraint.resourceBalancePercentage(resource)).andReturn(resourceBalancePercentage).anyTimes();\n+    EasyMock.expect(mockBalanceConstraint.goalViolationDistributionThresholdMultiplier()).\n+        andReturn(goalViolationDistributionThresholdMultiplier).anyTimes();\n+\n+    EasyMock.replay(mockBalanceConstraint);", "originalCommit": "0111f5dca716caddf672e6581b6c176add204eeb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI5MDUzNw==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r534290537", "bodyText": "It was missed. I will add it back", "author": "Lincong", "createdAt": "2020-12-02T16:09:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyNTY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyNjE1MA==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r533726150", "bodyText": "We have a lot of parameters, but seems like we only test a few. Can we either drop the constant parameters and assign the value within this function or add test cases that varies the tested parameter.", "author": "efeg", "createdAt": "2020-12-01T21:15:47Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/GoalUtilsTest.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.common.Resource;\n+import org.easymock.EasyMock;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class GoalUtilsTest {\n+\n+  @Test\n+  public void testComputeResourceUtilizationBalanceThreshold() {\n+    Resource resource = Resource.CPU;\n+\n+    // Verify 1: Low utilization and compute balance threshold lower bound\n+    verifyComputingResourceUtilizationBalanceThreshold(0.3,\n+                                                       resource,\n+                                                       ResourceDistributionGoal.BALANCE_MARGIN,\n+                                                       true,\n+                                                       true,\n+                                                       0.4,\n+                                                       1.3,\n+                                                       1.2,\n+                                                       0.0);\n+\n+    // Verify 2: Low utilization and compute balance threshold upper bound\n+    verifyComputingResourceUtilizationBalanceThreshold(0.3,\n+                                                       resource,\n+                                                       ResourceDistributionGoal.BALANCE_MARGIN,\n+                                                       false,\n+                                                       true,\n+                                                       0.4,\n+                                                       1.3,\n+                                                       1.2,\n+                                                       0.4 * ResourceDistributionGoal.BALANCE_MARGIN);\n+\n+    // Verify 3: Not low utilization and compute balance threshold lower bound\n+    verifyComputingResourceUtilizationBalanceThreshold(0.3,\n+                                                       resource,\n+                                                       ResourceDistributionGoal.BALANCE_MARGIN,\n+                                                       true,\n+                                                       true,\n+                                                       0.2,\n+                                                       1.3,\n+                                                       1.2,\n+                                                       0.3 * (1 - ((1.3 * 1.2) - 1) * ResourceDistributionGoal.BALANCE_MARGIN));\n+\n+    // Verify 4: Not low utilization and compute balance threshold upper bound\n+    verifyComputingResourceUtilizationBalanceThreshold(0.3,\n+                                                       resource,\n+                                                       ResourceDistributionGoal.BALANCE_MARGIN,\n+                                                       false,\n+                                                       true,\n+                                                       0.2,\n+                                                       1.3,\n+                                                       1.2,\n+                                                       0.3 * (1 + ((1.3 * 1.2) - 1) * ResourceDistributionGoal.BALANCE_MARGIN));\n+\n+  }\n+\n+  private void verifyComputingResourceUtilizationBalanceThreshold(double avgUtilizationPercentage,\n+                                                                  Resource resource,\n+                                                                  double balanceMargin,\n+                                                                  boolean isLowerThreshold,\n+                                                                  boolean isTriggeredByGoalViolation,\n+                                                                  double lowUtilizationThreshold,\n+                                                                  double resourceBalancePercentage,\n+                                                                  double goalViolationDistributionThresholdMultiplier,\n+                                                                  double expectedComputedBalanceThreshold) {", "originalCommit": "0111f5dca716caddf672e6581b6c176add204eeb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM1NDgyOQ==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r534354829", "bodyText": "I will drop the constant parameters and assign the value within this function", "author": "Lincong", "createdAt": "2020-12-02T17:35:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyNjE1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyNjk1Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r533726953", "bodyText": "Do we really expect this functions to be called anyTimes()? Can't we be more specific?", "author": "efeg", "createdAt": "2020-12-01T21:17:21Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/GoalUtilsTest.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.common.Resource;\n+import org.easymock.EasyMock;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class GoalUtilsTest {\n+\n+  @Test\n+  public void testComputeResourceUtilizationBalanceThreshold() {\n+    Resource resource = Resource.CPU;\n+\n+    // Verify 1: Low utilization and compute balance threshold lower bound\n+    verifyComputingResourceUtilizationBalanceThreshold(0.3,\n+                                                       resource,\n+                                                       ResourceDistributionGoal.BALANCE_MARGIN,\n+                                                       true,\n+                                                       true,\n+                                                       0.4,\n+                                                       1.3,\n+                                                       1.2,\n+                                                       0.0);\n+\n+    // Verify 2: Low utilization and compute balance threshold upper bound\n+    verifyComputingResourceUtilizationBalanceThreshold(0.3,\n+                                                       resource,\n+                                                       ResourceDistributionGoal.BALANCE_MARGIN,\n+                                                       false,\n+                                                       true,\n+                                                       0.4,\n+                                                       1.3,\n+                                                       1.2,\n+                                                       0.4 * ResourceDistributionGoal.BALANCE_MARGIN);\n+\n+    // Verify 3: Not low utilization and compute balance threshold lower bound\n+    verifyComputingResourceUtilizationBalanceThreshold(0.3,\n+                                                       resource,\n+                                                       ResourceDistributionGoal.BALANCE_MARGIN,\n+                                                       true,\n+                                                       true,\n+                                                       0.2,\n+                                                       1.3,\n+                                                       1.2,\n+                                                       0.3 * (1 - ((1.3 * 1.2) - 1) * ResourceDistributionGoal.BALANCE_MARGIN));\n+\n+    // Verify 4: Not low utilization and compute balance threshold upper bound\n+    verifyComputingResourceUtilizationBalanceThreshold(0.3,\n+                                                       resource,\n+                                                       ResourceDistributionGoal.BALANCE_MARGIN,\n+                                                       false,\n+                                                       true,\n+                                                       0.2,\n+                                                       1.3,\n+                                                       1.2,\n+                                                       0.3 * (1 + ((1.3 * 1.2) - 1) * ResourceDistributionGoal.BALANCE_MARGIN));\n+\n+  }\n+\n+  private void verifyComputingResourceUtilizationBalanceThreshold(double avgUtilizationPercentage,\n+                                                                  Resource resource,\n+                                                                  double balanceMargin,\n+                                                                  boolean isLowerThreshold,\n+                                                                  boolean isTriggeredByGoalViolation,\n+                                                                  double lowUtilizationThreshold,\n+                                                                  double resourceBalancePercentage,\n+                                                                  double goalViolationDistributionThresholdMultiplier,\n+                                                                  double expectedComputedBalanceThreshold) {\n+\n+    BalancingConstraint mockBalanceConstraint = EasyMock.mock(BalancingConstraint.class);\n+    EasyMock.expect(mockBalanceConstraint.lowUtilizationThreshold(resource)).andReturn(lowUtilizationThreshold).anyTimes();\n+    EasyMock.expect(mockBalanceConstraint.resourceBalancePercentage(resource)).andReturn(resourceBalancePercentage).anyTimes();\n+    EasyMock.expect(mockBalanceConstraint.goalViolationDistributionThresholdMultiplier()).\n+        andReturn(goalViolationDistributionThresholdMultiplier).anyTimes();", "originalCommit": "0111f5dca716caddf672e6581b6c176add204eeb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI5MzExMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r534293111", "bodyText": "I used anyTimes() intentionally since ensuring specific methods on this BalancingConstraint object gets invoked exactly N number of times is meaningless IMO.  The BalancingConstraint object serves as a group of constant values, as long as computeResourceUtilizationBalanceThreshold computes the correct value, the user of this method should not care how many times the implementation of this method tries to access constant values in the BalancingConstraint object.", "author": "Lincong", "createdAt": "2020-12-02T16:12:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyNjk1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwNjM5Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r534506392", "bodyText": "I don't have a strong opinion -- feel free to leave it as is.\nBut, we as developers (not users) may care about the number of times a function is called to improve/preserve efficiency of our implementations. For example, an implementation that calls a function within a loop and just before a loop may achieve the same outcome, but the latter implementation would be more efficient/preferable.", "author": "efeg", "createdAt": "2020-12-02T21:53:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyNjk1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxNTgyNw==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r534515827", "bodyText": "I see your point. I agree that it worth verifying the number of invocations of a method if we need to measure/ensure efficiency. However, that is not necessary in this case. So, I will leave it as is.", "author": "Lincong", "createdAt": "2020-12-02T22:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyNjk1Mw=="}], "type": "inlineReview"}, {"oid": "c75cc104686b5101cd3a14da85124274f82fb816", "url": "https://github.com/linkedin/cruise-control/commit/c75cc104686b5101cd3a14da85124274f82fb816", "message": "Calculate balance lower bound for resource distribution lower bound with low utilization threshold", "committedDate": "2020-12-02T15:39:41Z", "type": "commit"}, {"oid": "ebe6e70ec7b956d5609f3cd453bce65e84e87dbc", "url": "https://github.com/linkedin/cruise-control/commit/ebe6e70ec7b956d5609f3cd453bce65e84e87dbc", "message": "Adjust implementation", "committedDate": "2020-12-02T15:39:41Z", "type": "commit"}, {"oid": "9845f10a46f104dba9b9bacb5c9d71fa3bf0410a", "url": "https://github.com/linkedin/cruise-control/commit/9845f10a46f104dba9b9bacb5c9d71fa3bf0410a", "message": "Add unit test", "committedDate": "2020-12-02T15:39:41Z", "type": "commit"}, {"oid": "4c74851dd702c73460d669b4afaeb6861df86691", "url": "https://github.com/linkedin/cruise-control/commit/4c74851dd702c73460d669b4afaeb6861df86691", "message": "wip", "committedDate": "2020-12-02T15:39:41Z", "type": "commit"}, {"oid": "ee9de69e6e6dc9c9a4e5f202a8e74f522aab83a7", "url": "https://github.com/linkedin/cruise-control/commit/ee9de69e6e6dc9c9a4e5f202a8e74f522aab83a7", "message": "Fixed some issues", "committedDate": "2020-12-02T15:39:41Z", "type": "commit"}, {"oid": "b7b46676d9f8d084d5792dd99ce470caed251f84", "url": "https://github.com/linkedin/cruise-control/commit/b7b46676d9f8d084d5792dd99ce470caed251f84", "message": "[WIP] Need to squash this commit", "committedDate": "2020-12-02T15:39:41Z", "type": "commit"}, {"oid": "22c5261891eecaa6173b2633f60d13352061e466", "url": "https://github.com/linkedin/cruise-control/commit/22c5261891eecaa6173b2633f60d13352061e466", "message": "Fixed PR issues", "committedDate": "2020-12-02T15:39:41Z", "type": "commit"}, {"oid": "8656898b27227799a208705dac69761328150e37", "url": "https://github.com/linkedin/cruise-control/commit/8656898b27227799a208705dac69761328150e37", "message": "Delete unused method", "committedDate": "2020-12-02T15:39:41Z", "type": "commit"}, {"oid": "415c13c38e2815aeb538beed2562866f427c3f6a", "url": "https://github.com/linkedin/cruise-control/commit/415c13c38e2815aeb538beed2562866f427c3f6a", "message": "Add unit test for GoalUtil", "committedDate": "2020-12-02T15:39:41Z", "type": "commit"}, {"oid": "1fbb50819c99e08b64089338e7d0a5dc91bb013b", "url": "https://github.com/linkedin/cruise-control/commit/1fbb50819c99e08b64089338e7d0a5dc91bb013b", "message": "Fixed PR issues", "committedDate": "2020-12-02T18:10:00Z", "type": "commit"}, {"oid": "1fbb50819c99e08b64089338e7d0a5dc91bb013b", "url": "https://github.com/linkedin/cruise-control/commit/1fbb50819c99e08b64089338e7d0a5dc91bb013b", "message": "Fixed PR issues", "committedDate": "2020-12-02T18:10:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwNzI5Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r534507297", "bodyText": "Nit: Can we move the hardcoded constants to static variables?", "author": "efeg", "createdAt": "2020-12-02T21:54:57Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/GoalUtilsTest.java", "diffHunk": "@@ -17,75 +17,35 @@ public void testComputeResourceUtilizationBalanceThreshold() {\n     Resource resource = Resource.CPU;\n \n     // Verify 1: Low utilization and compute balance threshold lower bound\n-    verifyComputingResourceUtilizationBalanceThreshold(0.3,\n-                                                       resource,\n-                                                       ResourceDistributionGoal.BALANCE_MARGIN,\n-                                                       true,\n-                                                       true,\n-                                                       0.4,\n-                                                       1.3,\n-                                                       1.2,\n-                                                       0.0);\n+    verifyComputingResourceUtilizationBalanceThreshold(resource, true, 0.4, 0.0);\n \n     // Verify 2: Low utilization and compute balance threshold upper bound\n-    verifyComputingResourceUtilizationBalanceThreshold(0.3,\n-                                                       resource,\n-                                                       ResourceDistributionGoal.BALANCE_MARGIN,\n-                                                       false,\n-                                                       true,\n-                                                       0.4,\n-                                                       1.3,\n-                                                       1.2,\n-                                                       0.4 * ResourceDistributionGoal.BALANCE_MARGIN);\n+    verifyComputingResourceUtilizationBalanceThreshold(resource, false, 0.4, 0.4 * ResourceDistributionGoal.BALANCE_MARGIN);\n \n     // Verify 3: Not low utilization and compute balance threshold lower bound\n-    verifyComputingResourceUtilizationBalanceThreshold(0.3,\n-                                                       resource,\n-                                                       ResourceDistributionGoal.BALANCE_MARGIN,\n-                                                       true,\n-                                                       true,\n-                                                       0.2,\n-                                                       1.3,\n-                                                       1.2,\n-                                                       0.3 * (1 - ((1.3 * 1.2) - 1) * ResourceDistributionGoal.BALANCE_MARGIN));\n+    verifyComputingResourceUtilizationBalanceThreshold(resource, true, 0.2, 0.3 * (1 - ((1.3 * 1.2) - 1) * ResourceDistributionGoal.BALANCE_MARGIN));\n \n     // Verify 4: Not low utilization and compute balance threshold upper bound\n-    verifyComputingResourceUtilizationBalanceThreshold(0.3,\n-                                                       resource,\n-                                                       ResourceDistributionGoal.BALANCE_MARGIN,\n-                                                       false,\n-                                                       true,\n-                                                       0.2,\n-                                                       1.3,\n-                                                       1.2,\n-                                                       0.3 * (1 + ((1.3 * 1.2) - 1) * ResourceDistributionGoal.BALANCE_MARGIN));\n-\n+    verifyComputingResourceUtilizationBalanceThreshold(resource, false, 0.2, 0.3 * (1 + ((1.3 * 1.2) - 1) * ResourceDistributionGoal.BALANCE_MARGIN));\n   }\n \n-  private void verifyComputingResourceUtilizationBalanceThreshold(double avgUtilizationPercentage,\n-                                                                  Resource resource,\n-                                                                  double balanceMargin,\n+  private void verifyComputingResourceUtilizationBalanceThreshold(Resource resource,\n                                                                   boolean isLowerThreshold,\n-                                                                  boolean isTriggeredByGoalViolation,\n                                                                   double lowUtilizationThreshold,\n-                                                                  double resourceBalancePercentage,\n-                                                                  double goalViolationDistributionThresholdMultiplier,\n                                                                   double expectedComputedBalanceThreshold) {\n \n     BalancingConstraint mockBalanceConstraint = EasyMock.mock(BalancingConstraint.class);\n     EasyMock.expect(mockBalanceConstraint.lowUtilizationThreshold(resource)).andReturn(lowUtilizationThreshold).anyTimes();\n-    EasyMock.expect(mockBalanceConstraint.resourceBalancePercentage(resource)).andReturn(resourceBalancePercentage).anyTimes();\n+    EasyMock.expect(mockBalanceConstraint.resourceBalancePercentage(resource)).andReturn(1.3).anyTimes();\n     EasyMock.expect(mockBalanceConstraint.goalViolationDistributionThresholdMultiplier()).\n-        andReturn(goalViolationDistributionThresholdMultiplier).anyTimes();\n+        andReturn(1.2).anyTimes();\n \n     EasyMock.replay(mockBalanceConstraint);\n-    double computedBalanceThreshold = GoalUtils.computeResourceUtilizationBalanceThreshold(avgUtilizationPercentage,\n+    double computedBalanceThreshold = GoalUtils.computeResourceUtilizationBalanceThreshold(0.3,", "originalCommit": "1fbb50819c99e08b64089338e7d0a5dc91bb013b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUyMDQyOQ==", "url": "https://github.com/linkedin/cruise-control/pull/1391#discussion_r534520429", "bodyText": "Sure", "author": "Lincong", "createdAt": "2020-12-02T22:20:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwNzI5Nw=="}], "type": "inlineReview"}, {"oid": "1c185566220cf6e46de3d00755c7489a4e86b621", "url": "https://github.com/linkedin/cruise-control/commit/1c185566220cf6e46de3d00755c7489a4e86b621", "message": "Fix one PR issue", "committedDate": "2020-12-02T22:19:36Z", "type": "commit"}, {"oid": "19b2c9177df3e514faeecfa60a9301c179d287cd", "url": "https://github.com/linkedin/cruise-control/commit/19b2c9177df3e514faeecfa60a9301c179d287cd", "message": "Fixed one missing PR issue", "committedDate": "2020-12-02T22:33:34Z", "type": "commit"}]}