{"pr_number": 1111, "pr_title": "Add support for topic partition size anomaly detection.", "pr_createdAt": "2020-02-21T23:09:38Z", "pr_url": "https://github.com/linkedin/cruise-control/pull/1111", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM5ODQwMg==", "url": "https://github.com/linkedin/cruise-control/pull/1111#discussion_r383398402", "bodyText": "Missing unit of SELF_HEALING_PARTITION_SIZE_THRESHOLD_CONFIG and DEFAULT_SELF_HEALING_PARTITION_SIZE_THRESHOLD -- i.e. are they in bytes, KB, MB?", "author": "efeg", "createdAt": "2020-02-24T17:13:33Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicPartitionSizeAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.cruisecontrol.exception.NotEnoughValidWindowsException;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.async.progress.OperationProgress;\n+import com.linkedin.kafka.cruisecontrol.common.Resource;\n+import com.linkedin.kafka.cruisecontrol.exception.KafkaCruiseControlException;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Partition;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.*;\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with gigantic size.\n+ * Required configurations for this class.\n+ * <ul>\n+ *   <li>{@link #SELF_HEALING_PARTITION_SIZE_THRESHOLD_CONFIG}: The config for the partition size threshold to alert,\n+ *   default value is set to {@link #DEFAULT_SELF_HEALING_PARTITION_SIZE_THRESHOLD}.", "originalCommit": "9b99afd9e27406264708572fb61102085dc45ecc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM5ODY0NA==", "url": "https://github.com/linkedin/cruise-control/pull/1111#discussion_r383398644", "bodyText": "Can we avoid star import?", "author": "efeg", "createdAt": "2020-02-24T17:13:57Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicPartitionSizeAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.cruisecontrol.exception.NotEnoughValidWindowsException;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.async.progress.OperationProgress;\n+import com.linkedin.kafka.cruisecontrol.common.Resource;\n+import com.linkedin.kafka.cruisecontrol.exception.KafkaCruiseControlException;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Partition;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.*;", "originalCommit": "9b99afd9e27406264708572fb61102085dc45ecc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQwOTU5Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1111#discussion_r383409592", "bodyText": "This JavaDoc presents (1) meta discussion around large partitions, (2) terms w/o definitions, and (3) a (i.e. one of many) potential way to use this function. However, it doesn't provide information on what this function simply does.\nCan we\n\nMove the generic discussion about large partitions to the class JavaDoc.\nClarify what it means to break the client-side applications,\nAvoid limiting the potential ways to fix partitions with large size -- i.e. it is possible to fix them in other ways, such as deleting topics with large partitions.\nRemove references to sending out alerts, and\nAdd description of what this function simply does.", "author": "efeg", "createdAt": "2020-02-24T17:33:56Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicPartitionSizeAnomaly.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import java.util.Map;\n+import java.util.function.Supplier;\n+import org.apache.kafka.common.TopicPartition;\n+\n+import static com.linkedin.kafka.cruisecontrol.detector.TopicPartitionSizeAnomalyFinder.PARTITIONS_WITH_LARGE_SIZE_CONFIG;\n+\n+\n+/**\n+ * Topic partitions with size larger than\n+ * {@link com.linkedin.kafka.cruisecontrol.detector.TopicPartitionSizeAnomalyFinder#SELF_HEALING_PARTITION_SIZE_THRESHOLD_CONFIG}\n+ */\n+public class TopicPartitionSizeAnomaly extends TopicAnomaly {\n+  protected Map<TopicPartition, Double> _sizeByPartition;\n+\n+  /**\n+   * There are two potential ways to fix partitions with large size, i.e. increasing topic's partition count and reducing\n+   * topic's retention time/size.\n+   * But both ways could break the client-side applications, therefore it is safer for Cruise Control to just send out alert\n+   * and not try to self-heal the anomaly.\n+   *\n+   * @return True if fix was started successfully (i.e. there is actual work towards a fix), false otherwise.\n+   */", "originalCommit": "9b99afd9e27406264708572fb61102085dc45ecc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQxMzI5MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1111#discussion_r383413291", "bodyText": "Incomplete implementation -- i.e. can we add a reason for a potential self-healing (i.e. in case fix() return true in a future implementation) -- e.g. return () -> String.format(\"Self healing for topic partition size anomaly: %s\", this);", "author": "efeg", "createdAt": "2020-02-24T17:41:28Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicPartitionSizeAnomaly.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import java.util.Map;\n+import java.util.function.Supplier;\n+import org.apache.kafka.common.TopicPartition;\n+\n+import static com.linkedin.kafka.cruisecontrol.detector.TopicPartitionSizeAnomalyFinder.PARTITIONS_WITH_LARGE_SIZE_CONFIG;\n+\n+\n+/**\n+ * Topic partitions with size larger than\n+ * {@link com.linkedin.kafka.cruisecontrol.detector.TopicPartitionSizeAnomalyFinder#SELF_HEALING_PARTITION_SIZE_THRESHOLD_CONFIG}\n+ */\n+public class TopicPartitionSizeAnomaly extends TopicAnomaly {\n+  protected Map<TopicPartition, Double> _sizeByPartition;\n+\n+  /**\n+   * There are two potential ways to fix partitions with large size, i.e. increasing topic's partition count and reducing\n+   * topic's retention time/size.\n+   * But both ways could break the client-side applications, therefore it is safer for Cruise Control to just send out alert\n+   * and not try to self-heal the anomaly.\n+   *\n+   * @return True if fix was started successfully (i.e. there is actual work towards a fix), false otherwise.\n+   */\n+  @Override\n+  public boolean fix() {\n+    return false;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public void configure(Map<String, ?> configs) {\n+    super.configure(configs);\n+    _sizeByPartition = (Map<TopicPartition, Double>) configs.get(PARTITIONS_WITH_LARGE_SIZE_CONFIG);\n+    if (_sizeByPartition == null || _sizeByPartition.isEmpty()) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s for topic partition size anomaly.\", PARTITIONS_WITH_LARGE_SIZE_CONFIG));\n+    }\n+  }\n+\n+  @Override\n+  public Supplier<String> reasonSupplier() {\n+    return () -> \"\";", "originalCommit": "9b99afd9e27406264708572fb61102085dc45ecc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQxMzY0NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1111#discussion_r383413645", "bodyText": "Can we also include the unit of size?", "author": "efeg", "createdAt": "2020-02-24T17:42:03Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicPartitionSizeAnomaly.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import java.util.Map;\n+import java.util.function.Supplier;\n+import org.apache.kafka.common.TopicPartition;\n+\n+import static com.linkedin.kafka.cruisecontrol.detector.TopicPartitionSizeAnomalyFinder.PARTITIONS_WITH_LARGE_SIZE_CONFIG;\n+\n+\n+/**\n+ * Topic partitions with size larger than\n+ * {@link com.linkedin.kafka.cruisecontrol.detector.TopicPartitionSizeAnomalyFinder#SELF_HEALING_PARTITION_SIZE_THRESHOLD_CONFIG}\n+ */\n+public class TopicPartitionSizeAnomaly extends TopicAnomaly {\n+  protected Map<TopicPartition, Double> _sizeByPartition;\n+\n+  /**\n+   * There are two potential ways to fix partitions with large size, i.e. increasing topic's partition count and reducing\n+   * topic's retention time/size.\n+   * But both ways could break the client-side applications, therefore it is safer for Cruise Control to just send out alert\n+   * and not try to self-heal the anomaly.\n+   *\n+   * @return True if fix was started successfully (i.e. there is actual work towards a fix), false otherwise.\n+   */\n+  @Override\n+  public boolean fix() {\n+    return false;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public void configure(Map<String, ?> configs) {\n+    super.configure(configs);\n+    _sizeByPartition = (Map<TopicPartition, Double>) configs.get(PARTITIONS_WITH_LARGE_SIZE_CONFIG);\n+    if (_sizeByPartition == null || _sizeByPartition.isEmpty()) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s for topic partition size anomaly.\", PARTITIONS_WITH_LARGE_SIZE_CONFIG));\n+    }\n+  }\n+\n+  @Override\n+  public Supplier<String> reasonSupplier() {\n+    return () -> \"\";\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"{Detected following topic partitions having too large size:\\n\");\n+    for (Map.Entry<TopicPartition, Double> entry : _sizeByPartition.entrySet()) {\n+      sb.append(String.format(\"\\t%s\\t%f%n\", entry.getKey().toString(), entry.getValue()));", "originalCommit": "9b99afd9e27406264708572fb61102085dc45ecc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQxNDg5OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1111#discussion_r383414899", "bodyText": "Incorrect class name: TopicPartitionSizeAnomaly -> TopicPartitionSizeAnomalyFinder", "author": "efeg", "createdAt": "2020-02-24T17:44:27Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicPartitionSizeAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.cruisecontrol.exception.NotEnoughValidWindowsException;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.async.progress.OperationProgress;\n+import com.linkedin.kafka.cruisecontrol.common.Resource;\n+import com.linkedin.kafka.cruisecontrol.exception.KafkaCruiseControlException;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Partition;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.*;\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with gigantic size.\n+ * Required configurations for this class.\n+ * <ul>\n+ *   <li>{@link #SELF_HEALING_PARTITION_SIZE_THRESHOLD_CONFIG}: The config for the partition size threshold to alert,\n+ *   default value is set to {@link #DEFAULT_SELF_HEALING_PARTITION_SIZE_THRESHOLD}.\n+ *   <li>{@link #TOPIC_EXCLUDED_FROM_PARTITION_SIZE_CHECK}: The config to specify topics excluded from the anomaly checking.\n+ *   The value is treated as a regular expression, default value is set to\n+ *   {@link #DEFAULT_TOPIC_EXCLUDED_FROM_PARTITION_SIZE_CHECK}.\n+ *   <li>{@link #TOPIC_PARTITION_SIZE_ANOMALY_CLASS_CONFIG}: The config for the topic anomaly class name,\n+ *   default value is set to {@link #DEFAULT_TOPIC_PARTITION_SIZE_ANOMALY_CLASS}.\n+ * </ul>\n+ */\n+public class TopicPartitionSizeAnomalyFinder implements TopicAnomalyFinder {\n+  private static final Logger LOG = LoggerFactory.getLogger(TopicPartitionSizeAnomaly.class);", "originalCommit": "9b99afd9e27406264708572fb61102085dc45ecc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQxODc1MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1111#discussion_r383418751", "bodyText": "Nit: \"Topic partition  -> \"Partition", "author": "efeg", "createdAt": "2020-02-24T17:52:09Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicPartitionSizeAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.cruisecontrol.exception.NotEnoughValidWindowsException;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.async.progress.OperationProgress;\n+import com.linkedin.kafka.cruisecontrol.common.Resource;\n+import com.linkedin.kafka.cruisecontrol.exception.KafkaCruiseControlException;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Partition;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.*;\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with gigantic size.\n+ * Required configurations for this class.\n+ * <ul>\n+ *   <li>{@link #SELF_HEALING_PARTITION_SIZE_THRESHOLD_CONFIG}: The config for the partition size threshold to alert,\n+ *   default value is set to {@link #DEFAULT_SELF_HEALING_PARTITION_SIZE_THRESHOLD}.\n+ *   <li>{@link #TOPIC_EXCLUDED_FROM_PARTITION_SIZE_CHECK}: The config to specify topics excluded from the anomaly checking.\n+ *   The value is treated as a regular expression, default value is set to\n+ *   {@link #DEFAULT_TOPIC_EXCLUDED_FROM_PARTITION_SIZE_CHECK}.\n+ *   <li>{@link #TOPIC_PARTITION_SIZE_ANOMALY_CLASS_CONFIG}: The config for the topic anomaly class name,\n+ *   default value is set to {@link #DEFAULT_TOPIC_PARTITION_SIZE_ANOMALY_CLASS}.\n+ * </ul>\n+ */\n+public class TopicPartitionSizeAnomalyFinder implements TopicAnomalyFinder {\n+  private static final Logger LOG = LoggerFactory.getLogger(TopicPartitionSizeAnomaly.class);\n+  public static final String SELF_HEALING_PARTITION_SIZE_THRESHOLD_CONFIG = \"self.healing.partition.size.threshold\";\n+  public static final Integer DEFAULT_SELF_HEALING_PARTITION_SIZE_THRESHOLD = 500 * 1024 * 1024;\n+  public static final String TOPIC_EXCLUDED_FROM_PARTITION_SIZE_CHECK = \"topic.excluded.from.partition.size.check\";\n+  public static final String DEFAULT_TOPIC_EXCLUDED_FROM_PARTITION_SIZE_CHECK = \"\";\n+  public static final String TOPIC_PARTITION_SIZE_ANOMALY_CLASS_CONFIG = \"topic.partition.size.anomaly.class\";\n+  public static final Class<?> DEFAULT_TOPIC_PARTITION_SIZE_ANOMALY_CLASS = TopicPartitionSizeAnomaly.class;\n+  public static final String PARTITIONS_WITH_LARGE_SIZE_CONFIG = \"partitions.with.large.size\";\n+  private KafkaCruiseControl _kafkaCruiseControl;\n+  private int _partitionSizeThreshold;\n+  private Pattern _topicExcludedFromCheck;\n+  private Class<?> _topicPartitionSizeAnomalyClass;\n+\n+  @Override\n+  public Set<TopicAnomaly> topicAnomalies() {\n+    Map<TopicPartition, Double> partitionsWithLargeSize = new HashMap<>();\n+    OperationProgress operationProgress = new OperationProgress();\n+    ClusterModel clusterModel;\n+    try (AutoCloseable ignored = _kafkaCruiseControl.acquireForModelGeneration(operationProgress)) {\n+      clusterModel = _kafkaCruiseControl.clusterModel(\n+          new ModelCompletenessRequirements(MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true), new OperationProgress());\n+      for (Map.Entry<String, List<Partition>> entry: clusterModel.getPartitionsByTopic().entrySet()) {\n+        if (_topicExcludedFromCheck.matcher(entry.getKey()).matches()) {\n+          continue;\n+        }\n+        for (Partition partition : entry.getValue()) {\n+          double partitionSize = partition.leader().load().expectedUtilizationFor(Resource.DISK);\n+          if (partitionSize > _partitionSizeThreshold) {\n+            partitionsWithLargeSize.put(partition.topicPartition(), partitionSize);\n+          }\n+        }\n+      }\n+    } catch (NotEnoughValidWindowsException nevwe) {\n+      LOG.debug(\"Skipping topic partition size anomaly detection because there are not enough valid windows.\", nevwe);\n+    } catch (KafkaCruiseControlException kcce) {\n+      LOG.warn(\"Topic partition size anomaly finder received exception\", kcce);", "originalCommit": "9b99afd9e27406264708572fb61102085dc45ecc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQxODg0Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1111#discussion_r383418842", "bodyText": "Nit: \"Topic partition  -> \"Partition", "author": "efeg", "createdAt": "2020-02-24T17:52:21Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicPartitionSizeAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.cruisecontrol.exception.NotEnoughValidWindowsException;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.async.progress.OperationProgress;\n+import com.linkedin.kafka.cruisecontrol.common.Resource;\n+import com.linkedin.kafka.cruisecontrol.exception.KafkaCruiseControlException;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Partition;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.*;\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with gigantic size.\n+ * Required configurations for this class.\n+ * <ul>\n+ *   <li>{@link #SELF_HEALING_PARTITION_SIZE_THRESHOLD_CONFIG}: The config for the partition size threshold to alert,\n+ *   default value is set to {@link #DEFAULT_SELF_HEALING_PARTITION_SIZE_THRESHOLD}.\n+ *   <li>{@link #TOPIC_EXCLUDED_FROM_PARTITION_SIZE_CHECK}: The config to specify topics excluded from the anomaly checking.\n+ *   The value is treated as a regular expression, default value is set to\n+ *   {@link #DEFAULT_TOPIC_EXCLUDED_FROM_PARTITION_SIZE_CHECK}.\n+ *   <li>{@link #TOPIC_PARTITION_SIZE_ANOMALY_CLASS_CONFIG}: The config for the topic anomaly class name,\n+ *   default value is set to {@link #DEFAULT_TOPIC_PARTITION_SIZE_ANOMALY_CLASS}.\n+ * </ul>\n+ */\n+public class TopicPartitionSizeAnomalyFinder implements TopicAnomalyFinder {\n+  private static final Logger LOG = LoggerFactory.getLogger(TopicPartitionSizeAnomaly.class);\n+  public static final String SELF_HEALING_PARTITION_SIZE_THRESHOLD_CONFIG = \"self.healing.partition.size.threshold\";\n+  public static final Integer DEFAULT_SELF_HEALING_PARTITION_SIZE_THRESHOLD = 500 * 1024 * 1024;\n+  public static final String TOPIC_EXCLUDED_FROM_PARTITION_SIZE_CHECK = \"topic.excluded.from.partition.size.check\";\n+  public static final String DEFAULT_TOPIC_EXCLUDED_FROM_PARTITION_SIZE_CHECK = \"\";\n+  public static final String TOPIC_PARTITION_SIZE_ANOMALY_CLASS_CONFIG = \"topic.partition.size.anomaly.class\";\n+  public static final Class<?> DEFAULT_TOPIC_PARTITION_SIZE_ANOMALY_CLASS = TopicPartitionSizeAnomaly.class;\n+  public static final String PARTITIONS_WITH_LARGE_SIZE_CONFIG = \"partitions.with.large.size\";\n+  private KafkaCruiseControl _kafkaCruiseControl;\n+  private int _partitionSizeThreshold;\n+  private Pattern _topicExcludedFromCheck;\n+  private Class<?> _topicPartitionSizeAnomalyClass;\n+\n+  @Override\n+  public Set<TopicAnomaly> topicAnomalies() {\n+    Map<TopicPartition, Double> partitionsWithLargeSize = new HashMap<>();\n+    OperationProgress operationProgress = new OperationProgress();\n+    ClusterModel clusterModel;\n+    try (AutoCloseable ignored = _kafkaCruiseControl.acquireForModelGeneration(operationProgress)) {\n+      clusterModel = _kafkaCruiseControl.clusterModel(\n+          new ModelCompletenessRequirements(MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true), new OperationProgress());\n+      for (Map.Entry<String, List<Partition>> entry: clusterModel.getPartitionsByTopic().entrySet()) {\n+        if (_topicExcludedFromCheck.matcher(entry.getKey()).matches()) {\n+          continue;\n+        }\n+        for (Partition partition : entry.getValue()) {\n+          double partitionSize = partition.leader().load().expectedUtilizationFor(Resource.DISK);\n+          if (partitionSize > _partitionSizeThreshold) {\n+            partitionsWithLargeSize.put(partition.topicPartition(), partitionSize);\n+          }\n+        }\n+      }\n+    } catch (NotEnoughValidWindowsException nevwe) {\n+      LOG.debug(\"Skipping topic partition size anomaly detection because there are not enough valid windows.\", nevwe);\n+    } catch (KafkaCruiseControlException kcce) {\n+      LOG.warn(\"Topic partition size anomaly finder received exception\", kcce);\n+    } catch (Exception e) {\n+      LOG.error(\"Unexpected exception\", e);\n+    }\n+    if (!partitionsWithLargeSize.isEmpty()) {\n+      return Collections.singleton(createTopicPartitionSizeAnomaly(partitionsWithLargeSize));\n+    }\n+    return Collections.emptySet();\n+  }\n+\n+  private TopicAnomaly createTopicPartitionSizeAnomaly(Map<TopicPartition, Double> partitionsWithLargeSize) {\n+    Map<String, Object> configs = new HashMap<>(3);\n+    configs.put(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG, _kafkaCruiseControl);\n+    configs.put(PARTITIONS_WITH_LARGE_SIZE_CONFIG, partitionsWithLargeSize);\n+    configs.put(ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG, _kafkaCruiseControl.timeMs());\n+    return getConfiguredInstance(_topicPartitionSizeAnomalyClass, TopicAnomaly.class, configs);\n+  }\n+\n+  @Override\n+  public void configure(Map<String, ?> configs) {\n+    _kafkaCruiseControl = (KafkaCruiseControl) configs.get(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);\n+    if (_kafkaCruiseControl == null) {\n+      throw new IllegalArgumentException(\"Topic partition size anomaly finder is missing \" + KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);", "originalCommit": "9b99afd9e27406264708572fb61102085dc45ecc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyMjc1Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1111#discussion_r383422752", "bodyText": "Nit: Should we name it TopicPartitionSizeAnomalyFinder -> PartitionSizeAnomalyFinder for simplicity? -- i.e. this class already implements TopicAnomalyFinder; hence, the connotation is clear.", "author": "efeg", "createdAt": "2020-02-24T18:00:05Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicPartitionSizeAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.cruisecontrol.exception.NotEnoughValidWindowsException;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.async.progress.OperationProgress;\n+import com.linkedin.kafka.cruisecontrol.common.Resource;\n+import com.linkedin.kafka.cruisecontrol.exception.KafkaCruiseControlException;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Partition;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.*;\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with gigantic size.\n+ * Required configurations for this class.\n+ * <ul>\n+ *   <li>{@link #SELF_HEALING_PARTITION_SIZE_THRESHOLD_CONFIG}: The config for the partition size threshold to alert,\n+ *   default value is set to {@link #DEFAULT_SELF_HEALING_PARTITION_SIZE_THRESHOLD}.\n+ *   <li>{@link #TOPIC_EXCLUDED_FROM_PARTITION_SIZE_CHECK}: The config to specify topics excluded from the anomaly checking.\n+ *   The value is treated as a regular expression, default value is set to\n+ *   {@link #DEFAULT_TOPIC_EXCLUDED_FROM_PARTITION_SIZE_CHECK}.\n+ *   <li>{@link #TOPIC_PARTITION_SIZE_ANOMALY_CLASS_CONFIG}: The config for the topic anomaly class name,\n+ *   default value is set to {@link #DEFAULT_TOPIC_PARTITION_SIZE_ANOMALY_CLASS}.\n+ * </ul>\n+ */\n+public class TopicPartitionSizeAnomalyFinder implements TopicAnomalyFinder {", "originalCommit": "9b99afd9e27406264708572fb61102085dc45ecc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyNjA2Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1111#discussion_r383426062", "bodyText": "Nit: topic partition -> partition", "author": "efeg", "createdAt": "2020-02-24T18:06:50Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicPartitionSizeAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.cruisecontrol.exception.NotEnoughValidWindowsException;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.async.progress.OperationProgress;\n+import com.linkedin.kafka.cruisecontrol.common.Resource;\n+import com.linkedin.kafka.cruisecontrol.exception.KafkaCruiseControlException;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Partition;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.*;\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with gigantic size.\n+ * Required configurations for this class.\n+ * <ul>\n+ *   <li>{@link #SELF_HEALING_PARTITION_SIZE_THRESHOLD_CONFIG}: The config for the partition size threshold to alert,\n+ *   default value is set to {@link #DEFAULT_SELF_HEALING_PARTITION_SIZE_THRESHOLD}.\n+ *   <li>{@link #TOPIC_EXCLUDED_FROM_PARTITION_SIZE_CHECK}: The config to specify topics excluded from the anomaly checking.\n+ *   The value is treated as a regular expression, default value is set to\n+ *   {@link #DEFAULT_TOPIC_EXCLUDED_FROM_PARTITION_SIZE_CHECK}.\n+ *   <li>{@link #TOPIC_PARTITION_SIZE_ANOMALY_CLASS_CONFIG}: The config for the topic anomaly class name,\n+ *   default value is set to {@link #DEFAULT_TOPIC_PARTITION_SIZE_ANOMALY_CLASS}.\n+ * </ul>\n+ */\n+public class TopicPartitionSizeAnomalyFinder implements TopicAnomalyFinder {\n+  private static final Logger LOG = LoggerFactory.getLogger(TopicPartitionSizeAnomaly.class);\n+  public static final String SELF_HEALING_PARTITION_SIZE_THRESHOLD_CONFIG = \"self.healing.partition.size.threshold\";\n+  public static final Integer DEFAULT_SELF_HEALING_PARTITION_SIZE_THRESHOLD = 500 * 1024 * 1024;\n+  public static final String TOPIC_EXCLUDED_FROM_PARTITION_SIZE_CHECK = \"topic.excluded.from.partition.size.check\";\n+  public static final String DEFAULT_TOPIC_EXCLUDED_FROM_PARTITION_SIZE_CHECK = \"\";\n+  public static final String TOPIC_PARTITION_SIZE_ANOMALY_CLASS_CONFIG = \"topic.partition.size.anomaly.class\";\n+  public static final Class<?> DEFAULT_TOPIC_PARTITION_SIZE_ANOMALY_CLASS = TopicPartitionSizeAnomaly.class;\n+  public static final String PARTITIONS_WITH_LARGE_SIZE_CONFIG = \"partitions.with.large.size\";\n+  private KafkaCruiseControl _kafkaCruiseControl;\n+  private int _partitionSizeThreshold;\n+  private Pattern _topicExcludedFromCheck;\n+  private Class<?> _topicPartitionSizeAnomalyClass;\n+\n+  @Override\n+  public Set<TopicAnomaly> topicAnomalies() {\n+    Map<TopicPartition, Double> partitionsWithLargeSize = new HashMap<>();\n+    OperationProgress operationProgress = new OperationProgress();\n+    ClusterModel clusterModel;\n+    try (AutoCloseable ignored = _kafkaCruiseControl.acquireForModelGeneration(operationProgress)) {\n+      clusterModel = _kafkaCruiseControl.clusterModel(\n+          new ModelCompletenessRequirements(MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true), new OperationProgress());\n+      for (Map.Entry<String, List<Partition>> entry: clusterModel.getPartitionsByTopic().entrySet()) {\n+        if (_topicExcludedFromCheck.matcher(entry.getKey()).matches()) {\n+          continue;\n+        }\n+        for (Partition partition : entry.getValue()) {\n+          double partitionSize = partition.leader().load().expectedUtilizationFor(Resource.DISK);\n+          if (partitionSize > _partitionSizeThreshold) {\n+            partitionsWithLargeSize.put(partition.topicPartition(), partitionSize);\n+          }\n+        }\n+      }\n+    } catch (NotEnoughValidWindowsException nevwe) {\n+      LOG.debug(\"Skipping topic partition size anomaly detection because there are not enough valid windows.\", nevwe);\n+    } catch (KafkaCruiseControlException kcce) {\n+      LOG.warn(\"Topic partition size anomaly finder received exception\", kcce);\n+    } catch (Exception e) {\n+      LOG.error(\"Unexpected exception\", e);\n+    }\n+    if (!partitionsWithLargeSize.isEmpty()) {\n+      return Collections.singleton(createTopicPartitionSizeAnomaly(partitionsWithLargeSize));\n+    }\n+    return Collections.emptySet();\n+  }\n+\n+  private TopicAnomaly createTopicPartitionSizeAnomaly(Map<TopicPartition, Double> partitionsWithLargeSize) {\n+    Map<String, Object> configs = new HashMap<>(3);\n+    configs.put(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG, _kafkaCruiseControl);\n+    configs.put(PARTITIONS_WITH_LARGE_SIZE_CONFIG, partitionsWithLargeSize);\n+    configs.put(ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG, _kafkaCruiseControl.timeMs());\n+    return getConfiguredInstance(_topicPartitionSizeAnomalyClass, TopicAnomaly.class, configs);\n+  }\n+\n+  @Override\n+  public void configure(Map<String, ?> configs) {\n+    _kafkaCruiseControl = (KafkaCruiseControl) configs.get(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);\n+    if (_kafkaCruiseControl == null) {\n+      throw new IllegalArgumentException(\"Topic partition size anomaly finder is missing \" + KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);\n+    }\n+    String topicExcludedFromCheck = (String) configs.get(TOPIC_EXCLUDED_FROM_PARTITION_SIZE_CHECK);\n+    _topicExcludedFromCheck = Pattern.compile(topicExcludedFromCheck == null ? DEFAULT_TOPIC_EXCLUDED_FROM_PARTITION_SIZE_CHECK\n+                                                                             : topicExcludedFromCheck);\n+    Integer partitionSizeThreshold = (Integer) configs.get(SELF_HEALING_PARTITION_SIZE_THRESHOLD_CONFIG);\n+    _partitionSizeThreshold = partitionSizeThreshold == null ? DEFAULT_SELF_HEALING_PARTITION_SIZE_THRESHOLD\n+                                                             : partitionSizeThreshold;\n+    String topicPartitionSizeAnomalyClass = (String) configs.get(TOPIC_PARTITION_SIZE_ANOMALY_CLASS_CONFIG);\n+    if (topicPartitionSizeAnomalyClass == null) {\n+      _topicPartitionSizeAnomalyClass = DEFAULT_TOPIC_PARTITION_SIZE_ANOMALY_CLASS;\n+    } else {\n+      _topicPartitionSizeAnomalyClass = (Class<?>) ConfigDef.parseType(TOPIC_PARTITION_SIZE_ANOMALY_CLASS_CONFIG,\n+                                                                       topicPartitionSizeAnomalyClass,\n+                                                                       CLASS);\n+      if (_topicPartitionSizeAnomalyClass == null || !TopicAnomaly.class.isAssignableFrom(_topicPartitionSizeAnomalyClass)) {\n+        throw new IllegalArgumentException(String.format(\"Invalid %s is provided to topic partition size anomaly finder, provided %s\",", "originalCommit": "9b99afd9e27406264708572fb61102085dc45ecc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg3NDUyNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1111#discussion_r384874525", "bodyText": "Nit: Could you clarify why the code shrinks the size by 2?", "author": "efeg", "createdAt": "2020-02-27T02:01:43Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/SlowBrokerFinder.java", "diffHunk": "@@ -202,10 +202,11 @@ private SlowBrokers createSlowBrokersAnomaly(Map<BrokerEntity, Long> detectedBro\n   }\n \n   private String getSlowBrokerDescription(Map<BrokerEntity, Long> detectedBrokers) {\n-    StringBuilder descriptionSb = new StringBuilder().append(\"{\\n\");\n+    StringBuilder descriptionSb = new StringBuilder().append(\"{\");\n     detectedBrokers.forEach((key, value) -> {\n-      descriptionSb.append(\"\\tBroker \").append(key.brokerId()).append(\"'s performance degraded at \").append(toDateString(value)).append(\"\\n\");\n+      descriptionSb.append(\"Broker \").append(key.brokerId()).append(\"'s performance degraded at \").append(toDateString(value)).append(\", \");\n     });\n+    descriptionSb.setLength(descriptionSb.length() - 2);", "originalCommit": "517f6af86d9659b3e7a97bad38c291cdca3797c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f55ed412f1b0581d29f74a679fad3d9508d1aa97", "url": "https://github.com/linkedin/cruise-control/commit/f55ed412f1b0581d29f74a679fad3d9508d1aa97", "message": "Add support for topic partition size anomaly detection.", "committedDate": "2020-02-27T04:00:18Z", "type": "commit"}, {"oid": "b3f5c4250e37857e999326582821daa90e2cb7e9", "url": "https://github.com/linkedin/cruise-control/commit/b3f5c4250e37857e999326582821daa90e2cb7e9", "message": "Address the feedback.", "committedDate": "2020-02-27T04:00:18Z", "type": "commit"}, {"oid": "7f09b29c4c96ae8ea7238cc90de95d52c4b48007", "url": "https://github.com/linkedin/cruise-control/commit/7f09b29c4c96ae8ea7238cc90de95d52c4b48007", "message": "Address the feedback.", "committedDate": "2020-02-27T04:06:19Z", "type": "commit"}, {"oid": "7f09b29c4c96ae8ea7238cc90de95d52c4b48007", "url": "https://github.com/linkedin/cruise-control/commit/7f09b29c4c96ae8ea7238cc90de95d52c4b48007", "message": "Address the feedback.", "committedDate": "2020-02-27T04:06:19Z", "type": "forcePushed"}]}