{"pr_number": 1079, "pr_title": "Add support to detect and self-heal inconsistent topic replication factor", "pr_createdAt": "2020-01-27T23:36:24Z", "pr_url": "https://github.com/linkedin/cruise-control/pull/1079", "timeline": [{"oid": "48f8f0f90e56869bc5bed19d04983bea8aba7f24", "url": "https://github.com/linkedin/cruise-control/commit/48f8f0f90e56869bc5bed19d04983bea8aba7f24", "message": "Add support to detect and self-heal inconsistent topic replication factor.", "committedDate": "2020-02-04T00:07:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyMTY1NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374421655", "bodyText": "Nit: Can we put these *AnomalyDetectionIntervalMs to a map per anomaly type?", "author": "efeg", "createdAt": "2020-02-04T00:44:23Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetector.java", "diffHunk": "@@ -60,10 +60,12 @@\n   private final BrokerFailureDetector _brokerFailureDetector;\n   private final MetricAnomalyDetector _metricAnomalyDetector;\n   private final DiskFailureDetector _diskFailureDetector;\n+  private final TopicAnomalyDetector _topicAnomalyDetector;\n   private final ScheduledExecutorService _detectorScheduler;\n   private final long _goalViolationDetectionIntervalMs;\n   private final long _diskFailureDetectionIntervalMs;\n   private final long _metricAnomalyDetectionIntervalMs;\n+  private final long _topicAnomalyDetectionIntervalMs;", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyNjI0NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374426245", "bodyText": "Can we be more verbose on what a topic anomaly means?", "author": "efeg", "createdAt": "2020-02-04T01:02:13Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomaly.java", "diffHunk": "@@ -0,0 +1,19 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.detector.AnomalyType;\n+\n+import static com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyType.TOPIC_ANOMALY;\n+\n+/**\n+ * The interface for a topic anomaly.", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyNzc0OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374427749", "bodyText": "The logic of this function seems to be commonly used by the other anomaly detectors. Is it possible to combine their common logic in a parameterized util function?", "author": "efeg", "createdAt": "2020-02-04T01:08:30Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyDetector.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.detector.Anomaly;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.MAX_METADATA_WAIT_MS;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.shouldSkipAnomalyDetection;\n+\n+/**\n+ * This class will be scheduled to periodically check if {@link TopicAnomalyFinder} identifies a topic anomaly.\n+ * An alert will be triggered if one of the desired topic property is not met.\n+ */\n+public class TopicAnomalyDetector implements Runnable {\n+  private static final Logger LOG = LoggerFactory.getLogger(TopicAnomalyDetector.class);\n+  private final Queue<Anomaly> _anomalies;\n+  private final KafkaCruiseControl _kafkaCruiseControl;\n+  private final List<TopicAnomalyFinder> _topicAnomalyFinders;\n+\n+  TopicAnomalyDetector(Queue<Anomaly> anomalies,\n+                       KafkaCruiseControl kafkaCruiseControl) {\n+    _anomalies = anomalies;\n+    _kafkaCruiseControl = kafkaCruiseControl;\n+    Map<String, Object> configWithCruiseControlObject = Collections.singletonMap(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG,\n+                                                                                 kafkaCruiseControl);\n+    _topicAnomalyFinders = kafkaCruiseControl.config().getConfiguredInstances(AnomalyDetectorConfig.TOPIC_ANOMALY_FINDER_CLASSES_CONFIG,\n+                                                                              TopicAnomalyFinder.class,\n+                                                                              configWithCruiseControlObject);\n+  }\n+\n+  /**\n+   * Skip topic anomaly detection if any of the following is true:\n+   * <ul>\n+   *  <li>There is offline replicas in the cluster, which means there is dead brokers/disks. In this case\n+   * {@link BrokerFailureDetector} or {@link DiskFailureDetector} should take care of the anomaly.</li>\n+   *  <li>{@link AnomalyDetectorUtils#shouldSkipAnomalyDetection(KafkaCruiseControl)} returns true.\n+   * </ul>\n+   *\n+   * @return True to skip topic anomaly detection based on the current state, false otherwise.\n+   */\n+  private boolean shouldSkipMetricAnomalyDetection() {", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyODgxOQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374428819", "bodyText": "Why is this a list -- i.e. what is the implied ordering of anomalies? If the ordering does not matter, can we avoid using a list?", "author": "efeg", "createdAt": "2020-02-04T01:12:40Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.CruiseControlConfigurable;\n+import java.util.List;\n+import org.apache.yetus.audience.InterfaceStability;\n+\n+\n+/**\n+ * The finder which checks topics against certain desired topic property to identify topic anomaly.\n+ */\n+@InterfaceStability.Evolving\n+public interface  TopicAnomalyFinder extends CruiseControlConfigurable {\n+\n+  /**\n+   * Get a list of topic anomalies for topics which are misconfigured or violate some desired property.\n+   * @return List of topic anomalies.\n+   */\n+  List<TopicAnomaly> topicAnomalies();", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzMDQwMw==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374430403", "bodyText": "Can we add explanation of the configs to the JavaDoc?", "author": "efeg", "createdAt": "2020-02-04T01:19:01Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzMTM0Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374431342", "bodyText": "Should this be a static function in some utils class with a corresponding unit test?", "author": "efeg", "createdAt": "2020-02-04T01:22:51Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfig;\n+import com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyType;\n+import com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.UpdateTopicConfigurationRunnable;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.regex.Pattern;\n+\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.getSelfHealingGoalNames;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.extractKafkaCruiseControlObjectFromConfig;\n+import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyType.TOPIC_ANOMALY;\n+\n+\n+/**\n+ * Topics which contain at least one partition with replication factor not equal to the config value of\n+ * {@link com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder#SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}\n+ */\n+public class TopicReplicationFactorAnomaly extends TopicAnomaly {\n+  protected Short _targetReplicationFactor;\n+  protected Set<String> _topicsWithBadReplicationFactor;\n+  protected UpdateTopicConfigurationRunnable _updateTopicConfigurationRunnable;\n+\n+  @Override\n+  public boolean fix() throws Exception {\n+    _optimizationResult = _updateTopicConfigurationRunnable.getResult();\n+    boolean hasProposalsToFix = hasProposalsToFix();\n+    // Ensure that only the relevant response is cached to avoid memory pressure.\n+    _optimizationResult.discardIrrelevantAndCacheJsonAndPlaintext();\n+    return hasProposalsToFix;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public void configure(Map<String, ?> configs) {\n+    super.configure(configs);\n+    KafkaCruiseControl kafkaCruiseControl = extractKafkaCruiseControlObjectFromConfig(configs, KafkaAnomalyType.TOPIC_ANOMALY);\n+    KafkaCruiseControlConfig config = kafkaCruiseControl.config();\n+    _topicsWithBadReplicationFactor = (Set<String>) configs.get(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG);\n+    if (_topicsWithBadReplicationFactor == null || _topicsWithBadReplicationFactor.isEmpty()) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s for topic replication factor anomaly.\", TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG));\n+    }\n+    _targetReplicationFactor = (Short) configs.get(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG);\n+    if (_targetReplicationFactor == null) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s for topic replication factor anomaly.\",\n+                                                       SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG));\n+    }\n+    boolean allowCapacityEstimation = config.getBoolean(ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG);\n+    boolean excludeRecentlyDemotedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG);\n+    boolean excludeRecentlyRemovedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG);\n+    _updateTopicConfigurationRunnable = new UpdateTopicConfigurationRunnable(kafkaCruiseControl,\n+                                                                             Collections.singletonMap(_targetReplicationFactor,\n+                                                                                                      buildTopicRegex(_topicsWithBadReplicationFactor)),\n+                                                                             getSelfHealingGoalNames(config),\n+                                                                             allowCapacityEstimation,\n+                                                                             excludeRecentlyDemotedBrokers,\n+                                                                             excludeRecentlyRemovedBrokers,\n+                                                                             _anomalyId.toString(),\n+                                                                             String.format(\"Self healing for %s: %s\", TOPIC_ANOMALY, this));\n+\n+  }\n+\n+  private Pattern buildTopicRegex(Set<String> topics) {", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzMzExNw==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374433117", "bodyText": "I am curious why we need these parentheses? Aren't they redundant?", "author": "efeg", "createdAt": "2020-02-04T01:30:52Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfig;\n+import com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyType;\n+import com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.UpdateTopicConfigurationRunnable;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.regex.Pattern;\n+\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.getSelfHealingGoalNames;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.extractKafkaCruiseControlObjectFromConfig;\n+import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyType.TOPIC_ANOMALY;\n+\n+\n+/**\n+ * Topics which contain at least one partition with replication factor not equal to the config value of\n+ * {@link com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder#SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}\n+ */\n+public class TopicReplicationFactorAnomaly extends TopicAnomaly {\n+  protected Short _targetReplicationFactor;\n+  protected Set<String> _topicsWithBadReplicationFactor;\n+  protected UpdateTopicConfigurationRunnable _updateTopicConfigurationRunnable;\n+\n+  @Override\n+  public boolean fix() throws Exception {\n+    _optimizationResult = _updateTopicConfigurationRunnable.getResult();\n+    boolean hasProposalsToFix = hasProposalsToFix();\n+    // Ensure that only the relevant response is cached to avoid memory pressure.\n+    _optimizationResult.discardIrrelevantAndCacheJsonAndPlaintext();\n+    return hasProposalsToFix;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public void configure(Map<String, ?> configs) {\n+    super.configure(configs);\n+    KafkaCruiseControl kafkaCruiseControl = extractKafkaCruiseControlObjectFromConfig(configs, KafkaAnomalyType.TOPIC_ANOMALY);\n+    KafkaCruiseControlConfig config = kafkaCruiseControl.config();\n+    _topicsWithBadReplicationFactor = (Set<String>) configs.get(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG);\n+    if (_topicsWithBadReplicationFactor == null || _topicsWithBadReplicationFactor.isEmpty()) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s for topic replication factor anomaly.\", TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG));\n+    }\n+    _targetReplicationFactor = (Short) configs.get(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG);\n+    if (_targetReplicationFactor == null) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s for topic replication factor anomaly.\",\n+                                                       SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG));\n+    }\n+    boolean allowCapacityEstimation = config.getBoolean(ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG);\n+    boolean excludeRecentlyDemotedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG);\n+    boolean excludeRecentlyRemovedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG);\n+    _updateTopicConfigurationRunnable = new UpdateTopicConfigurationRunnable(kafkaCruiseControl,\n+                                                                             Collections.singletonMap(_targetReplicationFactor,\n+                                                                                                      buildTopicRegex(_topicsWithBadReplicationFactor)),\n+                                                                             getSelfHealingGoalNames(config),\n+                                                                             allowCapacityEstimation,\n+                                                                             excludeRecentlyDemotedBrokers,\n+                                                                             excludeRecentlyRemovedBrokers,\n+                                                                             _anomalyId.toString(),\n+                                                                             String.format(\"Self healing for %s: %s\", TOPIC_ANOMALY, this));\n+\n+  }\n+\n+  private Pattern buildTopicRegex(Set<String> topics) {\n+    StringJoiner sj = new StringJoiner(\"|\");\n+    topics.forEach(sj::add);\n+    return Pattern.compile(\"(\" + sj.toString() + \")\");", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc0MTUwMg==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r376741502", "bodyText": "I think the syntax of regex is that \"(a|b|c)\" will match a or b or c.", "author": "kidkun", "createdAt": "2020-02-08T23:35:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzMzExNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MTQ0MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379191441", "bodyText": "The corresponding unit test seems to pass without parentheses, as well. Capturing group seems redundant.", "author": "efeg", "createdAt": "2020-02-14T00:18:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzMzExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzMzUyMw==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374433523", "bodyText": "The meaning of the following sentence is not clear: Detected follow topics...", "author": "efeg", "createdAt": "2020-02-04T01:32:45Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfig;\n+import com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyType;\n+import com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.UpdateTopicConfigurationRunnable;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.regex.Pattern;\n+\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.getSelfHealingGoalNames;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.extractKafkaCruiseControlObjectFromConfig;\n+import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyType.TOPIC_ANOMALY;\n+\n+\n+/**\n+ * Topics which contain at least one partition with replication factor not equal to the config value of\n+ * {@link com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder#SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}\n+ */\n+public class TopicReplicationFactorAnomaly extends TopicAnomaly {\n+  protected Short _targetReplicationFactor;\n+  protected Set<String> _topicsWithBadReplicationFactor;\n+  protected UpdateTopicConfigurationRunnable _updateTopicConfigurationRunnable;\n+\n+  @Override\n+  public boolean fix() throws Exception {\n+    _optimizationResult = _updateTopicConfigurationRunnable.getResult();\n+    boolean hasProposalsToFix = hasProposalsToFix();\n+    // Ensure that only the relevant response is cached to avoid memory pressure.\n+    _optimizationResult.discardIrrelevantAndCacheJsonAndPlaintext();\n+    return hasProposalsToFix;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public void configure(Map<String, ?> configs) {\n+    super.configure(configs);\n+    KafkaCruiseControl kafkaCruiseControl = extractKafkaCruiseControlObjectFromConfig(configs, KafkaAnomalyType.TOPIC_ANOMALY);\n+    KafkaCruiseControlConfig config = kafkaCruiseControl.config();\n+    _topicsWithBadReplicationFactor = (Set<String>) configs.get(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG);\n+    if (_topicsWithBadReplicationFactor == null || _topicsWithBadReplicationFactor.isEmpty()) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s for topic replication factor anomaly.\", TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG));\n+    }\n+    _targetReplicationFactor = (Short) configs.get(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG);\n+    if (_targetReplicationFactor == null) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s for topic replication factor anomaly.\",\n+                                                       SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG));\n+    }\n+    boolean allowCapacityEstimation = config.getBoolean(ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG);\n+    boolean excludeRecentlyDemotedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG);\n+    boolean excludeRecentlyRemovedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG);\n+    _updateTopicConfigurationRunnable = new UpdateTopicConfigurationRunnable(kafkaCruiseControl,\n+                                                                             Collections.singletonMap(_targetReplicationFactor,\n+                                                                                                      buildTopicRegex(_topicsWithBadReplicationFactor)),\n+                                                                             getSelfHealingGoalNames(config),\n+                                                                             allowCapacityEstimation,\n+                                                                             excludeRecentlyDemotedBrokers,\n+                                                                             excludeRecentlyRemovedBrokers,\n+                                                                             _anomalyId.toString(),\n+                                                                             String.format(\"Self healing for %s: %s\", TOPIC_ANOMALY, this));\n+\n+  }\n+\n+  private Pattern buildTopicRegex(Set<String> topics) {\n+    StringJoiner sj = new StringJoiner(\"|\");\n+    topics.forEach(sj::add);\n+    return Pattern.compile(\"(\" + sj.toString() + \")\");\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"{Detected follow topics have at least one partition with replication factor other than \")", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzNDMwNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374434305", "bodyText": "Can we avoid wildcard import?", "author": "efeg", "createdAt": "2020-02-04T01:36:01Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzNTU3NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374435575", "bodyText": "This is a potentially disruptive config -- i.e. if the user forgets setting the value for the target self healing replication factor and enable self healing for all anomaly types, it may cause unintended changes in RF in clusters, where the intended RF != 3.\nTo avoid this scenario, should we make this a required config? -- i.e. we can have a sanity check that fails if the user does not provide a value for this config when this pluggable anomaly finder is used upon configuration time.", "author": "efeg", "createdAt": "2020-02-04T01:41:29Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc0MTc3OA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r376741778", "bodyText": "Good point!", "author": "kidkun", "createdAt": "2020-02-08T23:42:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzNTU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzNjI1MA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374436250", "bodyText": "Can we define what each parameter corresponds to? c and t are not descriptive for a public util function.", "author": "efeg", "createdAt": "2020-02-04T01:44:27Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfigUtils.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.config;\n+\n+import com.linkedin.cruisecontrol.common.CruiseControlConfigurable;\n+import java.util.Map;\n+\n+\n+public class KafkaCruiseControlConfigUtils {\n+\n+  private KafkaCruiseControlConfigUtils() {\n+\n+  }\n+\n+  /**\n+   * @return Configured instance.\n+   */\n+  public static <T> T getConfiguredInstance(Class<?> c, Class<T> t, Map<String, Object> configs) {", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzNzQ4MA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374437480", "bodyText": "Shouldn't the second param be TopicAnomaly.class?", "author": "efeg", "createdAt": "2020-02-04T01:49:37Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;\n+  public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n+  public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n+  public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n+  public static final Class<?> DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS = TopicReplicationFactorAnomaly.class;\n+  public static final String TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG = \"topics.with.bad.replication.factor\";\n+  private KafkaCruiseControl _kafkaCruiseControl;\n+  private int _targetReplicationFactor;\n+  private Pattern _topicExcludedFromCheck;\n+  private Class<?> _topicReplicationTopicAnomalyClass;\n+\n+  @Override\n+  public List<TopicAnomaly> topicAnomalies() {\n+    Cluster cluster = _kafkaCruiseControl.kafkaCluster();\n+    Set<String> topicsWithBadReplicationFactor = new HashSet<>();\n+    for (String topic : cluster.topics()) {\n+      if (_topicExcludedFromCheck.matcher(topic).matches()) {\n+        continue;\n+      }\n+      for (PartitionInfo partition : cluster.partitionsForTopic(topic)) {\n+        if (partition.replicas().length != _targetReplicationFactor) {\n+          topicsWithBadReplicationFactor.add(topic);\n+          break;\n+        }\n+      }\n+    }\n+    if (!topicsWithBadReplicationFactor.isEmpty()) {\n+      return Collections.singletonList(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+                                                                           _targetReplicationFactor));\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  private TopicAnomaly createTopicReplicationFactorAnomaly(Set<String> topicsWithBadReplicationFactor,\n+                                                          int targetReplicationFactor) {\n+    Map<String, Object> configs = new HashMap<>(4);\n+    configs.put(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG, _kafkaCruiseControl);\n+    configs.put(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG, topicsWithBadReplicationFactor);\n+    configs.put(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG, targetReplicationFactor);\n+    configs.put(ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG, _kafkaCruiseControl.timeMs());\n+    return getConfiguredInstance(_topicReplicationTopicAnomalyClass, TopicReplicationFactorAnomaly.class, configs);", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzODEwMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374438101", "bodyText": "I am curious why we prefer this method over KafkaCruiseControlConfig#getConfiguredInstance?", "author": "efeg", "createdAt": "2020-02-04T01:52:37Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;\n+  public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n+  public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n+  public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n+  public static final Class<?> DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS = TopicReplicationFactorAnomaly.class;\n+  public static final String TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG = \"topics.with.bad.replication.factor\";\n+  private KafkaCruiseControl _kafkaCruiseControl;\n+  private int _targetReplicationFactor;\n+  private Pattern _topicExcludedFromCheck;\n+  private Class<?> _topicReplicationTopicAnomalyClass;\n+\n+  @Override\n+  public List<TopicAnomaly> topicAnomalies() {\n+    Cluster cluster = _kafkaCruiseControl.kafkaCluster();\n+    Set<String> topicsWithBadReplicationFactor = new HashSet<>();\n+    for (String topic : cluster.topics()) {\n+      if (_topicExcludedFromCheck.matcher(topic).matches()) {\n+        continue;\n+      }\n+      for (PartitionInfo partition : cluster.partitionsForTopic(topic)) {\n+        if (partition.replicas().length != _targetReplicationFactor) {\n+          topicsWithBadReplicationFactor.add(topic);\n+          break;\n+        }\n+      }\n+    }\n+    if (!topicsWithBadReplicationFactor.isEmpty()) {\n+      return Collections.singletonList(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+                                                                           _targetReplicationFactor));\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  private TopicAnomaly createTopicReplicationFactorAnomaly(Set<String> topicsWithBadReplicationFactor,\n+                                                          int targetReplicationFactor) {\n+    Map<String, Object> configs = new HashMap<>(4);\n+    configs.put(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG, _kafkaCruiseControl);\n+    configs.put(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG, topicsWithBadReplicationFactor);\n+    configs.put(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG, targetReplicationFactor);\n+    configs.put(ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG, _kafkaCruiseControl.timeMs());\n+    return getConfiguredInstance(_topicReplicationTopicAnomalyClass, TopicReplicationFactorAnomaly.class, configs);", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc0MjUxNw==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r376742517", "bodyText": "The issue with  KafkaCruiseControlConfig#getConfiguredInstance is that using this method you can only create object of one type of TopicAnomaly.\nImagine we are trying to that method, we will define a TOPIC_ANOMALY_CLASS_CONFIG config in AnomalyDetectorConfig , and lets's say we set the value of this config to be TopicReplicationFactorAnomaly.class.\nTopicReplicationFactorAnomalyFinder will work just fine.\nThen we are trying to add another TopicAnomalyFinder, TopicPartitionSizeAnomalyFinder and it is supposed to generate TopicPartitionSizeAnomaly, this finder is unable to generate anomaly object using KafkaCruiseControlConfig#getConfiguredInstance.", "author": "kidkun", "createdAt": "2020-02-09T00:00:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzODEwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc0MjU4Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r376742586", "bodyText": "I think MeticAnomaly also has the same issue.", "author": "kidkun", "createdAt": "2020-02-09T00:01:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzODEwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5OTU1MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379199551", "bodyText": "Shouldn't the *AnomalyFinder of a particular Anomaly Detector always generate the same type of anomalies?\n-- i.e. Shouldn't the generated anomaly type have an API to support any anomaly finders? If the anomaly type is missing certain functionalities, I think we should evolve its API. Note that in case of metric anomalies, we have SlowBrokers extending KafkaMetricAnomaly. Hence, the metric anomaly detector always returns an instance of KafkaMetricAnomaly as expected.", "author": "efeg", "createdAt": "2020-02-14T00:49:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzODEwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzODI5MA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374438290", "bodyText": "anomaly detector -> anomaly finder?", "author": "efeg", "createdAt": "2020-02-04T01:53:31Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;\n+  public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n+  public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n+  public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n+  public static final Class<?> DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS = TopicReplicationFactorAnomaly.class;\n+  public static final String TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG = \"topics.with.bad.replication.factor\";\n+  private KafkaCruiseControl _kafkaCruiseControl;\n+  private int _targetReplicationFactor;\n+  private Pattern _topicExcludedFromCheck;\n+  private Class<?> _topicReplicationTopicAnomalyClass;\n+\n+  @Override\n+  public List<TopicAnomaly> topicAnomalies() {\n+    Cluster cluster = _kafkaCruiseControl.kafkaCluster();\n+    Set<String> topicsWithBadReplicationFactor = new HashSet<>();\n+    for (String topic : cluster.topics()) {\n+      if (_topicExcludedFromCheck.matcher(topic).matches()) {\n+        continue;\n+      }\n+      for (PartitionInfo partition : cluster.partitionsForTopic(topic)) {\n+        if (partition.replicas().length != _targetReplicationFactor) {\n+          topicsWithBadReplicationFactor.add(topic);\n+          break;\n+        }\n+      }\n+    }\n+    if (!topicsWithBadReplicationFactor.isEmpty()) {\n+      return Collections.singletonList(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+                                                                           _targetReplicationFactor));\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  private TopicAnomaly createTopicReplicationFactorAnomaly(Set<String> topicsWithBadReplicationFactor,\n+                                                          int targetReplicationFactor) {\n+    Map<String, Object> configs = new HashMap<>(4);\n+    configs.put(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG, _kafkaCruiseControl);\n+    configs.put(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG, topicsWithBadReplicationFactor);\n+    configs.put(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG, targetReplicationFactor);\n+    configs.put(ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG, _kafkaCruiseControl.timeMs());\n+    return getConfiguredInstance(_topicReplicationTopicAnomalyClass, TopicReplicationFactorAnomaly.class, configs);\n+  }\n+\n+  @Override\n+  public void configure(Map<String, ?> configs) {\n+    _kafkaCruiseControl = (KafkaCruiseControl) configs.get(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);\n+    if (_kafkaCruiseControl == null) {\n+      throw new IllegalArgumentException(\"Topic replication factor anomaly detector is missing \" + KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzODg5Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374438897", "bodyText": "If we make this configurable, should we have a sanity check to make sure that this is an instance of TopicAnomaly for early failure?", "author": "efeg", "createdAt": "2020-02-04T01:56:20Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;\n+  public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n+  public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n+  public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n+  public static final Class<?> DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS = TopicReplicationFactorAnomaly.class;\n+  public static final String TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG = \"topics.with.bad.replication.factor\";\n+  private KafkaCruiseControl _kafkaCruiseControl;\n+  private int _targetReplicationFactor;\n+  private Pattern _topicExcludedFromCheck;\n+  private Class<?> _topicReplicationTopicAnomalyClass;\n+\n+  @Override\n+  public List<TopicAnomaly> topicAnomalies() {\n+    Cluster cluster = _kafkaCruiseControl.kafkaCluster();\n+    Set<String> topicsWithBadReplicationFactor = new HashSet<>();\n+    for (String topic : cluster.topics()) {\n+      if (_topicExcludedFromCheck.matcher(topic).matches()) {\n+        continue;\n+      }\n+      for (PartitionInfo partition : cluster.partitionsForTopic(topic)) {\n+        if (partition.replicas().length != _targetReplicationFactor) {\n+          topicsWithBadReplicationFactor.add(topic);\n+          break;\n+        }\n+      }\n+    }\n+    if (!topicsWithBadReplicationFactor.isEmpty()) {\n+      return Collections.singletonList(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+                                                                           _targetReplicationFactor));\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  private TopicAnomaly createTopicReplicationFactorAnomaly(Set<String> topicsWithBadReplicationFactor,\n+                                                          int targetReplicationFactor) {\n+    Map<String, Object> configs = new HashMap<>(4);\n+    configs.put(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG, _kafkaCruiseControl);\n+    configs.put(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG, topicsWithBadReplicationFactor);\n+    configs.put(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG, targetReplicationFactor);\n+    configs.put(ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG, _kafkaCruiseControl.timeMs());\n+    return getConfiguredInstance(_topicReplicationTopicAnomalyClass, TopicReplicationFactorAnomaly.class, configs);\n+  }\n+\n+  @Override\n+  public void configure(Map<String, ?> configs) {\n+    _kafkaCruiseControl = (KafkaCruiseControl) configs.get(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);\n+    if (_kafkaCruiseControl == null) {\n+      throw new IllegalArgumentException(\"Topic replication factor anomaly detector is missing \" + KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);\n+    }\n+    Short targetReplicationFactor = (Short) configs.get(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG);\n+    _targetReplicationFactor = targetReplicationFactor == null ? DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR\n+                                                               : _targetReplicationFactor;\n+    String topicExcludedFromCheck = (String) configs.get(TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK);\n+    _topicExcludedFromCheck = Pattern.compile(topicExcludedFromCheck == null ? DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK\n+                                                                             : topicExcludedFromCheck);\n+    String topicReplicationTopicAnomalyClass = (String) configs.get(TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG);\n+    if (topicReplicationTopicAnomalyClass == null) {\n+      _topicReplicationTopicAnomalyClass = DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS;", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0MjEwMg==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374442102", "bodyText": "If all parameters are local, can we avoid passing them to the method of the same class (e.g. see RemoveBrokersRunnable#removeBrokers())?", "author": "efeg", "createdAt": "2020-02-04T02:11:05Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/UpdateTopicConfigurationRunnable.java", "diffHunk": "@@ -48,38 +57,107 @@\n  */\n public class UpdateTopicConfigurationRunnable extends OperationRunnable {\n   private static final Logger LOG = LoggerFactory.getLogger(UpdateTopicConfigurationRunnable.class);\n-  protected final TopicReplicationFactorChangeParameters _topicReplicationFactorChangeParameters;\n   protected final String _uuid;\n+  protected Map<Short, Pattern> _topicPatternByReplicationFactor;\n+  protected List<String> _goals;\n+  protected boolean _skipRackAwarenessCheck;\n+  protected ModelCompletenessRequirements _requirements;\n+  protected boolean _allowCapacityEstimation;\n+  protected Integer _concurrentInterBrokerPartitionMovements;\n+  protected Integer _concurrentLeaderMovements;\n+  protected Long _executionProgressCheckIntervalMs;\n+  protected boolean _skipHardGoalCheck;\n+  protected ReplicaMovementStrategy _replicaMovementStrategy;\n+  protected Long _replicationThrottle;\n+  protected boolean _excludeRecentlyDemotedBrokers;\n+  protected boolean _excludeRecentlyRemovedBrokers;\n+  protected boolean _dryRun;\n+  protected String _reason;\n+  protected boolean _stopOngoingExecution;\n+  protected boolean _isTriggeredByUserRequest;\n \n   public UpdateTopicConfigurationRunnable(KafkaCruiseControl kafkaCruiseControl,\n                                           OperationFuture future,\n                                           String uuid,\n                                           TopicConfigurationParameters parameters) {\n     super(kafkaCruiseControl, future);\n-    _topicReplicationFactorChangeParameters = parameters.topicReplicationFactorChangeParameters();\n+    TopicReplicationFactorChangeParameters topicReplicationFactorChangeParameters = parameters.topicReplicationFactorChangeParameters();\n+    if (topicReplicationFactorChangeParameters != null) {\n+      _topicPatternByReplicationFactor = topicReplicationFactorChangeParameters.topicPatternByReplicationFactor();\n+      _goals = topicReplicationFactorChangeParameters.goals();\n+      _skipRackAwarenessCheck = topicReplicationFactorChangeParameters.skipRackAwarenessCheck();\n+      _requirements = topicReplicationFactorChangeParameters.modelCompletenessRequirements();\n+      _allowCapacityEstimation = topicReplicationFactorChangeParameters.allowCapacityEstimation();\n+      _concurrentInterBrokerPartitionMovements = topicReplicationFactorChangeParameters.concurrentInterBrokerPartitionMovements();\n+      _concurrentLeaderMovements = topicReplicationFactorChangeParameters.concurrentLeaderMovements();\n+      _executionProgressCheckIntervalMs = topicReplicationFactorChangeParameters.executionProgressCheckIntervalMs();\n+      _skipHardGoalCheck = topicReplicationFactorChangeParameters.skipHardGoalCheck();\n+      _replicaMovementStrategy = topicReplicationFactorChangeParameters.replicaMovementStrategy();\n+      _replicationThrottle = topicReplicationFactorChangeParameters.replicationThrottle();\n+      _excludeRecentlyDemotedBrokers = topicReplicationFactorChangeParameters.excludeRecentlyDemotedBrokers();\n+      _excludeRecentlyRemovedBrokers = topicReplicationFactorChangeParameters.excludeRecentlyRemovedBrokers();\n+      _dryRun = topicReplicationFactorChangeParameters.dryRun();\n+      _reason = topicReplicationFactorChangeParameters.reason();\n+      _stopOngoingExecution = topicReplicationFactorChangeParameters.stopOngoingExecution();\n+      }\n     _uuid = uuid;\n+    _isTriggeredByUserRequest = true;\n   }\n \n+  /**\n+   * Constructor to be used for creating a runnable for self-healing.\n+   */\n+  public UpdateTopicConfigurationRunnable(KafkaCruiseControl kafkaCruiseControl,\n+                                          Map<Short, Pattern> topicPatternByReplicationFactor,\n+                                          List<String> selfHealingGoals,\n+                                          boolean allowCapacityEstimation,\n+                                          boolean excludeRecentlyDemotedBrokers,\n+                                          boolean excludeRecentlyRemovedBrokers,\n+                                          String anomalyId,\n+                                          String reason) {\n+    super(kafkaCruiseControl, new OperationFuture(\"Topic replication factor anomaly self-healing.\"));\n+    _topicPatternByReplicationFactor = topicPatternByReplicationFactor;\n+    _goals = selfHealingGoals;\n+    _skipRackAwarenessCheck = SELF_HEALING_SKIP_RACK_AWARENESS_CHECK;\n+    _requirements = SELF_HEALING_MODEL_COMPLETENESS_REQUIREMENTS;\n+    _allowCapacityEstimation = allowCapacityEstimation;\n+    _concurrentInterBrokerPartitionMovements = SELF_HEALING_CONCURRENT_MOVEMENTS;\n+    _concurrentLeaderMovements = SELF_HEALING_CONCURRENT_MOVEMENTS;\n+    _executionProgressCheckIntervalMs = SELF_HEALING_EXECUTION_PROGRESS_CHECK_INTERVAL_MS;\n+    _skipHardGoalCheck = SELF_HEALING_SKIP_HARD_GOAL_CHECK;\n+    _replicaMovementStrategy = SELF_HEALING_REPLICA_MOVEMENT_STRATEGY;\n+    _replicationThrottle = kafkaCruiseControl.config().getLong(ExecutorConfig.DEFAULT_REPLICATION_THROTTLE_CONFIG);\n+    _excludeRecentlyDemotedBrokers = excludeRecentlyDemotedBrokers;\n+    _excludeRecentlyRemovedBrokers = excludeRecentlyRemovedBrokers;\n+    _dryRun = SELF_HEALING_DRYRUN;\n+    _reason = reason;\n+    _stopOngoingExecution = SELF_HEALING_STOP_ONGOING_EXECUTION;\n+    _uuid = anomalyId;\n+    _isTriggeredByUserRequest = false;\n+  }\n+\n+\n   @Override\n-  protected OptimizationResult getResult() throws Exception {\n-    if (_topicReplicationFactorChangeParameters != null) {\n+  public OptimizationResult getResult() throws Exception {\n+    if (_topicPatternByReplicationFactor != null) {\n       return new OptimizationResult(\n-          updateTopicReplicationFactor(_topicReplicationFactorChangeParameters.topicPatternByReplicationFactor(),\n-                                       _topicReplicationFactorChangeParameters.goals(),\n-                                       _topicReplicationFactorChangeParameters.skipRackAwarenessCheck(),\n-                                       _topicReplicationFactorChangeParameters.modelCompletenessRequirements(),\n-                                       _topicReplicationFactorChangeParameters.allowCapacityEstimation(),\n-                                       _topicReplicationFactorChangeParameters.concurrentInterBrokerPartitionMovements(),\n-                                       _topicReplicationFactorChangeParameters.concurrentLeaderMovements(),\n-                                       _topicReplicationFactorChangeParameters.executionProgressCheckIntervalMs(),\n-                                       _topicReplicationFactorChangeParameters.skipHardGoalCheck(),\n-                                       _topicReplicationFactorChangeParameters.replicaMovementStrategy(),\n-                                       _topicReplicationFactorChangeParameters.replicationThrottle(),\n-                                       _topicReplicationFactorChangeParameters.excludeRecentlyDemotedBrokers(),\n-                                       _topicReplicationFactorChangeParameters.excludeRecentlyRemovedBrokers(),\n-                                       _topicReplicationFactorChangeParameters.dryRun(),\n-                                       _topicReplicationFactorChangeParameters.reason(),\n-                                       _topicReplicationFactorChangeParameters.stopOngoingExecution()),\n+          updateTopicReplicationFactor(_topicPatternByReplicationFactor,", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0MjI1MA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374442250", "bodyText": "Null check on a random local variable of this runnable is a little confusing. Can we make it more clear?", "author": "efeg", "createdAt": "2020-02-04T02:11:56Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/UpdateTopicConfigurationRunnable.java", "diffHunk": "@@ -48,38 +57,107 @@\n  */\n public class UpdateTopicConfigurationRunnable extends OperationRunnable {\n   private static final Logger LOG = LoggerFactory.getLogger(UpdateTopicConfigurationRunnable.class);\n-  protected final TopicReplicationFactorChangeParameters _topicReplicationFactorChangeParameters;\n   protected final String _uuid;\n+  protected Map<Short, Pattern> _topicPatternByReplicationFactor;\n+  protected List<String> _goals;\n+  protected boolean _skipRackAwarenessCheck;\n+  protected ModelCompletenessRequirements _requirements;\n+  protected boolean _allowCapacityEstimation;\n+  protected Integer _concurrentInterBrokerPartitionMovements;\n+  protected Integer _concurrentLeaderMovements;\n+  protected Long _executionProgressCheckIntervalMs;\n+  protected boolean _skipHardGoalCheck;\n+  protected ReplicaMovementStrategy _replicaMovementStrategy;\n+  protected Long _replicationThrottle;\n+  protected boolean _excludeRecentlyDemotedBrokers;\n+  protected boolean _excludeRecentlyRemovedBrokers;\n+  protected boolean _dryRun;\n+  protected String _reason;\n+  protected boolean _stopOngoingExecution;\n+  protected boolean _isTriggeredByUserRequest;\n \n   public UpdateTopicConfigurationRunnable(KafkaCruiseControl kafkaCruiseControl,\n                                           OperationFuture future,\n                                           String uuid,\n                                           TopicConfigurationParameters parameters) {\n     super(kafkaCruiseControl, future);\n-    _topicReplicationFactorChangeParameters = parameters.topicReplicationFactorChangeParameters();\n+    TopicReplicationFactorChangeParameters topicReplicationFactorChangeParameters = parameters.topicReplicationFactorChangeParameters();\n+    if (topicReplicationFactorChangeParameters != null) {\n+      _topicPatternByReplicationFactor = topicReplicationFactorChangeParameters.topicPatternByReplicationFactor();\n+      _goals = topicReplicationFactorChangeParameters.goals();\n+      _skipRackAwarenessCheck = topicReplicationFactorChangeParameters.skipRackAwarenessCheck();\n+      _requirements = topicReplicationFactorChangeParameters.modelCompletenessRequirements();\n+      _allowCapacityEstimation = topicReplicationFactorChangeParameters.allowCapacityEstimation();\n+      _concurrentInterBrokerPartitionMovements = topicReplicationFactorChangeParameters.concurrentInterBrokerPartitionMovements();\n+      _concurrentLeaderMovements = topicReplicationFactorChangeParameters.concurrentLeaderMovements();\n+      _executionProgressCheckIntervalMs = topicReplicationFactorChangeParameters.executionProgressCheckIntervalMs();\n+      _skipHardGoalCheck = topicReplicationFactorChangeParameters.skipHardGoalCheck();\n+      _replicaMovementStrategy = topicReplicationFactorChangeParameters.replicaMovementStrategy();\n+      _replicationThrottle = topicReplicationFactorChangeParameters.replicationThrottle();\n+      _excludeRecentlyDemotedBrokers = topicReplicationFactorChangeParameters.excludeRecentlyDemotedBrokers();\n+      _excludeRecentlyRemovedBrokers = topicReplicationFactorChangeParameters.excludeRecentlyRemovedBrokers();\n+      _dryRun = topicReplicationFactorChangeParameters.dryRun();\n+      _reason = topicReplicationFactorChangeParameters.reason();\n+      _stopOngoingExecution = topicReplicationFactorChangeParameters.stopOngoingExecution();\n+      }\n     _uuid = uuid;\n+    _isTriggeredByUserRequest = true;\n   }\n \n+  /**\n+   * Constructor to be used for creating a runnable for self-healing.\n+   */\n+  public UpdateTopicConfigurationRunnable(KafkaCruiseControl kafkaCruiseControl,\n+                                          Map<Short, Pattern> topicPatternByReplicationFactor,\n+                                          List<String> selfHealingGoals,\n+                                          boolean allowCapacityEstimation,\n+                                          boolean excludeRecentlyDemotedBrokers,\n+                                          boolean excludeRecentlyRemovedBrokers,\n+                                          String anomalyId,\n+                                          String reason) {\n+    super(kafkaCruiseControl, new OperationFuture(\"Topic replication factor anomaly self-healing.\"));\n+    _topicPatternByReplicationFactor = topicPatternByReplicationFactor;\n+    _goals = selfHealingGoals;\n+    _skipRackAwarenessCheck = SELF_HEALING_SKIP_RACK_AWARENESS_CHECK;\n+    _requirements = SELF_HEALING_MODEL_COMPLETENESS_REQUIREMENTS;\n+    _allowCapacityEstimation = allowCapacityEstimation;\n+    _concurrentInterBrokerPartitionMovements = SELF_HEALING_CONCURRENT_MOVEMENTS;\n+    _concurrentLeaderMovements = SELF_HEALING_CONCURRENT_MOVEMENTS;\n+    _executionProgressCheckIntervalMs = SELF_HEALING_EXECUTION_PROGRESS_CHECK_INTERVAL_MS;\n+    _skipHardGoalCheck = SELF_HEALING_SKIP_HARD_GOAL_CHECK;\n+    _replicaMovementStrategy = SELF_HEALING_REPLICA_MOVEMENT_STRATEGY;\n+    _replicationThrottle = kafkaCruiseControl.config().getLong(ExecutorConfig.DEFAULT_REPLICATION_THROTTLE_CONFIG);\n+    _excludeRecentlyDemotedBrokers = excludeRecentlyDemotedBrokers;\n+    _excludeRecentlyRemovedBrokers = excludeRecentlyRemovedBrokers;\n+    _dryRun = SELF_HEALING_DRYRUN;\n+    _reason = reason;\n+    _stopOngoingExecution = SELF_HEALING_STOP_ONGOING_EXECUTION;\n+    _uuid = anomalyId;\n+    _isTriggeredByUserRequest = false;\n+  }\n+\n+\n   @Override\n-  protected OptimizationResult getResult() throws Exception {\n-    if (_topicReplicationFactorChangeParameters != null) {\n+  public OptimizationResult getResult() throws Exception {\n+    if (_topicPatternByReplicationFactor != null) {", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc0NDg0Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r376744846", "bodyText": "I feel this is needed because we plan to add more functionality to this Runnable.  It is supposed to be part of all the topic configuration change code path. Currently we only have topic RF change, so it looks a little bizarre. Once we support more topic configuration change type, it will make more sense.", "author": "kidkun", "createdAt": "2020-02-09T00:25:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0MjI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0Mzc5Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374443797", "bodyText": "Nit: Can we name the CLUSTER_ID to a more specific value?", "author": "efeg", "createdAt": "2020-02-04T02:19:09Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java", "diffHunk": "@@ -24,6 +29,7 @@\n   public static final String T1 = \"T1\";\n   public static final String T2 = \"T2\";\n   public static final Map<Integer, Integer> RACK_BY_BROKER;\n+  public static final String CLUSTER_ID = \"TEST\";", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NDIzMA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374444230", "bodyText": "Nit: Can we avoid hard-coding port number?", "author": "efeg", "createdAt": "2020-02-04T02:21:08Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java", "diffHunk": "@@ -503,4 +509,31 @@ public static ClusterModel getHomogeneousCluster(Map<Integer, Integer> rackByBro\n         (key, value) -> cluster.createBroker(value.toString(), Integer.toString(key), key, commonBrokerCapacityInfo, diskCapacityByLogDir != null));\n     return cluster;\n   }\n+\n+  /**\n+   * Generate the cluster metadata from given cluster model.\n+   * @param clusterModel The cluster model.\n+   * @return The cluster metadata.\n+   */\n+  public static Cluster generateClusterFromClusterModel(ClusterModel clusterModel) {\n+    Map<Integer, Node> nodes = new HashMap<>();\n+    clusterModel.brokers().forEach(b -> nodes.put(b.id(), new Node(b.id(), b.host().toString(), 0, b.rack().id())));", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NTAwNg==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374445006", "bodyText": "Rather than b.host().toString(), maybe it is more preferable to use host().name()?\nFor historical reasons, toString() method is returning XML format -- which is something we should change in this or another patch.", "author": "efeg", "createdAt": "2020-02-04T02:24:31Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java", "diffHunk": "@@ -503,4 +509,31 @@ public static ClusterModel getHomogeneousCluster(Map<Integer, Integer> rackByBro\n         (key, value) -> cluster.createBroker(value.toString(), Integer.toString(key), key, commonBrokerCapacityInfo, diskCapacityByLogDir != null));\n     return cluster;\n   }\n+\n+  /**\n+   * Generate the cluster metadata from given cluster model.\n+   * @param clusterModel The cluster model.\n+   * @return The cluster metadata.\n+   */\n+  public static Cluster generateClusterFromClusterModel(ClusterModel clusterModel) {\n+    Map<Integer, Node> nodes = new HashMap<>();\n+    clusterModel.brokers().forEach(b -> nodes.put(b.id(), new Node(b.id(), b.host().toString(), 0, b.rack().id())));", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NTk4OA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374445988", "bodyText": "Nit (not introduced in this patch): Noticed a typo in static private final long MOCK_ANOMALY_DETECTER_SHUTDOWN_MS = 5000L;", "author": "efeg", "createdAt": "2020-02-04T02:29:02Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetectorTest.java", "diffHunk": "@@ -41,6 +41,9 @@\n import org.junit.Test;\n \n import static com.linkedin.kafka.cruisecontrol.common.DeterministicCluster.smallClusterModel;\n+import static com.linkedin.kafka.cruisecontrol.common.DeterministicCluster.unbalanced;", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NjU4OA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374446588", "bodyText": "This function seems to be quite verbose -- can we move some of the logic to functions to make what it is testing more clear?", "author": "efeg", "createdAt": "2020-02-04T02:31:57Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetectorTest.java", "diffHunk": "@@ -255,7 +278,8 @@ private void testFixAnomaly(AnomalyType anomalyType)\n     EasyMock.expect(mockKafkaCruiseControl.getLoadMonitorTaskRunnerState())\n             .andReturn(LoadMonitorTaskRunner.LoadMonitorTaskRunnerState.RUNNING).times(1, 4);\n \n-    startPeriodicDetectors(mockDetectorScheduler, mockGoalViolationDetector, mockMetricAnomalyDetector, mockDiskFailureDetector, executorService);\n+    startPeriodicDetectors(mockDetectorScheduler, mockGoalViolationDetector, mockMetricAnomalyDetector, mockDiskFailureDetector,", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc0NTA2Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r376745066", "bodyText": "It would be hard since most of the code is to create mock objects, if we move these code to another method, the return value(we need to return a lot of mock object) will be hard in Java.", "author": "kidkun", "createdAt": "2020-02-09T00:31:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NjU4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NzEzMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374447131", "bodyText": "Can we add some notes (e.g. to JavaDoc or inline) on what we are testing?", "author": "efeg", "createdAt": "2020-02-04T02:34:31Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/notifier/SelfHealingNotifierTest.java", "diffHunk": "@@ -197,6 +203,15 @@ public void testSelfHealingDisabled() {\n     assertEquals(AnomalyNotificationResult.Action.IGNORE, result.action());\n     assertTrue(anomalyNotifier._alertCalled.get(KafkaAnomalyType.DISK_FAILURE));\n     assertFalse(anomalyNotifier._autoFixTriggered.get(KafkaAnomalyType.DISK_FAILURE));\n+\n+    // (5) Topic Anomaly", "originalCommit": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "url": "https://github.com/linkedin/cruise-control/commit/c694052ddc5f7c393429b187991b2b5b0a70e7f7", "message": "Fix build failure.", "committedDate": "2020-02-10T06:31:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE4ODMxNg==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379188316", "bodyText": "Nit: Can these static variables also be final?", "author": "efeg", "createdAt": "2020-02-14T00:07:01Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyUtilsTest.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.junit.Test;\n+\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.buildTopicRegex;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+\n+/**\n+ * Unit test class for anomaly utilization methods.\n+ */\n+public class AnomalyUtilsTest {\n+    private static String TOPIC1 = \"abc\";", "originalCommit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MTQ3OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379191479", "bodyText": "The corresponding unit test seems to pass without parentheses, as well. Capturing group seems redundant.", "author": "efeg", "createdAt": "2020-02-14T00:18:19Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyUtilsTest.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.junit.Test;\n+\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.buildTopicRegex;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+\n+/**\n+ * Unit test class for anomaly utilization methods.\n+ */\n+public class AnomalyUtilsTest {\n+    private static String TOPIC1 = \"abc\";\n+    private static String TOPIC2 = \"def\";\n+    private static String TOPIC3 = \"ghi\";\n+\n+    @Test\n+    public void testBuildTopicRegex() {", "originalCommit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MjkxNA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379192914", "bodyText": "Nit: Can we make it KafkaAnomalyType.cachedValues().size() + 1 and add a comment to clarify why we have a + 1?", "author": "efeg", "createdAt": "2020-02-14T00:24:07Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetector.java", "diffHunk": "@@ -48,7 +50,7 @@\n   static final String METRIC_REGISTRY_NAME = \"AnomalyDetector\";\n   private static final int INIT_JITTER_BOUND = 10000;\n   private static final long SCHEDULER_SHUTDOWN_TIMEOUT_MS = 5000L;\n-  private static final int NUM_ANOMALY_DETECTION_THREADS = 5;\n+  private static final int NUM_ANOMALY_DETECTION_THREADS = 6;", "originalCommit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5NDk4OA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379194988", "bodyText": "Nit: Would it be more clear to say violation of user-defined topic properties rather than certain desired topic property?", "author": "efeg", "createdAt": "2020-02-14T00:31:55Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.CruiseControlConfigurable;\n+import java.util.Set;\n+import org.apache.yetus.audience.InterfaceStability;\n+\n+\n+/**\n+ * The finder which checks topics against certain desired topic property to identify topic anomaly.", "originalCommit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwMTk3NA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379201974", "bodyText": "Can we make all variables final?", "author": "efeg", "createdAt": "2020-02-14T00:58:09Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/UpdateTopicConfigurationRunnable.java", "diffHunk": "@@ -48,39 +57,90 @@\n  */\n public class UpdateTopicConfigurationRunnable extends OperationRunnable {\n   private static final Logger LOG = LoggerFactory.getLogger(UpdateTopicConfigurationRunnable.class);\n-  protected final TopicReplicationFactorChangeParameters _topicReplicationFactorChangeParameters;\n   protected final String _uuid;\n+  protected Map<Short, Pattern> _topicPatternByReplicationFactor;", "originalCommit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTc1NzI4MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379757281", "bodyText": "we can not make them final because in one constructor we may not initialize them.", "author": "kidkun", "createdAt": "2020-02-15T06:10:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwMTk3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk5OTQ0NA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r380999444", "bodyText": "Would it be possible to initialize them to null in the constructor otherwise?", "author": "efeg", "createdAt": "2020-02-18T23:37:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwMTk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwMzQyMA==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379203420", "bodyText": "Nit: Let's avoid hardcoding test constants.", "author": "efeg", "createdAt": "2020-02-14T01:03:11Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/notifier/SelfHealingNotifierTest.java", "diffHunk": "@@ -162,6 +166,8 @@ public void testSelfHealingDisabled() {\n                                  Collections.singletonMap(brokerWithMetricAnomaly, anomalyDetectionTime));\n     parameterConfigOverrides.put(FAILED_DISKS_OBJECT_CONFIG,\n                                  Collections.singletonMap(1, Collections.singletonMap(\"logdir1\", failureTime1)));\n+    parameterConfigOverrides.put(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG, (short) 3);\n+    parameterConfigOverrides.put(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG, Collections.singleton(\"topic1\"));", "originalCommit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwNDc1NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379204755", "bodyText": "Nit: bad indentation", "author": "efeg", "createdAt": "2020-02-14T01:07:39Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.CLASS;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.getConfiguredInstance;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ * Required configurations for this class.\n+ * <ul>\n+ *   <li>{@link #SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}: The config for the target replication factor of topics.\n+ *   <li>{@link #TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}: The config to specify topics excluded from the anomaly checking.\n+ *   The value is treated as a regular expression, default value is set to\n+ *   {@link #DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}.\n+ *   <li>{@link #TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG}: The config for the topic anomaly class name,\n+ *   default value is set to {@link #DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS}.\n+ * </ul>\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n+  public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n+  public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n+  public static final Class<?> DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS = TopicReplicationFactorAnomaly.class;\n+  public static final String TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG = \"topics.with.bad.replication.factor\";\n+  private KafkaCruiseControl _kafkaCruiseControl;\n+  private int _targetReplicationFactor;\n+  private Pattern _topicExcludedFromCheck;\n+  private Class<?> _topicReplicationTopicAnomalyClass;\n+\n+  @Override\n+  public Set<TopicAnomaly> topicAnomalies() {\n+    Cluster cluster = _kafkaCruiseControl.kafkaCluster();\n+    Set<String> topicsWithBadReplicationFactor = new HashSet<>();\n+    for (String topic : cluster.topics()) {\n+      if (_topicExcludedFromCheck.matcher(topic).matches()) {\n+        continue;\n+      }\n+      for (PartitionInfo partition : cluster.partitionsForTopic(topic)) {\n+        if (partition.replicas().length != _targetReplicationFactor) {\n+          topicsWithBadReplicationFactor.add(topic);\n+          break;\n+        }\n+      }\n+    }\n+    if (!topicsWithBadReplicationFactor.isEmpty()) {\n+      return Collections.singleton(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+                                                                       _targetReplicationFactor));\n+    }\n+    return Collections.emptySet();\n+  }\n+\n+  private TopicAnomaly createTopicReplicationFactorAnomaly(Set<String> topicsWithBadReplicationFactor,\n+                                                          int targetReplicationFactor) {", "originalCommit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwNjUxNg==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379206516", "bodyText": "(Not introduced in this patch) We are missing similar sanity checks for pluggable SlowBrokerFinder for AnomalyDetectorConfig.METRIC_ANOMALY_CLASS_CONFIG .", "author": "efeg", "createdAt": "2020-02-14T01:14:23Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.CLASS;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.getConfiguredInstance;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ * Required configurations for this class.\n+ * <ul>\n+ *   <li>{@link #SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}: The config for the target replication factor of topics.\n+ *   <li>{@link #TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}: The config to specify topics excluded from the anomaly checking.\n+ *   The value is treated as a regular expression, default value is set to\n+ *   {@link #DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}.\n+ *   <li>{@link #TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG}: The config for the topic anomaly class name,\n+ *   default value is set to {@link #DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS}.\n+ * </ul>\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n+  public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n+  public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n+  public static final Class<?> DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS = TopicReplicationFactorAnomaly.class;\n+  public static final String TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG = \"topics.with.bad.replication.factor\";\n+  private KafkaCruiseControl _kafkaCruiseControl;\n+  private int _targetReplicationFactor;\n+  private Pattern _topicExcludedFromCheck;\n+  private Class<?> _topicReplicationTopicAnomalyClass;\n+\n+  @Override\n+  public Set<TopicAnomaly> topicAnomalies() {\n+    Cluster cluster = _kafkaCruiseControl.kafkaCluster();\n+    Set<String> topicsWithBadReplicationFactor = new HashSet<>();\n+    for (String topic : cluster.topics()) {\n+      if (_topicExcludedFromCheck.matcher(topic).matches()) {\n+        continue;\n+      }\n+      for (PartitionInfo partition : cluster.partitionsForTopic(topic)) {\n+        if (partition.replicas().length != _targetReplicationFactor) {\n+          topicsWithBadReplicationFactor.add(topic);\n+          break;\n+        }\n+      }\n+    }\n+    if (!topicsWithBadReplicationFactor.isEmpty()) {\n+      return Collections.singleton(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+                                                                       _targetReplicationFactor));\n+    }\n+    return Collections.emptySet();\n+  }\n+\n+  private TopicAnomaly createTopicReplicationFactorAnomaly(Set<String> topicsWithBadReplicationFactor,\n+                                                          int targetReplicationFactor) {\n+    Map<String, Object> configs = new HashMap<>(4);\n+    configs.put(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG, _kafkaCruiseControl);\n+    configs.put(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG, topicsWithBadReplicationFactor);\n+    configs.put(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG, targetReplicationFactor);\n+    configs.put(ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG, _kafkaCruiseControl.timeMs());\n+    return getConfiguredInstance(_topicReplicationTopicAnomalyClass, TopicAnomaly.class, configs);\n+  }\n+\n+  @Override\n+  public void configure(Map<String, ?> configs) {\n+    _kafkaCruiseControl = (KafkaCruiseControl) configs.get(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);\n+    if (_kafkaCruiseControl == null) {\n+      throw new IllegalArgumentException(\"Topic replication factor anomaly finder is missing \" + KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);\n+    }\n+    Short targetReplicationFactor = (Short) configs.get(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG);\n+    if (targetReplicationFactor == null) {\n+      throw new IllegalArgumentException(\"Topic replication factor anomaly finder is missing \" + SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG);\n+    }\n+    _targetReplicationFactor = targetReplicationFactor;\n+    String topicExcludedFromCheck = (String) configs.get(TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK);\n+    _topicExcludedFromCheck = Pattern.compile(topicExcludedFromCheck == null ? DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK\n+                                                                             : topicExcludedFromCheck);\n+    String topicReplicationTopicAnomalyClass = (String) configs.get(TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG);\n+    if (topicReplicationTopicAnomalyClass == null) {\n+      _topicReplicationTopicAnomalyClass = DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS;\n+    } else {\n+      _topicReplicationTopicAnomalyClass = (Class<?>) ConfigDef.parseType(TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG,\n+                                                                          topicReplicationTopicAnomalyClass,\n+                                                                          CLASS);\n+      if (_topicReplicationTopicAnomalyClass == null || !TopicAnomaly.class.isAssignableFrom(_topicReplicationTopicAnomalyClass)) {", "originalCommit": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTc2MDE1Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379760156", "bodyText": "Discussed this offline, I would like to fix this in a follow-up patch to fix a bigger metric anomaly issue.", "author": "kidkun", "createdAt": "2020-02-15T06:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwNjUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIzMjc5Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r382232793", "bodyText": "Nit: Can we move the default to a static variable?", "author": "efeg", "createdAt": "2020-02-20T20:13:16Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnomalyDetectorConfig.java", "diffHunk": "@@ -269,6 +286,16 @@ public static ConfigDef define(ConfigDef configDef) {\n                             ConfigDef.Type.BOOLEAN,\n                             DEFAULT_ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG,\n                             ConfigDef.Importance.LOW,\n-                            ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_DOC);\n+                            ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_DOC)\n+                    .define(TOPIC_ANOMALY_FINDER_CLASSES_CONFIG,\n+                            ConfigDef.Type.LIST,\n+                            DEFAULT_TOPIC_ANOMALY_FINDER_CLASS,\n+                            ConfigDef.Importance.MEDIUM,\n+                            TOPIC_ANOMALY_FINDER_CLASSES_DOC)\n+                    .define(TOPIC_ANOMALY_DETECTION_INTERVAL_MS_CONFIG,\n+                            ConfigDef.Type.LONG,\n+                            null,", "originalCommit": "7c600aa16a95127bb01db28f130c479a913ea9ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIzNTkxNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r382235915", "bodyText": "If we make this the default topic anomaly finder, even if the user does not want to use the topic anomaly finder, s/he will receive an IllegalXXX exception upon configuration time due to missing default replication factor. Should we:\n\nMake the NoopTopic Anomaly Finder as the default here, and\nAdd a documentation under the wiki on what needs to be done to use TopicReplicationFactorAnomalyFinder?\nAlso add documentation on configurations section of wiki to add the new configs?", "author": "efeg", "createdAt": "2020-02-20T20:20:03Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnomalyDetectorConfig.java", "diffHunk": "@@ -172,6 +173,22 @@ private AnomalyDetectorConfig() {\n   public static final String ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_DOC = \"The flag to indicate whether anomaly \"\n       + \"detection threads allow capacity estimation in the generated cluster model they use.\";\n \n+  /**\n+   * <code>topic.anomaly.detection.interval.ms</code>\n+   */\n+  public static final String TOPIC_ANOMALY_DETECTION_INTERVAL_MS_CONFIG = \"topic.anomaly.detection.interval.ms\";\n+  public static final String TOPIC_ANOMALY_DETECTION_INTERVAL_MS_DOC = \"The interval in millisecond that topic anomaly \"\n+      + \"detector will run to detect topic anomalies. If this interval time is not specified, topic anomaly detector \"\n+      + \"will run with interval specified in \" + ANOMALY_DETECTION_INTERVAL_MS_CONFIG + \".\";\n+\n+  /**\n+   * <code>topic.anomaly.finder.class</code>\n+   */\n+  public static final String TOPIC_ANOMALY_FINDER_CLASSES_CONFIG = \"topic.anomaly.finder.class\";\n+  public static final String DEFAULT_TOPIC_ANOMALY_FINDER_CLASS = TopicReplicationFactorAnomalyFinder.class.getName();", "originalCommit": "7c600aa16a95127bb01db28f130c479a913ea9ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIzNjQ3Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r382236477", "bodyText": "Is this import intentional? Shouldn't we use org.apache.kafka.common.annotation.InterfaceStability;?", "author": "efeg", "createdAt": "2020-02-20T20:21:16Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.CruiseControlConfigurable;\n+import java.util.Set;\n+import org.apache.yetus.audience.InterfaceStability;", "originalCommit": "7c600aa16a95127bb01db28f130c479a913ea9ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0ef939f4f523ff7e90f2669da3be46fdc847f260", "url": "https://github.com/linkedin/cruise-control/commit/0ef939f4f523ff7e90f2669da3be46fdc847f260", "message": "Add support to detect and self-heal inconsistent topic replication factor.", "committedDate": "2020-02-20T22:45:44Z", "type": "commit"}, {"oid": "ac1c3b1ed8ec53ba2662ce503dde083e92dea69f", "url": "https://github.com/linkedin/cruise-control/commit/ac1c3b1ed8ec53ba2662ce503dde083e92dea69f", "message": "Fix build failure.", "committedDate": "2020-02-20T22:45:44Z", "type": "commit"}, {"oid": "7f73b230eccfcbff9ca89991cb9ad0a09e88e6aa", "url": "https://github.com/linkedin/cruise-control/commit/7f73b230eccfcbff9ca89991cb9ad0a09e88e6aa", "message": "Remove access.log", "committedDate": "2020-02-20T22:45:44Z", "type": "commit"}, {"oid": "a31b96c336a80462028dbfa40a891d1c3d9e90db", "url": "https://github.com/linkedin/cruise-control/commit/a31b96c336a80462028dbfa40a891d1c3d9e90db", "message": "Address the feedback.", "committedDate": "2020-02-20T22:46:35Z", "type": "commit"}, {"oid": "529138d2635fbe86947ce6b2556eff615b31bd50", "url": "https://github.com/linkedin/cruise-control/commit/529138d2635fbe86947ce6b2556eff615b31bd50", "message": "Fix build failure.", "committedDate": "2020-02-20T22:46:35Z", "type": "commit"}, {"oid": "ee8771f3ab11ffe5671e0753b5f1af7f65506632", "url": "https://github.com/linkedin/cruise-control/commit/ee8771f3ab11ffe5671e0753b5f1af7f65506632", "message": "Address the feedback.", "committedDate": "2020-02-20T22:46:35Z", "type": "commit"}, {"oid": "3cbfa344156a644b0d80e28f01deb2cc6279e18b", "url": "https://github.com/linkedin/cruise-control/commit/3cbfa344156a644b0d80e28f01deb2cc6279e18b", "message": "remove access log.", "committedDate": "2020-02-20T22:46:35Z", "type": "commit"}, {"oid": "97033a2e74eb2fea158a67d3e114cb41173ace0e", "url": "https://github.com/linkedin/cruise-control/commit/97033a2e74eb2fea158a67d3e114cb41173ace0e", "message": "Address the feedback.", "committedDate": "2020-02-20T22:52:54Z", "type": "commit"}, {"oid": "97033a2e74eb2fea158a67d3e114cb41173ace0e", "url": "https://github.com/linkedin/cruise-control/commit/97033a2e74eb2fea158a67d3e114cb41173ace0e", "message": "Address the feedback.", "committedDate": "2020-02-20T22:52:54Z", "type": "forcePushed"}, {"oid": "05cfe1c9757e0c3f4b40144e79c08c357d381f80", "url": "https://github.com/linkedin/cruise-control/commit/05cfe1c9757e0c3f4b40144e79c08c357d381f80", "message": "Fix build failure and udpate wiki.", "committedDate": "2020-02-20T23:17:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2MjcwNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r382362705", "bodyText": "Can we use NoopTopicAnomalyFinder.class.getName() and use in topic anomaly unit test?", "author": "efeg", "createdAt": "2020-02-21T02:11:43Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControlUnitTestUtils.java", "diffHunk": "@@ -60,6 +60,7 @@ public static Properties getKafkaCruiseControlProperties() {\n                       Boolean.toString(AnomalyDetectorConfig.DEFAULT_SELF_HEALING_EXCLUDE_RECENT_BROKERS_CONFIG));\n     props.setProperty(AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG,\n                       Boolean.toString(AnomalyDetectorConfig.DEFAULT_SELF_HEALING_EXCLUDE_RECENT_BROKERS_CONFIG));\n+    props.setProperty(AnomalyDetectorConfig.TOPIC_ANOMALY_FINDER_CLASSES_CONFIG, \"\");", "originalCommit": "05cfe1c9757e0c3f4b40144e79c08c357d381f80", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dffd7ff392b8df6e393798d89f2384f435ea2b8f", "url": "https://github.com/linkedin/cruise-control/commit/dffd7ff392b8df6e393798d89f2384f435ea2b8f", "message": "Address the feedback.", "committedDate": "2020-02-21T18:18:26Z", "type": "commit"}]}