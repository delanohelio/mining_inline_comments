{"pr_number": 1407, "pr_title": "Provide idempotency support to handle duplicate maintenance events", "pr_createdAt": "2020-12-03T02:50:59Z", "pr_url": "https://github.com/linkedin/cruise-control/pull/1407", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ3ODA4MA==", "url": "https://github.com/linkedin/cruise-control/pull/1407#discussion_r535478080", "bodyText": "Just curious: in what situation(s) CC needs to use a non-daemon thread?", "author": "Lincong", "createdAt": "2020-12-03T18:25:22Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/common/KafkaCruiseControlThreadFactory.java", "diffHunk": "@@ -17,9 +17,11 @@\n   private final AtomicInteger _id = new AtomicInteger(0);\n   private final Logger _logger;\n \n-  public KafkaCruiseControlThreadFactory(String name,\n-                                         boolean daemon,\n-                                         Logger logger) {\n+  public KafkaCruiseControlThreadFactory(String name) {\n+    this(name, true, null);\n+  }\n+\n+  public KafkaCruiseControlThreadFactory(String name, boolean daemon, Logger logger) {", "originalCommit": "92ab5730fed792b750e7ceb91018dabfabe69c5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTgwNDA3Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1407#discussion_r535804072", "bodyText": "A daemon thread provides a general service in the background as long as the program is running. It does not prevent the JVM from exiting when the program finishes but the thread is still running.\nFor example, when CC is executing a proposal, we may not want to let JVM exit until we make sure that the execution cleanup is handled properly -- i.e. stopped/cancelled tasks. Hence, if execution is still in progress, it might take slightly longer to shutdown the executor. That's why we have a non-daemon proposal executor.", "author": "efeg", "createdAt": "2020-12-04T03:12:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ3ODA4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTgwNjQ3NA==", "url": "https://github.com/linkedin/cruise-control/pull/1407#discussion_r535806474", "bodyText": "Makes sense", "author": "Lincong", "createdAt": "2020-12-04T03:20:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ3ODA4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ3OTg1MA==", "url": "https://github.com/linkedin/cruise-control/pull/1407#discussion_r535479850", "bodyText": "Is it reasonable to think about creating another static class MaintenanceEventConfig for all configs related to maintenance event?", "author": "Lincong", "createdAt": "2020-12-03T18:27:58Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnomalyDetectorConfig.java", "diffHunk": "@@ -227,6 +228,31 @@ private AnomalyDetectorConfig() {\n   public static final String DEFAULT_MAINTENANCE_EVENT_CLASS = MaintenanceEvent.class.getName();", "originalCommit": "92ab5730fed792b750e7ceb91018dabfabe69c5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTgwNDA4Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1407#discussion_r535804086", "bodyText": "MaintenanceEvent is an anomaly -- it extends from it -- and all anomaly configs are located in AnomalyDetectorConfig.", "author": "efeg", "createdAt": "2020-12-04T03:12:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ3OTg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ4MDg4Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1407#discussion_r535480887", "bodyText": "Even though 25 as default is probably good enough. But why not make the mac cache size larger (e.g. 1000)? I assume the cache entry is not too big in size.", "author": "Lincong", "createdAt": "2020-12-03T18:29:40Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnomalyDetectorConfig.java", "diffHunk": "@@ -227,6 +228,31 @@ private AnomalyDetectorConfig() {\n   public static final String DEFAULT_MAINTENANCE_EVENT_CLASS = MaintenanceEvent.class.getName();\n   public static final String MAINTENANCE_EVENT_CLASS_DOC = \"The name of class that extends maintenance event.\";\n \n+  /**\n+   * <code>maintenance.event.enable.idempotence</code>\n+   */\n+  public static final String MAINTENANCE_EVENT_ENABLE_IDEMPOTENCE_CONFIG = \"maintenance.event.enable.idempotence\";\n+  public static final boolean DEFAULT_MAINTENANCE_EVENT_ENABLE_IDEMPOTENCE = true;\n+  public static final String MAINTENANCE_EVENT_ENABLE_IDEMPOTENCE_DOC = \"The flag to indicate whether maintenance event detector will drop \"\n+      + \"the duplicate maintenance events detected within the configured retention period.\";\n+\n+  /**\n+   * <code>maintenance.event.idempotence.retention.ms</code>\n+   */\n+  public static final String MAINTENANCE_EVENT_IDEMPOTENCE_RETENTION_MS_CONFIG = \"maintenance.event.idempotence.retention.ms\";\n+  public static final long DEFAULT_MAINTENANCE_EVENT_IDEMPOTENCE_RETENTION_MS = TimeUnit.MINUTES.toMillis(3);\n+  public static final String MAINTENANCE_EVENT_IDEMPOTENCE_RETENTION_MS_DOC = \"The maximum time in ms to store events retrieved from the\"\n+      + \" MaintenanceEventReader. Relevant only if idempotency is enabled (see \" + MAINTENANCE_EVENT_ENABLE_IDEMPOTENCE_CONFIG + \").\";\n+\n+  /**\n+   * <code>maintenance.event.max.idempotence.cache.size</code>\n+   */\n+  public static final String MAINTENANCE_EVENT_MAX_IDEMPOTENCE_CACHE_SIZE_CONFIG = \"maintenance.event.max.idempotence.cache.size\";\n+  public static final int DEFAULT_MAINTENANCE_EVENT_MAX_IDEMPOTENCE_CACHE_SIZE = 25;", "originalCommit": "92ab5730fed792b750e7ceb91018dabfabe69c5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTgwNDEwMg==", "url": "https://github.com/linkedin/cruise-control/pull/1407#discussion_r535804102", "bodyText": "Maintenance events (e.g. planned maintenance events in Azure) are expected to be rare. In particular, a burst of up to 25 distinct (i.e. not duplicate) maintenance events within the default retention period must be extremely rare. CC's anomaly detector manager cannot (and is not expected to) handle this many maintenance events in such a short period.\nPresumably, pushing the limit to a higher value would be an exceptional case that would better handled based on user needs.", "author": "efeg", "createdAt": "2020-12-04T03:12:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ4MDg4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ4MzQyNA==", "url": "https://github.com/linkedin/cruise-control/pull/1407#discussion_r535483424", "bodyText": "Nit: I usually prefer to put a shorter branch first. For example, in this case:\nif (! _idempotenceEnabled) {\n    _maintenanceEventByTime = null;\n    _idempotenceCacheCleaner = null;\n} else{\n    ...\n}", "author": "Lincong", "createdAt": "2020-12-03T18:33:49Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/MaintenanceEventDetector.java", "diffHunk": "@@ -6,42 +6,112 @@\n \n import com.linkedin.cruisecontrol.detector.Anomaly;\n import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.common.KafkaCruiseControlThreadFactory;\n import com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig;\n import java.time.Duration;\n import java.util.Collections;\n+import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.MAINTENANCE_EVENT_READER_CLASS_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.getAnomalyDetectionStatus;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n \n \n public class MaintenanceEventDetector extends AbstractAnomalyDetector implements Runnable {\n   private static final Logger LOG = LoggerFactory.getLogger(MaintenanceEventDetector.class);\n   public static final long DETECTION_NOT_READY_BACKOFF_MS = TimeUnit.SECONDS.toMillis(10);\n+  public static final long IDEMPOTENCE_CACHE_CLEANER_PERIOD_SECONDS = 5;\n+  public static final long IDEMPOTENCE_CACHE_CLEANER_INITIAL_DELAY_SECONDS = 0;\n   // TODO: Make this configurable.\n   public static final Duration READ_EVENTS_TIMEOUT = Duration.ofSeconds(5);\n   private volatile boolean _shutdown;\n   private final MaintenanceEventReader _maintenanceEventReader;\n+  private final boolean _idempotenceEnabled;\n+  private final Duration _idempotenceRetention;\n+  private final ScheduledExecutorService _idempotenceCacheCleaner;\n+  private final Map<Long, MaintenanceEvent> _maintenanceEventByTime;\n \n   public MaintenanceEventDetector(Queue<Anomaly> anomalies, KafkaCruiseControl kafkaCruiseControl) {\n     super(anomalies, kafkaCruiseControl);\n     KafkaCruiseControlConfig config = _kafkaCruiseControl.config();\n     _shutdown = false;\n     Map<String, Object> configWithCruiseControlObject = Collections.singletonMap(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG,\n                                                                                  kafkaCruiseControl);\n-    _maintenanceEventReader = config.getConfiguredInstance(MAINTENANCE_EVENT_READER_CLASS_CONFIG,\n+    _maintenanceEventReader = config.getConfiguredInstance(AnomalyDetectorConfig.MAINTENANCE_EVENT_READER_CLASS_CONFIG,\n                                                            MaintenanceEventReader.class,\n                                                            configWithCruiseControlObject);\n+    _idempotenceEnabled = config.getBoolean(AnomalyDetectorConfig.MAINTENANCE_EVENT_ENABLE_IDEMPOTENCE_CONFIG);\n+    _idempotenceRetention = Duration.ofMillis(config.getLong(AnomalyDetectorConfig.MAINTENANCE_EVENT_IDEMPOTENCE_RETENTION_MS_CONFIG));\n+    if (_idempotenceEnabled) {", "originalCommit": "92ab5730fed792b750e7ceb91018dabfabe69c5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTgwNDIyMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1407#discussion_r535804221", "bodyText": "This became irrelevant with the latest update.", "author": "efeg", "createdAt": "2020-12-04T03:13:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ4MzQyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ4ODQ0OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1407#discussion_r535488449", "bodyText": "Maybe we should log something after we remove some entries and include the number of entries we have removed in this method", "author": "Lincong", "createdAt": "2020-12-03T18:41:58Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/MaintenanceEventDetector.java", "diffHunk": "@@ -6,42 +6,112 @@\n \n import com.linkedin.cruisecontrol.detector.Anomaly;\n import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.common.KafkaCruiseControlThreadFactory;\n import com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig;\n import java.time.Duration;\n import java.util.Collections;\n+import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.MAINTENANCE_EVENT_READER_CLASS_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.getAnomalyDetectionStatus;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n \n \n public class MaintenanceEventDetector extends AbstractAnomalyDetector implements Runnable {\n   private static final Logger LOG = LoggerFactory.getLogger(MaintenanceEventDetector.class);\n   public static final long DETECTION_NOT_READY_BACKOFF_MS = TimeUnit.SECONDS.toMillis(10);\n+  public static final long IDEMPOTENCE_CACHE_CLEANER_PERIOD_SECONDS = 5;\n+  public static final long IDEMPOTENCE_CACHE_CLEANER_INITIAL_DELAY_SECONDS = 0;\n   // TODO: Make this configurable.\n   public static final Duration READ_EVENTS_TIMEOUT = Duration.ofSeconds(5);\n   private volatile boolean _shutdown;\n   private final MaintenanceEventReader _maintenanceEventReader;\n+  private final boolean _idempotenceEnabled;\n+  private final Duration _idempotenceRetention;\n+  private final ScheduledExecutorService _idempotenceCacheCleaner;\n+  private final Map<Long, MaintenanceEvent> _maintenanceEventByTime;\n \n   public MaintenanceEventDetector(Queue<Anomaly> anomalies, KafkaCruiseControl kafkaCruiseControl) {\n     super(anomalies, kafkaCruiseControl);\n     KafkaCruiseControlConfig config = _kafkaCruiseControl.config();\n     _shutdown = false;\n     Map<String, Object> configWithCruiseControlObject = Collections.singletonMap(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG,\n                                                                                  kafkaCruiseControl);\n-    _maintenanceEventReader = config.getConfiguredInstance(MAINTENANCE_EVENT_READER_CLASS_CONFIG,\n+    _maintenanceEventReader = config.getConfiguredInstance(AnomalyDetectorConfig.MAINTENANCE_EVENT_READER_CLASS_CONFIG,\n                                                            MaintenanceEventReader.class,\n                                                            configWithCruiseControlObject);\n+    _idempotenceEnabled = config.getBoolean(AnomalyDetectorConfig.MAINTENANCE_EVENT_ENABLE_IDEMPOTENCE_CONFIG);\n+    _idempotenceRetention = Duration.ofMillis(config.getLong(AnomalyDetectorConfig.MAINTENANCE_EVENT_IDEMPOTENCE_RETENTION_MS_CONFIG));\n+    if (_idempotenceEnabled) {\n+      int maxIdempotenceCacheSize = config.getInt(AnomalyDetectorConfig.MAINTENANCE_EVENT_MAX_IDEMPOTENCE_CACHE_SIZE_CONFIG);\n+      _maintenanceEventByTime = new LinkedHashMap<Long, MaintenanceEvent>() {\n+        @Override\n+        protected boolean removeEldestEntry(Map.Entry<Long, MaintenanceEvent> eldest) {\n+          return this.size() > maxIdempotenceCacheSize;\n+        }\n+      };\n+      _idempotenceCacheCleaner = Executors.newSingleThreadScheduledExecutor(new KafkaCruiseControlThreadFactory(\"IdempotenceCacheCleaner\"));\n+      _idempotenceCacheCleaner.scheduleAtFixedRate(new IdempotenceCacheCleaner(),\n+                                                   IDEMPOTENCE_CACHE_CLEANER_INITIAL_DELAY_SECONDS,\n+                                                   IDEMPOTENCE_CACHE_CLEANER_PERIOD_SECONDS,\n+                                                   TimeUnit.SECONDS);\n+    } else {\n+      _maintenanceEventByTime = null;\n+      _idempotenceCacheCleaner = null;\n+    }\n+  }\n+\n+  private synchronized void removeOldEventsFromIdempotenceCache() {\n+    LOG.debug(\"Remove old events from idempotence cache.\");", "originalCommit": "92ab5730fed792b750e7ceb91018dabfabe69c5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTgwNDI2NA==", "url": "https://github.com/linkedin/cruise-control/pull/1407#discussion_r535804264", "bodyText": "I agree that logging the idempotence cache before and after to see if there are any issues with the cache or cleanup mechanism might be useful for debugging purposes.", "author": "efeg", "createdAt": "2020-12-04T03:13:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ4ODQ0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ5NzM0NA==", "url": "https://github.com/linkedin/cruise-control/pull/1407#discussion_r535497344", "bodyText": "Instead of storing reference of MaintenanceEvent as values in the map, can we just add hashCode() and equals() methods to the MaintenanceEvent class and store hash code of MaintenanceEvent object in this map? I think we can save memory and increase the max cache size by a lot", "author": "Lincong", "createdAt": "2020-12-03T18:56:15Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/MaintenanceEventDetector.java", "diffHunk": "@@ -6,42 +6,112 @@\n \n import com.linkedin.cruisecontrol.detector.Anomaly;\n import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.common.KafkaCruiseControlThreadFactory;\n import com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig;\n import java.time.Duration;\n import java.util.Collections;\n+import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.MAINTENANCE_EVENT_READER_CLASS_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.getAnomalyDetectionStatus;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n \n \n public class MaintenanceEventDetector extends AbstractAnomalyDetector implements Runnable {\n   private static final Logger LOG = LoggerFactory.getLogger(MaintenanceEventDetector.class);\n   public static final long DETECTION_NOT_READY_BACKOFF_MS = TimeUnit.SECONDS.toMillis(10);\n+  public static final long IDEMPOTENCE_CACHE_CLEANER_PERIOD_SECONDS = 5;\n+  public static final long IDEMPOTENCE_CACHE_CLEANER_INITIAL_DELAY_SECONDS = 0;\n   // TODO: Make this configurable.\n   public static final Duration READ_EVENTS_TIMEOUT = Duration.ofSeconds(5);\n   private volatile boolean _shutdown;\n   private final MaintenanceEventReader _maintenanceEventReader;\n+  private final boolean _idempotenceEnabled;\n+  private final Duration _idempotenceRetention;\n+  private final ScheduledExecutorService _idempotenceCacheCleaner;\n+  private final Map<Long, MaintenanceEvent> _maintenanceEventByTime;", "originalCommit": "92ab5730fed792b750e7ceb91018dabfabe69c5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTgwNDI5OA==", "url": "https://github.com/linkedin/cruise-control/pull/1407#discussion_r535804298", "bodyText": "(This patch already adds hashCode() and equals() methods to the MaintenanceEvent class).\nI see the reasoning, but as discussed earlier this cache is not expected to contain many entries. Hence, I don't think the additional programming complexity of storing hashcode rather than the event itself would worth it.", "author": "efeg", "createdAt": "2020-12-04T03:13:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ5NzM0NA=="}], "type": "inlineReview"}, {"oid": "00112ecf74d2f247adb11e2919a6a7d10725ca1c", "url": "https://github.com/linkedin/cruise-control/commit/00112ecf74d2f247adb11e2919a6a7d10725ca1c", "message": "Provide idempotency support to handle duplicate maintenance events", "committedDate": "2020-12-03T22:18:15Z", "type": "commit"}, {"oid": "0ef70aeac1de5dfe78f8315221cb980686a46e6b", "url": "https://github.com/linkedin/cruise-control/commit/0ef70aeac1de5dfe78f8315221cb980686a46e6b", "message": "Address the feedback.", "committedDate": "2020-12-04T03:12:07Z", "type": "commit"}, {"oid": "0ef70aeac1de5dfe78f8315221cb980686a46e6b", "url": "https://github.com/linkedin/cruise-control/commit/0ef70aeac1de5dfe78f8315221cb980686a46e6b", "message": "Address the feedback.", "committedDate": "2020-12-04T03:12:07Z", "type": "forcePushed"}]}