{"pr_number": 1277, "pr_title": "Add config option for accurate CPU estimation on Kubernetes", "pr_createdAt": "2020-07-21T22:37:09Z", "pr_url": "https://github.com/linkedin/cruise-control/pull/1277", "timeline": [{"oid": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439", "url": "https://github.com/linkedin/cruise-control/commit/8a9b3fb47f4c1cbb98d57740ed33e04466ecd439", "message": "Add config option for accurate CPU estimation on Kubernetes\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-07-21T20:58:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA5ODUxNw==", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459098517", "bodyText": "Nits:\n(1) extra space before metrics,\n(2) missing dot at the end of doc, and\n(3) inconsistent indentation (i.e. starts with more than 4 spaces).", "author": "efeg", "createdAt": "2020-07-22T21:37:48Z", "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/CruiseControlMetricsReporterConfig.java", "diffHunk": "@@ -50,6 +50,9 @@\n   public static final String CRUISE_CONTROL_METRICS_REPORTER_BATCH_SIZE_CONFIG = PREFIX + \"batch.size\";\n   private static final String CRUISE_CONTROL_METRICS_REPORTER_BATCH_SIZE_DOC = \"The batch.size configuration of KafkaProducer used in Cruise \"\n       + \"Control metrics reporter. Set this config and cruise.control.metrics.reporter.linger.ms to a large number to have better batching.\";\n+  public static final String CRUISE_CONTROL_METRICS_REPORTER_KUBERNETES_MODE_CONFIG = PREFIX + \"kubernetes.mode\";\n+  public static final String CRUISE_CONTROL_METRICS_REPORTER_KUBERNETES_MODE_DOC = \"Cruise Control metrics reporter will report \" +\n+          \" metrics using methods that are aware of container boundaries\";", "originalCommit": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA5OTk2Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459099967", "bodyText": "Nit: Missing javadoc for kubernetesMode parameter.", "author": "efeg", "createdAt": "2020-07-22T21:40:43Z", "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/MetricsUtils.java", "diffHunk": "@@ -164,8 +163,14 @@ public static CruiseControlMetric toCruiseControlMetric(long now,\n    * @param brokerId Broker Id.\n    * @return the \"recent CPU usage\" for the JVM process as a double in [0.0,1.0].\n    */\n-  public static BrokerMetric getCpuMetric(long now, int brokerId) {\n+  public static BrokerMetric getCpuMetric(long now, int brokerId, boolean kubernetesMode) {", "originalCommit": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExNjk0Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459116943", "bodyText": "Did we avoid making the utils class final along with a private constructor and all static functions to be able to mock selected methods in ContainerMetricUtilsTest using EasyMock? If so, should we consider using the PowerMock to make this utils class cleaner?", "author": "efeg", "createdAt": "2020-07-22T22:21:49Z", "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public class ContainerMetricUtils {", "originalCommit": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExODEwMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459118101", "bodyText": "Nit: 2017 -> 2020", "author": "efeg", "createdAt": "2020-07-22T22:24:49Z", "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.", "originalCommit": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExODE1Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459118157", "bodyText": "Nit: 2017 -> 2020", "author": "efeg", "createdAt": "2020-07-22T22:24:55Z", "path": "cruise-control-metrics-reporter/src/test/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtilsTest.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.", "originalCommit": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNDA0Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459124042", "bodyText": "Does -1.0 indicate no quota? Can we move the hardcoded value to a static variable to make this clear?", "author": "efeg", "createdAt": "2020-07-22T22:41:06Z", "path": "cruise-control-metrics-reporter/src/test/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtilsTest.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import org.easymock.EasyMock;\n+import org.junit.Test;\n+\n+import static org.easymock.EasyMock.partialMockBuilder;\n+import static org.junit.Assert.assertEquals;\n+\n+public class ContainerMetricUtilsTest {\n+\n+    private static final double DELTA = 0.01;\n+\n+    private void mockGetContainerProcessCpuLoad(int processors, double cpuQuota, double cpuPeriod, double cpuUtil, double expectedLoad) {\n+        ContainerMetricUtils cmu = partialMockBuilder(ContainerMetricUtils.class)\n+                .addMockedMethod(\"getAvailableProcessors\")\n+                .addMockedMethod(\"getCpuPeriod\")\n+                .addMockedMethod(\"getCpuQuota\")\n+                .createMock();\n+\n+        EasyMock.expect(cmu.getAvailableProcessors()).andReturn(processors);\n+        EasyMock.expect(cmu.getCpuPeriod()).andReturn(cpuPeriod);\n+        EasyMock.expect(cmu.getCpuQuota()).andReturn(cpuQuota);\n+\n+        EasyMock.replay(cmu);\n+\n+        assertEquals(expectedLoad, cmu.getContainerProcessCpuLoad(cpuUtil), DELTA);\n+    }\n+\n+    @Test\n+    public void testGetContainerProcessCpuLoad() {\n+        /*\n+         *  expectedContainerProcessCpuLoad = (cpuUtil * processors) / (cpuQuota / cpuPeriod)\n+         */\n+        mockGetContainerProcessCpuLoad(1, 100000.0, 100000.0, 1.0, 1.0);\n+        mockGetContainerProcessCpuLoad(1, 100000.0, 100000.0, 0.5, 0.5);\n+        mockGetContainerProcessCpuLoad(1, 50000.0, 100000.0, 0.5, 1.0);\n+        mockGetContainerProcessCpuLoad(1, 75000.0, 100000.0, 0.5, 0.66);\n+\n+        mockGetContainerProcessCpuLoad(2, 100000.0, 100000.0, 0.5, 1.0);\n+        mockGetContainerProcessCpuLoad(2, 200000.0, 100000.0, 1.0, 1.0);\n+        mockGetContainerProcessCpuLoad(2, 25000.0, 100000.0, 0.125, 1.0);\n+        mockGetContainerProcessCpuLoad(2, 2500.0, 100000.0, 0.0125, 1.0);\n+\n+        mockGetContainerProcessCpuLoad(2, -1.0, 100000.0, 0.125, 0.125);", "originalCommit": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNzI2OA==", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459127268", "bodyText": "Nit: Can we move the hardcoded pathnames to static variables?", "author": "efeg", "createdAt": "2020-07-22T22:50:02Z", "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public class ContainerMetricUtils {\n+\n+    public double getCpuPeriod() {\n+        return Double.parseDouble(readFile(CgroupFiles.PERIOD_PATH.getValue()));\n+    }\n+\n+    public double getCpuQuota() {\n+        return Double.parseDouble(readFile(CgroupFiles.QUOTA_PATH.getValue()));\n+    }\n+\n+    /**\n+     * Gets the the number of logical cores available to the node.\n+     *\n+     * We can get this value while running in a container by using the \"nproc\" command.\n+     * Using other methods like OperatingSystemMXBean.getAvailableProcessors() and\n+     * Runtime.getRuntime().availableProcessors() would require disabling container\n+     * support (-XX:-UseContainerSupport) since these methods are aware of container\n+     * boundaries\n+     *\n+     * @return Number of logical processors on node\n+     */\n+    public int getAvailableProcessors() {\n+        int proc = 1;\n+        try {\n+            InputStream in = Runtime.getRuntime().exec(\"nproc\").getInputStream();\n+            proc = Integer.parseInt(readStringValue(in));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return proc;\n+    }\n+\n+    private static String readFile(String path) {\n+        String s = null;\n+        try {\n+            s = readStringValue(new FileInputStream(path));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return s;\n+    }\n+\n+    private static String readStringValue(InputStream in) {\n+        try {\n+            BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n+            String line;\n+            while ((line = br.readLine()) != null) {\n+                return line;\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get the \"recent CPU usage\" for the JVM process running inside of a container.\n+     *\n+     * At this time, the methods of OperatingSystemMXBean used for retrieving recent CPU usage are not\n+     * container aware and calculate CPU usage with respect to the physical host instead of the operating\n+     * environment from which they are called from. There have been efforts to make these methods container\n+     * aware but the changes have not been backported to Java versions less than version 14.\n+     *\n+     * Once these changes get backported, https://bugs.openjdk.java.net/browse/JDK-8226575, we can use\n+     * \"getSystemCpuLoad()\" for retrieving the CPU usage values when running in a container environment.\n+     *\n+     * @param cpuUtil The \"recent CPU usage\" for a JVM process with respect to node\n+     * @return the \"recent CPU usage\" for a JVM process with respect to operating environment\n+     *         as a double in [0.0,1.0].\n+     */\n+    public double getContainerProcessCpuLoad(double cpuUtil) {\n+        int logicalProcessorsOfNode = getAvailableProcessors();\n+        double cpuQuota = getCpuQuota();\n+        if (cpuQuota == -1) {\n+            /* A CPU quota value of -1 indicates that the cgroup does not adhere to any CPU time restrictions so we\n+             * will use the original container agnostic CPU usage value.\n+             */\n+            return cpuUtil;\n+        }\n+\n+        // Get the number of CPUs of a node that can be used by the operating environment\n+        double cpuLimit = (cpuQuota / getCpuPeriod());\n+\n+        // Get the minimal number of CPUs needed to achieve the reported CPU utilization\n+        double cpus = cpuUtil * logicalProcessorsOfNode;\n+\n+        /* Calculate the CPU utilization of a JVM process with respect to the operating environment.\n+         * Since the operating environment will only use the CPU resources allocated by CGroups,\n+         * it will always be that: cpuLimit >= cpus and the result is in the [0.0,1.0] interval.\n+         */\n+        return cpus / cpuLimit;\n+    }\n+\n+    public enum CgroupFiles {\n+\n+        QUOTA_PATH(\"/sys/fs/cgroup/cpu/cpu.cfs_quota_us\"),\n+        PERIOD_PATH(\"/sys/fs/cgroup/cpu/cpu.cfs_period_us\");", "originalCommit": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzNzQ4NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r461237485", "bodyText": "I was getting a DMI_HARDCODED_ABSOLUTE_FILENAME spotbugs error when I originally had these pathnames as static variables in the ContainerMetricsUtils class. I just added them back as static variables and referenced them from the CgroupFiles enum to avoid the DMI_HARDCODED_ABSOLUTE_FILENAME error. Let me know what you think!", "author": "kyguy", "createdAt": "2020-07-27T23:58:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNzI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNzk2OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459127969", "bodyText": "Can this value be final?", "author": "efeg", "createdAt": "2020-07-22T22:52:05Z", "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public class ContainerMetricUtils {\n+\n+    public double getCpuPeriod() {\n+        return Double.parseDouble(readFile(CgroupFiles.PERIOD_PATH.getValue()));\n+    }\n+\n+    public double getCpuQuota() {\n+        return Double.parseDouble(readFile(CgroupFiles.QUOTA_PATH.getValue()));\n+    }\n+\n+    /**\n+     * Gets the the number of logical cores available to the node.\n+     *\n+     * We can get this value while running in a container by using the \"nproc\" command.\n+     * Using other methods like OperatingSystemMXBean.getAvailableProcessors() and\n+     * Runtime.getRuntime().availableProcessors() would require disabling container\n+     * support (-XX:-UseContainerSupport) since these methods are aware of container\n+     * boundaries\n+     *\n+     * @return Number of logical processors on node\n+     */\n+    public int getAvailableProcessors() {\n+        int proc = 1;\n+        try {\n+            InputStream in = Runtime.getRuntime().exec(\"nproc\").getInputStream();\n+            proc = Integer.parseInt(readStringValue(in));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return proc;\n+    }\n+\n+    private static String readFile(String path) {\n+        String s = null;\n+        try {\n+            s = readStringValue(new FileInputStream(path));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return s;\n+    }\n+\n+    private static String readStringValue(InputStream in) {\n+        try {\n+            BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n+            String line;\n+            while ((line = br.readLine()) != null) {\n+                return line;\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get the \"recent CPU usage\" for the JVM process running inside of a container.\n+     *\n+     * At this time, the methods of OperatingSystemMXBean used for retrieving recent CPU usage are not\n+     * container aware and calculate CPU usage with respect to the physical host instead of the operating\n+     * environment from which they are called from. There have been efforts to make these methods container\n+     * aware but the changes have not been backported to Java versions less than version 14.\n+     *\n+     * Once these changes get backported, https://bugs.openjdk.java.net/browse/JDK-8226575, we can use\n+     * \"getSystemCpuLoad()\" for retrieving the CPU usage values when running in a container environment.\n+     *\n+     * @param cpuUtil The \"recent CPU usage\" for a JVM process with respect to node\n+     * @return the \"recent CPU usage\" for a JVM process with respect to operating environment\n+     *         as a double in [0.0,1.0].\n+     */\n+    public double getContainerProcessCpuLoad(double cpuUtil) {\n+        int logicalProcessorsOfNode = getAvailableProcessors();\n+        double cpuQuota = getCpuQuota();\n+        if (cpuQuota == -1) {\n+            /* A CPU quota value of -1 indicates that the cgroup does not adhere to any CPU time restrictions so we\n+             * will use the original container agnostic CPU usage value.\n+             */\n+            return cpuUtil;\n+        }\n+\n+        // Get the number of CPUs of a node that can be used by the operating environment\n+        double cpuLimit = (cpuQuota / getCpuPeriod());\n+\n+        // Get the minimal number of CPUs needed to achieve the reported CPU utilization\n+        double cpus = cpuUtil * logicalProcessorsOfNode;\n+\n+        /* Calculate the CPU utilization of a JVM process with respect to the operating environment.\n+         * Since the operating environment will only use the CPU resources allocated by CGroups,\n+         * it will always be that: cpuLimit >= cpus and the result is in the [0.0,1.0] interval.\n+         */\n+        return cpus / cpuLimit;\n+    }\n+\n+    public enum CgroupFiles {\n+\n+        QUOTA_PATH(\"/sys/fs/cgroup/cpu/cpu.cfs_quota_us\"),\n+        PERIOD_PATH(\"/sys/fs/cgroup/cpu/cpu.cfs_period_us\");\n+\n+        private String _value;", "originalCommit": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzMDE0NA==", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459130144", "bodyText": "Can we move nproc to a static variable?", "author": "efeg", "createdAt": "2020-07-22T22:58:13Z", "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public class ContainerMetricUtils {\n+\n+    public double getCpuPeriod() {\n+        return Double.parseDouble(readFile(CgroupFiles.PERIOD_PATH.getValue()));\n+    }\n+\n+    public double getCpuQuota() {\n+        return Double.parseDouble(readFile(CgroupFiles.QUOTA_PATH.getValue()));\n+    }\n+\n+    /**\n+     * Gets the the number of logical cores available to the node.\n+     *\n+     * We can get this value while running in a container by using the \"nproc\" command.\n+     * Using other methods like OperatingSystemMXBean.getAvailableProcessors() and\n+     * Runtime.getRuntime().availableProcessors() would require disabling container\n+     * support (-XX:-UseContainerSupport) since these methods are aware of container\n+     * boundaries\n+     *\n+     * @return Number of logical processors on node\n+     */\n+    public int getAvailableProcessors() {\n+        int proc = 1;\n+        try {\n+            InputStream in = Runtime.getRuntime().exec(\"nproc\").getInputStream();", "originalCommit": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNzY0NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459137645", "bodyText": "Do we need a while statement here -- i.e. does it ever loop?\nThis function seems to just return the first line from the given input stream. If the stream is empty, it returns null. Can we drop the loop and rename the function to reflect what it does?\n-- also is it ever acceptable for this function to return null? Should we handle the null case either at this function or in its returned context?", "author": "efeg", "createdAt": "2020-07-22T23:21:39Z", "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public class ContainerMetricUtils {\n+\n+    public double getCpuPeriod() {\n+        return Double.parseDouble(readFile(CgroupFiles.PERIOD_PATH.getValue()));\n+    }\n+\n+    public double getCpuQuota() {\n+        return Double.parseDouble(readFile(CgroupFiles.QUOTA_PATH.getValue()));\n+    }\n+\n+    /**\n+     * Gets the the number of logical cores available to the node.\n+     *\n+     * We can get this value while running in a container by using the \"nproc\" command.\n+     * Using other methods like OperatingSystemMXBean.getAvailableProcessors() and\n+     * Runtime.getRuntime().availableProcessors() would require disabling container\n+     * support (-XX:-UseContainerSupport) since these methods are aware of container\n+     * boundaries\n+     *\n+     * @return Number of logical processors on node\n+     */\n+    public int getAvailableProcessors() {\n+        int proc = 1;\n+        try {\n+            InputStream in = Runtime.getRuntime().exec(\"nproc\").getInputStream();\n+            proc = Integer.parseInt(readStringValue(in));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return proc;\n+    }\n+\n+    private static String readFile(String path) {\n+        String s = null;\n+        try {\n+            s = readStringValue(new FileInputStream(path));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return s;\n+    }\n+\n+    private static String readStringValue(InputStream in) {\n+        try {\n+            BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n+            String line;\n+            while ((line = br.readLine()) != null) {", "originalCommit": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzNjU5MA==", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r461236590", "bodyText": "This function seems to just return the first line from the given input stream. If the stream is empty, it returns null. Can we drop the loop and rename the function to reflect what it does?\n\nYou are right, we don't need the while statement here,  I updated the function to just read the first line of the stream and renamed the function.\n\n-- also is it ever acceptable for this function to return null? Should we handle the null case either at this function or in its returned context?\n\nNo it is not, we should definitely handle the null case! Just added a null check in case the InputStream is empty/null.\nLet me know what you think!", "author": "kyguy", "createdAt": "2020-07-27T23:56:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNzY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzOTE1MA==", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459139150", "bodyText": "Can we update Configurations.md to document these new configs?", "author": "efeg", "createdAt": "2020-07-22T23:26:29Z", "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/CruiseControlMetricsReporterConfig.java", "diffHunk": "@@ -50,6 +50,9 @@\n   public static final String CRUISE_CONTROL_METRICS_REPORTER_BATCH_SIZE_CONFIG = PREFIX + \"batch.size\";\n   private static final String CRUISE_CONTROL_METRICS_REPORTER_BATCH_SIZE_DOC = \"The batch.size configuration of KafkaProducer used in Cruise \"\n       + \"Control metrics reporter. Set this config and cruise.control.metrics.reporter.linger.ms to a large number to have better batching.\";\n+  public static final String CRUISE_CONTROL_METRICS_REPORTER_KUBERNETES_MODE_CONFIG = PREFIX + \"kubernetes.mode\";\n+  public static final String CRUISE_CONTROL_METRICS_REPORTER_KUBERNETES_MODE_DOC = \"Cruise Control metrics reporter will report \" +\n+          \" metrics using methods that are aware of container boundaries\";", "originalCommit": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0MDQ4MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459140481", "bodyText": "Can we move the hardcoded -1 to a static variable (and also move the documentation to there)?", "author": "efeg", "createdAt": "2020-07-22T23:30:38Z", "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public class ContainerMetricUtils {\n+\n+    public double getCpuPeriod() {\n+        return Double.parseDouble(readFile(CgroupFiles.PERIOD_PATH.getValue()));\n+    }\n+\n+    public double getCpuQuota() {\n+        return Double.parseDouble(readFile(CgroupFiles.QUOTA_PATH.getValue()));\n+    }\n+\n+    /**\n+     * Gets the the number of logical cores available to the node.\n+     *\n+     * We can get this value while running in a container by using the \"nproc\" command.\n+     * Using other methods like OperatingSystemMXBean.getAvailableProcessors() and\n+     * Runtime.getRuntime().availableProcessors() would require disabling container\n+     * support (-XX:-UseContainerSupport) since these methods are aware of container\n+     * boundaries\n+     *\n+     * @return Number of logical processors on node\n+     */\n+    public int getAvailableProcessors() {\n+        int proc = 1;\n+        try {\n+            InputStream in = Runtime.getRuntime().exec(\"nproc\").getInputStream();\n+            proc = Integer.parseInt(readStringValue(in));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return proc;\n+    }\n+\n+    private static String readFile(String path) {\n+        String s = null;\n+        try {\n+            s = readStringValue(new FileInputStream(path));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return s;\n+    }\n+\n+    private static String readStringValue(InputStream in) {\n+        try {\n+            BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n+            String line;\n+            while ((line = br.readLine()) != null) {\n+                return line;\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get the \"recent CPU usage\" for the JVM process running inside of a container.\n+     *\n+     * At this time, the methods of OperatingSystemMXBean used for retrieving recent CPU usage are not\n+     * container aware and calculate CPU usage with respect to the physical host instead of the operating\n+     * environment from which they are called from. There have been efforts to make these methods container\n+     * aware but the changes have not been backported to Java versions less than version 14.\n+     *\n+     * Once these changes get backported, https://bugs.openjdk.java.net/browse/JDK-8226575, we can use\n+     * \"getSystemCpuLoad()\" for retrieving the CPU usage values when running in a container environment.\n+     *\n+     * @param cpuUtil The \"recent CPU usage\" for a JVM process with respect to node\n+     * @return the \"recent CPU usage\" for a JVM process with respect to operating environment\n+     *         as a double in [0.0,1.0].\n+     */\n+    public double getContainerProcessCpuLoad(double cpuUtil) {\n+        int logicalProcessorsOfNode = getAvailableProcessors();\n+        double cpuQuota = getCpuQuota();\n+        if (cpuQuota == -1) {\n+            /* A CPU quota value of -1 indicates that the cgroup does not adhere to any CPU time restrictions so we\n+             * will use the original container agnostic CPU usage value.\n+             */", "originalCommit": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0MDgzNg==", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459140836", "bodyText": "Nit: redundant parentheses.", "author": "efeg", "createdAt": "2020-07-22T23:31:51Z", "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public class ContainerMetricUtils {\n+\n+    public double getCpuPeriod() {\n+        return Double.parseDouble(readFile(CgroupFiles.PERIOD_PATH.getValue()));\n+    }\n+\n+    public double getCpuQuota() {\n+        return Double.parseDouble(readFile(CgroupFiles.QUOTA_PATH.getValue()));\n+    }\n+\n+    /**\n+     * Gets the the number of logical cores available to the node.\n+     *\n+     * We can get this value while running in a container by using the \"nproc\" command.\n+     * Using other methods like OperatingSystemMXBean.getAvailableProcessors() and\n+     * Runtime.getRuntime().availableProcessors() would require disabling container\n+     * support (-XX:-UseContainerSupport) since these methods are aware of container\n+     * boundaries\n+     *\n+     * @return Number of logical processors on node\n+     */\n+    public int getAvailableProcessors() {\n+        int proc = 1;\n+        try {\n+            InputStream in = Runtime.getRuntime().exec(\"nproc\").getInputStream();\n+            proc = Integer.parseInt(readStringValue(in));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return proc;\n+    }\n+\n+    private static String readFile(String path) {\n+        String s = null;\n+        try {\n+            s = readStringValue(new FileInputStream(path));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return s;\n+    }\n+\n+    private static String readStringValue(InputStream in) {\n+        try {\n+            BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n+            String line;\n+            while ((line = br.readLine()) != null) {\n+                return line;\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get the \"recent CPU usage\" for the JVM process running inside of a container.\n+     *\n+     * At this time, the methods of OperatingSystemMXBean used for retrieving recent CPU usage are not\n+     * container aware and calculate CPU usage with respect to the physical host instead of the operating\n+     * environment from which they are called from. There have been efforts to make these methods container\n+     * aware but the changes have not been backported to Java versions less than version 14.\n+     *\n+     * Once these changes get backported, https://bugs.openjdk.java.net/browse/JDK-8226575, we can use\n+     * \"getSystemCpuLoad()\" for retrieving the CPU usage values when running in a container environment.\n+     *\n+     * @param cpuUtil The \"recent CPU usage\" for a JVM process with respect to node\n+     * @return the \"recent CPU usage\" for a JVM process with respect to operating environment\n+     *         as a double in [0.0,1.0].\n+     */\n+    public double getContainerProcessCpuLoad(double cpuUtil) {\n+        int logicalProcessorsOfNode = getAvailableProcessors();\n+        double cpuQuota = getCpuQuota();\n+        if (cpuQuota == -1) {\n+            /* A CPU quota value of -1 indicates that the cgroup does not adhere to any CPU time restrictions so we\n+             * will use the original container agnostic CPU usage value.\n+             */\n+            return cpuUtil;\n+        }\n+\n+        // Get the number of CPUs of a node that can be used by the operating environment\n+        double cpuLimit = (cpuQuota / getCpuPeriod());", "originalCommit": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0MTEyNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459141125", "bodyText": "Should we handle if getCpuPeriod() returns 0?", "author": "efeg", "createdAt": "2020-07-22T23:32:53Z", "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public class ContainerMetricUtils {\n+\n+    public double getCpuPeriod() {\n+        return Double.parseDouble(readFile(CgroupFiles.PERIOD_PATH.getValue()));\n+    }\n+\n+    public double getCpuQuota() {\n+        return Double.parseDouble(readFile(CgroupFiles.QUOTA_PATH.getValue()));\n+    }\n+\n+    /**\n+     * Gets the the number of logical cores available to the node.\n+     *\n+     * We can get this value while running in a container by using the \"nproc\" command.\n+     * Using other methods like OperatingSystemMXBean.getAvailableProcessors() and\n+     * Runtime.getRuntime().availableProcessors() would require disabling container\n+     * support (-XX:-UseContainerSupport) since these methods are aware of container\n+     * boundaries\n+     *\n+     * @return Number of logical processors on node\n+     */\n+    public int getAvailableProcessors() {\n+        int proc = 1;\n+        try {\n+            InputStream in = Runtime.getRuntime().exec(\"nproc\").getInputStream();\n+            proc = Integer.parseInt(readStringValue(in));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return proc;\n+    }\n+\n+    private static String readFile(String path) {\n+        String s = null;\n+        try {\n+            s = readStringValue(new FileInputStream(path));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return s;\n+    }\n+\n+    private static String readStringValue(InputStream in) {\n+        try {\n+            BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n+            String line;\n+            while ((line = br.readLine()) != null) {\n+                return line;\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get the \"recent CPU usage\" for the JVM process running inside of a container.\n+     *\n+     * At this time, the methods of OperatingSystemMXBean used for retrieving recent CPU usage are not\n+     * container aware and calculate CPU usage with respect to the physical host instead of the operating\n+     * environment from which they are called from. There have been efforts to make these methods container\n+     * aware but the changes have not been backported to Java versions less than version 14.\n+     *\n+     * Once these changes get backported, https://bugs.openjdk.java.net/browse/JDK-8226575, we can use\n+     * \"getSystemCpuLoad()\" for retrieving the CPU usage values when running in a container environment.\n+     *\n+     * @param cpuUtil The \"recent CPU usage\" for a JVM process with respect to node\n+     * @return the \"recent CPU usage\" for a JVM process with respect to operating environment\n+     *         as a double in [0.0,1.0].\n+     */\n+    public double getContainerProcessCpuLoad(double cpuUtil) {\n+        int logicalProcessorsOfNode = getAvailableProcessors();\n+        double cpuQuota = getCpuQuota();\n+        if (cpuQuota == -1) {\n+            /* A CPU quota value of -1 indicates that the cgroup does not adhere to any CPU time restrictions so we\n+             * will use the original container agnostic CPU usage value.\n+             */\n+            return cpuUtil;\n+        }\n+\n+        // Get the number of CPUs of a node that can be used by the operating environment\n+        double cpuLimit = (cpuQuota / getCpuPeriod());", "originalCommit": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0MzgxMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r461243811", "bodyText": "The cgroupds file, \"/sys/fs/cgroup/cpu/cpu.cfs_period_us\", where is this value is read from has an enforced lowerbound of 1000 so we shouldn't need to. I have just added documentation to the method to  clarify this. Let me know what you think!", "author": "kyguy", "createdAt": "2020-07-28T00:19:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0MTEyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0MTQ0Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459141442", "bodyText": "Should we handle getCpuQuota() being 0?", "author": "efeg", "createdAt": "2020-07-22T23:33:58Z", "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public class ContainerMetricUtils {\n+\n+    public double getCpuPeriod() {\n+        return Double.parseDouble(readFile(CgroupFiles.PERIOD_PATH.getValue()));\n+    }\n+\n+    public double getCpuQuota() {\n+        return Double.parseDouble(readFile(CgroupFiles.QUOTA_PATH.getValue()));\n+    }\n+\n+    /**\n+     * Gets the the number of logical cores available to the node.\n+     *\n+     * We can get this value while running in a container by using the \"nproc\" command.\n+     * Using other methods like OperatingSystemMXBean.getAvailableProcessors() and\n+     * Runtime.getRuntime().availableProcessors() would require disabling container\n+     * support (-XX:-UseContainerSupport) since these methods are aware of container\n+     * boundaries\n+     *\n+     * @return Number of logical processors on node\n+     */\n+    public int getAvailableProcessors() {\n+        int proc = 1;\n+        try {\n+            InputStream in = Runtime.getRuntime().exec(\"nproc\").getInputStream();\n+            proc = Integer.parseInt(readStringValue(in));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return proc;\n+    }\n+\n+    private static String readFile(String path) {\n+        String s = null;\n+        try {\n+            s = readStringValue(new FileInputStream(path));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return s;\n+    }\n+\n+    private static String readStringValue(InputStream in) {\n+        try {\n+            BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n+            String line;\n+            while ((line = br.readLine()) != null) {\n+                return line;\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get the \"recent CPU usage\" for the JVM process running inside of a container.\n+     *\n+     * At this time, the methods of OperatingSystemMXBean used for retrieving recent CPU usage are not\n+     * container aware and calculate CPU usage with respect to the physical host instead of the operating\n+     * environment from which they are called from. There have been efforts to make these methods container\n+     * aware but the changes have not been backported to Java versions less than version 14.\n+     *\n+     * Once these changes get backported, https://bugs.openjdk.java.net/browse/JDK-8226575, we can use\n+     * \"getSystemCpuLoad()\" for retrieving the CPU usage values when running in a container environment.\n+     *\n+     * @param cpuUtil The \"recent CPU usage\" for a JVM process with respect to node\n+     * @return the \"recent CPU usage\" for a JVM process with respect to operating environment\n+     *         as a double in [0.0,1.0].\n+     */\n+    public double getContainerProcessCpuLoad(double cpuUtil) {\n+        int logicalProcessorsOfNode = getAvailableProcessors();\n+        double cpuQuota = getCpuQuota();", "originalCommit": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0Mzk1Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r461243953", "bodyText": "The cgroupds file, \"/sys/fs/cgroup/cpu/cpu.cfs_quota_us\", where is this value is read from has an enforced lowerbound of 1000 so we shouldn't need to. I have just added documentation to the method to  clarify this. Let me know what you think!", "author": "kyguy", "createdAt": "2020-07-28T00:19:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0MTQ0Mg=="}], "type": "inlineReview"}, {"oid": "9a23ccc73abbc743603c65c621857a1346d5dd9b", "url": "https://github.com/linkedin/cruise-control/commit/9a23ccc73abbc743603c65c621857a1346d5dd9b", "message": "Addressing comments\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-07-27T23:24:11Z", "type": "commit"}, {"oid": "c1d4274c8eec99443539595bc22808f6d5720910", "url": "https://github.com/linkedin/cruise-control/commit/c1d4274c8eec99443539595bc22808f6d5720910", "message": "Fix indentation to from 4 to 2 spaces for consistency with project\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-07-27T23:32:40Z", "type": "commit"}, {"oid": "f29e3d682eadf34e8c90afeff74f41a1d9d049b1", "url": "https://github.com/linkedin/cruise-control/commit/f29e3d682eadf34e8c90afeff74f41a1d9d049b1", "message": "Remove extra lines added to build.gradle file\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-07-27T23:35:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI3MTIyNg==", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r461271226", "bodyText": "Nit: Redundant semicolon.", "author": "efeg", "createdAt": "2020-07-28T01:56:45Z", "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public final class ContainerMetricUtils {\n+  // Paths used to get cgroup information\n+  private static final String QUOTA_PATH = \"/sys/fs/cgroup/cpu/cpu.cfs_quota_us\";\n+  private static final String PERIOD_PATH = \"/sys/fs/cgroup/cpu/cpu.cfs_period_us\";\n+  // Unix command to execute inside a Linux container to get the number of logical processors available to the node\n+  private static final String NPROC = \"nproc\";\n+  // A CPU quota value of -1 indicates that the cgroup does not adhere to any CPU time restrictions\n+  public static final int NO_CPU_QUOTA = -1;\n+\n+  private ContainerMetricUtils() { };", "originalCommit": "f29e3d682eadf34e8c90afeff74f41a1d9d049b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI3MTg5NA==", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r461271894", "bodyText": "If the stream is empty (or similarly if there is an IOException), the function prints the relevant stack trace and returns a null. This later causes exceptions such as a NullPointerException (e.g. https://github.com/linkedin/cruise-control/pull/1277/files#diff-9c19ccfff1709f545e3cf0352470a21bR42) and NumberFormatException (see https://github.com/linkedin/cruise-control/pull/1277/files#diff-9c19ccfff1709f545e3cf0352470a21bR60). If any of these unexpected conditions occur, presumably, they indicate a broken/unexpected environment setup. In those cases, I wonder if just throwing the relevant exceptions would suffice? We know that eventually, all such exceptions are going to be handled/caught by https://github.com/linkedin/cruise-control/pull/1277/files#diff-8f6babccb3903b0056ad0c2c2e6d7adeR284.", "author": "efeg", "createdAt": "2020-07-28T01:59:19Z", "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public final class ContainerMetricUtils {\n+  // Paths used to get cgroup information\n+  private static final String QUOTA_PATH = \"/sys/fs/cgroup/cpu/cpu.cfs_quota_us\";\n+  private static final String PERIOD_PATH = \"/sys/fs/cgroup/cpu/cpu.cfs_period_us\";\n+  // Unix command to execute inside a Linux container to get the number of logical processors available to the node\n+  private static final String NPROC = \"nproc\";\n+  // A CPU quota value of -1 indicates that the cgroup does not adhere to any CPU time restrictions\n+  public static final int NO_CPU_QUOTA = -1;\n+\n+  private ContainerMetricUtils() { };\n+\n+  /**\n+   * Reads Cgroups CPU period from Cgroups file. Value has a lowerbound of 1 millisecond and  an upperbound of 1 second\n+   * according to https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt\n+   *\n+   * @return Cgroups CPU period in microseconds as a double.\n+   */\n+  private static double getCpuPeriod() {\n+    return Double.parseDouble(readFile(CgroupFiles.PERIOD_PATH.getValue()));\n+  }\n+\n+  /**\n+   * Reads Cgroups CPU quota from Cgroups file. The value has lowerbound of 1 millisecond\n+   * according to https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt\n+   *\n+   * @return Cgroups CPU quota in microseconds as a double.\n+   */\n+  private static double getCpuQuota() {\n+    return Double.parseDouble(readFile(CgroupFiles.QUOTA_PATH.getValue()));\n+  }\n+\n+  /**\n+   * Gets the the number of logical cores available to the node.\n+   * <p>\n+   * We can get this value while running in a container by using the \"nproc\" command.\n+   * Using other methods like OperatingSystemMXBean.getAvailableProcessors() and\n+   * Runtime.getRuntime().availableProcessors() would require disabling container\n+   * support (-XX:-UseContainerSupport) since these methods are aware of container\n+   * boundaries\n+   *\n+   * @return Number of logical processors on node\n+   */\n+  private static int getAvailableProcessors() {\n+    int proc = 1;\n+    try {\n+      InputStream in = Runtime.getRuntime().exec(NPROC).getInputStream();\n+      proc = Integer.parseInt(readInputStream(in));\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+    }\n+    return proc;\n+  }\n+\n+  private static String readFile(String path) {\n+    try {\n+      return readInputStream(new FileInputStream(path));\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+    }\n+    return null;\n+  }\n+\n+  private static String readInputStream(InputStream in) {\n+    try {\n+      BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n+      String stream = br.readLine();\n+      if (stream != null) {\n+        return stream;\n+      } else {\n+        throw new EmptyInputStreamException(\"Nothing was read from stream \" + in);\n+      }\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+    } catch (EmptyInputStreamException e) {\n+      e.printStackTrace();\n+    }", "originalCommit": "f29e3d682eadf34e8c90afeff74f41a1d9d049b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5ODExNA==", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r461898114", "bodyText": "You are right, I think that would make a lot more sense too. I just updated all of the functions to throw the relevant exceptions so that they propagate to the CruiseControlMetricReporter class. If any of the methods fail to get the underlying host information, whether it be the cgroup information or processor count, the calculated load would be inaccurate. This way, appropriate error exceptions will be thrown. Let me know what you think!", "author": "kyguy", "createdAt": "2020-07-28T21:42:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI3MTg5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI4MzI4Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r461283287", "bodyText": "Should we avoid introducing a new exception type by throwing an IllegalArgumentException here?", "author": "efeg", "createdAt": "2020-07-28T02:40:48Z", "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public final class ContainerMetricUtils {\n+  // Paths used to get cgroup information\n+  private static final String QUOTA_PATH = \"/sys/fs/cgroup/cpu/cpu.cfs_quota_us\";\n+  private static final String PERIOD_PATH = \"/sys/fs/cgroup/cpu/cpu.cfs_period_us\";\n+  // Unix command to execute inside a Linux container to get the number of logical processors available to the node\n+  private static final String NPROC = \"nproc\";\n+  // A CPU quota value of -1 indicates that the cgroup does not adhere to any CPU time restrictions\n+  public static final int NO_CPU_QUOTA = -1;\n+\n+  private ContainerMetricUtils() { };\n+\n+  /**\n+   * Reads Cgroups CPU period from Cgroups file. Value has a lowerbound of 1 millisecond and  an upperbound of 1 second\n+   * according to https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt\n+   *\n+   * @return Cgroups CPU period in microseconds as a double.\n+   */\n+  private static double getCpuPeriod() {\n+    return Double.parseDouble(readFile(CgroupFiles.PERIOD_PATH.getValue()));\n+  }\n+\n+  /**\n+   * Reads Cgroups CPU quota from Cgroups file. The value has lowerbound of 1 millisecond\n+   * according to https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt\n+   *\n+   * @return Cgroups CPU quota in microseconds as a double.\n+   */\n+  private static double getCpuQuota() {\n+    return Double.parseDouble(readFile(CgroupFiles.QUOTA_PATH.getValue()));\n+  }\n+\n+  /**\n+   * Gets the the number of logical cores available to the node.\n+   * <p>\n+   * We can get this value while running in a container by using the \"nproc\" command.\n+   * Using other methods like OperatingSystemMXBean.getAvailableProcessors() and\n+   * Runtime.getRuntime().availableProcessors() would require disabling container\n+   * support (-XX:-UseContainerSupport) since these methods are aware of container\n+   * boundaries\n+   *\n+   * @return Number of logical processors on node\n+   */\n+  private static int getAvailableProcessors() {\n+    int proc = 1;\n+    try {\n+      InputStream in = Runtime.getRuntime().exec(NPROC).getInputStream();\n+      proc = Integer.parseInt(readInputStream(in));\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+    }\n+    return proc;\n+  }\n+\n+  private static String readFile(String path) {\n+    try {\n+      return readInputStream(new FileInputStream(path));\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+    }\n+    return null;\n+  }\n+\n+  private static String readInputStream(InputStream in) {\n+    try {\n+      BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n+      String stream = br.readLine();\n+      if (stream != null) {\n+        return stream;\n+      } else {\n+        throw new EmptyInputStreamException(\"Nothing was read from stream \" + in);", "originalCommit": "f29e3d682eadf34e8c90afeff74f41a1d9d049b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d91096e34b6ff7c647007b9a98e1036b778aab88", "url": "https://github.com/linkedin/cruise-control/commit/d91096e34b6ff7c647007b9a98e1036b778aab88", "message": "Fix typos and exception handling\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>", "committedDate": "2020-07-28T21:29:06Z", "type": "commit"}]}