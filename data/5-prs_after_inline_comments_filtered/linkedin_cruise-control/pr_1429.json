{"pr_number": 1429, "pr_title": "Add a new hard goal that ensures that each alive broker has a leader replica from a configured pool of topics", "pr_createdAt": "2020-12-23T04:49:13Z", "pr_url": "https://github.com/linkedin/cruise-control/pull/1429", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI3MDkwOA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548270908", "bodyText": "cruise-control-code module contains the system agnostic logic of Cruise Control. However, this utility function is about Kafka topics -- i.e. it is system-specific.\nCan we move this to the relevant utility class under cruise-control module?", "author": "efeg", "createdAt": "2020-12-23T21:52:15Z", "path": "cruise-control-core/src/main/java/com/linkedin/cruisecontrol/common/utils/Utils.java", "diffHunk": "@@ -115,4 +118,17 @@ public static ClassLoader getCruiseControlClassLoader() {\n     }\n     return obj;\n   }\n+\n+  /**\n+   * Get topic names that match with a given topic naming pattern\n+   * @param topicNamePattern target topic naming pattern\n+   * @param topicNames all topic names\n+   * @return topic names\n+   */\n+  public static Set<String> getTopicNamesMatchedWithPattern(Pattern topicNamePattern, Set<String> topicNames) {\n+    return topicNames\n+        .stream()\n+        .filter(topicName -> topicNamePattern.matcher(topicName).matches())\n+        .collect(Collectors.toSet());\n+  }", "originalCommit": "63addab0bdf02806bf04f5935641ce9359e9b1fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI3NTY0MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548275641", "bodyText": "minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker is relevant to a single hard goal.\nWhereas OptimizationOptions intends to contain common options applicable to the overall optimization process.\n\nCan we refrain from making changes in the optimization options and instead modify BalancingConstraint to add the relevant constraints?\nGoing forward (not on this PR), we can create an interface for BalancingConstraint, and enable users to implement this interface to address the needs for their custom goals.", "author": "efeg", "createdAt": "2020-12-23T21:59:06Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/DefaultOptimizationOptionsGenerator.java", "diffHunk": "@@ -17,22 +17,30 @@\n   public OptimizationOptions optimizationOptionsForGoalViolationDetection(ClusterModel clusterModel,\n                                                                           Set<String> excludedTopics,\n                                                                           Set<Integer> excludedBrokersForLeadership,\n-                                                                          Set<Integer> excludedBrokersForReplicaMove) {\n+                                                                          Set<Integer> excludedBrokersForReplicaMove,\n+                                                                          Set<String> mustHaveLeaderReplicaPerBrokerTopics,\n+                                                                          int minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker) {\n     return new OptimizationOptions(excludedTopics,\n                                    excludedBrokersForLeadership,\n                                    excludedBrokersForReplicaMove,\n-                                   true);\n+                                   true,\n+                                   mustHaveLeaderReplicaPerBrokerTopics,\n+                                   minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker);\n   }\n \n   @Override\n   public OptimizationOptions optimizationOptionsForCachedProposalCalculation(ClusterModel clusterModel,\n-                                                                             Set<String> excludedTopics) {\n+                                                                             Set<String> excludedTopics,\n+                                                                             Set<String> mustHaveLeaderReplicaPerBrokerTopics,\n+                                                                             int minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker) {\n     return new OptimizationOptions(excludedTopics,\n                                    Collections.emptySet(),\n                                    Collections.emptySet(),\n                                    false,\n                                    Collections.emptySet(),\n-                                   false);\n+                                   false,\n+                                   mustHaveLeaderReplicaPerBrokerTopics,\n+                                   minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker);", "originalCommit": "63addab0bdf02806bf04f5935641ce9359e9b1fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM4NjM4OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548386389", "bodyText": "Created an issue to keep track of your second point.", "author": "Lincong", "createdAt": "2020-12-24T05:18:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI3NTY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQyMTkxMg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548421912", "bodyText": "Moved these two variables to BalancingConstraint. Btw, initially, I put them in BalancingConstraint and you told me to put it somewhere else during an offline discussion. So, I decided to put them in OptimizationOptions since there is no other suitable place. But anyway, I agree that putting them in BalancingConstraint is better.", "author": "Lincong", "createdAt": "2020-12-24T07:02:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI3NTY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI4ODE0NA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548288144", "bodyText": "If we refrain from making changes in the optimization options and instead modify BalancingConstraint to add the relevant constraints, we can drop these new variables.", "author": "efeg", "createdAt": "2020-12-23T22:17:17Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/GoalOptimizer.java", "diffHunk": "@@ -64,6 +64,8 @@\n   private final List<Goal> _goalsByPriority;\n   private final BalancingConstraint _balancingConstraint;\n   private final Pattern _defaultExcludedTopics;\n+  private final Pattern _mustHaveLeaderReplicaPerBrokerTopicsPattern;\n+  private final int _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker;", "originalCommit": "63addab0bdf02806bf04f5935641ce9359e9b1fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI5Njc5MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548296791", "bodyText": "This should be a regex -- i.e. not a list (?) of topic names, because cluster operators may not always know the exact topic names, but they may know the prefix, suffix, or other relevant generic naming schemes about relevant topics. In such cases, regex provides more flexibility -- please see TOPICS_EXCLUDED_FROM_PARTITION_MOVEMENT_CONFIG for example use.", "author": "efeg", "createdAt": "2020-12-23T22:29:09Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnalyzerConfig.java", "diffHunk": "@@ -334,6 +338,23 @@ private AnalyzerConfig() {\n   public static final String ALLOW_CAPACITY_ESTIMATION_ON_PROPOSAL_PRECOMPUTE_DOC = \"The flag to indicate whether to \"\n       + \"allow capacity estimation on proposal precomputation.\";\n \n+  /**\n+   * <code>topics.must.have.leader.replica.per.broker</code>\n+   */\n+  public static final String TOPICS_MUST_HAVE_LEADER_REPLICA_PER_BROKER_CONFIG = \"topics.must.have.leader.replica.per.broker\";\n+  public static final String DEFAULT_TOPICS_MUST_HAVE_LEADER_REPLICA_PER_BROKER = \"\";\n+  public static final String TOPICS_MUST_HAVE_LEADER_REPLICA_PER_BROKER_DOC = \"The topics that must have some number of \"\n+      + \"replica per broker. It is a comma-separated list of topic names.\";", "originalCommit": "63addab0bdf02806bf04f5935641ce9359e9b1fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM3NTQ3NA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548375474", "bodyText": "Got it. Thanks!", "author": "Lincong", "createdAt": "2020-12-24T04:19:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI5Njc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMwMjgyMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548302821", "bodyText": "For conciseness and consistency between relevant configs, can we use\n\ntopics.must.have.leader.replica.per.broker -> topics.with.min.leaders.per.broker\nmin.leader.replica.count.per.broker.for.topics.must.have.leader.replica.per.broker -> min.topic.leaders.per.broker (the documentation of this config can explain that this config is applicable to the topics specified by the topics.with.min.leaders.per.broker config)", "author": "efeg", "createdAt": "2020-12-23T22:38:02Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnalyzerConfig.java", "diffHunk": "@@ -334,6 +338,23 @@ private AnalyzerConfig() {\n   public static final String ALLOW_CAPACITY_ESTIMATION_ON_PROPOSAL_PRECOMPUTE_DOC = \"The flag to indicate whether to \"\n       + \"allow capacity estimation on proposal precomputation.\";\n \n+  /**\n+   * <code>topics.must.have.leader.replica.per.broker</code>\n+   */\n+  public static final String TOPICS_MUST_HAVE_LEADER_REPLICA_PER_BROKER_CONFIG = \"topics.must.have.leader.replica.per.broker\";\n+  public static final String DEFAULT_TOPICS_MUST_HAVE_LEADER_REPLICA_PER_BROKER = \"\";\n+  public static final String TOPICS_MUST_HAVE_LEADER_REPLICA_PER_BROKER_DOC = \"The topics that must have some number of \"\n+      + \"replica per broker. It is a comma-separated list of topic names.\";\n+\n+  /**\n+   * <code>min.leader.replica.count.per.broker.for.topics.must.have.leader.replica.per.broker</code>\n+   */\n+  public static final String MIN_LEADER_REPLICA_COUNT_PER_BROKER_FOR_TOPICS_MUST_HAVE_LEADER_REPLICA_PER_BROKER_CONFIG =\n+      \"min.leader.replica.count.per.broker.for.topics.must.have.leader.replica.per.broker\";", "originalCommit": "63addab0bdf02806bf04f5935641ce9359e9b1fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMwNDMwMA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548304300", "bodyText": "Would renaming this goal as follows make its purpose more clear?:\n\nLeaderReplicaPerLiveBrokerGoal -> MinTopicLeadersPerBrokerGoal?", "author": "efeg", "createdAt": "2020-12-23T22:40:29Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/LeaderReplicaPerLiveBrokerGoal.java", "diffHunk": "@@ -0,0 +1,511 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ *\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.*;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker has\n+ * at least a certain number of leader replica of each topic in a configured set of topics\n+ */\n+public class LeaderReplicaPerLiveBrokerGoal extends AbstractGoal {", "originalCommit": "63addab0bdf02806bf04f5935641ce9359e9b1fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM3MzMzOQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548373339", "bodyText": "Good name", "author": "Lincong", "createdAt": "2020-12-24T04:07:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMwNDMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMwNTE2Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548305167", "bodyText": "Can we ensure that this JavaDoc explains how it uses the two new AnalyzerConfigs?\n\"... ensure that each alive broker has ...\" -> Does this goal omit brokers excluded for replica moves or not (it should)?", "author": "efeg", "createdAt": "2020-12-23T22:44:12Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/LeaderReplicaPerLiveBrokerGoal.java", "diffHunk": "@@ -0,0 +1,511 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ *\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.*;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker has\n+ * at least a certain number of leader replica of each topic in a configured set of topics\n+ */", "originalCommit": "63addab0bdf02806bf04f5935641ce9359e9b1fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMwNjE3Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548306177", "bodyText": "Please see earlier comment on moving these variables to BalancingConstraint.", "author": "efeg", "createdAt": "2020-12-23T22:47:04Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/OptimizationOptions.java", "diffHunk": "@@ -15,6 +15,8 @@\n  */\n public class OptimizationOptions {\n   private final Set<String> _excludedTopics;\n+  private final Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+  private final int _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker;", "originalCommit": "63addab0bdf02806bf04f5935641ce9359e9b1fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMwNjI3Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548306272", "bodyText": "Please see earlier comment on moving these variables to BalancingConstraint.", "author": "efeg", "createdAt": "2020-12-23T22:47:38Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/OptimizationOptionsGenerator.java", "diffHunk": "@@ -44,6 +46,8 @@ OptimizationOptions optimizationOptionsForGoalViolationDetection(ClusterModel cl\n    * @throws KafkaCruiseControlException If anything goes wrong.\n    */\n   OptimizationOptions optimizationOptionsForCachedProposalCalculation(ClusterModel clusterModel,\n-                                                                      Set<String> excludedTopics)\n+                                                                      Set<String> excludedTopics,\n+                                                                      Set<String> mustHaveLeaderReplicaPerBrokerTopics,\n+                                                                      int minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker)", "originalCommit": "63addab0bdf02806bf04f5935641ce9359e9b1fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMwNjk1Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548306952", "bodyText": "Incorrect statement: Package private for unit test.", "author": "efeg", "createdAt": "2020-12-23T22:50:54Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/LeaderReplicaPerLiveBrokerGoal.java", "diffHunk": "@@ -0,0 +1,511 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ *\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.*;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker has\n+ * at least a certain number of leader replica of each topic in a configured set of topics\n+ */\n+public class LeaderReplicaPerLiveBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(LeaderReplicaPerLiveBrokerGoal.class);\n+\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+  private int _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker;\n+\n+  public LeaderReplicaPerLiveBrokerGoal() {\n+    _mustHaveLeaderReplicaPerBrokerTopics = null;\n+    _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker = 1;\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  public LeaderReplicaPerLiveBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }", "originalCommit": "63addab0bdf02806bf04f5935641ce9359e9b1fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMwODcyNA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548308724", "bodyText": "There is no support for replica addition / deletion flags -- i.e. these were experimental balancing actions that are not adopted later on.\n\nCan we remove case statements for these flags?\n[In a separate PR -- Not on this PR] Can we cleanup the use of these flags globally?", "author": "efeg", "createdAt": "2020-12-23T22:58:22Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/LeaderReplicaPerLiveBrokerGoal.java", "diffHunk": "@@ -0,0 +1,511 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ *\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.*;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker has\n+ * at least a certain number of leader replica of each topic in a configured set of topics\n+ */\n+public class LeaderReplicaPerLiveBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(LeaderReplicaPerLiveBrokerGoal.class);\n+\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+  private int _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker;\n+\n+  public LeaderReplicaPerLiveBrokerGoal() {\n+    _mustHaveLeaderReplicaPerBrokerTopics = null;\n+    _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker = 1;\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  public LeaderReplicaPerLiveBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return LeaderReplicaPerLiveBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics must have at least one leader\n+   * replica on each broker.\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   * {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!_mustHaveLeaderReplicaPerBrokerTopics.contains(action.topic())) {\n+      // Always accept balancing action on topics that are not of the interest of this goal\n+      return ActionAcceptance.ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case REPLICA_ADDITION:\n+        return ActionAcceptance.ACCEPT;\n+      case REPLICA_DELETION:", "originalCommit": "63addab0bdf02806bf04f5935641ce9359e9b1fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM4MjU2Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548382562", "bodyText": "OK, I created an issue.", "author": "Lincong", "createdAt": "2020-12-24T04:58:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMwODcyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMwODk2Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548308967", "bodyText": "Nit: Can we avoid using wildcard import?", "author": "efeg", "createdAt": "2020-12-23T22:59:02Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/LeaderReplicaPerLiveBrokerGoal.java", "diffHunk": "@@ -0,0 +1,511 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ *\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.*;", "originalCommit": "63addab0bdf02806bf04f5935641ce9359e9b1fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMwOTIxNw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548309217", "bodyText": "JavaDoc explanation seems inaccurate -- e.g. is it \"one\" leader on \"each\" broker?", "author": "efeg", "createdAt": "2020-12-23T23:00:07Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/LeaderReplicaPerLiveBrokerGoal.java", "diffHunk": "@@ -0,0 +1,511 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ *\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.*;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker has\n+ * at least a certain number of leader replica of each topic in a configured set of topics\n+ */\n+public class LeaderReplicaPerLiveBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(LeaderReplicaPerLiveBrokerGoal.class);\n+\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+  private int _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker;\n+\n+  public LeaderReplicaPerLiveBrokerGoal() {\n+    _mustHaveLeaderReplicaPerBrokerTopics = null;\n+    _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker = 1;\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  public LeaderReplicaPerLiveBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return LeaderReplicaPerLiveBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics must have at least one leader\n+   * replica on each broker.\n+   *", "originalCommit": "63addab0bdf02806bf04f5935641ce9359e9b1fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM4MDEwMw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548380103", "bodyText": "I modified it to A configured set of topics that should have a minimum number of leader replicas on each alive broker that is not excluded for replica move.", "author": "Lincong", "createdAt": "2020-12-24T04:45:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMwOTIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMwOTY2NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548309665", "bodyText": "This does not match with the implementation. Why / when do we return BROKER_REJECT?", "author": "efeg", "createdAt": "2020-12-23T23:01:39Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/LeaderReplicaPerLiveBrokerGoal.java", "diffHunk": "@@ -0,0 +1,511 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ *\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.*;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker has\n+ * at least a certain number of leader replica of each topic in a configured set of topics\n+ */\n+public class LeaderReplicaPerLiveBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(LeaderReplicaPerLiveBrokerGoal.class);\n+\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+  private int _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker;\n+\n+  public LeaderReplicaPerLiveBrokerGoal() {\n+    _mustHaveLeaderReplicaPerBrokerTopics = null;\n+    _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker = 1;\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  public LeaderReplicaPerLiveBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return LeaderReplicaPerLiveBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics must have at least one leader\n+   * replica on each broker.\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   * {@link ActionAcceptance#REPLICA_REJECT} otherwise.", "originalCommit": "63addab0bdf02806bf04f5935641ce9359e9b1fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM4MTE5MA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548381190", "bodyText": "I changed the implementation to only return REPLICA_REJECT since even moving one replica of this action type is not accepted, another action with this type to move a replica of another topic might be accepted. Therefore, only REPLICA_REJECT and no BROKER_REJECT. Let me know if my understanding is correct.", "author": "Lincong", "createdAt": "2020-12-24T04:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMwOTY2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMxNzY5MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548317691", "bodyText": "Can this be static and moved to GoalUtils?\ncountTopicLeaderReplicaOnBroker -> numTopicLeadersOnBroker?\nFinally, looks like this patch adds Broker#numReplicasOfTopicInBroker. If that is the case, do we even need this function? If not can we remove either this one or the one under Broker class?", "author": "efeg", "createdAt": "2020-12-23T23:25:45Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/LeaderReplicaPerLiveBrokerGoal.java", "diffHunk": "@@ -0,0 +1,511 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ *\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.*;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker has\n+ * at least a certain number of leader replica of each topic in a configured set of topics\n+ */\n+public class LeaderReplicaPerLiveBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(LeaderReplicaPerLiveBrokerGoal.class);\n+\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+  private int _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker;\n+\n+  public LeaderReplicaPerLiveBrokerGoal() {\n+    _mustHaveLeaderReplicaPerBrokerTopics = null;\n+    _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker = 1;\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  public LeaderReplicaPerLiveBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return LeaderReplicaPerLiveBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics must have at least one leader\n+   * replica on each broker.\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   * {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!_mustHaveLeaderReplicaPerBrokerTopics.contains(action.topic())) {\n+      // Always accept balancing action on topics that are not of the interest of this goal\n+      return ActionAcceptance.ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case REPLICA_ADDITION:\n+        return ActionAcceptance.ACCEPT;\n+      case REPLICA_DELETION:\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+      case INTER_BROKER_REPLICA_SWAP:\n+        if (doesReplicaRemoveViolateOptimizedGoal(clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition()))) {\n+          return ActionAcceptance.BROKER_REJECT;\n+        }\n+        if (action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP\n+            && doesReplicaRemoveViolateOptimizedGoal(clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition()))) {\n+          return REPLICA_REJECT;\n+        }\n+        return ACCEPT;\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given replica. It is violated if there is not be enough '\n+   * leader replica on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker =\n+        countTopicLeaderReplicaOnBroker(replicaToBeRemoved.topicPartition().topic(), replicaToBeRemoved.broker());\n+    return topicLeaderReplicaCountOnSourceBroker - 1 < _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker;\n+  }\n+\n+  private int countTopicLeaderReplicaOnBroker(String replicaTopicName, Broker broker) {", "originalCommit": "63addab0bdf02806bf04f5935641ce9359e9b1fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM3ODIyNg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548378226", "bodyText": "I will remove this one and keep the method in the Broker class", "author": "Lincong", "createdAt": "2020-12-24T04:35:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMxNzY5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMxOTMxNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548319315", "bodyText": "Nit: Why does this variable has SourceBroker in its name?", "author": "efeg", "createdAt": "2020-12-23T23:32:31Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/LeaderReplicaPerLiveBrokerGoal.java", "diffHunk": "@@ -0,0 +1,511 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ *\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.*;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker has\n+ * at least a certain number of leader replica of each topic in a configured set of topics\n+ */\n+public class LeaderReplicaPerLiveBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(LeaderReplicaPerLiveBrokerGoal.class);\n+\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+  private int _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker;\n+\n+  public LeaderReplicaPerLiveBrokerGoal() {\n+    _mustHaveLeaderReplicaPerBrokerTopics = null;\n+    _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker = 1;\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  public LeaderReplicaPerLiveBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return LeaderReplicaPerLiveBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics must have at least one leader\n+   * replica on each broker.\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   * {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!_mustHaveLeaderReplicaPerBrokerTopics.contains(action.topic())) {\n+      // Always accept balancing action on topics that are not of the interest of this goal\n+      return ActionAcceptance.ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case REPLICA_ADDITION:\n+        return ActionAcceptance.ACCEPT;\n+      case REPLICA_DELETION:\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+      case INTER_BROKER_REPLICA_SWAP:\n+        if (doesReplicaRemoveViolateOptimizedGoal(clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition()))) {\n+          return ActionAcceptance.BROKER_REJECT;\n+        }\n+        if (action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP\n+            && doesReplicaRemoveViolateOptimizedGoal(clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition()))) {\n+          return REPLICA_REJECT;\n+        }\n+        return ACCEPT;\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given replica. It is violated if there is not be enough '\n+   * leader replica on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker =\n+        countTopicLeaderReplicaOnBroker(replicaToBeRemoved.topicPartition().topic(), replicaToBeRemoved.broker());\n+    return topicLeaderReplicaCountOnSourceBroker - 1 < _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker;\n+  }\n+\n+  private int countTopicLeaderReplicaOnBroker(String replicaTopicName, Broker broker) {\n+    int topicLeaderReplicaCountOnSourceBroker = 0;", "originalCommit": "63addab0bdf02806bf04f5935641ce9359e9b1fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM3ODYyNA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548378624", "bodyText": "This countTopicLeaderReplicaOnBroker method will be removed", "author": "Lincong", "createdAt": "2020-12-24T04:37:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMxOTMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyMzIwNA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548323204", "bodyText": "This function is called for LEADERSHIP_MOVEMENT actions -- is \"replica remove\" an accurate name for it?", "author": "efeg", "createdAt": "2020-12-23T23:50:29Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/LeaderReplicaPerLiveBrokerGoal.java", "diffHunk": "@@ -0,0 +1,511 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ *\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.*;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker has\n+ * at least a certain number of leader replica of each topic in a configured set of topics\n+ */\n+public class LeaderReplicaPerLiveBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(LeaderReplicaPerLiveBrokerGoal.class);\n+\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+  private int _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker;\n+\n+  public LeaderReplicaPerLiveBrokerGoal() {\n+    _mustHaveLeaderReplicaPerBrokerTopics = null;\n+    _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker = 1;\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  public LeaderReplicaPerLiveBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return LeaderReplicaPerLiveBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics must have at least one leader\n+   * replica on each broker.\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   * {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!_mustHaveLeaderReplicaPerBrokerTopics.contains(action.topic())) {\n+      // Always accept balancing action on topics that are not of the interest of this goal\n+      return ActionAcceptance.ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case REPLICA_ADDITION:\n+        return ActionAcceptance.ACCEPT;\n+      case REPLICA_DELETION:\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+      case INTER_BROKER_REPLICA_SWAP:\n+        if (doesReplicaRemoveViolateOptimizedGoal(clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition()))) {\n+          return ActionAcceptance.BROKER_REJECT;\n+        }\n+        if (action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP\n+            && doesReplicaRemoveViolateOptimizedGoal(clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition()))) {\n+          return REPLICA_REJECT;\n+        }\n+        return ACCEPT;\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given replica. It is violated if there is not be enough '\n+   * leader replica on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {", "originalCommit": "63addab0bdf02806bf04f5935641ce9359e9b1fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM4NDkzMA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548384930", "bodyText": "I will rename it to doesLeaderReplicaRemoveViolateOptimizedGoal", "author": "Lincong", "createdAt": "2020-12-24T05:11:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyMzIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyMzU5MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548323591", "bodyText": "Nit: Is this the same as checking the simpler inequality?:\ntopicLeaderReplicaCountOnSourceBroker <= _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker", "author": "efeg", "createdAt": "2020-12-23T23:52:39Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/LeaderReplicaPerLiveBrokerGoal.java", "diffHunk": "@@ -0,0 +1,511 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ *\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.*;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker has\n+ * at least a certain number of leader replica of each topic in a configured set of topics\n+ */\n+public class LeaderReplicaPerLiveBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(LeaderReplicaPerLiveBrokerGoal.class);\n+\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+  private int _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker;\n+\n+  public LeaderReplicaPerLiveBrokerGoal() {\n+    _mustHaveLeaderReplicaPerBrokerTopics = null;\n+    _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker = 1;\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  public LeaderReplicaPerLiveBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return LeaderReplicaPerLiveBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics must have at least one leader\n+   * replica on each broker.\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   * {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!_mustHaveLeaderReplicaPerBrokerTopics.contains(action.topic())) {\n+      // Always accept balancing action on topics that are not of the interest of this goal\n+      return ActionAcceptance.ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case REPLICA_ADDITION:\n+        return ActionAcceptance.ACCEPT;\n+      case REPLICA_DELETION:\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+      case INTER_BROKER_REPLICA_SWAP:\n+        if (doesReplicaRemoveViolateOptimizedGoal(clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition()))) {\n+          return ActionAcceptance.BROKER_REJECT;\n+        }\n+        if (action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP\n+            && doesReplicaRemoveViolateOptimizedGoal(clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition()))) {\n+          return REPLICA_REJECT;\n+        }\n+        return ACCEPT;\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given replica. It is violated if there is not be enough '\n+   * leader replica on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker =\n+        countTopicLeaderReplicaOnBroker(replicaToBeRemoved.topicPartition().topic(), replicaToBeRemoved.broker());\n+    return topicLeaderReplicaCountOnSourceBroker - 1 < _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker;", "originalCommit": "63addab0bdf02806bf04f5935641ce9359e9b1fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyMzkxMA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548323910", "bodyText": "I am confused. Why does this goal talk about replica capacity goal in its JavaDoc?", "author": "efeg", "createdAt": "2020-12-23T23:54:25Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/LeaderReplicaPerLiveBrokerGoal.java", "diffHunk": "@@ -0,0 +1,511 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ *\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.*;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker has\n+ * at least a certain number of leader replica of each topic in a configured set of topics\n+ */\n+public class LeaderReplicaPerLiveBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(LeaderReplicaPerLiveBrokerGoal.class);\n+\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+  private int _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker;\n+\n+  public LeaderReplicaPerLiveBrokerGoal() {\n+    _mustHaveLeaderReplicaPerBrokerTopics = null;\n+    _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker = 1;\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  public LeaderReplicaPerLiveBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return LeaderReplicaPerLiveBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics must have at least one leader\n+   * replica on each broker.\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   * {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!_mustHaveLeaderReplicaPerBrokerTopics.contains(action.topic())) {\n+      // Always accept balancing action on topics that are not of the interest of this goal\n+      return ActionAcceptance.ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case REPLICA_ADDITION:\n+        return ActionAcceptance.ACCEPT;\n+      case REPLICA_DELETION:\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+      case INTER_BROKER_REPLICA_SWAP:\n+        if (doesReplicaRemoveViolateOptimizedGoal(clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition()))) {\n+          return ActionAcceptance.BROKER_REJECT;\n+        }\n+        if (action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP\n+            && doesReplicaRemoveViolateOptimizedGoal(clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition()))) {\n+          return REPLICA_REJECT;\n+        }\n+        return ACCEPT;\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given replica. It is violated if there is not be enough '\n+   * leader replica on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker =\n+        countTopicLeaderReplicaOnBroker(replicaToBeRemoved.topicPartition().topic(), replicaToBeRemoved.broker());\n+    return topicLeaderReplicaCountOnSourceBroker - 1 < _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker;\n+  }\n+\n+  private int countTopicLeaderReplicaOnBroker(String replicaTopicName, Broker broker) {\n+    int topicLeaderReplicaCountOnSourceBroker = 0;\n+    for (Replica leaderReplica : broker.leaderReplicas()) {\n+      if (Objects.equals(replicaTopicName, leaderReplica.topicPartition().topic())) {\n+        topicLeaderReplicaCountOnSourceBroker++;\n+      }\n+    }\n+    return topicLeaderReplicaCountOnSourceBroker;\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: Each node has sufficient number of replicas that can be moved to satisfy the replica capacity goal.", "originalCommit": "63addab0bdf02806bf04f5935641ce9359e9b1fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM4MzU3NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548383575", "bodyText": "I changed this comment. I copied from the replica capacity goal and forgot to change it completely.", "author": "Lincong", "createdAt": "2020-12-24T05:04:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyMzkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyNDMyOQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r548324329", "bodyText": "Can we ensure this by construction using the given regex config and the cluster model (see how we do this for excludedTopics)? -- i.e. not in the init function of this goal.", "author": "efeg", "createdAt": "2020-12-23T23:56:33Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/LeaderReplicaPerLiveBrokerGoal.java", "diffHunk": "@@ -0,0 +1,511 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ *\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.*;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker has\n+ * at least a certain number of leader replica of each topic in a configured set of topics\n+ */\n+public class LeaderReplicaPerLiveBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(LeaderReplicaPerLiveBrokerGoal.class);\n+\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+  private int _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker;\n+\n+  public LeaderReplicaPerLiveBrokerGoal() {\n+    _mustHaveLeaderReplicaPerBrokerTopics = null;\n+    _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker = 1;\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  public LeaderReplicaPerLiveBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return LeaderReplicaPerLiveBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics must have at least one leader\n+   * replica on each broker.\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   * {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!_mustHaveLeaderReplicaPerBrokerTopics.contains(action.topic())) {\n+      // Always accept balancing action on topics that are not of the interest of this goal\n+      return ActionAcceptance.ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case REPLICA_ADDITION:\n+        return ActionAcceptance.ACCEPT;\n+      case REPLICA_DELETION:\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+      case INTER_BROKER_REPLICA_SWAP:\n+        if (doesReplicaRemoveViolateOptimizedGoal(clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition()))) {\n+          return ActionAcceptance.BROKER_REJECT;\n+        }\n+        if (action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP\n+            && doesReplicaRemoveViolateOptimizedGoal(clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition()))) {\n+          return REPLICA_REJECT;\n+        }\n+        return ACCEPT;\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given replica. It is violated if there is not be enough '\n+   * leader replica on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker =\n+        countTopicLeaderReplicaOnBroker(replicaToBeRemoved.topicPartition().topic(), replicaToBeRemoved.broker());\n+    return topicLeaderReplicaCountOnSourceBroker - 1 < _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker;\n+  }\n+\n+  private int countTopicLeaderReplicaOnBroker(String replicaTopicName, Broker broker) {\n+    int topicLeaderReplicaCountOnSourceBroker = 0;\n+    for (Replica leaderReplica : broker.leaderReplicas()) {\n+      if (Objects.equals(replicaTopicName, leaderReplica.topicPartition().topic())) {\n+        topicLeaderReplicaCountOnSourceBroker++;\n+      }\n+    }\n+    return topicLeaderReplicaCountOnSourceBroker;\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: Each node has sufficient number of replicas that can be moved to satisfy the replica capacity goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity checks\n+    validateMustHaveLeaderReplicaOnEachBrokerTopicsExist(clusterModel, optimizationOptions.mustHaveLeaderReplicaPerBrokerTopics());", "originalCommit": "63addab0bdf02806bf04f5935641ce9359e9b1fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwNjcxMA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552106710", "bodyText": "Variable names (e.g. TOPICS_MUST_HAVE_LEADER_REPLICA_PER_BROKER_CONFIG  and MIN_LEADER_REPLICA_COUNT_PER_BROKER_FOR_TOPICS_MUST_HAVE_LEADER_REPLICA_PER_BROKER_CONFIG ) do not match the config names (e.g. topics.with.min.leaders.per.broker and min.topic.leaders.per.broker). Please use matching names.", "author": "efeg", "createdAt": "2021-01-05T18:14:20Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnalyzerConfig.java", "diffHunk": "@@ -334,6 +338,24 @@ private AnalyzerConfig() {\n   public static final String ALLOW_CAPACITY_ESTIMATION_ON_PROPOSAL_PRECOMPUTE_DOC = \"The flag to indicate whether to \"\n       + \"allow capacity estimation on proposal precomputation.\";\n \n+  /**\n+   * <code>topics.with.min.leaders.per.broker</code>\n+   */\n+  public static final String TOPICS_MUST_HAVE_LEADER_REPLICA_PER_BROKER_CONFIG = \"topics.with.min.leaders.per.broker\";\n+  public static final String DEFAULT_TOPICS_MUST_HAVE_LEADER_REPLICA_PER_BROKER = \"\";\n+  public static final String TOPICS_MUST_HAVE_LEADER_REPLICA_PER_BROKER_DOC = \"The topics that should have minimum \"\n+      + \"number of replica per alive broker that is not excluded for replica move. It is a regex.\";\n+\n+  /**\n+   * <code>min.topic.leaders.per.broker</code>\n+   */\n+  public static final String MIN_LEADER_REPLICA_COUNT_PER_BROKER_FOR_TOPICS_MUST_HAVE_LEADER_REPLICA_PER_BROKER_CONFIG =\n+      \"min.topic.leaders.per.broker\";\n+  public static final int DEFAULT_MIN_LEADER_REPLICA_COUNT_PER_BROKER_FOR_TOPICS_MUST_HAVE_LEADER_REPLICA_PER_BROKER = 1;\n+  public static final String MIN_LEADER_REPLICA_COUNT_PER_BROKER_FOR_TOPICS_MUST_HAVE_LEADER_REPLICA_PER_BROKER_DOC =\n+      \"The minimum required number of leader replica per broker for topics that must have leader replica per broker \"\n+          + \"that is not excluded for replica move.\";\n+", "originalCommit": "51b47ac68ebe3f4b2be20802d6de800e8f194e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwNzUxNA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552107514", "bodyText": "Nit: Bad indentation", "author": "efeg", "createdAt": "2021-01-05T18:15:27Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnalyzerConfig.java", "diffHunk": "@@ -334,6 +338,24 @@ private AnalyzerConfig() {\n   public static final String ALLOW_CAPACITY_ESTIMATION_ON_PROPOSAL_PRECOMPUTE_DOC = \"The flag to indicate whether to \"\n       + \"allow capacity estimation on proposal precomputation.\";\n \n+  /**\n+   * <code>topics.with.min.leaders.per.broker</code>\n+   */\n+  public static final String TOPICS_MUST_HAVE_LEADER_REPLICA_PER_BROKER_CONFIG = \"topics.with.min.leaders.per.broker\";\n+  public static final String DEFAULT_TOPICS_MUST_HAVE_LEADER_REPLICA_PER_BROKER = \"\";\n+  public static final String TOPICS_MUST_HAVE_LEADER_REPLICA_PER_BROKER_DOC = \"The topics that should have minimum \"\n+      + \"number of replica per alive broker that is not excluded for replica move. It is a regex.\";\n+\n+  /**\n+   * <code>min.topic.leaders.per.broker</code>\n+   */\n+  public static final String MIN_LEADER_REPLICA_COUNT_PER_BROKER_FOR_TOPICS_MUST_HAVE_LEADER_REPLICA_PER_BROKER_CONFIG =\n+      \"min.topic.leaders.per.broker\";\n+  public static final int DEFAULT_MIN_LEADER_REPLICA_COUNT_PER_BROKER_FOR_TOPICS_MUST_HAVE_LEADER_REPLICA_PER_BROKER = 1;\n+  public static final String MIN_LEADER_REPLICA_COUNT_PER_BROKER_FOR_TOPICS_MUST_HAVE_LEADER_REPLICA_PER_BROKER_DOC =\n+      \"The minimum required number of leader replica per broker for topics that must have leader replica per broker \"\n+          + \"that is not excluded for replica move.\";", "originalCommit": "51b47ac68ebe3f4b2be20802d6de800e8f194e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwODUxOA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552108518", "bodyText": "Variable names are inconsistent with the config names (please see relevant feedback on AnalyzerConfig).", "author": "efeg", "createdAt": "2021-01-05T18:16:29Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/BalancingConstraint.java", "diffHunk": "@@ -27,6 +28,8 @@\n   private final Map<Resource, Double> _capacityThreshold;\n   private final Map<Resource, Double> _lowUtilizationThreshold;\n   private final long _maxReplicasPerBroker;\n+  private final Pattern _mustHaveLeaderReplicaPerBrokerTopicsPattern;\n+  private final int _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker;", "originalCommit": "51b47ac68ebe3f4b2be20802d6de800e8f194e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjExMzc0OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552113749", "bodyText": "The default values of existing configs have been updated\nNew configs have been added\n\nBut the relevant updates in documentation in Configuration.md are missing. We should ensure consistency between our documentation and default values and supported configs.\nCan we updated  Configuration.md?", "author": "efeg", "createdAt": "2021-01-05T18:26:39Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnalyzerConfig.java", "diffHunk": "@@ -14,6 +14,7 @@\n import com.linkedin.kafka.cruisecontrol.analyzer.goals.IntraBrokerDiskUsageDistributionGoal;\n import com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderBytesInDistributionGoal;\n import com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderReplicaDistributionGoal;\n+import com.linkedin.kafka.cruisecontrol.analyzer.goals.MinTopicLeadersPerBrokerGoal;", "originalCommit": "51b47ac68ebe3f4b2be20802d6de800e8f194e16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE3ODQ4Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567178487", "bodyText": "Updated", "author": "Lincong", "createdAt": "2021-01-30T01:51:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjExMzc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjExNDI3Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552114276", "bodyText": "The default values of existing configs have been updated, but the relevant updates in documentation in Configuration.md are missing. We should ensure consistency between our documentation and default values.\nCan we updated  Configuration.md?", "author": "efeg", "createdAt": "2021-01-05T18:27:42Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnomalyDetectorConfig.java", "diffHunk": "@@ -101,6 +102,7 @@ private AnomalyDetectorConfig() {\n    */\n   public static final String ANOMALY_DETECTION_GOALS_CONFIG = \"anomaly.detection.goals\";\n   public static final String DEFAULT_ANOMALY_DETECTION_GOALS = new StringJoiner(\",\").add(RackAwareGoal.class.getName())\n+                                                                                    .add(MinTopicLeadersPerBrokerGoal.class.getName())", "originalCommit": "51b47ac68ebe3f4b2be20802d6de800e8f194e16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE3ODY5MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567178691", "bodyText": "Added", "author": "Lincong", "createdAt": "2021-01-30T01:53:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjExNDI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEyMDc0MA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552120740", "bodyText": "Nit: Can we add an inline comment to describe which default values are being set here (please see similar comments above).", "author": "efeg", "createdAt": "2021-01-05T18:40:24Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/BalancingConstraint.java", "diffHunk": "@@ -63,6 +66,11 @@ public BalancingConstraint(KafkaCruiseControlConfig config) {\n     _topicReplicaBalanceMinGap = config.getInt(AnalyzerConfig.TOPIC_REPLICA_COUNT_BALANCE_MIN_GAP_CONFIG);\n     _topicReplicaBalanceMaxGap = config.getInt(AnalyzerConfig.TOPIC_REPLICA_COUNT_BALANCE_MAX_GAP_CONFIG);\n     _goalViolationDistributionThresholdMultiplier = config.getDouble(AnalyzerConfig.GOAL_VIOLATION_DISTRIBUTION_THRESHOLD_MULTIPLIER_CONFIG);\n+", "originalCommit": "51b47ac68ebe3f4b2be20802d6de800e8f194e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEyMTk2OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552121969", "bodyText": "what does topic number mean?", "author": "efeg", "createdAt": "2021-01-05T18:42:52Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/BalancingConstraint.java", "diffHunk": "@@ -171,6 +183,26 @@ public double lowUtilizationThreshold(Resource resource) {\n     return _lowUtilizationThreshold.get(resource);\n   }\n \n+  /**\n+   * Get the regex pattern of names of topics that must have a minimum number of leader replicas on alive brokers that\n+   * not excluded for replica move.\n+   *\n+   * @return regex pattern of topics names\n+   */\n+  public Pattern mustHaveLeaderReplicaPerBrokerTopicsPattern() {\n+    return _mustHaveLeaderReplicaPerBrokerTopicsPattern;\n+  }\n+\n+  /**\n+   * Get the minimum required number of leader replica per broker for topics that must have leader replica per broker\n+   * that is not excluded for replica move.\n+   *\n+   * @return topic number", "originalCommit": "51b47ac68ebe3f4b2be20802d6de800e8f194e16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxODQxOA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552218418", "bodyText": "I will change it to topic count and its specific meaning has been explained in the description of this method's Java doc", "author": "Lincong", "createdAt": "2021-01-05T21:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEyMTk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEyMjQ0OA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552122448", "bodyText": "Can we update these function names and javadoc to make them consistent with the actual config names?", "author": "efeg", "createdAt": "2021-01-05T18:43:42Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/BalancingConstraint.java", "diffHunk": "@@ -171,6 +183,26 @@ public double lowUtilizationThreshold(Resource resource) {\n     return _lowUtilizationThreshold.get(resource);\n   }\n \n+  /**\n+   * Get the regex pattern of names of topics that must have a minimum number of leader replicas on alive brokers that\n+   * not excluded for replica move.\n+   *\n+   * @return regex pattern of topics names\n+   */\n+  public Pattern mustHaveLeaderReplicaPerBrokerTopicsPattern() {\n+    return _mustHaveLeaderReplicaPerBrokerTopicsPattern;\n+  }\n+\n+  /**\n+   * Get the minimum required number of leader replica per broker for topics that must have leader replica per broker\n+   * that is not excluded for replica move.\n+   *\n+   * @return topic number\n+   */\n+  public int minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker() {\n+    return _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker;\n+  }\n+", "originalCommit": "51b47ac68ebe3f4b2be20802d6de800e8f194e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEyMzU2Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552123563", "bodyText": "The ] corresponds to the end of String -- so it should be moved to the end of the new string.", "author": "efeg", "createdAt": "2021-01-05T18:45:50Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/BalancingConstraint.java", "diffHunk": "@@ -229,13 +261,17 @@ public String toString() {\n                          + \"diskCapacityThreshold=%.4f,inboundNwCapacityThreshold=%.4f,outboundNwCapacityThreshold=%.4f,\"\n                          + \"maxReplicasPerBroker=%d,replicaBalancePercentage=%.4f,leaderReplicaBalancePercentage=%.4f,\"\n                          + \"topicReplicaBalancePercentage=%.4f,topicReplicaBalanceGap=[%d,%d],\"\n-                         + \"goalViolationDistributionThresholdMultiplier=%.4f]\",\n+                         + \"goalViolationDistributionThresholdMultiplier=%.4f],\"", "originalCommit": "51b47ac68ebe3f4b2be20802d6de800e8f194e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEyNDA2OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552124069", "bodyText": "reminder -- can we  use the consistent names with the config names?", "author": "efeg", "createdAt": "2021-01-05T18:46:41Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/BalancingConstraint.java", "diffHunk": "@@ -229,13 +261,17 @@ public String toString() {\n                          + \"diskCapacityThreshold=%.4f,inboundNwCapacityThreshold=%.4f,outboundNwCapacityThreshold=%.4f,\"\n                          + \"maxReplicasPerBroker=%d,replicaBalancePercentage=%.4f,leaderReplicaBalancePercentage=%.4f,\"\n                          + \"topicReplicaBalancePercentage=%.4f,topicReplicaBalanceGap=[%d,%d],\"\n-                         + \"goalViolationDistributionThresholdMultiplier=%.4f]\",\n+                         + \"goalViolationDistributionThresholdMultiplier=%.4f],\"\n+                         + \"mustHaveLeaderReplicaPerBrokerTopicsPattern=%s,\"\n+                         + \"minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker=%d\",", "originalCommit": "51b47ac68ebe3f4b2be20802d6de800e8f194e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEyODU4Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552128583", "bodyText": ".. alive brokers that not excluded ... -> .. alive brokers that are not excluded ...?\nIn general, can we simplify this statement a little? Maybe something like:\nGet the regex pattern of topics with a minimum number of leaders on brokers that are not excluded for replica move.", "author": "efeg", "createdAt": "2021-01-05T18:55:24Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/BalancingConstraint.java", "diffHunk": "@@ -171,6 +183,26 @@ public double lowUtilizationThreshold(Resource resource) {\n     return _lowUtilizationThreshold.get(resource);\n   }\n \n+  /**\n+   * Get the regex pattern of names of topics that must have a minimum number of leader replicas on alive brokers that\n+   * not excluded for replica move.", "originalCommit": "51b47ac68ebe3f4b2be20802d6de800e8f194e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEyOTk4OA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552129988", "bodyText": "Nit (applies to similar modifications): Can we avoid redundant changes.", "author": "efeg", "createdAt": "2021-01-05T18:57:58Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/GoalOptimizer.java", "diffHunk": "@@ -380,7 +380,8 @@ public OptimizerResult optimizations(ClusterModel clusterModel,\n     Set<String> excludedTopics = excludedTopics(clusterModel, null);\n     LOG.debug(\"Topics excluded from partition movement: {}\", excludedTopics);\n     OptimizationOptions optimizationOptions =\n-        _optimizationOptionsGenerator.optimizationOptionsForCachedProposalCalculation(clusterModel, excludedTopics);\n+        _optimizationOptionsGenerator.optimizationOptionsForCachedProposalCalculation(clusterModel,\n+                                                                                      excludedTopics);", "originalCommit": "51b47ac68ebe3f4b2be20802d6de800e8f194e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE0ODA2MA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552148060", "bodyText": "(Applies to other similar uses of getTopicNamesMatchedWithPattern) If topicsToExclude.pattern() is empty, then this function should ideally terminate early w/o performing redundant operations.\n-- Currently regardless of whether the pattern is empty or not, clusterModel.topics() is called, which is an expensive call that generates objects for no reason. Similarly, call to getTopicNamesMatchedWithPattern is expensive with redundant Matcher generation. All of these can be eliminated.\n(Can we also add a unit test to verify that behavior?)", "author": "efeg", "createdAt": "2021-01-05T19:32:13Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/GoalOptimizer.java", "diffHunk": "@@ -494,10 +495,7 @@ public OptimizerResult optimizations(ClusterModel clusterModel,\n    */\n   public Set<String> excludedTopics(ClusterModel clusterModel, Pattern requestedExcludedTopics) {\n     Pattern topicsToExclude = requestedExcludedTopics != null ? requestedExcludedTopics : _defaultExcludedTopics;\n-    return clusterModel.topics()\n-                       .stream()\n-                       .filter(topic -> topicsToExclude.matcher(topic).matches())\n-                       .collect(Collectors.toSet());\n+    return Utils.getTopicNamesMatchedWithPattern(topicsToExclude, clusterModel.topics());", "originalCommit": "51b47ac68ebe3f4b2be20802d6de800e8f194e16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE3ODA0NA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567178044", "bodyText": "Yes, topicsToExclude.pattern().isEmpty() has been applied to other places as well", "author": "Lincong", "createdAt": "2021-01-30T01:48:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE0ODA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE0ODc3NA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552148774", "bodyText": "Why is this deleted?", "author": "efeg", "createdAt": "2021-01-05T19:33:45Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/OptimizationOptionsGenerator.java", "diffHunk": "@@ -25,7 +25,6 @@\n    * @param excludedBrokersForLeadership The brokers to be specified to not considered for leadership movement in\n    *                                     generated optimization options.\n    * @param excludedBrokersForReplicaMove The brokers to be specified to not considered for replica movement in\n-   *                                      generated optimization options.", "originalCommit": "51b47ac68ebe3f4b2be20802d6de800e8f194e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE1MTI0Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552151247", "bodyText": "_minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker is assigned but never accessed.\nDoes your IDE not warn you about this?", "author": "efeg", "createdAt": "2021-01-05T19:38:28Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/GoalViolationDetector.java", "diffHunk": "@@ -51,7 +51,9 @@\n   private static final Logger LOG = LoggerFactory.getLogger(GoalViolationDetector.class);\n   private final List<Goal> _detectionGoals;\n   private ModelGeneration _lastCheckedModelGeneration;\n-  private final Pattern _excludedTopics;\n+  private final Pattern _excludedTopicsPattern;\n+  private final Pattern _mustHaveLeaderReplicaPerBrokerTopicsPattern;\n+  private final int _minLeaderReplicaCountForTopicsMustHaveLeaderReplicaPerBroker;", "originalCommit": "51b47ac68ebe3f4b2be20802d6de800e8f194e16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIyNTc5Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552225793", "bodyText": "Oops, missed it", "author": "Lincong", "createdAt": "2021-01-05T22:02:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE1MTI0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE1MjE3MA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552152170", "bodyText": "This is not used -- can we drop _mustHaveLeaderReplicaPerBrokerTopicsPattern and other changes from this class?", "author": "efeg", "createdAt": "2021-01-05T19:40:20Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/GoalViolationDetector.java", "diffHunk": "@@ -229,10 +235,11 @@ protected void refreshBalancednessScore(Map<Boolean, List<String>> violatedGoals\n   }\n \n   protected Set<String> excludedTopics(ClusterModel clusterModel) {\n-    return clusterModel.topics()\n-        .stream()\n-        .filter(topic -> _excludedTopics.matcher(topic).matches())\n-        .collect(Collectors.toSet());\n+    return Utils.getTopicNamesMatchedWithPattern(_excludedTopicsPattern, clusterModel.topics());\n+  }\n+\n+  protected Set<String> mustHaveLeaderReplicaPerBrokerTopics(ClusterModel clusterModel) {\n+    return Utils.getTopicNamesMatchedWithPattern(_mustHaveLeaderReplicaPerBrokerTopicsPattern, clusterModel.topics());", "originalCommit": "51b47ac68ebe3f4b2be20802d6de800e8f194e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE1Mjk5NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552152995", "bodyText": "Why are we breaking this indentation?\nCan we please use the project's style file: https://github.com/linkedin/cruise-control/blob/master/docs/code-style.xml ?", "author": "efeg", "createdAt": "2021-01-05T19:42:00Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/GoalViolationDetector.java", "diffHunk": "@@ -251,9 +258,9 @@ protected boolean optimizeForGoal(ClusterModel clusterModel,\n       goal.optimize(clusterModel,\n                     new HashSet<>(),\n                     _optimizationOptionsGenerator.optimizationOptionsForGoalViolationDetection(clusterModel,\n-                                                                                               excludedTopics(clusterModel),\n-                                                                                               excludedBrokersForLeadership,\n-                                                                                               excludedBrokersForReplicaMove));\n+                        excludedTopics(clusterModel),\n+                        excludedBrokersForLeadership,\n+                        excludedBrokersForReplicaMove));", "originalCommit": "51b47ac68ebe3f4b2be20802d6de800e8f194e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE1NDgzMw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552154833", "bodyText": "Nit: (Applies to similar changes) Such global name changes makes the PR harder to review as it touches many files that are irrelevant to the current PR.\nCan we please move such global name changes to their own trivial PRs?", "author": "efeg", "createdAt": "2021-01-05T19:45:29Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/GoalBasedOperationRunnable.java", "diffHunk": "@@ -38,7 +38,7 @@\n   protected final boolean _dryRun;\n   protected final boolean _stopOngoingExecution;\n   protected final boolean _skipHardGoalCheck;\n-  protected final Pattern _excludedTopics;\n+  protected final Pattern _excludedTopicsPattern;", "originalCommit": "51b47ac68ebe3f4b2be20802d6de800e8f194e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE1NTMzMg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552155332", "bodyText": "Nit: Can we keep each parameter in their own line as before?", "author": "efeg", "createdAt": "2021-01-05T19:46:28Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/ProposalsRunnable.java", "diffHunk": "@@ -120,8 +120,7 @@ protected OptimizerResult workWithoutClusterModel() throws KafkaCruiseControlExc\n   @Override\n   protected boolean shouldWorkWithClusterModel() {\n     return _kafkaCruiseControl.ignoreProposalCache(_goals,\n-                                                   _combinedCompletenessRequirements,\n-                                                   _excludedTopics,\n+                                                   _combinedCompletenessRequirements, _excludedTopicsPattern,", "originalCommit": "51b47ac68ebe3f4b2be20802d6de800e8f194e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE1NjMyNw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552156327", "bodyText": "Nit: Can we avoid line deletion?", "author": "efeg", "createdAt": "2021-01-05T19:48:24Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControlUnitTestUtils.java", "diffHunk": "@@ -73,7 +73,6 @@ public static Properties getKafkaCruiseControlProperties() {\n     props.setProperty(AnomalyDetectorConfig.TOPIC_ANOMALY_FINDER_CLASSES_CONFIG, NoopTopicAnomalyFinder.class.getName());\n     props.setProperty(AnomalyDetectorConfig.SELF_HEALING_GOALS_CONFIG, \"\");\n     props.setProperty(AnalyzerConfig.DEFAULT_GOALS_CONFIG, TestConstants.DEFAULT_GOALS_VALUES);\n-", "originalCommit": "51b47ac68ebe3f4b2be20802d6de800e8f194e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE1ODEyNg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552158126", "bodyText": "Is wildcard import intentional?", "author": "efeg", "createdAt": "2021-01-05T19:52:07Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java", "diffHunk": "@@ -23,6 +23,7 @@\n import org.apache.kafka.common.TopicPartition;\n \n import static com.linkedin.kafka.cruisecontrol.KafkaCruiseControlUnitTestUtils.getAggregatedMetricValues;\n+import static com.linkedin.kafka.cruisecontrol.common.TestConstants.*;", "originalCommit": "51b47ac68ebe3f4b2be20802d6de800e8f194e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1ODU3NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552258575", "bodyText": "Nit: New line after = is redundant.", "author": "efeg", "createdAt": "2021-01-05T23:25:28Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/BalancingConstraint.java", "diffHunk": "@@ -63,6 +66,12 @@ public BalancingConstraint(KafkaCruiseControlConfig config) {\n     _topicReplicaBalanceMinGap = config.getInt(AnalyzerConfig.TOPIC_REPLICA_COUNT_BALANCE_MIN_GAP_CONFIG);\n     _topicReplicaBalanceMaxGap = config.getInt(AnalyzerConfig.TOPIC_REPLICA_COUNT_BALANCE_MAX_GAP_CONFIG);\n     _goalViolationDistributionThresholdMultiplier = config.getDouble(AnalyzerConfig.GOAL_VIOLATION_DISTRIBUTION_THRESHOLD_MULTIPLIER_CONFIG);\n+    // Set default value for the topics that must have a minimum number of leader replicas on brokers that are not\n+    // excluded for replica move.\n+    _topicsWithMinLeadersPerBrokerPattern =\n+        Pattern.compile(config.getString(AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    _minTopicLeadersPerBroker =\n+        config.getInt(AnalyzerConfig.MIN_TOPIC_LEADERS_PER_BROKER_CONFIG);", "originalCommit": "e6bcc68722644fdfd8063ef0cf8fe892716fe5c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1ODYzNg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552258636", "bodyText": "Nit: New line after , is redundant.", "author": "efeg", "createdAt": "2021-01-05T23:25:39Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/BalancingConstraint.java", "diffHunk": "@@ -89,6 +98,10 @@ Properties setProps(Properties props) {\n     props.put(AnalyzerConfig.TOPIC_REPLICA_COUNT_BALANCE_MAX_GAP_CONFIG, Integer.toString(_topicReplicaBalanceMaxGap));\n     props.put(AnalyzerConfig.GOAL_VIOLATION_DISTRIBUTION_THRESHOLD_MULTIPLIER_CONFIG,\n               Double.toString(_goalViolationDistributionThresholdMultiplier));\n+    props.put(AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG,\n+              _topicsWithMinLeadersPerBrokerPattern.pattern());\n+    props.put(AnalyzerConfig.MIN_TOPIC_LEADERS_PER_BROKER_CONFIG,\n+              Integer.toString(_minTopicLeadersPerBroker));", "originalCommit": "e6bcc68722644fdfd8063ef0cf8fe892716fe5c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1OTc4Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552259782", "bodyText": "Nit: New line after = is redundant.", "author": "efeg", "createdAt": "2021-01-05T23:28:54Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnalyzerConfig.java", "diffHunk": "@@ -334,6 +338,23 @@ private AnalyzerConfig() {\n   public static final String ALLOW_CAPACITY_ESTIMATION_ON_PROPOSAL_PRECOMPUTE_DOC = \"The flag to indicate whether to \"\n       + \"allow capacity estimation on proposal precomputation.\";\n \n+  /**\n+   * <code>topics.with.min.leaders.per.broker</code>\n+   */\n+  public static final String TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG = \"topics.with.min.leaders.per.broker\";\n+  public static final String DEFAULT_TOPICS_WITH_MIN_LEADERS_PER_BROKER = \"\";\n+  public static final String DEFAULT_TOPICS_WITH_MIN_LEADERS_PER_BROKER_DOC = \"The topics that should have minimum \"\n+      + \"number of replica on brokers that are not excluded for replica move. It is a regex.\";\n+\n+  /**\n+   * <code>min.topic.leaders.per.broker</code>\n+   */\n+  public static final String MIN_TOPIC_LEADERS_PER_BROKER_CONFIG =\n+      \"min.topic.leaders.per.broker\";", "originalCommit": "e6bcc68722644fdfd8063ef0cf8fe892716fe5c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2MDAxNg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552260016", "bodyText": "Nit: Missing new line after comma.", "author": "efeg", "createdAt": "2021-01-05T23:29:37Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnalyzerConfig.java", "diffHunk": "@@ -521,6 +542,16 @@ public static ConfigDef define(ConfigDef configDef) {\n                             DEFAULT_TOPICS_EXCLUDED_FROM_PARTITION_MOVEMENT,\n                             ConfigDef.Importance.LOW,\n                             TOPICS_EXCLUDED_FROM_PARTITION_MOVEMENT_DOC)\n+                    .define(TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG,\n+                            ConfigDef.Type.STRING,\n+                            DEFAULT_TOPICS_WITH_MIN_LEADERS_PER_BROKER,\n+                            ConfigDef.Importance.LOW,\n+                            DEFAULT_TOPICS_WITH_MIN_LEADERS_PER_BROKER_DOC)\n+                    .define(MIN_TOPIC_LEADERS_PER_BROKER_CONFIG,\n+                            ConfigDef.Type.INT,\n+                            DEFAULT_MIN_TOPIC_LEADERS_PER_BROKER,\n+                            atLeast(1),\n+                            ConfigDef.Importance.LOW, MIN_TOPIC_LEADERS_PER_BROKER_DOC)", "originalCommit": "e6bcc68722644fdfd8063ef0cf8fe892716fe5c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2MDkwOA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552260908", "bodyText": "Please see earlier comment: #1429 (comment)", "author": "efeg", "createdAt": "2021-01-05T23:32:23Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/GoalViolationDetector.java", "diffHunk": "@@ -229,10 +229,7 @@ protected void refreshBalancednessScore(Map<Boolean, List<String>> violatedGoals\n   }\n \n   protected Set<String> excludedTopics(ClusterModel clusterModel) {\n-    return clusterModel.topics()\n-        .stream()\n-        .filter(topic -> _excludedTopics.matcher(topic).matches())\n-        .collect(Collectors.toSet());\n+    return Utils.getTopicNamesMatchedWithPattern(_excludedTopics, clusterModel.topics());", "originalCommit": "e6bcc68722644fdfd8063ef0cf8fe892716fe5c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE3ODczNw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567178737", "bodyText": "Fixed", "author": "Lincong", "createdAt": "2021-01-30T01:53:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2MDkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2NDUwMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552264501", "bodyText": "The description of return tag is incomplete -- i.e these are not all replicas, but either leader or follower replicas.", "author": "efeg", "createdAt": "2021-01-05T23:43:02Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/model/Broker.java", "diffHunk": "@@ -195,6 +195,28 @@ public int numReplicasOfTopicInBroker(String topic) {\n     return topicReplicas == null ? 0 : topicReplicas.size();\n   }\n \n+  /**\n+   * Get number of either leader replicas or follower replicas from the given topic in this broker\n+   *\n+   * @param topic Topic for which the replica count will be returned.\n+   * @param countOnlyLeaderReplica Count only leader replicas if {@code true} and count only follower replicas if\n+   * {@code false}\n+   * @return The number of replicas from the given topic in this broker.", "originalCommit": "e6bcc68722644fdfd8063ef0cf8fe892716fe5c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2NzA2Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552267066", "bodyText": "Why does this function return a list of replicas rather than a set of replicas for each topic? Does the preferred order of replicas matter (if so it should be documented in the javadoc)?", "author": "efeg", "createdAt": "2021-01-05T23:48:21Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/model/ClusterModel.java", "diffHunk": "@@ -263,6 +263,19 @@ public Partition partition(TopicPartition tp) {\n     return _partitionsByTopicPartition.values().stream().map(Partition::leader).collect(Collectors.toSet());\n   }\n \n+  /**\n+   * @return A map from topic names to all replicas of each topic\n+   */\n+  public Map<String, List<Replica>> allReplicasOfTopics(Set<String> topicNames) {\n+    Map<String, List<Replica>> replicasByTopicNames = new HashMap<>(topicNames.size());\n+    _partitionsByTopicPartition.forEach((topicPartition, partition) -> {\n+      if (topicNames.contains(topicPartition.topic())) {\n+        replicasByTopicNames.computeIfAbsent(topicPartition.topic(), topicName -> new ArrayList<>()).addAll(partition.replicas());\n+      }\n+    });\n+    return replicasByTopicNames;\n+  }\n+", "originalCommit": "e6bcc68722644fdfd8063ef0cf8fe892716fe5c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE3MzMzOA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567173338", "bodyText": "The order does not matter. I will use a set instead of a list", "author": "Lincong", "createdAt": "2021-01-30T01:18:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2NzA2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2ODU5OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552268599", "bodyText": "Missing JavaDoc tag for topicNames.\nCan we simplify name allReplicasOfTopics -> replicasOf?", "author": "efeg", "createdAt": "2021-01-05T23:50:41Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/model/ClusterModel.java", "diffHunk": "@@ -263,6 +263,19 @@ public Partition partition(TopicPartition tp) {\n     return _partitionsByTopicPartition.values().stream().map(Partition::leader).collect(Collectors.toSet());\n   }\n \n+  /**\n+   * @return A map from topic names to all replicas of each topic\n+   */\n+  public Map<String, List<Replica>> allReplicasOfTopics(Set<String> topicNames) {", "originalCommit": "e6bcc68722644fdfd8063ef0cf8fe892716fe5c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI3MzE3MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552273171", "bodyText": "Bad indentation.", "author": "efeg", "createdAt": "2021-01-06T00:05:40Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/AddBrokersRunnable.java", "diffHunk": "@@ -103,7 +103,7 @@ protected OptimizerResult workWithClusterModel() throws KafkaCruiseControlExcept\n                                                                          _dryRun,\n                                                                          _excludeRecentlyDemotedBrokers,\n                                                                          _excludeRecentlyRemovedBrokers,\n-                                                                         _excludedTopics,\n+        _excludedTopics,", "originalCommit": "e6bcc68722644fdfd8063ef0cf8fe892716fe5c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI3MzIxMA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552273210", "bodyText": "Bad indentation.", "author": "efeg", "createdAt": "2021-01-06T00:05:44Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/DemoteBrokerRunnable.java", "diffHunk": "@@ -169,7 +169,7 @@ protected OptimizerResult workWithClusterModel() throws KafkaCruiseControlExcept\n                                                                          _dryRun,\n                                                                          _excludeRecentlyDemotedBrokers,\n                                                                          _excludeRecentlyRemovedBrokers,\n-                                                                         _excludedTopics,\n+        _excludedTopics,", "originalCommit": "e6bcc68722644fdfd8063ef0cf8fe892716fe5c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI3MzIzNg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552273236", "bodyText": "Bad indentation.", "author": "efeg", "createdAt": "2021-01-06T00:05:49Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/FixOfflineReplicasRunnable.java", "diffHunk": "@@ -87,7 +87,7 @@ protected OptimizerResult workWithClusterModel() throws KafkaCruiseControlExcept\n                                                                          _dryRun,\n                                                                          _excludeRecentlyDemotedBrokers,\n                                                                          _excludeRecentlyRemovedBrokers,\n-                                                                         _excludedTopics,\n+        _excludedTopics,", "originalCommit": "e6bcc68722644fdfd8063ef0cf8fe892716fe5c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI3MzI3Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552273272", "bodyText": "Bad indentation.", "author": "efeg", "createdAt": "2021-01-06T00:05:53Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/ProposalsRunnable.java", "diffHunk": "@@ -105,7 +105,7 @@ protected OptimizerResult workWithClusterModel() throws KafkaCruiseControlExcept\n                                                                          _dryRun,\n                                                                          _excludeRecentlyDemotedBrokers,\n                                                                          _excludeRecentlyRemovedBrokers,\n-                                                                         _excludedTopics,\n+        _excludedTopics,", "originalCommit": "e6bcc68722644fdfd8063ef0cf8fe892716fe5c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI3MzcwNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552273705", "bodyText": "I suspect the IDE has changed this automatically -- can we please check the diff before submitting a PR?", "author": "efeg", "createdAt": "2021-01-06T00:07:15Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/ProposalsRunnable.java", "diffHunk": "@@ -120,8 +120,7 @@ protected OptimizerResult workWithoutClusterModel() throws KafkaCruiseControlExc\n   @Override\n   protected boolean shouldWorkWithClusterModel() {\n     return _kafkaCruiseControl.ignoreProposalCache(_goals,\n-                                                   _combinedCompletenessRequirements,\n-                                                   _excludedTopics,\n+                                                   _combinedCompletenessRequirements, _excludedTopics,", "originalCommit": "e6bcc68722644fdfd8063ef0cf8fe892716fe5c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI3Mzc2NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552273765", "bodyText": "Bad indentation", "author": "efeg", "createdAt": "2021-01-06T00:07:26Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/RemoveBrokersRunnable.java", "diffHunk": "@@ -106,7 +106,7 @@ protected OptimizerResult workWithClusterModel() throws KafkaCruiseControlExcept\n                                                                          _dryRun,\n                                                                          _excludeRecentlyDemotedBrokers,\n                                                                          _excludeRecentlyRemovedBrokers,\n-                                                                         _excludedTopics,\n+        _excludedTopics,", "originalCommit": "e6bcc68722644fdfd8063ef0cf8fe892716fe5c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI3MzgwMA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552273800", "bodyText": "Bad indentation", "author": "efeg", "createdAt": "2021-01-06T00:07:31Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/UpdateTopicConfigurationRunnable.java", "diffHunk": "@@ -180,7 +180,7 @@ protected OptimizerResult workWithClusterModel() throws KafkaCruiseControlExcept\n                                                                          _dryRun,\n                                                                          _excludeRecentlyDemotedBrokers,\n                                                                          _excludeRecentlyRemovedBrokers,\n-                                                                         _excludedTopics,\n+        _excludedTopics,", "originalCommit": "e6bcc68722644fdfd8063ef0cf8fe892716fe5c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI3NDE1Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552274157", "bodyText": "Redundant space in Copyright statement.", "author": "efeg", "createdAt": "2021-01-06T00:08:48Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,568 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ *", "originalCommit": "e6bcc68722644fdfd8063ef0cf8fe892716fe5c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI4NjkxOA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r552286918", "bodyText": "Are there any possible cases, where this else branch can ever be executed?\n-- i.e. wouldn't _balancingConstraint always be null when the constructor is being executed?\nSo does that mean any instantiation of this goal for regular requests (i.e. this is the constructor used for all user requests and self-healing actions) or unit tests does not work because _hasTopicsWithMinLeadersPerBrokerPattern is always false?\nTo mitigate this issue, please instantiate _hasTopicsWithMinLeadersPerBrokerPattern in initGoalState.", "author": "efeg", "createdAt": "2021-01-06T00:28:12Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,568 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ *\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at minimum number (specified by \"min.topic.leaders.per.broker\" config\n+ * property) of leader replica of each topic in a configured set of topics (specified by \"topics.with.min.leaders.per.broker\"\n+ * config property).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private final boolean _hasTopicsWithMinLeadersPerBrokerPattern;\n+\n+  /**\n+   * This constructor is required for unit test\n+   */\n+  public MinTopicLeadersPerBrokerGoal() {\n+    if (_balancingConstraint == null) {\n+      _hasTopicsWithMinLeadersPerBrokerPattern = false;\n+    } else {\n+      _hasTopicsWithMinLeadersPerBrokerPattern =\n+          !_balancingConstraint.topicsWithMinLeadersPerBrokerPattern().pattern().isEmpty();\n+    }", "originalCommit": "e6bcc68722644fdfd8063ef0cf8fe892716fe5c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fbe88b534592d3c0c8974939dc820af01ac6f7e6", "url": "https://github.com/linkedin/cruise-control/commit/fbe88b534592d3c0c8974939dc820af01ac6f7e6", "message": "[WIP] Rebased on the master branch", "committedDate": "2021-01-19T00:32:49Z", "type": "forcePushed"}, {"oid": "92fb66d47824e643f2a581ca928be62cce380d4a", "url": "https://github.com/linkedin/cruise-control/commit/92fb66d47824e643f2a581ca928be62cce380d4a", "message": "[WIP] Add a small optimization", "committedDate": "2021-01-21T06:41:19Z", "type": "forcePushed"}, {"oid": "a509d6977a2831787c5548c78f137583213ab685", "url": "https://github.com/linkedin/cruise-control/commit/a509d6977a2831787c5548c78f137583213ab685", "message": "Add a hard goald named MinTopicLeadersPerBrokerGoal", "committedDate": "2021-01-30T00:13:42Z", "type": "commit"}, {"oid": "a509d6977a2831787c5548c78f137583213ab685", "url": "https://github.com/linkedin/cruise-control/commit/a509d6977a2831787c5548c78f137583213ab685", "message": "Add a hard goald named MinTopicLeadersPerBrokerGoal", "committedDate": "2021-01-30T00:13:42Z", "type": "forcePushed"}, {"oid": "6e5dcf7dd14191aefd1203022aba833bb344f3ca", "url": "https://github.com/linkedin/cruise-control/commit/6e5dcf7dd14191aefd1203022aba833bb344f3ca", "message": "Fix some small issues", "committedDate": "2021-01-30T00:54:37Z", "type": "commit"}, {"oid": "2a7a1749bef01090ec2ef72efc96c3b6b182b7d2", "url": "https://github.com/linkedin/cruise-control/commit/2a7a1749bef01090ec2ef72efc96c3b6b182b7d2", "message": "Fix indentation issues", "committedDate": "2021-01-30T01:05:32Z", "type": "commit"}, {"oid": "c6ccb9183b2f41160ceb17e3223487d4ba28732a", "url": "https://github.com/linkedin/cruise-control/commit/c6ccb9183b2f41160ceb17e3223487d4ba28732a", "message": "Fix small issues", "committedDate": "2021-01-30T01:23:23Z", "type": "commit"}, {"oid": "672c1740eedd4f9f546b347ddf4e7c287dd60d6a", "url": "https://github.com/linkedin/cruise-control/commit/672c1740eedd4f9f546b347ddf4e7c287dd60d6a", "message": "Fix an unresolved issue", "committedDate": "2021-01-30T01:46:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE3ODQ5NA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567178494", "bodyText": "moves has at minimum number -> moves has at least the minimum number", "author": "efeg", "createdAt": "2021-01-30T01:51:21Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,543 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at minimum number (specified by \"min.topic.leaders.per.broker\" config", "originalCommit": "672c1740eedd4f9f546b347ddf4e7c287dd60d6a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE3ODcyMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567178721", "bodyText": "I believe this is not just required for unit test -- also required for regular use case. Can we remove or fix this comment?", "author": "efeg", "createdAt": "2021-01-30T01:53:24Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,543 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at minimum number (specified by \"min.topic.leaders.per.broker\" config\n+ * property) of leader replica of each topic in a configured set of topics (specified by \"topics.with.min.leaders.per.broker\"\n+ * config property).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+\n+  /**\n+   * This constructor is required for unit test", "originalCommit": "672c1740eedd4f9f546b347ddf4e7c287dd60d6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4MzQ2Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567183466", "bodyText": "Comment removed", "author": "Lincong", "createdAt": "2021-01-30T02:29:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE3ODcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE3ODkxMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567178911", "bodyText": "have a minimum number -> have at least a minimum number", "author": "efeg", "createdAt": "2021-01-30T01:54:47Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,543 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at minimum number (specified by \"min.topic.leaders.per.broker\" config\n+ * property) of leader replica of each topic in a configured set of topics (specified by \"topics.with.min.leaders.per.broker\"\n+ * config property).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+\n+  /**\n+   * This constructor is required for unit test\n+   */\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have a minimum number", "originalCommit": "672c1740eedd4f9f546b347ddf4e7c287dd60d6a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4MDYyMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567180621", "bodyText": "From our earlier discussion, I remember that doing a pattern match is an expensive operation. Can be more efficient by doing the following:\n\nIn initGoalState method of this goal, calculate the set of all topics relevant to this goal (see KafkaCruiseControl#excludedTopics(ClusterModel, Pattern) regarding how this can ben done),\nthen keep the result in a local hashset.\nIn places, where the check is relevant (e.g. in actionAcceptance), just use set,contains().", "author": "efeg", "createdAt": "2021-01-30T02:06:23Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,543 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at minimum number (specified by \"min.topic.leaders.per.broker\" config\n+ * property) of leader replica of each topic in a configured set of topics (specified by \"topics.with.min.leaders.per.broker\"\n+ * config property).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+\n+  /**\n+   * This constructor is required for unit test\n+   */\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!topicInterestedByThisGoal(action.topic()) || !topicsWithMinLeadersPerBrokerNames(clusterModel).contains(action.topic())) {\n+      // Always accept balancing action on topics that are not of the interest of this goal\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (srcReplicaToSwap.isLeader() == dstReplicaToSwap.isLeader()) {\n+      return ACCEPT;\n+    }\n+    if (srcReplicaToSwap.isLeader()) {\n+      return doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) ? REPLICA_REJECT : ACCEPT;\n+    } else { // dstReplicaToSwap.isLeader()\n+      return doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap) ? REPLICA_REJECT : ACCEPT;\n+    }\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker =\n+        replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(replicaToBeRemoved.topicPartition().topic());\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (!hasTopicsWithMinLeadersPerBrokerPattern()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(clusterModel, optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    // Sort leader replicas for each broker based on resource utilization.\n+    new SortedReplicasHelper().addPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants())\n+                              .trackSortedReplicasFor(replicaSortName(this, false, false), clusterModel);\n+  }\n+\n+  private Set<String> topicsWithMinLeadersPerBrokerNames(ClusterModel clusterModel) {\n+    if (!hasTopicsWithMinLeadersPerBrokerPattern()) {\n+      return Collections.emptySet(); // Avoid running unnecessary regex pattern matching to save CPU cycles\n+    }\n+    return Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel.topics());\n+  }\n+\n+  private boolean hasTopicsWithMinLeadersPerBrokerPattern() {\n+    return !_balancingConstraint.topicsWithMinLeadersPerBrokerPattern().pattern().isEmpty();\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(ClusterModel clusterModel,\n+                                                               OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<String> mustHaveLeaderReplicaPerBrokerTopicNames = topicsWithMinLeadersPerBrokerNames(clusterModel);\n+    if (mustHaveLeaderReplicaPerBrokerTopicNames.isEmpty() || optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    List<String> shouldNotBeExcludedTopics = new ArrayList<>();\n+    mustHaveLeaderReplicaPerBrokerTopicNames.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies\"\n+          + \"a config error. Topics should not be excluded=[%s]\", String.join(\", \", shouldNotBeExcludedTopics)));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderReplicaToDistribute(ClusterModel clusterModel,\n+                                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<String> mustHaveLeaderReplicaPerBrokerTopics = topicsWithMinLeadersPerBrokerNames(clusterModel);\n+    if (mustHaveLeaderReplicaPerBrokerTopics.isEmpty()) {\n+      return;\n+    }\n+    Map<String, Set<Replica>> replicasByTopicNames = clusterModel.replicasOf(mustHaveLeaderReplicaPerBrokerTopics);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleToHaveLeaderReplicaBrokers(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderReplicaCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Set<Replica>> replicasByTopicName : replicasByTopicNames.entrySet()) {\n+      int totalLeaderReplicaCountForTopic = countLeaderReplicas(replicasByTopicName.getValue());\n+      if (totalLeaderReplicaCountForTopic < totalMinimumLeaderReplicaCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader \"\n+                    + \"replica count %d for topic %s.\",\n+                totalLeaderReplicaCountForTopic, eligibleBrokersForLeadership.size(),\n+                totalLeaderReplicaCountForTopic, replicasByTopicName.getKey()));\n+      }\n+    }\n+  }\n+\n+  private int countLeaderReplicas(Collection<Replica> replicas) {\n+    int leaderReplicaCount = 0;\n+    for (Replica replica : replicas) {\n+      if (replica.isLeader()) {\n+        leaderReplicaCount++;\n+      }\n+    }\n+    return leaderReplicaCount;\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (!topicInterestedByThisGoal(action.topic()) || !topicsWithMinLeadersPerBrokerNames(clusterModel).contains(action.topic())) {\n+      // Always self-satisfied on topics that are not of the interest of this goal\n+      return true;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+        Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+        if (!replicaToBeMoved.isLeader()) {\n+          return true; // Move a follower replica of a topic of this goal's interest is always self-satisfied since it does not matter\n+        }\n+        return isSelfSatisfiedToMoveOneLeaderReplica(sourceBroker,\n+                                                     clusterModel.broker(action.destinationBrokerId()),\n+                                                     action.topic());\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica sourceReplica = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica destinationReplica = clusterModel.broker(action.destinationBrokerId()).replica(action.topicPartition());\n+        if (sourceReplica.isLeader() == destinationReplica.isLeader()) {\n+          // Swapping either 2 leader replicas or 2 follower replicas has no effect on this goal\n+          return true;\n+        }\n+        // At this point, one replica must be leader and the other must be follower\n+        if (sourceReplica.isLeader()) {\n+          return isSelfSatisfiedToMoveOneLeaderReplica(clusterModel.broker(action.sourceBrokerId()),\n+                                                       clusterModel.broker(action.destinationBrokerId()),\n+                                                       action.topic());\n+        }\n+        // The replica on the destination broker is a leader replica\n+        return isSelfSatisfiedToMoveOneLeaderReplica(clusterModel.broker(action.destinationBrokerId()),\n+                                                     clusterModel.broker(action.sourceBrokerId()),\n+                                                     action.topic());\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private boolean topicInterestedByThisGoal(String topicName) {\n+    if (_balancingConstraint.topicsWithMinLeadersPerBrokerPattern().pattern().isEmpty()) {\n+      return false; // No topic is of this goal's interest\n+    }\n+    return _balancingConstraint.topicsWithMinLeadersPerBrokerPattern().matcher(topicName).matches();\n+  }", "originalCommit": "672c1740eedd4f9f546b347ddf4e7c287dd60d6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4MjcwMg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567182702", "bodyText": "Good idea", "author": "Lincong", "createdAt": "2021-01-30T02:23:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4MDYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4MTEwMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567181101", "bodyText": "This should be cached and the response should be used wherever needed (please see earlier comment on the changes on init function)", "author": "efeg", "createdAt": "2021-01-30T02:09:49Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,543 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at minimum number (specified by \"min.topic.leaders.per.broker\" config\n+ * property) of leader replica of each topic in a configured set of topics (specified by \"topics.with.min.leaders.per.broker\"\n+ * config property).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+\n+  /**\n+   * This constructor is required for unit test\n+   */\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!topicInterestedByThisGoal(action.topic()) || !topicsWithMinLeadersPerBrokerNames(clusterModel).contains(action.topic())) {\n+      // Always accept balancing action on topics that are not of the interest of this goal\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (srcReplicaToSwap.isLeader() == dstReplicaToSwap.isLeader()) {\n+      return ACCEPT;\n+    }\n+    if (srcReplicaToSwap.isLeader()) {\n+      return doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) ? REPLICA_REJECT : ACCEPT;\n+    } else { // dstReplicaToSwap.isLeader()\n+      return doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap) ? REPLICA_REJECT : ACCEPT;\n+    }\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker =\n+        replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(replicaToBeRemoved.topicPartition().topic());\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (!hasTopicsWithMinLeadersPerBrokerPattern()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(clusterModel, optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    // Sort leader replicas for each broker based on resource utilization.\n+    new SortedReplicasHelper().addPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants())\n+                              .trackSortedReplicasFor(replicaSortName(this, false, false), clusterModel);\n+  }\n+\n+  private Set<String> topicsWithMinLeadersPerBrokerNames(ClusterModel clusterModel) {\n+    if (!hasTopicsWithMinLeadersPerBrokerPattern()) {\n+      return Collections.emptySet(); // Avoid running unnecessary regex pattern matching to save CPU cycles\n+    }\n+    return Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel.topics());", "originalCommit": "672c1740eedd4f9f546b347ddf4e7c287dd60d6a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f57149aaf6ecf5d395709efa478f089a2c42f8d5", "url": "https://github.com/linkedin/cruise-control/commit/f57149aaf6ecf5d395709efa478f089a2c42f8d5", "message": "Adopt optimization", "committedDate": "2021-01-30T02:28:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4Mjc4OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567182789", "bodyText": "Can we simplify the content of this function as follows?\nreturn (int) replicasOfTopicInBroker(topic).stream().filter(r -> r.isLeader() == countLeaderReplica).count();", "author": "efeg", "createdAt": "2021-01-30T02:24:14Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/model/Broker.java", "diffHunk": "@@ -187,14 +187,56 @@ public Replica replica(TopicPartition tp) {\n   /**\n    * Get number of replicas from the given topic in this broker.\n    *\n-   * @param topic Topic for which the replica count will be returned.\n+   * @param topic Topic for which both the leader and follower replica count will be returned.\n    * @return The number of replicas from the given topic in this broker.\n    */\n   public int numReplicasOfTopicInBroker(String topic) {\n     Map<Integer, Replica> topicReplicas = _topicReplicas.get(topic);\n     return topicReplicas == null ? 0 : topicReplicas.size();\n   }\n \n+  /**\n+   * Get number of only leader replicas from the given topic in this broker.\n+   *\n+   * @param topicName Topic for which the replica count will be returned.\n+   * @return The number of leader replicas from the given topic in this broker.\n+   */\n+  public int numLeaderReplicasOfTopicInBroker(String topicName) {\n+    return numReplicasOfTopicInBroker(topicName, true);\n+  }\n+\n+  /**\n+   * Get number of only follower replicas from the given topic in this broker.\n+   *\n+   * @param topicName Topic for which the replica count will be returned.\n+   * @return The number of replicas from the given topic in this broker.\n+   */\n+  public int numFollowerReplicasOfTopicInBroker(String topicName) {\n+    return numReplicasOfTopicInBroker(topicName, false);\n+  }\n+\n+  /**\n+   * Get number of either leader or follower replicas from the given topic in this broker\n+   *\n+   * @param topic Topic for which either the leader or the follower replica count will be returned.\n+   * @param countLeaderReplica Count leader replicas if {@code true} and count follower replicas if\n+   * {@code false}\n+   * @return The number of replicas from the given topic in this broker.\n+   */\n+  private int numReplicasOfTopicInBroker(String topic, boolean countLeaderReplica) {\n+    Map<Integer, Replica> topicReplicas = _topicReplicas.get(topic);\n+    if (topicReplicas == null) {\n+      return 0;\n+    }\n+    int replicaCount = 0;\n+    for (Replica replica : topicReplicas.values()) {\n+      if (replica.isLeader() == countLeaderReplica) {\n+        replicaCount++;\n+      }\n+    }\n+    return replicaCount;", "originalCommit": "672c1740eedd4f9f546b347ddf4e7c287dd60d6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4MzYyOA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567183628", "bodyText": "Cool!", "author": "Lincong", "createdAt": "2021-01-30T02:30:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4Mjc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4Mjk4Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567182982", "bodyText": "Can we drop this unused function from the class?", "author": "efeg", "createdAt": "2021-01-30T02:26:11Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/model/Broker.java", "diffHunk": "@@ -187,14 +187,56 @@ public Replica replica(TopicPartition tp) {\n   /**\n    * Get number of replicas from the given topic in this broker.\n    *\n-   * @param topic Topic for which the replica count will be returned.\n+   * @param topic Topic for which both the leader and follower replica count will be returned.\n    * @return The number of replicas from the given topic in this broker.\n    */\n   public int numReplicasOfTopicInBroker(String topic) {\n     Map<Integer, Replica> topicReplicas = _topicReplicas.get(topic);\n     return topicReplicas == null ? 0 : topicReplicas.size();\n   }\n \n+  /**\n+   * Get number of only leader replicas from the given topic in this broker.\n+   *\n+   * @param topicName Topic for which the replica count will be returned.\n+   * @return The number of leader replicas from the given topic in this broker.\n+   */\n+  public int numLeaderReplicasOfTopicInBroker(String topicName) {\n+    return numReplicasOfTopicInBroker(topicName, true);\n+  }\n+\n+  /**\n+   * Get number of only follower replicas from the given topic in this broker.\n+   *\n+   * @param topicName Topic for which the replica count will be returned.\n+   * @return The number of replicas from the given topic in this broker.\n+   */\n+  public int numFollowerReplicasOfTopicInBroker(String topicName) {\n+    return numReplicasOfTopicInBroker(topicName, false);\n+  }", "originalCommit": "672c1740eedd4f9f546b347ddf4e7c287dd60d6a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fbf8d1fc016b8fdd3536ab53f7d8507d93b2f9a9", "url": "https://github.com/linkedin/cruise-control/commit/fbf8d1fc016b8fdd3536ab53f7d8507d93b2f9a9", "message": "Fix issues", "committedDate": "2021-01-30T02:32:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4NDkwMA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567184900", "bodyText": "Utils.getTopicNamesMatchedWithPattern(...) will also perform the empty pattern check and return an empty set. Can we eliminate repeated check for empty pattern?", "author": "efeg", "createdAt": "2021-01-30T02:43:10Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,529 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by \"min.topic.leaders.per.broker\" config\n+ * property) of leader replica of each topic in a configured set of topics (specified by \"topics.with.min.leaders.per.broker\"\n+ * config property).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!_mustHaveLeaderReplicaPerBrokerTopics.contains(action.topic())) {\n+      // Always accept balancing action on topics that are not of the interest of this goal\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (srcReplicaToSwap.isLeader() == dstReplicaToSwap.isLeader()) {\n+      return ACCEPT;\n+    }\n+    if (srcReplicaToSwap.isLeader()) {\n+      return doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) ? REPLICA_REJECT : ACCEPT;\n+    } else { // dstReplicaToSwap.isLeader()\n+      return doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap) ? REPLICA_REJECT : ACCEPT;\n+    }\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker =\n+        replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(replicaToBeRemoved.topicPartition().topic());\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_balancingConstraint.topicsWithMinLeadersPerBrokerPattern().pattern().isEmpty()) {\n+      _mustHaveLeaderReplicaPerBrokerTopics = Collections.emptySet();\n+      return;\n+    }\n+    _mustHaveLeaderReplicaPerBrokerTopics = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel.topics()));", "originalCommit": "fbf8d1fc016b8fdd3536ab53f7d8507d93b2f9a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4Njc2MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567186761", "bodyText": "The empty pattern check in this getTopicNamesMatchedWithPattern method is intentional. In case the caller pass in an empty pattern and a long list of topic name. This empty check will catch it.", "author": "Lincong", "createdAt": "2021-01-30T03:00:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4NDkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE5ODQ4MA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567198480", "bodyText": "I don't recommend a change in Utils.getTopicNamesMatchedWithPattern(...). I refer to the preceding if clause.", "author": "efeg", "createdAt": "2021-01-30T05:00:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4NDkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE5ODY1MA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567198650", "bodyText": "If we remove the empty check before Utils.getTopicNamesMatchedWithPattern(...), this clusterModel.topics() method will be called and that will be a waste right?", "author": "Lincong", "createdAt": "2021-01-30T05:02:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4NDkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE5OTQ0MA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567199440", "bodyText": "I see -- so the reason why there is a duplicate check is to avoid a relatively more expensive call to clusterModel.topics() in case the pattern is empty.\nThanks for the clarification.", "author": "efeg", "createdAt": "2021-01-30T05:11:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4NDkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzIwNDI5NA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567204294", "bodyText": "Actually we can achieve this optimization w/o code duplication by using a Supplier<Set<String>> as the second parameter of Utils.getTopicNamesMatchedWithPattern(...).\nLazy evaluation ensures that the call for clusterModel.topics() be made only when needed.", "author": "efeg", "createdAt": "2021-01-30T06:06:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4NDkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzIxMTE2MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567211161", "bodyText": "Good idea. Fixed", "author": "Lincong", "createdAt": "2021-01-30T07:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4NDkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4NTA5OA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567185098", "bodyText": "Utils.getTopicNamesMatchedWithPattern(...) will also perform the empty pattern check and return an empty set. Can we eliminate repeated check for empty pattern?", "author": "efeg", "createdAt": "2021-01-30T02:44:20Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/GoalViolationDetector.java", "diffHunk": "@@ -246,10 +246,10 @@ protected void refreshBalancednessScore(Map<Boolean, List<String>> violatedGoals\n   }\n \n   protected Set<String> excludedTopics(ClusterModel clusterModel) {\n-    return clusterModel.topics()\n-        .stream()\n-        .filter(topic -> _excludedTopics.matcher(topic).matches())\n-        .collect(Collectors.toSet());\n+    if (_excludedTopics.pattern().isEmpty()) {\n+      return Collections.emptySet();\n+    }\n+    return Utils.getTopicNamesMatchedWithPattern(_excludedTopics, clusterModel.topics());", "originalCommit": "fbf8d1fc016b8fdd3536ab53f7d8507d93b2f9a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4NjgyNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567186825", "bodyText": "Same response as above", "author": "Lincong", "createdAt": "2021-01-30T03:00:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4NTA5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE5ODUxNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567198515", "bodyText": "Please see the response in the other comment.", "author": "efeg", "createdAt": "2021-01-30T05:00:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4NTA5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4NTM5OA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567185398", "bodyText": "Why do we use a list rather than a set? Does the order matter or do we expect to handle repeated entries?", "author": "efeg", "createdAt": "2021-01-30T02:47:24Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,529 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by \"min.topic.leaders.per.broker\" config\n+ * property) of leader replica of each topic in a configured set of topics (specified by \"topics.with.min.leaders.per.broker\"\n+ * config property).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!_mustHaveLeaderReplicaPerBrokerTopics.contains(action.topic())) {\n+      // Always accept balancing action on topics that are not of the interest of this goal\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (srcReplicaToSwap.isLeader() == dstReplicaToSwap.isLeader()) {\n+      return ACCEPT;\n+    }\n+    if (srcReplicaToSwap.isLeader()) {\n+      return doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) ? REPLICA_REJECT : ACCEPT;\n+    } else { // dstReplicaToSwap.isLeader()\n+      return doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap) ? REPLICA_REJECT : ACCEPT;\n+    }\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker =\n+        replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(replicaToBeRemoved.topicPartition().topic());\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_balancingConstraint.topicsWithMinLeadersPerBrokerPattern().pattern().isEmpty()) {\n+      _mustHaveLeaderReplicaPerBrokerTopics = Collections.emptySet();\n+      return;\n+    }\n+    _mustHaveLeaderReplicaPerBrokerTopics = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel.topics()));\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(clusterModel, optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    // Sort leader replicas for each broker based on resource utilization.\n+    new SortedReplicasHelper().addPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants())\n+                              .trackSortedReplicasFor(replicaSortName(this, false, false), clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(ClusterModel clusterModel,\n+                                                               OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty() || optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    List<String> shouldNotBeExcludedTopics = new ArrayList<>();", "originalCommit": "fbf8d1fc016b8fdd3536ab53f7d8507d93b2f9a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4NjkyMg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567186922", "bodyText": "I can change it to use a set", "author": "Lincong", "createdAt": "2021-01-30T03:02:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4NTM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4NjQzNg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567186436", "bodyText": "If this is a replica swap operation, then this check might miss destination topic that might be relevant to this goal. This may cause accepting a replica swap that it was supposed to reject.", "author": "efeg", "createdAt": "2021-01-30T02:57:39Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,529 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by \"min.topic.leaders.per.broker\" config\n+ * property) of leader replica of each topic in a configured set of topics (specified by \"topics.with.min.leaders.per.broker\"\n+ * config property).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!_mustHaveLeaderReplicaPerBrokerTopics.contains(action.topic())) {\n+      // Always accept balancing action on topics that are not of the interest of this goal\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (srcReplicaToSwap.isLeader() == dstReplicaToSwap.isLeader()) {\n+      return ACCEPT;\n+    }\n+    if (srcReplicaToSwap.isLeader()) {\n+      return doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) ? REPLICA_REJECT : ACCEPT;\n+    } else { // dstReplicaToSwap.isLeader()\n+      return doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap) ? REPLICA_REJECT : ACCEPT;\n+    }\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker =\n+        replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(replicaToBeRemoved.topicPartition().topic());\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_balancingConstraint.topicsWithMinLeadersPerBrokerPattern().pattern().isEmpty()) {\n+      _mustHaveLeaderReplicaPerBrokerTopics = Collections.emptySet();\n+      return;\n+    }\n+    _mustHaveLeaderReplicaPerBrokerTopics = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel.topics()));\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(clusterModel, optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    // Sort leader replicas for each broker based on resource utilization.\n+    new SortedReplicasHelper().addPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants())\n+                              .trackSortedReplicasFor(replicaSortName(this, false, false), clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(ClusterModel clusterModel,\n+                                                               OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty() || optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    List<String> shouldNotBeExcludedTopics = new ArrayList<>();\n+    _mustHaveLeaderReplicaPerBrokerTopics.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies\"\n+          + \"a config error. Topics should not be excluded=[%s]\", String.join(\", \", shouldNotBeExcludedTopics)));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderReplicaToDistribute(ClusterModel clusterModel,\n+                                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty()) {\n+      return;\n+    }\n+    Map<String, Set<Replica>> replicasByTopicNames = clusterModel.replicasOf(_mustHaveLeaderReplicaPerBrokerTopics);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleToHaveLeaderReplicaBrokers(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderReplicaCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Set<Replica>> replicasByTopicName : replicasByTopicNames.entrySet()) {\n+      int totalLeaderReplicaCountForTopic = countLeaderReplicas(replicasByTopicName.getValue());\n+      if (totalLeaderReplicaCountForTopic < totalMinimumLeaderReplicaCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader \"\n+                    + \"replica count %d for topic %s.\",\n+                totalLeaderReplicaCountForTopic, eligibleBrokersForLeadership.size(),\n+                totalLeaderReplicaCountForTopic, replicasByTopicName.getKey()));\n+      }\n+    }\n+  }\n+\n+  private int countLeaderReplicas(Collection<Replica> replicas) {\n+    int leaderReplicaCount = 0;\n+    for (Replica replica : replicas) {\n+      if (replica.isLeader()) {\n+        leaderReplicaCount++;\n+      }\n+    }\n+    return leaderReplicaCount;\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (!_mustHaveLeaderReplicaPerBrokerTopics.contains(action.topic())) {", "originalCommit": "fbf8d1fc016b8fdd3536ab53f7d8507d93b2f9a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzIwMjE1MA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567202150", "bodyText": "Thanks for pointing out this point. I assumed that the swap operation always swaps replicas of the same topic. So, I did not consider the case in which two to-be-swapped topics could be different.\nI add some logic to handle this case.", "author": "Lincong", "createdAt": "2021-01-30T05:42:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzE4NjQzNg=="}], "type": "inlineReview"}, {"oid": "b50d5e894a8b40e73e5a868d96c7833851b16482", "url": "https://github.com/linkedin/cruise-control/commit/b50d5e894a8b40e73e5a868d96c7833851b16482", "message": "Fix replica swap issues", "committedDate": "2021-01-30T05:45:36Z", "type": "commit"}, {"oid": "620e20903d1d4e627f0b378ad28becfda9358f3c", "url": "https://github.com/linkedin/cruise-control/commit/620e20903d1d4e627f0b378ad28becfda9358f3c", "message": "Add lazy eval for the getTopicNamesMatchedWithPattern method", "committedDate": "2021-01-30T07:22:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzMxMjg1Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567312857", "bodyText": "(This is a followup for the earlier comment #1429 (comment))\nCan we just call the following function first, then use _mustHaveLeaderReplicaPerBrokerTopics in a following if statement to see if it is empty?\n_mustHaveLeaderReplicaPerBrokerTopics = Collections.unmodifiableSet(Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n\nThis\n\neliminates code duplication and\nensures that if _mustHaveLeaderReplicaPerBrokerTopics is empty despite having a non-empty pattern, we terminate early.\n\nAm I missing something?", "author": "efeg", "createdAt": "2021-01-30T20:49:30Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by \"min.topic.leaders.per.broker\" config\n+ * property) of leader replica of each topic in a configured set of topics (specified by \"topics.with.min.leaders.per.broker\"\n+ * config property).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveLeaderReplicaPerBrokerTopics.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_balancingConstraint.topicsWithMinLeadersPerBrokerPattern().pattern().isEmpty()) {\n+      _mustHaveLeaderReplicaPerBrokerTopics = Collections.emptySet();\n+      return;\n+    }", "originalCommit": "620e20903d1d4e627f0b378ad28becfda9358f3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzMxOTU3Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567319572", "bodyText": "Good idea", "author": "Lincong", "createdAt": "2021-01-30T21:09:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzMxMjg1Nw=="}], "type": "inlineReview"}, {"oid": "7191c6eb4737d349858fbb4c7c7f76906f5c8892", "url": "https://github.com/linkedin/cruise-control/commit/7191c6eb4737d349858fbb4c7c7f76906f5c8892", "message": "Change the way of how _mustHaveLeaderReplicaPerBrokerTopics is initialized", "committedDate": "2021-01-30T21:10:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzUxNzU5OA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567517598", "bodyText": "Nit:\n\ntopics names -> topic names\n[Also applies to return description of minTopicLeadersPerBroker below] Can we capitalize the first letter of return description? -- i.e. -> Regex pattern of ...", "author": "efeg", "createdAt": "2021-02-01T01:17:02Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/BalancingConstraint.java", "diffHunk": "@@ -204,6 +212,25 @@ public double lowUtilizationThreshold(Resource resource) {\n     return _lowUtilizationThreshold.get(resource);\n   }\n \n+  /**\n+   * Get the regex pattern of topics with a minimum number of leaders on brokers that are not excluded for replica move.\n+   *\n+   * @return regex pattern of topics names", "originalCommit": "7191c6eb4737d349858fbb4c7c7f76906f5c8892", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzUyMjM0NA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567522344", "bodyText": "Nit: 2020 -> 2021", "author": "efeg", "createdAt": "2021-02-01T01:41:59Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/common/Utils.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.", "originalCommit": "7191c6eb4737d349858fbb4c7c7f76906f5c8892", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzUyMjY5MA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567522690", "bodyText": "Nit: (for consistency with goal name and conciseness) _mustHaveLeaderReplicaPerBrokerTopics -> _mustHaveTopicLeadersPerBroker", "author": "efeg", "createdAt": "2021-02-01T01:43:55Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by \"min.topic.leaders.per.broker\" config\n+ * property) of leader replica of each topic in a configured set of topics (specified by \"topics.with.min.leaders.per.broker\"\n+ * config property).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;", "originalCommit": "7191c6eb4737d349858fbb4c7c7f76906f5c8892", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzUyMzAwNA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567523004", "bodyText": "Nit:\n\nmissing space before a config error.\nalso, would it help if this error message include the relevant config names to address the issue?", "author": "efeg", "createdAt": "2021-02-01T01:45:36Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by \"min.topic.leaders.per.broker\" config\n+ * property) of leader replica of each topic in a configured set of topics (specified by \"topics.with.min.leaders.per.broker\"\n+ * config property).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveLeaderReplicaPerBrokerTopics.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveLeaderReplicaPerBrokerTopics = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(clusterModel, optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    // Sort leader replicas for each broker based on resource utilization.\n+    new SortedReplicasHelper().addPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants())\n+                              .trackSortedReplicasFor(replicaSortName(this, false, false), clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(ClusterModel clusterModel,\n+                                                               OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty() || optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveLeaderReplicaPerBrokerTopics.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies\"\n+          + \"a config error. Topics should not be excluded=[%s]\", String.join(\", \", shouldNotBeExcludedTopics)));", "originalCommit": "7191c6eb4737d349858fbb4c7c7f76906f5c8892", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzYwMTE0Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567601142", "bodyText": "Good idea", "author": "Lincong", "createdAt": "2021-02-01T07:06:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzUyMzAwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzUyMzg5Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567523892", "bodyText": "This private function is called only from initGoalState, and it never calls this function if _mustHaveLeaderReplicaPerBrokerTopics.isEmpty() is true.\nSo this check seems redundant -- can we drop it?", "author": "efeg", "createdAt": "2021-02-01T01:49:39Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by \"min.topic.leaders.per.broker\" config\n+ * property) of leader replica of each topic in a configured set of topics (specified by \"topics.with.min.leaders.per.broker\"\n+ * config property).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveLeaderReplicaPerBrokerTopics.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveLeaderReplicaPerBrokerTopics = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(clusterModel, optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    // Sort leader replicas for each broker based on resource utilization.\n+    new SortedReplicasHelper().addPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants())\n+                              .trackSortedReplicasFor(replicaSortName(this, false, false), clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(ClusterModel clusterModel,\n+                                                               OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty() || optimizationOptions.excludedTopics().isEmpty()) {", "originalCommit": "7191c6eb4737d349858fbb4c7c7f76906f5c8892", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzYwMTc1Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567601753", "bodyText": "Redundant check dropped", "author": "Lincong", "createdAt": "2021-02-01T07:07:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzUyMzg5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzUyMzk1NA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567523954", "bodyText": "This private function is called only from initGoalState, and it never calls this function if _mustHaveLeaderReplicaPerBrokerTopics.isEmpty() is true.\nSo this check seems redundant -- can we drop it?", "author": "efeg", "createdAt": "2021-02-01T01:49:51Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by \"min.topic.leaders.per.broker\" config\n+ * property) of leader replica of each topic in a configured set of topics (specified by \"topics.with.min.leaders.per.broker\"\n+ * config property).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveLeaderReplicaPerBrokerTopics.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveLeaderReplicaPerBrokerTopics = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(clusterModel, optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    // Sort leader replicas for each broker based on resource utilization.\n+    new SortedReplicasHelper().addPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants())\n+                              .trackSortedReplicasFor(replicaSortName(this, false, false), clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(ClusterModel clusterModel,\n+                                                               OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty() || optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveLeaderReplicaPerBrokerTopics.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies\"\n+          + \"a config error. Topics should not be excluded=[%s]\", String.join(\", \", shouldNotBeExcludedTopics)));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderReplicaToDistribute(ClusterModel clusterModel,\n+                                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty()) {", "originalCommit": "7191c6eb4737d349858fbb4c7c7f76906f5c8892", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzYwMjE2OA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567602168", "bodyText": "Redundant check dropped", "author": "Lincong", "createdAt": "2021-02-01T07:09:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzUyMzk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzUyNjE4OA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567526188", "bodyText": "Nit: brokerIsEligibleToHaveAnyLeaderReplica -> isEligibleToHaveLeaders?", "author": "efeg", "createdAt": "2021-02-01T02:00:58Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by \"min.topic.leaders.per.broker\" config\n+ * property) of leader replica of each topic in a configured set of topics (specified by \"topics.with.min.leaders.per.broker\"\n+ * config property).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveLeaderReplicaPerBrokerTopics.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveLeaderReplicaPerBrokerTopics = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(clusterModel, optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    // Sort leader replicas for each broker based on resource utilization.\n+    new SortedReplicasHelper().addPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants())\n+                              .trackSortedReplicasFor(replicaSortName(this, false, false), clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(ClusterModel clusterModel,\n+                                                               OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty() || optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveLeaderReplicaPerBrokerTopics.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies\"\n+          + \"a config error. Topics should not be excluded=[%s]\", String.join(\", \", shouldNotBeExcludedTopics)));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderReplicaToDistribute(ClusterModel clusterModel,\n+                                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty()) {\n+      return;\n+    }\n+    Map<String, Set<Replica>> replicasByTopicNames = clusterModel.replicasOf(_mustHaveLeaderReplicaPerBrokerTopics);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleToHaveLeaderReplicaBrokers(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderReplicaCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Set<Replica>> replicasByTopicName : replicasByTopicNames.entrySet()) {\n+      int totalLeaderReplicaCountForTopic = countLeaderReplicas(replicasByTopicName.getValue());\n+      if (totalLeaderReplicaCountForTopic < totalMinimumLeaderReplicaCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader \"\n+                    + \"replica count %d for topic %s.\",\n+                totalLeaderReplicaCountForTopic, eligibleBrokersForLeadership.size(),\n+                totalLeaderReplicaCountForTopic, replicasByTopicName.getKey()));\n+      }\n+    }\n+  }\n+\n+  private int countLeaderReplicas(Collection<Replica> replicas) {\n+    int leaderReplicaCount = 0;\n+    for (Replica replica : replicas) {\n+      if (replica.isLeader()) {\n+        leaderReplicaCount++;\n+      }\n+    }\n+    return leaderReplicaCount;\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return true;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+        Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+        if (!replicaToBeMoved.isLeader()) {\n+          return true; // Move a follower replica of a topic of this goal's interest is always self-satisfied since it does not matter\n+        }\n+        return isSelfSatisfiedToMoveOneLeaderReplica(sourceBroker,\n+                                                     clusterModel.broker(action.destinationBrokerId()),\n+                                                     replicaToBeMoved);\n+      case INTER_BROKER_REPLICA_SWAP:\n+        return isSwapActionSelfSatisfied(clusterModel, action);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private boolean isSwapActionSelfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (action.balancingAction() != ActionType.INTER_BROKER_REPLICA_SWAP) {\n+      throw new IllegalArgumentException(\"Expected INTER_BROKER_REPLICA_SWAP. But got: \" + action.balancingAction());\n+    }\n+    Replica sourceReplica = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+    Replica destinationReplica = clusterModel.broker(action.destinationBrokerId()).replica(action.topicPartition());\n+    if (sourceReplica.isLeader() == destinationReplica.isLeader() && Objects.equals(action.topic(), action.destinationTopic())) {\n+      // Swapping either 2 leader replicas or 2 follower replicas of the same topic has no effect on this goal\n+      return true;\n+    }\n+    return isSelfSatisfiedToMoveOneLeaderReplica(clusterModel.broker(action.sourceBrokerId()),\n+                                                 clusterModel.broker(action.destinationBrokerId()),\n+                                                 sourceReplica)\n+           && isSelfSatisfiedToMoveOneLeaderReplica(clusterModel.broker(action.destinationBrokerId()),\n+                                                    clusterModel.broker(action.sourceBrokerId()),\n+                                                    destinationReplica);\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveLeaderReplicaPerBrokerTopics.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Check whether it is self-satisfied to move a leader replica of a topic with the given name from a the given source\n+   * broker to the given destination broker\n+   * @param sourceBroker the broker from which a leader replica is removed\n+   * @param destinationBroker the broker from which a leader replica is added\n+   * @param replicaToBeMoved replica to be moved from the source broker to the destination broker\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean isSelfSatisfiedToMoveOneLeaderReplica(Broker sourceBroker, Broker destinationBroker, Replica replicaToBeMoved) {\n+    if (!replicaToBeMoved.isLeader()) {\n+      return true;\n+    }\n+    String topicName = replicaToBeMoved.topicPartition().topic();\n+    if (!_mustHaveLeaderReplicaPerBrokerTopics.contains(topicName)) {\n+      return true;\n+    }\n+    // Moving a replica leadership from a not-alive broker to an alive broker is self-satisfied\n+    if (!sourceBroker.isAlive() && destinationBroker.isAlive()) {\n+      return true;\n+    }\n+    // Moving leader replica from more abundant broker could be considered as self-satisfied\n+    return sourceBroker.numLeaderReplicasOfTopicInBroker(topicName) > destinationBroker.numLeaderReplicasOfTopicInBroker(topicName);\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderReplicaOfTopics(clusterModel, optimizationOptions);\n+    finish();\n+  }\n+\n+  private void ensureBrokersAllHaveEnoughLeaderReplicaOfTopics(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    for (Broker broker : clusterModel.brokers()) {\n+      if (!brokerIsEligibleToHaveAnyLeaderReplica(broker, optimizationOptions)) {\n+        continue;\n+      }\n+      for (String mustHaveLeaderReplicaPerBrokerTopicName : _mustHaveLeaderReplicaPerBrokerTopics) {\n+        int leaderReplicaCount = broker.numLeaderReplicasOfTopicInBroker(mustHaveLeaderReplicaPerBrokerTopicName);\n+        if (leaderReplicaCount < minTopicLeadersPerBroker()) {\n+          throw new OptimizationFailureException(String.format(\"Broker %d does not have enough leader replica for topic %s. \"\n+              + \"Minimum required per-broker leader replica count %d. Actual broker leader replica count %d\",\n+              broker.id(), mustHaveLeaderReplicaPerBrokerTopicName, minTopicLeadersPerBroker(), leaderReplicaCount));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of the current goal and optimized goals.\n+   * @param broker         Broker to be balanced.\n+   * @param clusterModel   The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    LOG.debug(\"balancing broker {}, optimized goals = {}\", broker, optimizedGoals);\n+    moveAwayOfflineReplicas(broker, clusterModel, optimizedGoals, optimizationOptions);\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    if (!brokerIsEligibleToHaveAnyLeaderReplica(broker, optimizationOptions)) {\n+      return;\n+    }\n+    for (String topicMustHaveLeaderReplicaPerBroker : _mustHaveLeaderReplicaPerBrokerTopics) {\n+      maybeMoveLeaderReplicaOfTopicToBroker(topicMustHaveLeaderReplicaPerBroker, broker, clusterModel, optimizedGoals, optimizationOptions);\n+    }\n+  }\n+\n+  private void maybeMoveLeaderReplicaOfTopicToBroker(String topicMustHaveLeaderReplicaPerBroker,\n+                                                     Broker broker,\n+                                                     ClusterModel clusterModel,\n+                                                     Set<Goal> optimizedGoals,\n+                                                     OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (brokerHasSufficientLeaderReplicasOfTopic(broker, topicMustHaveLeaderReplicaPerBroker)) {\n+      return; // This broker has enough leader replica(s)\n+    }\n+    // Try to elect follower replica(s) of the interested topic on this broker to be leader\n+    Set<Replica> followerReplicas = broker.replicas().stream()\n+                                          .filter(\n+                                              replica -> !replica.isLeader()\n+                                                         && replica.topicPartition().topic().equals(topicMustHaveLeaderReplicaPerBroker))\n+                                          .collect(Collectors.toSet());\n+\n+    for (Replica followerReplica : followerReplicas) {\n+      Replica leaderReplica = leaderReplicaOfTopicPartition(clusterModel, followerReplica.topicPartition());\n+      if (leaderReplica == null) {\n+        LOG.warn(\"No leader replica for {}\", followerReplica.topicPartition());\n+      } else {\n+        if (leaderReplica.broker().id() != broker.id()\n+            && leaderReplica.broker().numLeaderReplicasOfTopicInBroker(topicMustHaveLeaderReplicaPerBroker) > minTopicLeadersPerBroker()) {\n+          maybeApplyBalancingAction(clusterModel, leaderReplica, Collections.singleton(broker),\n+                                    LEADERSHIP_MOVEMENT, optimizedGoals, optimizationOptions);\n+        }\n+      }\n+      if (brokerHasSufficientLeaderReplicasOfTopic(broker, topicMustHaveLeaderReplicaPerBroker)) {\n+        return; // This broker satisfies this goal\n+      }\n+    }\n+\n+    // Try to move leader replica(s) of the interested topic from other brokers to this broker\n+    PriorityQueue<Broker> brokersWithExcessiveLeaderReplicaToMove =\n+        getBrokersWithExcessiveLeaderReplicaToMove(topicMustHaveLeaderReplicaPerBroker, clusterModel, broker);\n+\n+    while (!brokersWithExcessiveLeaderReplicaToMove.isEmpty()) {\n+      Broker brokerWithExcessiveLeaderReplicaToMove = brokersWithExcessiveLeaderReplicaToMove.poll();\n+      List<Replica> leaderReplicasOfTopic = brokerWithExcessiveLeaderReplicaToMove.replicas().stream()\n+                                                                                  .filter(replica ->\n+                                                                                              replica.isLeader()\n+                                                                                              && replica.topicPartition()\n+                                                                                                        .topic()\n+                                                                                                        .equals(topicMustHaveLeaderReplicaPerBroker))\n+                                                                                  .collect(Collectors.toList());\n+      boolean leaderReplicaMoved = false;\n+      for (Replica leaderReplicaOfTopic : leaderReplicasOfTopic) {\n+        Broker destinationBroker = maybeApplyBalancingAction(clusterModel, leaderReplicaOfTopic, Collections.singleton(broker),\n+                                                             INTER_BROKER_REPLICA_MOVEMENT, optimizedGoals, optimizationOptions);\n+        if (destinationBroker != null) {\n+          leaderReplicaMoved = true;\n+          break; // Successfully move one leader replica\n+        }\n+      }\n+      if (leaderReplicaMoved) {\n+        if (brokerHasSufficientLeaderReplicasOfTopic(broker, topicMustHaveLeaderReplicaPerBroker)) {\n+          return; // This broker satisfies this goal\n+        }\n+        if (brokerHasExcessiveLeaderReplicasOfTopic(topicMustHaveLeaderReplicaPerBroker, brokerWithExcessiveLeaderReplicaToMove)) {\n+          brokersWithExcessiveLeaderReplicaToMove.add(brokerWithExcessiveLeaderReplicaToMove);\n+        }\n+      }\n+    }\n+\n+    if (!brokerHasSufficientLeaderReplicasOfTopic(broker, topicMustHaveLeaderReplicaPerBroker)) {\n+      throw new OptimizationFailureException(String.format(\"Cannot make broker %d have at least %d leader replica(s) of topic %s\",\n+                                                           broker.id(),\n+                                                           minTopicLeadersPerBroker(),\n+                                                           topicMustHaveLeaderReplicaPerBroker));\n+    }\n+  }\n+\n+  private boolean brokerHasSufficientLeaderReplicasOfTopic(Broker broker, String topicName) {\n+    return broker.numLeaderReplicasOfTopicInBroker(topicName) >= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This method creates a priority queue which has the broker with the most number of leader replicas of a given topic at the top of queue\n+   * @param topicName name of the given topic\n+   * @param clusterModel cluster model\n+   * @param originalBroker original broker which needs to be excluded from the priority queue\n+   * @return a priority queue which has the broker with the most number of leader replicas of a given topic at the top of queue\n+   */\n+  private PriorityQueue<Broker> getBrokersWithExcessiveLeaderReplicaToMove(String topicName, ClusterModel clusterModel, Broker originalBroker) {\n+    PriorityQueue<Broker> brokersWithExcessiveLeaderReplicaToMove = new PriorityQueue<>((broker1, broker2) -> {\n+      int broker1LeaderReplicaCount = broker1.numLeaderReplicasOfTopicInBroker(topicName);\n+      int broker2LeaderReplicaCount = broker2.numLeaderReplicasOfTopicInBroker(topicName);\n+      int leaderReplicaCountCompareResult = Integer.compare(broker2LeaderReplicaCount, broker1LeaderReplicaCount);\n+      return leaderReplicaCountCompareResult == 0 ? Integer.compare(broker1.id(), broker2.id()) : leaderReplicaCountCompareResult;\n+    });\n+    clusterModel.brokers().forEach((broker -> {\n+      if (broker.isAlive() && broker.id() != originalBroker.id() && brokerHasExcessiveLeaderReplicasOfTopic(topicName, broker)) {\n+        brokersWithExcessiveLeaderReplicaToMove.add(broker);\n+      }\n+    }));\n+    return brokersWithExcessiveLeaderReplicaToMove;\n+  }\n+\n+  private boolean brokerHasExcessiveLeaderReplicasOfTopic(String topicName, Broker broker) {\n+    return broker.numLeaderReplicasOfTopicInBroker(topicName) > minTopicLeadersPerBroker();\n+  }\n+\n+  @Nullable\n+  private Replica leaderReplicaOfTopicPartition(ClusterModel clusterModel, TopicPartition topicPartition) {\n+    for (Replica leaderReplica : clusterModel.leaderReplicas()) {\n+      if (leaderReplica.topicPartition().equals(topicPartition)) {\n+        return leaderReplica;\n+      }\n+    }\n+    return null;\n+  }\n+\n+\n+  private Set<Broker> eligibleToHaveLeaderReplicaBrokers(ClusterModel clusterModel, OptimizationOptions optimizationOptions) {\n+    return clusterModel.brokers()\n+                       .stream()\n+                       .filter(broker -> brokerIsEligibleToHaveAnyLeaderReplica(broker, optimizationOptions))\n+                       .collect(Collectors.toSet());\n+  }\n+\n+  private boolean brokerIsEligibleToHaveAnyLeaderReplica(Broker broker, OptimizationOptions optimizationOptions) {", "originalCommit": "7191c6eb4737d349858fbb4c7c7f76906f5c8892", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzUyNjM2MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567526361", "bodyText": "Nit: eligibleToHaveLeaderReplicaBrokers -> eligibleBrokersForLeadership?", "author": "efeg", "createdAt": "2021-02-01T02:02:01Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by \"min.topic.leaders.per.broker\" config\n+ * property) of leader replica of each topic in a configured set of topics (specified by \"topics.with.min.leaders.per.broker\"\n+ * config property).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveLeaderReplicaPerBrokerTopics.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveLeaderReplicaPerBrokerTopics = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(clusterModel, optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    // Sort leader replicas for each broker based on resource utilization.\n+    new SortedReplicasHelper().addPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants())\n+                              .trackSortedReplicasFor(replicaSortName(this, false, false), clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(ClusterModel clusterModel,\n+                                                               OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty() || optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveLeaderReplicaPerBrokerTopics.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies\"\n+          + \"a config error. Topics should not be excluded=[%s]\", String.join(\", \", shouldNotBeExcludedTopics)));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderReplicaToDistribute(ClusterModel clusterModel,\n+                                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty()) {\n+      return;\n+    }\n+    Map<String, Set<Replica>> replicasByTopicNames = clusterModel.replicasOf(_mustHaveLeaderReplicaPerBrokerTopics);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleToHaveLeaderReplicaBrokers(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderReplicaCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Set<Replica>> replicasByTopicName : replicasByTopicNames.entrySet()) {\n+      int totalLeaderReplicaCountForTopic = countLeaderReplicas(replicasByTopicName.getValue());\n+      if (totalLeaderReplicaCountForTopic < totalMinimumLeaderReplicaCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader \"\n+                    + \"replica count %d for topic %s.\",\n+                totalLeaderReplicaCountForTopic, eligibleBrokersForLeadership.size(),\n+                totalLeaderReplicaCountForTopic, replicasByTopicName.getKey()));\n+      }\n+    }\n+  }\n+\n+  private int countLeaderReplicas(Collection<Replica> replicas) {\n+    int leaderReplicaCount = 0;\n+    for (Replica replica : replicas) {\n+      if (replica.isLeader()) {\n+        leaderReplicaCount++;\n+      }\n+    }\n+    return leaderReplicaCount;\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return true;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+        Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+        if (!replicaToBeMoved.isLeader()) {\n+          return true; // Move a follower replica of a topic of this goal's interest is always self-satisfied since it does not matter\n+        }\n+        return isSelfSatisfiedToMoveOneLeaderReplica(sourceBroker,\n+                                                     clusterModel.broker(action.destinationBrokerId()),\n+                                                     replicaToBeMoved);\n+      case INTER_BROKER_REPLICA_SWAP:\n+        return isSwapActionSelfSatisfied(clusterModel, action);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private boolean isSwapActionSelfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (action.balancingAction() != ActionType.INTER_BROKER_REPLICA_SWAP) {\n+      throw new IllegalArgumentException(\"Expected INTER_BROKER_REPLICA_SWAP. But got: \" + action.balancingAction());\n+    }\n+    Replica sourceReplica = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+    Replica destinationReplica = clusterModel.broker(action.destinationBrokerId()).replica(action.topicPartition());\n+    if (sourceReplica.isLeader() == destinationReplica.isLeader() && Objects.equals(action.topic(), action.destinationTopic())) {\n+      // Swapping either 2 leader replicas or 2 follower replicas of the same topic has no effect on this goal\n+      return true;\n+    }\n+    return isSelfSatisfiedToMoveOneLeaderReplica(clusterModel.broker(action.sourceBrokerId()),\n+                                                 clusterModel.broker(action.destinationBrokerId()),\n+                                                 sourceReplica)\n+           && isSelfSatisfiedToMoveOneLeaderReplica(clusterModel.broker(action.destinationBrokerId()),\n+                                                    clusterModel.broker(action.sourceBrokerId()),\n+                                                    destinationReplica);\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveLeaderReplicaPerBrokerTopics.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Check whether it is self-satisfied to move a leader replica of a topic with the given name from a the given source\n+   * broker to the given destination broker\n+   * @param sourceBroker the broker from which a leader replica is removed\n+   * @param destinationBroker the broker from which a leader replica is added\n+   * @param replicaToBeMoved replica to be moved from the source broker to the destination broker\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean isSelfSatisfiedToMoveOneLeaderReplica(Broker sourceBroker, Broker destinationBroker, Replica replicaToBeMoved) {\n+    if (!replicaToBeMoved.isLeader()) {\n+      return true;\n+    }\n+    String topicName = replicaToBeMoved.topicPartition().topic();\n+    if (!_mustHaveLeaderReplicaPerBrokerTopics.contains(topicName)) {\n+      return true;\n+    }\n+    // Moving a replica leadership from a not-alive broker to an alive broker is self-satisfied\n+    if (!sourceBroker.isAlive() && destinationBroker.isAlive()) {\n+      return true;\n+    }\n+    // Moving leader replica from more abundant broker could be considered as self-satisfied\n+    return sourceBroker.numLeaderReplicasOfTopicInBroker(topicName) > destinationBroker.numLeaderReplicasOfTopicInBroker(topicName);\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderReplicaOfTopics(clusterModel, optimizationOptions);\n+    finish();\n+  }\n+\n+  private void ensureBrokersAllHaveEnoughLeaderReplicaOfTopics(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    for (Broker broker : clusterModel.brokers()) {\n+      if (!brokerIsEligibleToHaveAnyLeaderReplica(broker, optimizationOptions)) {\n+        continue;\n+      }\n+      for (String mustHaveLeaderReplicaPerBrokerTopicName : _mustHaveLeaderReplicaPerBrokerTopics) {\n+        int leaderReplicaCount = broker.numLeaderReplicasOfTopicInBroker(mustHaveLeaderReplicaPerBrokerTopicName);\n+        if (leaderReplicaCount < minTopicLeadersPerBroker()) {\n+          throw new OptimizationFailureException(String.format(\"Broker %d does not have enough leader replica for topic %s. \"\n+              + \"Minimum required per-broker leader replica count %d. Actual broker leader replica count %d\",\n+              broker.id(), mustHaveLeaderReplicaPerBrokerTopicName, minTopicLeadersPerBroker(), leaderReplicaCount));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of the current goal and optimized goals.\n+   * @param broker         Broker to be balanced.\n+   * @param clusterModel   The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    LOG.debug(\"balancing broker {}, optimized goals = {}\", broker, optimizedGoals);\n+    moveAwayOfflineReplicas(broker, clusterModel, optimizedGoals, optimizationOptions);\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    if (!brokerIsEligibleToHaveAnyLeaderReplica(broker, optimizationOptions)) {\n+      return;\n+    }\n+    for (String topicMustHaveLeaderReplicaPerBroker : _mustHaveLeaderReplicaPerBrokerTopics) {\n+      maybeMoveLeaderReplicaOfTopicToBroker(topicMustHaveLeaderReplicaPerBroker, broker, clusterModel, optimizedGoals, optimizationOptions);\n+    }\n+  }\n+\n+  private void maybeMoveLeaderReplicaOfTopicToBroker(String topicMustHaveLeaderReplicaPerBroker,\n+                                                     Broker broker,\n+                                                     ClusterModel clusterModel,\n+                                                     Set<Goal> optimizedGoals,\n+                                                     OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (brokerHasSufficientLeaderReplicasOfTopic(broker, topicMustHaveLeaderReplicaPerBroker)) {\n+      return; // This broker has enough leader replica(s)\n+    }\n+    // Try to elect follower replica(s) of the interested topic on this broker to be leader\n+    Set<Replica> followerReplicas = broker.replicas().stream()\n+                                          .filter(\n+                                              replica -> !replica.isLeader()\n+                                                         && replica.topicPartition().topic().equals(topicMustHaveLeaderReplicaPerBroker))\n+                                          .collect(Collectors.toSet());\n+\n+    for (Replica followerReplica : followerReplicas) {\n+      Replica leaderReplica = leaderReplicaOfTopicPartition(clusterModel, followerReplica.topicPartition());\n+      if (leaderReplica == null) {\n+        LOG.warn(\"No leader replica for {}\", followerReplica.topicPartition());\n+      } else {\n+        if (leaderReplica.broker().id() != broker.id()\n+            && leaderReplica.broker().numLeaderReplicasOfTopicInBroker(topicMustHaveLeaderReplicaPerBroker) > minTopicLeadersPerBroker()) {\n+          maybeApplyBalancingAction(clusterModel, leaderReplica, Collections.singleton(broker),\n+                                    LEADERSHIP_MOVEMENT, optimizedGoals, optimizationOptions);\n+        }\n+      }\n+      if (brokerHasSufficientLeaderReplicasOfTopic(broker, topicMustHaveLeaderReplicaPerBroker)) {\n+        return; // This broker satisfies this goal\n+      }\n+    }\n+\n+    // Try to move leader replica(s) of the interested topic from other brokers to this broker\n+    PriorityQueue<Broker> brokersWithExcessiveLeaderReplicaToMove =\n+        getBrokersWithExcessiveLeaderReplicaToMove(topicMustHaveLeaderReplicaPerBroker, clusterModel, broker);\n+\n+    while (!brokersWithExcessiveLeaderReplicaToMove.isEmpty()) {\n+      Broker brokerWithExcessiveLeaderReplicaToMove = brokersWithExcessiveLeaderReplicaToMove.poll();\n+      List<Replica> leaderReplicasOfTopic = brokerWithExcessiveLeaderReplicaToMove.replicas().stream()\n+                                                                                  .filter(replica ->\n+                                                                                              replica.isLeader()\n+                                                                                              && replica.topicPartition()\n+                                                                                                        .topic()\n+                                                                                                        .equals(topicMustHaveLeaderReplicaPerBroker))\n+                                                                                  .collect(Collectors.toList());\n+      boolean leaderReplicaMoved = false;\n+      for (Replica leaderReplicaOfTopic : leaderReplicasOfTopic) {\n+        Broker destinationBroker = maybeApplyBalancingAction(clusterModel, leaderReplicaOfTopic, Collections.singleton(broker),\n+                                                             INTER_BROKER_REPLICA_MOVEMENT, optimizedGoals, optimizationOptions);\n+        if (destinationBroker != null) {\n+          leaderReplicaMoved = true;\n+          break; // Successfully move one leader replica\n+        }\n+      }\n+      if (leaderReplicaMoved) {\n+        if (brokerHasSufficientLeaderReplicasOfTopic(broker, topicMustHaveLeaderReplicaPerBroker)) {\n+          return; // This broker satisfies this goal\n+        }\n+        if (brokerHasExcessiveLeaderReplicasOfTopic(topicMustHaveLeaderReplicaPerBroker, brokerWithExcessiveLeaderReplicaToMove)) {\n+          brokersWithExcessiveLeaderReplicaToMove.add(brokerWithExcessiveLeaderReplicaToMove);\n+        }\n+      }\n+    }\n+\n+    if (!brokerHasSufficientLeaderReplicasOfTopic(broker, topicMustHaveLeaderReplicaPerBroker)) {\n+      throw new OptimizationFailureException(String.format(\"Cannot make broker %d have at least %d leader replica(s) of topic %s\",\n+                                                           broker.id(),\n+                                                           minTopicLeadersPerBroker(),\n+                                                           topicMustHaveLeaderReplicaPerBroker));\n+    }\n+  }\n+\n+  private boolean brokerHasSufficientLeaderReplicasOfTopic(Broker broker, String topicName) {\n+    return broker.numLeaderReplicasOfTopicInBroker(topicName) >= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This method creates a priority queue which has the broker with the most number of leader replicas of a given topic at the top of queue\n+   * @param topicName name of the given topic\n+   * @param clusterModel cluster model\n+   * @param originalBroker original broker which needs to be excluded from the priority queue\n+   * @return a priority queue which has the broker with the most number of leader replicas of a given topic at the top of queue\n+   */\n+  private PriorityQueue<Broker> getBrokersWithExcessiveLeaderReplicaToMove(String topicName, ClusterModel clusterModel, Broker originalBroker) {\n+    PriorityQueue<Broker> brokersWithExcessiveLeaderReplicaToMove = new PriorityQueue<>((broker1, broker2) -> {\n+      int broker1LeaderReplicaCount = broker1.numLeaderReplicasOfTopicInBroker(topicName);\n+      int broker2LeaderReplicaCount = broker2.numLeaderReplicasOfTopicInBroker(topicName);\n+      int leaderReplicaCountCompareResult = Integer.compare(broker2LeaderReplicaCount, broker1LeaderReplicaCount);\n+      return leaderReplicaCountCompareResult == 0 ? Integer.compare(broker1.id(), broker2.id()) : leaderReplicaCountCompareResult;\n+    });\n+    clusterModel.brokers().forEach((broker -> {\n+      if (broker.isAlive() && broker.id() != originalBroker.id() && brokerHasExcessiveLeaderReplicasOfTopic(topicName, broker)) {\n+        brokersWithExcessiveLeaderReplicaToMove.add(broker);\n+      }\n+    }));\n+    return brokersWithExcessiveLeaderReplicaToMove;\n+  }\n+\n+  private boolean brokerHasExcessiveLeaderReplicasOfTopic(String topicName, Broker broker) {\n+    return broker.numLeaderReplicasOfTopicInBroker(topicName) > minTopicLeadersPerBroker();\n+  }\n+\n+  @Nullable\n+  private Replica leaderReplicaOfTopicPartition(ClusterModel clusterModel, TopicPartition topicPartition) {\n+    for (Replica leaderReplica : clusterModel.leaderReplicas()) {\n+      if (leaderReplica.topicPartition().equals(topicPartition)) {\n+        return leaderReplica;\n+      }\n+    }\n+    return null;\n+  }\n+\n+\n+  private Set<Broker> eligibleToHaveLeaderReplicaBrokers(ClusterModel clusterModel, OptimizationOptions optimizationOptions) {", "originalCommit": "7191c6eb4737d349858fbb4c7c7f76906f5c8892", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzUyODg2OA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567528868", "bodyText": "Looks like the only use for this variable is to count the number of leaders for each relevant topic. This makes the creation of clusterModel#replicasOf and the following use of this#countLeaderReplicas inefficient / redundant.\nInstead, does it make sense to\n\nEliminate clusterModel#replicasOf,\nCreate clusterModel#numLeadersPerTopic(Set<String> topics), which returns a Map<String, Integer>, showing number of leaders per given topic?", "author": "efeg", "createdAt": "2021-02-01T02:14:50Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by \"min.topic.leaders.per.broker\" config\n+ * property) of leader replica of each topic in a configured set of topics (specified by \"topics.with.min.leaders.per.broker\"\n+ * config property).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveLeaderReplicaPerBrokerTopics.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveLeaderReplicaPerBrokerTopics = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(clusterModel, optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    // Sort leader replicas for each broker based on resource utilization.\n+    new SortedReplicasHelper().addPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants())\n+                              .trackSortedReplicasFor(replicaSortName(this, false, false), clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(ClusterModel clusterModel,\n+                                                               OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty() || optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveLeaderReplicaPerBrokerTopics.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies\"\n+          + \"a config error. Topics should not be excluded=[%s]\", String.join(\", \", shouldNotBeExcludedTopics)));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderReplicaToDistribute(ClusterModel clusterModel,\n+                                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty()) {\n+      return;\n+    }\n+    Map<String, Set<Replica>> replicasByTopicNames = clusterModel.replicasOf(_mustHaveLeaderReplicaPerBrokerTopics);", "originalCommit": "7191c6eb4737d349858fbb4c7c7f76906f5c8892", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzYwOTg0NA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567609844", "bodyText": "Good idea", "author": "Lincong", "createdAt": "2021-02-01T07:29:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzUyODg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzUyOTIxMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567529211", "bodyText": "Nit: (Applies to other uses) leader replica -> leader", "author": "efeg", "createdAt": "2021-02-01T02:16:23Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by \"min.topic.leaders.per.broker\" config\n+ * property) of leader replica of each topic in a configured set of topics (specified by \"topics.with.min.leaders.per.broker\"\n+ * config property).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveLeaderReplicaPerBrokerTopics.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveLeaderReplicaPerBrokerTopics = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(clusterModel, optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    // Sort leader replicas for each broker based on resource utilization.\n+    new SortedReplicasHelper().addPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants())\n+                              .trackSortedReplicasFor(replicaSortName(this, false, false), clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(ClusterModel clusterModel,\n+                                                               OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty() || optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveLeaderReplicaPerBrokerTopics.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies\"\n+          + \"a config error. Topics should not be excluded=[%s]\", String.join(\", \", shouldNotBeExcludedTopics)));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderReplicaToDistribute(ClusterModel clusterModel,\n+                                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty()) {\n+      return;\n+    }\n+    Map<String, Set<Replica>> replicasByTopicNames = clusterModel.replicasOf(_mustHaveLeaderReplicaPerBrokerTopics);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleToHaveLeaderReplicaBrokers(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderReplicaCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Set<Replica>> replicasByTopicName : replicasByTopicNames.entrySet()) {\n+      int totalLeaderReplicaCountForTopic = countLeaderReplicas(replicasByTopicName.getValue());\n+      if (totalLeaderReplicaCountForTopic < totalMinimumLeaderReplicaCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader \"\n+                    + \"replica count %d for topic %s.\",", "originalCommit": "7191c6eb4737d349858fbb4c7c7f76906f5c8892", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzUyOTQ1OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567529459", "bodyText": "Let's drop this function (please see earlier comment)", "author": "efeg", "createdAt": "2021-02-01T02:17:27Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by \"min.topic.leaders.per.broker\" config\n+ * property) of leader replica of each topic in a configured set of topics (specified by \"topics.with.min.leaders.per.broker\"\n+ * config property).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveLeaderReplicaPerBrokerTopics.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveLeaderReplicaPerBrokerTopics = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(clusterModel, optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    // Sort leader replicas for each broker based on resource utilization.\n+    new SortedReplicasHelper().addPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants())\n+                              .trackSortedReplicasFor(replicaSortName(this, false, false), clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(ClusterModel clusterModel,\n+                                                               OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty() || optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveLeaderReplicaPerBrokerTopics.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies\"\n+          + \"a config error. Topics should not be excluded=[%s]\", String.join(\", \", shouldNotBeExcludedTopics)));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderReplicaToDistribute(ClusterModel clusterModel,\n+                                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty()) {\n+      return;\n+    }\n+    Map<String, Set<Replica>> replicasByTopicNames = clusterModel.replicasOf(_mustHaveLeaderReplicaPerBrokerTopics);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleToHaveLeaderReplicaBrokers(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderReplicaCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Set<Replica>> replicasByTopicName : replicasByTopicNames.entrySet()) {\n+      int totalLeaderReplicaCountForTopic = countLeaderReplicas(replicasByTopicName.getValue());\n+      if (totalLeaderReplicaCountForTopic < totalMinimumLeaderReplicaCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader \"\n+                    + \"replica count %d for topic %s.\",\n+                totalLeaderReplicaCountForTopic, eligibleBrokersForLeadership.size(),\n+                totalLeaderReplicaCountForTopic, replicasByTopicName.getKey()));\n+      }\n+    }\n+  }\n+\n+  private int countLeaderReplicas(Collection<Replica> replicas) {\n+    int leaderReplicaCount = 0;\n+    for (Replica replica : replicas) {\n+      if (replica.isLeader()) {\n+        leaderReplicaCount++;\n+      }\n+    }\n+    return leaderReplicaCount;\n+  }", "originalCommit": "7191c6eb4737d349858fbb4c7c7f76906f5c8892", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzUzMjg4NA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567532884", "bodyText": "Comment and the sorted replicas do not match -- i.e. the sorted replicas is incorrect (please see other goals for example use).\nFor example, optimizationOptions.onlyMoveImmigrantReplicas() must be honored if it is true.", "author": "efeg", "createdAt": "2021-02-01T02:33:53Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by \"min.topic.leaders.per.broker\" config\n+ * property) of leader replica of each topic in a configured set of topics (specified by \"topics.with.min.leaders.per.broker\"\n+ * config property).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveLeaderReplicaPerBrokerTopics;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveLeaderReplicaPerBrokerTopics.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveLeaderReplicaPerBrokerTopics = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveLeaderReplicaPerBrokerTopics.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(clusterModel, optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    // Sort leader replicas for each broker based on resource utilization.\n+    new SortedReplicasHelper().addPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants())\n+                              .trackSortedReplicasFor(replicaSortName(this, false, false), clusterModel);", "originalCommit": "7191c6eb4737d349858fbb4c7c7f76906f5c8892", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzYxOTczMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r567619731", "bodyText": "Thank you for pointing it out. I changed it to the below. Let me know if it is correct this time:\n    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n    Set<String> excludedTopics = optimizationOptions.excludedTopics();\n    new SortedReplicasHelper().addSelectionFunc(ReplicaSortFunctionFactory.selectLeaders())\n                              .maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnExcludedTopics(excludedTopics))\n                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n                              .trackSortedReplicasFor(replicaSortName(this, true, true), clusterModel);", "author": "Lincong", "createdAt": "2021-02-01T07:53:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzUzMjg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODE5NTAxMw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568195013", "bodyText": ".addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnExcludedTopics(excludedTopics))\n\nShould we add a new selection function to choose from replicas of relevant topics?", "author": "efeg", "createdAt": "2021-02-01T22:48:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzUzMjg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODIwNTg1MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568205851", "bodyText": "Good idea", "author": "Lincong", "createdAt": "2021-02-01T23:09:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzUzMjg4NA=="}], "type": "inlineReview"}, {"oid": "d134dcac6c38ce907dccca97ba982d620ea6a492", "url": "https://github.com/linkedin/cruise-control/commit/d134dcac6c38ce907dccca97ba982d620ea6a492", "message": "Fix some issues", "committedDate": "2021-02-01T07:55:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAwMjAzNg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568002036", "bodyText": "Nit: Please use {@link AnalyzerConfig#...} to refer to config names in JavaDoc.", "author": "efeg", "createdAt": "2021-02-01T17:22:12Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,539 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by \"min.topic.leaders.per.broker\" config\n+ * property) of leader replica of each topic in a configured set of topics (specified by \"topics.with.min.leaders.per.broker\"", "originalCommit": "d134dcac6c38ce907dccca97ba982d620ea6a492", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAwNTE2MA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568005160", "bodyText": "Won't this always be 1? -- i.e. doesn't a partition have 1 leader by definition?\nHow could it be possible for the number of leaders per topic to be a Long? Do we expect a Kafka topic to have more than Integer.MAX_VALUE partitions?\n\nCan we use the following function:\n  public Map<String, Integer> numLeadersPerTopic(Set<String> topics) {\n    Map<String, Integer> leaderCountByTopicNames = new HashMap<>(topics.size());\n    for (TopicPartition tp : _partitionsByTopicPartition.keySet()) {\n      String topicName = tp.topic();\n      if (topics.contains(topicName)) {\n        leaderCountByTopicNames.merge(topicName, 1, Integer::sum);\n      }\n    }\n    return leaderCountByTopicNames;\n  }", "author": "efeg", "createdAt": "2021-02-01T17:26:53Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/model/ClusterModel.java", "diffHunk": "@@ -263,6 +263,23 @@ public Partition partition(TopicPartition tp) {\n     return _partitionsByTopicPartition.values().stream().map(Partition::leader).collect(Collectors.toSet());\n   }\n \n+  /**\n+   * Return a map from topic names to the number of leader replicas of each topic\n+   * @param topics a set of topic names\n+   * @return A map from topic names to the number of leader replicas of each topic\n+   */\n+  public Map<String, Long> numLeadersPerTopic(Set<String> topics) {\n+    Map<String, Long> leaderCountByTopicNames = new HashMap<>(topics.size());\n+    _partitionsByTopicPartition.forEach((topicPartition, partition) -> {\n+      String topicName = topicPartition.topic();\n+      if (topics.contains(topicName)) {\n+        long leaderReplicaCount = partition.replicas().stream().filter(Replica::isLeader).count();", "originalCommit": "d134dcac6c38ce907dccca97ba982d620ea6a492", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAyNDc2NA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568024764", "bodyText": "Yes. We can assume that a partition always has 1 leader\nThe reason why I used Long is that the return type of the below statement is long\npartition.replicas().stream().filter(Replica::isLeader).count();\n\nI will change the impl of this method to use the one you suggested", "author": "Lincong", "createdAt": "2021-02-01T17:55:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAwNTE2MA=="}], "type": "inlineReview"}, {"oid": "4bec71eb9e8043f102659b4011fbe4351eb7d7b0", "url": "https://github.com/linkedin/cruise-control/commit/4bec71eb9e8043f102659b4011fbe4351eb7d7b0", "message": "Fix some issues", "committedDate": "2021-02-01T23:47:16Z", "type": "commit"}, {"oid": "5e42118272ef6b7f28d62ef2d4e7e5b291676ea5", "url": "https://github.com/linkedin/cruise-control/commit/5e42118272ef6b7f28d62ef2d4e7e5b291676ea5", "message": "Enrich the ReplicationFactorChangeTest", "committedDate": "2021-02-02T00:21:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODIzNTYzMw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568235633", "bodyText": "Nit: Can we avoid static import?", "author": "efeg", "createdAt": "2021-02-02T00:24:50Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/analyzer/ReplicationFactorChangeTest.java", "diffHunk": "@@ -51,7 +54,7 @@\n import org.junit.runner.RunWith;\n import org.junit.runners.Parameterized;\n \n-import static com.linkedin.kafka.cruisecontrol.analyzer.AnalyzerUnitTestUtils.goal;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.AnalyzerUnitTestUtils.*;", "originalCommit": "5e42118272ef6b7f28d62ef2d4e7e5b291676ea5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI0MDYyMA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568240620", "bodyText": "You mean removing the wild card import right?", "author": "Lincong", "createdAt": "2021-02-02T00:37:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODIzNTYzMw=="}], "type": "inlineReview"}, {"oid": "ccbd661e4287e1216c859aa15ffc6672c2195462", "url": "https://github.com/linkedin/cruise-control/commit/ccbd661e4287e1216c859aa15ffc6672c2195462", "message": "Make ReplicationFactorChangeTest cover the medium cluster case for the MinTopicLeadersPerBrokerGoal", "committedDate": "2021-02-02T00:47:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI0MDc3NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568240775", "bodyText": "This should never happen. Even if happens, this should never return true. This is a correctness issue.\nCan we drop this check?", "author": "efeg", "createdAt": "2021-02-02T00:38:00Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,538 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().addSelectionFunc(ReplicaSortFunctionFactory.selectLeaders())\n+                              .maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(replicaSortName(this, true, true), clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderReplicaToDistribute(ClusterModel clusterModel,\n+                                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderReplicaCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderReplicaCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          numLeadersPerTopic.getValue(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return true;\n+    }", "originalCommit": "5e42118272ef6b7f28d62ef2d4e7e5b291676ea5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI1OTc0NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568259745", "bodyText": "Makes sense. I'll drop it", "author": "Lincong", "createdAt": "2021-02-02T01:30:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI0MDc3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI0MjE2Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568242163", "bodyText": "Does this goal ever generate swap action for satisfying the goal requirements? If not can we drop this function?", "author": "efeg", "createdAt": "2021-02-02T00:41:11Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,538 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().addSelectionFunc(ReplicaSortFunctionFactory.selectLeaders())\n+                              .maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(replicaSortName(this, true, true), clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderReplicaToDistribute(ClusterModel clusterModel,\n+                                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderReplicaCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderReplicaCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          numLeadersPerTopic.getValue(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return true;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+        Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+        if (!replicaToBeMoved.isLeader()) {\n+          return true; // Move a follower replica of a topic of this goal's interest is always self-satisfied since it does not matter\n+        }\n+        return isSelfSatisfiedToMoveOneLeaderReplica(sourceBroker,\n+                                                     clusterModel.broker(action.destinationBrokerId()),\n+                                                     replicaToBeMoved);\n+      case INTER_BROKER_REPLICA_SWAP:\n+        return isSwapActionSelfSatisfied(clusterModel, action);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private boolean isSwapActionSelfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (action.balancingAction() != ActionType.INTER_BROKER_REPLICA_SWAP) {\n+      throw new IllegalArgumentException(\"Expected INTER_BROKER_REPLICA_SWAP. But got: \" + action.balancingAction());\n+    }\n+    Replica sourceReplica = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+    Replica destinationReplica = clusterModel.broker(action.destinationBrokerId()).replica(action.topicPartition());\n+    if (sourceReplica.isLeader() == destinationReplica.isLeader() && Objects.equals(action.topic(), action.destinationTopic())) {\n+      // Swapping either 2 leader replicas or 2 follower replicas of the same topic has no effect on this goal\n+      return true;\n+    }\n+    return isSelfSatisfiedToMoveOneLeaderReplica(clusterModel.broker(action.sourceBrokerId()),\n+                                                 clusterModel.broker(action.destinationBrokerId()),\n+                                                 sourceReplica)\n+           && isSelfSatisfiedToMoveOneLeaderReplica(clusterModel.broker(action.destinationBrokerId()),\n+                                                    clusterModel.broker(action.sourceBrokerId()),\n+                                                    destinationReplica);\n+  }", "originalCommit": "5e42118272ef6b7f28d62ef2d4e7e5b291676ea5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI2MDk0Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568260947", "bodyText": "Good point. We can drop this isSwapActionSelfSatisfied method", "author": "Lincong", "createdAt": "2021-02-02T01:34:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI0MjE2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI0MzI2Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568243263", "bodyText": "Doesn't this goal only generate either (1) leadership or (2) inter-broker replica moves?\nGiven that we know that this function will receive either a (1) leadership or (2) inter-broker replica moves for sure, can we remove any handling for swap and unknown balancing action -- i.e. drop the swap-case please?", "author": "efeg", "createdAt": "2021-02-02T00:44:20Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,538 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().addSelectionFunc(ReplicaSortFunctionFactory.selectLeaders())\n+                              .maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(replicaSortName(this, true, true), clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderReplicaToDistribute(ClusterModel clusterModel,\n+                                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderReplicaCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderReplicaCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          numLeadersPerTopic.getValue(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return true;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+        Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+        if (!replicaToBeMoved.isLeader()) {\n+          return true; // Move a follower replica of a topic of this goal's interest is always self-satisfied since it does not matter\n+        }\n+        return isSelfSatisfiedToMoveOneLeaderReplica(sourceBroker,\n+                                                     clusterModel.broker(action.destinationBrokerId()),\n+                                                     replicaToBeMoved);\n+      case INTER_BROKER_REPLICA_SWAP:\n+        return isSwapActionSelfSatisfied(clusterModel, action);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }", "originalCommit": "5e42118272ef6b7f28d62ef2d4e7e5b291676ea5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI2MTIxMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568261211", "bodyText": "Yes, we can", "author": "Lincong", "createdAt": "2021-02-02T01:35:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI0MzI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI0NjgwMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568246801", "bodyText": "Moving a non-leader replica is acceptable only if the replica is offline and the action is a replica move. This is not a self satisfied action.", "author": "efeg", "createdAt": "2021-02-02T00:52:37Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,538 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().addSelectionFunc(ReplicaSortFunctionFactory.selectLeaders())\n+                              .maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(replicaSortName(this, true, true), clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderReplicaToDistribute(ClusterModel clusterModel,\n+                                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderReplicaCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderReplicaCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          numLeadersPerTopic.getValue(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return true;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+        Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+        if (!replicaToBeMoved.isLeader()) {\n+          return true; // Move a follower replica of a topic of this goal's interest is always self-satisfied since it does not matter\n+        }", "originalCommit": "5e42118272ef6b7f28d62ef2d4e7e5b291676ea5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI2NTcxOA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568265718", "bodyText": "Thanks for pointing it out", "author": "Lincong", "createdAt": "2021-02-02T01:48:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI0NjgwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI0ODkyMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568248921", "bodyText": "Can we simplify this function as something like the following?\n  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n    Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n    Replica sourceReplica = sourceBroker.replica(action.topicPartition());\n\n    if (sourceReplica.broker().replica(action.topicPartition()).isCurrentOffline()) {\n      return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n    }\n\n    return isSelfSatisfiedToMoveOneLeaderReplica(sourceBroker,\n                                                 clusterModel.broker(action.destinationBrokerId()),\n                                                 sourceReplica);\n  }", "author": "efeg", "createdAt": "2021-02-02T00:58:44Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,538 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().addSelectionFunc(ReplicaSortFunctionFactory.selectLeaders())\n+                              .maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(replicaSortName(this, true, true), clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderReplicaToDistribute(ClusterModel clusterModel,\n+                                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderReplicaCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderReplicaCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          numLeadersPerTopic.getValue(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return true;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+        Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+        if (!replicaToBeMoved.isLeader()) {\n+          return true; // Move a follower replica of a topic of this goal's interest is always self-satisfied since it does not matter\n+        }\n+        return isSelfSatisfiedToMoveOneLeaderReplica(sourceBroker,\n+                                                     clusterModel.broker(action.destinationBrokerId()),\n+                                                     replicaToBeMoved);\n+      case INTER_BROKER_REPLICA_SWAP:\n+        return isSwapActionSelfSatisfied(clusterModel, action);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }", "originalCommit": "5e42118272ef6b7f28d62ef2d4e7e5b291676ea5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI1Mzg5Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568253893", "bodyText": "By design, this function should not be called with\n\na non-leader replica -- please drop check on if (!replicaToBeMoved.isLeader()).\nwith replicas from topics other than _mustHaveTopicLeadersPerBroker -- please drop check on if (!_mustHaveTopicLeadersPerBroker.contains(topicName)).\noffline replicas because this is already done in the proposed simplified version of selfSatisfied(also destinationBroker should not be dead if it is proposed here) -- please drop check on if (!sourceBroker.isAlive() && destinationBroker.isAlive())\n\n-- See my comment above on the proposed simplified version of selfSatisfied.", "author": "efeg", "createdAt": "2021-02-02T01:13:20Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,538 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().addSelectionFunc(ReplicaSortFunctionFactory.selectLeaders())\n+                              .maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(replicaSortName(this, true, true), clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderReplicaToDistribute(ClusterModel clusterModel,\n+                                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderReplicaCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderReplicaCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          numLeadersPerTopic.getValue(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return true;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+        Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+        if (!replicaToBeMoved.isLeader()) {\n+          return true; // Move a follower replica of a topic of this goal's interest is always self-satisfied since it does not matter\n+        }\n+        return isSelfSatisfiedToMoveOneLeaderReplica(sourceBroker,\n+                                                     clusterModel.broker(action.destinationBrokerId()),\n+                                                     replicaToBeMoved);\n+      case INTER_BROKER_REPLICA_SWAP:\n+        return isSwapActionSelfSatisfied(clusterModel, action);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private boolean isSwapActionSelfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (action.balancingAction() != ActionType.INTER_BROKER_REPLICA_SWAP) {\n+      throw new IllegalArgumentException(\"Expected INTER_BROKER_REPLICA_SWAP. But got: \" + action.balancingAction());\n+    }\n+    Replica sourceReplica = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+    Replica destinationReplica = clusterModel.broker(action.destinationBrokerId()).replica(action.topicPartition());\n+    if (sourceReplica.isLeader() == destinationReplica.isLeader() && Objects.equals(action.topic(), action.destinationTopic())) {\n+      // Swapping either 2 leader replicas or 2 follower replicas of the same topic has no effect on this goal\n+      return true;\n+    }\n+    return isSelfSatisfiedToMoveOneLeaderReplica(clusterModel.broker(action.sourceBrokerId()),\n+                                                 clusterModel.broker(action.destinationBrokerId()),\n+                                                 sourceReplica)\n+           && isSelfSatisfiedToMoveOneLeaderReplica(clusterModel.broker(action.destinationBrokerId()),\n+                                                    clusterModel.broker(action.sourceBrokerId()),\n+                                                    destinationReplica);\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Check whether it is self-satisfied to move a leader replica of a topic with the given name from a the given source\n+   * broker to the given destination broker\n+   * @param sourceBroker the broker from which a leader replica is removed\n+   * @param destinationBroker the broker from which a leader replica is added\n+   * @param replicaToBeMoved replica to be moved from the source broker to the destination broker\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean isSelfSatisfiedToMoveOneLeaderReplica(Broker sourceBroker, Broker destinationBroker, Replica replicaToBeMoved) {\n+    if (!replicaToBeMoved.isLeader()) {\n+      return true;\n+    }\n+    String topicName = replicaToBeMoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      return true;\n+    }\n+    // Moving a replica leadership from a not-alive broker to an alive broker is self-satisfied\n+    if (!sourceBroker.isAlive() && destinationBroker.isAlive()) {\n+      return true;\n+    }", "originalCommit": "5e42118272ef6b7f28d62ef2d4e7e5b291676ea5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI2ODgxMA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568268810", "bodyText": "Good point!", "author": "Lincong", "createdAt": "2021-02-02T01:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI1Mzg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI1NDU2MA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568254560", "bodyText": "numLeaderReplicasOfTopicInBroker -> numLeadersFor", "author": "efeg", "createdAt": "2021-02-02T01:15:26Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/model/Broker.java", "diffHunk": "@@ -187,14 +185,36 @@ public Replica replica(TopicPartition tp) {\n   /**\n    * Get number of replicas from the given topic in this broker.\n    *\n-   * @param topic Topic for which the replica count will be returned.\n+   * @param topic Topic for which both the leader and follower replica count will be returned.\n    * @return The number of replicas from the given topic in this broker.\n    */\n   public int numReplicasOfTopicInBroker(String topic) {\n     Map<Integer, Replica> topicReplicas = _topicReplicas.get(topic);\n     return topicReplicas == null ? 0 : topicReplicas.size();\n   }\n \n+  /**\n+   * Get number of only leader replicas from the given topic in this broker.\n+   *\n+   * @param topicName Topic for which the replica count will be returned.\n+   * @return The number of leader replicas from the given topic in this broker.\n+   */\n+  public int numLeaderReplicasOfTopicInBroker(String topicName) {", "originalCommit": "5e42118272ef6b7f28d62ef2d4e7e5b291676ea5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI1NTExMg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568255112", "bodyText": "Can we drop this function and move its content to numLeaderReplicasOfTopicInBroker? We are using it only as part of counting leaders, so filtering can be based on leadership.", "author": "efeg", "createdAt": "2021-02-02T01:16:54Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/model/Broker.java", "diffHunk": "@@ -187,14 +185,36 @@ public Replica replica(TopicPartition tp) {\n   /**\n    * Get number of replicas from the given topic in this broker.\n    *\n-   * @param topic Topic for which the replica count will be returned.\n+   * @param topic Topic for which both the leader and follower replica count will be returned.\n    * @return The number of replicas from the given topic in this broker.\n    */\n   public int numReplicasOfTopicInBroker(String topic) {\n     Map<Integer, Replica> topicReplicas = _topicReplicas.get(topic);\n     return topicReplicas == null ? 0 : topicReplicas.size();\n   }\n \n+  /**\n+   * Get number of only leader replicas from the given topic in this broker.\n+   *\n+   * @param topicName Topic for which the replica count will be returned.\n+   * @return The number of leader replicas from the given topic in this broker.\n+   */\n+  public int numLeaderReplicasOfTopicInBroker(String topicName) {\n+    return numReplicasOfTopicInBroker(topicName, true);\n+  }\n+\n+  /**\n+   * Get number of either leader or follower replicas from the given topic in this broker\n+   *\n+   * @param topic Topic for which either the leader or the follower replica count will be returned.\n+   * @param countLeaderReplica Count leader replicas if {@code true} and count follower replicas if\n+   * {@code false}\n+   * @return The number of replicas from the given topic in this broker.\n+   */\n+  private int numReplicasOfTopicInBroker(String topic, boolean countLeaderReplica) {", "originalCommit": "5e42118272ef6b7f28d62ef2d4e7e5b291676ea5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI2NTAxOQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568265019", "bodyText": "Yes, I dropped this method and keep:\n  public int numLeadersFor(String topicName) {\n    return (int) replicasOfTopicInBroker(topicName).stream().filter(Replica::isLeader).count();\n  }", "author": "Lincong", "createdAt": "2021-02-02T01:46:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI1NTExMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI1NjI1OA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568256258", "bodyText": "Shouldn't this be\nreturn sourceBroker.numLeaderReplicasOfTopicInBroker(topicName) > minTopicLeadersPerBroker();\n\nOtherwise your move can cause (1) the source broker to have fewer than intended number of replicas from the topic or (2) extra replica moves from source to other brokers and from other brokers to source to compensate for the missing topic replicas.\nAm I missing something?\n-- Also with this change and all the other changes proposed above, this function will have a single line of code, which is only called from selfSatisfied. Hence, it can be deleted and its content can be moved to selfSatisfied.", "author": "efeg", "createdAt": "2021-02-02T01:20:12Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,538 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().addSelectionFunc(ReplicaSortFunctionFactory.selectLeaders())\n+                              .maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(replicaSortName(this, true, true), clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderReplicaToDistribute(ClusterModel clusterModel,\n+                                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderReplicaCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderReplicaCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          numLeadersPerTopic.getValue(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return true;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+        Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+        if (!replicaToBeMoved.isLeader()) {\n+          return true; // Move a follower replica of a topic of this goal's interest is always self-satisfied since it does not matter\n+        }\n+        return isSelfSatisfiedToMoveOneLeaderReplica(sourceBroker,\n+                                                     clusterModel.broker(action.destinationBrokerId()),\n+                                                     replicaToBeMoved);\n+      case INTER_BROKER_REPLICA_SWAP:\n+        return isSwapActionSelfSatisfied(clusterModel, action);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private boolean isSwapActionSelfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (action.balancingAction() != ActionType.INTER_BROKER_REPLICA_SWAP) {\n+      throw new IllegalArgumentException(\"Expected INTER_BROKER_REPLICA_SWAP. But got: \" + action.balancingAction());\n+    }\n+    Replica sourceReplica = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+    Replica destinationReplica = clusterModel.broker(action.destinationBrokerId()).replica(action.topicPartition());\n+    if (sourceReplica.isLeader() == destinationReplica.isLeader() && Objects.equals(action.topic(), action.destinationTopic())) {\n+      // Swapping either 2 leader replicas or 2 follower replicas of the same topic has no effect on this goal\n+      return true;\n+    }\n+    return isSelfSatisfiedToMoveOneLeaderReplica(clusterModel.broker(action.sourceBrokerId()),\n+                                                 clusterModel.broker(action.destinationBrokerId()),\n+                                                 sourceReplica)\n+           && isSelfSatisfiedToMoveOneLeaderReplica(clusterModel.broker(action.destinationBrokerId()),\n+                                                    clusterModel.broker(action.sourceBrokerId()),\n+                                                    destinationReplica);\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Check whether it is self-satisfied to move a leader replica of a topic with the given name from a the given source\n+   * broker to the given destination broker\n+   * @param sourceBroker the broker from which a leader replica is removed\n+   * @param destinationBroker the broker from which a leader replica is added\n+   * @param replicaToBeMoved replica to be moved from the source broker to the destination broker\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean isSelfSatisfiedToMoveOneLeaderReplica(Broker sourceBroker, Broker destinationBroker, Replica replicaToBeMoved) {\n+    if (!replicaToBeMoved.isLeader()) {\n+      return true;\n+    }\n+    String topicName = replicaToBeMoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      return true;\n+    }\n+    // Moving a replica leadership from a not-alive broker to an alive broker is self-satisfied\n+    if (!sourceBroker.isAlive() && destinationBroker.isAlive()) {\n+      return true;\n+    }\n+    // Moving leader replica from more abundant broker could be considered as self-satisfied\n+    return sourceBroker.numLeaderReplicasOfTopicInBroker(topicName) > destinationBroker.numLeaderReplicasOfTopicInBroker(topicName);", "originalCommit": "5e42118272ef6b7f28d62ef2d4e7e5b291676ea5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI2ODkxNw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568268917", "bodyText": "Good point!", "author": "Lincong", "createdAt": "2021-02-02T01:57:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI1NjI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI1NzI5Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568257293", "bodyText": "clusterModel.brokers()) -> clusterModel.aliveBrokers", "author": "efeg", "createdAt": "2021-02-02T01:23:38Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,538 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().addSelectionFunc(ReplicaSortFunctionFactory.selectLeaders())\n+                              .maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(replicaSortName(this, true, true), clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderReplicaToDistribute(ClusterModel clusterModel,\n+                                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderReplicaCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderReplicaCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          numLeadersPerTopic.getValue(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return true;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+        Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+        if (!replicaToBeMoved.isLeader()) {\n+          return true; // Move a follower replica of a topic of this goal's interest is always self-satisfied since it does not matter\n+        }\n+        return isSelfSatisfiedToMoveOneLeaderReplica(sourceBroker,\n+                                                     clusterModel.broker(action.destinationBrokerId()),\n+                                                     replicaToBeMoved);\n+      case INTER_BROKER_REPLICA_SWAP:\n+        return isSwapActionSelfSatisfied(clusterModel, action);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private boolean isSwapActionSelfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (action.balancingAction() != ActionType.INTER_BROKER_REPLICA_SWAP) {\n+      throw new IllegalArgumentException(\"Expected INTER_BROKER_REPLICA_SWAP. But got: \" + action.balancingAction());\n+    }\n+    Replica sourceReplica = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+    Replica destinationReplica = clusterModel.broker(action.destinationBrokerId()).replica(action.topicPartition());\n+    if (sourceReplica.isLeader() == destinationReplica.isLeader() && Objects.equals(action.topic(), action.destinationTopic())) {\n+      // Swapping either 2 leader replicas or 2 follower replicas of the same topic has no effect on this goal\n+      return true;\n+    }\n+    return isSelfSatisfiedToMoveOneLeaderReplica(clusterModel.broker(action.sourceBrokerId()),\n+                                                 clusterModel.broker(action.destinationBrokerId()),\n+                                                 sourceReplica)\n+           && isSelfSatisfiedToMoveOneLeaderReplica(clusterModel.broker(action.destinationBrokerId()),\n+                                                    clusterModel.broker(action.sourceBrokerId()),\n+                                                    destinationReplica);\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Check whether it is self-satisfied to move a leader replica of a topic with the given name from a the given source\n+   * broker to the given destination broker\n+   * @param sourceBroker the broker from which a leader replica is removed\n+   * @param destinationBroker the broker from which a leader replica is added\n+   * @param replicaToBeMoved replica to be moved from the source broker to the destination broker\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean isSelfSatisfiedToMoveOneLeaderReplica(Broker sourceBroker, Broker destinationBroker, Replica replicaToBeMoved) {\n+    if (!replicaToBeMoved.isLeader()) {\n+      return true;\n+    }\n+    String topicName = replicaToBeMoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      return true;\n+    }\n+    // Moving a replica leadership from a not-alive broker to an alive broker is self-satisfied\n+    if (!sourceBroker.isAlive() && destinationBroker.isAlive()) {\n+      return true;\n+    }\n+    // Moving leader replica from more abundant broker could be considered as self-satisfied\n+    return sourceBroker.numLeaderReplicasOfTopicInBroker(topicName) > destinationBroker.numLeaderReplicasOfTopicInBroker(topicName);\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderReplicaOfTopics(clusterModel, optimizationOptions);\n+    finish();\n+  }\n+\n+  private void ensureBrokersAllHaveEnoughLeaderReplicaOfTopics(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    for (Broker broker : clusterModel.brokers()) {", "originalCommit": "5e42118272ef6b7f28d62ef2d4e7e5b291676ea5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1f88fc462883f0be209332624b08b82c70142710", "url": "https://github.com/linkedin/cruise-control/commit/1f88fc462883f0be209332624b08b82c70142710", "message": "Fix issues", "committedDate": "2021-02-02T01:58:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI2NDUxNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568264515", "bodyText": "There is no need for this micro-optimization. The next call to maybeApplyBalancingAction  will already fail with a null response and we will throw the exception. Please drop this check.\n-- also incorrect exception message. Isn't this function trying to move offline replicas -- i.e. not all replicas.", "author": "efeg", "createdAt": "2021-02-02T01:44:53Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,538 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().addSelectionFunc(ReplicaSortFunctionFactory.selectLeaders())\n+                              .maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(replicaSortName(this, true, true), clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderReplicaToDistribute(ClusterModel clusterModel,\n+                                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderReplicaCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderReplicaCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          numLeadersPerTopic.getValue(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return true;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+        Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+        if (!replicaToBeMoved.isLeader()) {\n+          return true; // Move a follower replica of a topic of this goal's interest is always self-satisfied since it does not matter\n+        }\n+        return isSelfSatisfiedToMoveOneLeaderReplica(sourceBroker,\n+                                                     clusterModel.broker(action.destinationBrokerId()),\n+                                                     replicaToBeMoved);\n+      case INTER_BROKER_REPLICA_SWAP:\n+        return isSwapActionSelfSatisfied(clusterModel, action);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private boolean isSwapActionSelfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (action.balancingAction() != ActionType.INTER_BROKER_REPLICA_SWAP) {\n+      throw new IllegalArgumentException(\"Expected INTER_BROKER_REPLICA_SWAP. But got: \" + action.balancingAction());\n+    }\n+    Replica sourceReplica = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+    Replica destinationReplica = clusterModel.broker(action.destinationBrokerId()).replica(action.topicPartition());\n+    if (sourceReplica.isLeader() == destinationReplica.isLeader() && Objects.equals(action.topic(), action.destinationTopic())) {\n+      // Swapping either 2 leader replicas or 2 follower replicas of the same topic has no effect on this goal\n+      return true;\n+    }\n+    return isSelfSatisfiedToMoveOneLeaderReplica(clusterModel.broker(action.sourceBrokerId()),\n+                                                 clusterModel.broker(action.destinationBrokerId()),\n+                                                 sourceReplica)\n+           && isSelfSatisfiedToMoveOneLeaderReplica(clusterModel.broker(action.destinationBrokerId()),\n+                                                    clusterModel.broker(action.sourceBrokerId()),\n+                                                    destinationReplica);\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Check whether it is self-satisfied to move a leader replica of a topic with the given name from a the given source\n+   * broker to the given destination broker\n+   * @param sourceBroker the broker from which a leader replica is removed\n+   * @param destinationBroker the broker from which a leader replica is added\n+   * @param replicaToBeMoved replica to be moved from the source broker to the destination broker\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean isSelfSatisfiedToMoveOneLeaderReplica(Broker sourceBroker, Broker destinationBroker, Replica replicaToBeMoved) {\n+    if (!replicaToBeMoved.isLeader()) {\n+      return true;\n+    }\n+    String topicName = replicaToBeMoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      return true;\n+    }\n+    // Moving a replica leadership from a not-alive broker to an alive broker is self-satisfied\n+    if (!sourceBroker.isAlive() && destinationBroker.isAlive()) {\n+      return true;\n+    }\n+    // Moving leader replica from more abundant broker could be considered as self-satisfied\n+    return sourceBroker.numLeaderReplicasOfTopicInBroker(topicName) > destinationBroker.numLeaderReplicasOfTopicInBroker(topicName);\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderReplicaOfTopics(clusterModel, optimizationOptions);\n+    finish();\n+  }\n+\n+  private void ensureBrokersAllHaveEnoughLeaderReplicaOfTopics(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    for (Broker broker : clusterModel.brokers()) {\n+      if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+        continue;\n+      }\n+      for (String mustHaveLeaderReplicaPerBrokerTopicName : _mustHaveTopicLeadersPerBroker) {\n+        int leaderReplicaCount = broker.numLeaderReplicasOfTopicInBroker(mustHaveLeaderReplicaPerBrokerTopicName);\n+        if (leaderReplicaCount < minTopicLeadersPerBroker()) {\n+          throw new OptimizationFailureException(String.format(\"Broker %d does not have enough leader replica for topic %s. \"\n+              + \"Minimum required per-broker leader replica count %d. Actual broker leader replica count %d\",\n+              broker.id(), mustHaveLeaderReplicaPerBrokerTopicName, minTopicLeadersPerBroker(), leaderReplicaCount));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of the current goal and optimized goals.\n+   * @param broker         Broker to be balanced.\n+   * @param clusterModel   The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    LOG.debug(\"balancing broker {}, optimized goals = {}\", broker, optimizedGoals);\n+    moveAwayOfflineReplicas(broker, clusterModel, optimizedGoals, optimizationOptions);\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+      return;\n+    }\n+    for (String topicMustHaveLeaderReplicaPerBroker : _mustHaveTopicLeadersPerBroker) {\n+      maybeMoveLeaderReplicaOfTopicToBroker(topicMustHaveLeaderReplicaPerBroker, broker, clusterModel, optimizedGoals, optimizationOptions);\n+    }\n+  }\n+\n+  private void maybeMoveLeaderReplicaOfTopicToBroker(String topicMustHaveLeaderReplicaPerBroker,\n+                                                     Broker broker,\n+                                                     ClusterModel clusterModel,\n+                                                     Set<Goal> optimizedGoals,\n+                                                     OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (brokerHasSufficientLeaderReplicasOfTopic(broker, topicMustHaveLeaderReplicaPerBroker)) {\n+      return; // This broker has enough leader replica(s)\n+    }\n+    // Try to elect follower replica(s) of the interested topic on this broker to be leader\n+    Set<Replica> followerReplicas = broker.replicas().stream()\n+                                          .filter(\n+                                              replica -> !replica.isLeader()\n+                                                         && replica.topicPartition().topic().equals(topicMustHaveLeaderReplicaPerBroker))\n+                                          .collect(Collectors.toSet());\n+\n+    for (Replica followerReplica : followerReplicas) {\n+      Replica leaderReplica = leaderReplicaOfTopicPartition(clusterModel, followerReplica.topicPartition());\n+      if (leaderReplica == null) {\n+        LOG.warn(\"No leader replica for {}\", followerReplica.topicPartition());\n+      } else {\n+        if (leaderReplica.broker().id() != broker.id()\n+            && leaderReplica.broker().numLeaderReplicasOfTopicInBroker(topicMustHaveLeaderReplicaPerBroker) > minTopicLeadersPerBroker()) {\n+          maybeApplyBalancingAction(clusterModel, leaderReplica, Collections.singleton(broker),\n+                                    LEADERSHIP_MOVEMENT, optimizedGoals, optimizationOptions);\n+        }\n+      }\n+      if (brokerHasSufficientLeaderReplicasOfTopic(broker, topicMustHaveLeaderReplicaPerBroker)) {\n+        return; // This broker satisfies this goal\n+      }\n+    }\n+\n+    // Try to move leader replica(s) of the interested topic from other brokers to this broker\n+    PriorityQueue<Broker> brokersWithExcessiveLeaderReplicaToMove =\n+        getBrokersWithExcessiveLeaderReplicaToMove(topicMustHaveLeaderReplicaPerBroker, clusterModel, broker);\n+\n+    while (!brokersWithExcessiveLeaderReplicaToMove.isEmpty()) {\n+      Broker brokerWithExcessiveLeaderReplicaToMove = brokersWithExcessiveLeaderReplicaToMove.poll();\n+      List<Replica> leaderReplicasOfTopic = brokerWithExcessiveLeaderReplicaToMove.replicas().stream()\n+                                                                                  .filter(replica ->\n+                                                                                              replica.isLeader()\n+                                                                                              && replica.topicPartition()\n+                                                                                                        .topic()\n+                                                                                                        .equals(topicMustHaveLeaderReplicaPerBroker))\n+                                                                                  .collect(Collectors.toList());\n+      boolean leaderReplicaMoved = false;\n+      for (Replica leaderReplicaOfTopic : leaderReplicasOfTopic) {\n+        Broker destinationBroker = maybeApplyBalancingAction(clusterModel, leaderReplicaOfTopic, Collections.singleton(broker),\n+                                                             INTER_BROKER_REPLICA_MOVEMENT, optimizedGoals, optimizationOptions);\n+        if (destinationBroker != null) {\n+          leaderReplicaMoved = true;\n+          break; // Successfully move one leader replica\n+        }\n+      }\n+      if (leaderReplicaMoved) {\n+        if (brokerHasSufficientLeaderReplicasOfTopic(broker, topicMustHaveLeaderReplicaPerBroker)) {\n+          return; // This broker satisfies this goal\n+        }\n+        if (brokerHasExcessiveLeaderReplicasOfTopic(topicMustHaveLeaderReplicaPerBroker, brokerWithExcessiveLeaderReplicaToMove)) {\n+          brokersWithExcessiveLeaderReplicaToMove.add(brokerWithExcessiveLeaderReplicaToMove);\n+        }\n+      }\n+    }\n+\n+    if (!brokerHasSufficientLeaderReplicasOfTopic(broker, topicMustHaveLeaderReplicaPerBroker)) {\n+      throw new OptimizationFailureException(String.format(\"Cannot make broker %d have at least %d leader replica(s) of topic %s\",\n+                                                           broker.id(),\n+                                                           minTopicLeadersPerBroker(),\n+                                                           topicMustHaveLeaderReplicaPerBroker));\n+    }\n+  }\n+\n+  private boolean brokerHasSufficientLeaderReplicasOfTopic(Broker broker, String topicName) {\n+    return broker.numLeaderReplicasOfTopicInBroker(topicName) >= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This method creates a priority queue which has the broker with the most number of leader replicas of a given topic at the top of queue\n+   * @param topicName name of the given topic\n+   * @param clusterModel cluster model\n+   * @param originalBroker original broker which needs to be excluded from the priority queue\n+   * @return a priority queue which has the broker with the most number of leader replicas of a given topic at the top of queue\n+   */\n+  private PriorityQueue<Broker> getBrokersWithExcessiveLeaderReplicaToMove(String topicName, ClusterModel clusterModel, Broker originalBroker) {\n+    PriorityQueue<Broker> brokersWithExcessiveLeaderReplicaToMove = new PriorityQueue<>((broker1, broker2) -> {\n+      int broker1LeaderReplicaCount = broker1.numLeaderReplicasOfTopicInBroker(topicName);\n+      int broker2LeaderReplicaCount = broker2.numLeaderReplicasOfTopicInBroker(topicName);\n+      int leaderReplicaCountCompareResult = Integer.compare(broker2LeaderReplicaCount, broker1LeaderReplicaCount);\n+      return leaderReplicaCountCompareResult == 0 ? Integer.compare(broker1.id(), broker2.id()) : leaderReplicaCountCompareResult;\n+    });\n+    clusterModel.brokers().forEach((broker -> {\n+      if (broker.isAlive() && broker.id() != originalBroker.id() && brokerHasExcessiveLeaderReplicasOfTopic(topicName, broker)) {\n+        brokersWithExcessiveLeaderReplicaToMove.add(broker);\n+      }\n+    }));\n+    return brokersWithExcessiveLeaderReplicaToMove;\n+  }\n+\n+  private boolean brokerHasExcessiveLeaderReplicasOfTopic(String topicName, Broker broker) {\n+    return broker.numLeaderReplicasOfTopicInBroker(topicName) > minTopicLeadersPerBroker();\n+  }\n+\n+  @Nullable\n+  private Replica leaderReplicaOfTopicPartition(ClusterModel clusterModel, TopicPartition topicPartition) {\n+    for (Replica leaderReplica : clusterModel.leaderReplicas()) {\n+      if (leaderReplica.topicPartition().equals(topicPartition)) {\n+        return leaderReplica;\n+      }\n+    }\n+    return null;\n+  }\n+\n+\n+  private Set<Broker> eligibleBrokersForLeadership(ClusterModel clusterModel, OptimizationOptions optimizationOptions) {\n+    return clusterModel.brokers()\n+                       .stream()\n+                       .filter(broker -> isEligibleToHaveLeaders(broker, optimizationOptions))\n+                       .collect(Collectors.toSet());\n+  }\n+\n+  private boolean isEligibleToHaveLeaders(Broker broker, OptimizationOptions optimizationOptions) {\n+    return broker.isAlive()\n+           && !optimizationOptions.excludedBrokersForLeadership().contains(broker.id())\n+           && !optimizationOptions.excludedBrokersForReplicaMove().contains(broker.id());\n+  }\n+\n+  private void moveAwayOfflineReplicas(Broker srcBroker,\n+                                       ClusterModel clusterModel,\n+                                       Set<Goal> optimizedGoals,\n+                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (srcBroker.currentOfflineReplicas().isEmpty()) {\n+      return;\n+    }\n+    SortedSet<Broker> eligibleBrokersToMoveOfflineReplicasTo = findEligibleBrokersToMoveOfflineReplicasTo(clusterModel, optimizationOptions);\n+    eligibleBrokersToMoveOfflineReplicasTo.removeIf(broker -> broker.id() == srcBroker.id());\n+    if (eligibleBrokersToMoveOfflineReplicasTo.isEmpty()) {\n+      throw new OptimizationFailureException(\"Cannot move all replicas away from broker \" + srcBroker);", "originalCommit": "ccbd661e4287e1216c859aa15ffc6672c2195462", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI3MjA5Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568272093", "bodyText": "This whole filtering is redundant. The return value of this function is used in maybeApplyBalancingAction. But if we check the content of this function, we will notice that (1) it does the same filtering for excluded brokers for both leadership and replica moves and (2) it does not move a replica to a broker that has the same replica, because it is not a legitMove.\nCan we\n\njust use:\n\n    SortedSet<Broker> sortedBrokers = new TreeSet<>(\n        Comparator.comparingInt((Broker broker) -> broker.replicas().size()).thenComparingInt(Broker::id));\n    sortedBrokers.addAll(clusterModel.aliveBrokers());\n\n\ndelete findEligibleBrokersToMoveOfflineReplicasTo  and move its content to moveAwayOfflineReplicas?", "author": "efeg", "createdAt": "2021-02-02T02:06:53Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,538 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().addSelectionFunc(ReplicaSortFunctionFactory.selectLeaders())\n+                              .maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(replicaSortName(this, true, true), clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderReplicaToDistribute(ClusterModel clusterModel,\n+                                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderReplicaCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderReplicaCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          numLeadersPerTopic.getValue(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return true;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+        Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+        if (!replicaToBeMoved.isLeader()) {\n+          return true; // Move a follower replica of a topic of this goal's interest is always self-satisfied since it does not matter\n+        }\n+        return isSelfSatisfiedToMoveOneLeaderReplica(sourceBroker,\n+                                                     clusterModel.broker(action.destinationBrokerId()),\n+                                                     replicaToBeMoved);\n+      case INTER_BROKER_REPLICA_SWAP:\n+        return isSwapActionSelfSatisfied(clusterModel, action);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private boolean isSwapActionSelfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (action.balancingAction() != ActionType.INTER_BROKER_REPLICA_SWAP) {\n+      throw new IllegalArgumentException(\"Expected INTER_BROKER_REPLICA_SWAP. But got: \" + action.balancingAction());\n+    }\n+    Replica sourceReplica = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+    Replica destinationReplica = clusterModel.broker(action.destinationBrokerId()).replica(action.topicPartition());\n+    if (sourceReplica.isLeader() == destinationReplica.isLeader() && Objects.equals(action.topic(), action.destinationTopic())) {\n+      // Swapping either 2 leader replicas or 2 follower replicas of the same topic has no effect on this goal\n+      return true;\n+    }\n+    return isSelfSatisfiedToMoveOneLeaderReplica(clusterModel.broker(action.sourceBrokerId()),\n+                                                 clusterModel.broker(action.destinationBrokerId()),\n+                                                 sourceReplica)\n+           && isSelfSatisfiedToMoveOneLeaderReplica(clusterModel.broker(action.destinationBrokerId()),\n+                                                    clusterModel.broker(action.sourceBrokerId()),\n+                                                    destinationReplica);\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Check whether it is self-satisfied to move a leader replica of a topic with the given name from a the given source\n+   * broker to the given destination broker\n+   * @param sourceBroker the broker from which a leader replica is removed\n+   * @param destinationBroker the broker from which a leader replica is added\n+   * @param replicaToBeMoved replica to be moved from the source broker to the destination broker\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean isSelfSatisfiedToMoveOneLeaderReplica(Broker sourceBroker, Broker destinationBroker, Replica replicaToBeMoved) {\n+    if (!replicaToBeMoved.isLeader()) {\n+      return true;\n+    }\n+    String topicName = replicaToBeMoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      return true;\n+    }\n+    // Moving a replica leadership from a not-alive broker to an alive broker is self-satisfied\n+    if (!sourceBroker.isAlive() && destinationBroker.isAlive()) {\n+      return true;\n+    }\n+    // Moving leader replica from more abundant broker could be considered as self-satisfied\n+    return sourceBroker.numLeaderReplicasOfTopicInBroker(topicName) > destinationBroker.numLeaderReplicasOfTopicInBroker(topicName);\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderReplicaOfTopics(clusterModel, optimizationOptions);\n+    finish();\n+  }\n+\n+  private void ensureBrokersAllHaveEnoughLeaderReplicaOfTopics(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    for (Broker broker : clusterModel.brokers()) {\n+      if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+        continue;\n+      }\n+      for (String mustHaveLeaderReplicaPerBrokerTopicName : _mustHaveTopicLeadersPerBroker) {\n+        int leaderReplicaCount = broker.numLeaderReplicasOfTopicInBroker(mustHaveLeaderReplicaPerBrokerTopicName);\n+        if (leaderReplicaCount < minTopicLeadersPerBroker()) {\n+          throw new OptimizationFailureException(String.format(\"Broker %d does not have enough leader replica for topic %s. \"\n+              + \"Minimum required per-broker leader replica count %d. Actual broker leader replica count %d\",\n+              broker.id(), mustHaveLeaderReplicaPerBrokerTopicName, minTopicLeadersPerBroker(), leaderReplicaCount));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of the current goal and optimized goals.\n+   * @param broker         Broker to be balanced.\n+   * @param clusterModel   The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    LOG.debug(\"balancing broker {}, optimized goals = {}\", broker, optimizedGoals);\n+    moveAwayOfflineReplicas(broker, clusterModel, optimizedGoals, optimizationOptions);\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+      return;\n+    }\n+    for (String topicMustHaveLeaderReplicaPerBroker : _mustHaveTopicLeadersPerBroker) {\n+      maybeMoveLeaderReplicaOfTopicToBroker(topicMustHaveLeaderReplicaPerBroker, broker, clusterModel, optimizedGoals, optimizationOptions);\n+    }\n+  }\n+\n+  private void maybeMoveLeaderReplicaOfTopicToBroker(String topicMustHaveLeaderReplicaPerBroker,\n+                                                     Broker broker,\n+                                                     ClusterModel clusterModel,\n+                                                     Set<Goal> optimizedGoals,\n+                                                     OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (brokerHasSufficientLeaderReplicasOfTopic(broker, topicMustHaveLeaderReplicaPerBroker)) {\n+      return; // This broker has enough leader replica(s)\n+    }\n+    // Try to elect follower replica(s) of the interested topic on this broker to be leader\n+    Set<Replica> followerReplicas = broker.replicas().stream()\n+                                          .filter(\n+                                              replica -> !replica.isLeader()\n+                                                         && replica.topicPartition().topic().equals(topicMustHaveLeaderReplicaPerBroker))\n+                                          .collect(Collectors.toSet());\n+\n+    for (Replica followerReplica : followerReplicas) {\n+      Replica leaderReplica = leaderReplicaOfTopicPartition(clusterModel, followerReplica.topicPartition());\n+      if (leaderReplica == null) {\n+        LOG.warn(\"No leader replica for {}\", followerReplica.topicPartition());\n+      } else {\n+        if (leaderReplica.broker().id() != broker.id()\n+            && leaderReplica.broker().numLeaderReplicasOfTopicInBroker(topicMustHaveLeaderReplicaPerBroker) > minTopicLeadersPerBroker()) {\n+          maybeApplyBalancingAction(clusterModel, leaderReplica, Collections.singleton(broker),\n+                                    LEADERSHIP_MOVEMENT, optimizedGoals, optimizationOptions);\n+        }\n+      }\n+      if (brokerHasSufficientLeaderReplicasOfTopic(broker, topicMustHaveLeaderReplicaPerBroker)) {\n+        return; // This broker satisfies this goal\n+      }\n+    }\n+\n+    // Try to move leader replica(s) of the interested topic from other brokers to this broker\n+    PriorityQueue<Broker> brokersWithExcessiveLeaderReplicaToMove =\n+        getBrokersWithExcessiveLeaderReplicaToMove(topicMustHaveLeaderReplicaPerBroker, clusterModel, broker);\n+\n+    while (!brokersWithExcessiveLeaderReplicaToMove.isEmpty()) {\n+      Broker brokerWithExcessiveLeaderReplicaToMove = brokersWithExcessiveLeaderReplicaToMove.poll();\n+      List<Replica> leaderReplicasOfTopic = brokerWithExcessiveLeaderReplicaToMove.replicas().stream()\n+                                                                                  .filter(replica ->\n+                                                                                              replica.isLeader()\n+                                                                                              && replica.topicPartition()\n+                                                                                                        .topic()\n+                                                                                                        .equals(topicMustHaveLeaderReplicaPerBroker))\n+                                                                                  .collect(Collectors.toList());\n+      boolean leaderReplicaMoved = false;\n+      for (Replica leaderReplicaOfTopic : leaderReplicasOfTopic) {\n+        Broker destinationBroker = maybeApplyBalancingAction(clusterModel, leaderReplicaOfTopic, Collections.singleton(broker),\n+                                                             INTER_BROKER_REPLICA_MOVEMENT, optimizedGoals, optimizationOptions);\n+        if (destinationBroker != null) {\n+          leaderReplicaMoved = true;\n+          break; // Successfully move one leader replica\n+        }\n+      }\n+      if (leaderReplicaMoved) {\n+        if (brokerHasSufficientLeaderReplicasOfTopic(broker, topicMustHaveLeaderReplicaPerBroker)) {\n+          return; // This broker satisfies this goal\n+        }\n+        if (brokerHasExcessiveLeaderReplicasOfTopic(topicMustHaveLeaderReplicaPerBroker, brokerWithExcessiveLeaderReplicaToMove)) {\n+          brokersWithExcessiveLeaderReplicaToMove.add(brokerWithExcessiveLeaderReplicaToMove);\n+        }\n+      }\n+    }\n+\n+    if (!brokerHasSufficientLeaderReplicasOfTopic(broker, topicMustHaveLeaderReplicaPerBroker)) {\n+      throw new OptimizationFailureException(String.format(\"Cannot make broker %d have at least %d leader replica(s) of topic %s\",\n+                                                           broker.id(),\n+                                                           minTopicLeadersPerBroker(),\n+                                                           topicMustHaveLeaderReplicaPerBroker));\n+    }\n+  }\n+\n+  private boolean brokerHasSufficientLeaderReplicasOfTopic(Broker broker, String topicName) {\n+    return broker.numLeaderReplicasOfTopicInBroker(topicName) >= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This method creates a priority queue which has the broker with the most number of leader replicas of a given topic at the top of queue\n+   * @param topicName name of the given topic\n+   * @param clusterModel cluster model\n+   * @param originalBroker original broker which needs to be excluded from the priority queue\n+   * @return a priority queue which has the broker with the most number of leader replicas of a given topic at the top of queue\n+   */\n+  private PriorityQueue<Broker> getBrokersWithExcessiveLeaderReplicaToMove(String topicName, ClusterModel clusterModel, Broker originalBroker) {\n+    PriorityQueue<Broker> brokersWithExcessiveLeaderReplicaToMove = new PriorityQueue<>((broker1, broker2) -> {\n+      int broker1LeaderReplicaCount = broker1.numLeaderReplicasOfTopicInBroker(topicName);\n+      int broker2LeaderReplicaCount = broker2.numLeaderReplicasOfTopicInBroker(topicName);\n+      int leaderReplicaCountCompareResult = Integer.compare(broker2LeaderReplicaCount, broker1LeaderReplicaCount);\n+      return leaderReplicaCountCompareResult == 0 ? Integer.compare(broker1.id(), broker2.id()) : leaderReplicaCountCompareResult;\n+    });\n+    clusterModel.brokers().forEach((broker -> {\n+      if (broker.isAlive() && broker.id() != originalBroker.id() && brokerHasExcessiveLeaderReplicasOfTopic(topicName, broker)) {\n+        brokersWithExcessiveLeaderReplicaToMove.add(broker);\n+      }\n+    }));\n+    return brokersWithExcessiveLeaderReplicaToMove;\n+  }\n+\n+  private boolean brokerHasExcessiveLeaderReplicasOfTopic(String topicName, Broker broker) {\n+    return broker.numLeaderReplicasOfTopicInBroker(topicName) > minTopicLeadersPerBroker();\n+  }\n+\n+  @Nullable\n+  private Replica leaderReplicaOfTopicPartition(ClusterModel clusterModel, TopicPartition topicPartition) {\n+    for (Replica leaderReplica : clusterModel.leaderReplicas()) {\n+      if (leaderReplica.topicPartition().equals(topicPartition)) {\n+        return leaderReplica;\n+      }\n+    }\n+    return null;\n+  }\n+\n+\n+  private Set<Broker> eligibleBrokersForLeadership(ClusterModel clusterModel, OptimizationOptions optimizationOptions) {\n+    return clusterModel.brokers()\n+                       .stream()\n+                       .filter(broker -> isEligibleToHaveLeaders(broker, optimizationOptions))\n+                       .collect(Collectors.toSet());\n+  }\n+\n+  private boolean isEligibleToHaveLeaders(Broker broker, OptimizationOptions optimizationOptions) {\n+    return broker.isAlive()\n+           && !optimizationOptions.excludedBrokersForLeadership().contains(broker.id())\n+           && !optimizationOptions.excludedBrokersForReplicaMove().contains(broker.id());\n+  }\n+\n+  private void moveAwayOfflineReplicas(Broker srcBroker,\n+                                       ClusterModel clusterModel,\n+                                       Set<Goal> optimizedGoals,\n+                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (srcBroker.currentOfflineReplicas().isEmpty()) {\n+      return;\n+    }\n+    SortedSet<Broker> eligibleBrokersToMoveOfflineReplicasTo = findEligibleBrokersToMoveOfflineReplicasTo(clusterModel, optimizationOptions);\n+    eligibleBrokersToMoveOfflineReplicasTo.removeIf(broker -> broker.id() == srcBroker.id());\n+    if (eligibleBrokersToMoveOfflineReplicasTo.isEmpty()) {\n+      throw new OptimizationFailureException(\"Cannot move all replicas away from broker \" + srcBroker);\n+    }\n+    Set<Replica> offlineReplicas = new HashSet<>(srcBroker.currentOfflineReplicas());\n+    for (Replica offlineReplica : offlineReplicas) {\n+      if (maybeApplyBalancingAction(clusterModel, offlineReplica, eligibleBrokersToMoveOfflineReplicasTo,\n+                                    INTER_BROKER_REPLICA_MOVEMENT, optimizedGoals, optimizationOptions) == null) {\n+        throw new OptimizationFailureException(String.format(\"Cannot move offline replica %s to any broker in %s\",\n+                                                             offlineReplica, eligibleBrokersToMoveOfflineReplicasTo));\n+      }\n+    }\n+  }\n+\n+  private SortedSet<Broker> findEligibleBrokersToMoveOfflineReplicasTo(ClusterModel clusterModel, OptimizationOptions optimizationOptions) {\n+    Set<Broker> candidateBrokers = clusterModel.brokers()\n+                                               .stream()\n+                                               .filter(broker -> broker.isAlive()\n+                                                                 && !optimizationOptions.excludedBrokersForReplicaMove().contains(broker.id()))\n+                                               .collect(Collectors.toSet());", "originalCommit": "ccbd661e4287e1216c859aa15ffc6672c2195462", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI4OTg2Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568289867", "bodyText": "Good point", "author": "Lincong", "createdAt": "2021-02-02T03:00:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI3MjA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI3MjkyNA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568272924", "bodyText": "No need to remove this -- see my other comment.", "author": "efeg", "createdAt": "2021-02-02T02:09:09Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,538 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeaderReplicasOfTopicInBroker(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().addSelectionFunc(ReplicaSortFunctionFactory.selectLeaders())\n+                              .maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(replicaSortName(this, true, true), clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderReplicaToDistribute(ClusterModel clusterModel,\n+                                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderReplicaCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderReplicaCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          numLeadersPerTopic.getValue(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return true;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+        Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+        if (!replicaToBeMoved.isLeader()) {\n+          return true; // Move a follower replica of a topic of this goal's interest is always self-satisfied since it does not matter\n+        }\n+        return isSelfSatisfiedToMoveOneLeaderReplica(sourceBroker,\n+                                                     clusterModel.broker(action.destinationBrokerId()),\n+                                                     replicaToBeMoved);\n+      case INTER_BROKER_REPLICA_SWAP:\n+        return isSwapActionSelfSatisfied(clusterModel, action);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private boolean isSwapActionSelfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    if (action.balancingAction() != ActionType.INTER_BROKER_REPLICA_SWAP) {\n+      throw new IllegalArgumentException(\"Expected INTER_BROKER_REPLICA_SWAP. But got: \" + action.balancingAction());\n+    }\n+    Replica sourceReplica = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+    Replica destinationReplica = clusterModel.broker(action.destinationBrokerId()).replica(action.topicPartition());\n+    if (sourceReplica.isLeader() == destinationReplica.isLeader() && Objects.equals(action.topic(), action.destinationTopic())) {\n+      // Swapping either 2 leader replicas or 2 follower replicas of the same topic has no effect on this goal\n+      return true;\n+    }\n+    return isSelfSatisfiedToMoveOneLeaderReplica(clusterModel.broker(action.sourceBrokerId()),\n+                                                 clusterModel.broker(action.destinationBrokerId()),\n+                                                 sourceReplica)\n+           && isSelfSatisfiedToMoveOneLeaderReplica(clusterModel.broker(action.destinationBrokerId()),\n+                                                    clusterModel.broker(action.sourceBrokerId()),\n+                                                    destinationReplica);\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Check whether it is self-satisfied to move a leader replica of a topic with the given name from a the given source\n+   * broker to the given destination broker\n+   * @param sourceBroker the broker from which a leader replica is removed\n+   * @param destinationBroker the broker from which a leader replica is added\n+   * @param replicaToBeMoved replica to be moved from the source broker to the destination broker\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean isSelfSatisfiedToMoveOneLeaderReplica(Broker sourceBroker, Broker destinationBroker, Replica replicaToBeMoved) {\n+    if (!replicaToBeMoved.isLeader()) {\n+      return true;\n+    }\n+    String topicName = replicaToBeMoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      return true;\n+    }\n+    // Moving a replica leadership from a not-alive broker to an alive broker is self-satisfied\n+    if (!sourceBroker.isAlive() && destinationBroker.isAlive()) {\n+      return true;\n+    }\n+    // Moving leader replica from more abundant broker could be considered as self-satisfied\n+    return sourceBroker.numLeaderReplicasOfTopicInBroker(topicName) > destinationBroker.numLeaderReplicasOfTopicInBroker(topicName);\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderReplicaOfTopics(clusterModel, optimizationOptions);\n+    finish();\n+  }\n+\n+  private void ensureBrokersAllHaveEnoughLeaderReplicaOfTopics(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    for (Broker broker : clusterModel.brokers()) {\n+      if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+        continue;\n+      }\n+      for (String mustHaveLeaderReplicaPerBrokerTopicName : _mustHaveTopicLeadersPerBroker) {\n+        int leaderReplicaCount = broker.numLeaderReplicasOfTopicInBroker(mustHaveLeaderReplicaPerBrokerTopicName);\n+        if (leaderReplicaCount < minTopicLeadersPerBroker()) {\n+          throw new OptimizationFailureException(String.format(\"Broker %d does not have enough leader replica for topic %s. \"\n+              + \"Minimum required per-broker leader replica count %d. Actual broker leader replica count %d\",\n+              broker.id(), mustHaveLeaderReplicaPerBrokerTopicName, minTopicLeadersPerBroker(), leaderReplicaCount));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of the current goal and optimized goals.\n+   * @param broker         Broker to be balanced.\n+   * @param clusterModel   The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    LOG.debug(\"balancing broker {}, optimized goals = {}\", broker, optimizedGoals);\n+    moveAwayOfflineReplicas(broker, clusterModel, optimizedGoals, optimizationOptions);\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+      return;\n+    }\n+    for (String topicMustHaveLeaderReplicaPerBroker : _mustHaveTopicLeadersPerBroker) {\n+      maybeMoveLeaderReplicaOfTopicToBroker(topicMustHaveLeaderReplicaPerBroker, broker, clusterModel, optimizedGoals, optimizationOptions);\n+    }\n+  }\n+\n+  private void maybeMoveLeaderReplicaOfTopicToBroker(String topicMustHaveLeaderReplicaPerBroker,\n+                                                     Broker broker,\n+                                                     ClusterModel clusterModel,\n+                                                     Set<Goal> optimizedGoals,\n+                                                     OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (brokerHasSufficientLeaderReplicasOfTopic(broker, topicMustHaveLeaderReplicaPerBroker)) {\n+      return; // This broker has enough leader replica(s)\n+    }\n+    // Try to elect follower replica(s) of the interested topic on this broker to be leader\n+    Set<Replica> followerReplicas = broker.replicas().stream()\n+                                          .filter(\n+                                              replica -> !replica.isLeader()\n+                                                         && replica.topicPartition().topic().equals(topicMustHaveLeaderReplicaPerBroker))\n+                                          .collect(Collectors.toSet());\n+\n+    for (Replica followerReplica : followerReplicas) {\n+      Replica leaderReplica = leaderReplicaOfTopicPartition(clusterModel, followerReplica.topicPartition());\n+      if (leaderReplica == null) {\n+        LOG.warn(\"No leader replica for {}\", followerReplica.topicPartition());\n+      } else {\n+        if (leaderReplica.broker().id() != broker.id()\n+            && leaderReplica.broker().numLeaderReplicasOfTopicInBroker(topicMustHaveLeaderReplicaPerBroker) > minTopicLeadersPerBroker()) {\n+          maybeApplyBalancingAction(clusterModel, leaderReplica, Collections.singleton(broker),\n+                                    LEADERSHIP_MOVEMENT, optimizedGoals, optimizationOptions);\n+        }\n+      }\n+      if (brokerHasSufficientLeaderReplicasOfTopic(broker, topicMustHaveLeaderReplicaPerBroker)) {\n+        return; // This broker satisfies this goal\n+      }\n+    }\n+\n+    // Try to move leader replica(s) of the interested topic from other brokers to this broker\n+    PriorityQueue<Broker> brokersWithExcessiveLeaderReplicaToMove =\n+        getBrokersWithExcessiveLeaderReplicaToMove(topicMustHaveLeaderReplicaPerBroker, clusterModel, broker);\n+\n+    while (!brokersWithExcessiveLeaderReplicaToMove.isEmpty()) {\n+      Broker brokerWithExcessiveLeaderReplicaToMove = brokersWithExcessiveLeaderReplicaToMove.poll();\n+      List<Replica> leaderReplicasOfTopic = brokerWithExcessiveLeaderReplicaToMove.replicas().stream()\n+                                                                                  .filter(replica ->\n+                                                                                              replica.isLeader()\n+                                                                                              && replica.topicPartition()\n+                                                                                                        .topic()\n+                                                                                                        .equals(topicMustHaveLeaderReplicaPerBroker))\n+                                                                                  .collect(Collectors.toList());\n+      boolean leaderReplicaMoved = false;\n+      for (Replica leaderReplicaOfTopic : leaderReplicasOfTopic) {\n+        Broker destinationBroker = maybeApplyBalancingAction(clusterModel, leaderReplicaOfTopic, Collections.singleton(broker),\n+                                                             INTER_BROKER_REPLICA_MOVEMENT, optimizedGoals, optimizationOptions);\n+        if (destinationBroker != null) {\n+          leaderReplicaMoved = true;\n+          break; // Successfully move one leader replica\n+        }\n+      }\n+      if (leaderReplicaMoved) {\n+        if (brokerHasSufficientLeaderReplicasOfTopic(broker, topicMustHaveLeaderReplicaPerBroker)) {\n+          return; // This broker satisfies this goal\n+        }\n+        if (brokerHasExcessiveLeaderReplicasOfTopic(topicMustHaveLeaderReplicaPerBroker, brokerWithExcessiveLeaderReplicaToMove)) {\n+          brokersWithExcessiveLeaderReplicaToMove.add(brokerWithExcessiveLeaderReplicaToMove);\n+        }\n+      }\n+    }\n+\n+    if (!brokerHasSufficientLeaderReplicasOfTopic(broker, topicMustHaveLeaderReplicaPerBroker)) {\n+      throw new OptimizationFailureException(String.format(\"Cannot make broker %d have at least %d leader replica(s) of topic %s\",\n+                                                           broker.id(),\n+                                                           minTopicLeadersPerBroker(),\n+                                                           topicMustHaveLeaderReplicaPerBroker));\n+    }\n+  }\n+\n+  private boolean brokerHasSufficientLeaderReplicasOfTopic(Broker broker, String topicName) {\n+    return broker.numLeaderReplicasOfTopicInBroker(topicName) >= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This method creates a priority queue which has the broker with the most number of leader replicas of a given topic at the top of queue\n+   * @param topicName name of the given topic\n+   * @param clusterModel cluster model\n+   * @param originalBroker original broker which needs to be excluded from the priority queue\n+   * @return a priority queue which has the broker with the most number of leader replicas of a given topic at the top of queue\n+   */\n+  private PriorityQueue<Broker> getBrokersWithExcessiveLeaderReplicaToMove(String topicName, ClusterModel clusterModel, Broker originalBroker) {\n+    PriorityQueue<Broker> brokersWithExcessiveLeaderReplicaToMove = new PriorityQueue<>((broker1, broker2) -> {\n+      int broker1LeaderReplicaCount = broker1.numLeaderReplicasOfTopicInBroker(topicName);\n+      int broker2LeaderReplicaCount = broker2.numLeaderReplicasOfTopicInBroker(topicName);\n+      int leaderReplicaCountCompareResult = Integer.compare(broker2LeaderReplicaCount, broker1LeaderReplicaCount);\n+      return leaderReplicaCountCompareResult == 0 ? Integer.compare(broker1.id(), broker2.id()) : leaderReplicaCountCompareResult;\n+    });\n+    clusterModel.brokers().forEach((broker -> {\n+      if (broker.isAlive() && broker.id() != originalBroker.id() && brokerHasExcessiveLeaderReplicasOfTopic(topicName, broker)) {\n+        brokersWithExcessiveLeaderReplicaToMove.add(broker);\n+      }\n+    }));\n+    return brokersWithExcessiveLeaderReplicaToMove;\n+  }\n+\n+  private boolean brokerHasExcessiveLeaderReplicasOfTopic(String topicName, Broker broker) {\n+    return broker.numLeaderReplicasOfTopicInBroker(topicName) > minTopicLeadersPerBroker();\n+  }\n+\n+  @Nullable\n+  private Replica leaderReplicaOfTopicPartition(ClusterModel clusterModel, TopicPartition topicPartition) {\n+    for (Replica leaderReplica : clusterModel.leaderReplicas()) {\n+      if (leaderReplica.topicPartition().equals(topicPartition)) {\n+        return leaderReplica;\n+      }\n+    }\n+    return null;\n+  }\n+\n+\n+  private Set<Broker> eligibleBrokersForLeadership(ClusterModel clusterModel, OptimizationOptions optimizationOptions) {\n+    return clusterModel.brokers()\n+                       .stream()\n+                       .filter(broker -> isEligibleToHaveLeaders(broker, optimizationOptions))\n+                       .collect(Collectors.toSet());\n+  }\n+\n+  private boolean isEligibleToHaveLeaders(Broker broker, OptimizationOptions optimizationOptions) {\n+    return broker.isAlive()\n+           && !optimizationOptions.excludedBrokersForLeadership().contains(broker.id())\n+           && !optimizationOptions.excludedBrokersForReplicaMove().contains(broker.id());\n+  }\n+\n+  private void moveAwayOfflineReplicas(Broker srcBroker,\n+                                       ClusterModel clusterModel,\n+                                       Set<Goal> optimizedGoals,\n+                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (srcBroker.currentOfflineReplicas().isEmpty()) {\n+      return;\n+    }\n+    SortedSet<Broker> eligibleBrokersToMoveOfflineReplicasTo = findEligibleBrokersToMoveOfflineReplicasTo(clusterModel, optimizationOptions);\n+    eligibleBrokersToMoveOfflineReplicasTo.removeIf(broker -> broker.id() == srcBroker.id());", "originalCommit": "ccbd661e4287e1216c859aa15ffc6672c2195462", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "08ae15b2294dabc676c32b4d28772873240eaa2b", "url": "https://github.com/linkedin/cruise-control/commit/08ae15b2294dabc676c32b4d28772873240eaa2b", "message": "Remove redundant method", "committedDate": "2021-02-02T03:13:04Z", "type": "commit"}, {"oid": "c8f1a25feecce3d5e7de4722f536f8229d5d382f", "url": "https://github.com/linkedin/cruise-control/commit/c8f1a25feecce3d5e7de4722f536f8229d5d382f", "message": "Start using untrackSortedReplicas method", "committedDate": "2021-02-02T06:20:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgzMTQzOQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568831439", "bodyText": "The finally block in AbstractGoal already calls the following:\n      // Clear any sorted replicas tracked in the process of optimization.\n      clusterModel.clearSortedReplicas();\n\nSo calling this function here seems redundant. Can we drop this?\n-- also note that for such uses we should have preferred ClusterModel#untrackSortedReplicas(String).", "author": "efeg", "createdAt": "2021-02-02T18:24:24Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,472 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private final String _replicaSortName = replicaSortName(this, true, false);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeadersFor(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(_replicaSortName, clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderReplicaToDistribute(ClusterModel clusterModel,\n+                                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderReplicaCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderReplicaCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          numLeadersPerTopic.getValue(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+    Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+\n+    if (replicaToBeMoved.broker().replica(action.topicPartition()).isCurrentOffline()) {\n+      return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+    }\n+    // Moving leader replica from more abundant broker is considered as self-satisfied\n+    return sourceBroker.numLeadersFor(replicaToBeMoved.topicPartition().topic()) > minTopicLeadersPerBroker();\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderReplicaOfTopics(clusterModel, optimizationOptions);\n+    clusterModel.brokers().forEach(broker -> broker.untrackSortedReplicas(_replicaSortName));", "originalCommit": "c8f1a25feecce3d5e7de4722f536f8229d5d382f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgzNTIwMg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568835202", "bodyText": "Nit (I will not list each case here, but this applies to any other function name, variable name, and comment in this class): Can we change LeaderReplica -> Leader?", "author": "efeg", "createdAt": "2021-02-02T18:29:48Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,472 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private final String _replicaSortName = replicaSortName(this, true, false);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeadersFor(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(_replicaSortName, clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderReplicaToDistribute(ClusterModel clusterModel,\n+                                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderReplicaCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();", "originalCommit": "c8f1a25feecce3d5e7de4722f536f8229d5d382f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4NjM4NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568886385", "bodyText": "Fixed", "author": "Lincong", "createdAt": "2021-02-02T19:51:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgzNTIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgzNjgyMQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568836821", "bodyText": "total minimum required leader count %d uses the value numLeadersPerTopic.getValue(). But, this uses the same value numLeadersPerTopic.getValue(), which was already used in this message.\nShould we instead print minTopicLeadersPerBroker() with proper message?", "author": "efeg", "createdAt": "2021-02-02T18:32:14Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,472 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private final String _replicaSortName = replicaSortName(this, true, false);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeadersFor(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(_replicaSortName, clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderReplicaToDistribute(ClusterModel clusterModel,\n+                                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderReplicaCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderReplicaCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          numLeadersPerTopic.getValue(), numLeadersPerTopic.getKey()));", "originalCommit": "c8f1a25feecce3d5e7de4722f536f8229d5d382f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4NzI0OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568887249", "bodyText": "Yes, good catch!", "author": "Lincong", "createdAt": "2021-02-02T19:53:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgzNjgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg1MDU5OA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568850598", "bodyText": "Don't we already selectReplicasBasedOnIncludedTopics? Why do we need this filtering?\n\nThere is a similar use below. Please also verify that.", "author": "efeg", "createdAt": "2021-02-02T18:53:48Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,472 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private final String _replicaSortName = replicaSortName(this, true, false);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderReplicaRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderReplicaRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderReplicaRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderReplicaRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderReplicaCountOnSourceBroker = replicaToBeRemoved.broker().numLeadersFor(topicName);\n+    return topicLeaderReplicaCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderReplicaIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderReplicaToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(_replicaSortName, clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderReplicaIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderReplicaToDistribute(ClusterModel clusterModel,\n+                                                       OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderReplicaCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderReplicaCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          numLeadersPerTopic.getValue(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+    Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+\n+    if (replicaToBeMoved.broker().replica(action.topicPartition()).isCurrentOffline()) {\n+      return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+    }\n+    // Moving leader replica from more abundant broker is considered as self-satisfied\n+    return sourceBroker.numLeadersFor(replicaToBeMoved.topicPartition().topic()) > minTopicLeadersPerBroker();\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderReplicaOfTopics(clusterModel, optimizationOptions);\n+    clusterModel.brokers().forEach(broker -> broker.untrackSortedReplicas(_replicaSortName));\n+    finish();\n+  }\n+\n+  private void ensureBrokersAllHaveEnoughLeaderReplicaOfTopics(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    for (Broker broker : clusterModel.aliveBrokers()) {\n+      if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+        continue;\n+      }\n+      for (String mustHaveLeaderReplicaPerBrokerTopicName : _mustHaveTopicLeadersPerBroker) {\n+        int leaderReplicaCount = broker.numLeadersFor(mustHaveLeaderReplicaPerBrokerTopicName);\n+        if (leaderReplicaCount < minTopicLeadersPerBroker()) {\n+          throw new OptimizationFailureException(String.format(\"Broker %d does not have enough leader replica for topic %s. \"\n+              + \"Minimum required per-broker leader replica count %d. Actual broker leader replica count %d\",\n+              broker.id(), mustHaveLeaderReplicaPerBrokerTopicName, minTopicLeadersPerBroker(), leaderReplicaCount));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of the current goal and optimized goals.\n+   * @param broker         Broker to be balanced.\n+   * @param clusterModel   The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    LOG.debug(\"balancing broker {}, optimized goals = {}\", broker, optimizedGoals);\n+    moveAwayOfflineReplicas(broker, clusterModel, optimizedGoals, optimizationOptions);\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+      return;\n+    }\n+    for (String topicMustHaveLeaderReplicaPerBroker : _mustHaveTopicLeadersPerBroker) {\n+      maybeMoveLeaderReplicaOfTopicToBroker(topicMustHaveLeaderReplicaPerBroker, broker, clusterModel, optimizedGoals, optimizationOptions);\n+    }\n+  }\n+\n+  private void maybeMoveLeaderReplicaOfTopicToBroker(String topicMustHaveLeaderReplicaPerBroker,\n+                                                     Broker broker,\n+                                                     ClusterModel clusterModel,\n+                                                     Set<Goal> optimizedGoals,\n+                                                     OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (brokerHasSufficientLeaderReplicasOfTopic(broker, topicMustHaveLeaderReplicaPerBroker)) {\n+      return; // This broker has enough leader replica(s)\n+    }\n+    // Try to elect follower replica(s) of the interested topic on this broker to be leader\n+    Set<Replica> followerReplicas = broker.trackedSortedReplicas(_replicaSortName)\n+                                          .sortedReplicas(false).stream().filter(\n+                                              replica -> !replica.isLeader()\n+                                                         && replica.topicPartition().topic().equals(topicMustHaveLeaderReplicaPerBroker))", "originalCommit": "c8f1a25feecce3d5e7de4722f536f8229d5d382f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4ODgwMw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568888803", "bodyText": "The selectReplicasBasedOnIncludedTopics method takes a set of topic names. Here, we need to find (leader) replicas of a specific topic with the name topicMustHaveLeaderReplicaPerBroker. So, this filtering is necessary.", "author": "Lincong", "createdAt": "2021-02-02T19:56:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg1MDU5OA=="}], "type": "inlineReview"}, {"oid": "f3351c308cc3b4aecbc73ec16807124d327addab", "url": "https://github.com/linkedin/cruise-control/commit/f3351c308cc3b4aecbc73ec16807124d327addab", "message": "Replace leaderReplica with leader", "committedDate": "2021-02-02T19:54:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg5MjgyMg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568892822", "bodyText": "Can we drop leaderOfTopicPartition function and instead use\nReplica leader = clusterModel.partition(followerReplica.topicPartition()).leader();", "author": "efeg", "createdAt": "2021-02-02T20:02:45Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private final String _replicaSortName = replicaSortName(this, true, false);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderCountOnSourceBroker = replicaToBeRemoved.broker().numLeadersFor(topicName);\n+    return topicLeaderCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(_replicaSortName, clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderToDistribute(ClusterModel clusterModel,\n+                                                OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          minTopicLeadersPerBroker(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+    Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+\n+    if (replicaToBeMoved.broker().replica(action.topicPartition()).isCurrentOffline()) {\n+      return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+    }\n+    // Moving leader replica from more abundant broker is considered as self-satisfied\n+    return sourceBroker.numLeadersFor(replicaToBeMoved.topicPartition().topic()) > minTopicLeadersPerBroker();\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderOfTopics(clusterModel, optimizationOptions);\n+    finish();\n+  }\n+\n+  private void ensureBrokersAllHaveEnoughLeaderOfTopics(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    for (Broker broker : clusterModel.aliveBrokers()) {\n+      if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+        continue;\n+      }\n+      for (String mustHaveLeaderPerBrokerTopicName : _mustHaveTopicLeadersPerBroker) {\n+        int leaderCount = broker.numLeadersFor(mustHaveLeaderPerBrokerTopicName);\n+        if (leaderCount < minTopicLeadersPerBroker()) {\n+          throw new OptimizationFailureException(String.format(\"Broker %d does not have enough leader replica for topic %s. \"\n+              + \"Minimum required per-broker leader replica count %d. Actual broker leader replica count %d\",\n+              broker.id(), mustHaveLeaderPerBrokerTopicName, minTopicLeadersPerBroker(), leaderCount));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of the current goal and optimized goals.\n+   * @param broker         Broker to be balanced.\n+   * @param clusterModel   The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    LOG.debug(\"balancing broker {}, optimized goals = {}\", broker, optimizedGoals);\n+    moveAwayOfflineReplicas(broker, clusterModel, optimizedGoals, optimizationOptions);\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+      return;\n+    }\n+    for (String topicMustHaveLeaderPerBroker : _mustHaveTopicLeadersPerBroker) {\n+      maybeMoveLeaderOfTopicToBroker(topicMustHaveLeaderPerBroker, broker, clusterModel, optimizedGoals, optimizationOptions);\n+    }\n+  }\n+\n+  private void maybeMoveLeaderOfTopicToBroker(String topicMustHaveLeaderPerBroker,\n+                                              Broker broker,\n+                                              ClusterModel clusterModel,\n+                                              Set<Goal> optimizedGoals,\n+                                              OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (brokerHasSufficientLeadersOfTopic(broker, topicMustHaveLeaderPerBroker)) {\n+      return; // This broker has enough leader replica(s)\n+    }\n+    // Try to elect follower replica(s) of the interested topic on this broker to be leader\n+    Set<Replica> followerReplicas = broker.trackedSortedReplicas(_replicaSortName)\n+                                          .sortedReplicas(false).stream().filter(\n+                                              replica -> !replica.isLeader()\n+                                                         && replica.topicPartition().topic().equals(topicMustHaveLeaderPerBroker))\n+                                          .collect(Collectors.toSet());\n+\n+    for (Replica followerReplica : followerReplicas) {\n+      Replica leader = leaderOfTopicPartition(clusterModel, followerReplica.topicPartition());", "originalCommit": "f3351c308cc3b4aecbc73ec16807124d327addab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg5NzE3NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568897175", "bodyText": "By construction of cluster model, we can assume that each partition has a leader -- Can we drop leader==null check?", "author": "efeg", "createdAt": "2021-02-02T20:10:13Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private final String _replicaSortName = replicaSortName(this, true, false);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderCountOnSourceBroker = replicaToBeRemoved.broker().numLeadersFor(topicName);\n+    return topicLeaderCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(_replicaSortName, clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderToDistribute(ClusterModel clusterModel,\n+                                                OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          minTopicLeadersPerBroker(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+    Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+\n+    if (replicaToBeMoved.broker().replica(action.topicPartition()).isCurrentOffline()) {\n+      return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+    }\n+    // Moving leader replica from more abundant broker is considered as self-satisfied\n+    return sourceBroker.numLeadersFor(replicaToBeMoved.topicPartition().topic()) > minTopicLeadersPerBroker();\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderOfTopics(clusterModel, optimizationOptions);\n+    finish();\n+  }\n+\n+  private void ensureBrokersAllHaveEnoughLeaderOfTopics(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    for (Broker broker : clusterModel.aliveBrokers()) {\n+      if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+        continue;\n+      }\n+      for (String mustHaveLeaderPerBrokerTopicName : _mustHaveTopicLeadersPerBroker) {\n+        int leaderCount = broker.numLeadersFor(mustHaveLeaderPerBrokerTopicName);\n+        if (leaderCount < minTopicLeadersPerBroker()) {\n+          throw new OptimizationFailureException(String.format(\"Broker %d does not have enough leader replica for topic %s. \"\n+              + \"Minimum required per-broker leader replica count %d. Actual broker leader replica count %d\",\n+              broker.id(), mustHaveLeaderPerBrokerTopicName, minTopicLeadersPerBroker(), leaderCount));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of the current goal and optimized goals.\n+   * @param broker         Broker to be balanced.\n+   * @param clusterModel   The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    LOG.debug(\"balancing broker {}, optimized goals = {}\", broker, optimizedGoals);\n+    moveAwayOfflineReplicas(broker, clusterModel, optimizedGoals, optimizationOptions);\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+      return;\n+    }\n+    for (String topicMustHaveLeaderPerBroker : _mustHaveTopicLeadersPerBroker) {\n+      maybeMoveLeaderOfTopicToBroker(topicMustHaveLeaderPerBroker, broker, clusterModel, optimizedGoals, optimizationOptions);\n+    }\n+  }\n+\n+  private void maybeMoveLeaderOfTopicToBroker(String topicMustHaveLeaderPerBroker,\n+                                              Broker broker,\n+                                              ClusterModel clusterModel,\n+                                              Set<Goal> optimizedGoals,\n+                                              OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (brokerHasSufficientLeadersOfTopic(broker, topicMustHaveLeaderPerBroker)) {\n+      return; // This broker has enough leader replica(s)\n+    }\n+    // Try to elect follower replica(s) of the interested topic on this broker to be leader\n+    Set<Replica> followerReplicas = broker.trackedSortedReplicas(_replicaSortName)\n+                                          .sortedReplicas(false).stream().filter(\n+                                              replica -> !replica.isLeader()\n+                                                         && replica.topicPartition().topic().equals(topicMustHaveLeaderPerBroker))\n+                                          .collect(Collectors.toSet());\n+\n+    for (Replica followerReplica : followerReplicas) {\n+      Replica leader = leaderOfTopicPartition(clusterModel, followerReplica.topicPartition());\n+      if (leader == null) {\n+        LOG.warn(\"No leader replica for {}\", followerReplica.topicPartition());\n+      } else {", "originalCommit": "f3351c308cc3b4aecbc73ec16807124d327addab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODkwMDYxMA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568900610", "bodyText": "leader.broker().id() != broker.id() -> the leader is the leader replica of the partition that the followerReplica belongs to. Given that a replica cannot be a follower and a leader at the same time, isn't this check a no-op?\nIf so, can we drop this check?", "author": "efeg", "createdAt": "2021-02-02T20:16:32Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private final String _replicaSortName = replicaSortName(this, true, false);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderCountOnSourceBroker = replicaToBeRemoved.broker().numLeadersFor(topicName);\n+    return topicLeaderCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(_replicaSortName, clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderToDistribute(ClusterModel clusterModel,\n+                                                OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          minTopicLeadersPerBroker(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+    Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+\n+    if (replicaToBeMoved.broker().replica(action.topicPartition()).isCurrentOffline()) {\n+      return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+    }\n+    // Moving leader replica from more abundant broker is considered as self-satisfied\n+    return sourceBroker.numLeadersFor(replicaToBeMoved.topicPartition().topic()) > minTopicLeadersPerBroker();\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderOfTopics(clusterModel, optimizationOptions);\n+    finish();\n+  }\n+\n+  private void ensureBrokersAllHaveEnoughLeaderOfTopics(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    for (Broker broker : clusterModel.aliveBrokers()) {\n+      if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+        continue;\n+      }\n+      for (String mustHaveLeaderPerBrokerTopicName : _mustHaveTopicLeadersPerBroker) {\n+        int leaderCount = broker.numLeadersFor(mustHaveLeaderPerBrokerTopicName);\n+        if (leaderCount < minTopicLeadersPerBroker()) {\n+          throw new OptimizationFailureException(String.format(\"Broker %d does not have enough leader replica for topic %s. \"\n+              + \"Minimum required per-broker leader replica count %d. Actual broker leader replica count %d\",\n+              broker.id(), mustHaveLeaderPerBrokerTopicName, minTopicLeadersPerBroker(), leaderCount));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of the current goal and optimized goals.\n+   * @param broker         Broker to be balanced.\n+   * @param clusterModel   The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    LOG.debug(\"balancing broker {}, optimized goals = {}\", broker, optimizedGoals);\n+    moveAwayOfflineReplicas(broker, clusterModel, optimizedGoals, optimizationOptions);\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+      return;\n+    }\n+    for (String topicMustHaveLeaderPerBroker : _mustHaveTopicLeadersPerBroker) {\n+      maybeMoveLeaderOfTopicToBroker(topicMustHaveLeaderPerBroker, broker, clusterModel, optimizedGoals, optimizationOptions);\n+    }\n+  }\n+\n+  private void maybeMoveLeaderOfTopicToBroker(String topicMustHaveLeaderPerBroker,\n+                                              Broker broker,\n+                                              ClusterModel clusterModel,\n+                                              Set<Goal> optimizedGoals,\n+                                              OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (brokerHasSufficientLeadersOfTopic(broker, topicMustHaveLeaderPerBroker)) {\n+      return; // This broker has enough leader replica(s)\n+    }\n+    // Try to elect follower replica(s) of the interested topic on this broker to be leader\n+    Set<Replica> followerReplicas = broker.trackedSortedReplicas(_replicaSortName)\n+                                          .sortedReplicas(false).stream().filter(\n+                                              replica -> !replica.isLeader()\n+                                                         && replica.topicPartition().topic().equals(topicMustHaveLeaderPerBroker))\n+                                          .collect(Collectors.toSet());\n+\n+    for (Replica followerReplica : followerReplicas) {\n+      Replica leader = leaderOfTopicPartition(clusterModel, followerReplica.topicPartition());\n+      if (leader == null) {\n+        LOG.warn(\"No leader replica for {}\", followerReplica.topicPartition());\n+      } else {\n+        if (leader.broker().id() != broker.id()", "originalCommit": "f3351c308cc3b4aecbc73ec16807124d327addab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODkwMzEwNg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568903106", "bodyText": "Isn't this a bit early to untrackSortedReplicas? It is not guaranteed that This broker satisfies this goal -- at this point, we only know that this broker satisfies this goal for this topic. Hence, it might still be violating the goal for other topics.\n\n\nDon't we have tests with multiple topics to verify this? Can we make sure that we have a unit test that fails if this is not fixed?", "author": "efeg", "createdAt": "2021-02-02T20:20:39Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private final String _replicaSortName = replicaSortName(this, true, false);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderCountOnSourceBroker = replicaToBeRemoved.broker().numLeadersFor(topicName);\n+    return topicLeaderCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(_replicaSortName, clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderToDistribute(ClusterModel clusterModel,\n+                                                OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          minTopicLeadersPerBroker(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+    Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+\n+    if (replicaToBeMoved.broker().replica(action.topicPartition()).isCurrentOffline()) {\n+      return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+    }\n+    // Moving leader replica from more abundant broker is considered as self-satisfied\n+    return sourceBroker.numLeadersFor(replicaToBeMoved.topicPartition().topic()) > minTopicLeadersPerBroker();\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderOfTopics(clusterModel, optimizationOptions);\n+    finish();\n+  }\n+\n+  private void ensureBrokersAllHaveEnoughLeaderOfTopics(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    for (Broker broker : clusterModel.aliveBrokers()) {\n+      if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+        continue;\n+      }\n+      for (String mustHaveLeaderPerBrokerTopicName : _mustHaveTopicLeadersPerBroker) {\n+        int leaderCount = broker.numLeadersFor(mustHaveLeaderPerBrokerTopicName);\n+        if (leaderCount < minTopicLeadersPerBroker()) {\n+          throw new OptimizationFailureException(String.format(\"Broker %d does not have enough leader replica for topic %s. \"\n+              + \"Minimum required per-broker leader replica count %d. Actual broker leader replica count %d\",\n+              broker.id(), mustHaveLeaderPerBrokerTopicName, minTopicLeadersPerBroker(), leaderCount));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of the current goal and optimized goals.\n+   * @param broker         Broker to be balanced.\n+   * @param clusterModel   The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    LOG.debug(\"balancing broker {}, optimized goals = {}\", broker, optimizedGoals);\n+    moveAwayOfflineReplicas(broker, clusterModel, optimizedGoals, optimizationOptions);\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+      return;\n+    }\n+    for (String topicMustHaveLeaderPerBroker : _mustHaveTopicLeadersPerBroker) {\n+      maybeMoveLeaderOfTopicToBroker(topicMustHaveLeaderPerBroker, broker, clusterModel, optimizedGoals, optimizationOptions);\n+    }\n+  }\n+\n+  private void maybeMoveLeaderOfTopicToBroker(String topicMustHaveLeaderPerBroker,\n+                                              Broker broker,\n+                                              ClusterModel clusterModel,\n+                                              Set<Goal> optimizedGoals,\n+                                              OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (brokerHasSufficientLeadersOfTopic(broker, topicMustHaveLeaderPerBroker)) {\n+      return; // This broker has enough leader replica(s)\n+    }\n+    // Try to elect follower replica(s) of the interested topic on this broker to be leader\n+    Set<Replica> followerReplicas = broker.trackedSortedReplicas(_replicaSortName)\n+                                          .sortedReplicas(false).stream().filter(\n+                                              replica -> !replica.isLeader()\n+                                                         && replica.topicPartition().topic().equals(topicMustHaveLeaderPerBroker))\n+                                          .collect(Collectors.toSet());\n+\n+    for (Replica followerReplica : followerReplicas) {\n+      Replica leader = leaderOfTopicPartition(clusterModel, followerReplica.topicPartition());\n+      if (leader == null) {\n+        LOG.warn(\"No leader replica for {}\", followerReplica.topicPartition());\n+      } else {\n+        if (leader.broker().id() != broker.id()\n+            && leader.broker().numLeadersFor(topicMustHaveLeaderPerBroker) > minTopicLeadersPerBroker()) {\n+          maybeApplyBalancingAction(clusterModel, leader, Collections.singleton(broker),\n+                                    LEADERSHIP_MOVEMENT, optimizedGoals, optimizationOptions);\n+        }\n+      }\n+      if (brokerHasSufficientLeadersOfTopic(broker, topicMustHaveLeaderPerBroker)) {\n+        broker.untrackSortedReplicas(_replicaSortName);\n+        return; // This broker satisfies this goal", "originalCommit": "f3351c308cc3b4aecbc73ec16807124d327addab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODk2ODE3NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568968175", "bodyText": "Good point. Will add unit tests to cover this case", "author": "Lincong", "createdAt": "2021-02-02T22:14:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODkwMzEwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODkwMzczMw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568903733", "bodyText": "Each call to brokerHasSufficientLeadersOfTopic is performed within a loop here. But this is costly. We know that every time a balancing action succeeds, it would move only one leader into this broker. So we can just get the count once before the loop, and then increment the value in a variable as necessary, which is cheaper.", "author": "efeg", "createdAt": "2021-02-02T20:21:53Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private final String _replicaSortName = replicaSortName(this, true, false);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderCountOnSourceBroker = replicaToBeRemoved.broker().numLeadersFor(topicName);\n+    return topicLeaderCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(_replicaSortName, clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderToDistribute(ClusterModel clusterModel,\n+                                                OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          minTopicLeadersPerBroker(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+    Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+\n+    if (replicaToBeMoved.broker().replica(action.topicPartition()).isCurrentOffline()) {\n+      return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+    }\n+    // Moving leader replica from more abundant broker is considered as self-satisfied\n+    return sourceBroker.numLeadersFor(replicaToBeMoved.topicPartition().topic()) > minTopicLeadersPerBroker();\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderOfTopics(clusterModel, optimizationOptions);\n+    finish();\n+  }\n+\n+  private void ensureBrokersAllHaveEnoughLeaderOfTopics(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    for (Broker broker : clusterModel.aliveBrokers()) {\n+      if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+        continue;\n+      }\n+      for (String mustHaveLeaderPerBrokerTopicName : _mustHaveTopicLeadersPerBroker) {\n+        int leaderCount = broker.numLeadersFor(mustHaveLeaderPerBrokerTopicName);\n+        if (leaderCount < minTopicLeadersPerBroker()) {\n+          throw new OptimizationFailureException(String.format(\"Broker %d does not have enough leader replica for topic %s. \"\n+              + \"Minimum required per-broker leader replica count %d. Actual broker leader replica count %d\",\n+              broker.id(), mustHaveLeaderPerBrokerTopicName, minTopicLeadersPerBroker(), leaderCount));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of the current goal and optimized goals.\n+   * @param broker         Broker to be balanced.\n+   * @param clusterModel   The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    LOG.debug(\"balancing broker {}, optimized goals = {}\", broker, optimizedGoals);\n+    moveAwayOfflineReplicas(broker, clusterModel, optimizedGoals, optimizationOptions);\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+      return;\n+    }\n+    for (String topicMustHaveLeaderPerBroker : _mustHaveTopicLeadersPerBroker) {\n+      maybeMoveLeaderOfTopicToBroker(topicMustHaveLeaderPerBroker, broker, clusterModel, optimizedGoals, optimizationOptions);\n+    }\n+  }\n+\n+  private void maybeMoveLeaderOfTopicToBroker(String topicMustHaveLeaderPerBroker,\n+                                              Broker broker,\n+                                              ClusterModel clusterModel,\n+                                              Set<Goal> optimizedGoals,\n+                                              OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (brokerHasSufficientLeadersOfTopic(broker, topicMustHaveLeaderPerBroker)) {\n+      return; // This broker has enough leader replica(s)\n+    }\n+    // Try to elect follower replica(s) of the interested topic on this broker to be leader\n+    Set<Replica> followerReplicas = broker.trackedSortedReplicas(_replicaSortName)\n+                                          .sortedReplicas(false).stream().filter(\n+                                              replica -> !replica.isLeader()\n+                                                         && replica.topicPartition().topic().equals(topicMustHaveLeaderPerBroker))\n+                                          .collect(Collectors.toSet());\n+\n+    for (Replica followerReplica : followerReplicas) {\n+      Replica leader = leaderOfTopicPartition(clusterModel, followerReplica.topicPartition());\n+      if (leader == null) {\n+        LOG.warn(\"No leader replica for {}\", followerReplica.topicPartition());\n+      } else {\n+        if (leader.broker().id() != broker.id()\n+            && leader.broker().numLeadersFor(topicMustHaveLeaderPerBroker) > minTopicLeadersPerBroker()) {\n+          maybeApplyBalancingAction(clusterModel, leader, Collections.singleton(broker),\n+                                    LEADERSHIP_MOVEMENT, optimizedGoals, optimizationOptions);\n+        }\n+      }\n+      if (brokerHasSufficientLeadersOfTopic(broker, topicMustHaveLeaderPerBroker)) {", "originalCommit": "f3351c308cc3b4aecbc73ec16807124d327addab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODk2NTM4NA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568965384", "bodyText": "Good idea", "author": "Lincong", "createdAt": "2021-02-02T22:09:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODkwMzczMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODkxNTc0Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568915742", "bodyText": "Please use aliveBrokers() rather than brokers() + broker.isAlive()\nIf this function is called, we know that the originalBroker does not have  excessive leaders of topic -- i.e. brokerHasExcessiveLeadersOfTopic returns false. Thus, broker.id() != originalBroker.id() is redundant.\n\nCan we use something like --\n    clusterModel.aliveBrokers()\n                .stream()\n                .filter(broker -> brokerHasExcessiveLeadersOfTopic(topicName, broker))\n                .forEach(brokersWithExcessiveLeaderToMove::add);", "author": "efeg", "createdAt": "2021-02-02T20:41:18Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private final String _replicaSortName = replicaSortName(this, true, false);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderCountOnSourceBroker = replicaToBeRemoved.broker().numLeadersFor(topicName);\n+    return topicLeaderCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(_replicaSortName, clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderToDistribute(ClusterModel clusterModel,\n+                                                OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          minTopicLeadersPerBroker(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+    Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+\n+    if (replicaToBeMoved.broker().replica(action.topicPartition()).isCurrentOffline()) {\n+      return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+    }\n+    // Moving leader replica from more abundant broker is considered as self-satisfied\n+    return sourceBroker.numLeadersFor(replicaToBeMoved.topicPartition().topic()) > minTopicLeadersPerBroker();\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderOfTopics(clusterModel, optimizationOptions);\n+    finish();\n+  }\n+\n+  private void ensureBrokersAllHaveEnoughLeaderOfTopics(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    for (Broker broker : clusterModel.aliveBrokers()) {\n+      if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+        continue;\n+      }\n+      for (String mustHaveLeaderPerBrokerTopicName : _mustHaveTopicLeadersPerBroker) {\n+        int leaderCount = broker.numLeadersFor(mustHaveLeaderPerBrokerTopicName);\n+        if (leaderCount < minTopicLeadersPerBroker()) {\n+          throw new OptimizationFailureException(String.format(\"Broker %d does not have enough leader replica for topic %s. \"\n+              + \"Minimum required per-broker leader replica count %d. Actual broker leader replica count %d\",\n+              broker.id(), mustHaveLeaderPerBrokerTopicName, minTopicLeadersPerBroker(), leaderCount));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of the current goal and optimized goals.\n+   * @param broker         Broker to be balanced.\n+   * @param clusterModel   The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    LOG.debug(\"balancing broker {}, optimized goals = {}\", broker, optimizedGoals);\n+    moveAwayOfflineReplicas(broker, clusterModel, optimizedGoals, optimizationOptions);\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+      return;\n+    }\n+    for (String topicMustHaveLeaderPerBroker : _mustHaveTopicLeadersPerBroker) {\n+      maybeMoveLeaderOfTopicToBroker(topicMustHaveLeaderPerBroker, broker, clusterModel, optimizedGoals, optimizationOptions);\n+    }\n+  }\n+\n+  private void maybeMoveLeaderOfTopicToBroker(String topicMustHaveLeaderPerBroker,\n+                                              Broker broker,\n+                                              ClusterModel clusterModel,\n+                                              Set<Goal> optimizedGoals,\n+                                              OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (brokerHasSufficientLeadersOfTopic(broker, topicMustHaveLeaderPerBroker)) {\n+      return; // This broker has enough leader replica(s)\n+    }\n+    // Try to elect follower replica(s) of the interested topic on this broker to be leader\n+    Set<Replica> followerReplicas = broker.trackedSortedReplicas(_replicaSortName)\n+                                          .sortedReplicas(false).stream().filter(\n+                                              replica -> !replica.isLeader()\n+                                                         && replica.topicPartition().topic().equals(topicMustHaveLeaderPerBroker))\n+                                          .collect(Collectors.toSet());\n+\n+    for (Replica followerReplica : followerReplicas) {\n+      Replica leader = leaderOfTopicPartition(clusterModel, followerReplica.topicPartition());\n+      if (leader == null) {\n+        LOG.warn(\"No leader replica for {}\", followerReplica.topicPartition());\n+      } else {\n+        if (leader.broker().id() != broker.id()\n+            && leader.broker().numLeadersFor(topicMustHaveLeaderPerBroker) > minTopicLeadersPerBroker()) {\n+          maybeApplyBalancingAction(clusterModel, leader, Collections.singleton(broker),\n+                                    LEADERSHIP_MOVEMENT, optimizedGoals, optimizationOptions);\n+        }\n+      }\n+      if (brokerHasSufficientLeadersOfTopic(broker, topicMustHaveLeaderPerBroker)) {\n+        broker.untrackSortedReplicas(_replicaSortName);\n+        return; // This broker satisfies this goal\n+      }\n+    }\n+\n+    // Try to move leader replica(s) of the interested topic from other brokers to this broker\n+    PriorityQueue<Broker> brokersWithExcessiveLeaderToMove =\n+        getBrokersWithExcessiveLeaderToMove(topicMustHaveLeaderPerBroker, clusterModel, broker);\n+\n+    while (!brokersWithExcessiveLeaderToMove.isEmpty()) {\n+      Broker brokerWithExcessiveLeaderToMove = brokersWithExcessiveLeaderToMove.poll();\n+      List<Replica> leadersOfTopic = brokerWithExcessiveLeaderToMove.trackedSortedReplicas(_replicaSortName)\n+                                                                                  .sortedReplicas(false).stream()\n+                                                                                  .filter(replica ->\n+                                                                                              replica.isLeader()\n+                                                                                              && replica.topicPartition()\n+                                                                                                        .topic()\n+                                                                                                        .equals(topicMustHaveLeaderPerBroker))\n+                                                                                  .collect(Collectors.toList());\n+      boolean leaderMoved = false;\n+      for (Replica leaderOfTopic : leadersOfTopic) {\n+        Broker destinationBroker = maybeApplyBalancingAction(clusterModel, leaderOfTopic, Collections.singleton(broker),\n+                                                             INTER_BROKER_REPLICA_MOVEMENT, optimizedGoals, optimizationOptions);\n+        if (destinationBroker != null) {\n+          leaderMoved = true;\n+          break; // Successfully move one leader replica\n+        }\n+      }\n+      if (leaderMoved) {\n+        if (brokerHasSufficientLeadersOfTopic(broker, topicMustHaveLeaderPerBroker)) {\n+          broker.untrackSortedReplicas(_replicaSortName);\n+          return; // This broker satisfies this goal\n+        }\n+        if (brokerHasExcessiveLeadersOfTopic(topicMustHaveLeaderPerBroker, brokerWithExcessiveLeaderToMove)) {\n+          brokersWithExcessiveLeaderToMove.add(brokerWithExcessiveLeaderToMove);\n+        }\n+      }\n+    }\n+\n+    if (!brokerHasSufficientLeadersOfTopic(broker, topicMustHaveLeaderPerBroker)) {\n+      throw new OptimizationFailureException(String.format(\"Cannot make broker %d have at least %d leader replica(s) of topic %s\",\n+                                                           broker.id(),\n+                                                           minTopicLeadersPerBroker(),\n+                                                           topicMustHaveLeaderPerBroker));\n+    }\n+  }\n+\n+  private boolean brokerHasSufficientLeadersOfTopic(Broker broker, String topicName) {\n+    return broker.numLeadersFor(topicName) >= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This method creates a priority queue which has the broker with the most number of leader replicas of a given topic at the top of queue\n+   * @param topicName name of the given topic\n+   * @param clusterModel cluster model\n+   * @param originalBroker original broker which needs to be excluded from the priority queue\n+   * @return a priority queue which has the broker with the most number of leader replicas of a given topic at the top of queue\n+   */\n+  private PriorityQueue<Broker> getBrokersWithExcessiveLeaderToMove(String topicName, ClusterModel clusterModel, Broker originalBroker) {\n+    PriorityQueue<Broker> brokersWithExcessiveLeaderToMove = new PriorityQueue<>((broker1, broker2) -> {\n+      int broker1LeaderCount = broker1.numLeadersFor(topicName);\n+      int broker2LeaderCount = broker2.numLeadersFor(topicName);\n+      int leaderCountCompareResult = Integer.compare(broker2LeaderCount, broker1LeaderCount);\n+      return leaderCountCompareResult == 0 ? Integer.compare(broker1.id(), broker2.id()) : leaderCountCompareResult;\n+    });\n+    clusterModel.brokers().forEach((broker -> {\n+      if (broker.isAlive() && broker.id() != originalBroker.id() && brokerHasExcessiveLeadersOfTopic(topicName, broker)) {\n+        brokersWithExcessiveLeaderToMove.add(broker);\n+      }\n+    }));", "originalCommit": "f3351c308cc3b4aecbc73ec16807124d327addab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODkxODg1MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568918851", "bodyText": "See the earlier comment on untracking early. Please add unit tests to cover this miss.", "author": "efeg", "createdAt": "2021-02-02T20:47:07Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private final String _replicaSortName = replicaSortName(this, true, false);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderCountOnSourceBroker = replicaToBeRemoved.broker().numLeadersFor(topicName);\n+    return topicLeaderCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(_replicaSortName, clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderToDistribute(ClusterModel clusterModel,\n+                                                OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          minTopicLeadersPerBroker(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+    Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+\n+    if (replicaToBeMoved.broker().replica(action.topicPartition()).isCurrentOffline()) {\n+      return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+    }\n+    // Moving leader replica from more abundant broker is considered as self-satisfied\n+    return sourceBroker.numLeadersFor(replicaToBeMoved.topicPartition().topic()) > minTopicLeadersPerBroker();\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderOfTopics(clusterModel, optimizationOptions);\n+    finish();\n+  }\n+\n+  private void ensureBrokersAllHaveEnoughLeaderOfTopics(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    for (Broker broker : clusterModel.aliveBrokers()) {\n+      if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+        continue;\n+      }\n+      for (String mustHaveLeaderPerBrokerTopicName : _mustHaveTopicLeadersPerBroker) {\n+        int leaderCount = broker.numLeadersFor(mustHaveLeaderPerBrokerTopicName);\n+        if (leaderCount < minTopicLeadersPerBroker()) {\n+          throw new OptimizationFailureException(String.format(\"Broker %d does not have enough leader replica for topic %s. \"\n+              + \"Minimum required per-broker leader replica count %d. Actual broker leader replica count %d\",\n+              broker.id(), mustHaveLeaderPerBrokerTopicName, minTopicLeadersPerBroker(), leaderCount));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of the current goal and optimized goals.\n+   * @param broker         Broker to be balanced.\n+   * @param clusterModel   The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    LOG.debug(\"balancing broker {}, optimized goals = {}\", broker, optimizedGoals);\n+    moveAwayOfflineReplicas(broker, clusterModel, optimizedGoals, optimizationOptions);\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+      return;\n+    }\n+    for (String topicMustHaveLeaderPerBroker : _mustHaveTopicLeadersPerBroker) {\n+      maybeMoveLeaderOfTopicToBroker(topicMustHaveLeaderPerBroker, broker, clusterModel, optimizedGoals, optimizationOptions);\n+    }\n+  }\n+\n+  private void maybeMoveLeaderOfTopicToBroker(String topicMustHaveLeaderPerBroker,\n+                                              Broker broker,\n+                                              ClusterModel clusterModel,\n+                                              Set<Goal> optimizedGoals,\n+                                              OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (brokerHasSufficientLeadersOfTopic(broker, topicMustHaveLeaderPerBroker)) {\n+      return; // This broker has enough leader replica(s)\n+    }\n+    // Try to elect follower replica(s) of the interested topic on this broker to be leader\n+    Set<Replica> followerReplicas = broker.trackedSortedReplicas(_replicaSortName)\n+                                          .sortedReplicas(false).stream().filter(\n+                                              replica -> !replica.isLeader()\n+                                                         && replica.topicPartition().topic().equals(topicMustHaveLeaderPerBroker))\n+                                          .collect(Collectors.toSet());\n+\n+    for (Replica followerReplica : followerReplicas) {\n+      Replica leader = leaderOfTopicPartition(clusterModel, followerReplica.topicPartition());\n+      if (leader == null) {\n+        LOG.warn(\"No leader replica for {}\", followerReplica.topicPartition());\n+      } else {\n+        if (leader.broker().id() != broker.id()\n+            && leader.broker().numLeadersFor(topicMustHaveLeaderPerBroker) > minTopicLeadersPerBroker()) {\n+          maybeApplyBalancingAction(clusterModel, leader, Collections.singleton(broker),\n+                                    LEADERSHIP_MOVEMENT, optimizedGoals, optimizationOptions);\n+        }\n+      }\n+      if (brokerHasSufficientLeadersOfTopic(broker, topicMustHaveLeaderPerBroker)) {\n+        broker.untrackSortedReplicas(_replicaSortName);\n+        return; // This broker satisfies this goal\n+      }\n+    }\n+\n+    // Try to move leader replica(s) of the interested topic from other brokers to this broker\n+    PriorityQueue<Broker> brokersWithExcessiveLeaderToMove =\n+        getBrokersWithExcessiveLeaderToMove(topicMustHaveLeaderPerBroker, clusterModel, broker);\n+\n+    while (!brokersWithExcessiveLeaderToMove.isEmpty()) {\n+      Broker brokerWithExcessiveLeaderToMove = brokersWithExcessiveLeaderToMove.poll();\n+      List<Replica> leadersOfTopic = brokerWithExcessiveLeaderToMove.trackedSortedReplicas(_replicaSortName)\n+                                                                                  .sortedReplicas(false).stream()\n+                                                                                  .filter(replica ->\n+                                                                                              replica.isLeader()\n+                                                                                              && replica.topicPartition()\n+                                                                                                        .topic()\n+                                                                                                        .equals(topicMustHaveLeaderPerBroker))\n+                                                                                  .collect(Collectors.toList());\n+      boolean leaderMoved = false;\n+      for (Replica leaderOfTopic : leadersOfTopic) {\n+        Broker destinationBroker = maybeApplyBalancingAction(clusterModel, leaderOfTopic, Collections.singleton(broker),\n+                                                             INTER_BROKER_REPLICA_MOVEMENT, optimizedGoals, optimizationOptions);\n+        if (destinationBroker != null) {\n+          leaderMoved = true;\n+          break; // Successfully move one leader replica\n+        }\n+      }\n+      if (leaderMoved) {\n+        if (brokerHasSufficientLeadersOfTopic(broker, topicMustHaveLeaderPerBroker)) {\n+          broker.untrackSortedReplicas(_replicaSortName);\n+          return; // This broker satisfies this goal", "originalCommit": "f3351c308cc3b4aecbc73ec16807124d327addab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODkxOTk0MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568919941", "bodyText": "Each call to brokerHasExcessiveLeadersOfTopic is performed within a loop here.\nWe can avoid this via caching the response in a variable.\nSee similar comment above.", "author": "efeg", "createdAt": "2021-02-02T20:48:55Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private final String _replicaSortName = replicaSortName(this, true, false);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderCountOnSourceBroker = replicaToBeRemoved.broker().numLeadersFor(topicName);\n+    return topicLeaderCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(_replicaSortName, clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderToDistribute(ClusterModel clusterModel,\n+                                                OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          minTopicLeadersPerBroker(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+    Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+\n+    if (replicaToBeMoved.broker().replica(action.topicPartition()).isCurrentOffline()) {\n+      return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+    }\n+    // Moving leader replica from more abundant broker is considered as self-satisfied\n+    return sourceBroker.numLeadersFor(replicaToBeMoved.topicPartition().topic()) > minTopicLeadersPerBroker();\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderOfTopics(clusterModel, optimizationOptions);\n+    finish();\n+  }\n+\n+  private void ensureBrokersAllHaveEnoughLeaderOfTopics(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    for (Broker broker : clusterModel.aliveBrokers()) {\n+      if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+        continue;\n+      }\n+      for (String mustHaveLeaderPerBrokerTopicName : _mustHaveTopicLeadersPerBroker) {\n+        int leaderCount = broker.numLeadersFor(mustHaveLeaderPerBrokerTopicName);\n+        if (leaderCount < minTopicLeadersPerBroker()) {\n+          throw new OptimizationFailureException(String.format(\"Broker %d does not have enough leader replica for topic %s. \"\n+              + \"Minimum required per-broker leader replica count %d. Actual broker leader replica count %d\",\n+              broker.id(), mustHaveLeaderPerBrokerTopicName, minTopicLeadersPerBroker(), leaderCount));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of the current goal and optimized goals.\n+   * @param broker         Broker to be balanced.\n+   * @param clusterModel   The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    LOG.debug(\"balancing broker {}, optimized goals = {}\", broker, optimizedGoals);\n+    moveAwayOfflineReplicas(broker, clusterModel, optimizedGoals, optimizationOptions);\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+      return;\n+    }\n+    for (String topicMustHaveLeaderPerBroker : _mustHaveTopicLeadersPerBroker) {\n+      maybeMoveLeaderOfTopicToBroker(topicMustHaveLeaderPerBroker, broker, clusterModel, optimizedGoals, optimizationOptions);\n+    }\n+  }\n+\n+  private void maybeMoveLeaderOfTopicToBroker(String topicMustHaveLeaderPerBroker,\n+                                              Broker broker,\n+                                              ClusterModel clusterModel,\n+                                              Set<Goal> optimizedGoals,\n+                                              OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (brokerHasSufficientLeadersOfTopic(broker, topicMustHaveLeaderPerBroker)) {\n+      return; // This broker has enough leader replica(s)\n+    }\n+    // Try to elect follower replica(s) of the interested topic on this broker to be leader\n+    Set<Replica> followerReplicas = broker.trackedSortedReplicas(_replicaSortName)\n+                                          .sortedReplicas(false).stream().filter(\n+                                              replica -> !replica.isLeader()\n+                                                         && replica.topicPartition().topic().equals(topicMustHaveLeaderPerBroker))\n+                                          .collect(Collectors.toSet());\n+\n+    for (Replica followerReplica : followerReplicas) {\n+      Replica leader = leaderOfTopicPartition(clusterModel, followerReplica.topicPartition());\n+      if (leader == null) {\n+        LOG.warn(\"No leader replica for {}\", followerReplica.topicPartition());\n+      } else {\n+        if (leader.broker().id() != broker.id()\n+            && leader.broker().numLeadersFor(topicMustHaveLeaderPerBroker) > minTopicLeadersPerBroker()) {\n+          maybeApplyBalancingAction(clusterModel, leader, Collections.singleton(broker),\n+                                    LEADERSHIP_MOVEMENT, optimizedGoals, optimizationOptions);\n+        }\n+      }\n+      if (brokerHasSufficientLeadersOfTopic(broker, topicMustHaveLeaderPerBroker)) {\n+        broker.untrackSortedReplicas(_replicaSortName);\n+        return; // This broker satisfies this goal\n+      }\n+    }\n+\n+    // Try to move leader replica(s) of the interested topic from other brokers to this broker\n+    PriorityQueue<Broker> brokersWithExcessiveLeaderToMove =\n+        getBrokersWithExcessiveLeaderToMove(topicMustHaveLeaderPerBroker, clusterModel, broker);\n+\n+    while (!brokersWithExcessiveLeaderToMove.isEmpty()) {\n+      Broker brokerWithExcessiveLeaderToMove = brokersWithExcessiveLeaderToMove.poll();\n+      List<Replica> leadersOfTopic = brokerWithExcessiveLeaderToMove.trackedSortedReplicas(_replicaSortName)\n+                                                                                  .sortedReplicas(false).stream()\n+                                                                                  .filter(replica ->\n+                                                                                              replica.isLeader()\n+                                                                                              && replica.topicPartition()\n+                                                                                                        .topic()\n+                                                                                                        .equals(topicMustHaveLeaderPerBroker))\n+                                                                                  .collect(Collectors.toList());\n+      boolean leaderMoved = false;\n+      for (Replica leaderOfTopic : leadersOfTopic) {\n+        Broker destinationBroker = maybeApplyBalancingAction(clusterModel, leaderOfTopic, Collections.singleton(broker),\n+                                                             INTER_BROKER_REPLICA_MOVEMENT, optimizedGoals, optimizationOptions);\n+        if (destinationBroker != null) {\n+          leaderMoved = true;\n+          break; // Successfully move one leader replica\n+        }\n+      }\n+      if (leaderMoved) {\n+        if (brokerHasSufficientLeadersOfTopic(broker, topicMustHaveLeaderPerBroker)) {\n+          broker.untrackSortedReplicas(_replicaSortName);\n+          return; // This broker satisfies this goal\n+        }\n+        if (brokerHasExcessiveLeadersOfTopic(topicMustHaveLeaderPerBroker, brokerWithExcessiveLeaderToMove)) {", "originalCommit": "f3351c308cc3b4aecbc73ec16807124d327addab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODk3OTg1NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568979855", "bodyText": "Fixed", "author": "Lincong", "createdAt": "2021-02-02T22:37:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODkxOTk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODkyMTc4OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568921789", "bodyText": "Do we even need this check? Isn't it guaranteed to be true if we reach here based on the current codepath?\nIf that is the case, can we drop this redundant check?", "author": "efeg", "createdAt": "2021-02-02T20:51:57Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.apache.kafka.common.TopicPartition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private final String _replicaSortName = replicaSortName(this, true, false);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderCountOnSourceBroker = replicaToBeRemoved.broker().numLeadersFor(topicName);\n+    return topicLeaderCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(_replicaSortName, clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderToDistribute(ClusterModel clusterModel,\n+                                                OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          minTopicLeadersPerBroker(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+    Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+\n+    if (replicaToBeMoved.broker().replica(action.topicPartition()).isCurrentOffline()) {\n+      return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+    }\n+    // Moving leader replica from more abundant broker is considered as self-satisfied\n+    return sourceBroker.numLeadersFor(replicaToBeMoved.topicPartition().topic()) > minTopicLeadersPerBroker();\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderOfTopics(clusterModel, optimizationOptions);\n+    finish();\n+  }\n+\n+  private void ensureBrokersAllHaveEnoughLeaderOfTopics(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    for (Broker broker : clusterModel.aliveBrokers()) {\n+      if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+        continue;\n+      }\n+      for (String mustHaveLeaderPerBrokerTopicName : _mustHaveTopicLeadersPerBroker) {\n+        int leaderCount = broker.numLeadersFor(mustHaveLeaderPerBrokerTopicName);\n+        if (leaderCount < minTopicLeadersPerBroker()) {\n+          throw new OptimizationFailureException(String.format(\"Broker %d does not have enough leader replica for topic %s. \"\n+              + \"Minimum required per-broker leader replica count %d. Actual broker leader replica count %d\",\n+              broker.id(), mustHaveLeaderPerBrokerTopicName, minTopicLeadersPerBroker(), leaderCount));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of the current goal and optimized goals.\n+   * @param broker         Broker to be balanced.\n+   * @param clusterModel   The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    LOG.debug(\"balancing broker {}, optimized goals = {}\", broker, optimizedGoals);\n+    moveAwayOfflineReplicas(broker, clusterModel, optimizedGoals, optimizationOptions);\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+      return;\n+    }\n+    for (String topicMustHaveLeaderPerBroker : _mustHaveTopicLeadersPerBroker) {\n+      maybeMoveLeaderOfTopicToBroker(topicMustHaveLeaderPerBroker, broker, clusterModel, optimizedGoals, optimizationOptions);\n+    }\n+  }\n+\n+  private void maybeMoveLeaderOfTopicToBroker(String topicMustHaveLeaderPerBroker,\n+                                              Broker broker,\n+                                              ClusterModel clusterModel,\n+                                              Set<Goal> optimizedGoals,\n+                                              OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    if (brokerHasSufficientLeadersOfTopic(broker, topicMustHaveLeaderPerBroker)) {\n+      return; // This broker has enough leader replica(s)\n+    }\n+    // Try to elect follower replica(s) of the interested topic on this broker to be leader\n+    Set<Replica> followerReplicas = broker.trackedSortedReplicas(_replicaSortName)\n+                                          .sortedReplicas(false).stream().filter(\n+                                              replica -> !replica.isLeader()\n+                                                         && replica.topicPartition().topic().equals(topicMustHaveLeaderPerBroker))\n+                                          .collect(Collectors.toSet());\n+\n+    for (Replica followerReplica : followerReplicas) {\n+      Replica leader = leaderOfTopicPartition(clusterModel, followerReplica.topicPartition());\n+      if (leader == null) {\n+        LOG.warn(\"No leader replica for {}\", followerReplica.topicPartition());\n+      } else {\n+        if (leader.broker().id() != broker.id()\n+            && leader.broker().numLeadersFor(topicMustHaveLeaderPerBroker) > minTopicLeadersPerBroker()) {\n+          maybeApplyBalancingAction(clusterModel, leader, Collections.singleton(broker),\n+                                    LEADERSHIP_MOVEMENT, optimizedGoals, optimizationOptions);\n+        }\n+      }\n+      if (brokerHasSufficientLeadersOfTopic(broker, topicMustHaveLeaderPerBroker)) {\n+        broker.untrackSortedReplicas(_replicaSortName);\n+        return; // This broker satisfies this goal\n+      }\n+    }\n+\n+    // Try to move leader replica(s) of the interested topic from other brokers to this broker\n+    PriorityQueue<Broker> brokersWithExcessiveLeaderToMove =\n+        getBrokersWithExcessiveLeaderToMove(topicMustHaveLeaderPerBroker, clusterModel, broker);\n+\n+    while (!brokersWithExcessiveLeaderToMove.isEmpty()) {\n+      Broker brokerWithExcessiveLeaderToMove = brokersWithExcessiveLeaderToMove.poll();\n+      List<Replica> leadersOfTopic = brokerWithExcessiveLeaderToMove.trackedSortedReplicas(_replicaSortName)\n+                                                                                  .sortedReplicas(false).stream()\n+                                                                                  .filter(replica ->\n+                                                                                              replica.isLeader()\n+                                                                                              && replica.topicPartition()\n+                                                                                                        .topic()\n+                                                                                                        .equals(topicMustHaveLeaderPerBroker))\n+                                                                                  .collect(Collectors.toList());\n+      boolean leaderMoved = false;\n+      for (Replica leaderOfTopic : leadersOfTopic) {\n+        Broker destinationBroker = maybeApplyBalancingAction(clusterModel, leaderOfTopic, Collections.singleton(broker),\n+                                                             INTER_BROKER_REPLICA_MOVEMENT, optimizedGoals, optimizationOptions);\n+        if (destinationBroker != null) {\n+          leaderMoved = true;\n+          break; // Successfully move one leader replica\n+        }\n+      }\n+      if (leaderMoved) {\n+        if (brokerHasSufficientLeadersOfTopic(broker, topicMustHaveLeaderPerBroker)) {\n+          broker.untrackSortedReplicas(_replicaSortName);\n+          return; // This broker satisfies this goal\n+        }\n+        if (brokerHasExcessiveLeadersOfTopic(topicMustHaveLeaderPerBroker, brokerWithExcessiveLeaderToMove)) {\n+          brokersWithExcessiveLeaderToMove.add(brokerWithExcessiveLeaderToMove);\n+        }\n+      }\n+    }\n+\n+    if (!brokerHasSufficientLeadersOfTopic(broker, topicMustHaveLeaderPerBroker)) {", "originalCommit": "f3351c308cc3b4aecbc73ec16807124d327addab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODk4MjA3NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568982075", "bodyText": "Yes, we can drop this redundant check", "author": "Lincong", "createdAt": "2021-02-02T22:42:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODkyMTc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODkyMjYxMg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568922612", "bodyText": "Nit: Can we shift .get() to the same line as return topicNamesSupplier?", "author": "efeg", "createdAt": "2021-02-02T20:53:27Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/common/Utils.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.common;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+\n+public class Utils {\n+\n+  private Utils() {\n+\n+  }\n+\n+  /**\n+   * Get topic names that match with a given topic naming pattern\n+   * @param topicNamePattern target topic naming pattern\n+   * @param topicNamesSupplier a supplier that provides topic names\n+   * @return topic names\n+   */\n+  public static Set<String> getTopicNamesMatchedWithPattern(Pattern topicNamePattern, Supplier<Set<String>> topicNamesSupplier) {\n+    if (topicNamePattern.pattern().isEmpty()) {\n+      return Collections.emptySet();\n+    }\n+    return topicNamesSupplier\n+        .get()\n+        .stream()\n+        .filter(topicName -> topicNamePattern.matcher(topicName).matches())\n+        .collect(Collectors.toSet());", "originalCommit": "f3351c308cc3b4aecbc73ec16807124d327addab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODkyMzQyNw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568923427", "bodyText": "Nit: -> .. a minimum ...", "author": "efeg", "createdAt": "2021-02-02T20:54:52Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnalyzerConfig.java", "diffHunk": "@@ -334,6 +338,22 @@ private AnalyzerConfig() {\n   public static final String ALLOW_CAPACITY_ESTIMATION_ON_PROPOSAL_PRECOMPUTE_DOC = \"The flag to indicate whether to \"\n       + \"allow capacity estimation on proposal precomputation.\";\n \n+  /**\n+   * <code>topics.with.min.leaders.per.broker</code>\n+   */\n+  public static final String TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG = \"topics.with.min.leaders.per.broker\";\n+  public static final String DEFAULT_TOPICS_WITH_MIN_LEADERS_PER_BROKER = \"\";\n+  public static final String DEFAULT_TOPICS_WITH_MIN_LEADERS_PER_BROKER_DOC = \"The topics that should have minimum \"", "originalCommit": "f3351c308cc3b4aecbc73ec16807124d327addab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODkyMzg3Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568923876", "bodyText": "leader replicas per or leaders per", "author": "efeg", "createdAt": "2021-02-02T20:55:35Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnalyzerConfig.java", "diffHunk": "@@ -334,6 +338,22 @@ private AnalyzerConfig() {\n   public static final String ALLOW_CAPACITY_ESTIMATION_ON_PROPOSAL_PRECOMPUTE_DOC = \"The flag to indicate whether to \"\n       + \"allow capacity estimation on proposal precomputation.\";\n \n+  /**\n+   * <code>topics.with.min.leaders.per.broker</code>\n+   */\n+  public static final String TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG = \"topics.with.min.leaders.per.broker\";\n+  public static final String DEFAULT_TOPICS_WITH_MIN_LEADERS_PER_BROKER = \"\";\n+  public static final String DEFAULT_TOPICS_WITH_MIN_LEADERS_PER_BROKER_DOC = \"The topics that should have minimum \"\n+      + \"number of replica on brokers that are not excluded for replica move. It is a regex.\";\n+\n+  /**\n+   * <code>min.topic.leaders.per.broker</code>\n+   */\n+  public static final String MIN_TOPIC_LEADERS_PER_BROKER_CONFIG = \"min.topic.leaders.per.broker\";\n+  public static final int DEFAULT_MIN_TOPIC_LEADERS_PER_BROKER = 1;\n+  public static final String MIN_TOPIC_LEADERS_PER_BROKER_DOC = \"The minimum required number of leader replica per broker\"", "originalCommit": "f3351c308cc3b4aecbc73ec16807124d327addab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODkyNDA2NA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568924064", "bodyText": "leader replicas per or leaders per", "author": "efeg", "createdAt": "2021-02-02T20:55:53Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnalyzerConfig.java", "diffHunk": "@@ -334,6 +338,22 @@ private AnalyzerConfig() {\n   public static final String ALLOW_CAPACITY_ESTIMATION_ON_PROPOSAL_PRECOMPUTE_DOC = \"The flag to indicate whether to \"\n       + \"allow capacity estimation on proposal precomputation.\";\n \n+  /**\n+   * <code>topics.with.min.leaders.per.broker</code>\n+   */\n+  public static final String TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG = \"topics.with.min.leaders.per.broker\";\n+  public static final String DEFAULT_TOPICS_WITH_MIN_LEADERS_PER_BROKER = \"\";\n+  public static final String DEFAULT_TOPICS_WITH_MIN_LEADERS_PER_BROKER_DOC = \"The topics that should have minimum \"\n+      + \"number of replica on brokers that are not excluded for replica move. It is a regex.\";\n+\n+  /**\n+   * <code>min.topic.leaders.per.broker</code>\n+   */\n+  public static final String MIN_TOPIC_LEADERS_PER_BROKER_CONFIG = \"min.topic.leaders.per.broker\";\n+  public static final int DEFAULT_MIN_TOPIC_LEADERS_PER_BROKER = 1;\n+  public static final String MIN_TOPIC_LEADERS_PER_BROKER_DOC = \"The minimum required number of leader replica per broker\"\n+      + \" for topics that must have leader replica on brokers that are not excluded for replica move.\";", "originalCommit": "f3351c308cc3b4aecbc73ec16807124d327addab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7bf74b6cb2e91a0521a89fc7e3891406a0bccba6", "url": "https://github.com/linkedin/cruise-control/commit/7bf74b6cb2e91a0521a89fc7e3891406a0bccba6", "message": "Improve efficiency", "committedDate": "2021-02-02T22:17:20Z", "type": "commit"}, {"oid": "69fdf3f8305c810269d778a333b2d0b7ca39c302", "url": "https://github.com/linkedin/cruise-control/commit/69fdf3f8305c810269d778a333b2d0b7ca39c302", "message": "Clean up unused code", "committedDate": "2021-02-02T22:31:00Z", "type": "commit"}, {"oid": "b5e4dfa31d15e70a8c21429921cb48bda94826ce", "url": "https://github.com/linkedin/cruise-control/commit/b5e4dfa31d15e70a8c21429921cb48bda94826ce", "message": "Remove redundant check", "committedDate": "2021-02-02T22:40:51Z", "type": "commit"}, {"oid": "f4ff4847acaa42c21bfcda816aab897e0a502324", "url": "https://github.com/linkedin/cruise-control/commit/f4ff4847acaa42c21bfcda816aab897e0a502324", "message": "Add unit test for the case where 2 topics are handled by the new hard goal", "committedDate": "2021-02-02T23:23:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODk4OTkwNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568989905", "bodyText": "Nit: Can we use proper indentation using the project checkstyle file?\nCan you please do a global check to ensure that there are no other indentation issues?", "author": "efeg", "createdAt": "2021-02-02T22:58:47Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/common/Utils.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.common;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+\n+public class Utils {\n+\n+  private Utils() {\n+\n+  }\n+\n+  /**\n+   * Get topic names that match with a given topic naming pattern\n+   * @param topicNamePattern target topic naming pattern\n+   * @param topicNamesSupplier a supplier that provides topic names\n+   * @return topic names\n+   */\n+  public static Set<String> getTopicNamesMatchedWithPattern(Pattern topicNamePattern, Supplier<Set<String>> topicNamesSupplier) {\n+    if (topicNamePattern.pattern().isEmpty()) {\n+      return Collections.emptySet();\n+    }\n+    return topicNamesSupplier.get()\n+        .stream()\n+        .filter(topicName -> topicNamePattern.matcher(topicName).matches())\n+        .collect(Collectors.toSet());", "originalCommit": "b5e4dfa31d15e70a8c21429921cb48bda94826ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODk5MzAyNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568993025", "bodyText": "Nit: Can we make this static", "author": "efeg", "createdAt": "2021-02-02T23:06:05Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private final String _replicaSortName = replicaSortName(this, true, false);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderCountOnSourceBroker = replicaToBeRemoved.broker().numLeadersFor(topicName);\n+    return topicLeaderCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(_replicaSortName, clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderToDistribute(ClusterModel clusterModel,\n+                                                OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          minTopicLeadersPerBroker(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,", "originalCommit": "b5e4dfa31d15e70a8c21429921cb48bda94826ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODk5NjUxNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568996515", "bodyText": "This sanity check seems redundant. All the callers of doesLeaderRemoveViolateOptimizedGoal already verify that the topicName is in _mustHaveTopicLeadersPerBroker.\nAm I missing something?", "author": "efeg", "createdAt": "2021-02-02T23:14:31Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private final String _replicaSortName = replicaSortName(this, true, false);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }", "originalCommit": "b5e4dfa31d15e70a8c21429921cb48bda94826ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAwNDQwMg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569004402", "bodyText": "Yes, it is redundant in this case", "author": "Lincong", "createdAt": "2021-02-02T23:33:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODk5NjUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODk5OTQ2MA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r568999460", "bodyText": "return clusterModel.brokers() -> return clusterModel.aliveBrokers()", "author": "efeg", "createdAt": "2021-02-02T23:21:04Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private final String _replicaSortName = replicaSortName(this, true, false);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderCountOnSourceBroker = replicaToBeRemoved.broker().numLeadersFor(topicName);\n+    return topicLeaderCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(_replicaSortName, clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderToDistribute(ClusterModel clusterModel,\n+                                                OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          minTopicLeadersPerBroker(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+    Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+\n+    if (replicaToBeMoved.broker().replica(action.topicPartition()).isCurrentOffline()) {\n+      return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+    }\n+    // Moving leader replica from more abundant broker is considered as self-satisfied\n+    return sourceBroker.numLeadersFor(replicaToBeMoved.topicPartition().topic()) > minTopicLeadersPerBroker();\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderOfTopics(clusterModel, optimizationOptions);\n+    finish();\n+  }\n+\n+  private void ensureBrokersAllHaveEnoughLeaderOfTopics(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    for (Broker broker : clusterModel.aliveBrokers()) {\n+      if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+        continue;\n+      }\n+      for (String mustHaveLeaderPerBrokerTopicName : _mustHaveTopicLeadersPerBroker) {\n+        int leaderCount = broker.numLeadersFor(mustHaveLeaderPerBrokerTopicName);\n+        if (leaderCount < minTopicLeadersPerBroker()) {\n+          throw new OptimizationFailureException(String.format(\"Broker %d does not have enough leader replica for topic %s. \"\n+              + \"Minimum required per-broker leader replica count %d. Actual broker leader replica count %d\",\n+              broker.id(), mustHaveLeaderPerBrokerTopicName, minTopicLeadersPerBroker(), leaderCount));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of the current goal and optimized goals.\n+   * @param broker         Broker to be balanced.\n+   * @param clusterModel   The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    LOG.debug(\"balancing broker {}, optimized goals = {}\", broker, optimizedGoals);\n+    moveAwayOfflineReplicas(broker, clusterModel, optimizedGoals, optimizationOptions);\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+      return;\n+    }\n+    for (String topicMustHaveLeaderPerBroker : _mustHaveTopicLeadersPerBroker) {\n+      maybeMoveLeaderOfTopicToBroker(topicMustHaveLeaderPerBroker, broker, clusterModel, optimizedGoals, optimizationOptions);\n+    }\n+  }\n+\n+  private void maybeMoveLeaderOfTopicToBroker(String topicMustHaveLeaderPerBroker,\n+                                              Broker broker,\n+                                              ClusterModel clusterModel,\n+                                              Set<Goal> optimizedGoals,\n+                                              OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    int topicLeaderCountOnReceiverBroker = broker.numLeadersFor(topicMustHaveLeaderPerBroker);\n+    if (topicLeaderCountOnReceiverBroker >= minTopicLeadersPerBroker()) {\n+      return; // This broker has enough leader replica(s) for the given topic\n+    }\n+    // Try to elect follower replica(s) of the interested topic on this broker to be leader\n+    Set<Replica> followerReplicas = broker.trackedSortedReplicas(_replicaSortName)\n+                                          .sortedReplicas(false).stream().filter(\n+                                              replica -> !replica.isLeader()\n+                                                         && replica.topicPartition().topic().equals(topicMustHaveLeaderPerBroker))\n+                                          .collect(Collectors.toSet());\n+\n+    for (Replica followerReplica : followerReplicas) {\n+      Replica leader = clusterModel.partition(followerReplica.topicPartition()).leader();\n+      if (leader.broker().numLeadersFor(topicMustHaveLeaderPerBroker) > minTopicLeadersPerBroker()) {\n+        if (maybeApplyBalancingAction(clusterModel, leader, Collections.singleton(broker),\n+                                      LEADERSHIP_MOVEMENT, optimizedGoals, optimizationOptions) != null) {\n+          topicLeaderCountOnReceiverBroker++;\n+          if (topicLeaderCountOnReceiverBroker >= minTopicLeadersPerBroker()) {\n+            return; // This broker satisfies this goal for the given topic\n+          }\n+        }\n+      }\n+    }\n+\n+    // Try to move leader replica(s) of the interested topic from other brokers to this broker\n+    PriorityQueue<Broker> brokersWithExcessiveLeaderToMove =\n+        getBrokersWithExcessiveLeaderToMove(topicMustHaveLeaderPerBroker, clusterModel, broker);\n+\n+    while (!brokersWithExcessiveLeaderToMove.isEmpty()) {\n+      Broker brokerWithExcessiveLeaderToMove = brokersWithExcessiveLeaderToMove.poll();\n+      List<Replica> leadersOfTopic = brokerWithExcessiveLeaderToMove.trackedSortedReplicas(_replicaSortName)\n+                                                                                  .sortedReplicas(false).stream()\n+                                                                                  .filter(replica ->\n+                                                                                              replica.isLeader()\n+                                                                                              && replica.topicPartition()\n+                                                                                                        .topic()\n+                                                                                                        .equals(topicMustHaveLeaderPerBroker))\n+                                                                                  .collect(Collectors.toList());\n+      boolean leaderMoved = false;\n+      int topicLeaderCountOnGiverBroker = leadersOfTopic.size();\n+      for (Replica leaderOfTopic : leadersOfTopic) {\n+        Broker destinationBroker = maybeApplyBalancingAction(clusterModel, leaderOfTopic, Collections.singleton(broker),\n+                                                             INTER_BROKER_REPLICA_MOVEMENT, optimizedGoals, optimizationOptions);\n+        if (destinationBroker != null) {\n+          leaderMoved = true;\n+          break; // Successfully move one leader replica\n+        }\n+      }\n+      if (leaderMoved) {\n+        topicLeaderCountOnReceiverBroker++;\n+        if (topicLeaderCountOnReceiverBroker >= minTopicLeadersPerBroker()) {\n+          return; // This broker satisfies this goal for the given topic\n+        }\n+        topicLeaderCountOnGiverBroker--;\n+        if (topicLeaderCountOnGiverBroker > minTopicLeadersPerBroker()) {\n+          // Still have excessive topic leader to give\n+          brokersWithExcessiveLeaderToMove.add(brokerWithExcessiveLeaderToMove);\n+        }\n+      }\n+    }\n+    throw new OptimizationFailureException(String.format(\"Cannot make broker %d have at least %d leader replica(s) of topic %s\",\n+                                                         broker.id(),\n+                                                         minTopicLeadersPerBroker(),\n+                                                         topicMustHaveLeaderPerBroker));\n+  }\n+\n+  /**\n+   * This method creates a priority queue which has the broker with the most number of leader replicas of a given topic at the top of queue\n+   * @param topicName name of the given topic\n+   * @param clusterModel cluster model\n+   * @param originalBroker original broker which needs to be excluded from the priority queue\n+   * @return a priority queue which has the broker with the most number of leader replicas of a given topic at the top of queue\n+   */\n+  private PriorityQueue<Broker> getBrokersWithExcessiveLeaderToMove(String topicName, ClusterModel clusterModel, Broker originalBroker) {\n+    PriorityQueue<Broker> brokersWithExcessiveLeaderToMove = new PriorityQueue<>((broker1, broker2) -> {\n+      int broker1LeaderCount = broker1.numLeadersFor(topicName);\n+      int broker2LeaderCount = broker2.numLeadersFor(topicName);\n+      int leaderCountCompareResult = Integer.compare(broker2LeaderCount, broker1LeaderCount);\n+      return leaderCountCompareResult == 0 ? Integer.compare(broker1.id(), broker2.id()) : leaderCountCompareResult;\n+    });\n+    clusterModel.aliveBrokers()\n+                .stream()\n+                .filter(broker -> broker.numLeadersFor(topicName) > minTopicLeadersPerBroker())\n+                .forEach(brokersWithExcessiveLeaderToMove::add);\n+    return brokersWithExcessiveLeaderToMove;\n+  }\n+\n+  private Set<Broker> eligibleBrokersForLeadership(ClusterModel clusterModel, OptimizationOptions optimizationOptions) {\n+    return clusterModel.brokers()", "originalCommit": "b5e4dfa31d15e70a8c21429921cb48bda94826ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAwMDcwMw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569000703", "bodyText": "Can we drop broker.isAlive() once we apply the other proposed changes in this review?", "author": "efeg", "createdAt": "2021-02-02T23:24:08Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private final String _replicaSortName = replicaSortName(this, true, false);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderCountOnSourceBroker = replicaToBeRemoved.broker().numLeadersFor(topicName);\n+    return topicLeaderCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(_replicaSortName, clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderToDistribute(ClusterModel clusterModel,\n+                                                OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          minTopicLeadersPerBroker(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+    Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+\n+    if (replicaToBeMoved.broker().replica(action.topicPartition()).isCurrentOffline()) {\n+      return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+    }\n+    // Moving leader replica from more abundant broker is considered as self-satisfied\n+    return sourceBroker.numLeadersFor(replicaToBeMoved.topicPartition().topic()) > minTopicLeadersPerBroker();\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderOfTopics(clusterModel, optimizationOptions);\n+    finish();\n+  }\n+\n+  private void ensureBrokersAllHaveEnoughLeaderOfTopics(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    for (Broker broker : clusterModel.aliveBrokers()) {\n+      if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+        continue;\n+      }\n+      for (String mustHaveLeaderPerBrokerTopicName : _mustHaveTopicLeadersPerBroker) {\n+        int leaderCount = broker.numLeadersFor(mustHaveLeaderPerBrokerTopicName);\n+        if (leaderCount < minTopicLeadersPerBroker()) {\n+          throw new OptimizationFailureException(String.format(\"Broker %d does not have enough leader replica for topic %s. \"\n+              + \"Minimum required per-broker leader replica count %d. Actual broker leader replica count %d\",\n+              broker.id(), mustHaveLeaderPerBrokerTopicName, minTopicLeadersPerBroker(), leaderCount));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of the current goal and optimized goals.\n+   * @param broker         Broker to be balanced.\n+   * @param clusterModel   The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    LOG.debug(\"balancing broker {}, optimized goals = {}\", broker, optimizedGoals);\n+    moveAwayOfflineReplicas(broker, clusterModel, optimizedGoals, optimizationOptions);\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+      return;\n+    }\n+    for (String topicMustHaveLeaderPerBroker : _mustHaveTopicLeadersPerBroker) {\n+      maybeMoveLeaderOfTopicToBroker(topicMustHaveLeaderPerBroker, broker, clusterModel, optimizedGoals, optimizationOptions);\n+    }\n+  }\n+\n+  private void maybeMoveLeaderOfTopicToBroker(String topicMustHaveLeaderPerBroker,\n+                                              Broker broker,\n+                                              ClusterModel clusterModel,\n+                                              Set<Goal> optimizedGoals,\n+                                              OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    int topicLeaderCountOnReceiverBroker = broker.numLeadersFor(topicMustHaveLeaderPerBroker);\n+    if (topicLeaderCountOnReceiverBroker >= minTopicLeadersPerBroker()) {\n+      return; // This broker has enough leader replica(s) for the given topic\n+    }\n+    // Try to elect follower replica(s) of the interested topic on this broker to be leader\n+    Set<Replica> followerReplicas = broker.trackedSortedReplicas(_replicaSortName)\n+                                          .sortedReplicas(false).stream().filter(\n+                                              replica -> !replica.isLeader()\n+                                                         && replica.topicPartition().topic().equals(topicMustHaveLeaderPerBroker))\n+                                          .collect(Collectors.toSet());\n+\n+    for (Replica followerReplica : followerReplicas) {\n+      Replica leader = clusterModel.partition(followerReplica.topicPartition()).leader();\n+      if (leader.broker().numLeadersFor(topicMustHaveLeaderPerBroker) > minTopicLeadersPerBroker()) {\n+        if (maybeApplyBalancingAction(clusterModel, leader, Collections.singleton(broker),\n+                                      LEADERSHIP_MOVEMENT, optimizedGoals, optimizationOptions) != null) {\n+          topicLeaderCountOnReceiverBroker++;\n+          if (topicLeaderCountOnReceiverBroker >= minTopicLeadersPerBroker()) {\n+            return; // This broker satisfies this goal for the given topic\n+          }\n+        }\n+      }\n+    }\n+\n+    // Try to move leader replica(s) of the interested topic from other brokers to this broker\n+    PriorityQueue<Broker> brokersWithExcessiveLeaderToMove =\n+        getBrokersWithExcessiveLeaderToMove(topicMustHaveLeaderPerBroker, clusterModel, broker);\n+\n+    while (!brokersWithExcessiveLeaderToMove.isEmpty()) {\n+      Broker brokerWithExcessiveLeaderToMove = brokersWithExcessiveLeaderToMove.poll();\n+      List<Replica> leadersOfTopic = brokerWithExcessiveLeaderToMove.trackedSortedReplicas(_replicaSortName)\n+                                                                                  .sortedReplicas(false).stream()\n+                                                                                  .filter(replica ->\n+                                                                                              replica.isLeader()\n+                                                                                              && replica.topicPartition()\n+                                                                                                        .topic()\n+                                                                                                        .equals(topicMustHaveLeaderPerBroker))\n+                                                                                  .collect(Collectors.toList());\n+      boolean leaderMoved = false;\n+      int topicLeaderCountOnGiverBroker = leadersOfTopic.size();\n+      for (Replica leaderOfTopic : leadersOfTopic) {\n+        Broker destinationBroker = maybeApplyBalancingAction(clusterModel, leaderOfTopic, Collections.singleton(broker),\n+                                                             INTER_BROKER_REPLICA_MOVEMENT, optimizedGoals, optimizationOptions);\n+        if (destinationBroker != null) {\n+          leaderMoved = true;\n+          break; // Successfully move one leader replica\n+        }\n+      }\n+      if (leaderMoved) {\n+        topicLeaderCountOnReceiverBroker++;\n+        if (topicLeaderCountOnReceiverBroker >= minTopicLeadersPerBroker()) {\n+          return; // This broker satisfies this goal for the given topic\n+        }\n+        topicLeaderCountOnGiverBroker--;\n+        if (topicLeaderCountOnGiverBroker > minTopicLeadersPerBroker()) {\n+          // Still have excessive topic leader to give\n+          brokersWithExcessiveLeaderToMove.add(brokerWithExcessiveLeaderToMove);\n+        }\n+      }\n+    }\n+    throw new OptimizationFailureException(String.format(\"Cannot make broker %d have at least %d leader replica(s) of topic %s\",\n+                                                         broker.id(),\n+                                                         minTopicLeadersPerBroker(),\n+                                                         topicMustHaveLeaderPerBroker));\n+  }\n+\n+  /**\n+   * This method creates a priority queue which has the broker with the most number of leader replicas of a given topic at the top of queue\n+   * @param topicName name of the given topic\n+   * @param clusterModel cluster model\n+   * @param originalBroker original broker which needs to be excluded from the priority queue\n+   * @return a priority queue which has the broker with the most number of leader replicas of a given topic at the top of queue\n+   */\n+  private PriorityQueue<Broker> getBrokersWithExcessiveLeaderToMove(String topicName, ClusterModel clusterModel, Broker originalBroker) {\n+    PriorityQueue<Broker> brokersWithExcessiveLeaderToMove = new PriorityQueue<>((broker1, broker2) -> {\n+      int broker1LeaderCount = broker1.numLeadersFor(topicName);\n+      int broker2LeaderCount = broker2.numLeadersFor(topicName);\n+      int leaderCountCompareResult = Integer.compare(broker2LeaderCount, broker1LeaderCount);\n+      return leaderCountCompareResult == 0 ? Integer.compare(broker1.id(), broker2.id()) : leaderCountCompareResult;\n+    });\n+    clusterModel.aliveBrokers()\n+                .stream()\n+                .filter(broker -> broker.numLeadersFor(topicName) > minTopicLeadersPerBroker())\n+                .forEach(brokersWithExcessiveLeaderToMove::add);\n+    return brokersWithExcessiveLeaderToMove;\n+  }\n+\n+  private Set<Broker> eligibleBrokersForLeadership(ClusterModel clusterModel, OptimizationOptions optimizationOptions) {\n+    return clusterModel.brokers()\n+                       .stream()\n+                       .filter(broker -> isEligibleToHaveLeaders(broker, optimizationOptions))\n+                       .collect(Collectors.toSet());\n+  }\n+\n+  private boolean isEligibleToHaveLeaders(Broker broker, OptimizationOptions optimizationOptions) {\n+    return broker.isAlive()", "originalCommit": "b5e4dfa31d15e70a8c21429921cb48bda94826ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAwMTczNg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569001736", "bodyText": "Can we move broker.isAlive() out of isEligibleToHaveLeaders -- once we apply other proposed changes in this review, it would be redundant to have this check within the method.\nif (!(broker.isAlive() && isEligibleToHaveLeaders(broker, optimizationOptions))) {", "author": "efeg", "createdAt": "2021-02-02T23:26:39Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private final String _replicaSortName = replicaSortName(this, true, false);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderCountOnSourceBroker = replicaToBeRemoved.broker().numLeadersFor(topicName);\n+    return topicLeaderCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(_replicaSortName, clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderToDistribute(ClusterModel clusterModel,\n+                                                OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          minTopicLeadersPerBroker(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+    Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+\n+    if (replicaToBeMoved.broker().replica(action.topicPartition()).isCurrentOffline()) {\n+      return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+    }\n+    // Moving leader replica from more abundant broker is considered as self-satisfied\n+    return sourceBroker.numLeadersFor(replicaToBeMoved.topicPartition().topic()) > minTopicLeadersPerBroker();\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderOfTopics(clusterModel, optimizationOptions);\n+    finish();\n+  }\n+\n+  private void ensureBrokersAllHaveEnoughLeaderOfTopics(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    for (Broker broker : clusterModel.aliveBrokers()) {\n+      if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+        continue;\n+      }\n+      for (String mustHaveLeaderPerBrokerTopicName : _mustHaveTopicLeadersPerBroker) {\n+        int leaderCount = broker.numLeadersFor(mustHaveLeaderPerBrokerTopicName);\n+        if (leaderCount < minTopicLeadersPerBroker()) {\n+          throw new OptimizationFailureException(String.format(\"Broker %d does not have enough leader replica for topic %s. \"\n+              + \"Minimum required per-broker leader replica count %d. Actual broker leader replica count %d\",\n+              broker.id(), mustHaveLeaderPerBrokerTopicName, minTopicLeadersPerBroker(), leaderCount));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of the current goal and optimized goals.\n+   * @param broker         Broker to be balanced.\n+   * @param clusterModel   The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    LOG.debug(\"balancing broker {}, optimized goals = {}\", broker, optimizedGoals);\n+    moveAwayOfflineReplicas(broker, clusterModel, optimizedGoals, optimizationOptions);\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {", "originalCommit": "b5e4dfa31d15e70a8c21429921cb48bda94826ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "24d8ad76ebb21bdbe3428966f6c0d04c18ed347c", "url": "https://github.com/linkedin/cruise-control/commit/24d8ad76ebb21bdbe3428966f6c0d04c18ed347c", "message": "Fix some issues", "committedDate": "2021-02-02T23:38:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAwNTc3Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569005777", "bodyText": "Set does not guarantee order preservation. Should we use a LinkedHashSet (or a List) here to preserve the order? -- e.g.\n    Set<Replica> followerReplicas = broker.trackedSortedReplicas(_replicaSortName)\n                                          .sortedReplicas(false).stream()\n                                          .filter(r -> !r.isLeader() && r.topicPartition().topic().equals(topicMustHaveLeaderPerBroker))\n                                          .collect(Collectors.toCollection(LinkedHashSet::new));", "author": "efeg", "createdAt": "2021-02-02T23:36:26Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private final String _replicaSortName = replicaSortName(this, true, false);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderCountOnSourceBroker = replicaToBeRemoved.broker().numLeadersFor(topicName);\n+    return topicLeaderCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(_replicaSortName, clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderToDistribute(ClusterModel clusterModel,\n+                                                OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          minTopicLeadersPerBroker(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+    Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+\n+    if (replicaToBeMoved.broker().replica(action.topicPartition()).isCurrentOffline()) {\n+      return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+    }\n+    // Moving leader replica from more abundant broker is considered as self-satisfied\n+    return sourceBroker.numLeadersFor(replicaToBeMoved.topicPartition().topic()) > minTopicLeadersPerBroker();\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderOfTopics(clusterModel, optimizationOptions);\n+    finish();\n+  }\n+\n+  private void ensureBrokersAllHaveEnoughLeaderOfTopics(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    for (Broker broker : clusterModel.aliveBrokers()) {\n+      if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+        continue;\n+      }\n+      for (String mustHaveLeaderPerBrokerTopicName : _mustHaveTopicLeadersPerBroker) {\n+        int leaderCount = broker.numLeadersFor(mustHaveLeaderPerBrokerTopicName);\n+        if (leaderCount < minTopicLeadersPerBroker()) {\n+          throw new OptimizationFailureException(String.format(\"Broker %d does not have enough leader replica for topic %s. \"\n+              + \"Minimum required per-broker leader replica count %d. Actual broker leader replica count %d\",\n+              broker.id(), mustHaveLeaderPerBrokerTopicName, minTopicLeadersPerBroker(), leaderCount));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of the current goal and optimized goals.\n+   * @param broker         Broker to be balanced.\n+   * @param clusterModel   The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    LOG.debug(\"balancing broker {}, optimized goals = {}\", broker, optimizedGoals);\n+    moveAwayOfflineReplicas(broker, clusterModel, optimizedGoals, optimizationOptions);\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+      return;\n+    }\n+    for (String topicMustHaveLeaderPerBroker : _mustHaveTopicLeadersPerBroker) {\n+      maybeMoveLeaderOfTopicToBroker(topicMustHaveLeaderPerBroker, broker, clusterModel, optimizedGoals, optimizationOptions);\n+    }\n+  }\n+\n+  private void maybeMoveLeaderOfTopicToBroker(String topicMustHaveLeaderPerBroker,\n+                                              Broker broker,\n+                                              ClusterModel clusterModel,\n+                                              Set<Goal> optimizedGoals,\n+                                              OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    int topicLeaderCountOnReceiverBroker = broker.numLeadersFor(topicMustHaveLeaderPerBroker);\n+    if (topicLeaderCountOnReceiverBroker >= minTopicLeadersPerBroker()) {\n+      return; // This broker has enough leader replica(s) for the given topic\n+    }\n+    // Try to elect follower replica(s) of the interested topic on this broker to be leader\n+    Set<Replica> followerReplicas = broker.trackedSortedReplicas(_replicaSortName)", "originalCommit": "f4ff4847acaa42c21bfcda816aab897e0a502324", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAxNDA5NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569014095", "bodyText": "I will go with List", "author": "Lincong", "createdAt": "2021-02-02T23:57:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAwNTc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAwOTUzMg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569009532", "bodyText": "Nit: Missing dot at the end of exception message.", "author": "efeg", "createdAt": "2021-02-02T23:45:46Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private final String _replicaSortName = replicaSortName(this, true, false);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    String topicName = replicaToBeRemoved.topicPartition().topic();\n+    if (!_mustHaveTopicLeadersPerBroker.contains(topicName)) {\n+      // Moving a replica of a irrelevant topic does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderCountOnSourceBroker = replicaToBeRemoved.broker().numLeadersFor(topicName);\n+    return topicLeaderCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(_replicaSortName, clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderToDistribute(ClusterModel clusterModel,\n+                                                OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          minTopicLeadersPerBroker(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+    Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+\n+    if (replicaToBeMoved.broker().replica(action.topicPartition()).isCurrentOffline()) {\n+      return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+    }\n+    // Moving leader replica from more abundant broker is considered as self-satisfied\n+    return sourceBroker.numLeadersFor(replicaToBeMoved.topicPartition().topic()) > minTopicLeadersPerBroker();\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderOfTopics(clusterModel, optimizationOptions);\n+    finish();\n+  }\n+\n+  private void ensureBrokersAllHaveEnoughLeaderOfTopics(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    for (Broker broker : clusterModel.aliveBrokers()) {\n+      if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+        continue;\n+      }\n+      for (String mustHaveLeaderPerBrokerTopicName : _mustHaveTopicLeadersPerBroker) {\n+        int leaderCount = broker.numLeadersFor(mustHaveLeaderPerBrokerTopicName);\n+        if (leaderCount < minTopicLeadersPerBroker()) {\n+          throw new OptimizationFailureException(String.format(\"Broker %d does not have enough leader replica for topic %s. \"\n+              + \"Minimum required per-broker leader replica count %d. Actual broker leader replica count %d\",\n+              broker.id(), mustHaveLeaderPerBrokerTopicName, minTopicLeadersPerBroker(), leaderCount));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of the current goal and optimized goals.\n+   * @param broker         Broker to be balanced.\n+   * @param clusterModel   The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    LOG.debug(\"balancing broker {}, optimized goals = {}\", broker, optimizedGoals);\n+    moveAwayOfflineReplicas(broker, clusterModel, optimizedGoals, optimizationOptions);\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+      return;\n+    }\n+    for (String topicMustHaveLeaderPerBroker : _mustHaveTopicLeadersPerBroker) {\n+      maybeMoveLeaderOfTopicToBroker(topicMustHaveLeaderPerBroker, broker, clusterModel, optimizedGoals, optimizationOptions);\n+    }\n+  }\n+\n+  private void maybeMoveLeaderOfTopicToBroker(String topicMustHaveLeaderPerBroker,\n+                                              Broker broker,\n+                                              ClusterModel clusterModel,\n+                                              Set<Goal> optimizedGoals,\n+                                              OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    int topicLeaderCountOnReceiverBroker = broker.numLeadersFor(topicMustHaveLeaderPerBroker);\n+    if (topicLeaderCountOnReceiverBroker >= minTopicLeadersPerBroker()) {\n+      return; // This broker has enough leader replica(s) for the given topic\n+    }\n+    // Try to elect follower replica(s) of the interested topic on this broker to be leader\n+    Set<Replica> followerReplicas = broker.trackedSortedReplicas(_replicaSortName)\n+                                          .sortedReplicas(false).stream().filter(\n+                                              replica -> !replica.isLeader()\n+                                                         && replica.topicPartition().topic().equals(topicMustHaveLeaderPerBroker))\n+                                          .collect(Collectors.toSet());\n+\n+    for (Replica followerReplica : followerReplicas) {\n+      Replica leader = clusterModel.partition(followerReplica.topicPartition()).leader();\n+      if (leader.broker().numLeadersFor(topicMustHaveLeaderPerBroker) > minTopicLeadersPerBroker()) {\n+        if (maybeApplyBalancingAction(clusterModel, leader, Collections.singleton(broker),\n+                                      LEADERSHIP_MOVEMENT, optimizedGoals, optimizationOptions) != null) {\n+          topicLeaderCountOnReceiverBroker++;\n+          if (topicLeaderCountOnReceiverBroker >= minTopicLeadersPerBroker()) {\n+            return; // This broker satisfies this goal for the given topic\n+          }\n+        }\n+      }\n+    }\n+\n+    // Try to move leader replica(s) of the interested topic from other brokers to this broker\n+    PriorityQueue<Broker> brokersWithExcessiveLeaderToMove =\n+        getBrokersWithExcessiveLeaderToMove(topicMustHaveLeaderPerBroker, clusterModel, broker);\n+\n+    while (!brokersWithExcessiveLeaderToMove.isEmpty()) {\n+      Broker brokerWithExcessiveLeaderToMove = brokersWithExcessiveLeaderToMove.poll();\n+      List<Replica> leadersOfTopic = brokerWithExcessiveLeaderToMove.trackedSortedReplicas(_replicaSortName)\n+                                                                                  .sortedReplicas(false).stream()\n+                                                                                  .filter(replica ->\n+                                                                                              replica.isLeader()\n+                                                                                              && replica.topicPartition()\n+                                                                                                        .topic()\n+                                                                                                        .equals(topicMustHaveLeaderPerBroker))\n+                                                                                  .collect(Collectors.toList());\n+      boolean leaderMoved = false;\n+      int topicLeaderCountOnGiverBroker = leadersOfTopic.size();\n+      for (Replica leaderOfTopic : leadersOfTopic) {\n+        Broker destinationBroker = maybeApplyBalancingAction(clusterModel, leaderOfTopic, Collections.singleton(broker),\n+                                                             INTER_BROKER_REPLICA_MOVEMENT, optimizedGoals, optimizationOptions);\n+        if (destinationBroker != null) {\n+          leaderMoved = true;\n+          break; // Successfully move one leader replica\n+        }\n+      }\n+      if (leaderMoved) {\n+        topicLeaderCountOnReceiverBroker++;\n+        if (topicLeaderCountOnReceiverBroker >= minTopicLeadersPerBroker()) {\n+          return; // This broker satisfies this goal for the given topic\n+        }\n+        topicLeaderCountOnGiverBroker--;\n+        if (topicLeaderCountOnGiverBroker > minTopicLeadersPerBroker()) {\n+          // Still have excessive topic leader to give\n+          brokersWithExcessiveLeaderToMove.add(brokerWithExcessiveLeaderToMove);\n+        }\n+      }\n+    }\n+    throw new OptimizationFailureException(String.format(\"Cannot make broker %d have at least %d leader replica(s) of topic %s\",", "originalCommit": "f4ff4847acaa42c21bfcda816aab897e0a502324", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAxMTM1NA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569011354", "bodyText": "What is the purpose of this new function?\nWhy don't the caller of this function just call goal(goalClass, configOverrides);?\nCan we drop this function?", "author": "efeg", "createdAt": "2021-02-02T23:50:26Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/analyzer/AnalyzerUnitTestUtils.java", "diffHunk": "@@ -54,4 +54,15 @@ public static Goal goal(Class<? extends Goal> goalClass, Properties configOverri\n   public static Goal goal(Class<? extends Goal> goalClass) throws Exception {\n     return goal(goalClass, new Properties());\n   }\n+\n+  /**\n+   * Reflectively create goal object from specified goal class and a set of config overrides.\n+   *\n+   * @param goalClass The goal class to create object.\n+   * @param configOverrides A set of config properties to override.\n+   * @return New object of specified class.\n+   */\n+  public static Goal goalWithConfigOverrides(Class<? extends Goal> goalClass, Properties configOverrides) throws Exception {\n+    return goal(goalClass, configOverrides);\n+  }", "originalCommit": "24d8ad76ebb21bdbe3428966f6c0d04c18ed347c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAxNTk0MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569015941", "bodyText": "Yes, we can drop it", "author": "Lincong", "createdAt": "2021-02-03T00:02:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAxMTM1NA=="}], "type": "inlineReview"}, {"oid": "5e8f98c435c79ca51189451b97ff7ffe3be02393", "url": "https://github.com/linkedin/cruise-control/commit/5e8f98c435c79ca51189451b97ff7ffe3be02393", "message": "Removed redundant method", "committedDate": "2021-02-03T00:02:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAyMjEzNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569022135", "bodyText": "Nit: Redundant space.", "author": "efeg", "createdAt": "2021-02-03T00:19:11Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/TestConstants.java", "diffHunk": "@@ -17,6 +17,8 @@\n   public static final String TOPIC1 = \"topic1\";\n   public static final String TOPIC2 = \"topic2\";\n   public static final String TOPIC3 = \"topic3\";\n+  public static final String TOPIC_MUST_HAVE_LEADER_REPLICAS_ON_BROKERS = \"must_have_leader_replica_on_broker_topic\";\n+", "originalCommit": "5e8f98c435c79ca51189451b97ff7ffe3be02393", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAyMzIyNg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569023226", "bodyText": "Shouldn't this be T_P2_leader?", "author": "efeg", "createdAt": "2021-02-03T00:22:17Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java", "diffHunk": "@@ -284,6 +299,267 @@ public static ClusterModel rackAwareUnsatisfiable() {\n     return cluster;\n   }\n \n+  /**\n+   * Three brokers, one topic, three partitions, each partition has two replicas.\n+   * <p>\n+   * <h3>Replica Distribution</h3>\n+   * <li>B0: T_P0_leader, T_P1_leader</li>\n+   * <li>B1: T_P2_leader, T_P0_follower</li>\n+   * <li>B2: T_P2_follower, T_P1_follower</li>\n+   * </p>\n+   *\n+   * @return Cluster model for the tests.\n+   */\n+  public static ClusterModel minLeaderReplicaPerBrokerSatisfiable() {\n+    ClusterModel cluster = getHomogeneousCluster(RACK_BY_BROKER2, TestConstants.BROKER_CAPACITY, null);\n+\n+    // Create topic partition.\n+    TopicPartition pInfoT0 = new TopicPartition(TOPIC_MUST_HAVE_LEADER_REPLICAS_ON_BROKERS, 0);\n+    TopicPartition pInfoT1 = new TopicPartition(TOPIC_MUST_HAVE_LEADER_REPLICAS_ON_BROKERS, 1);\n+    TopicPartition pInfoT2 = new TopicPartition(TOPIC_MUST_HAVE_LEADER_REPLICAS_ON_BROKERS, 2);\n+\n+    // Create replicas for topics.\n+    cluster.createReplica(RACK_BY_BROKER2.get(0).toString(), 0, pInfoT0, 0, true);  // T_P0_leader\n+    cluster.createReplica(RACK_BY_BROKER2.get(0).toString(), 0, pInfoT1, 0, true);  // T_P1_leader\n+\n+    cluster.createReplica(RACK_BY_BROKER2.get(1).toString(), 1, pInfoT2, 0, true);  // T_P2_leader\n+    cluster.createReplica(RACK_BY_BROKER2.get(1).toString(), 1, pInfoT0, 1, false); // T_P0_follower\n+\n+    cluster.createReplica(RACK_BY_BROKER2.get(2).toString(), 2, pInfoT2, 1, false); // T_P2_follower\n+    cluster.createReplica(RACK_BY_BROKER2.get(2).toString(), 2, pInfoT1, 1, false); // T_P1_follower\n+\n+    AggregatedMetricValues aggregatedMetricValues =\n+        getAggregatedMetricValues(TestConstants.TYPICAL_CPU_CAPACITY / 2,\n+            TestConstants.LARGE_BROKER_CAPACITY / 2,\n+            TestConstants.MEDIUM_BROKER_CAPACITY / 2,\n+            TestConstants.LARGE_BROKER_CAPACITY / 2);\n+\n+    // Create snapshots and push them to the cluster.\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(0).toString(), 0, pInfoT0, aggregatedMetricValues, Collections.singletonList(1L));\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(0).toString(), 0, pInfoT1, aggregatedMetricValues, Collections.singletonList(1L));\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(1).toString(), 1, pInfoT0, aggregatedMetricValues, Collections.singletonList(1L));\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(1).toString(), 1, pInfoT2, aggregatedMetricValues, Collections.singletonList(1L));\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(2).toString(), 2, pInfoT2, aggregatedMetricValues, Collections.singletonList(1L));\n+\n+    return cluster;\n+  }\n+\n+  /**\n+   * Three brokers, one topic, three partitions, each partition has 2 replicas.\n+   * <p>\n+   * <h3>Replica Distribution</h3>\n+   * <li>B0: T_P0_leader, T_P1_leader, T_P2_leader</li>\n+   * <li>B1: T_P1_follower</li>\n+   * <li>B2: T_P0_follower, T_P2_follower</li>\n+   * </p>\n+   *\n+   * @return Cluster model for the tests.\n+   */\n+  public static ClusterModel minLeaderReplicaPerBrokerSatisfiable2() {\n+    ClusterModel cluster = getHomogeneousCluster(RACK_BY_BROKER2, TestConstants.BROKER_CAPACITY, null);\n+\n+    // Create topic partition.\n+    TopicPartition pInfoT0 = new TopicPartition(TOPIC_MUST_HAVE_LEADER_REPLICAS_ON_BROKERS, 0);\n+    TopicPartition pInfoT1 = new TopicPartition(TOPIC_MUST_HAVE_LEADER_REPLICAS_ON_BROKERS, 1);\n+    TopicPartition pInfoT2 = new TopicPartition(TOPIC_MUST_HAVE_LEADER_REPLICAS_ON_BROKERS, 2);\n+\n+    // Create replicas for topics.\n+    cluster.createReplica(RACK_BY_BROKER2.get(0).toString(), 0, pInfoT0, 0, true);  // T_P0_leader\n+    cluster.createReplica(RACK_BY_BROKER2.get(0).toString(), 0, pInfoT1, 0, true);  // T_P1_leader\n+    cluster.createReplica(RACK_BY_BROKER2.get(0).toString(), 0, pInfoT2, 0, true);  // T_P1_leader", "originalCommit": "5e8f98c435c79ca51189451b97ff7ffe3be02393", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAyNjYxMg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569026612", "bodyText": "Can we make this and similar repeated uses more compact when applicable -- e.g.\n    for (int bId : Arrays.asList(1, 2)) {\n      cluster.setReplicaLoad(RACK_BY_BROKER2.get(bId).toString(), bId, topic0Partition0, aggregatedMetricValues, Collections.singletonList(1L));\n      cluster.setReplicaLoad(RACK_BY_BROKER2.get(bId).toString(), bId, topic0Partition1, aggregatedMetricValues, Collections.singletonList(1L));\n      ...\n    }", "author": "efeg", "createdAt": "2021-02-03T00:31:48Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java", "diffHunk": "@@ -284,6 +299,267 @@ public static ClusterModel rackAwareUnsatisfiable() {\n     return cluster;\n   }\n \n+  /**\n+   * Three brokers, one topic, three partitions, each partition has two replicas.\n+   * <p>\n+   * <h3>Replica Distribution</h3>\n+   * <li>B0: T_P0_leader, T_P1_leader</li>\n+   * <li>B1: T_P2_leader, T_P0_follower</li>\n+   * <li>B2: T_P2_follower, T_P1_follower</li>\n+   * </p>\n+   *\n+   * @return Cluster model for the tests.\n+   */\n+  public static ClusterModel minLeaderReplicaPerBrokerSatisfiable() {\n+    ClusterModel cluster = getHomogeneousCluster(RACK_BY_BROKER2, TestConstants.BROKER_CAPACITY, null);\n+\n+    // Create topic partition.\n+    TopicPartition pInfoT0 = new TopicPartition(TOPIC_MUST_HAVE_LEADER_REPLICAS_ON_BROKERS, 0);\n+    TopicPartition pInfoT1 = new TopicPartition(TOPIC_MUST_HAVE_LEADER_REPLICAS_ON_BROKERS, 1);\n+    TopicPartition pInfoT2 = new TopicPartition(TOPIC_MUST_HAVE_LEADER_REPLICAS_ON_BROKERS, 2);\n+\n+    // Create replicas for topics.\n+    cluster.createReplica(RACK_BY_BROKER2.get(0).toString(), 0, pInfoT0, 0, true);  // T_P0_leader\n+    cluster.createReplica(RACK_BY_BROKER2.get(0).toString(), 0, pInfoT1, 0, true);  // T_P1_leader\n+\n+    cluster.createReplica(RACK_BY_BROKER2.get(1).toString(), 1, pInfoT2, 0, true);  // T_P2_leader\n+    cluster.createReplica(RACK_BY_BROKER2.get(1).toString(), 1, pInfoT0, 1, false); // T_P0_follower\n+\n+    cluster.createReplica(RACK_BY_BROKER2.get(2).toString(), 2, pInfoT2, 1, false); // T_P2_follower\n+    cluster.createReplica(RACK_BY_BROKER2.get(2).toString(), 2, pInfoT1, 1, false); // T_P1_follower\n+\n+    AggregatedMetricValues aggregatedMetricValues =\n+        getAggregatedMetricValues(TestConstants.TYPICAL_CPU_CAPACITY / 2,\n+            TestConstants.LARGE_BROKER_CAPACITY / 2,\n+            TestConstants.MEDIUM_BROKER_CAPACITY / 2,\n+            TestConstants.LARGE_BROKER_CAPACITY / 2);\n+\n+    // Create snapshots and push them to the cluster.\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(0).toString(), 0, pInfoT0, aggregatedMetricValues, Collections.singletonList(1L));\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(0).toString(), 0, pInfoT1, aggregatedMetricValues, Collections.singletonList(1L));\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(1).toString(), 1, pInfoT0, aggregatedMetricValues, Collections.singletonList(1L));\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(1).toString(), 1, pInfoT2, aggregatedMetricValues, Collections.singletonList(1L));\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(2).toString(), 2, pInfoT2, aggregatedMetricValues, Collections.singletonList(1L));\n+\n+    return cluster;\n+  }\n+\n+  /**\n+   * Three brokers, one topic, three partitions, each partition has 2 replicas.\n+   * <p>\n+   * <h3>Replica Distribution</h3>\n+   * <li>B0: T_P0_leader, T_P1_leader, T_P2_leader</li>\n+   * <li>B1: T_P1_follower</li>\n+   * <li>B2: T_P0_follower, T_P2_follower</li>\n+   * </p>\n+   *\n+   * @return Cluster model for the tests.\n+   */\n+  public static ClusterModel minLeaderReplicaPerBrokerSatisfiable2() {\n+    ClusterModel cluster = getHomogeneousCluster(RACK_BY_BROKER2, TestConstants.BROKER_CAPACITY, null);\n+\n+    // Create topic partition.\n+    TopicPartition pInfoT0 = new TopicPartition(TOPIC_MUST_HAVE_LEADER_REPLICAS_ON_BROKERS, 0);\n+    TopicPartition pInfoT1 = new TopicPartition(TOPIC_MUST_HAVE_LEADER_REPLICAS_ON_BROKERS, 1);\n+    TopicPartition pInfoT2 = new TopicPartition(TOPIC_MUST_HAVE_LEADER_REPLICAS_ON_BROKERS, 2);\n+\n+    // Create replicas for topics.\n+    cluster.createReplica(RACK_BY_BROKER2.get(0).toString(), 0, pInfoT0, 0, true);  // T_P0_leader\n+    cluster.createReplica(RACK_BY_BROKER2.get(0).toString(), 0, pInfoT1, 0, true);  // T_P1_leader\n+    cluster.createReplica(RACK_BY_BROKER2.get(0).toString(), 0, pInfoT2, 0, true);  // T_P1_leader\n+\n+    cluster.createReplica(RACK_BY_BROKER2.get(1).toString(), 1, pInfoT1, 1, false); // T_P1_follower\n+\n+    cluster.createReplica(RACK_BY_BROKER2.get(2).toString(), 2, pInfoT0, 1, false); // T_P0_follower\n+    cluster.createReplica(RACK_BY_BROKER2.get(2).toString(), 2, pInfoT2, 1, false); // T_P0_follower\n+\n+    AggregatedMetricValues aggregatedMetricValues =\n+        getAggregatedMetricValues(TestConstants.TYPICAL_CPU_CAPACITY / 2,\n+            TestConstants.LARGE_BROKER_CAPACITY / 2,\n+            TestConstants.MEDIUM_BROKER_CAPACITY / 2,\n+            TestConstants.LARGE_BROKER_CAPACITY / 2);\n+\n+    // Create snapshots and push them to the cluster.\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(0).toString(), 0, pInfoT0, aggregatedMetricValues, Collections.singletonList(1L));\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(2).toString(), 2, pInfoT0, aggregatedMetricValues, Collections.singletonList(1L));\n+\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(0).toString(), 0, pInfoT1, aggregatedMetricValues, Collections.singletonList(1L));\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(1).toString(), 1, pInfoT1, aggregatedMetricValues, Collections.singletonList(1L));\n+\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(2).toString(), 2, pInfoT2, aggregatedMetricValues, Collections.singletonList(1L));\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(0).toString(), 0, pInfoT2, aggregatedMetricValues, Collections.singletonList(1L));\n+    return cluster;\n+  }\n+\n+  /**\n+   * Three brokers, two topics, each topic has three partitions, each partition has 2 replicas.\n+   * <p>\n+   * <h3>Replica Distribution</h3>\n+   * <li>B0: T0_P0_leader, T0_P1_leader, T0_P2_leader, T1_P0_leader, T1_P1_leader, T1_P2_leader</li>\n+   * <li>B1: T0_P0_follower, T0_P1_follower, T0_P2_follower, T1_P0_follower, T1_P1_follower, T1_P2_follower</li>\n+   * <li>B2: N/A</li>\n+   * </p>\n+   *\n+   * @return Cluster model for the tests.\n+   */\n+  public static ClusterModel minLeaderReplicaPerBrokerSatisfiable4() {\n+    ClusterModel cluster = getHomogeneousCluster(RACK_BY_BROKER2, TestConstants.BROKER_CAPACITY, null);\n+\n+    // Create topic partitions.\n+    TopicPartition topic0Partition0 = new TopicPartition(TOPIC0, 0);\n+    TopicPartition topic0Partition1 = new TopicPartition(TOPIC0, 1);\n+    TopicPartition topic0Partition2 = new TopicPartition(TOPIC0, 2);\n+\n+    TopicPartition topic1Partition0 = new TopicPartition(TOPIC1, 0);\n+    TopicPartition topic1Partition1 = new TopicPartition(TOPIC1, 1);\n+    TopicPartition topic1Partition2 = new TopicPartition(TOPIC1, 2);\n+\n+    // Create replicas for topics.\n+    cluster.createReplica(RACK_BY_BROKER2.get(0).toString(), 0, topic0Partition0, 0, true);  // T0_P0_leader\n+    cluster.createReplica(RACK_BY_BROKER2.get(0).toString(), 0, topic0Partition1, 0, true);  // T0_P1_leader\n+    cluster.createReplica(RACK_BY_BROKER2.get(0).toString(), 0, topic0Partition2, 0, true);  // T0_P2_leader\n+    cluster.createReplica(RACK_BY_BROKER2.get(0).toString(), 0, topic1Partition0, 0, true);  // T1_P0_leader\n+    cluster.createReplica(RACK_BY_BROKER2.get(0).toString(), 0, topic1Partition1, 0, true);  // T1_P1_leader\n+    cluster.createReplica(RACK_BY_BROKER2.get(0).toString(), 0, topic1Partition2, 0, true);  // T1_P2_leader\n+\n+    cluster.createReplica(RACK_BY_BROKER2.get(1).toString(), 1, topic0Partition0, 1, false); // T0_P0_follower\n+    cluster.createReplica(RACK_BY_BROKER2.get(1).toString(), 1, topic0Partition1, 1, false); // T0_P1_follower\n+    cluster.createReplica(RACK_BY_BROKER2.get(1).toString(), 1, topic0Partition2, 1, false); // T0_P2_follower\n+    cluster.createReplica(RACK_BY_BROKER2.get(1).toString(), 1, topic1Partition0, 1, false); // T1_P0_follower\n+    cluster.createReplica(RACK_BY_BROKER2.get(1).toString(), 1, topic1Partition1, 1, false); // T1_P1_follower\n+    cluster.createReplica(RACK_BY_BROKER2.get(1).toString(), 1, topic1Partition2, 1, false); // T1_P2_follower\n+\n+    AggregatedMetricValues aggregatedMetricValues =\n+        getAggregatedMetricValues(TestConstants.TYPICAL_CPU_CAPACITY / 2,\n+                                  TestConstants.LARGE_BROKER_CAPACITY / 2,\n+                                  TestConstants.MEDIUM_BROKER_CAPACITY / 2,\n+                                  TestConstants.LARGE_BROKER_CAPACITY / 2);\n+\n+    // Create snapshots and push them to the cluster.\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(0).toString(), 0, topic0Partition0, aggregatedMetricValues, Collections.singletonList(1L));\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(1).toString(), 1, topic0Partition0, aggregatedMetricValues, Collections.singletonList(1L));\n+\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(0).toString(), 0, topic0Partition1, aggregatedMetricValues, Collections.singletonList(1L));\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(1).toString(), 1, topic0Partition1, aggregatedMetricValues, Collections.singletonList(1L));\n+\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(0).toString(), 0, topic0Partition2, aggregatedMetricValues, Collections.singletonList(1L));\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(1).toString(), 1, topic0Partition2, aggregatedMetricValues, Collections.singletonList(1L));\n+\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(0).toString(), 0, topic1Partition0, aggregatedMetricValues, Collections.singletonList(1L));\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(1).toString(), 1, topic1Partition0, aggregatedMetricValues, Collections.singletonList(1L));\n+\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(0).toString(), 0, topic1Partition1, aggregatedMetricValues, Collections.singletonList(1L));\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(1).toString(), 1, topic1Partition1, aggregatedMetricValues, Collections.singletonList(1L));\n+\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(0).toString(), 0, topic1Partition2, aggregatedMetricValues, Collections.singletonList(1L));\n+    cluster.setReplicaLoad(RACK_BY_BROKER2.get(1).toString(), 1, topic1Partition2, aggregatedMetricValues, Collections.singletonList(1L));", "originalCommit": "5e8f98c435c79ca51189451b97ff7ffe3be02393", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAyODM3Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569028376", "bodyText": "Are there any tests showing that there are no dead brokers, but there is an optimization failure exception due to inability to distribute leadership over eligible brokers?\nMaybe for that test, we can have a clustermodel with a single relevant topic with 1 leader and multiple brokers?", "author": "efeg", "createdAt": "2021-02-03T00:36:43Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/analyzer/ExcludedBrokersForLeadershipTest.java", "diffHunk": "@@ -112,6 +116,38 @@\n     p.add(params(5, RackAwareDistributionGoal.class, excludeB1, OptimizationFailureException.class, DeterministicCluster.rackAwareUnsatisfiable(),\n                  deadBroker0, null));\n \n+    // ============MinTopicLeadersPerBrokerGoal============\n+    Properties configOverrides = new Properties();\n+    configOverrides.put(AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG, TestConstants.TOPIC_MUST_HAVE_LEADER_REPLICAS_ON_BROKERS);\n+\n+    // With single excluded broker, no dead brokers (No exception, Expected to look optimized)", "originalCommit": "5e8f98c435c79ca51189451b97ff7ffe3be02393", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAzNTE0OA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569035148", "bodyText": "Yes, there is a test case in ReplicationFactorChangeTest for this goal to cover what you described:\nthere are no dead brokers, but there is an optimization failure exception due to inability to distribute leadership over eligible brokers.", "author": "Lincong", "createdAt": "2021-02-03T00:55:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAyODM3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA0NjY1Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569046656", "bodyText": "@Lincong But is there a test with excluded brokers with leadership moves, which are tested as part of this class?", "author": "efeg", "createdAt": "2021-02-03T01:27:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAyODM3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAyOTQyOA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569029428", "bodyText": "What is the purpose of this change?\nLooks like previous code was already doing the same thing with fewer arguments. Can we rollback this change?", "author": "efeg", "createdAt": "2021-02-03T00:39:35Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/analyzer/ExcludedBrokersForLeadershipTest.java", "diffHunk": "@@ -265,7 +301,8 @@ public ExcludedBrokersForLeadershipTest(int testId,\n                                           Boolean expectedToOptimize) {\n     _testId = testId;\n     _goal = goal;\n-    _optimizationOptions = new OptimizationOptions(Collections.emptySet(), excludedBrokersForLeadership);\n+    _optimizationOptions = new OptimizationOptions(Collections.emptySet(), excludedBrokersForLeadership,\n+                                                   Collections.emptySet(), false);", "originalCommit": "5e8f98c435c79ca51189451b97ff7ffe3be02393", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAzNjEzNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569036135", "bodyText": "Yes, rolled back", "author": "Lincong", "createdAt": "2021-02-03T00:58:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAyOTQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAzMTA3Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569031076", "bodyText": "If this is a common property that we would like to use in tests, let's move this to AnalyzerUnitTestUtils#goal, so that we can avoid changes to handle goal creation (1) with and (2) without this property separately in tests.", "author": "efeg", "createdAt": "2021-02-03T00:44:07Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/analyzer/ExcludedBrokersForLeadershipTest.java", "diffHunk": "@@ -112,6 +116,38 @@\n     p.add(params(5, RackAwareDistributionGoal.class, excludeB1, OptimizationFailureException.class, DeterministicCluster.rackAwareUnsatisfiable(),\n                  deadBroker0, null));\n \n+    // ============MinTopicLeadersPerBrokerGoal============\n+    Properties configOverrides = new Properties();\n+    configOverrides.put(AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG, TestConstants.TOPIC_MUST_HAVE_LEADER_REPLICAS_ON_BROKERS);", "originalCommit": "5e8f98c435c79ca51189451b97ff7ffe3be02393", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA1MDA0Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569050042", "bodyText": "I don't think this constant TOPIC_MUST_HAVE_LEADER_REPLICAS_ON_BROKERS is common property. Some tests use it to test this new hard goal. However, in some other test cases, this constant variable is not used since in these cases, we want to test how this new goal handles a cluster model with no topic names such as TOPIC_MUST_HAVE_LEADER_REPLICAS_ON_BROKERS", "author": "Lincong", "createdAt": "2021-02-03T01:37:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAzMTA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA1NjE0Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569056146", "bodyText": "sounds good -- thanks for the clarification", "author": "efeg", "createdAt": "2021-02-03T01:45:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAzMTA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAzMzA5Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569033093", "bodyText": "What is the purpose of this change -- can we rollback?", "author": "efeg", "createdAt": "2021-02-03T00:49:49Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/analyzer/ExcludedBrokersForReplicaMoveTest.java", "diffHunk": "@@ -280,7 +337,8 @@ public ExcludedBrokersForReplicaMoveTest(int testId,\n                                            Boolean expectedToGenerateProposals) {\n     _testId = testId;\n     _goal = goal;\n-    _optimizationOptions = new OptimizationOptions(Collections.emptySet(), Collections.emptySet(), excludedBrokersForReplicaMove);\n+    _optimizationOptions = new OptimizationOptions(Collections.emptySet(), Collections.emptySet(),\n+                                                   excludedBrokersForReplicaMove, false);", "originalCommit": "5e8f98c435c79ca51189451b97ff7ffe3be02393", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAzMzUxOA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569033518", "bodyText": "Bad indentation -- but we can completely drop this change via adding the relevant config property update to goal function directly. (please see earlier comment)", "author": "efeg", "createdAt": "2021-02-03T00:50:57Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/analyzer/ExcludedBrokersForReplicaMoveTest.java", "diffHunk": "@@ -350,8 +408,22 @@ public void test() throws Exception {\n                                  Collection<Integer> deadBrokers,\n                                  Boolean expectedToOptimize,\n                                  Boolean expectedToGenerateProposals) throws Exception {\n+    return params(tid, goalClass, excludedBrokersForReplicaMove, exceptionClass, clusterModel,\n+                  deadBrokers, expectedToOptimize, expectedToGenerateProposals, null);\n+  }\n+\n+  private static Object[] params(int tid,\n+      Class<? extends Goal> goalClass,\n+      Set<Integer> excludedBrokersForReplicaMove,\n+      Class<? extends Throwable> exceptionClass,\n+      ClusterModel clusterModel,\n+      Collection<Integer> deadBrokers,\n+      Boolean expectedToOptimize,\n+      Boolean expectedToGenerateProposals,\n+      Properties configOverrides) throws Exception {\n     deadBrokers.forEach(id -> clusterModel.setBrokerState(id, Broker.State.DEAD));\n-    return new Object[]{tid, goal(goalClass), excludedBrokersForReplicaMove, exceptionClass, clusterModel, expectedToOptimize,\n-                        expectedToGenerateProposals};\n+    Goal goal = configOverrides == null ? goal(goalClass) : goal(goalClass, configOverrides);\n+    return new Object[]{tid, goal, excludedBrokersForReplicaMove, exceptionClass, clusterModel, expectedToOptimize,\n+        expectedToGenerateProposals};", "originalCommit": "5e8f98c435c79ca51189451b97ff7ffe3be02393", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA1MjE2Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569052167", "bodyText": "Fixed the indentation issue. I prefer to keep the below change:\nconfigOverrides.put(AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG, TestConstants.TOPIC_MUST_HAVE_LEADER_REPLICAS_ON_BROKERS);\nBecause in some test cases, we want to set different values for the config AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG to test this new hard goal", "author": "Lincong", "createdAt": "2021-02-03T01:40:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAzMzUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAzNDE5Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569034193", "bodyText": "Can we rollback this redundant change?", "author": "efeg", "createdAt": "2021-02-03T00:53:01Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/analyzer/ExcludedTopicsTest.java", "diffHunk": "@@ -281,7 +296,8 @@ public ExcludedTopicsTest(int testId,\n                             Boolean expectedToGenerateProposals) {\n     _testId = testId;\n     _goal = goal;\n-    _optimizationOptions = new OptimizationOptions(excludedTopics);\n+    _optimizationOptions = new OptimizationOptions(excludedTopics, Collections.emptySet(),\n+                                                   Collections.emptySet(), false);", "originalCommit": "5e8f98c435c79ca51189451b97ff7ffe3be02393", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA1MjQ1MA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569052450", "bodyText": "Yes", "author": "Lincong", "createdAt": "2021-02-03T01:41:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAzNDE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAzOTQ5NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569039495", "bodyText": "In this test class, does it matter for the other goals if we make the config changes proposed under this if case? -- i.e. is it possible to drop if-else and just do the config changes regardless of what the goal is?", "author": "efeg", "createdAt": "2021-02-03T01:07:10Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/analyzer/ReplicationFactorChangeTest.java", "diffHunk": "@@ -270,6 +279,21 @@ private void prepareContext() {\n                                  Class<? extends Throwable> exceptionClass,\n                                  ClusterModel clusterModel,\n                                  Boolean expectedToOptimize) throws Exception {\n-    return new Object[]{tid, topics, replicationFactor, goal(goalClass), exceptionClass, clusterModel, expectedToOptimize};\n+    Goal goal;\n+    if (goalClass == MinTopicLeadersPerBrokerGoal.class) {", "originalCommit": "5e8f98c435c79ca51189451b97ff7ffe3be02393", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA1NTU4OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569055589", "bodyText": "The if-else statement can be dropped. However, I feel like it affects the readability since readers might be wondering why some config props such as MIN_TOPIC_LEADERS_PER_BROKER_CONFIG and TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG is required for this testing.\nWhereas with this if-else statement, it's very clear that these config props only need to be set for the MinTopicLeadersPerBrokerGoal.\nI will drop the if-else statement for now", "author": "Lincong", "createdAt": "2021-02-03T01:45:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAzOTQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA0MTUzOA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569041538", "bodyText": "Nit: this(\"T\" + topicId, 1, 1);", "author": "efeg", "createdAt": "2021-02-03T01:12:53Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/model/RandomCluster.java", "diffHunk": "@@ -522,9 +525,12 @@ public static ClusterModel singleBrokerWithBadDisk() throws BrokerCapacityResolu\n     private int _numTopicLeaders;\n \n     TopicMetadata(int topicId) {\n-      _topic = \"T\" + Integer.toString(topicId);\n-      _replicationFactor = 1;\n-      _numTopicLeaders = 1;\n+      this(\"T\" + Integer.toString(topicId), 1, 1);", "originalCommit": "5e8f98c435c79ca51189451b97ff7ffe3be02393", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA0MzkwNw==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569043907", "bodyText": "How is this topic used? Can we add some comment on its use?\nAlso\nNit: TopicWithOneLeaderReplicaPerBroker --> TopicWithOneLeaderPerBroker", "author": "efeg", "createdAt": "2021-02-03T01:19:23Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/model/RandomCluster.java", "diffHunk": "@@ -37,6 +37,8 @@\n  */\n public class RandomCluster {\n \n+  public static final String TOPIC_WITH_ONE_LEADER_REPLICA_PER_BROKER = \"TopicWithOneLeaderReplicaPerBroker\";\n+", "originalCommit": "5e8f98c435c79ca51189451b97ff7ffe3be02393", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6940f1d0140f831c3ed44225ebecad796e7cb716", "url": "https://github.com/linkedin/cruise-control/commit/6940f1d0140f831c3ed44225ebecad796e7cb716", "message": "Fix test-related issues", "committedDate": "2021-02-03T01:55:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA3NjUwNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569076505", "bodyText": "Nit: Can we make (1) eligibleBrokersForLeadership and (2) isEligibleToHaveLeaders functions static?", "author": "efeg", "createdAt": "2021-02-03T02:11:56Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private final String _replicaSortName = replicaSortName(this, true, false);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderCountOnSourceBroker = replicaToBeRemoved.broker().numLeadersFor(replicaToBeRemoved.topicPartition().topic());\n+    return topicLeaderCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(_replicaSortName, clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderToDistribute(ClusterModel clusterModel,\n+                                                OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          minTopicLeadersPerBroker(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private static void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                             OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+    Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+\n+    if (replicaToBeMoved.broker().replica(action.topicPartition()).isCurrentOffline()) {\n+      return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+    }\n+    // Moving leader replica from more abundant broker is considered as self-satisfied\n+    return sourceBroker.numLeadersFor(replicaToBeMoved.topicPartition().topic()) > minTopicLeadersPerBroker();\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderOfTopics(clusterModel, optimizationOptions);\n+    finish();\n+  }\n+\n+  private void ensureBrokersAllHaveEnoughLeaderOfTopics(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    for (Broker broker : clusterModel.aliveBrokers()) {\n+      if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+        continue;\n+      }\n+      for (String mustHaveLeaderPerBrokerTopicName : _mustHaveTopicLeadersPerBroker) {\n+        int leaderCount = broker.numLeadersFor(mustHaveLeaderPerBrokerTopicName);\n+        if (leaderCount < minTopicLeadersPerBroker()) {\n+          throw new OptimizationFailureException(String.format(\"Broker %d does not have enough leader replica for topic %s. \"\n+              + \"Minimum required per-broker leader replica count %d. Actual broker leader replica count %d\",\n+              broker.id(), mustHaveLeaderPerBrokerTopicName, minTopicLeadersPerBroker(), leaderCount));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of the current goal and optimized goals.\n+   * @param broker         Broker to be balanced.\n+   * @param clusterModel   The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    LOG.debug(\"balancing broker {}, optimized goals = {}\", broker, optimizedGoals);\n+    moveAwayOfflineReplicas(broker, clusterModel, optimizedGoals, optimizationOptions);\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    if (!(broker.isAlive() && isEligibleToHaveLeaders(broker, optimizationOptions))) {\n+      return;\n+    }\n+    for (String topicMustHaveLeaderPerBroker : _mustHaveTopicLeadersPerBroker) {\n+      maybeMoveLeaderOfTopicToBroker(topicMustHaveLeaderPerBroker, broker, clusterModel, optimizedGoals, optimizationOptions);\n+    }\n+  }\n+\n+  private void maybeMoveLeaderOfTopicToBroker(String topicMustHaveLeaderPerBroker,\n+                                              Broker broker,\n+                                              ClusterModel clusterModel,\n+                                              Set<Goal> optimizedGoals,\n+                                              OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    int topicLeaderCountOnReceiverBroker = broker.numLeadersFor(topicMustHaveLeaderPerBroker);\n+    if (topicLeaderCountOnReceiverBroker >= minTopicLeadersPerBroker()) {\n+      return; // This broker has enough leader replica(s) for the given topic\n+    }\n+    // Try to elect follower replica(s) of the interested topic on this broker to be leader\n+    List<Replica> followerReplicas = broker.trackedSortedReplicas(_replicaSortName)\n+                                          .sortedReplicas(false).stream().filter(\n+                                              replica -> !replica.isLeader()\n+                                                         && replica.topicPartition().topic().equals(topicMustHaveLeaderPerBroker))\n+                                          .collect(Collectors.toList());\n+\n+    for (Replica followerReplica : followerReplicas) {\n+      Replica leader = clusterModel.partition(followerReplica.topicPartition()).leader();\n+      if (leader.broker().numLeadersFor(topicMustHaveLeaderPerBroker) > minTopicLeadersPerBroker()) {\n+        if (maybeApplyBalancingAction(clusterModel, leader, Collections.singleton(broker),\n+                                      LEADERSHIP_MOVEMENT, optimizedGoals, optimizationOptions) != null) {\n+          topicLeaderCountOnReceiverBroker++;\n+          if (topicLeaderCountOnReceiverBroker >= minTopicLeadersPerBroker()) {\n+            return; // This broker satisfies this goal for the given topic\n+          }\n+        }\n+      }\n+    }\n+\n+    // Try to move leader replica(s) of the interested topic from other brokers to this broker\n+    PriorityQueue<Broker> brokersWithExcessiveLeaderToMove =\n+        getBrokersWithExcessiveLeaderToMove(topicMustHaveLeaderPerBroker, clusterModel, broker);\n+\n+    while (!brokersWithExcessiveLeaderToMove.isEmpty()) {\n+      Broker brokerWithExcessiveLeaderToMove = brokersWithExcessiveLeaderToMove.poll();\n+      List<Replica> leadersOfTopic = brokerWithExcessiveLeaderToMove.trackedSortedReplicas(_replicaSortName)\n+                                                                                  .sortedReplicas(false).stream()\n+                                                                                  .filter(replica ->\n+                                                                                              replica.isLeader()\n+                                                                                              && replica.topicPartition()\n+                                                                                                        .topic()\n+                                                                                                        .equals(topicMustHaveLeaderPerBroker))\n+                                                                                  .collect(Collectors.toList());\n+      boolean leaderMoved = false;\n+      int topicLeaderCountOnGiverBroker = leadersOfTopic.size();\n+      for (Replica leaderOfTopic : leadersOfTopic) {\n+        Broker destinationBroker = maybeApplyBalancingAction(clusterModel, leaderOfTopic, Collections.singleton(broker),\n+                                                             INTER_BROKER_REPLICA_MOVEMENT, optimizedGoals, optimizationOptions);\n+        if (destinationBroker != null) {\n+          leaderMoved = true;\n+          break; // Successfully move one leader replica\n+        }\n+      }\n+      if (leaderMoved) {\n+        topicLeaderCountOnReceiverBroker++;\n+        if (topicLeaderCountOnReceiverBroker >= minTopicLeadersPerBroker()) {\n+          return; // This broker satisfies this goal for the given topic\n+        }\n+        topicLeaderCountOnGiverBroker--;\n+        if (topicLeaderCountOnGiverBroker > minTopicLeadersPerBroker()) {\n+          // Still have excessive topic leader to give\n+          brokersWithExcessiveLeaderToMove.add(brokerWithExcessiveLeaderToMove);\n+        }\n+      }\n+    }\n+    throw new OptimizationFailureException(String.format(\"Cannot make broker %d have at least %d leader replica(s) of topic %s.\",\n+                                                         broker.id(),\n+                                                         minTopicLeadersPerBroker(),\n+                                                         topicMustHaveLeaderPerBroker));\n+  }\n+\n+  /**\n+   * This method creates a priority queue which has the broker with the most number of leader replicas of a given topic at the top of queue\n+   * @param topicName name of the given topic\n+   * @param clusterModel cluster model\n+   * @param originalBroker original broker which needs to be excluded from the priority queue\n+   * @return a priority queue which has the broker with the most number of leader replicas of a given topic at the top of queue\n+   */\n+  private PriorityQueue<Broker> getBrokersWithExcessiveLeaderToMove(String topicName, ClusterModel clusterModel, Broker originalBroker) {\n+    PriorityQueue<Broker> brokersWithExcessiveLeaderToMove = new PriorityQueue<>((broker1, broker2) -> {\n+      int broker1LeaderCount = broker1.numLeadersFor(topicName);\n+      int broker2LeaderCount = broker2.numLeadersFor(topicName);\n+      int leaderCountCompareResult = Integer.compare(broker2LeaderCount, broker1LeaderCount);\n+      return leaderCountCompareResult == 0 ? Integer.compare(broker1.id(), broker2.id()) : leaderCountCompareResult;\n+    });\n+    clusterModel.aliveBrokers()\n+                .stream()\n+                .filter(broker -> broker.numLeadersFor(topicName) > minTopicLeadersPerBroker())\n+                .forEach(brokersWithExcessiveLeaderToMove::add);\n+    return brokersWithExcessiveLeaderToMove;\n+  }\n+\n+  private Set<Broker> eligibleBrokersForLeadership(ClusterModel clusterModel, OptimizationOptions optimizationOptions) {\n+    return clusterModel.aliveBrokers()\n+                       .stream()\n+                       .filter(broker -> isEligibleToHaveLeaders(broker, optimizationOptions))\n+                       .collect(Collectors.toSet());\n+  }\n+\n+  private boolean isEligibleToHaveLeaders(Broker broker, OptimizationOptions optimizationOptions) {\n+    return !optimizationOptions.excludedBrokersForLeadership().contains(broker.id())\n+           && !optimizationOptions.excludedBrokersForReplicaMove().contains(broker.id());\n+  }", "originalCommit": "6940f1d0140f831c3ed44225ebecad796e7cb716", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA4MjQ4NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569082485", "bodyText": "Nit: -> leader replica(s) of -> leader(s) from", "author": "efeg", "createdAt": "2021-02-03T02:19:32Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/MinTopicLeadersPerBrokerGoal.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright 2021 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.analyzer.goals;\n+\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance;\n+import com.linkedin.kafka.cruisecontrol.analyzer.ActionType;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n+import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;\n+import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;\n+import com.linkedin.kafka.cruisecontrol.common.Utils;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;\n+import com.linkedin.kafka.cruisecontrol.model.Broker;\n+import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n+import com.linkedin.kafka.cruisecontrol.model.Replica;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaSortFunctionFactory;\n+import com.linkedin.kafka.cruisecontrol.model.SortedReplicasHelper;\n+import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.REPLICA_REJECT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionAcceptance.ACCEPT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.LEADERSHIP_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+import static com.linkedin.kafka.cruisecontrol.analyzer.goals.GoalUtils.replicaSortName;\n+\n+\n+/**\n+ * HARD GOAL: Generate leadership movement and leader replica movement proposals to ensure that each alive broker that\n+ * is not excluded for replica leadership moves has at least the minimum number (specified by\n+ * {@link AnalyzerConfig#MIN_TOPIC_LEADERS_PER_BROKER_CONFIG}) of leader replica of each topic in a configured set of topics\n+ * (specified by {@link AnalyzerConfig#TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG}).\n+ */\n+public class MinTopicLeadersPerBrokerGoal extends AbstractGoal {\n+  private static final Logger LOG = LoggerFactory.getLogger(MinTopicLeadersPerBrokerGoal.class);\n+  private final String _replicaSortName = replicaSortName(this, true, false);\n+  private Set<String> _mustHaveTopicLeadersPerBroker;\n+\n+  public MinTopicLeadersPerBrokerGoal() {\n+\n+  }\n+\n+  /**\n+   * Package private for unit test.\n+   */\n+  MinTopicLeadersPerBrokerGoal(BalancingConstraint constraint) {\n+    _balancingConstraint = constraint;\n+  }\n+\n+  @Override\n+  public ClusterModelStatsComparator clusterModelStatsComparator() {\n+    return new GoalUtils.HardGoalStatsComparator();\n+  }\n+\n+  @Override\n+  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {\n+    return new ModelCompletenessRequirements(GoalUtils.MIN_NUM_VALID_WINDOWS_FOR_SELF_HEALING, 0.0, true);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return MinTopicLeadersPerBrokerGoal.class.getSimpleName();\n+  }\n+\n+  @Override\n+  public boolean isHardGoal() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check whether given action is acceptable by this goal. An action is acceptable by a goal if it satisfies\n+   * requirements of the goal. Requirements(hard goal): A configured set of topics that should have at least a minimum number\n+   * of leader replicas on each alive broker that is not excluded for replica leadership moves\n+   *\n+   * @param action Action to be checked for acceptance.\n+   * @param clusterModel The state of the cluster.\n+   * @return {@link ActionAcceptance#ACCEPT} if the action is acceptable by this goal,\n+   *         {@link ActionAcceptance#REPLICA_REJECT} otherwise.\n+   */\n+  @Override\n+  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n+    if (!actionAffectsRelevantTopics(action)) {\n+      return ACCEPT;\n+    }\n+    switch (action.balancingAction()) {\n+      case LEADERSHIP_MOVEMENT:\n+      case INTER_BROKER_REPLICA_MOVEMENT:\n+        Replica replicaToBeRemoved = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        return doesLeaderRemoveViolateOptimizedGoal(replicaToBeRemoved) ? REPLICA_REJECT : ACCEPT;\n+      case INTER_BROKER_REPLICA_SWAP:\n+        Replica srcReplicaToSwap = clusterModel.broker(action.sourceBrokerId()).replica(action.topicPartition());\n+        Replica dstReplicaToSwap = clusterModel.broker(action.destinationBrokerId()).replica(action.destinationTopicPartition());\n+        return acceptReplicaSwap(srcReplicaToSwap, dstReplicaToSwap);\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported balancing action \" + action.balancingAction() + \" is provided.\");\n+    }\n+  }\n+\n+  private ActionAcceptance acceptReplicaSwap(Replica srcReplicaToSwap, Replica dstReplicaToSwap) {\n+    if (!srcReplicaToSwap.isLeader() && !dstReplicaToSwap.isLeader()) {\n+      // Swapping two follower replicas is always accepted\n+      return ACCEPT;\n+    }\n+    String srcTopicName = srcReplicaToSwap.topicPartition().topic();\n+    String dstTopicName = dstReplicaToSwap.topicPartition().topic();\n+    if (srcReplicaToSwap.isLeader() && dstReplicaToSwap.isLeader() && Objects.equals(srcTopicName, dstTopicName)) {\n+      // Swapping two leader replicas of the same topic is always accepted\n+      return ACCEPT;\n+    }\n+    if (doesLeaderRemoveViolateOptimizedGoal(srcReplicaToSwap) || doesLeaderRemoveViolateOptimizedGoal(dstReplicaToSwap)) {\n+      return REPLICA_REJECT;\n+    }\n+    return ACCEPT;\n+  }\n+\n+  /**\n+   * Check whether this goal is violated after removing the given leader replica. It is violated if there is not be enough\n+   * leader replicas on that broker for that topic\n+   *\n+   * @param replicaToBeRemoved replica to be removed\n+   * @return {@code true} if the given replica move would violate the optimized goal (i.e. the move is not acceptable),\n+   * {@code false} otherwise.\n+   */\n+  private boolean doesLeaderRemoveViolateOptimizedGoal(Replica replicaToBeRemoved) {\n+    if (!replicaToBeRemoved.isLeader()) {\n+      // Moving a follower replica does not violate/affect this goal\n+      return false;\n+    }\n+    int topicLeaderCountOnSourceBroker = replicaToBeRemoved.broker().numLeadersFor(replicaToBeRemoved.topicPartition().topic());\n+    return topicLeaderCountOnSourceBroker <= minTopicLeadersPerBroker();\n+  }\n+\n+  /**\n+   * This is a hard goal; hence, the proposals are not limited to dead broker replicas in case of self-healing.\n+   * Sanity Check: The total number of leader replicas of certain topics is sufficient so that these leader replicas\n+   * can be moved to satisfy this goal.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    _mustHaveTopicLeadersPerBroker = Collections.unmodifiableSet(\n+        Utils.getTopicNamesMatchedWithPattern(_balancingConstraint.topicsWithMinLeadersPerBrokerPattern(), clusterModel::topics));\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return;\n+    }\n+    // Sanity checks\n+    validateTopicsWithMinLeaderIsNotExcluded(optimizationOptions);\n+    validateEnoughLeaderToDistribute(clusterModel, optimizationOptions);\n+    validateBrokersAllowedReplicaMoveExist(clusterModel, optimizationOptions);\n+    boolean onlyMoveImmigrantReplicas = optimizationOptions.onlyMoveImmigrantReplicas();\n+    new SortedReplicasHelper().maybeAddSelectionFunc(ReplicaSortFunctionFactory.selectImmigrants(), onlyMoveImmigrantReplicas)\n+                              .addSelectionFunc(ReplicaSortFunctionFactory.selectReplicasBasedOnIncludedTopics(_mustHaveTopicLeadersPerBroker))\n+                              .maybeAddPriorityFunc(ReplicaSortFunctionFactory.prioritizeImmigrants(), !onlyMoveImmigrantReplicas)\n+                              .trackSortedReplicasFor(_replicaSortName, clusterModel);\n+  }\n+\n+  private int minTopicLeadersPerBroker() {\n+    return _balancingConstraint.minTopicLeadersPerBroker();\n+  }\n+\n+  private void validateTopicsWithMinLeaderIsNotExcluded(OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (optimizationOptions.excludedTopics().isEmpty()) {\n+      return;\n+    }\n+    Set<String> shouldNotBeExcludedTopics = new HashSet<>();\n+    _mustHaveTopicLeadersPerBroker.forEach(topicName -> {\n+      if (optimizationOptions.excludedTopics().contains(topicName)) {\n+        shouldNotBeExcludedTopics.add(topicName);\n+      }\n+    });\n+    if (!shouldNotBeExcludedTopics.isEmpty()) {\n+      throw new OptimizationFailureException(String.format(\"Topics that must have a minimum number of leader replicas \"\n+          + \"per alive broker that is not excluded for leadership moves should not be excluded. This error implies \"\n+          + \"a config error. Topics should not be excluded=[%s] and it is defined as a regex by the config property: %s\",\n+                                                           String.join(\", \", shouldNotBeExcludedTopics),\n+                                                           AnalyzerConfig.TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG));\n+    }\n+  }\n+\n+  private void validateEnoughLeaderToDistribute(ClusterModel clusterModel,\n+                                                OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Map<String, Integer> numLeadersByTopicNames = clusterModel.numLeadersPerTopic(_mustHaveTopicLeadersPerBroker);\n+    Set<Broker> eligibleBrokersForLeadership = eligibleBrokersForLeadership(clusterModel, optimizationOptions);\n+    int totalMinimumLeaderCount = eligibleBrokersForLeadership.size() * minTopicLeadersPerBroker();\n+\n+    for (Map.Entry<String, Integer> numLeadersPerTopic : numLeadersByTopicNames.entrySet()) {\n+      if (numLeadersPerTopic.getValue() < totalMinimumLeaderCount) {\n+        throw new OptimizationFailureException(\n+            String.format(\"Cannot distribute %d leader replica(s) over %d broker(s) with total minimum required leader count %d for topic %s.\",\n+                          numLeadersPerTopic.getValue(), eligibleBrokersForLeadership.size(),\n+                          minTopicLeadersPerBroker(), numLeadersPerTopic.getKey()));\n+      }\n+    }\n+  }\n+\n+  private static void validateBrokersAllowedReplicaMoveExist(ClusterModel clusterModel,\n+                                                             OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    Set<Integer> brokersAllowedReplicaMove = GoalUtils.aliveBrokersNotExcludedForReplicaMove(clusterModel, optimizationOptions);\n+    if (brokersAllowedReplicaMove.isEmpty()) {\n+      // Handle the case when all alive brokers are excluded from replica moves.\n+      throw new OptimizationFailureException(\"Cannot take any action as all alive brokers are excluded from replica moves.\");\n+    }\n+  }\n+\n+  /**\n+   * Check if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   *\n+   * @param clusterModel The state of the cluster.\n+   * @param action Action containing information about potential modification to the given cluster model.\n+   * @return True if requirements of this goal are not violated if this action is applied to the given cluster state,\n+   * false otherwise.\n+   */\n+  @Override\n+  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {\n+    Broker sourceBroker = clusterModel.broker(action.sourceBrokerId());\n+    Replica replicaToBeMoved = sourceBroker.replica(action.topicPartition());\n+\n+    if (replicaToBeMoved.broker().replica(action.topicPartition()).isCurrentOffline()) {\n+      return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_MOVEMENT;\n+    }\n+    // Moving leader replica from more abundant broker is considered as self-satisfied\n+    return sourceBroker.numLeadersFor(replicaToBeMoved.topicPartition().topic()) > minTopicLeadersPerBroker();\n+  }\n+\n+  private boolean actionAffectsRelevantTopics(BalancingAction action) {\n+    if (_mustHaveTopicLeadersPerBroker.contains(action.topic())) {\n+      return true;\n+    }\n+    return action.balancingAction() == ActionType.INTER_BROKER_REPLICA_SWAP &&\n+           _mustHaveTopicLeadersPerBroker.contains(action.destinationTopic());\n+  }\n+\n+  /**\n+   * Update goal state after one round of self-healing / rebalance.\n+   *\n+   *  @param clusterModel The state of the cluster.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void updateGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    // Sanity check: No self-healing eligible replica should remain at a dead broker/disk.\n+    GoalUtils.ensureNoOfflineReplicas(clusterModel, name());\n+    // Sanity check: No replica should be moved to a broker, which used to host any replica of the same partition on its broken disk.\n+    GoalUtils.ensureReplicasMoveOffBrokersWithBadDisks(clusterModel, name());\n+    ensureBrokersAllHaveEnoughLeaderOfTopics(clusterModel, optimizationOptions);\n+    finish();\n+  }\n+\n+  private void ensureBrokersAllHaveEnoughLeaderOfTopics(ClusterModel clusterModel, OptimizationOptions optimizationOptions)\n+      throws OptimizationFailureException {\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    for (Broker broker : clusterModel.aliveBrokers()) {\n+      if (!isEligibleToHaveLeaders(broker, optimizationOptions)) {\n+        continue;\n+      }\n+      for (String mustHaveLeaderPerBrokerTopicName : _mustHaveTopicLeadersPerBroker) {\n+        int leaderCount = broker.numLeadersFor(mustHaveLeaderPerBrokerTopicName);\n+        if (leaderCount < minTopicLeadersPerBroker()) {\n+          throw new OptimizationFailureException(String.format(\"Broker %d does not have enough leader replica for topic %s. \"\n+              + \"Minimum required per-broker leader replica count %d. Actual broker leader replica count %d\",\n+              broker.id(), mustHaveLeaderPerBrokerTopicName, minTopicLeadersPerBroker(), leaderCount));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rebalance the given broker without violating the constraints of the current goal and optimized goals.\n+   * @param broker         Broker to be balanced.\n+   * @param clusterModel   The state of the cluster.\n+   * @param optimizedGoals Optimized goals.\n+   * @param optimizationOptions Options to take into account during optimization.\n+   */\n+  @Override\n+  protected void rebalanceForBroker(Broker broker,\n+                                    ClusterModel clusterModel,\n+                                    Set<Goal> optimizedGoals,\n+                                    OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    LOG.debug(\"balancing broker {}, optimized goals = {}\", broker, optimizedGoals);\n+    moveAwayOfflineReplicas(broker, clusterModel, optimizedGoals, optimizationOptions);\n+    if (_mustHaveTopicLeadersPerBroker.isEmpty()) {\n+      return; // Early termination to avoid some unnecessary computation\n+    }\n+    if (!(broker.isAlive() && isEligibleToHaveLeaders(broker, optimizationOptions))) {\n+      return;\n+    }\n+    for (String topicMustHaveLeaderPerBroker : _mustHaveTopicLeadersPerBroker) {\n+      maybeMoveLeaderOfTopicToBroker(topicMustHaveLeaderPerBroker, broker, clusterModel, optimizedGoals, optimizationOptions);\n+    }\n+  }\n+\n+  private void maybeMoveLeaderOfTopicToBroker(String topicMustHaveLeaderPerBroker,\n+                                              Broker broker,\n+                                              ClusterModel clusterModel,\n+                                              Set<Goal> optimizedGoals,\n+                                              OptimizationOptions optimizationOptions) throws OptimizationFailureException {\n+    int topicLeaderCountOnReceiverBroker = broker.numLeadersFor(topicMustHaveLeaderPerBroker);\n+    if (topicLeaderCountOnReceiverBroker >= minTopicLeadersPerBroker()) {\n+      return; // This broker has enough leader replica(s) for the given topic\n+    }\n+    // Try to elect follower replica(s) of the interested topic on this broker to be leader\n+    List<Replica> followerReplicas = broker.trackedSortedReplicas(_replicaSortName)\n+                                          .sortedReplicas(false).stream().filter(\n+                                              replica -> !replica.isLeader()\n+                                                         && replica.topicPartition().topic().equals(topicMustHaveLeaderPerBroker))\n+                                          .collect(Collectors.toList());\n+\n+    for (Replica followerReplica : followerReplicas) {\n+      Replica leader = clusterModel.partition(followerReplica.topicPartition()).leader();\n+      if (leader.broker().numLeadersFor(topicMustHaveLeaderPerBroker) > minTopicLeadersPerBroker()) {\n+        if (maybeApplyBalancingAction(clusterModel, leader, Collections.singleton(broker),\n+                                      LEADERSHIP_MOVEMENT, optimizedGoals, optimizationOptions) != null) {\n+          topicLeaderCountOnReceiverBroker++;\n+          if (topicLeaderCountOnReceiverBroker >= minTopicLeadersPerBroker()) {\n+            return; // This broker satisfies this goal for the given topic\n+          }\n+        }\n+      }\n+    }\n+\n+    // Try to move leader replica(s) of the interested topic from other brokers to this broker\n+    PriorityQueue<Broker> brokersWithExcessiveLeaderToMove =\n+        getBrokersWithExcessiveLeaderToMove(topicMustHaveLeaderPerBroker, clusterModel, broker);\n+\n+    while (!brokersWithExcessiveLeaderToMove.isEmpty()) {\n+      Broker brokerWithExcessiveLeaderToMove = brokersWithExcessiveLeaderToMove.poll();\n+      List<Replica> leadersOfTopic = brokerWithExcessiveLeaderToMove.trackedSortedReplicas(_replicaSortName)\n+                                                                                  .sortedReplicas(false).stream()\n+                                                                                  .filter(replica ->\n+                                                                                              replica.isLeader()\n+                                                                                              && replica.topicPartition()\n+                                                                                                        .topic()\n+                                                                                                        .equals(topicMustHaveLeaderPerBroker))\n+                                                                                  .collect(Collectors.toList());\n+      boolean leaderMoved = false;\n+      int topicLeaderCountOnGiverBroker = leadersOfTopic.size();\n+      for (Replica leaderOfTopic : leadersOfTopic) {\n+        Broker destinationBroker = maybeApplyBalancingAction(clusterModel, leaderOfTopic, Collections.singleton(broker),\n+                                                             INTER_BROKER_REPLICA_MOVEMENT, optimizedGoals, optimizationOptions);\n+        if (destinationBroker != null) {\n+          leaderMoved = true;\n+          break; // Successfully move one leader replica\n+        }\n+      }\n+      if (leaderMoved) {\n+        topicLeaderCountOnReceiverBroker++;\n+        if (topicLeaderCountOnReceiverBroker >= minTopicLeadersPerBroker()) {\n+          return; // This broker satisfies this goal for the given topic\n+        }\n+        topicLeaderCountOnGiverBroker--;\n+        if (topicLeaderCountOnGiverBroker > minTopicLeadersPerBroker()) {\n+          // Still have excessive topic leader to give\n+          brokersWithExcessiveLeaderToMove.add(brokerWithExcessiveLeaderToMove);\n+        }\n+      }\n+    }\n+    throw new OptimizationFailureException(String.format(\"Cannot make broker %d have at least %d leader replica(s) of topic %s.\",", "originalCommit": "6940f1d0140f831c3ed44225ebecad796e7cb716", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA4OTAwNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569089005", "bodyText": "Can we make sure that Configurations.md has the same documentation as the ones listed here for these two new configs.\nCurrently they are inconsistent.", "author": "efeg", "createdAt": "2021-02-03T02:31:49Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnalyzerConfig.java", "diffHunk": "@@ -334,6 +338,22 @@ private AnalyzerConfig() {\n   public static final String ALLOW_CAPACITY_ESTIMATION_ON_PROPOSAL_PRECOMPUTE_DOC = \"The flag to indicate whether to \"\n       + \"allow capacity estimation on proposal precomputation.\";\n \n+  /**\n+   * <code>topics.with.min.leaders.per.broker</code>\n+   */\n+  public static final String TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG = \"topics.with.min.leaders.per.broker\";\n+  public static final String DEFAULT_TOPICS_WITH_MIN_LEADERS_PER_BROKER = \"\";\n+  public static final String DEFAULT_TOPICS_WITH_MIN_LEADERS_PER_BROKER_DOC = \"The topics that should have a minimum \"\n+      + \"number of replica on brokers that are not excluded for replica move. It is a regex.\";\n+\n+  /**\n+   * <code>min.topic.leaders.per.broker</code>\n+   */\n+  public static final String MIN_TOPIC_LEADERS_PER_BROKER_CONFIG = \"min.topic.leaders.per.broker\";\n+  public static final int DEFAULT_MIN_TOPIC_LEADERS_PER_BROKER = 1;\n+  public static final String MIN_TOPIC_LEADERS_PER_BROKER_DOC = \"The minimum required number of leader per broker\"\n+      + \" for topics that must have leader on brokers that are not excluded for replica move.\";\n+", "originalCommit": "6940f1d0140f831c3ed44225ebecad796e7cb716", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "590147e22f5860dbd54411d4f349b81792e1df5e", "url": "https://github.com/linkedin/cruise-control/commit/590147e22f5860dbd54411d4f349b81792e1df5e", "message": "Fix issues", "committedDate": "2021-02-03T02:41:00Z", "type": "commit"}, {"oid": "e853171ea670e2dc32e285c836e1035741986018", "url": "https://github.com/linkedin/cruise-control/commit/e853171ea670e2dc32e285c836e1035741986018", "message": "Fix test ID", "committedDate": "2021-02-03T02:43:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA5NDM3OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569094379", "bodyText": "Here and in configurations.md number of leader -> number of leaders", "author": "efeg", "createdAt": "2021-02-03T02:47:53Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnalyzerConfig.java", "diffHunk": "@@ -334,6 +338,22 @@ private AnalyzerConfig() {\n   public static final String ALLOW_CAPACITY_ESTIMATION_ON_PROPOSAL_PRECOMPUTE_DOC = \"The flag to indicate whether to \"\n       + \"allow capacity estimation on proposal precomputation.\";\n \n+  /**\n+   * <code>topics.with.min.leaders.per.broker</code>\n+   */\n+  public static final String TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG = \"topics.with.min.leaders.per.broker\";\n+  public static final String DEFAULT_TOPICS_WITH_MIN_LEADERS_PER_BROKER = \"\";\n+  public static final String DEFAULT_TOPICS_WITH_MIN_LEADERS_PER_BROKER_DOC = \"The topics that should have a minimum \"\n+      + \"number of leader on brokers that are not excluded for replica move. It is a regex.\";\n+\n+  /**\n+   * <code>min.topic.leaders.per.broker</code>\n+   */\n+  public static final String MIN_TOPIC_LEADERS_PER_BROKER_CONFIG = \"min.topic.leaders.per.broker\";\n+  public static final int DEFAULT_MIN_TOPIC_LEADERS_PER_BROKER = 1;\n+  public static final String MIN_TOPIC_LEADERS_PER_BROKER_DOC = \"The minimum required number of leader per broker\"", "originalCommit": "e853171ea670e2dc32e285c836e1035741986018", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA5NDQxOA==", "url": "https://github.com/linkedin/cruise-control/pull/1429#discussion_r569094418", "bodyText": "Here and in configurations.md number of leader -> number of leaders", "author": "efeg", "createdAt": "2021-02-03T02:48:00Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnalyzerConfig.java", "diffHunk": "@@ -334,6 +338,22 @@ private AnalyzerConfig() {\n   public static final String ALLOW_CAPACITY_ESTIMATION_ON_PROPOSAL_PRECOMPUTE_DOC = \"The flag to indicate whether to \"\n       + \"allow capacity estimation on proposal precomputation.\";\n \n+  /**\n+   * <code>topics.with.min.leaders.per.broker</code>\n+   */\n+  public static final String TOPICS_WITH_MIN_LEADERS_PER_BROKER_CONFIG = \"topics.with.min.leaders.per.broker\";\n+  public static final String DEFAULT_TOPICS_WITH_MIN_LEADERS_PER_BROKER = \"\";\n+  public static final String DEFAULT_TOPICS_WITH_MIN_LEADERS_PER_BROKER_DOC = \"The topics that should have a minimum \"\n+      + \"number of leader on brokers that are not excluded for replica move. It is a regex.\";", "originalCommit": "e853171ea670e2dc32e285c836e1035741986018", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f5b5543d8834cb32ee8dab3806860515573ba217", "url": "https://github.com/linkedin/cruise-control/commit/f5b5543d8834cb32ee8dab3806860515573ba217", "message": "Fix doc", "committedDate": "2021-02-03T02:57:07Z", "type": "commit"}]}