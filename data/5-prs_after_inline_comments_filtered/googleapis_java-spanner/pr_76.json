{"pr_number": 76, "pr_title": "refactor: move connection api to Spanner client lib", "pr_createdAt": "2020-02-14T13:55:30Z", "pr_url": "https://github.com/googleapis/java-spanner/pull/76", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY3MjgyOA==", "url": "https://github.com/googleapis/java-spanner/pull/76#discussion_r379672828", "bodyText": "Same comment as above -- AbortedDueToConcurrentModificationException too tied to JDBC.", "author": "elefeint", "createdAt": "2020-02-14T22:26:39Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/connection/TransactionRetryListener.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2019 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner.connection;\n+\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.AbortedException;\n+\n+/**\n+ * Cloud Spanner can abort any read/write transaction because of potential deadlocks or other\n+ * internal reasons. When a transaction is aborted, the entire transaction should be retried. A\n+ * {@link Connection} can automatically retry a transaction internally and check whether the results\n+ * that are returned during a retry attempt are equal to the results during the original\n+ * transaction. This is done by keeping track of a SHA-256 checksum of all the results that are\n+ * returned by Spanner during both transactions.\n+ *\n+ * <p>This listener class for internal transaction retries allow client applications to do\n+ * additional testing or logging of transaction retries. Transaction retry listeners of a {@link\n+ * Connection} can be added using {@link\n+ * Connection#addTransactionRetryListener(TransactionRetryListener)}.\n+ */\n+public interface TransactionRetryListener {\n+  /** The result of a retry. */\n+  public enum RetryResult {\n+    /** The retry executed successfully and the transaction will continue. */\n+    RETRY_SUCCESSFUL,\n+    /** The retry was aborted by Spanner and another retry attempt will be started. */\n+    RETRY_ABORTED_AND_RESTARTING,\n+    /**\n+     * The retry was aborted by the {@link Connection} because of a concurrent modification. The\n+     * transaction cannot continue and will throw an {@link\n+     * AbortedDueToConcurrentModificationException}.", "originalCommit": "e873e7b938b9a2900bb2a9634b9f85b1844455da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTc3OTA2MQ==", "url": "https://github.com/googleapis/java-spanner/pull/76#discussion_r379779061", "bodyText": "The text in the comment was not entirely correct. The exception is thrown by the connection API and then re-thrown by the JDBC driver as a com.google.cloud.spanner.jdbc.JdbcAbortedDueToConcurrentModificationException. I've updated the text and removed all references to JDBC.", "author": "olavloite", "createdAt": "2020-02-15T07:15:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY3MjgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY3MzkwMQ==", "url": "https://github.com/googleapis/java-spanner/pull/76#discussion_r379673901", "bodyText": "The exception hierarchy is Jdbc-specific. It's just mentioned in a comment (and pre-rename -- it's JdbcAbortedDueToConcurrentModificationException now), so it's not very important, but it might be better to avoid mentioning a JDBC-specific exception in Connection API.", "author": "elefeint", "createdAt": "2020-02-14T22:29:52Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/connection/Connection.java", "diffHunk": "@@ -0,0 +1,718 @@\n+/*\n+ * Copyright 2019 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner.connection;\n+\n+import com.google.api.core.InternalApi;\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.AbortedException;\n+import com.google.cloud.spanner.ErrorCode;\n+import com.google.cloud.spanner.Mutation;\n+import com.google.cloud.spanner.Options.QueryOption;\n+import com.google.cloud.spanner.ReadContext.QueryAnalyzeMode;\n+import com.google.cloud.spanner.ResultSet;\n+import com.google.cloud.spanner.SpannerBatchUpdateException;\n+import com.google.cloud.spanner.SpannerException;\n+import com.google.cloud.spanner.Statement;\n+import com.google.cloud.spanner.TimestampBound;\n+import com.google.cloud.spanner.connection.StatementResult.ResultType;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A connection to a Cloud Spanner database. Connections are not designed to be thread-safe. The\n+ * only exception is the {@link Connection#cancel()} method that may be called by any other thread\n+ * to stop the execution of the current statement on the connection.\n+ *\n+ * <p>Connections accept a number of additional SQL statements for setting or changing the state of\n+ * a {@link Connection}. These statements can only be executed using the {@link\n+ * Connection#execute(Statement)} method:\n+ *\n+ * <ul>\n+ *   <li><code>SHOW AUTOCOMMIT</code>: Returns the current value of <code>AUTOCOMMIT</code> of this\n+ *       connection as a {@link ResultSet}\n+ *   <li><code>SET AUTOCOMMIT=TRUE|FALSE</code>: Sets the value of <code>AUTOCOMMIT</code> for this\n+ *       connection\n+ *   <li><code>SHOW READONLY</code>: Returns the current value of <code>READONLY</code> of this\n+ *       connection as a {@link ResultSet}\n+ *   <li><code>SET READONLY=TRUE|FALSE</code>: Sets the value of <code>READONLY</code> for this\n+ *       connection\n+ *   <li><code>SHOW RETRY_ABORTS_INTERNALLY</code>: Returns the current value of <code>\n+ *       RETRY_ABORTS_INTERNALLY</code> of this connection as a {@link ResultSet}\n+ *   <li><code>SET RETRY_ABORTS_INTERNALLY=TRUE|FALSE</code>: Sets the value of <code>\n+ *       RETRY_ABORTS_INTERNALLY</code> for this connection\n+ *   <li><code>SHOW AUTOCOMMIT_DML_MODE</code>: Returns the current value of <code>\n+ *       AUTOCOMMIT_DML_MODE</code> of this connection as a {@link ResultSet}\n+ *   <li><code>SET AUTOCOMMIT_DML_MODE='TRANSACTIONAL' | 'PARTITIONED_NON_ATOMIC'</code>: Sets the\n+ *       value of <code>AUTOCOMMIT_DML_MODE</code> for this connection\n+ *   <li><code>SHOW STATEMENT_TIMEOUT</code>: Returns the current value of <code>STATEMENT_TIMEOUT\n+ *       </code> of this connection as a {@link ResultSet}\n+ *   <li><code>SET STATEMENT_TIMEOUT='&lt;int64&gt;s|ms|us|ns' | NULL</code>: Sets the value of\n+ *       <code>STATEMENT_TIMEOUT</code> for this connection. The supported {@link TimeUnit}s are:\n+ *       <ul>\n+ *         <li>s - Seconds\n+ *         <li>ms - Milliseconds\n+ *         <li>us - Microseconds\n+ *         <li>ns - Nanoseconds\n+ *       </ul>\n+ *       Setting the STATEMENT_TIMEOUT to NULL will clear the value for the STATEMENT_TIMEOUT on the\n+ *       connection.\n+ *   <li><code>SHOW READ_TIMESTAMP</code>: Returns the last <code>READ_TIMESTAMP</code> of this\n+ *       connection as a {@link ResultSet}\n+ *   <li><code>SHOW COMMIT_TIMESTAMP</code>: Returns the last <code>COMMIT_TIMESTAMP</code> of this\n+ *       connection as a {@link ResultSet}\n+ *   <li><code>SHOW READ_ONLY_STALENESS</code>: Returns the current value of <code>\n+ *       READ_ONLY_STALENESS</code> of this connection as a {@link ResultSet}\n+ *   <li><code>\n+ *       SET READ_ONLY_STALENESS='STRONG' | 'MIN_READ_TIMESTAMP &lt;timestamp&gt;' | 'READ_TIMESTAMP &lt;timestamp&gt;' | 'MAX_STALENESS &lt;int64&gt;s|ms|mus|ns' | 'EXACT_STALENESS (&lt;int64&gt;s|ms|mus|ns)'\n+ *       </code>: Sets the value of <code>READ_ONLY_STALENESS</code> for this connection.\n+ *   <li><code>BEGIN [TRANSACTION]</code>: Begins a new transaction. This statement is optional when\n+ *       the connection is not in autocommit mode, as a new transaction will automatically be\n+ *       started when a query or update statement is issued. In autocommit mode, this statement will\n+ *       temporarily put the connection in transactional mode, and return the connection to\n+ *       autocommit mode when <code>COMMIT [TRANSACTION]</code> or <code>ROLLBACK [TRANSACTION]\n+ *       </code> is executed\n+ *   <li><code>COMMIT [TRANSACTION]</code>: Commits the current transaction\n+ *   <li><code>ROLLBACK [TRANSACTION]</code>: Rollbacks the current transaction\n+ *   <li><code>SET TRANSACTION READ ONLY|READ WRITE</code>: Sets the type for the current\n+ *       transaction. May only be executed before a transaction is actually running (i.e. before any\n+ *       statements have been executed in the transaction)\n+ *   <li><code>START BATCH DDL</code>: Starts a batch of DDL statements. May only be executed when\n+ *       no transaction has been started and the connection is in read/write mode. The connection\n+ *       will only accept DDL statements while a DDL batch is active.\n+ *   <li><code>START BATCH DML</code>: Starts a batch of DML statements. May only be executed when\n+ *       the connection is in read/write mode. The connection will only accept DML statements while\n+ *       a DML batch is active.\n+ *   <li><code>RUN BATCH</code>: Ends the current batch, sends the batched DML or DDL statements to\n+ *       Spanner and blocks until all statements have been executed or an error occurs. May only be\n+ *       executed when a (possibly empty) batch is active. The statement will return the update\n+ *       counts of the batched statements as {@link ResultSet} with an ARRAY&lt;INT64&gt; column. In\n+ *       case of a DDL batch, this array will always be empty.\n+ *   <li><code>ABORT BATCH</code>: Ends the current batch and removes any DML or DDL statements from\n+ *       the buffer without sending any statements to Spanner. May only be executed when a (possibly\n+ *       empty) batch is active.\n+ * </ul>\n+ *\n+ * Note that Cloud Spanner could abort read/write transactions in the background, and that\n+ * <strong>any</strong> database call during a read/write transaction could fail with an {@link\n+ * AbortedException}. This also includes calls to {@link ResultSet#next()}.\n+ *\n+ * <p>If {@link Connection#isRetryAbortsInternally()} is <code>true</code>, then the connection will\n+ * silently handle any {@link AbortedException}s by internally re-acquiring all transactional locks\n+ * and verifying (via the use of cryptographic checksums) that no underlying data has changed. If a\n+ * change to the underlying data is detected, then an {@link\n+ * AbortedDueToConcurrentModificationException} error will be thrown. If your application already", "originalCommit": "e873e7b938b9a2900bb2a9634b9f85b1844455da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTc3OTk2MA==", "url": "https://github.com/googleapis/java-spanner/pull/76#discussion_r379779960", "bodyText": "I've updated this comment as well. Handling aborted transactions is done by the connection API, and the JDBC driver is just re-throwing these exceptions in a JDBC-specific class.", "author": "olavloite", "createdAt": "2020-02-15T07:17:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY3MzkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY3NDUxMA==", "url": "https://github.com/googleapis/java-spanner/pull/76#discussion_r379674510", "bodyText": "Same comment as above -- AbortedDueToConcurrentModificationException too tied to JDBC.", "author": "elefeint", "createdAt": "2020-02-14T22:32:00Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/connection/Connection.java", "diffHunk": "@@ -0,0 +1,718 @@\n+/*\n+ * Copyright 2019 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner.connection;\n+\n+import com.google.api.core.InternalApi;\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.AbortedException;\n+import com.google.cloud.spanner.ErrorCode;\n+import com.google.cloud.spanner.Mutation;\n+import com.google.cloud.spanner.Options.QueryOption;\n+import com.google.cloud.spanner.ReadContext.QueryAnalyzeMode;\n+import com.google.cloud.spanner.ResultSet;\n+import com.google.cloud.spanner.SpannerBatchUpdateException;\n+import com.google.cloud.spanner.SpannerException;\n+import com.google.cloud.spanner.Statement;\n+import com.google.cloud.spanner.TimestampBound;\n+import com.google.cloud.spanner.connection.StatementResult.ResultType;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A connection to a Cloud Spanner database. Connections are not designed to be thread-safe. The\n+ * only exception is the {@link Connection#cancel()} method that may be called by any other thread\n+ * to stop the execution of the current statement on the connection.\n+ *\n+ * <p>Connections accept a number of additional SQL statements for setting or changing the state of\n+ * a {@link Connection}. These statements can only be executed using the {@link\n+ * Connection#execute(Statement)} method:\n+ *\n+ * <ul>\n+ *   <li><code>SHOW AUTOCOMMIT</code>: Returns the current value of <code>AUTOCOMMIT</code> of this\n+ *       connection as a {@link ResultSet}\n+ *   <li><code>SET AUTOCOMMIT=TRUE|FALSE</code>: Sets the value of <code>AUTOCOMMIT</code> for this\n+ *       connection\n+ *   <li><code>SHOW READONLY</code>: Returns the current value of <code>READONLY</code> of this\n+ *       connection as a {@link ResultSet}\n+ *   <li><code>SET READONLY=TRUE|FALSE</code>: Sets the value of <code>READONLY</code> for this\n+ *       connection\n+ *   <li><code>SHOW RETRY_ABORTS_INTERNALLY</code>: Returns the current value of <code>\n+ *       RETRY_ABORTS_INTERNALLY</code> of this connection as a {@link ResultSet}\n+ *   <li><code>SET RETRY_ABORTS_INTERNALLY=TRUE|FALSE</code>: Sets the value of <code>\n+ *       RETRY_ABORTS_INTERNALLY</code> for this connection\n+ *   <li><code>SHOW AUTOCOMMIT_DML_MODE</code>: Returns the current value of <code>\n+ *       AUTOCOMMIT_DML_MODE</code> of this connection as a {@link ResultSet}\n+ *   <li><code>SET AUTOCOMMIT_DML_MODE='TRANSACTIONAL' | 'PARTITIONED_NON_ATOMIC'</code>: Sets the\n+ *       value of <code>AUTOCOMMIT_DML_MODE</code> for this connection\n+ *   <li><code>SHOW STATEMENT_TIMEOUT</code>: Returns the current value of <code>STATEMENT_TIMEOUT\n+ *       </code> of this connection as a {@link ResultSet}\n+ *   <li><code>SET STATEMENT_TIMEOUT='&lt;int64&gt;s|ms|us|ns' | NULL</code>: Sets the value of\n+ *       <code>STATEMENT_TIMEOUT</code> for this connection. The supported {@link TimeUnit}s are:\n+ *       <ul>\n+ *         <li>s - Seconds\n+ *         <li>ms - Milliseconds\n+ *         <li>us - Microseconds\n+ *         <li>ns - Nanoseconds\n+ *       </ul>\n+ *       Setting the STATEMENT_TIMEOUT to NULL will clear the value for the STATEMENT_TIMEOUT on the\n+ *       connection.\n+ *   <li><code>SHOW READ_TIMESTAMP</code>: Returns the last <code>READ_TIMESTAMP</code> of this\n+ *       connection as a {@link ResultSet}\n+ *   <li><code>SHOW COMMIT_TIMESTAMP</code>: Returns the last <code>COMMIT_TIMESTAMP</code> of this\n+ *       connection as a {@link ResultSet}\n+ *   <li><code>SHOW READ_ONLY_STALENESS</code>: Returns the current value of <code>\n+ *       READ_ONLY_STALENESS</code> of this connection as a {@link ResultSet}\n+ *   <li><code>\n+ *       SET READ_ONLY_STALENESS='STRONG' | 'MIN_READ_TIMESTAMP &lt;timestamp&gt;' | 'READ_TIMESTAMP &lt;timestamp&gt;' | 'MAX_STALENESS &lt;int64&gt;s|ms|mus|ns' | 'EXACT_STALENESS (&lt;int64&gt;s|ms|mus|ns)'\n+ *       </code>: Sets the value of <code>READ_ONLY_STALENESS</code> for this connection.\n+ *   <li><code>BEGIN [TRANSACTION]</code>: Begins a new transaction. This statement is optional when\n+ *       the connection is not in autocommit mode, as a new transaction will automatically be\n+ *       started when a query or update statement is issued. In autocommit mode, this statement will\n+ *       temporarily put the connection in transactional mode, and return the connection to\n+ *       autocommit mode when <code>COMMIT [TRANSACTION]</code> or <code>ROLLBACK [TRANSACTION]\n+ *       </code> is executed\n+ *   <li><code>COMMIT [TRANSACTION]</code>: Commits the current transaction\n+ *   <li><code>ROLLBACK [TRANSACTION]</code>: Rollbacks the current transaction\n+ *   <li><code>SET TRANSACTION READ ONLY|READ WRITE</code>: Sets the type for the current\n+ *       transaction. May only be executed before a transaction is actually running (i.e. before any\n+ *       statements have been executed in the transaction)\n+ *   <li><code>START BATCH DDL</code>: Starts a batch of DDL statements. May only be executed when\n+ *       no transaction has been started and the connection is in read/write mode. The connection\n+ *       will only accept DDL statements while a DDL batch is active.\n+ *   <li><code>START BATCH DML</code>: Starts a batch of DML statements. May only be executed when\n+ *       the connection is in read/write mode. The connection will only accept DML statements while\n+ *       a DML batch is active.\n+ *   <li><code>RUN BATCH</code>: Ends the current batch, sends the batched DML or DDL statements to\n+ *       Spanner and blocks until all statements have been executed or an error occurs. May only be\n+ *       executed when a (possibly empty) batch is active. The statement will return the update\n+ *       counts of the batched statements as {@link ResultSet} with an ARRAY&lt;INT64&gt; column. In\n+ *       case of a DDL batch, this array will always be empty.\n+ *   <li><code>ABORT BATCH</code>: Ends the current batch and removes any DML or DDL statements from\n+ *       the buffer without sending any statements to Spanner. May only be executed when a (possibly\n+ *       empty) batch is active.\n+ * </ul>\n+ *\n+ * Note that Cloud Spanner could abort read/write transactions in the background, and that\n+ * <strong>any</strong> database call during a read/write transaction could fail with an {@link\n+ * AbortedException}. This also includes calls to {@link ResultSet#next()}.\n+ *\n+ * <p>If {@link Connection#isRetryAbortsInternally()} is <code>true</code>, then the connection will\n+ * silently handle any {@link AbortedException}s by internally re-acquiring all transactional locks\n+ * and verifying (via the use of cryptographic checksums) that no underlying data has changed. If a\n+ * change to the underlying data is detected, then an {@link\n+ * AbortedDueToConcurrentModificationException} error will be thrown. If your application already\n+ * uses retry loops to handle these Aborted errors, then it will be most efficient to set {@link\n+ * Connection#isRetryAbortsInternally()} to <code>false</code>.\n+ *\n+ * <p>Use {@link ConnectionOptions} to create a {@link Connection}.\n+ */\n+public interface Connection extends AutoCloseable {\n+  /** Closes this connection. This is a no-op if the {@link Connection} has alread been closed. */\n+  @Override\n+  void close();\n+\n+  /** @return <code>true</code> if this connection has been closed. */\n+  boolean isClosed();\n+\n+  /**\n+   * Sets autocommit on/off for this {@link Connection}. Connections in autocommit mode will apply\n+   * any changes to the database directly without waiting for an explicit commit. DDL- and DML\n+   * statements as well as {@link Mutation}s are sent directly to Spanner, and committed\n+   * automatically unless the statement caused an error. The statement is retried in case of an\n+   * {@link AbortedException}. All other errors will cause the underlying transaction to be rolled\n+   * back.\n+   *\n+   * <p>A {@link Connection} that is in autocommit and read/write mode will allow all types of\n+   * statements: Queries, DML, DDL, and Mutations (writes). If the connection is in read-only mode,\n+   * only queries will be allowed.\n+   *\n+   * <p>{@link Connection}s in autocommit mode may also accept partitioned DML statements. See\n+   * {@link Connection#setAutocommitDmlMode(AutocommitDmlMode)} for more information.\n+   *\n+   * @param autocommit true/false to turn autocommit on/off\n+   */\n+  void setAutocommit(boolean autocommit);\n+\n+  /** @return <code>true</code> if this connection is in autocommit mode */\n+  boolean isAutocommit();\n+\n+  /**\n+   * Sets this connection to read-only or read-write. This method may only be called when no\n+   * transaction is active. A connection that is in read-only mode, will never allow any kind of\n+   * changes to the database to be submitted.\n+   *\n+   * @param readOnly true/false to turn read-only mode on/off\n+   */\n+  void setReadOnly(boolean readOnly);\n+\n+  /** @return <code>true</code> if this connection is in read-only mode */\n+  boolean isReadOnly();\n+\n+  /**\n+   * Sets the duration the connection should wait before automatically aborting the execution of a\n+   * statement. The default is no timeout. Statement timeouts are applied all types of statements,\n+   * both in autocommit and transactional mode. They also apply to {@link Connection#commit()} and\n+   * {@link Connection#rollback()} statements.\n+   *\n+   * <p>A DML statement in autocommit mode may or may not have actually been applied to the\n+   * database, depending on when the timeout occurred.\n+   *\n+   * <p>A DML statement in a transaction that times out may still have been applied to the\n+   * transaction. If you still decide to commit the transaction after such a timeout, the DML\n+   * statement may or may not have been part of the transaction, depending on whether the timeout\n+   * occurred before or after the statement was (successfully) sent to Spanner. You should therefore\n+   * either always rollback a transaction that had a DML statement that timed out, or you should\n+   * accept that the timed out statement still might have been applied to the database.\n+   *\n+   * <p>DDL statements and DML statements in {@link AutocommitDmlMode#PARTITIONED_NON_ATOMIC} mode\n+   * cannot be rolled back. If such a statement times out, it may or may not have been applied to\n+   * the database. The same applies to commit and rollback statements.\n+   *\n+   * <p>Statements that time out will throw a {@link SpannerException} with error code {@link\n+   * ErrorCode#DEADLINE_EXCEEDED}.\n+   *\n+   * @param timeout The number of {@link TimeUnit}s before a statement is automatically aborted by\n+   *     the connection. Zero or negative values are not allowed. The maximum allowed value is\n+   *     315,576,000,000 seconds. Use {@link Connection#clearStatementTimeout()} to remove a timeout\n+   *     value that has been set.\n+   * @param unit The {@link TimeUnit} to specify the timeout value in. Must be one of {@link\n+   *     TimeUnit#NANOSECONDS}, {@link TimeUnit#MICROSECONDS}, {@link TimeUnit#MILLISECONDS}, {@link\n+   *     TimeUnit#SECONDS}.\n+   */\n+  void setStatementTimeout(long timeout, TimeUnit unit);\n+\n+  /**\n+   * Clears the statement timeout value for this connection. This is a no-op if there is currently\n+   * no statement timeout set on this connection.\n+   */\n+  void clearStatementTimeout();\n+\n+  /**\n+   * @param unit The {@link TimeUnit} to get the timeout value in. Must be one of {@link\n+   *     TimeUnit#NANOSECONDS}, {@link TimeUnit#MICROSECONDS}, {@link TimeUnit#MILLISECONDS}, {@link\n+   *     TimeUnit#SECONDS}\n+   * @return the current statement timeout value or 0 if no timeout value has been set.\n+   */\n+  long getStatementTimeout(TimeUnit unit);\n+\n+  /** @return <code>true</code> if this {@link Connection} has a statement timeout value. */\n+  boolean hasStatementTimeout();\n+\n+  /**\n+   * Cancels the currently running statement on this {@link Connection} (if any). If canceling the\n+   * statement execution succeeds, the statement will be terminated and a {@link SpannerException}\n+   * with code {@link ErrorCode#CANCELLED} will be thrown. The result of the statement will be the\n+   * same as when a statement times out (see {@link Connection#setStatementTimeout(long, TimeUnit)}\n+   * for more information).\n+   *\n+   * <p>Canceling a DDL statement in autocommit mode or a RUN BATCH statement of a DDL batch will\n+   * cause the connection to try to cancel the execution of the DDL statement(s). This is not\n+   * guaranteed to cancel the execution of the statement(s) on Cloud Spanner. See\n+   * https://cloud.google.com/spanner/docs/reference/rpc/google.longrunning#google.longrunning.Operations.CancelOperation\n+   * for more information.\n+   *\n+   * <p>Canceling a DML statement that is running in {@link\n+   * AutocommitDmlMode#PARTITIONED_NON_ATOMIC} mode will not cancel a statement on Cloud Spanner\n+   * that is already being executed, and its effects will still be applied to the database.\n+   */\n+  void cancel();\n+\n+  /**\n+   * Begins a new transaction for this connection.\n+   *\n+   * <ul>\n+   *   <li>Calling this method on a connection that has no transaction and that is\n+   *       <strong>not</strong> in autocommit mode, will register a new transaction that has not yet\n+   *       started on this connection\n+   *   <li>Calling this method on a connection that has no transaction and that <strong>is</strong>\n+   *       in autocommit mode, will register a new transaction that has not yet started on this\n+   *       connection, and temporarily turn off autocommit mode until the next commit/rollback\n+   *   <li>Calling this method on a connection that already has a transaction that has not yet\n+   *       started, will cause a {@link SpannerException}\n+   *   <li>Calling this method on a connection that already has a transaction that has started, will\n+   *       cause a {@link SpannerException} (no nested transactions)\n+   * </ul>\n+   */\n+  void beginTransaction();\n+\n+  /**\n+   * Sets the transaction mode to use for current transaction. This method may only be called when\n+   * in a transaction, and before the transaction is actually started, i.e. before any statements\n+   * have been executed in the transaction.\n+   *\n+   * @param transactionMode The transaction mode to use for the current transaction.\n+   *     <ul>\n+   *       <li>{@link TransactionMode#READ_ONLY_TRANSACTION} will create a read-only transaction and\n+   *           prevent any changes to written to the database through this transaction. The read\n+   *           timestamp to be used will be determined based on the current readOnlyStaleness\n+   *           setting of this connection. It is recommended to use {@link\n+   *           TransactionMode#READ_ONLY_TRANSACTION} instead of {@link\n+   *           TransactionMode#READ_WRITE_TRANSACTION} when possible, as read-only transactions do\n+   *           not acquire locks on Cloud Spanner, and read-only transactions never abort.\n+   *       <li>{@link TransactionMode#READ_WRITE_TRANSACTION} this value is only allowed when the\n+   *           connection is not in read-only mode and will create a read-write transaction. If\n+   *           {@link Connection#isRetryAbortsInternally()} is <code>true</code>, each read/write\n+   *           transaction will keep track of a running SHA256 checksum for each {@link ResultSet}\n+   *           that is returned in order to be able to retry the transaction in case the transaction\n+   *           is aborted by Spanner.\n+   *     </ul>\n+   */\n+  void setTransactionMode(TransactionMode transactionMode);\n+\n+  /**\n+   * @return the transaction mode of the current transaction. This method may only be called when\n+   *     the connection is in a transaction.\n+   */\n+  TransactionMode getTransactionMode();\n+\n+  /**\n+   * @return <code>true</code> if this connection will automatically retry read/write transactions\n+   *     that abort. This method may only be called when the connection is in read/write\n+   *     transactional mode and no transaction has been started yet.\n+   */\n+  boolean isRetryAbortsInternally();\n+\n+  /**\n+   * Sets whether this connection will internally retry read/write transactions that abort. The\n+   * default is <code>true</code>. When internal retry is enabled, the {@link Connection} will keep\n+   * track of a running SHA256 checksum of all {@link ResultSet}s that have been returned from Cloud\n+   * Spanner. If the checksum that is calculated during an internal retry differs from the original\n+   * checksum, the transaction will abort with an {@link\n+   * AbortedDueToConcurrentModificationException}.", "originalCommit": "e873e7b938b9a2900bb2a9634b9f85b1844455da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTc4MDY1NA==", "url": "https://github.com/googleapis/java-spanner/pull/76#discussion_r379780654", "bodyText": "No, I don't agree with that. Aborted transactions are handled by the connection API and could be relevant for any framework built on top of it. If the framework does not have some kind of automatic retry-loop for transactions, this feature of the connection API should be used to prevent the user from being confronted with aborted errors.\nI've updated the comment to correctly link to the correct exception.", "author": "olavloite", "createdAt": "2020-02-15T07:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY3NDUxMA=="}], "type": "inlineReview"}, {"oid": "969003d5355538cf03ef9a67d7d8c4a0c916cc1b", "url": "https://github.com/googleapis/java-spanner/commit/969003d5355538cf03ef9a67d7d8c4a0c916cc1b", "message": "fix: mark API as internal", "committedDate": "2020-03-05T14:21:29Z", "type": "forcePushed"}, {"oid": "fb7b3dd2f02b00c0ac3b22c5ec67d6d00c10b795", "url": "https://github.com/googleapis/java-spanner/commit/fb7b3dd2f02b00c0ac3b22c5ec67d6d00c10b795", "message": "refactor: move connection api to Spanner client lib", "committedDate": "2020-04-02T16:25:45Z", "type": "commit"}, {"oid": "5bb9befdcec6ba02c936f3f852e4f47fc14d9b09", "url": "https://github.com/googleapis/java-spanner/commit/5bb9befdcec6ba02c936f3f852e4f47fc14d9b09", "message": "fix: add ignored dependencies", "committedDate": "2020-04-02T16:25:45Z", "type": "commit"}, {"oid": "355c27c21daaf689773af5feb88f89f0d0a50fd4", "url": "https://github.com/googleapis/java-spanner/commit/355c27c21daaf689773af5feb88f89f0d0a50fd4", "message": "fix: add new dependencies", "committedDate": "2020-04-02T16:25:45Z", "type": "commit"}, {"oid": "049f6ea426e5bc577a41bd5d968a50566c5eeef9", "url": "https://github.com/googleapis/java-spanner/commit/049f6ea426e5bc577a41bd5d968a50566c5eeef9", "message": "fix: remove JDBC-specific interface", "committedDate": "2020-04-02T16:25:45Z", "type": "commit"}, {"oid": "8c5d1893a107bce3acce44e56fc5cd7e0ede5a97", "url": "https://github.com/googleapis/java-spanner/commit/8c5d1893a107bce3acce44e56fc5cd7e0ede5a97", "message": "fix: remove jdbc references from comments", "committedDate": "2020-04-02T16:25:45Z", "type": "commit"}, {"oid": "706330d5d06362568aec629c56983e58d86dffd3", "url": "https://github.com/googleapis/java-spanner/commit/706330d5d06362568aec629c56983e58d86dffd3", "message": "fix: mark API as internal", "committedDate": "2020-04-02T16:25:45Z", "type": "commit"}, {"oid": "79f6678facf89f074e3f7256f5b3202cfd494ea5", "url": "https://github.com/googleapis/java-spanner/commit/79f6678facf89f074e3f7256f5b3202cfd494ea5", "message": "feat: include QueryOptions change", "committedDate": "2020-04-02T18:47:36Z", "type": "commit"}, {"oid": "79f6678facf89f074e3f7256f5b3202cfd494ea5", "url": "https://github.com/googleapis/java-spanner/commit/79f6678facf89f074e3f7256f5b3202cfd494ea5", "message": "feat: include QueryOptions change", "committedDate": "2020-04-02T18:47:36Z", "type": "forcePushed"}, {"oid": "712c86ec0bce500f28ba6dca33a15e4fd7b1f61b", "url": "https://github.com/googleapis/java-spanner/commit/712c86ec0bce500f28ba6dca33a15e4fd7b1f61b", "message": "tests: add missing test files + parallelize ITs", "committedDate": "2020-04-02T19:35:29Z", "type": "commit"}, {"oid": "10344214b2db78ddaf095cc850c0202ba3188cee", "url": "https://github.com/googleapis/java-spanner/commit/10344214b2db78ddaf095cc850c0202ba3188cee", "message": "tests: add comment to test class", "committedDate": "2020-04-02T20:41:16Z", "type": "commit"}, {"oid": "876dce613217d98dae8a57fcab7e819153b35a7a", "url": "https://github.com/googleapis/java-spanner/commit/876dce613217d98dae8a57fcab7e819153b35a7a", "message": "tests: clean up test case", "committedDate": "2020-04-03T15:57:48Z", "type": "commit"}, {"oid": "ab44beef45e8f033f015f5c5e9c7a81c10a810a2", "url": "https://github.com/googleapis/java-spanner/commit/ab44beef45e8f033f015f5c5e9c7a81c10a810a2", "message": "tests: increase exec time to prevent flakiness", "committedDate": "2020-04-04T07:52:50Z", "type": "commit"}]}