{"pr_number": 81, "pr_title": "feat: add async api", "pr_createdAt": "2020-02-21T19:49:00Z", "pr_url": "https://github.com/googleapis/java-spanner/pull/81", "timeline": [{"oid": "987b77f337b98033541651f6f294b295e4b734a8", "url": "https://github.com/googleapis/java-spanner/commit/987b77f337b98033541651f6f294b295e4b734a8", "message": "fix: fix span test cases after rebase", "committedDate": "2020-02-26T18:01:07Z", "type": "forcePushed"}, {"oid": "80d023a9ac598a1036c25f058bd2097c75911f0b", "url": "https://github.com/googleapis/java-spanner/commit/80d023a9ac598a1036c25f058bd2097c75911f0b", "message": "fix: make async runner wait for async operations", "committedDate": "2020-02-28T13:15:50Z", "type": "forcePushed"}, {"oid": "54c1951412b5bd2a0b0759ff1e45f29befe20721", "url": "https://github.com/googleapis/java-spanner/commit/54c1951412b5bd2a0b0759ff1e45f29befe20721", "message": "rebase: rebase on current master", "committedDate": "2020-03-16T13:54:46Z", "type": "forcePushed"}, {"oid": "e5e8df8c8b3cc17f5abe60d89994a5074e1f5db5", "url": "https://github.com/googleapis/java-spanner/commit/e5e8df8c8b3cc17f5abe60d89994a5074e1f5db5", "message": "feat: add async api", "committedDate": "2020-03-20T16:17:39Z", "type": "commit"}, {"oid": "c7db649ed353ac7812ee6dc418978101152e8d5e", "url": "https://github.com/googleapis/java-spanner/commit/c7db649ed353ac7812ee6dc418978101152e8d5e", "message": "feat: session pool is non-blocking", "committedDate": "2020-03-20T16:17:39Z", "type": "commit"}, {"oid": "e485709e46a8dbc231f851cfead5aaa3c48056ef", "url": "https://github.com/googleapis/java-spanner/commit/e485709e46a8dbc231f851cfead5aaa3c48056ef", "message": "tests: fix integration tests that assumed tx was blocking\n\nSome integration tests started transactions without executing a query,\nand expected these transactions to fail. However, as the client is\nnow non-blocking up until the first call to ResultSet#next(), no\nexception would occur.", "committedDate": "2020-03-20T16:17:39Z", "type": "commit"}, {"oid": "e3ebeb313fadfb37016998f5b03e261d58306f6f", "url": "https://github.com/googleapis/java-spanner/commit/e3ebeb313fadfb37016998f5b03e261d58306f6f", "message": "feat: add read methods support", "committedDate": "2020-03-20T16:17:39Z", "type": "commit"}, {"oid": "54629ad2724bc7d643c1141d0a08dc00db9708bd", "url": "https://github.com/googleapis/java-spanner/commit/54629ad2724bc7d643c1141d0a08dc00db9708bd", "message": "tests: test async runner", "committedDate": "2020-03-20T16:17:39Z", "type": "commit"}, {"oid": "8a10b646b416ab61c079f00294e20529ca9f7b9c", "url": "https://github.com/googleapis/java-spanner/commit/8a10b646b416ab61c079f00294e20529ca9f7b9c", "message": "feat: create async runner", "committedDate": "2020-03-20T16:17:39Z", "type": "commit"}, {"oid": "91253cf7dbd943a5162fab209bdb54607b321bdf", "url": "https://github.com/googleapis/java-spanner/commit/91253cf7dbd943a5162fab209bdb54607b321bdf", "message": "tests: centralize some commonly used test objects", "committedDate": "2020-03-20T16:17:39Z", "type": "commit"}, {"oid": "a2d28cd6601706fd3f5b32a35dc4d7745eb417b8", "url": "https://github.com/googleapis/java-spanner/commit/a2d28cd6601706fd3f5b32a35dc4d7745eb417b8", "message": "feat: keep session checked out until async finishes", "committedDate": "2020-03-20T16:17:39Z", "type": "commit"}, {"oid": "2a63e62560a1c7b266fc896f1133b03925b69875", "url": "https://github.com/googleapis/java-spanner/commit/2a63e62560a1c7b266fc896f1133b03925b69875", "message": "fix: fix span test cases after rebase", "committedDate": "2020-03-20T16:20:31Z", "type": "commit"}, {"oid": "9d58bc366dc3c9317a5b6419c2fb4a616e38b39a", "url": "https://github.com/googleapis/java-spanner/commit/9d58bc366dc3c9317a5b6419c2fb4a616e38b39a", "message": "fix: fix async runner tests", "committedDate": "2020-03-20T16:20:31Z", "type": "commit"}, {"oid": "4f796325b2c9f38bd2afe839604abc262a9ae48b", "url": "https://github.com/googleapis/java-spanner/commit/4f796325b2c9f38bd2afe839604abc262a9ae48b", "message": "fix: make async runner wait for async operations", "committedDate": "2020-03-20T16:20:31Z", "type": "commit"}, {"oid": "cfd1802183bfe7d16d00b9acc163fb1283922148", "url": "https://github.com/googleapis/java-spanner/commit/cfd1802183bfe7d16d00b9acc163fb1283922148", "message": "examples: add example integration test", "committedDate": "2020-03-20T16:20:31Z", "type": "commit"}, {"oid": "a2e28a577aa007133c723ea2d7fc785d66053c3a", "url": "https://github.com/googleapis/java-spanner/commit/a2e28a577aa007133c723ea2d7fc785d66053c3a", "message": "examples: add more examples", "committedDate": "2020-03-20T16:20:31Z", "type": "commit"}, {"oid": "fa61e7d14a3cd2a26a396107ce2b5a551a8587ba", "url": "https://github.com/googleapis/java-spanner/commit/fa61e7d14a3cd2a26a396107ce2b5a551a8587ba", "message": "tests: fix flaky tests", "committedDate": "2020-03-20T16:20:31Z", "type": "commit"}, {"oid": "fc53dbf2a62f199466da10655c2c355b36745144", "url": "https://github.com/googleapis/java-spanner/commit/fc53dbf2a62f199466da10655c2c355b36745144", "message": "rebase: rebase on current master", "committedDate": "2020-03-20T16:21:19Z", "type": "commit"}, {"oid": "0eee1f64f3767574608237f31d7a8cb1d7df6601", "url": "https://github.com/googleapis/java-spanner/commit/0eee1f64f3767574608237f31d7a8cb1d7df6601", "message": "fix: run code formatter", "committedDate": "2020-03-20T16:25:57Z", "type": "commit"}, {"oid": "0eee1f64f3767574608237f31d7a8cb1d7df6601", "url": "https://github.com/googleapis/java-spanner/commit/0eee1f64f3767574608237f31d7a8cb1d7df6601", "message": "fix: run code formatter", "committedDate": "2020-03-20T16:25:57Z", "type": "forcePushed"}, {"oid": "d3d2ffc49f2c6a73b08af77d420b12a3ff2065ab", "url": "https://github.com/googleapis/java-spanner/commit/d3d2ffc49f2c6a73b08af77d420b12a3ff2065ab", "message": "feat: add support for poller", "committedDate": "2020-03-26T15:08:12Z", "type": "commit"}, {"oid": "2e01ca71854f6d7e39ad0e9cf6bb184c2699a7b9", "url": "https://github.com/googleapis/java-spanner/commit/2e01ca71854f6d7e39ad0e9cf6bb184c2699a7b9", "message": "tests: support more param types", "committedDate": "2020-04-02T06:40:53Z", "type": "commit"}, {"oid": "5e63f2b02bd487a9b74e851f5af82e2ac85ec1cb", "url": "https://github.com/googleapis/java-spanner/commit/5e63f2b02bd487a9b74e851f5af82e2ac85ec1cb", "message": "fix: fix race conditions", "committedDate": "2020-04-08T05:02:36Z", "type": "commit"}, {"oid": "abe455e7e8bd2483ff419419f0ebe1b152c73ae8", "url": "https://github.com/googleapis/java-spanner/commit/abe455e7e8bd2483ff419419f0ebe1b152c73ae8", "message": "feat: return ApiFuture to monitor end of AsyncResultSet", "committedDate": "2020-04-09T16:20:10Z", "type": "commit"}, {"oid": "cc091e8d97ae2b01aea73571164ae746d81d8597", "url": "https://github.com/googleapis/java-spanner/commit/cc091e8d97ae2b01aea73571164ae746d81d8597", "message": "feat: add helper method for create test result sets", "committedDate": "2020-04-19T18:21:33Z", "type": "commit"}, {"oid": "944c701de1d5da6cedcf1e062ecda38e95984071", "url": "https://github.com/googleapis/java-spanner/commit/944c701de1d5da6cedcf1e062ecda38e95984071", "message": "merge: merge latest changes from master", "committedDate": "2020-04-21T15:28:57Z", "type": "commit"}, {"oid": "d75f9795e2782bd7d628da289e3c2f5103aa8136", "url": "https://github.com/googleapis/java-spanner/commit/d75f9795e2782bd7d628da289e3c2f5103aa8136", "message": "feat: add batchUpdateAsync", "committedDate": "2020-04-21T19:43:29Z", "type": "commit"}, {"oid": "7f06e845181ac240dbd5ec664f702946c321bd84", "url": "https://github.com/googleapis/java-spanner/commit/7f06e845181ac240dbd5ec664f702946c321bd84", "message": "fix: add ignored interface differences", "committedDate": "2020-04-26T09:17:32Z", "type": "commit"}, {"oid": "c1b0615f382fbbe21298f84d612e3718f55b1b6b", "url": "https://github.com/googleapis/java-spanner/commit/c1b0615f382fbbe21298f84d612e3718f55b1b6b", "message": "merge: merge master into async branch", "committedDate": "2020-04-26T09:29:46Z", "type": "commit"}, {"oid": "00b83d2ef88fa5ccee369809033a55cfbe9e298f", "url": "https://github.com/googleapis/java-spanner/commit/00b83d2ef88fa5ccee369809033a55cfbe9e298f", "message": "refactor: use future as waiter in SessionPool", "committedDate": "2020-04-26T20:33:24Z", "type": "commit"}, {"oid": "2ea27d7e4d11866e6f7fd880cadc1076c4f61c28", "url": "https://github.com/googleapis/java-spanner/commit/2ea27d7e4d11866e6f7fd880cadc1076c4f61c28", "message": "Merge branch 'master' into async-api", "committedDate": "2020-04-27T08:33:19Z", "type": "commit"}, {"oid": "17fb940bfb56d10a673ce20d7d17b8bd2dd38dc7", "url": "https://github.com/googleapis/java-spanner/commit/17fb940bfb56d10a673ce20d7d17b8bd2dd38dc7", "message": "merge: merge with latest from master", "committedDate": "2020-04-29T07:17:46Z", "type": "commit"}, {"oid": "51b511349e094ae5bac9225a9d22d6d9cad1c212", "url": "https://github.com/googleapis/java-spanner/commit/51b511349e094ae5bac9225a9d22d6d9cad1c212", "message": "format: run code formatter", "committedDate": "2020-04-29T07:25:39Z", "type": "commit"}, {"oid": "a03380be0c2a720131615f793a4b807adc593b9d", "url": "https://github.com/googleapis/java-spanner/commit/a03380be0c2a720131615f793a4b807adc593b9d", "message": "tests: fix test case + remove commented code", "committedDate": "2020-04-29T08:23:42Z", "type": "commit"}, {"oid": "8bc3a135382517e3e08097bb5e669946496d3028", "url": "https://github.com/googleapis/java-spanner/commit/8bc3a135382517e3e08097bb5e669946496d3028", "message": "fix: AsyncResultSet should throw Cancelled", "committedDate": "2020-04-29T13:01:58Z", "type": "commit"}, {"oid": "0927957750e144e5f24c6263c67b14d117560256", "url": "https://github.com/googleapis/java-spanner/commit/0927957750e144e5f24c6263c67b14d117560256", "message": "Merge branch 'master' into async-api", "committedDate": "2020-05-06T13:53:03Z", "type": "commit"}, {"oid": "e486c54a913797d73e9f83c00491812f5deb7d6d", "url": "https://github.com/googleapis/java-spanner/commit/e486c54a913797d73e9f83c00491812f5deb7d6d", "message": "feat: expose DatabaseId.of(String name)", "committedDate": "2020-05-11T13:05:54Z", "type": "commit"}, {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "url": "https://github.com/googleapis/java-spanner/commit/a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "message": "deps: set version to 1.53 to match bom", "committedDate": "2020-05-12T11:37:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4MzM3Mg==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437683372", "bodyText": "Would this loop execute at most twice? Wondering if the while loop is necessary here.", "author": "elefeint", "createdAt": "2020-06-09T19:59:28Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AbstractReadContext.java", "diffHunk": "@@ -666,4 +752,52 @@ private Struct consumeSingleRow(ResultSet resultSet) {\n     }\n     return row;\n   }\n+\n+  private ApiFuture<Struct> consumeSingleRowAsync(AsyncResultSet resultSet) {\n+    SettableApiFuture<Struct> result = SettableApiFuture.create();\n+    // We can safely use a directExecutor here, as we will only be consuming one row, and we will\n+    // not be doing any blocking stuff in the handler.\n+    resultSet.setCallback(MoreExecutors.directExecutor(), ConsumeSingleRowCallback.create(result));\n+    return result;\n+  }\n+\n+  /**\n+   * {@link ReadyCallback} for returning the first row in a result set as a future {@link Struct}.\n+   */\n+  static class ConsumeSingleRowCallback implements ReadyCallback {\n+    private final SettableApiFuture<Struct> result;\n+    private Struct row;\n+\n+    static ConsumeSingleRowCallback create(SettableApiFuture<Struct> result) {\n+      return new ConsumeSingleRowCallback(result);\n+    }\n+\n+    private ConsumeSingleRowCallback(SettableApiFuture<Struct> result) {\n+      this.result = result;\n+    }\n+\n+    @Override\n+    public CallbackResponse cursorReady(AsyncResultSet resultSet) {\n+      try {\n+        while (true) {", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcwODA3Nw==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438708077", "bodyText": "The while loop will as you noted be executed at most twice. Removing the while loop requires adding a default clause and the OK clause to return a CONTINUE, so the amount of code is not really less, and I'm not confident that it's more readable. I've made the change for comparison.", "author": "olavloite", "createdAt": "2020-06-11T11:06:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4MzM3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4NTg0MQ==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437685841", "bodyText": "Even though tryNext() returns an enum, can we add a default case with a fallthough comment along the lines of \"this should never happen\"? Or even an exception in case the enum grows over time?\nhttps://google.github.io/styleguide/javaguide.html#s4.8.4.3-switch-default", "author": "elefeint", "createdAt": "2020-06-09T20:04:12Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AbstractReadContext.java", "diffHunk": "@@ -666,4 +752,52 @@ private Struct consumeSingleRow(ResultSet resultSet) {\n     }\n     return row;\n   }\n+\n+  private ApiFuture<Struct> consumeSingleRowAsync(AsyncResultSet resultSet) {\n+    SettableApiFuture<Struct> result = SettableApiFuture.create();\n+    // We can safely use a directExecutor here, as we will only be consuming one row, and we will\n+    // not be doing any blocking stuff in the handler.\n+    resultSet.setCallback(MoreExecutors.directExecutor(), ConsumeSingleRowCallback.create(result));\n+    return result;\n+  }\n+\n+  /**\n+   * {@link ReadyCallback} for returning the first row in a result set as a future {@link Struct}.\n+   */\n+  static class ConsumeSingleRowCallback implements ReadyCallback {\n+    private final SettableApiFuture<Struct> result;\n+    private Struct row;\n+\n+    static ConsumeSingleRowCallback create(SettableApiFuture<Struct> result) {\n+      return new ConsumeSingleRowCallback(result);\n+    }\n+\n+    private ConsumeSingleRowCallback(SettableApiFuture<Struct> result) {\n+      this.result = result;\n+    }\n+\n+    @Override\n+    public CallbackResponse cursorReady(AsyncResultSet resultSet) {\n+      try {\n+        while (true) {\n+          switch (resultSet.tryNext()) {", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcwODI3Mw==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438708273", "bodyText": "Done (see above).", "author": "olavloite", "createdAt": "2020-06-11T11:06:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4NTg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4NzI5OA==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437687298", "bodyText": "Synchronous caller? For asynchronous scenario, we'd return CallbackResponse.CONTINUE and let the callback be invoked again.", "author": "elefeint", "createdAt": "2020-06-09T20:07:02Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncResultSet.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.common.base.Function;\n+import com.google.common.collect.ImmutableList;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+\n+/** Interface for result sets returned by async query methods. */\n+public interface AsyncResultSet extends ResultSet {\n+\n+  /**\n+   * Interface for receiving asynchronous callbacks when new data is ready. See {@link\n+   * AsyncResultSet#setCallback(Executor, ReadyCallback)}.\n+   */\n+  public static interface ReadyCallback {\n+    CallbackResponse cursorReady(AsyncResultSet resultSet);\n+  }\n+\n+  /** Response code from {@code tryNext()}. */\n+  public enum CursorState {\n+    /** Cursor has been moved to a new row. */\n+    OK,\n+    /** Read is complete, all rows have been consumed, and there are no more. */\n+    DONE,\n+    /** No further information known at this time, thus current row not available. */\n+    NOT_READY\n+  }\n+\n+  /**\n+   * Non-blocking call that attempts to step the cursor to the next position in the stream. The\n+   * cursor may be inspected only if the cursor returns {@code CursorState.OK}.\n+   *\n+   * <p>A caller will typically call {@link #tryNext()} in a loop inside the ReadyCallback,", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxOTE4Ng==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438719186", "bodyText": "tryNext() (currently) cannot be called by a synchronous caller, as it is only allowed from inside the cursorReady method. This documentation was copied from the original design document written by @snehashah16\nReturning CallbackResponse.CONTINUE after each row is legal and will cause the callback to be called again if there is more data available, although calling tryNext in a loop could have a (very small) efficiency advantage, as the result set will execute a couple of checks after the callback has returned CONTINUE.", "author": "olavloite", "createdAt": "2020-06-11T11:31:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4NzI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5MjI4Ng==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437692286", "bodyText": "nit: add newline before exception declaration? It does not seem to belong to the same visual member declaration block.", "author": "elefeint", "createdAt": "2020-06-09T20:16:35Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncResultSetImpl.java", "diffHunk": "@@ -0,0 +1,567 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.api.core.ListenableFutureToApiFuture;\n+import com.google.api.core.SettableApiFuture;\n+import com.google.api.gax.core.ExecutorProvider;\n+import com.google.cloud.spanner.AbstractReadContext.ListenableAsyncResultSet;\n+import com.google.common.base.Function;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.spanner.v1.ResultSetStats;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingDeque;\n+\n+/** Default implementation for {@link AsyncResultSet}. */\n+class AsyncResultSetImpl extends ForwardingStructReader implements ListenableAsyncResultSet {\n+\n+  /** State of an {@link AsyncResultSetImpl}. */\n+  private enum State {\n+    INITIALIZED,\n+    /** SYNC indicates that the {@link ResultSet} is used in sync pattern. */\n+    SYNC,\n+    CONSUMING,\n+    RUNNING,\n+    PAUSED,\n+    CANCELLED(true),\n+    DONE(true);\n+\n+    /** Does this state mean that the result set should permanently stop producing rows. */\n+    private final boolean shouldStop;\n+\n+    private State() {\n+      shouldStop = false;\n+    }\n+\n+    private State(boolean shouldStop) {\n+      this.shouldStop = shouldStop;\n+    }\n+  }\n+\n+  static final int DEFAULT_BUFFER_SIZE = 10;\n+  private static final int MAX_WAIT_FOR_BUFFER_CONSUMPTION = 10;\n+  private static final SpannerException CANCELLED_EXCEPTION =\n+      SpannerExceptionFactory.newSpannerException(\n+          ErrorCode.CANCELLED, \"This AsyncResultSet has been cancelled\");\n+\n+  private final Object monitor = new Object();\n+  private boolean closed;\n+\n+  /**\n+   * {@link ExecutorProvider} provides executor services that are used to fetch data from the\n+   * backend and put these into the buffer for further consumption by the callback.\n+   */\n+  private final ExecutorProvider executorProvider;\n+\n+  private final ListeningScheduledExecutorService service;\n+\n+  private final BlockingDeque<Struct> buffer;\n+  private Struct currentRow;\n+  /** The underlying synchronous {@link ResultSet} that is producing the rows. */\n+  private final ResultSet delegateResultSet;\n+  /**", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxOTYxMQ==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438719611", "bodyText": "Done.", "author": "olavloite", "createdAt": "2020-06-11T11:32:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5MjI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgyMzgzMQ==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437823831", "bodyText": "Non-actionable comment on your TODO above: we can in the future set up reactive streams test cases -- for example, there are Project Reactor operators that keep a certain percentage of a buffer full at all times, so refilling it not when empty but when down to the last N%.", "author": "elefeint", "createdAt": "2020-06-10T02:24:29Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncResultSetImpl.java", "diffHunk": "@@ -0,0 +1,567 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.api.core.ListenableFutureToApiFuture;\n+import com.google.api.core.SettableApiFuture;\n+import com.google.api.gax.core.ExecutorProvider;\n+import com.google.cloud.spanner.AbstractReadContext.ListenableAsyncResultSet;\n+import com.google.common.base.Function;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.spanner.v1.ResultSetStats;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingDeque;\n+\n+/** Default implementation for {@link AsyncResultSet}. */\n+class AsyncResultSetImpl extends ForwardingStructReader implements ListenableAsyncResultSet {\n+\n+  /** State of an {@link AsyncResultSetImpl}. */\n+  private enum State {\n+    INITIALIZED,\n+    /** SYNC indicates that the {@link ResultSet} is used in sync pattern. */\n+    SYNC,\n+    CONSUMING,\n+    RUNNING,\n+    PAUSED,\n+    CANCELLED(true),\n+    DONE(true);\n+\n+    /** Does this state mean that the result set should permanently stop producing rows. */\n+    private final boolean shouldStop;\n+\n+    private State() {\n+      shouldStop = false;\n+    }\n+\n+    private State(boolean shouldStop) {\n+      this.shouldStop = shouldStop;\n+    }\n+  }\n+\n+  static final int DEFAULT_BUFFER_SIZE = 10;\n+  private static final int MAX_WAIT_FOR_BUFFER_CONSUMPTION = 10;\n+  private static final SpannerException CANCELLED_EXCEPTION =\n+      SpannerExceptionFactory.newSpannerException(\n+          ErrorCode.CANCELLED, \"This AsyncResultSet has been cancelled\");\n+\n+  private final Object monitor = new Object();\n+  private boolean closed;\n+\n+  /**\n+   * {@link ExecutorProvider} provides executor services that are used to fetch data from the\n+   * backend and put these into the buffer for further consumption by the callback.\n+   */\n+  private final ExecutorProvider executorProvider;\n+\n+  private final ListeningScheduledExecutorService service;\n+\n+  private final BlockingDeque<Struct> buffer;\n+  private Struct currentRow;\n+  /** The underlying synchronous {@link ResultSet} that is producing the rows. */\n+  private final ResultSet delegateResultSet;\n+  /**\n+   * Any exception that occurs while executing the query and iterating over the result set will be\n+   * stored in this variable and propagated to the user through {@link #tryNext()}.\n+   */\n+  private volatile SpannerException executionException;\n+\n+  /**\n+   * Executor for callbacks. Regardless of the type of executor that is provided, the {@link\n+   * AsyncResultSetImpl} will ensure that at most 1 callback call will be active at any one time.\n+   */\n+  private Executor executor;\n+\n+  private ReadyCallback callback;\n+\n+  /**\n+   * Listeners that will be called when the {@link AsyncResultSetImpl} has finished fetching all\n+   * rows and any underlying transaction or session can be closed.\n+   */\n+  private Collection<Runnable> listeners = new LinkedList<>();\n+\n+  private State state = State.INITIALIZED;\n+\n+  /**\n+   * {@link #finished} indicates whether all the results from the underlying result set have been\n+   * read.\n+   */\n+  private volatile boolean finished;\n+\n+  private volatile ApiFuture<Void> result;\n+\n+  /**\n+   * {@link #cursorReturnedDoneOrException} indicates whether {@link #tryNext()} has returned {@link\n+   * CursorState#DONE} or a {@link SpannerException}.\n+   */\n+  private volatile boolean cursorReturnedDoneOrException;\n+\n+  /**\n+   * {@link #pausedLatch} is used to pause the producer when the {@link AsyncResultSet} is paused.\n+   * The production of rows that are put into the buffer is only paused once the buffer is full.\n+   */\n+  private volatile CountDownLatch pausedLatch = new CountDownLatch(1);\n+  /**\n+   * {@link #bufferConsumptionLatch} is used to pause the producer when the buffer is full and the\n+   * consumer needs some time to catch up.\n+   */\n+  private volatile CountDownLatch bufferConsumptionLatch = new CountDownLatch(0);\n+  /**\n+   * {@link #consumingLatch} is used to pause the producer when all rows have been put into the\n+   * buffer, but the consumer (the callback) has not yet received and processed all rows.\n+   */\n+  private volatile CountDownLatch consumingLatch = new CountDownLatch(0);\n+\n+  AsyncResultSetImpl(ExecutorProvider executorProvider, ResultSet delegate, int bufferSize) {\n+    super(delegate);\n+    this.buffer = new LinkedBlockingDeque<>(bufferSize);\n+    this.executorProvider = executorProvider;\n+    this.service = MoreExecutors.listeningDecorator(executorProvider.getExecutor());\n+    this.delegateResultSet = delegate;\n+  }\n+\n+  /**\n+   * Closes the {@link AsyncResultSet}. {@link #close()} is non-blocking and may be called multiple\n+   * times without side effects. An {@link AsyncResultSet} may be closed before all rows have been\n+   * returned to the callback, and calling {@link #tryNext()} on a closed {@link AsyncResultSet} is\n+   * allowed as long as this is done from within a {@link ReadyCallback}. Calling {@link #resume()}\n+   * on a closed {@link AsyncResultSet} is also allowed.\n+   */\n+  @Override\n+  public void close() {\n+    synchronized (monitor) {\n+      if (this.closed) {\n+        return;\n+      }\n+      if (state == State.INITIALIZED || state == State.SYNC) {\n+        delegateResultSet.close();\n+      }\n+      this.closed = true;\n+    }\n+  }\n+\n+  /**\n+   * Adds a listener that will be called when no more rows will be read from the underlying {@link\n+   * ResultSet}, either because all rows have been read, or because {@link\n+   * ReadyCallback#cursorReady(AsyncResultSet)} returned {@link CallbackResponse#DONE}.\n+   */\n+  @Override\n+  public void addListener(Runnable listener) {\n+    Preconditions.checkState(state == State.INITIALIZED);\n+    listeners.add(listener);\n+  }\n+\n+  @Override\n+  public void removeListener(Runnable listener) {\n+    Preconditions.checkState(state == State.INITIALIZED);\n+    listeners.remove(listener);\n+  }\n+\n+  /**\n+   * Tries to advance this {@link AsyncResultSet} to the next row. This method may only be called\n+   * from within a {@link ReadyCallback}.\n+   */\n+  @Override\n+  public CursorState tryNext() throws SpannerException {\n+    synchronized (monitor) {\n+      if (state == State.CANCELLED) {\n+        cursorReturnedDoneOrException = true;\n+        throw CANCELLED_EXCEPTION;\n+      }\n+      if (buffer.isEmpty() && executionException != null) {\n+        cursorReturnedDoneOrException = true;\n+        throw executionException;\n+      }\n+      Preconditions.checkState(\n+          this.callback != null, \"tryNext may only be called after a callback has been set.\");\n+      Preconditions.checkState(\n+          this.state == State.CONSUMING,\n+          \"tryNext may only be called from a DataReady callback. Current state: \"\n+              + this.state.name());\n+\n+      if (finished && buffer.isEmpty()) {\n+        cursorReturnedDoneOrException = true;\n+        return CursorState.DONE;\n+      }\n+    }\n+    if (!buffer.isEmpty()) {\n+      // Set the next row from the buffer as the current row of the StructReader.\n+      replaceDelegate(currentRow = buffer.pop());\n+      synchronized (monitor) {\n+        bufferConsumptionLatch.countDown();\n+      }\n+      return CursorState.OK;\n+    }\n+    return CursorState.NOT_READY;\n+  }\n+\n+  /**\n+   * {@link CallbackRunnable} calls the {@link ReadyCallback} registered for this {@link\n+   * AsyncResultSet}.\n+   */\n+  private class CallbackRunnable implements Runnable {\n+    @Override\n+    public void run() {\n+      try {\n+        while (true) {\n+          synchronized (monitor) {\n+            if (cursorReturnedDoneOrException) {\n+              break;\n+            }\n+          }\n+          CallbackResponse response;\n+          try {\n+            response = callback.cursorReady(AsyncResultSetImpl.this);\n+          } catch (Throwable e) {\n+            synchronized (monitor) {\n+              if (cursorReturnedDoneOrException\n+                  && state == State.CANCELLED\n+                  && e instanceof SpannerException\n+                  && ((SpannerException) e).getErrorCode() == ErrorCode.CANCELLED) {\n+                // The callback did not catch the cancelled exception (which it should have), but\n+                // we'll keep the cancelled state.\n+                return;\n+              }\n+              executionException = SpannerExceptionFactory.newSpannerException(e);\n+              cursorReturnedDoneOrException = true;\n+            }\n+            return;\n+          }\n+          synchronized (monitor) {\n+            if (state == State.CANCELLED) {\n+              if (cursorReturnedDoneOrException) {\n+                return;\n+              }\n+            } else {\n+              switch (response) {\n+                case DONE:\n+                  state = State.DONE;\n+                  return;\n+                case PAUSE:\n+                  state = State.PAUSED;\n+                  // Make sure no-one else is waiting on the current pause latch and create a new\n+                  // one.\n+                  pausedLatch.countDown();\n+                  pausedLatch = new CountDownLatch(1);\n+                  return;\n+                case CONTINUE:\n+                  if (buffer.isEmpty()) {\n+                    // Call the callback once more if the entire result set has been processed but\n+                    // the callback has not yet received a CursorState.DONE or a CANCELLED error.\n+                    if (finished && !cursorReturnedDoneOrException) {\n+                      break;\n+                    }\n+                    state = State.RUNNING;\n+                    return;\n+                  }\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\"Unknown response: \" + response);\n+              }\n+            }\n+          }\n+        }\n+      } finally {\n+        synchronized (monitor) {\n+          // Count down all latches that the producer might be waiting on.\n+          consumingLatch.countDown();\n+          while (bufferConsumptionLatch.getCount() > 0L) {\n+            bufferConsumptionLatch.countDown();\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  private final CallbackRunnable callbackRunnable = new CallbackRunnable();\n+\n+  /**\n+   * {@link ProduceRowsCallable} reads data from the underlying {@link ResultSet}, places these in\n+   * the buffer and dispatches the {@link CallbackRunnable} when data is ready to be consumed.\n+   */\n+  private class ProduceRowsCallable implements Callable<Void> {\n+    @Override\n+    public Void call() throws Exception {\n+      boolean stop = false;\n+      boolean hasNext = false;\n+      try {\n+        hasNext = delegateResultSet.next();\n+      } catch (Throwable e) {\n+        synchronized (monitor) {\n+          executionException = SpannerExceptionFactory.newSpannerException(e);\n+        }\n+      }\n+      try {\n+        while (!stop && hasNext) {\n+          try {\n+            synchronized (monitor) {\n+              stop = state.shouldStop;\n+            }\n+            if (!stop) {\n+              while (buffer.remainingCapacity() == 0 && !stop) {\n+                waitIfPaused();\n+                // The buffer is full and we should let the callback consume a number of rows before\n+                // we proceed with producing any more rows to prevent us from potentially waiting on\n+                // a full buffer repeatedly.\n+                // Wait until at least half of the buffer is available, or if it's a bigger buffer,\n+                // wait until at least 10 rows can be placed in it.\n+                // TODO: Make this more dynamic / configurable?\n+                startCallbackWithBufferLatchIfNecessary(\n+                    Math.min(\n+                        Math.min(buffer.size() / 2 + 1, buffer.size()),\n+                        MAX_WAIT_FOR_BUFFER_CONSUMPTION));\n+                bufferConsumptionLatch.await();", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgyNDM3Mw==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437824373", "bodyText": "Log at INFO-level that the exception has been ignored?", "author": "elefeint", "createdAt": "2020-06-10T02:26:30Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncResultSetImpl.java", "diffHunk": "@@ -0,0 +1,567 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.api.core.ListenableFutureToApiFuture;\n+import com.google.api.core.SettableApiFuture;\n+import com.google.api.gax.core.ExecutorProvider;\n+import com.google.cloud.spanner.AbstractReadContext.ListenableAsyncResultSet;\n+import com.google.common.base.Function;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.spanner.v1.ResultSetStats;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingDeque;\n+\n+/** Default implementation for {@link AsyncResultSet}. */\n+class AsyncResultSetImpl extends ForwardingStructReader implements ListenableAsyncResultSet {\n+\n+  /** State of an {@link AsyncResultSetImpl}. */\n+  private enum State {\n+    INITIALIZED,\n+    /** SYNC indicates that the {@link ResultSet} is used in sync pattern. */\n+    SYNC,\n+    CONSUMING,\n+    RUNNING,\n+    PAUSED,\n+    CANCELLED(true),\n+    DONE(true);\n+\n+    /** Does this state mean that the result set should permanently stop producing rows. */\n+    private final boolean shouldStop;\n+\n+    private State() {\n+      shouldStop = false;\n+    }\n+\n+    private State(boolean shouldStop) {\n+      this.shouldStop = shouldStop;\n+    }\n+  }\n+\n+  static final int DEFAULT_BUFFER_SIZE = 10;\n+  private static final int MAX_WAIT_FOR_BUFFER_CONSUMPTION = 10;\n+  private static final SpannerException CANCELLED_EXCEPTION =\n+      SpannerExceptionFactory.newSpannerException(\n+          ErrorCode.CANCELLED, \"This AsyncResultSet has been cancelled\");\n+\n+  private final Object monitor = new Object();\n+  private boolean closed;\n+\n+  /**\n+   * {@link ExecutorProvider} provides executor services that are used to fetch data from the\n+   * backend and put these into the buffer for further consumption by the callback.\n+   */\n+  private final ExecutorProvider executorProvider;\n+\n+  private final ListeningScheduledExecutorService service;\n+\n+  private final BlockingDeque<Struct> buffer;\n+  private Struct currentRow;\n+  /** The underlying synchronous {@link ResultSet} that is producing the rows. */\n+  private final ResultSet delegateResultSet;\n+  /**\n+   * Any exception that occurs while executing the query and iterating over the result set will be\n+   * stored in this variable and propagated to the user through {@link #tryNext()}.\n+   */\n+  private volatile SpannerException executionException;\n+\n+  /**\n+   * Executor for callbacks. Regardless of the type of executor that is provided, the {@link\n+   * AsyncResultSetImpl} will ensure that at most 1 callback call will be active at any one time.\n+   */\n+  private Executor executor;\n+\n+  private ReadyCallback callback;\n+\n+  /**\n+   * Listeners that will be called when the {@link AsyncResultSetImpl} has finished fetching all\n+   * rows and any underlying transaction or session can be closed.\n+   */\n+  private Collection<Runnable> listeners = new LinkedList<>();\n+\n+  private State state = State.INITIALIZED;\n+\n+  /**\n+   * {@link #finished} indicates whether all the results from the underlying result set have been\n+   * read.\n+   */\n+  private volatile boolean finished;\n+\n+  private volatile ApiFuture<Void> result;\n+\n+  /**\n+   * {@link #cursorReturnedDoneOrException} indicates whether {@link #tryNext()} has returned {@link\n+   * CursorState#DONE} or a {@link SpannerException}.\n+   */\n+  private volatile boolean cursorReturnedDoneOrException;\n+\n+  /**\n+   * {@link #pausedLatch} is used to pause the producer when the {@link AsyncResultSet} is paused.\n+   * The production of rows that are put into the buffer is only paused once the buffer is full.\n+   */\n+  private volatile CountDownLatch pausedLatch = new CountDownLatch(1);\n+  /**\n+   * {@link #bufferConsumptionLatch} is used to pause the producer when the buffer is full and the\n+   * consumer needs some time to catch up.\n+   */\n+  private volatile CountDownLatch bufferConsumptionLatch = new CountDownLatch(0);\n+  /**\n+   * {@link #consumingLatch} is used to pause the producer when all rows have been put into the\n+   * buffer, but the consumer (the callback) has not yet received and processed all rows.\n+   */\n+  private volatile CountDownLatch consumingLatch = new CountDownLatch(0);\n+\n+  AsyncResultSetImpl(ExecutorProvider executorProvider, ResultSet delegate, int bufferSize) {\n+    super(delegate);\n+    this.buffer = new LinkedBlockingDeque<>(bufferSize);\n+    this.executorProvider = executorProvider;\n+    this.service = MoreExecutors.listeningDecorator(executorProvider.getExecutor());\n+    this.delegateResultSet = delegate;\n+  }\n+\n+  /**\n+   * Closes the {@link AsyncResultSet}. {@link #close()} is non-blocking and may be called multiple\n+   * times without side effects. An {@link AsyncResultSet} may be closed before all rows have been\n+   * returned to the callback, and calling {@link #tryNext()} on a closed {@link AsyncResultSet} is\n+   * allowed as long as this is done from within a {@link ReadyCallback}. Calling {@link #resume()}\n+   * on a closed {@link AsyncResultSet} is also allowed.\n+   */\n+  @Override\n+  public void close() {\n+    synchronized (monitor) {\n+      if (this.closed) {\n+        return;\n+      }\n+      if (state == State.INITIALIZED || state == State.SYNC) {\n+        delegateResultSet.close();\n+      }\n+      this.closed = true;\n+    }\n+  }\n+\n+  /**\n+   * Adds a listener that will be called when no more rows will be read from the underlying {@link\n+   * ResultSet}, either because all rows have been read, or because {@link\n+   * ReadyCallback#cursorReady(AsyncResultSet)} returned {@link CallbackResponse#DONE}.\n+   */\n+  @Override\n+  public void addListener(Runnable listener) {\n+    Preconditions.checkState(state == State.INITIALIZED);\n+    listeners.add(listener);\n+  }\n+\n+  @Override\n+  public void removeListener(Runnable listener) {\n+    Preconditions.checkState(state == State.INITIALIZED);\n+    listeners.remove(listener);\n+  }\n+\n+  /**\n+   * Tries to advance this {@link AsyncResultSet} to the next row. This method may only be called\n+   * from within a {@link ReadyCallback}.\n+   */\n+  @Override\n+  public CursorState tryNext() throws SpannerException {\n+    synchronized (monitor) {\n+      if (state == State.CANCELLED) {\n+        cursorReturnedDoneOrException = true;\n+        throw CANCELLED_EXCEPTION;\n+      }\n+      if (buffer.isEmpty() && executionException != null) {\n+        cursorReturnedDoneOrException = true;\n+        throw executionException;\n+      }\n+      Preconditions.checkState(\n+          this.callback != null, \"tryNext may only be called after a callback has been set.\");\n+      Preconditions.checkState(\n+          this.state == State.CONSUMING,\n+          \"tryNext may only be called from a DataReady callback. Current state: \"\n+              + this.state.name());\n+\n+      if (finished && buffer.isEmpty()) {\n+        cursorReturnedDoneOrException = true;\n+        return CursorState.DONE;\n+      }\n+    }\n+    if (!buffer.isEmpty()) {\n+      // Set the next row from the buffer as the current row of the StructReader.\n+      replaceDelegate(currentRow = buffer.pop());\n+      synchronized (monitor) {\n+        bufferConsumptionLatch.countDown();\n+      }\n+      return CursorState.OK;\n+    }\n+    return CursorState.NOT_READY;\n+  }\n+\n+  /**\n+   * {@link CallbackRunnable} calls the {@link ReadyCallback} registered for this {@link\n+   * AsyncResultSet}.\n+   */\n+  private class CallbackRunnable implements Runnable {\n+    @Override\n+    public void run() {\n+      try {\n+        while (true) {\n+          synchronized (monitor) {\n+            if (cursorReturnedDoneOrException) {\n+              break;\n+            }\n+          }\n+          CallbackResponse response;\n+          try {\n+            response = callback.cursorReady(AsyncResultSetImpl.this);\n+          } catch (Throwable e) {\n+            synchronized (monitor) {\n+              if (cursorReturnedDoneOrException\n+                  && state == State.CANCELLED\n+                  && e instanceof SpannerException\n+                  && ((SpannerException) e).getErrorCode() == ErrorCode.CANCELLED) {\n+                // The callback did not catch the cancelled exception (which it should have), but\n+                // we'll keep the cancelled state.\n+                return;\n+              }\n+              executionException = SpannerExceptionFactory.newSpannerException(e);\n+              cursorReturnedDoneOrException = true;\n+            }\n+            return;\n+          }\n+          synchronized (monitor) {\n+            if (state == State.CANCELLED) {\n+              if (cursorReturnedDoneOrException) {\n+                return;\n+              }\n+            } else {\n+              switch (response) {\n+                case DONE:\n+                  state = State.DONE;\n+                  return;\n+                case PAUSE:\n+                  state = State.PAUSED;\n+                  // Make sure no-one else is waiting on the current pause latch and create a new\n+                  // one.\n+                  pausedLatch.countDown();\n+                  pausedLatch = new CountDownLatch(1);\n+                  return;\n+                case CONTINUE:\n+                  if (buffer.isEmpty()) {\n+                    // Call the callback once more if the entire result set has been processed but\n+                    // the callback has not yet received a CursorState.DONE or a CANCELLED error.\n+                    if (finished && !cursorReturnedDoneOrException) {\n+                      break;\n+                    }\n+                    state = State.RUNNING;\n+                    return;\n+                  }\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\"Unknown response: \" + response);\n+              }\n+            }\n+          }\n+        }\n+      } finally {\n+        synchronized (monitor) {\n+          // Count down all latches that the producer might be waiting on.\n+          consumingLatch.countDown();\n+          while (bufferConsumptionLatch.getCount() > 0L) {\n+            bufferConsumptionLatch.countDown();\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  private final CallbackRunnable callbackRunnable = new CallbackRunnable();\n+\n+  /**\n+   * {@link ProduceRowsCallable} reads data from the underlying {@link ResultSet}, places these in\n+   * the buffer and dispatches the {@link CallbackRunnable} when data is ready to be consumed.\n+   */\n+  private class ProduceRowsCallable implements Callable<Void> {\n+    @Override\n+    public Void call() throws Exception {\n+      boolean stop = false;\n+      boolean hasNext = false;\n+      try {\n+        hasNext = delegateResultSet.next();\n+      } catch (Throwable e) {\n+        synchronized (monitor) {\n+          executionException = SpannerExceptionFactory.newSpannerException(e);\n+        }\n+      }\n+      try {\n+        while (!stop && hasNext) {\n+          try {\n+            synchronized (monitor) {\n+              stop = state.shouldStop;\n+            }\n+            if (!stop) {\n+              while (buffer.remainingCapacity() == 0 && !stop) {\n+                waitIfPaused();\n+                // The buffer is full and we should let the callback consume a number of rows before\n+                // we proceed with producing any more rows to prevent us from potentially waiting on\n+                // a full buffer repeatedly.\n+                // Wait until at least half of the buffer is available, or if it's a bigger buffer,\n+                // wait until at least 10 rows can be placed in it.\n+                // TODO: Make this more dynamic / configurable?\n+                startCallbackWithBufferLatchIfNecessary(\n+                    Math.min(\n+                        Math.min(buffer.size() / 2 + 1, buffer.size()),\n+                        MAX_WAIT_FOR_BUFFER_CONSUMPTION));\n+                bufferConsumptionLatch.await();\n+                synchronized (monitor) {\n+                  stop = state.shouldStop;\n+                }\n+              }\n+            }\n+            if (!stop) {\n+              buffer.put(delegateResultSet.getCurrentRowAsStruct());\n+              startCallbackIfNecessary();\n+            }\n+            hasNext = delegateResultSet.next();\n+          } catch (Throwable e) {\n+            synchronized (monitor) {\n+              executionException = SpannerExceptionFactory.newSpannerException(e);\n+              stop = true;\n+            }\n+          }\n+        }\n+        // We don't need any more data from the underlying result set, so we close it as soon as\n+        // possible. Any error that might occur during this will be ignored.\n+        try {\n+          delegateResultSet.close();\n+        } catch (Throwable t) {", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyMTUzMg==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438721532", "bodyText": "Done.", "author": "olavloite", "createdAt": "2020-06-11T11:37:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgyNDM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgyODQwMg==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437828402", "bodyText": "Out of scope for this PR: should there be a concept of \"giving up\" if the session could not be replaced after N tries?", "author": "elefeint", "createdAt": "2020-06-10T02:41:50Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SessionPool.java", "diffHunk": "@@ -125,53 +135,117 @@ Instant instant() {\n     }\n   }\n \n+  private abstract static class CachedResultSetSupplier implements Supplier<ResultSet> {\n+    private ResultSet cached;\n+\n+    abstract ResultSet load();\n+\n+    ResultSet reload() {\n+      return cached = load();\n+    }\n+\n+    @Override\n+    public ResultSet get() {\n+      if (cached == null) {\n+        cached = load();\n+      }\n+      return cached;\n+    }\n+  }\n+\n   /**\n    * Wrapper around {@code ReadContext} that releases the session to the pool once the call is\n    * finished, if it is a single use context.\n    */\n   private static class AutoClosingReadContext<T extends ReadContext> implements ReadContext {\n-    private final Function<PooledSession, T> readContextDelegateSupplier;\n+    /**\n+     * {@link AsyncResultSet} implementation that keeps track of the async operations that are still\n+     * running for this {@link ReadContext} and that should finish before the {@link ReadContext}\n+     * releases its session back into the pool.\n+     */\n+    private class AutoClosingReadContextAsyncResultSetImpl extends AsyncResultSetImpl {\n+      private AutoClosingReadContextAsyncResultSetImpl(\n+          ExecutorProvider executorProvider, ResultSet delegate, int bufferRows) {\n+        super(executorProvider, delegate, bufferRows);\n+      }\n+\n+      @Override\n+      public ApiFuture<Void> setCallback(Executor exec, ReadyCallback cb) {\n+        Runnable listener =\n+            new Runnable() {\n+              @Override\n+              public void run() {\n+                synchronized (lock) {\n+                  if (asyncOperationsCount.decrementAndGet() == 0) {\n+                    if (closed) {\n+                      // All async operations for this read context have finished.\n+                      AutoClosingReadContext.this.close();\n+                    }\n+                  }\n+                }\n+              }\n+            };\n+        try {\n+          asyncOperationsCount.incrementAndGet();\n+          addListener(listener);\n+          return super.setCallback(exec, cb);\n+        } catch (Throwable t) {\n+          removeListener(listener);\n+          asyncOperationsCount.decrementAndGet();\n+          throw t;\n+        }\n+      }\n+    }\n+\n+    private final Function<PooledSessionFuture, T> readContextDelegateSupplier;\n     private T readContextDelegate;\n     private final SessionPool sessionPool;\n-    private PooledSession session;\n     private final boolean isSingleUse;\n-    private boolean closed;\n+    private final AtomicInteger asyncOperationsCount = new AtomicInteger();\n+\n+    private Object lock = new Object();\n+\n+    @GuardedBy(\"lock\")\n     private boolean sessionUsedForQuery = false;\n \n+    @GuardedBy(\"lock\")\n+    private PooledSessionFuture session;\n+\n+    @GuardedBy(\"lock\")\n+    private boolean closed;\n+\n+    @GuardedBy(\"lock\")\n+    private boolean delegateClosed;\n+\n     private AutoClosingReadContext(\n-        Function<PooledSession, T> delegateSupplier,\n+        Function<PooledSessionFuture, T> delegateSupplier,\n         SessionPool sessionPool,\n-        PooledSession session,\n+        PooledSessionFuture session,\n         boolean isSingleUse) {\n       this.readContextDelegateSupplier = delegateSupplier;\n       this.sessionPool = sessionPool;\n       this.session = session;\n       this.isSingleUse = isSingleUse;\n-      while (true) {\n-        try {\n-          this.readContextDelegate = readContextDelegateSupplier.apply(this.session);\n-          break;\n-        } catch (SessionNotFoundException e) {\n-          replaceSessionIfPossible(e);\n-        }\n-      }\n     }\n \n     T getReadContextDelegate() {\n+      synchronized (lock) {\n+        if (readContextDelegate == null) {\n+          while (true) {", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyMzkxMQ==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438723911", "bodyText": "The SessionNotFound exception should normally not bubble up to the client application, and it should in theory also not really be possible for it to continue getting such an exception, but I guess theory and reality could in extreme or unexpected circumstances disagree. The 'giving up' value should be set quite high in that case, as there is no normal scenario where it should be expected that this error bubbles up.", "author": "olavloite", "createdAt": "2020-06-11T11:42:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgyODQwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgyOTE3NA==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437829174", "bodyText": "Same question as above about giving up. As is currently, the exception will keep getting replaced by the latest one  but never actually bubble up to any calling code.", "author": "elefeint", "createdAt": "2020-06-10T02:44:49Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SessionPool.java", "diffHunk": "@@ -180,8 +254,18 @@ public boolean next() throws SpannerException {\n             try {\n               return internalNext();\n             } catch (SessionNotFoundException e) {\n-              replaceSessionIfPossible(e);\n-              replaceDelegate(resultSetSupplier.get());\n+              while (true) {\n+                // Keep the replace-if-possible outside the try-block to let the exception bubble up\n+                // if it's too late to replace the session.\n+                replaceSessionIfPossible(e);\n+                try {\n+                  replaceDelegate(resultSetSupplier.reload());\n+                  break;\n+                } catch (SessionNotFoundException snfe) {\n+                  e = snfe;", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyNDAyOQ==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438724029", "bodyText": "See above, same applies here.", "author": "olavloite", "createdAt": "2020-06-11T11:42:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgyOTE3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzMTIxMg==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437831212", "bodyText": "Remove stray commented line.", "author": "elefeint", "createdAt": "2020-06-10T02:52:31Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SessionPool.java", "diffHunk": "@@ -463,39 +717,41 @@ public void close() {\n \n     private TransactionManager delegate;\n     private final SessionPool sessionPool;\n-    private PooledSession session;\n+    private PooledSessionFuture session;\n     private boolean closed;\n     private boolean restartedAfterSessionNotFound;\n \n-    AutoClosingTransactionManager(SessionPool sessionPool, PooledSession session) {\n+    AutoClosingTransactionManager(SessionPool sessionPool, PooledSessionFuture session) {\n       this.sessionPool = sessionPool;\n       this.session = session;\n-      this.delegate = session.delegate.transactionManager();\n+      //      this.delegate = session.delegate.transactionManager();", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzMTg2MA==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437831860", "bodyText": "This call to get() looks like it will block waiting for results of the async work?", "author": "elefeint", "createdAt": "2020-06-10T02:55:22Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SessionPool.java", "diffHunk": "@@ -589,37 +851,104 @@ private SessionPoolTransactionRunner(SessionPool sessionPool, PooledSession sess\n         T result;\n         while (true) {\n           try {\n-            result = runner.run(callable);\n+            result = getRunner().run(callable);\n             break;\n           } catch (SessionNotFoundException e) {\n             session = sessionPool.replaceReadWriteSession(e, session);\n-            runner = session.delegate.readWriteTransaction();\n+            runner = session.get().delegate.readWriteTransaction();\n           }\n         }\n-        session.markUsed();\n+        session.get().markUsed();\n         return result;\n       } catch (SpannerException e) {\n-        throw session.lastException = e;\n+        throw session.get().lastException = e;\n       } finally {\n         session.close();\n       }\n     }\n \n     @Override\n     public Timestamp getCommitTimestamp() {\n-      return runner.getCommitTimestamp();\n+      return getRunner().getCommitTimestamp();\n     }\n \n     @Override\n     public TransactionRunner allowNestedTransaction() {\n-      runner.allowNestedTransaction();\n+      getRunner().allowNestedTransaction();\n       return this;\n     }\n   }\n \n+  private static class SessionPoolAsyncRunner implements AsyncRunner {\n+    private final SessionPool sessionPool;\n+    private volatile PooledSessionFuture session;\n+    private final SettableApiFuture<Timestamp> commitTimestamp = SettableApiFuture.create();\n+\n+    private SessionPoolAsyncRunner(SessionPool sessionPool, PooledSessionFuture session) {\n+      this.sessionPool = sessionPool;\n+      this.session = session;\n+    }\n+\n+    @Override\n+    public <R> ApiFuture<R> runAsync(final AsyncWork<R> work, Executor executor) {\n+      final SettableApiFuture<R> res = SettableApiFuture.create();\n+      executor.execute(\n+          new Runnable() {\n+            @Override\n+            public void run() {\n+              SpannerException se = null;\n+              R r = null;\n+              AsyncRunner runner = null;\n+              while (true) {\n+                try {\n+                  runner = session.get().runAsync();\n+                  r = runner.runAsync(work, MoreExecutors.directExecutor()).get();", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyNzE1OA==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438727158", "bodyText": "Yes, that is correct, but also intentional. This block is called inside the executor.execute(Runnable) method, which means that the outer block that is accessible for the client application is non-blocking.", "author": "olavloite", "createdAt": "2020-06-11T11:49:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzMTg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzMjgyMA==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437832820", "bodyText": "Log at INFO? Might be useful for diagnosing subtle issues.", "author": "elefeint", "createdAt": "2020-06-10T02:59:12Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SessionPool.java", "diffHunk": "@@ -806,6 +1107,176 @@ public TransactionRunner readWriteTransaction() {\n       return new SessionPoolTransactionRunner(SessionPool.this, this);\n     }\n \n+    @Override\n+    public TransactionManager transactionManager() {\n+      return new AutoClosingTransactionManager(SessionPool.this, this);\n+    }\n+\n+    @Override\n+    public AsyncRunner runAsync() {\n+      return new SessionPoolAsyncRunner(SessionPool.this, this);\n+    }\n+\n+    @Override\n+    public long executePartitionedUpdate(Statement stmt) {\n+      try {\n+        return get().executePartitionedUpdate(stmt);\n+      } finally {\n+        close();\n+      }\n+    }\n+\n+    @Override\n+    public String getName() {\n+      return get().getName();\n+    }\n+\n+    @Override\n+    public void prepareReadWriteTransaction() {\n+      get().prepareReadWriteTransaction();\n+    }\n+\n+    @Override\n+    public void close() {\n+      synchronized (lock) {\n+        leakedException = null;\n+        checkedOutSessions.remove(this);\n+      }\n+      get().close();\n+    }\n+\n+    @Override\n+    public ApiFuture<Empty> asyncClose() {\n+      synchronized (lock) {\n+        leakedException = null;\n+        checkedOutSessions.remove(this);\n+      }\n+      return get().asyncClose();\n+    }\n+\n+    @Override\n+    public PooledSession get() {\n+      if (inUse.compareAndSet(false, true)) {\n+        try {\n+          PooledSession res = super.get();\n+          synchronized (lock) {\n+            res.markBusy(span);\n+            span.addAnnotation(sessionAnnotation(res));\n+            incrementNumSessionsInUse();\n+            checkedOutSessions.add(this);\n+          }\n+          initialized.countDown();\n+        } catch (Throwable e) {\n+          initialized.countDown();\n+          // ignore and fallthrough.", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczMTM4Mw==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438731383", "bodyText": "I've restructured the code block a little. The exception is ignored here, because it can only be caused by the call to super.get(), and that will be handled in the block below. I've included that in the comment, and restructured the block so that only the call to super.get() that can actually cause an exception is in the try-block.", "author": "olavloite", "createdAt": "2020-06-11T11:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzMjgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzNjIzNw==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437836237", "bodyText": "This is a really long anonymous class implementation. Would it make sense to externalize it to a top-level class or at least least a nested class to improve readability of checkoutSession()?", "author": "elefeint", "createdAt": "2020-06-10T03:13:57Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SessionPool.java", "diffHunk": "@@ -1485,129 +1956,204 @@ PooledSession getReadSession() throws SpannerException {\n    *       to the pool which is then write prepared.\n    * </ol>\n    */\n-  PooledSession getReadWriteSession() {\n+  PooledSessionFuture getReadWriteSession() {\n     Span span = Tracing.getTracer().getCurrentSpan();\n     span.addAnnotation(\"Acquiring read write session\");\n     PooledSession sess = null;\n-    // Loop to retry SessionNotFoundExceptions that might occur during in-process prepare of a\n-    // session.\n-    while (true) {\n-      Waiter waiter = null;\n-      boolean inProcessPrepare = stopAutomaticPrepare;\n-      synchronized (lock) {\n-        if (closureFuture != null) {\n-          span.addAnnotation(\"Pool has been closed\");\n-          throw new IllegalStateException(\"Pool has been closed\");\n-        }\n-        if (resourceNotFoundException != null) {\n-          span.addAnnotation(\"Database has been deleted\");\n-          throw SpannerExceptionFactory.newSpannerException(\n-              ErrorCode.NOT_FOUND,\n-              String.format(\n-                  \"The session pool has been invalidated because a previous RPC returned 'Database not found': %s\",\n-                  resourceNotFoundException.getMessage()),\n-              resourceNotFoundException);\n-        }\n-        sess = writePreparedSessions.poll();\n-        if (sess == null) {\n-          if (!inProcessPrepare && numSessionsBeingPrepared <= prepareThreadPoolSize) {\n-            if (numSessionsBeingPrepared <= readWriteWaiters.size()) {\n-              PooledSession readSession = readSessions.poll();\n-              if (readSession != null) {\n-                span.addAnnotation(\n-                    \"Acquired read only session. Preparing for read write transaction\");\n-                prepareSession(readSession);\n-              } else {\n-                span.addAnnotation(\"No session available\");\n-                maybeCreateSession();\n-              }\n-            }\n-          } else {\n-            inProcessPrepare = true;\n-            numSessionsInProcessPrepared++;\n+    WaiterFuture waiter = null;\n+    boolean inProcessPrepare = stopAutomaticPrepare;\n+    synchronized (lock) {\n+      if (closureFuture != null) {\n+        span.addAnnotation(\"Pool has been closed\");\n+        throw new IllegalStateException(\"Pool has been closed\");\n+      }\n+      if (resourceNotFoundException != null) {\n+        span.addAnnotation(\"Database has been deleted\");\n+        throw SpannerExceptionFactory.newSpannerException(\n+            ErrorCode.NOT_FOUND,\n+            String.format(\n+                \"The session pool has been invalidated because a previous RPC returned 'Database not found': %s\",\n+                resourceNotFoundException.getMessage()),\n+            resourceNotFoundException);\n+      }\n+      sess = writePreparedSessions.poll();\n+      if (sess == null) {\n+        if (!inProcessPrepare && numSessionsBeingPrepared <= prepareThreadPoolSize) {\n+          if (numSessionsBeingPrepared <= readWriteWaiters.size()) {\n             PooledSession readSession = readSessions.poll();\n             if (readSession != null) {\n-              // Create a read/write transaction in-process if there is already a queue for prepared\n-              // sessions. This is more efficient than doing it asynchronously, as it scales with\n-              // the number of user threads. The thread pool for asynchronously preparing sessions\n-              // is fixed.\n               span.addAnnotation(\n-                  \"Acquired read only session. Preparing in-process for read write transaction\");\n-              sess = readSession;\n+                  \"Acquired read only session. Preparing for read write transaction\");\n+              prepareSession(readSession);\n             } else {\n               span.addAnnotation(\"No session available\");\n               maybeCreateSession();\n             }\n           }\n-          if (sess == null) {\n-            waiter = new Waiter();\n-            if (inProcessPrepare) {\n-              // inProcessPrepare=true means that we have already determined that the queue for\n-              // preparing read/write sessions is larger than the number of threads in the prepare\n-              // thread pool, and that it's more efficient to do the prepare in-process. We will\n-              // therefore create a waiter for a read-only session, even though a read/write session\n-              // has been requested.\n-              readWaiters.add(waiter);\n-            } else {\n-              readWriteWaiters.add(waiter);\n-            }\n-          }\n         } else {\n-          span.addAnnotation(\"Acquired read write session\");\n-        }\n-      }\n-      if (waiter != null) {\n-        logger.log(\n-            Level.FINE,\n-            \"No session available in the pool. Blocking for one to become available/created\");\n-        span.addAnnotation(\"Waiting for read write session to be available\");\n-        sess = waiter.take();\n-      }\n-      if (inProcessPrepare) {\n-        try {\n-          sess.prepareReadWriteTransaction();\n-          // Session prepare succeeded, restart automatic prepare if it had been stopped.\n-          synchronized (lock) {\n-            stopAutomaticPrepare = false;\n-          }\n-        } catch (Throwable t) {\n-          SpannerException e = newSpannerException(t);\n-          if (!isClosed()) {\n-            handlePrepareSessionFailure(e, sess, false);\n+          inProcessPrepare = true;\n+          numSessionsInProcessPrepared++;\n+          PooledSession readSession = readSessions.poll();\n+          if (readSession != null) {\n+            // Create a read/write transaction in-process if there is already a queue for prepared\n+            // sessions. This is more efficient than doing it asynchronously, as it scales with\n+            // the number of user threads. The thread pool for asynchronously preparing sessions\n+            // is fixed.\n+            span.addAnnotation(\n+                \"Acquired read only session. Preparing in-process for read write transaction\");\n+            sess = readSession;\n+          } else {\n+            span.addAnnotation(\"No session available\");\n+            maybeCreateSession();\n           }\n-          sess = null;\n-          if (!isSessionNotFound(e)) {\n-            throw e;\n+        }\n+        if (sess == null) {\n+          waiter = new WaiterFuture();\n+          if (inProcessPrepare) {\n+            // inProcessPrepare=true means that we have already determined that the queue for\n+            // preparing read/write sessions is larger than the number of threads in the prepare\n+            // thread pool, and that it's more efficient to do the prepare in-process. We will\n+            // therefore create a waiter for a read-only session, even though a read/write session\n+            // has been requested.\n+            readWaiters.add(waiter);\n+          } else {\n+            readWriteWaiters.add(waiter);\n           }\n         }\n+      } else {\n+        span.addAnnotation(\"Acquired read write session\");\n       }\n-      if (sess != null) {\n-        break;\n-      }\n+      return checkoutSession(span, sess, waiter, true, inProcessPrepare);\n     }\n-    sess.markBusy();\n-    incrementNumSessionsInUse();\n-    span.addAnnotation(sessionAnnotation(sess));\n-    return sess;\n   }\n \n-  PooledSession replaceReadSession(SessionNotFoundException e, PooledSession session) {\n+  private PooledSessionFuture checkoutSession(\n+      final Span span,\n+      final PooledSession readySession,\n+      WaiterFuture waiter,\n+      boolean write,\n+      final boolean inProcessPrepare) {\n+    Future<PooledSession> sessionFuture;\n+    if (waiter != null) {\n+      logger.log(\n+          Level.FINE,\n+          \"No session available in the pool. Blocking for one to become available/created\");\n+      span.addAnnotation(\n+          String.format(\n+              \"Waiting for %s session to be available\", write ? \"read write\" : \"read only\"));\n+      sessionFuture = waiter;\n+    } else {\n+      sessionFuture = ApiFutures.immediateFuture(readySession);\n+    }\n+    SimpleForwardingFuture<PooledSession> forwardingFuture =\n+        new SimpleForwardingFuture<SessionPool.PooledSession>(sessionFuture) {", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNjM1OQ==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438736359", "bodyText": "I've made a nested class and added some documentation. Externalizing it as a top-level class is less logical, as it depends heavily on the SessionPool class.", "author": "olavloite", "createdAt": "2020-06-11T12:09:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzNjIzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzNzM4OA==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437837388", "bodyText": "Should we specify \"spanner\" in the thread prefix? It can be hard to troubleshoot where wild threadpools come from when an application uses multiple client libraries..", "author": "elefeint", "createdAt": "2020-06-10T03:18:44Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SpannerOptions.java", "diffHunk": "@@ -134,6 +143,66 @@ public ServiceRpc create(SpannerOptions options) {\n     }\n   }\n \n+  private static final AtomicInteger DEFAULT_POOL_COUNT = new AtomicInteger();\n+\n+  /** {@link ExecutorProvider} that is used for {@link AsyncResultSet}. */\n+  interface CloseableExecutorProvider extends ExecutorProvider, AutoCloseable {\n+    /** Overridden to suppress the throws declaration of the super interface. */\n+    @Override\n+    public void close();\n+  }\n+\n+  static class FixedCloseableExecutorProvider implements CloseableExecutorProvider {\n+    private final ScheduledExecutorService executor;\n+\n+    private FixedCloseableExecutorProvider(ScheduledExecutorService executor) {\n+      this.executor = Preconditions.checkNotNull(executor);\n+    }\n+\n+    @Override\n+    public void close() {\n+      executor.shutdown();\n+    }\n+\n+    @Override\n+    public ScheduledExecutorService getExecutor() {\n+      return executor;\n+    }\n+\n+    @Override\n+    public boolean shouldAutoClose() {\n+      return false;\n+    }\n+\n+    /** Creates a FixedCloseableExecutorProvider. */\n+    static FixedCloseableExecutorProvider create(ScheduledExecutorService executor) {\n+      return new FixedCloseableExecutorProvider(executor);\n+    }\n+  }\n+\n+  /**\n+   * Default {@link ExecutorProvider} for high-level async calls that need an executor. The default\n+   * uses a cached thread pool containing a max of 8 threads. The pool is lazily initialized and\n+   * will not create any threads if the user application does not use any async methods. It will\n+   * also scale down the thread usage if the async load allows for that.\n+   */\n+  @VisibleForTesting\n+  static CloseableExecutorProvider createDefaultAsyncExecutorProvider() {\n+    return createAsyncExecutorProvider(8, 60L, TimeUnit.SECONDS);\n+  }\n+\n+  @VisibleForTesting\n+  static CloseableExecutorProvider createAsyncExecutorProvider(\n+      int poolSize, long keepAliveTime, TimeUnit unit) {\n+    String format = String.format(\"async-pool-%d-thread-%%d\", DEFAULT_POOL_COUNT.incrementAndGet());", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNjY1Nw==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438736657", "bodyText": "Good point, done.", "author": "olavloite", "createdAt": "2020-06-11T12:09:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzNzM4OA=="}], "type": "inlineReview"}, {"oid": "c662ed75db1d9e4630ef0d7289f95fb86b081925", "url": "https://github.com/googleapis/java-spanner/commit/c662ed75db1d9e4630ef0d7289f95fb86b081925", "message": "feat: steps to add async support for tx manager", "committedDate": "2020-06-10T08:35:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcwMjU4Mw==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437702583", "bodyText": "minor nit: I would suggest organizing the order of the nested members here - either to move all nested classes/interfaces to the bottom or move them closer to the first place they're used; for example ReadyCallback can be moved closer to setCallback", "author": "dzou", "createdAt": "2020-06-09T20:36:47Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncResultSet.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.common.base.Function;\n+import com.google.common.collect.ImmutableList;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+\n+/** Interface for result sets returned by async query methods. */\n+public interface AsyncResultSet extends ResultSet {", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc0NzUwMQ==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438747501", "bodyText": "I've re-organized the nested members so they are close to where they are first used, and in a (hopefully) logical order.", "author": "olavloite", "createdAt": "2020-06-11T12:31:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcwMjU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcwNTQ2MQ==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437705461", "bodyText": "Should this begin with <p>The transaction runner; looks like the paragraph was cut off from the starting sentence.", "author": "dzou", "createdAt": "2020-06-09T20:42:09Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncRunner.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.cloud.Timestamp;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+\n+public interface AsyncRunner {\n+\n+  interface AsyncWork<R> {\n+    /**\n+     * Performs a single transaction attempt. All reads/writes should be performed using {@code\n+     * txn}.\n+     *\n+     * <p>Implementations of this method should not attempt to commit the transaction directly:\n+     * returning normally will result in the runner attempting to commit the transaction once the\n+     * returned future completes, retrying on abort.\n+     *\n+     * <p>In most cases, the implementation will not need to catch {@code SpannerException}s from\n+     * Spanner operations, instead letting these propagate to the framework. The transaction runner\n+     *\n+     * <p>will take appropriate action based on the type of exception. In particular,", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc0OTY4MQ==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438749681", "bodyText": "Done.", "author": "olavloite", "createdAt": "2020-06-11T12:35:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcwNTQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxMDQzMA==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437710430", "bodyText": "For readability, you could rename the variable r to response to give hint on what R is.", "author": "dzou", "createdAt": "2020-06-09T20:49:06Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncRunnerImpl.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.api.core.SettableApiFuture;\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.TransactionRunner.TransactionCallable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+\n+class AsyncRunnerImpl implements AsyncRunner {\n+  private final TransactionRunnerImpl delegate;\n+  private final SettableApiFuture<Timestamp> commitTimestamp = SettableApiFuture.create();\n+\n+  AsyncRunnerImpl(TransactionRunnerImpl delegate) {\n+    this.delegate = delegate;\n+  }\n+\n+  @Override\n+  public <R> ApiFuture<R> runAsync(final AsyncWork<R> work, Executor executor) {\n+    final SettableApiFuture<R> res = SettableApiFuture.create();\n+    executor.execute(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            try {\n+              R r =", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc0OTg5MQ==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438749891", "bodyText": "Done.", "author": "olavloite", "createdAt": "2020-06-11T12:36:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxMDQzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxMTQzMw==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437711433", "bodyText": "Might need to add a short sentence clarifying the type R (which I assume refers to the response object type?).", "author": "dzou", "createdAt": "2020-06-09T20:50:17Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncRunner.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.cloud.Timestamp;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+\n+public interface AsyncRunner {\n+\n+  interface AsyncWork<R> {", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc1MDcyOA==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438750728", "bodyText": "Correct. I added a line of documentation to the interface declaration.", "author": "olavloite", "createdAt": "2020-06-11T12:37:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxMTQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxNjc1NQ==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437716755", "bodyText": "For this call - instead of calling .get() directly, should you instead set the value of the settable future in a callback? Something like:\nwork.doWorkAsync(transaction).addCallback((result) -> res.set(result));\n\nI might be misunderstanding this though.", "author": "dzou", "createdAt": "2020-06-09T20:56:40Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncRunnerImpl.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.api.core.SettableApiFuture;\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.TransactionRunner.TransactionCallable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+\n+class AsyncRunnerImpl implements AsyncRunner {\n+  private final TransactionRunnerImpl delegate;\n+  private final SettableApiFuture<Timestamp> commitTimestamp = SettableApiFuture.create();\n+\n+  AsyncRunnerImpl(TransactionRunnerImpl delegate) {\n+    this.delegate = delegate;\n+  }\n+\n+  @Override\n+  public <R> ApiFuture<R> runAsync(final AsyncWork<R> work, Executor executor) {\n+    final SettableApiFuture<R> res = SettableApiFuture.create();\n+    executor.execute(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            try {\n+              R r =\n+                  delegate.run(\n+                      new TransactionCallable<R>() {\n+                        @Override\n+                        public R run(TransactionContext transaction) throws Exception {\n+                          try {\n+                            return work.doWorkAsync(transaction).get();", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc1Mjg2MQ==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438752861", "bodyText": "No, getting the result like this here is intentional as we are wrapping the asynchronous transaction runner in a 'normal' transaction runner to re-use as much logic from it as possible.\nBy getting the result here and then catching the ExecutionException and InterruptedException, we can translate the exception to a SpannerException and re-throw that. That again will ensure that the delegate TransactionRunner will handle any aborted transactions (or other transient failures) for us.", "author": "olavloite", "createdAt": "2020-06-11T12:41:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxNjc1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkyNjkxMA==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438926910", "bodyText": "I see, thanks for clarifying.", "author": "dzou", "createdAt": "2020-06-11T16:45:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxNjc1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxNzQyNQ==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437717425", "bodyText": "Might be nice to move this to a separate private static helper method to reduce levels of nesting.", "author": "dzou", "createdAt": "2020-06-09T20:57:28Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncRunnerImpl.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.api.core.SettableApiFuture;\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.TransactionRunner.TransactionCallable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+\n+class AsyncRunnerImpl implements AsyncRunner {\n+  private final TransactionRunnerImpl delegate;\n+  private final SettableApiFuture<Timestamp> commitTimestamp = SettableApiFuture.create();\n+\n+  AsyncRunnerImpl(TransactionRunnerImpl delegate) {\n+    this.delegate = delegate;\n+  }\n+\n+  @Override\n+  public <R> ApiFuture<R> runAsync(final AsyncWork<R> work, Executor executor) {\n+    final SettableApiFuture<R> res = SettableApiFuture.create();\n+    executor.execute(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            try {\n+              R r =\n+                  delegate.run(\n+                      new TransactionCallable<R>() {", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc1NjY1MA==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438756650", "bodyText": "Done.", "author": "olavloite", "createdAt": "2020-06-11T12:48:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxNzQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyMTMwOA==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437721308", "bodyText": "No issues here - just wondering what use-cases a forwarding result set helps with.", "author": "dzou", "createdAt": "2020-06-09T21:03:32Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/ForwardingAsyncResultSet.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.common.base.Function;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import java.util.concurrent.Executor;\n+\n+/** Forwarding implementation of {@link AsyncResultSet} that forwards all calls to a delegate. */\n+public class ForwardingAsyncResultSet extends ForwardingResultSet implements AsyncResultSet {", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkxNjE3NA==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438916174", "bodyText": "It's used by read/write transactions to prevent the TransactionRunner from committing the transaction before all AsyncResultSets that have been created by the transaction have returned DONE from the cursorReady method.\nConsider this test case. It roughly executes the following flow:\n\nStart an asynchronous read/write transaction.\nExecute an asynchronous query in the read/write transaction and consume the result set using a background executor.\nThe doWorkAsync method finishes directly after starting the async query. The AsyncResultSet will at that moment probably still be processed by the background executor.\nThe underlying TransactionContext keeps track of the AsyncResultSets that have been opened, and will not commit the transaction until all AsyncResultSets and other async statements have finished.", "author": "olavloite", "createdAt": "2020-06-11T16:27:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyMTMwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk0OTc0OA==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438949748", "bodyText": "I see, thanks for the thorough response.", "author": "dzou", "createdAt": "2020-06-11T17:26:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyMTMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyNTAyMA==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437725020", "bodyText": "I saw that several of the ForwardingXReaders were modified to use suppliers - Just curious what was the rationale behind the decision? I suppose it must be covering a caching use case.", "author": "dzou", "createdAt": "2020-06-09T21:11:03Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/ForwardingStructReader.java", "diffHunk": "@@ -20,14 +20,20 @@\n import com.google.cloud.Date;\n import com.google.cloud.Timestamp;\n import com.google.common.base.Preconditions;\n+import com.google.common.base.Supplier;\n+import com.google.common.base.Suppliers;\n import java.util.List;\n \n /** Forwarding implements of StructReader */\n public class ForwardingStructReader implements StructReader {\n \n-  private StructReader delegate;\n+  private Supplier<? extends StructReader> delegate;", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkxMTY3MQ==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438911671", "bodyText": "This is to ensure that getting a session from the pool is always non-blocking. The client library hides all session management from the client application, but many of these classes are in one way or another a wrapper around a session. So in this specific case, instead of having to wait for the delegate StructReader to be available (i.e. for a Session to be returned from the pool), it is handed a supplier.", "author": "olavloite", "createdAt": "2020-06-11T16:20:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyNTAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyNjUwOA==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437726508", "bodyText": "No-op method could be removed? If it was intentionally no-op for override, you can add a comment to clarify reason.", "author": "dzou", "createdAt": "2020-06-09T21:14:21Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/PartitionedDMLTransaction.java", "diffHunk": "@@ -101,4 +102,7 @@ long executePartitionedUpdate(final Statement statement, final Duration timeout)\n   public void invalidate() {\n     isValid = false;\n   }\n+\n+  @Override\n+  public void setSpan(Span span) {}", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkxMTM1Mw==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438911353", "bodyText": "Yep, it's needed to implement the interface SessionTransaction. I added a comment for it.", "author": "olavloite", "createdAt": "2020-06-11T16:19:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyNjUwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzczMDg2NQ==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437730865", "bodyText": "public static is redundant for inner interfaces; seems like you may omit public from the enums too.", "author": "dzou", "createdAt": "2020-06-09T21:23:43Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncResultSet.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.common.base.Function;\n+import com.google.common.collect.ImmutableList;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+\n+/** Interface for result sets returned by async query methods. */\n+public interface AsyncResultSet extends ResultSet {\n+\n+  /**\n+   * Interface for receiving asynchronous callbacks when new data is ready. See {@link\n+   * AsyncResultSet#setCallback(Executor, ReadyCallback)}.\n+   */\n+  public static interface ReadyCallback {", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkxMTI3OQ==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438911279", "bodyText": "Done", "author": "olavloite", "createdAt": "2020-06-11T16:19:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzczMDg2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzczODY0Mg==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437738642", "bodyText": "If this is true, is there any penalty for writing a callback which consumes one result at a time and returns CONTINUE? (No usage of while(true) to consume everything in the resultset).\nSomething like:\n    public CallbackResponse cursorReady(AsyncResultSet rs) {\n      switch(rs.tryNext()) {\n        case OK:\n          System.out.println(rs.getRow());\n          return CallbackResponse.CONTINUE;\n        case NOT_READY:\n          return CallbackResponse.CONTINUE;\n      }\n      return CallbackResponse.DONE;\n    }\n\nI find this more intuitive than trying to remember that the resultset might have multiple rows of available data that should be consumed before calling CONTINUE. Curious what your thoughts are.", "author": "dzou", "createdAt": "2020-06-09T21:41:07Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncResultSet.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.common.base.Function;\n+import com.google.common.collect.ImmutableList;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+\n+/** Interface for result sets returned by async query methods. */\n+public interface AsyncResultSet extends ResultSet {\n+\n+  /**\n+   * Interface for receiving asynchronous callbacks when new data is ready. See {@link\n+   * AsyncResultSet#setCallback(Executor, ReadyCallback)}.\n+   */\n+  public static interface ReadyCallback {\n+    CallbackResponse cursorReady(AsyncResultSet resultSet);\n+  }\n+\n+  /** Response code from {@code tryNext()}. */\n+  public enum CursorState {\n+    /** Cursor has been moved to a new row. */\n+    OK,\n+    /** Read is complete, all rows have been consumed, and there are no more. */\n+    DONE,\n+    /** No further information known at this time, thus current row not available. */\n+    NOT_READY\n+  }\n+\n+  /**\n+   * Non-blocking call that attempts to step the cursor to the next position in the stream. The\n+   * cursor may be inspected only if the cursor returns {@code CursorState.OK}.\n+   *\n+   * <p>A caller will typically call {@link #tryNext()} in a loop inside the ReadyCallback,\n+   * consuming all results available. For more information see {@link #setCallback(Executor,\n+   * ReadyCallback)}.\n+   *\n+   * <p>Currently this method may only be called if a ReadyCallback has been registered. This is for\n+   * safety purposes only, and may be relaxed in future.\n+   *\n+   * @return current cursor readiness state\n+   * @throws SpannerException When an unrecoverable problem downstream occurs. Once this occurs you\n+   *     will get no further callbacks. You should return CallbackResponse.DONE back from callback.\n+   */\n+  CursorState tryNext() throws SpannerException;\n+\n+  /**\n+   * Register a callback with the ResultSet to be made aware when more data is available, changing\n+   * the usage pattern from sync to async. Details:\n+   *\n+   * <ul>\n+   *   <li>The callback will be called at least once.\n+   *   <li>The callback is run each time more results are available, or when we discover that there\n+   *       will be no more results. (unless paused, see below). Spurious callbacks are possible, see\n+   *       below.\n+   *   <li>Spanner guarantees that one callback is ever outstanding at a time. Also, future\n+   *       callbacks guarantee the \"happens before\" property with previous callbacks.\n+   *   <li>A callback normally consumes all available data in the ResultSet, and then returns {@link\n+   *       CallbackResponse#CONTINUE}.\n+   *   <li>If a callback returns {@link CallbackResponse#CONTINUE} with data still in the ResultSet,", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkxMTIzOQ==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438911239", "bodyText": "The documentation is (largely) copy-paste from the design document, but there is a (very small) performance penalty for just returning CONTINUE instead of looping over all available results. The AsyncResultSetImpl implementation will check whether the result set has been cancelled when the callback returns with CONTINUE. To do so, it needs to take an internal lock.", "author": "olavloite", "createdAt": "2020-06-11T16:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzczODY0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk0OTQ1OQ==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438949459", "bodyText": "I see, good to know, thanks!", "author": "dzou", "createdAt": "2020-06-11T17:25:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzczODY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0MDA3NQ==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437740075", "bodyText": "How are these executors shutdown after the async resultset is consumed or no longer used?", "author": "dzou", "createdAt": "2020-06-09T21:44:42Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/ResultSets.java", "diffHunk": "@@ -41,6 +43,21 @@ public static ResultSet forRows(Type type, Iterable<Struct> rows) {\n     return new PrePopulatedResultSet(type, rows);\n   }\n \n+  /** Converts the given {@link ResultSet} to an {@link AsyncResultSet}. */\n+  public static AsyncResultSet toAsyncResultSet(ResultSet delegate) {\n+    return new AsyncResultSetImpl(\n+        InstantiatingExecutorProvider.newBuilder()", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkxMDg5NA==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438910894", "bodyText": "InstantiatingExecutorProviders by default return true for #shouldAutoClose. That method is checked by the AsyncResultSetImpl when it has finished consuming the result set, and if it returns true, the executor is shutdown.", "author": "olavloite", "createdAt": "2020-06-11T16:19:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0MDA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0MjMzMA==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437742330", "bodyText": "Can this condition be written as if (asyncOperationsCount.decrementAndGet() == 0 && closed)?", "author": "dzou", "createdAt": "2020-06-09T21:50:03Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SessionPool.java", "diffHunk": "@@ -125,53 +135,117 @@ Instant instant() {\n     }\n   }\n \n+  private abstract static class CachedResultSetSupplier implements Supplier<ResultSet> {\n+    private ResultSet cached;\n+\n+    abstract ResultSet load();\n+\n+    ResultSet reload() {\n+      return cached = load();\n+    }\n+\n+    @Override\n+    public ResultSet get() {\n+      if (cached == null) {\n+        cached = load();\n+      }\n+      return cached;\n+    }\n+  }\n+\n   /**\n    * Wrapper around {@code ReadContext} that releases the session to the pool once the call is\n    * finished, if it is a single use context.\n    */\n   private static class AutoClosingReadContext<T extends ReadContext> implements ReadContext {\n-    private final Function<PooledSession, T> readContextDelegateSupplier;\n+    /**\n+     * {@link AsyncResultSet} implementation that keeps track of the async operations that are still\n+     * running for this {@link ReadContext} and that should finish before the {@link ReadContext}\n+     * releases its session back into the pool.\n+     */\n+    private class AutoClosingReadContextAsyncResultSetImpl extends AsyncResultSetImpl {\n+      private AutoClosingReadContextAsyncResultSetImpl(\n+          ExecutorProvider executorProvider, ResultSet delegate, int bufferRows) {\n+        super(executorProvider, delegate, bufferRows);\n+      }\n+\n+      @Override\n+      public ApiFuture<Void> setCallback(Executor exec, ReadyCallback cb) {\n+        Runnable listener =\n+            new Runnable() {\n+              @Override\n+              public void run() {\n+                synchronized (lock) {\n+                  if (asyncOperationsCount.decrementAndGet() == 0) {", "originalCommit": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkxMDkyNg==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r438910926", "bodyText": "Done.", "author": "olavloite", "createdAt": "2020-06-11T16:19:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0MjMzMA=="}], "type": "inlineReview"}, {"oid": "226f91bcaf0178c62d49156e6d973c26e66d3676", "url": "https://github.com/googleapis/java-spanner/commit/226f91bcaf0178c62d49156e6d973c26e66d3676", "message": "review: process review comments", "committedDate": "2020-06-11T16:30:44Z", "type": "commit"}, {"oid": "a10b61c54c0b0f8a79a5d8a2733424213e512823", "url": "https://github.com/googleapis/java-spanner/commit/a10b61c54c0b0f8a79a5d8a2733424213e512823", "message": "fix: run formatter", "committedDate": "2020-06-11T17:00:53Z", "type": "commit"}, {"oid": "64b8a349a85a9a16404939f3e9384eeb9f9b8eda", "url": "https://github.com/googleapis/java-spanner/commit/64b8a349a85a9a16404939f3e9384eeb9f9b8eda", "message": "chore: remove unused code", "committedDate": "2020-06-11T17:02:19Z", "type": "commit"}, {"oid": "3354344a4d1ce961e076b0ecddc036323da5e85b", "url": "https://github.com/googleapis/java-spanner/commit/3354344a4d1ce961e076b0ecddc036323da5e85b", "message": "clirr: add ignored differences to clirr", "committedDate": "2020-06-11T18:47:36Z", "type": "commit"}, {"oid": "2b2a6a4af0d382a18c051dd968560df2532cc7a4", "url": "https://github.com/googleapis/java-spanner/commit/2b2a6a4af0d382a18c051dd968560df2532cc7a4", "message": "Merge branch 'master' into async-api", "committedDate": "2020-06-12T05:46:21Z", "type": "commit"}, {"oid": "1fada1c780452a251507048b6580d168cb84b9a0", "url": "https://github.com/googleapis/java-spanner/commit/1fada1c780452a251507048b6580d168cb84b9a0", "message": "fix: call listeners after all rows have been consumed", "committedDate": "2020-06-12T09:17:21Z", "type": "commit"}, {"oid": "35743e6a8dc2949c9fd2d37a57233aa7a9b05759", "url": "https://github.com/googleapis/java-spanner/commit/35743e6a8dc2949c9fd2d37a57233aa7a9b05759", "message": "feat: towards AsyncTransactionManager", "committedDate": "2020-06-12T20:43:51Z", "type": "commit"}, {"oid": "48de42e7385d23514c8ae4b2ef11caa7f5ed2dd1", "url": "https://github.com/googleapis/java-spanner/commit/48de42e7385d23514c8ae4b2ef11caa7f5ed2dd1", "message": "Merge branch 'master' into async-api", "committedDate": "2020-06-13T06:14:18Z", "type": "commit"}, {"oid": "888edd819565eff78c3a48fbdca58de57d9c8869", "url": "https://github.com/googleapis/java-spanner/commit/888edd819565eff78c3a48fbdca58de57d9c8869", "message": "fix: session leaks + code format", "committedDate": "2020-06-13T13:43:49Z", "type": "commit"}, {"oid": "b2a7176d994aacc0b413d6cf19b2da42fae0f2bd", "url": "https://github.com/googleapis/java-spanner/commit/b2a7176d994aacc0b413d6cf19b2da42fae0f2bd", "message": "fix: more session leak fixes", "committedDate": "2020-06-13T14:48:15Z", "type": "commit"}, {"oid": "fba270fbf62f73bc0489a2ce8626e5b011ff1416", "url": "https://github.com/googleapis/java-spanner/commit/fba270fbf62f73bc0489a2ce8626e5b011ff1416", "message": "feat: further work on AsyncTransactionManager", "committedDate": "2020-06-14T20:10:40Z", "type": "commit"}, {"oid": "8a0ad3ff5db6c35d7a36a277d6b9154d47dd9c42", "url": "https://github.com/googleapis/java-spanner/commit/8a0ad3ff5db6c35d7a36a277d6b9154d47dd9c42", "message": "fix: fix test failures", "committedDate": "2020-06-15T06:22:39Z", "type": "commit"}, {"oid": "80224575e37ed9d0d906ae2de5d1bfbc1d35e370", "url": "https://github.com/googleapis/java-spanner/commit/80224575e37ed9d0d906ae2de5d1bfbc1d35e370", "message": "fix: fix several race conditions", "committedDate": "2020-06-15T20:29:03Z", "type": "commit"}, {"oid": "5e84d344896c53f2f18a4ad2e7cb9b58bc5b4e46", "url": "https://github.com/googleapis/java-spanner/commit/5e84d344896c53f2f18a4ad2e7cb9b58bc5b4e46", "message": "tests: increase test timeout", "committedDate": "2020-06-15T21:40:59Z", "type": "commit"}, {"oid": "707382b112d164768147119e527e9ace16db9391", "url": "https://github.com/googleapis/java-spanner/commit/707382b112d164768147119e527e9ace16db9391", "message": "Merge branch 'master' into async-api", "committedDate": "2020-06-21T05:54:53Z", "type": "commit"}, {"oid": "fcf37fda8ca063231d13055225f63f48d1508a4d", "url": "https://github.com/googleapis/java-spanner/commit/fcf37fda8ca063231d13055225f63f48d1508a4d", "message": "feat: further towards AsyncTransactionManager", "committedDate": "2020-06-21T10:48:19Z", "type": "commit"}, {"oid": "910b6c7d0eb62666061efaf25e43c2de42b0bc83", "url": "https://github.com/googleapis/java-spanner/commit/910b6c7d0eb62666061efaf25e43c2de42b0bc83", "message": "feat: require executor for transaction functions", "committedDate": "2020-06-21T16:15:49Z", "type": "commit"}, {"oid": "86f85c0545368160b7d5f93fb0492792f3337014", "url": "https://github.com/googleapis/java-spanner/commit/86f85c0545368160b7d5f93fb0492792f3337014", "message": "revert: remove async connection api from branch", "committedDate": "2020-06-21T18:06:31Z", "type": "commit"}, {"oid": "f5af48f511da94df8dec03a276f42a0908f6d1cd", "url": "https://github.com/googleapis/java-spanner/commit/f5af48f511da94df8dec03a276f42a0908f6d1cd", "message": "chore: run code formatter", "committedDate": "2020-06-21T18:30:38Z", "type": "commit"}, {"oid": "b38d16481c121c183aa1b781d50ee1f476954b2f", "url": "https://github.com/googleapis/java-spanner/commit/b38d16481c121c183aa1b781d50ee1f476954b2f", "message": "chore: fix flaky test case", "committedDate": "2020-06-21T18:50:01Z", "type": "commit"}, {"oid": "fda9f011f634fbd5ec5f1b7259d1e148dcb6c510", "url": "https://github.com/googleapis/java-spanner/commit/fda9f011f634fbd5ec5f1b7259d1e148dcb6c510", "message": "Merge branch 'master' into async-api", "committedDate": "2020-06-30T15:47:37Z", "type": "commit"}, {"oid": "eee881a80e106cd878bd61b1f96419a989937e0a", "url": "https://github.com/googleapis/java-spanner/commit/eee881a80e106cd878bd61b1f96419a989937e0a", "message": "tests: fix ITs for emulator", "committedDate": "2020-06-30T16:34:44Z", "type": "commit"}, {"oid": "a1ef6405d49286055f2f27ebc0861bb3ac7f9296", "url": "https://github.com/googleapis/java-spanner/commit/a1ef6405d49286055f2f27ebc0861bb3ac7f9296", "message": "fix: SpannerOptions.toBuilder().host should override emulatorHost", "committedDate": "2020-06-30T17:10:39Z", "type": "commit"}, {"oid": "ea45612620d9d5807f4de936aaf90a8e9c26833a", "url": "https://github.com/googleapis/java-spanner/commit/ea45612620d9d5807f4de936aaf90a8e9c26833a", "message": "tests: fix potentially hanging test", "committedDate": "2020-06-30T17:57:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTEzNjg1Nw==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r659136857", "bodyText": "how do we set asyncExecutorProvider?", "author": "pravsingh", "createdAt": "2021-06-26T08:02:37Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SpannerImpl.java", "diffHunk": "@@ -140,6 +149,13 @@ QueryOptions getDefaultQueryOptions(DatabaseId databaseId) {\n     return getOptions().getDefaultQueryOptions(databaseId);\n   }\n \n+  /**\n+   * Returns the {@link ExecutorProvider} to use for async methods that need a background executor.\n+   */\n+  public ExecutorProvider getAsyncExecutorProvider() {", "originalCommit": "ea45612620d9d5807f4de936aaf90a8e9c26833a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTI3NzU3Ng==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r659277576", "bodyText": "It's currently not configurable, and it will automatically use the default provided here: \n  \n    \n      java-spanner/google-cloud-spanner/src/main/java/com/google/cloud/spanner/SpannerOptions.java\n    \n    \n         Line 514\n      in\n      b2a56c6\n    \n    \n    \n    \n\n        \n          \n           static CloseableExecutorProvider createDefaultAsyncExecutorProvider() {", "author": "olavloite", "createdAt": "2021-06-27T07:31:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTEzNjg1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTM3NDAyNQ==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r659374025", "bodyText": "thanks for the quick reply Knut Olav .\nIs there a plan to make it configurable?", "author": "pravsingh", "createdAt": "2021-06-27T20:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTEzNjg1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTUyMDIyOA==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r659520228", "bodyText": "There's no concrete plan for it, but this feels like an omission to me. Would you mind submitting a feature request here: https://github.com/googleapis/java-spanner/issues/new?assignees=&labels=&template=feature_request.md", "author": "olavloite", "createdAt": "2021-06-28T06:47:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTEzNjg1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTYwMzExNg==", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r659603116", "bodyText": "thanks so much.\njust created this issue", "author": "pravsingh", "createdAt": "2021-06-28T08:55:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTEzNjg1Nw=="}], "type": "inlineReview"}]}