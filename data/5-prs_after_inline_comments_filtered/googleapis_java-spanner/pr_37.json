{"pr_number": 37, "pr_title": "test: [WIP] add Commit Timestamp java integration tests for cloud spanner", "pr_createdAt": "2020-01-16T07:25:32Z", "pr_url": "https://github.com/googleapis/java-spanner/pull/37", "timeline": [{"oid": "ec3d74aeae9bbbb68ba6d71e21bd7103762f04c7", "url": "https://github.com/googleapis/java-spanner/commit/ec3d74aeae9bbbb68ba6d71e21bd7103762f04c7", "message": "test: add Commit Timestamp java integration tests for cloud spanner", "committedDate": "2020-01-16T07:26:56Z", "type": "forcePushed"}, {"oid": "a58652628192f91c5749658925568de9afd15438", "url": "https://github.com/googleapis/java-spanner/commit/a58652628192f91c5749658925568de9afd15438", "message": "test: add Commit Timestamp java integration tests for cloud spanner", "committedDate": "2020-01-16T08:06:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQzNDI0Mw==", "url": "https://github.com/googleapis/java-spanner/pull/37#discussion_r367434243", "bodyText": "Could we also add an assertion that the commit timestamp returned by the write(...) method is equal to the commit timestamp written to these columns?", "author": "olavloite", "createdAt": "2020-01-16T14:05:04Z", "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/it/ITCommitTimestampTest.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/*\n+ * Copyright 2017 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner.it;\n+\n+import static com.google.cloud.spanner.SpannerMatchers.isSpannerException;\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.Database;\n+import com.google.cloud.spanner.DatabaseAdminClient;\n+import com.google.cloud.spanner.DatabaseClient;\n+import com.google.cloud.spanner.ErrorCode;\n+import com.google.cloud.spanner.IntegrationTest;\n+import com.google.cloud.spanner.IntegrationTestEnv;\n+import com.google.cloud.spanner.Key;\n+import com.google.cloud.spanner.Mutation;\n+import com.google.cloud.spanner.SpannerExceptionFactory;\n+import com.google.cloud.spanner.Struct;\n+import com.google.cloud.spanner.TimestampBound;\n+import com.google.cloud.spanner.Value;\n+import com.google.cloud.spanner.testing.RemoteSpannerHelper;\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.concurrent.ExecutionException;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Integration test for commit timestamp of Cloud Spanner. */\n+@Category(IntegrationTest.class)\n+@RunWith(JUnit4.class)\n+public class ITCommitTimestampTest {\n+  @ClassRule public static IntegrationTestEnv env = new IntegrationTestEnv();\n+  @Rule public final ExpectedException expectedException = ExpectedException.none();\n+  private Database db;\n+  private DatabaseClient client;\n+  private DatabaseAdminClient dbAdminClient;\n+  private RemoteSpannerHelper testHelper;\n+  private String instanceId;\n+  private String databaseId;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    testHelper = env.getTestHelper();\n+    db =\n+        testHelper.createTestDatabase(\n+            \"CREATE TABLE T (\"\n+                + \"K  STRING(MAX) NOT NULL,\"\n+                + \"T1   TIMESTAMP OPTIONS (allow_commit_timestamp = true),\"\n+                + \"T2   TIMESTAMP OPTIONS (allow_commit_timestamp = true),\"\n+                + \"T3   TIMESTAMP,\"\n+                + \") PRIMARY KEY (K)\");\n+    client = testHelper.getDatabaseClient(db);\n+    dbAdminClient = testHelper.getClient().getDatabaseAdminClient();\n+    instanceId = testHelper.getInstanceId().getInstance();\n+    databaseId = db.getId().getDatabase();\n+  }\n+\n+  private Timestamp write(Mutation m) {\n+    return client.write(Arrays.asList(m));\n+  }\n+\n+  private Struct readRow(DatabaseClient client, String table, Key key, String... columns) {\n+    return client.singleUse(TimestampBound.strong()).readRow(table, key, Arrays.asList(columns));\n+  }\n+\n+  @Test\n+  public void writeCommitTimestamp() {\n+    // 1. timestamps auto populated and returned should be the same\n+    Timestamp commitTimestamp =\n+        write(\n+            Mutation.newInsertOrUpdateBuilder(\"T\")\n+                .set(\"K\")\n+                .to(\"a\")\n+                .set(\"T1\")\n+                .to(Value.COMMIT_TIMESTAMP)\n+                .set(\"T2\")\n+                .to(Value.COMMIT_TIMESTAMP)\n+                .build());\n+    Struct row = readRow(client, \"T\", Key.of(\"a\"), \"T1\", \"T2\");\n+    assertThat(row.getTimestamp(0)).isEqualTo(commitTimestamp);\n+    assertThat(row.getTimestamp(1)).isEqualTo(commitTimestamp);", "originalCommit": "a58652628192f91c5749658925568de9afd15438", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyMTgwNA==", "url": "https://github.com/googleapis/java-spanner/pull/37#discussion_r369321804", "bodyText": "Apologies if I missed something here, but line number 102 and 103 are doing exactly that. They are checking that commitTimestamp returned by write method on line 91 is same as that written to the Key \"a\" for columns \"T1\" and \"T2\".", "author": "agasheesh", "createdAt": "2020-01-22T00:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQzNDI0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQxMTU0NQ==", "url": "https://github.com/googleapis/java-spanner/pull/37#discussion_r369411545", "bodyText": "Sorry, you're completely right, I have no idea where my mind was when I added that comment :-)", "author": "olavloite", "createdAt": "2020-01-22T07:56:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQzNDI0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQzOTE4NQ==", "url": "https://github.com/googleapis/java-spanner/pull/37#discussion_r367439185", "bodyText": "I would prefer these comments in Javadoc style and placed before the @Test annotation, i.e.:\n/**\n * 1) Write timestamps in the past\n * 2) ...\n*/\n@Test\npublic void interleavedTable() throws Exception {", "author": "olavloite", "createdAt": "2020-01-16T14:14:36Z", "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/it/ITCommitTimestampTest.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/*\n+ * Copyright 2017 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner.it;\n+\n+import static com.google.cloud.spanner.SpannerMatchers.isSpannerException;\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.Database;\n+import com.google.cloud.spanner.DatabaseAdminClient;\n+import com.google.cloud.spanner.DatabaseClient;\n+import com.google.cloud.spanner.ErrorCode;\n+import com.google.cloud.spanner.IntegrationTest;\n+import com.google.cloud.spanner.IntegrationTestEnv;\n+import com.google.cloud.spanner.Key;\n+import com.google.cloud.spanner.Mutation;\n+import com.google.cloud.spanner.SpannerExceptionFactory;\n+import com.google.cloud.spanner.Struct;\n+import com.google.cloud.spanner.TimestampBound;\n+import com.google.cloud.spanner.Value;\n+import com.google.cloud.spanner.testing.RemoteSpannerHelper;\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.concurrent.ExecutionException;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Integration test for commit timestamp of Cloud Spanner. */\n+@Category(IntegrationTest.class)\n+@RunWith(JUnit4.class)\n+public class ITCommitTimestampTest {\n+  @ClassRule public static IntegrationTestEnv env = new IntegrationTestEnv();\n+  @Rule public final ExpectedException expectedException = ExpectedException.none();\n+  private Database db;\n+  private DatabaseClient client;\n+  private DatabaseAdminClient dbAdminClient;\n+  private RemoteSpannerHelper testHelper;\n+  private String instanceId;\n+  private String databaseId;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    testHelper = env.getTestHelper();\n+    db =\n+        testHelper.createTestDatabase(\n+            \"CREATE TABLE T (\"\n+                + \"K  STRING(MAX) NOT NULL,\"\n+                + \"T1   TIMESTAMP OPTIONS (allow_commit_timestamp = true),\"\n+                + \"T2   TIMESTAMP OPTIONS (allow_commit_timestamp = true),\"\n+                + \"T3   TIMESTAMP,\"\n+                + \") PRIMARY KEY (K)\");\n+    client = testHelper.getDatabaseClient(db);\n+    dbAdminClient = testHelper.getClient().getDatabaseAdminClient();\n+    instanceId = testHelper.getInstanceId().getInstance();\n+    databaseId = db.getId().getDatabase();\n+  }\n+\n+  private Timestamp write(Mutation m) {\n+    return client.write(Arrays.asList(m));\n+  }\n+\n+  private Struct readRow(DatabaseClient client, String table, Key key, String... columns) {\n+    return client.singleUse(TimestampBound.strong()).readRow(table, key, Arrays.asList(columns));\n+  }\n+\n+  @Test\n+  public void writeCommitTimestamp() {\n+    // 1. timestamps auto populated and returned should be the same\n+    Timestamp commitTimestamp =\n+        write(\n+            Mutation.newInsertOrUpdateBuilder(\"T\")\n+                .set(\"K\")\n+                .to(\"a\")\n+                .set(\"T1\")\n+                .to(Value.COMMIT_TIMESTAMP)\n+                .set(\"T2\")\n+                .to(Value.COMMIT_TIMESTAMP)\n+                .build());\n+    Struct row = readRow(client, \"T\", Key.of(\"a\"), \"T1\", \"T2\");\n+    assertThat(row.getTimestamp(0)).isEqualTo(commitTimestamp);\n+    assertThat(row.getTimestamp(1)).isEqualTo(commitTimestamp);\n+\n+    // 2. attempt to write CommitTimestamp to not enabled column should fail\n+    // error_catalog error CommitTimestampOptionNotEnabled\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"allow_commit_timestamp column option is not\");\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T3\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+  }\n+\n+  @Test\n+  public void consistency() {\n+    // 1. timestamps populated are consistent in order\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T1\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"b\")\n+            .set(\"T1\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+    Struct row1 = readRow(client, \"T\", Key.of(\"a\"), \"T1\");\n+    Struct row2 = readRow(client, \"T\", Key.of(\"b\"), \"T1\");\n+    assertThat(row2.getTimestamp(0)).isGreaterThan(row1.getTimestamp(0));\n+  }\n+\n+  @Test\n+  public void schemaChangeTimestampInFuture() throws Exception {\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T3\")\n+            .to(Timestamp.MAX_VALUE)\n+            .build());\n+\n+    // error_catalog error CommitTimestampNotInFuture\n+    expectedException.expectCause(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"has a timestamp in the future at key\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (allow_commit_timestamp=true)\";\n+    try {\n+      dbAdminClient\n+          .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+          .get();\n+    } catch (ExecutionException e) {\n+      throw SpannerExceptionFactory.newSpannerException(e.getCause());\n+    }\n+  }\n+\n+  @Test\n+  public void insertTimestampInFuture() {\n+    // error_catalog error TimestampInFuture\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"in the future\");\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T1\")\n+            .to(Timestamp.MAX_VALUE)\n+            .build());\n+  }\n+\n+  @Test\n+  public void invalidColumnOption() throws Exception {\n+    // error_catalog error DDLStatementWithError\n+    expectedException.expectCause(isSpannerException(ErrorCode.INVALID_ARGUMENT));\n+    expectedException.expectMessage(\"Option: bogus is unknown.\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (bogus=null)\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  @Test\n+  public void invalidColumnOptionValue() throws Exception {\n+    // error_catalog error DDLStatementWithErrors\n+    expectedException.expectCause(isSpannerException(ErrorCode.INVALID_ARGUMENT));\n+    expectedException.expectMessage(\"Errors parsing Spanner DDL statement\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (allow_commit_timestamp=bogus)\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  @Test\n+  public void invalidColumnType() throws Exception {\n+    // error_catalog error OptionErrorList\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"Option only allowed on TIMESTAMP columns\");\n+    String statement = \"ALTER TABLE T ADD COLUMN T4 INT64 OPTIONS (allow_commit_timestamp=true)\";\n+    try {\n+      dbAdminClient\n+          .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+          .get();\n+    } catch (ExecutionException e) {\n+      throw SpannerExceptionFactory.newSpannerException(e.getCause());\n+    }\n+  }\n+\n+  private void alterColumnOption(String databaseId, String table, String opt) throws Exception {\n+    String statement =\n+        \"ALTER TABLE \"\n+            + table\n+            + \" ALTER COLUMN ts\"\n+            + \" SET OPTIONS (allow_commit_timestamp=\"\n+            + opt\n+            + \")\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  private void writeAndVerify(DatabaseClient client, Timestamp ts) {\n+    Timestamp commitTimestamp =\n+        client.write(\n+            Arrays.asList(\n+                Mutation.newInsertOrUpdateBuilder(\"T1\").set(\"ts\").to(ts).build(),\n+                Mutation.newInsertOrUpdateBuilder(\"T2\").set(\"ts\").to(ts).build(),\n+                Mutation.newInsertOrUpdateBuilder(\"T3\").set(\"ts\").to(ts).build()));\n+    if (ts == Value.COMMIT_TIMESTAMP) {\n+      ts = commitTimestamp;\n+    }\n+    assertThat(readRow(client, \"T1\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+    assertThat(readRow(client, \"T2\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+    assertThat(readRow(client, \"T3\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+  }\n+\n+  @Test\n+  // 1) Write timestamps in the past", "originalCommit": "a58652628192f91c5749658925568de9afd15438", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyMjYwOQ==", "url": "https://github.com/googleapis/java-spanner/pull/37#discussion_r369322609", "bodyText": "Done @ d920e96.", "author": "agasheesh", "createdAt": "2020-01-22T00:54:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQzOTE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ0MDQ5MA==", "url": "https://github.com/googleapis/java-spanner/pull/37#discussion_r367440490", "bodyText": "Using TimeUnit.MICROSECONDS.convert(Instant.now().toEpochMilli(), TimeUnit.MILLISECONDS) instead of millis * 1000 reduces the chances of ever making a calculation mistake when converting time values between different units.\nAlso: Using the actual current system time makes this test case depend on the fact that the local system time will not be lagging behind the time of the backend. I think it would be better to use a fixed time here as well, or at least add a negative value to the current local system time to reduce the probability that a small discrepancy between the two would make the test case fail.", "author": "olavloite", "createdAt": "2020-01-16T14:17:03Z", "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/it/ITCommitTimestampTest.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/*\n+ * Copyright 2017 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner.it;\n+\n+import static com.google.cloud.spanner.SpannerMatchers.isSpannerException;\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.Database;\n+import com.google.cloud.spanner.DatabaseAdminClient;\n+import com.google.cloud.spanner.DatabaseClient;\n+import com.google.cloud.spanner.ErrorCode;\n+import com.google.cloud.spanner.IntegrationTest;\n+import com.google.cloud.spanner.IntegrationTestEnv;\n+import com.google.cloud.spanner.Key;\n+import com.google.cloud.spanner.Mutation;\n+import com.google.cloud.spanner.SpannerExceptionFactory;\n+import com.google.cloud.spanner.Struct;\n+import com.google.cloud.spanner.TimestampBound;\n+import com.google.cloud.spanner.Value;\n+import com.google.cloud.spanner.testing.RemoteSpannerHelper;\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.concurrent.ExecutionException;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Integration test for commit timestamp of Cloud Spanner. */\n+@Category(IntegrationTest.class)\n+@RunWith(JUnit4.class)\n+public class ITCommitTimestampTest {\n+  @ClassRule public static IntegrationTestEnv env = new IntegrationTestEnv();\n+  @Rule public final ExpectedException expectedException = ExpectedException.none();\n+  private Database db;\n+  private DatabaseClient client;\n+  private DatabaseAdminClient dbAdminClient;\n+  private RemoteSpannerHelper testHelper;\n+  private String instanceId;\n+  private String databaseId;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    testHelper = env.getTestHelper();\n+    db =\n+        testHelper.createTestDatabase(\n+            \"CREATE TABLE T (\"\n+                + \"K  STRING(MAX) NOT NULL,\"\n+                + \"T1   TIMESTAMP OPTIONS (allow_commit_timestamp = true),\"\n+                + \"T2   TIMESTAMP OPTIONS (allow_commit_timestamp = true),\"\n+                + \"T3   TIMESTAMP,\"\n+                + \") PRIMARY KEY (K)\");\n+    client = testHelper.getDatabaseClient(db);\n+    dbAdminClient = testHelper.getClient().getDatabaseAdminClient();\n+    instanceId = testHelper.getInstanceId().getInstance();\n+    databaseId = db.getId().getDatabase();\n+  }\n+\n+  private Timestamp write(Mutation m) {\n+    return client.write(Arrays.asList(m));\n+  }\n+\n+  private Struct readRow(DatabaseClient client, String table, Key key, String... columns) {\n+    return client.singleUse(TimestampBound.strong()).readRow(table, key, Arrays.asList(columns));\n+  }\n+\n+  @Test\n+  public void writeCommitTimestamp() {\n+    // 1. timestamps auto populated and returned should be the same\n+    Timestamp commitTimestamp =\n+        write(\n+            Mutation.newInsertOrUpdateBuilder(\"T\")\n+                .set(\"K\")\n+                .to(\"a\")\n+                .set(\"T1\")\n+                .to(Value.COMMIT_TIMESTAMP)\n+                .set(\"T2\")\n+                .to(Value.COMMIT_TIMESTAMP)\n+                .build());\n+    Struct row = readRow(client, \"T\", Key.of(\"a\"), \"T1\", \"T2\");\n+    assertThat(row.getTimestamp(0)).isEqualTo(commitTimestamp);\n+    assertThat(row.getTimestamp(1)).isEqualTo(commitTimestamp);\n+\n+    // 2. attempt to write CommitTimestamp to not enabled column should fail\n+    // error_catalog error CommitTimestampOptionNotEnabled\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"allow_commit_timestamp column option is not\");\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T3\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+  }\n+\n+  @Test\n+  public void consistency() {\n+    // 1. timestamps populated are consistent in order\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T1\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"b\")\n+            .set(\"T1\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+    Struct row1 = readRow(client, \"T\", Key.of(\"a\"), \"T1\");\n+    Struct row2 = readRow(client, \"T\", Key.of(\"b\"), \"T1\");\n+    assertThat(row2.getTimestamp(0)).isGreaterThan(row1.getTimestamp(0));\n+  }\n+\n+  @Test\n+  public void schemaChangeTimestampInFuture() throws Exception {\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T3\")\n+            .to(Timestamp.MAX_VALUE)\n+            .build());\n+\n+    // error_catalog error CommitTimestampNotInFuture\n+    expectedException.expectCause(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"has a timestamp in the future at key\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (allow_commit_timestamp=true)\";\n+    try {\n+      dbAdminClient\n+          .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+          .get();\n+    } catch (ExecutionException e) {\n+      throw SpannerExceptionFactory.newSpannerException(e.getCause());\n+    }\n+  }\n+\n+  @Test\n+  public void insertTimestampInFuture() {\n+    // error_catalog error TimestampInFuture\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"in the future\");\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T1\")\n+            .to(Timestamp.MAX_VALUE)\n+            .build());\n+  }\n+\n+  @Test\n+  public void invalidColumnOption() throws Exception {\n+    // error_catalog error DDLStatementWithError\n+    expectedException.expectCause(isSpannerException(ErrorCode.INVALID_ARGUMENT));\n+    expectedException.expectMessage(\"Option: bogus is unknown.\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (bogus=null)\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  @Test\n+  public void invalidColumnOptionValue() throws Exception {\n+    // error_catalog error DDLStatementWithErrors\n+    expectedException.expectCause(isSpannerException(ErrorCode.INVALID_ARGUMENT));\n+    expectedException.expectMessage(\"Errors parsing Spanner DDL statement\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (allow_commit_timestamp=bogus)\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  @Test\n+  public void invalidColumnType() throws Exception {\n+    // error_catalog error OptionErrorList\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"Option only allowed on TIMESTAMP columns\");\n+    String statement = \"ALTER TABLE T ADD COLUMN T4 INT64 OPTIONS (allow_commit_timestamp=true)\";\n+    try {\n+      dbAdminClient\n+          .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+          .get();\n+    } catch (ExecutionException e) {\n+      throw SpannerExceptionFactory.newSpannerException(e.getCause());\n+    }\n+  }\n+\n+  private void alterColumnOption(String databaseId, String table, String opt) throws Exception {\n+    String statement =\n+        \"ALTER TABLE \"\n+            + table\n+            + \" ALTER COLUMN ts\"\n+            + \" SET OPTIONS (allow_commit_timestamp=\"\n+            + opt\n+            + \")\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  private void writeAndVerify(DatabaseClient client, Timestamp ts) {\n+    Timestamp commitTimestamp =\n+        client.write(\n+            Arrays.asList(\n+                Mutation.newInsertOrUpdateBuilder(\"T1\").set(\"ts\").to(ts).build(),\n+                Mutation.newInsertOrUpdateBuilder(\"T2\").set(\"ts\").to(ts).build(),\n+                Mutation.newInsertOrUpdateBuilder(\"T3\").set(\"ts\").to(ts).build()));\n+    if (ts == Value.COMMIT_TIMESTAMP) {\n+      ts = commitTimestamp;\n+    }\n+    assertThat(readRow(client, \"T1\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+    assertThat(readRow(client, \"T2\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+    assertThat(readRow(client, \"T3\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+  }\n+\n+  @Test\n+  // 1) Write timestamps in the past\n+  // 2) Set all interleaved tables allow_commmit_timestamp=true\n+  // 3) Use commit timestamp in all tables\n+  // 4) Set all interleaved tables allow_commmit_timestamp=null\n+  // 5) Write timestamps in the future\n+  public void interleavedTable() throws Exception {\n+    Database db =\n+        testHelper.createTestDatabase(\n+            \"CREATE TABLE T1 (ts TIMESTAMP) PRIMARY KEY (ts)\",\n+            \"CREATE TABLE T2 (ts TIMESTAMP) PRIMARY KEY (ts), INTERLEAVE IN PARENT T1\",\n+            \"CREATE TABLE T3 (ts TIMESTAMP) PRIMARY KEY (ts), INTERLEAVE IN PARENT T2\");\n+    DatabaseClient client = testHelper.getDatabaseClient(db);\n+    String databaseId = db.getId().getDatabase();\n+\n+    Timestamp timeNow = Timestamp.ofTimeMicroseconds(Instant.now().toEpochMilli() * 1000);", "originalCommit": "a58652628192f91c5749658925568de9afd15438", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyMzI0Nw==", "url": "https://github.com/googleapis/java-spanner/pull/37#discussion_r369323247", "bodyText": "I see your point, but this test has been successfully passing in current format since always. Would prefer keeping it this way.", "author": "agasheesh", "createdAt": "2020-01-22T00:56:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ0MDQ5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQxMTY4MA==", "url": "https://github.com/googleapis/java-spanner/pull/37#discussion_r369411680", "bodyText": "Ack.", "author": "olavloite", "createdAt": "2020-01-22T07:57:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ0MDQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ0Mjc0Mg==", "url": "https://github.com/googleapis/java-spanner/pull/37#discussion_r367442742", "bodyText": "Same as above.", "author": "olavloite", "createdAt": "2020-01-16T14:21:11Z", "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/it/ITCommitTimestampTest.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/*\n+ * Copyright 2017 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner.it;\n+\n+import static com.google.cloud.spanner.SpannerMatchers.isSpannerException;\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.Database;\n+import com.google.cloud.spanner.DatabaseAdminClient;\n+import com.google.cloud.spanner.DatabaseClient;\n+import com.google.cloud.spanner.ErrorCode;\n+import com.google.cloud.spanner.IntegrationTest;\n+import com.google.cloud.spanner.IntegrationTestEnv;\n+import com.google.cloud.spanner.Key;\n+import com.google.cloud.spanner.Mutation;\n+import com.google.cloud.spanner.SpannerExceptionFactory;\n+import com.google.cloud.spanner.Struct;\n+import com.google.cloud.spanner.TimestampBound;\n+import com.google.cloud.spanner.Value;\n+import com.google.cloud.spanner.testing.RemoteSpannerHelper;\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.concurrent.ExecutionException;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Integration test for commit timestamp of Cloud Spanner. */\n+@Category(IntegrationTest.class)\n+@RunWith(JUnit4.class)\n+public class ITCommitTimestampTest {\n+  @ClassRule public static IntegrationTestEnv env = new IntegrationTestEnv();\n+  @Rule public final ExpectedException expectedException = ExpectedException.none();\n+  private Database db;\n+  private DatabaseClient client;\n+  private DatabaseAdminClient dbAdminClient;\n+  private RemoteSpannerHelper testHelper;\n+  private String instanceId;\n+  private String databaseId;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    testHelper = env.getTestHelper();\n+    db =\n+        testHelper.createTestDatabase(\n+            \"CREATE TABLE T (\"\n+                + \"K  STRING(MAX) NOT NULL,\"\n+                + \"T1   TIMESTAMP OPTIONS (allow_commit_timestamp = true),\"\n+                + \"T2   TIMESTAMP OPTIONS (allow_commit_timestamp = true),\"\n+                + \"T3   TIMESTAMP,\"\n+                + \") PRIMARY KEY (K)\");\n+    client = testHelper.getDatabaseClient(db);\n+    dbAdminClient = testHelper.getClient().getDatabaseAdminClient();\n+    instanceId = testHelper.getInstanceId().getInstance();\n+    databaseId = db.getId().getDatabase();\n+  }\n+\n+  private Timestamp write(Mutation m) {\n+    return client.write(Arrays.asList(m));\n+  }\n+\n+  private Struct readRow(DatabaseClient client, String table, Key key, String... columns) {\n+    return client.singleUse(TimestampBound.strong()).readRow(table, key, Arrays.asList(columns));\n+  }\n+\n+  @Test\n+  public void writeCommitTimestamp() {\n+    // 1. timestamps auto populated and returned should be the same\n+    Timestamp commitTimestamp =\n+        write(\n+            Mutation.newInsertOrUpdateBuilder(\"T\")\n+                .set(\"K\")\n+                .to(\"a\")\n+                .set(\"T1\")\n+                .to(Value.COMMIT_TIMESTAMP)\n+                .set(\"T2\")\n+                .to(Value.COMMIT_TIMESTAMP)\n+                .build());\n+    Struct row = readRow(client, \"T\", Key.of(\"a\"), \"T1\", \"T2\");\n+    assertThat(row.getTimestamp(0)).isEqualTo(commitTimestamp);\n+    assertThat(row.getTimestamp(1)).isEqualTo(commitTimestamp);\n+\n+    // 2. attempt to write CommitTimestamp to not enabled column should fail\n+    // error_catalog error CommitTimestampOptionNotEnabled\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"allow_commit_timestamp column option is not\");\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T3\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+  }\n+\n+  @Test\n+  public void consistency() {\n+    // 1. timestamps populated are consistent in order\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T1\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"b\")\n+            .set(\"T1\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+    Struct row1 = readRow(client, \"T\", Key.of(\"a\"), \"T1\");\n+    Struct row2 = readRow(client, \"T\", Key.of(\"b\"), \"T1\");\n+    assertThat(row2.getTimestamp(0)).isGreaterThan(row1.getTimestamp(0));\n+  }\n+\n+  @Test\n+  public void schemaChangeTimestampInFuture() throws Exception {\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T3\")\n+            .to(Timestamp.MAX_VALUE)\n+            .build());\n+\n+    // error_catalog error CommitTimestampNotInFuture\n+    expectedException.expectCause(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"has a timestamp in the future at key\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (allow_commit_timestamp=true)\";\n+    try {\n+      dbAdminClient\n+          .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+          .get();\n+    } catch (ExecutionException e) {\n+      throw SpannerExceptionFactory.newSpannerException(e.getCause());\n+    }\n+  }\n+\n+  @Test\n+  public void insertTimestampInFuture() {\n+    // error_catalog error TimestampInFuture\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"in the future\");\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T1\")\n+            .to(Timestamp.MAX_VALUE)\n+            .build());\n+  }\n+\n+  @Test\n+  public void invalidColumnOption() throws Exception {\n+    // error_catalog error DDLStatementWithError\n+    expectedException.expectCause(isSpannerException(ErrorCode.INVALID_ARGUMENT));\n+    expectedException.expectMessage(\"Option: bogus is unknown.\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (bogus=null)\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  @Test\n+  public void invalidColumnOptionValue() throws Exception {\n+    // error_catalog error DDLStatementWithErrors\n+    expectedException.expectCause(isSpannerException(ErrorCode.INVALID_ARGUMENT));\n+    expectedException.expectMessage(\"Errors parsing Spanner DDL statement\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (allow_commit_timestamp=bogus)\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  @Test\n+  public void invalidColumnType() throws Exception {\n+    // error_catalog error OptionErrorList\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"Option only allowed on TIMESTAMP columns\");\n+    String statement = \"ALTER TABLE T ADD COLUMN T4 INT64 OPTIONS (allow_commit_timestamp=true)\";\n+    try {\n+      dbAdminClient\n+          .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+          .get();\n+    } catch (ExecutionException e) {\n+      throw SpannerExceptionFactory.newSpannerException(e.getCause());\n+    }\n+  }\n+\n+  private void alterColumnOption(String databaseId, String table, String opt) throws Exception {\n+    String statement =\n+        \"ALTER TABLE \"\n+            + table\n+            + \" ALTER COLUMN ts\"\n+            + \" SET OPTIONS (allow_commit_timestamp=\"\n+            + opt\n+            + \")\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  private void writeAndVerify(DatabaseClient client, Timestamp ts) {\n+    Timestamp commitTimestamp =\n+        client.write(\n+            Arrays.asList(\n+                Mutation.newInsertOrUpdateBuilder(\"T1\").set(\"ts\").to(ts).build(),\n+                Mutation.newInsertOrUpdateBuilder(\"T2\").set(\"ts\").to(ts).build(),\n+                Mutation.newInsertOrUpdateBuilder(\"T3\").set(\"ts\").to(ts).build()));\n+    if (ts == Value.COMMIT_TIMESTAMP) {\n+      ts = commitTimestamp;\n+    }\n+    assertThat(readRow(client, \"T1\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+    assertThat(readRow(client, \"T2\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+    assertThat(readRow(client, \"T3\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+  }\n+\n+  @Test\n+  // 1) Write timestamps in the past\n+  // 2) Set all interleaved tables allow_commmit_timestamp=true\n+  // 3) Use commit timestamp in all tables\n+  // 4) Set all interleaved tables allow_commmit_timestamp=null\n+  // 5) Write timestamps in the future\n+  public void interleavedTable() throws Exception {\n+    Database db =\n+        testHelper.createTestDatabase(\n+            \"CREATE TABLE T1 (ts TIMESTAMP) PRIMARY KEY (ts)\",\n+            \"CREATE TABLE T2 (ts TIMESTAMP) PRIMARY KEY (ts), INTERLEAVE IN PARENT T1\",\n+            \"CREATE TABLE T3 (ts TIMESTAMP) PRIMARY KEY (ts), INTERLEAVE IN PARENT T2\");\n+    DatabaseClient client = testHelper.getDatabaseClient(db);\n+    String databaseId = db.getId().getDatabase();\n+\n+    Timestamp timeNow = Timestamp.ofTimeMicroseconds(Instant.now().toEpochMilli() * 1000);\n+    Timestamp timeFuture =\n+        Timestamp.ofTimeMicroseconds(\n+            Instant.now().plus(Duration.ofDays(300)).toEpochMilli() * 1000);\n+\n+    writeAndVerify(client, timeNow);\n+\n+    alterColumnOption(databaseId, \"T1\", \"true\");\n+    alterColumnOption(databaseId, \"T2\", \"true\");\n+    alterColumnOption(databaseId, \"T3\", \"true\");\n+    writeAndVerify(client, Value.COMMIT_TIMESTAMP);\n+\n+    alterColumnOption(databaseId, \"T1\", \"null\");\n+    alterColumnOption(databaseId, \"T2\", \"null\");\n+    alterColumnOption(databaseId, \"T3\", \"null\");\n+    writeAndVerify(client, timeFuture);\n+  }\n+\n+  @Test\n+  // In interleaved table, use of commit timestamp in child table is not allowed", "originalCommit": "a58652628192f91c5749658925568de9afd15438", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyMjY2MA==", "url": "https://github.com/googleapis/java-spanner/pull/37#discussion_r369322660", "bodyText": "Done @ d920e96", "author": "agasheesh", "createdAt": "2020-01-22T00:54:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ0Mjc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ0Mjk5OA==", "url": "https://github.com/googleapis/java-spanner/pull/37#discussion_r367442998", "bodyText": "Not supported in Java 7, use org.threeten.bp.Duration instead.", "author": "olavloite", "createdAt": "2020-01-16T14:21:41Z", "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/it/ITCommitTimestampTest.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/*\n+ * Copyright 2017 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner.it;\n+\n+import static com.google.cloud.spanner.SpannerMatchers.isSpannerException;\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.Database;\n+import com.google.cloud.spanner.DatabaseAdminClient;\n+import com.google.cloud.spanner.DatabaseClient;\n+import com.google.cloud.spanner.ErrorCode;\n+import com.google.cloud.spanner.IntegrationTest;\n+import com.google.cloud.spanner.IntegrationTestEnv;\n+import com.google.cloud.spanner.Key;\n+import com.google.cloud.spanner.Mutation;\n+import com.google.cloud.spanner.SpannerExceptionFactory;\n+import com.google.cloud.spanner.Struct;\n+import com.google.cloud.spanner.TimestampBound;\n+import com.google.cloud.spanner.Value;\n+import com.google.cloud.spanner.testing.RemoteSpannerHelper;\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;", "originalCommit": "a58652628192f91c5749658925568de9afd15438", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyNDk5MA==", "url": "https://github.com/googleapis/java-spanner/pull/37#discussion_r369324990", "bodyText": "Done @ 24faebe", "author": "agasheesh", "createdAt": "2020-01-22T01:04:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ0Mjk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ0MzExMQ==", "url": "https://github.com/googleapis/java-spanner/pull/37#discussion_r367443111", "bodyText": "Same as above.", "author": "olavloite", "createdAt": "2020-01-16T14:21:52Z", "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/it/ITCommitTimestampTest.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/*\n+ * Copyright 2017 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner.it;\n+\n+import static com.google.cloud.spanner.SpannerMatchers.isSpannerException;\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.Database;\n+import com.google.cloud.spanner.DatabaseAdminClient;\n+import com.google.cloud.spanner.DatabaseClient;\n+import com.google.cloud.spanner.ErrorCode;\n+import com.google.cloud.spanner.IntegrationTest;\n+import com.google.cloud.spanner.IntegrationTestEnv;\n+import com.google.cloud.spanner.Key;\n+import com.google.cloud.spanner.Mutation;\n+import com.google.cloud.spanner.SpannerExceptionFactory;\n+import com.google.cloud.spanner.Struct;\n+import com.google.cloud.spanner.TimestampBound;\n+import com.google.cloud.spanner.Value;\n+import com.google.cloud.spanner.testing.RemoteSpannerHelper;\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.time.Instant;", "originalCommit": "a58652628192f91c5749658925568de9afd15438", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyNTA0NA==", "url": "https://github.com/googleapis/java-spanner/pull/37#discussion_r369325044", "bodyText": "Done @ 24faebe", "author": "agasheesh", "createdAt": "2020-01-22T01:04:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ0MzExMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ0MzIzNw==", "url": "https://github.com/googleapis/java-spanner/pull/37#discussion_r367443237", "bodyText": "Same as above.", "author": "olavloite", "createdAt": "2020-01-16T14:22:05Z", "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/it/ITCommitTimestampTest.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/*\n+ * Copyright 2017 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner.it;\n+\n+import static com.google.cloud.spanner.SpannerMatchers.isSpannerException;\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.Database;\n+import com.google.cloud.spanner.DatabaseAdminClient;\n+import com.google.cloud.spanner.DatabaseClient;\n+import com.google.cloud.spanner.ErrorCode;\n+import com.google.cloud.spanner.IntegrationTest;\n+import com.google.cloud.spanner.IntegrationTestEnv;\n+import com.google.cloud.spanner.Key;\n+import com.google.cloud.spanner.Mutation;\n+import com.google.cloud.spanner.SpannerExceptionFactory;\n+import com.google.cloud.spanner.Struct;\n+import com.google.cloud.spanner.TimestampBound;\n+import com.google.cloud.spanner.Value;\n+import com.google.cloud.spanner.testing.RemoteSpannerHelper;\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.concurrent.ExecutionException;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Integration test for commit timestamp of Cloud Spanner. */\n+@Category(IntegrationTest.class)\n+@RunWith(JUnit4.class)\n+public class ITCommitTimestampTest {\n+  @ClassRule public static IntegrationTestEnv env = new IntegrationTestEnv();\n+  @Rule public final ExpectedException expectedException = ExpectedException.none();\n+  private Database db;\n+  private DatabaseClient client;\n+  private DatabaseAdminClient dbAdminClient;\n+  private RemoteSpannerHelper testHelper;\n+  private String instanceId;\n+  private String databaseId;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    testHelper = env.getTestHelper();\n+    db =\n+        testHelper.createTestDatabase(\n+            \"CREATE TABLE T (\"\n+                + \"K  STRING(MAX) NOT NULL,\"\n+                + \"T1   TIMESTAMP OPTIONS (allow_commit_timestamp = true),\"\n+                + \"T2   TIMESTAMP OPTIONS (allow_commit_timestamp = true),\"\n+                + \"T3   TIMESTAMP,\"\n+                + \") PRIMARY KEY (K)\");\n+    client = testHelper.getDatabaseClient(db);\n+    dbAdminClient = testHelper.getClient().getDatabaseAdminClient();\n+    instanceId = testHelper.getInstanceId().getInstance();\n+    databaseId = db.getId().getDatabase();\n+  }\n+\n+  private Timestamp write(Mutation m) {\n+    return client.write(Arrays.asList(m));\n+  }\n+\n+  private Struct readRow(DatabaseClient client, String table, Key key, String... columns) {\n+    return client.singleUse(TimestampBound.strong()).readRow(table, key, Arrays.asList(columns));\n+  }\n+\n+  @Test\n+  public void writeCommitTimestamp() {\n+    // 1. timestamps auto populated and returned should be the same\n+    Timestamp commitTimestamp =\n+        write(\n+            Mutation.newInsertOrUpdateBuilder(\"T\")\n+                .set(\"K\")\n+                .to(\"a\")\n+                .set(\"T1\")\n+                .to(Value.COMMIT_TIMESTAMP)\n+                .set(\"T2\")\n+                .to(Value.COMMIT_TIMESTAMP)\n+                .build());\n+    Struct row = readRow(client, \"T\", Key.of(\"a\"), \"T1\", \"T2\");\n+    assertThat(row.getTimestamp(0)).isEqualTo(commitTimestamp);\n+    assertThat(row.getTimestamp(1)).isEqualTo(commitTimestamp);\n+\n+    // 2. attempt to write CommitTimestamp to not enabled column should fail\n+    // error_catalog error CommitTimestampOptionNotEnabled\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"allow_commit_timestamp column option is not\");\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T3\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+  }\n+\n+  @Test\n+  public void consistency() {\n+    // 1. timestamps populated are consistent in order\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T1\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"b\")\n+            .set(\"T1\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+    Struct row1 = readRow(client, \"T\", Key.of(\"a\"), \"T1\");\n+    Struct row2 = readRow(client, \"T\", Key.of(\"b\"), \"T1\");\n+    assertThat(row2.getTimestamp(0)).isGreaterThan(row1.getTimestamp(0));\n+  }\n+\n+  @Test\n+  public void schemaChangeTimestampInFuture() throws Exception {\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T3\")\n+            .to(Timestamp.MAX_VALUE)\n+            .build());\n+\n+    // error_catalog error CommitTimestampNotInFuture\n+    expectedException.expectCause(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"has a timestamp in the future at key\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (allow_commit_timestamp=true)\";\n+    try {\n+      dbAdminClient\n+          .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+          .get();\n+    } catch (ExecutionException e) {\n+      throw SpannerExceptionFactory.newSpannerException(e.getCause());\n+    }\n+  }\n+\n+  @Test\n+  public void insertTimestampInFuture() {\n+    // error_catalog error TimestampInFuture\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"in the future\");\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T1\")\n+            .to(Timestamp.MAX_VALUE)\n+            .build());\n+  }\n+\n+  @Test\n+  public void invalidColumnOption() throws Exception {\n+    // error_catalog error DDLStatementWithError\n+    expectedException.expectCause(isSpannerException(ErrorCode.INVALID_ARGUMENT));\n+    expectedException.expectMessage(\"Option: bogus is unknown.\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (bogus=null)\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  @Test\n+  public void invalidColumnOptionValue() throws Exception {\n+    // error_catalog error DDLStatementWithErrors\n+    expectedException.expectCause(isSpannerException(ErrorCode.INVALID_ARGUMENT));\n+    expectedException.expectMessage(\"Errors parsing Spanner DDL statement\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (allow_commit_timestamp=bogus)\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  @Test\n+  public void invalidColumnType() throws Exception {\n+    // error_catalog error OptionErrorList\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"Option only allowed on TIMESTAMP columns\");\n+    String statement = \"ALTER TABLE T ADD COLUMN T4 INT64 OPTIONS (allow_commit_timestamp=true)\";\n+    try {\n+      dbAdminClient\n+          .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+          .get();\n+    } catch (ExecutionException e) {\n+      throw SpannerExceptionFactory.newSpannerException(e.getCause());\n+    }\n+  }\n+\n+  private void alterColumnOption(String databaseId, String table, String opt) throws Exception {\n+    String statement =\n+        \"ALTER TABLE \"\n+            + table\n+            + \" ALTER COLUMN ts\"\n+            + \" SET OPTIONS (allow_commit_timestamp=\"\n+            + opt\n+            + \")\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  private void writeAndVerify(DatabaseClient client, Timestamp ts) {\n+    Timestamp commitTimestamp =\n+        client.write(\n+            Arrays.asList(\n+                Mutation.newInsertOrUpdateBuilder(\"T1\").set(\"ts\").to(ts).build(),\n+                Mutation.newInsertOrUpdateBuilder(\"T2\").set(\"ts\").to(ts).build(),\n+                Mutation.newInsertOrUpdateBuilder(\"T3\").set(\"ts\").to(ts).build()));\n+    if (ts == Value.COMMIT_TIMESTAMP) {\n+      ts = commitTimestamp;\n+    }\n+    assertThat(readRow(client, \"T1\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+    assertThat(readRow(client, \"T2\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+    assertThat(readRow(client, \"T3\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+  }\n+\n+  @Test\n+  // 1) Write timestamps in the past\n+  // 2) Set all interleaved tables allow_commmit_timestamp=true\n+  // 3) Use commit timestamp in all tables\n+  // 4) Set all interleaved tables allow_commmit_timestamp=null\n+  // 5) Write timestamps in the future\n+  public void interleavedTable() throws Exception {\n+    Database db =\n+        testHelper.createTestDatabase(\n+            \"CREATE TABLE T1 (ts TIMESTAMP) PRIMARY KEY (ts)\",\n+            \"CREATE TABLE T2 (ts TIMESTAMP) PRIMARY KEY (ts), INTERLEAVE IN PARENT T1\",\n+            \"CREATE TABLE T3 (ts TIMESTAMP) PRIMARY KEY (ts), INTERLEAVE IN PARENT T2\");\n+    DatabaseClient client = testHelper.getDatabaseClient(db);\n+    String databaseId = db.getId().getDatabase();\n+\n+    Timestamp timeNow = Timestamp.ofTimeMicroseconds(Instant.now().toEpochMilli() * 1000);\n+    Timestamp timeFuture =\n+        Timestamp.ofTimeMicroseconds(\n+            Instant.now().plus(Duration.ofDays(300)).toEpochMilli() * 1000);\n+\n+    writeAndVerify(client, timeNow);\n+\n+    alterColumnOption(databaseId, \"T1\", \"true\");\n+    alterColumnOption(databaseId, \"T2\", \"true\");\n+    alterColumnOption(databaseId, \"T3\", \"true\");\n+    writeAndVerify(client, Value.COMMIT_TIMESTAMP);\n+\n+    alterColumnOption(databaseId, \"T1\", \"null\");\n+    alterColumnOption(databaseId, \"T2\", \"null\");\n+    alterColumnOption(databaseId, \"T3\", \"null\");\n+    writeAndVerify(client, timeFuture);\n+  }\n+\n+  @Test\n+  // In interleaved table, use of commit timestamp in child table is not allowed\n+  // if parent tables are not allow_commmit_timestamp=true\n+  public void interleavedTableHierarchy1() {\n+    Database db =\n+        testHelper.createTestDatabase(\n+            \"CREATE TABLE T1 (ts TIMESTAMP) PRIMARY KEY (ts)\",\n+            \"CREATE TABLE T2 (ts TIMESTAMP) PRIMARY KEY (ts), INTERLEAVE IN PARENT T1\",\n+            \"CREATE TABLE T3 (ts TIMESTAMP OPTIONS (allow_commit_timestamp = true)) \"\n+                + \"PRIMARY KEY (ts), INTERLEAVE IN PARENT T2\");\n+    DatabaseClient client = testHelper.getDatabaseClient(db);\n+    db.getId().getDatabase();\n+\n+    // error_catalog error CommitTimestampOptionNotEnabled\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\n+        \"corresponding shared key columns in this table's interleaved table hierarchy\");\n+    client.write(\n+        Arrays.asList(\n+            Mutation.newInsertOrUpdateBuilder(\"T3\").set(\"ts\").to(Value.COMMIT_TIMESTAMP).build()));\n+  }\n+\n+  @Test\n+  // In interleaved table, use of commit timestamp in parent table is not", "originalCommit": "a58652628192f91c5749658925568de9afd15438", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyMjcwMQ==", "url": "https://github.com/googleapis/java-spanner/pull/37#discussion_r369322701", "bodyText": "Done @ d920e96.", "author": "agasheesh", "createdAt": "2020-01-22T00:54:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ0MzIzNw=="}], "type": "inlineReview"}, {"oid": "56cd23e93a492f9b927214439c180dfc9e5d7e94", "url": "https://github.com/googleapis/java-spanner/commit/56cd23e93a492f9b927214439c180dfc9e5d7e94", "message": "test: add Commit Timestamp java integration tests for cloud spanner", "committedDate": "2020-01-22T00:29:41Z", "type": "commit"}, {"oid": "56cd23e93a492f9b927214439c180dfc9e5d7e94", "url": "https://github.com/googleapis/java-spanner/commit/56cd23e93a492f9b927214439c180dfc9e5d7e94", "message": "test: add Commit Timestamp java integration tests for cloud spanner", "committedDate": "2020-01-22T00:29:41Z", "type": "forcePushed"}, {"oid": "24faebe561fc561308f1587eba85efdcf34fc86b", "url": "https://github.com/googleapis/java-spanner/commit/24faebe561fc561308f1587eba85efdcf34fc86b", "message": "Use org.threeten.bp library instead of java.time for Java 7 compatibility", "committedDate": "2020-01-22T00:38:14Z", "type": "commit"}, {"oid": "d920e968233662d9a16c8dd74ed94f5a2ebcb819", "url": "https://github.com/googleapis/java-spanner/commit/d920e968233662d9a16c8dd74ed94f5a2ebcb819", "message": "test: Fix java comment documentation style to use @Test annotation right before function name", "committedDate": "2020-01-22T00:53:10Z", "type": "commit"}, {"oid": "03bd9effbc7d39a6b40792092c3b783235f4a025", "url": "https://github.com/googleapis/java-spanner/commit/03bd9effbc7d39a6b40792092c3b783235f4a025", "message": "Fix formatting error in imports", "committedDate": "2020-01-22T01:02:19Z", "type": "commit"}]}