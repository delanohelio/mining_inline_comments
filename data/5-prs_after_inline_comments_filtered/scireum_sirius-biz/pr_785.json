{"pr_number": 785, "pr_title": "Cleanup of Directory Traversal + Transfer APIS in the VFS", "pr_createdAt": "2020-06-16T23:54:43Z", "pr_url": "https://github.com/scireum/sirius-biz/pull/785", "timeline": [{"oid": "dbc09a87d3782ecbbbe0fb49d5014240276e5162", "url": "https://github.com/scireum/sirius-biz/commit/dbc09a87d3782ecbbbe0fb49d5014240276e5162", "message": "Marks JobFactory as AutoRegister.", "committedDate": "2020-06-16T23:47:42Z", "type": "commit"}, {"oid": "cba8ee3ef69e8419ae921151b819f5919655c976", "url": "https://github.com/scireum/sirius-biz/commit/cba8ee3ef69e8419ae921151b819f5919655c976", "message": "Code cleanup.", "committedDate": "2020-06-16T23:48:00Z", "type": "commit"}, {"oid": "e1942acf3a1e1104fddd0e9af3010ad13ff4cca6", "url": "https://github.com/scireum/sirius-biz/commit/e1942acf3a1e1104fddd0e9af3010ad13ff4cca6", "message": "BREAKING CHANGE: Provides a flexible and configurable way of traversing through directory hierarchies within the VFS.\n\nSome legacy methods have been removed since these are now readily available via .tree()", "committedDate": "2020-06-16T23:50:00Z", "type": "commit"}, {"oid": "c19dad13e315ef3121a6cfe2c4bc5b40c559eddd", "url": "https://github.com/scireum/sirius-biz/commit/c19dad13e315ef3121a6cfe2c4bc5b40c559eddd", "message": "Provides a single and central approach of transferring VirtualFiles around.\n\nThis handles copying and moving single files as well as directory hierarchies.\nWe support interactive operations was well as batch/background tasks.\n\nTherefore a TransferFilesJob is provided which can be used manually or is\nautomatically used by the framework if needed.", "committedDate": "2020-06-16T23:51:53Z", "type": "commit"}, {"oid": "416918af5f8ac289966e42d502c0130dd4ed46e2", "url": "https://github.com/scireum/sirius-biz/commit/416918af5f8ac289966e42d502c0130dd4ed46e2", "message": "Provides the changes necessary to use the newest sirius-kernel.", "committedDate": "2020-06-16T23:52:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxMDk1NA==", "url": "https://github.com/scireum/sirius-biz/pull/785#discussion_r441310954", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return a process ID if a backkground process has been created to perform the operation. An empty optional if the\n          \n          \n            \n                 * @return a process ID if a background process has been created to perform the operation. An empty optional if the", "author": "jmuscireum", "createdAt": "2020-06-17T06:33:24Z", "path": "src/main/java/sirius/biz/storage/layer3/Transfer.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.storage.layer3;\n+\n+import sirius.biz.jobs.Jobs;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.storage.layer2.Blob;\n+import sirius.biz.storage.util.Attempt;\n+import sirius.biz.storage.util.StorageUtils;\n+import sirius.kernel.commons.Value;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.health.Exceptions;\n+\n+import javax.annotation.CheckReturnValue;\n+import java.io.InputStream;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+\n+/**\n+ * Provides a configurable helper to either copy or move {@link VirtualFile virtual files} from one location to another.\n+ * <p>\n+ * A transfer is initiated using {@link VirtualFile#transferTo(VirtualFile)}.\n+ */\n+public class Transfer {\n+\n+    private static final int MAX_FILES_THRESHOLD = 128;\n+    private static final long MAX_SIZE_THRESHOLD = 32_768;\n+    private final VirtualFile source;\n+    private final VirtualFile destination;\n+    private boolean forceWrite = true;\n+    private ProcessContext processContext;\n+    private boolean autobatch = false;\n+\n+    @Part\n+    private static Jobs jobs;\n+\n+    protected Transfer(VirtualFile source, VirtualFile destination) {\n+        this.source = source;\n+        this.destination = destination;\n+    }\n+\n+    /**\n+     * Determines if moving the file to the destination could be performed interactive.\n+     * <p>\n+     * For interactive moves, we have an upper limit for the number of files to process and also their size.\n+     *\n+     * @return <tt>true</tt> if the file can be moved interactively\n+     * @see #MAX_FILES_THRESHOLD\n+     * @see #MAX_SIZE_THRESHOLD\n+     */\n+    public boolean canMoveInteractive() {\n+        return source.canFastMoveTo(destination) || canCopyInteractive();\n+    }\n+\n+    /**\n+     * Determines if a fast move can be performed.\n+     * <p>\n+     * A fast move is supported by the underlying implementation and won't juggle any bytes but rather perform a very\n+     * efficient implementation. A {@link Blob} of layer 2 for example will only update its directory field if moved\n+     * within the same space.\n+     *\n+     * @return <tt>true</tt> if a fast and efficient move is possible, <tt>false</tt> otherwise\n+     */\n+    public boolean canFastMove() {\n+        return source.canFastMoveTo(destination) || canCopyInteractive();\n+    }\n+\n+    /**\n+     * Determines if copying the file to the destination could be performed interactive.\n+     * <p>\n+     * For interactive copying, we have an upper limit for the number of files to process and also their size.\n+     *\n+     * @return <tt>true</tt> if the file can be moved interactively\n+     * @see #MAX_FILES_THRESHOLD\n+     * @see #MAX_SIZE_THRESHOLD\n+     */\n+    public boolean canCopyInteractive() {\n+        AtomicLong countOfFiles = new AtomicLong();\n+        AtomicLong sizeSum = new AtomicLong();\n+        source.tree().limit(MAX_FILES_THRESHOLD + 1).iterate(file -> {\n+            countOfFiles.incrementAndGet();\n+            return sizeSum.addAndGet(file.size()) < MAX_SIZE_THRESHOLD;\n+        });\n+\n+        return countOfFiles.get() < MAX_FILES_THRESHOLD && sizeSum.get() < MAX_SIZE_THRESHOLD;\n+    }\n+\n+    /**\n+     * Notifies the transfer that a batch/proces context is available.\n+     * <p>\n+     * As soon as a process context is available no limits are enforced anymore (e.g. {@link #canMoveInteractive()}.\n+     * Also, we provide some metrics and debug messages.\n+     *\n+     * @param processContext the process context to execute the transfer within\n+     * @return the transfer helper itself for fluent method calls\n+     */\n+    @CheckReturnValue\n+    public Transfer batch(ProcessContext processContext) {\n+        this.processContext = processContext;\n+        return this;\n+    }\n+\n+    /**\n+     * Signals that a process for the requested operation should be started if it isn't eligible for interactive\n+     * execution.\n+     *\n+     * @return the transfer helper itself for fluent method calls\n+     */\n+    @CheckReturnValue\n+    public Transfer autobatch() {\n+        this.autobatch = true;\n+        return this;\n+    }\n+\n+    /**\n+     * Enables smart transfers for copy operations.\n+     * <p>\n+     * Using this approach a copy will only happen if the source and destination sizes don't match or if the source\n+     * if newer than the destination. Otherwise the operation is skipped.\n+     *\n+     * @return the transfer helper itself for fluent method calls\n+     */\n+    @CheckReturnValue\n+    public Transfer smartTransfer() {\n+        this.forceWrite = false;\n+        return this;\n+    }\n+\n+    /**\n+     * Manually attempts a fast move.\n+     * <p>\n+     * Note that most probably calling {@link #move()} and letting the framework handle everything else is wiser.\n+     *\n+     * @return <tt>true</tt> if the fast move succeded, <tt>false</tt> otherwise\n+     */\n+    public boolean tryFastMove() {\n+        return source.tryFastMoveTo(destination);\n+    }\n+\n+    /**\n+     * Requests to move the source to/into the destination.\n+     * <p>\n+     * If the source is too large and cannot be moved interactively, one of three things will happen:\n+     * <ul>\n+     *     <li>\n+     *         A process context has been attached via {@link #batch(ProcessContext)} and the operation will succeed.\n+     *     </li>\n+     *     <li>\n+     *        Auto batching has been enabled via {@link #autobatch()} and a new process will be created and its ID\n+     *        will be returned.\n+     *     </li>\n+     *     <li>\n+     *        If neither a process is available nor one can be created, an exception is thrown.\n+     *     </li>\n+     * </ul>\n+     *\n+     * @return a process ID if a backkground process has been created to perform the operation. An empty optional if the", "originalCommit": "416918af5f8ac289966e42d502c0130dd4ed46e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxMTAwMQ==", "url": "https://github.com/scireum/sirius-biz/pull/785#discussion_r441311001", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return a process ID if a backkground process has been created to perform the operation. An empty optional if the\n          \n          \n            \n                 * @return a process ID if a background process has been created to perform the operation. An empty optional if the", "author": "jmuscireum", "createdAt": "2020-06-17T06:33:32Z", "path": "src/main/java/sirius/biz/storage/layer3/Transfer.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.storage.layer3;\n+\n+import sirius.biz.jobs.Jobs;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.storage.layer2.Blob;\n+import sirius.biz.storage.util.Attempt;\n+import sirius.biz.storage.util.StorageUtils;\n+import sirius.kernel.commons.Value;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.health.Exceptions;\n+\n+import javax.annotation.CheckReturnValue;\n+import java.io.InputStream;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+\n+/**\n+ * Provides a configurable helper to either copy or move {@link VirtualFile virtual files} from one location to another.\n+ * <p>\n+ * A transfer is initiated using {@link VirtualFile#transferTo(VirtualFile)}.\n+ */\n+public class Transfer {\n+\n+    private static final int MAX_FILES_THRESHOLD = 128;\n+    private static final long MAX_SIZE_THRESHOLD = 32_768;\n+    private final VirtualFile source;\n+    private final VirtualFile destination;\n+    private boolean forceWrite = true;\n+    private ProcessContext processContext;\n+    private boolean autobatch = false;\n+\n+    @Part\n+    private static Jobs jobs;\n+\n+    protected Transfer(VirtualFile source, VirtualFile destination) {\n+        this.source = source;\n+        this.destination = destination;\n+    }\n+\n+    /**\n+     * Determines if moving the file to the destination could be performed interactive.\n+     * <p>\n+     * For interactive moves, we have an upper limit for the number of files to process and also their size.\n+     *\n+     * @return <tt>true</tt> if the file can be moved interactively\n+     * @see #MAX_FILES_THRESHOLD\n+     * @see #MAX_SIZE_THRESHOLD\n+     */\n+    public boolean canMoveInteractive() {\n+        return source.canFastMoveTo(destination) || canCopyInteractive();\n+    }\n+\n+    /**\n+     * Determines if a fast move can be performed.\n+     * <p>\n+     * A fast move is supported by the underlying implementation and won't juggle any bytes but rather perform a very\n+     * efficient implementation. A {@link Blob} of layer 2 for example will only update its directory field if moved\n+     * within the same space.\n+     *\n+     * @return <tt>true</tt> if a fast and efficient move is possible, <tt>false</tt> otherwise\n+     */\n+    public boolean canFastMove() {\n+        return source.canFastMoveTo(destination) || canCopyInteractive();\n+    }\n+\n+    /**\n+     * Determines if copying the file to the destination could be performed interactive.\n+     * <p>\n+     * For interactive copying, we have an upper limit for the number of files to process and also their size.\n+     *\n+     * @return <tt>true</tt> if the file can be moved interactively\n+     * @see #MAX_FILES_THRESHOLD\n+     * @see #MAX_SIZE_THRESHOLD\n+     */\n+    public boolean canCopyInteractive() {\n+        AtomicLong countOfFiles = new AtomicLong();\n+        AtomicLong sizeSum = new AtomicLong();\n+        source.tree().limit(MAX_FILES_THRESHOLD + 1).iterate(file -> {\n+            countOfFiles.incrementAndGet();\n+            return sizeSum.addAndGet(file.size()) < MAX_SIZE_THRESHOLD;\n+        });\n+\n+        return countOfFiles.get() < MAX_FILES_THRESHOLD && sizeSum.get() < MAX_SIZE_THRESHOLD;\n+    }\n+\n+    /**\n+     * Notifies the transfer that a batch/proces context is available.\n+     * <p>\n+     * As soon as a process context is available no limits are enforced anymore (e.g. {@link #canMoveInteractive()}.\n+     * Also, we provide some metrics and debug messages.\n+     *\n+     * @param processContext the process context to execute the transfer within\n+     * @return the transfer helper itself for fluent method calls\n+     */\n+    @CheckReturnValue\n+    public Transfer batch(ProcessContext processContext) {\n+        this.processContext = processContext;\n+        return this;\n+    }\n+\n+    /**\n+     * Signals that a process for the requested operation should be started if it isn't eligible for interactive\n+     * execution.\n+     *\n+     * @return the transfer helper itself for fluent method calls\n+     */\n+    @CheckReturnValue\n+    public Transfer autobatch() {\n+        this.autobatch = true;\n+        return this;\n+    }\n+\n+    /**\n+     * Enables smart transfers for copy operations.\n+     * <p>\n+     * Using this approach a copy will only happen if the source and destination sizes don't match or if the source\n+     * if newer than the destination. Otherwise the operation is skipped.\n+     *\n+     * @return the transfer helper itself for fluent method calls\n+     */\n+    @CheckReturnValue\n+    public Transfer smartTransfer() {\n+        this.forceWrite = false;\n+        return this;\n+    }\n+\n+    /**\n+     * Manually attempts a fast move.\n+     * <p>\n+     * Note that most probably calling {@link #move()} and letting the framework handle everything else is wiser.\n+     *\n+     * @return <tt>true</tt> if the fast move succeded, <tt>false</tt> otherwise\n+     */\n+    public boolean tryFastMove() {\n+        return source.tryFastMoveTo(destination);\n+    }\n+\n+    /**\n+     * Requests to move the source to/into the destination.\n+     * <p>\n+     * If the source is too large and cannot be moved interactively, one of three things will happen:\n+     * <ul>\n+     *     <li>\n+     *         A process context has been attached via {@link #batch(ProcessContext)} and the operation will succeed.\n+     *     </li>\n+     *     <li>\n+     *        Auto batching has been enabled via {@link #autobatch()} and a new process will be created and its ID\n+     *        will be returned.\n+     *     </li>\n+     *     <li>\n+     *        If neither a process is available nor one can be created, an exception is thrown.\n+     *     </li>\n+     * </ul>\n+     *\n+     * @return a process ID if a backkground process has been created to perform the operation. An empty optional if the\n+     * operation was either handled interactively or if a process context was already available.\n+     */\n+    public Optional<String> move() {\n+        if (source.tryFastMoveTo(destination)) {\n+            return Optional.empty();\n+        }\n+\n+        if (processContext == null && !canMoveInteractive()) {\n+            if (autobatch) {\n+                return createTransferFilesJob(true);\n+            } else {\n+                throw Exceptions.handle()\n+                                .to(StorageUtils.LOG)\n+                                .withSystemErrorMessage(\n+                                        \"Layer 3/VFS: Failed to move '%s' to '%s': Contents too large to move interactively!\",\n+                                        source,\n+                                        destination)\n+                                .handle();\n+            }\n+        }\n+        transfer(true);\n+        return Optional.empty();\n+    }\n+\n+    private Optional<String> createTransferFilesJob(boolean delete) {\n+        return Optional.of(jobs.findFactory(TransferFilesJob.NAME, TransferFilesJob.class)\n+                               .startInBackground(createParameterSource(delete ?\n+                                                                        TransferFilesJob.TransferMode.MOVE :\n+                                                                        TransferFilesJob.TransferMode.COPY)));\n+    }\n+\n+    /**\n+     * Requests to copy  the source to/into the destination.\n+     * <p>\n+     * If the source is too large and cannot be moved interactively, one of three things will happen:\n+     * <ul>\n+     *     <li>\n+     *         A process context has been attached via {@link #batch(ProcessContext)} and the operation will succeed.\n+     *     </li>\n+     *     <li>\n+     *        Auto batching has been enabled via {@link #autobatch()} and a new process will be created and its ID\n+     *        will be returned.\n+     *     </li>\n+     *     <li>\n+     *        If neither a process is available nor one can be created, an exception is thrown.\n+     *     </li>\n+     * </ul>\n+     *\n+     * @return a process ID if a backkground process has been created to perform the operation. An empty optional if the", "originalCommit": "416918af5f8ac289966e42d502c0130dd4ed46e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxMTA1MA==", "url": "https://github.com/scireum/sirius-biz/pull/785#discussion_r441311050", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return a process ID if a backkground process has been created to perform the operation. An empty optional if the\n          \n          \n            \n                 * @return a process ID if a background process has been created to perform the operation. An empty optional if the", "author": "jmuscireum", "createdAt": "2020-06-17T06:33:40Z", "path": "src/main/java/sirius/biz/storage/layer3/Transfer.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.storage.layer3;\n+\n+import sirius.biz.jobs.Jobs;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.storage.layer2.Blob;\n+import sirius.biz.storage.util.Attempt;\n+import sirius.biz.storage.util.StorageUtils;\n+import sirius.kernel.commons.Value;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.health.Exceptions;\n+\n+import javax.annotation.CheckReturnValue;\n+import java.io.InputStream;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+\n+/**\n+ * Provides a configurable helper to either copy or move {@link VirtualFile virtual files} from one location to another.\n+ * <p>\n+ * A transfer is initiated using {@link VirtualFile#transferTo(VirtualFile)}.\n+ */\n+public class Transfer {\n+\n+    private static final int MAX_FILES_THRESHOLD = 128;\n+    private static final long MAX_SIZE_THRESHOLD = 32_768;\n+    private final VirtualFile source;\n+    private final VirtualFile destination;\n+    private boolean forceWrite = true;\n+    private ProcessContext processContext;\n+    private boolean autobatch = false;\n+\n+    @Part\n+    private static Jobs jobs;\n+\n+    protected Transfer(VirtualFile source, VirtualFile destination) {\n+        this.source = source;\n+        this.destination = destination;\n+    }\n+\n+    /**\n+     * Determines if moving the file to the destination could be performed interactive.\n+     * <p>\n+     * For interactive moves, we have an upper limit for the number of files to process and also their size.\n+     *\n+     * @return <tt>true</tt> if the file can be moved interactively\n+     * @see #MAX_FILES_THRESHOLD\n+     * @see #MAX_SIZE_THRESHOLD\n+     */\n+    public boolean canMoveInteractive() {\n+        return source.canFastMoveTo(destination) || canCopyInteractive();\n+    }\n+\n+    /**\n+     * Determines if a fast move can be performed.\n+     * <p>\n+     * A fast move is supported by the underlying implementation and won't juggle any bytes but rather perform a very\n+     * efficient implementation. A {@link Blob} of layer 2 for example will only update its directory field if moved\n+     * within the same space.\n+     *\n+     * @return <tt>true</tt> if a fast and efficient move is possible, <tt>false</tt> otherwise\n+     */\n+    public boolean canFastMove() {\n+        return source.canFastMoveTo(destination) || canCopyInteractive();\n+    }\n+\n+    /**\n+     * Determines if copying the file to the destination could be performed interactive.\n+     * <p>\n+     * For interactive copying, we have an upper limit for the number of files to process and also their size.\n+     *\n+     * @return <tt>true</tt> if the file can be moved interactively\n+     * @see #MAX_FILES_THRESHOLD\n+     * @see #MAX_SIZE_THRESHOLD\n+     */\n+    public boolean canCopyInteractive() {\n+        AtomicLong countOfFiles = new AtomicLong();\n+        AtomicLong sizeSum = new AtomicLong();\n+        source.tree().limit(MAX_FILES_THRESHOLD + 1).iterate(file -> {\n+            countOfFiles.incrementAndGet();\n+            return sizeSum.addAndGet(file.size()) < MAX_SIZE_THRESHOLD;\n+        });\n+\n+        return countOfFiles.get() < MAX_FILES_THRESHOLD && sizeSum.get() < MAX_SIZE_THRESHOLD;\n+    }\n+\n+    /**\n+     * Notifies the transfer that a batch/proces context is available.\n+     * <p>\n+     * As soon as a process context is available no limits are enforced anymore (e.g. {@link #canMoveInteractive()}.\n+     * Also, we provide some metrics and debug messages.\n+     *\n+     * @param processContext the process context to execute the transfer within\n+     * @return the transfer helper itself for fluent method calls\n+     */\n+    @CheckReturnValue\n+    public Transfer batch(ProcessContext processContext) {\n+        this.processContext = processContext;\n+        return this;\n+    }\n+\n+    /**\n+     * Signals that a process for the requested operation should be started if it isn't eligible for interactive\n+     * execution.\n+     *\n+     * @return the transfer helper itself for fluent method calls\n+     */\n+    @CheckReturnValue\n+    public Transfer autobatch() {\n+        this.autobatch = true;\n+        return this;\n+    }\n+\n+    /**\n+     * Enables smart transfers for copy operations.\n+     * <p>\n+     * Using this approach a copy will only happen if the source and destination sizes don't match or if the source\n+     * if newer than the destination. Otherwise the operation is skipped.\n+     *\n+     * @return the transfer helper itself for fluent method calls\n+     */\n+    @CheckReturnValue\n+    public Transfer smartTransfer() {\n+        this.forceWrite = false;\n+        return this;\n+    }\n+\n+    /**\n+     * Manually attempts a fast move.\n+     * <p>\n+     * Note that most probably calling {@link #move()} and letting the framework handle everything else is wiser.\n+     *\n+     * @return <tt>true</tt> if the fast move succeded, <tt>false</tt> otherwise\n+     */\n+    public boolean tryFastMove() {\n+        return source.tryFastMoveTo(destination);\n+    }\n+\n+    /**\n+     * Requests to move the source to/into the destination.\n+     * <p>\n+     * If the source is too large and cannot be moved interactively, one of three things will happen:\n+     * <ul>\n+     *     <li>\n+     *         A process context has been attached via {@link #batch(ProcessContext)} and the operation will succeed.\n+     *     </li>\n+     *     <li>\n+     *        Auto batching has been enabled via {@link #autobatch()} and a new process will be created and its ID\n+     *        will be returned.\n+     *     </li>\n+     *     <li>\n+     *        If neither a process is available nor one can be created, an exception is thrown.\n+     *     </li>\n+     * </ul>\n+     *\n+     * @return a process ID if a backkground process has been created to perform the operation. An empty optional if the\n+     * operation was either handled interactively or if a process context was already available.\n+     */\n+    public Optional<String> move() {\n+        if (source.tryFastMoveTo(destination)) {\n+            return Optional.empty();\n+        }\n+\n+        if (processContext == null && !canMoveInteractive()) {\n+            if (autobatch) {\n+                return createTransferFilesJob(true);\n+            } else {\n+                throw Exceptions.handle()\n+                                .to(StorageUtils.LOG)\n+                                .withSystemErrorMessage(\n+                                        \"Layer 3/VFS: Failed to move '%s' to '%s': Contents too large to move interactively!\",\n+                                        source,\n+                                        destination)\n+                                .handle();\n+            }\n+        }\n+        transfer(true);\n+        return Optional.empty();\n+    }\n+\n+    private Optional<String> createTransferFilesJob(boolean delete) {\n+        return Optional.of(jobs.findFactory(TransferFilesJob.NAME, TransferFilesJob.class)\n+                               .startInBackground(createParameterSource(delete ?\n+                                                                        TransferFilesJob.TransferMode.MOVE :\n+                                                                        TransferFilesJob.TransferMode.COPY)));\n+    }\n+\n+    /**\n+     * Requests to copy  the source to/into the destination.\n+     * <p>\n+     * If the source is too large and cannot be moved interactively, one of three things will happen:\n+     * <ul>\n+     *     <li>\n+     *         A process context has been attached via {@link #batch(ProcessContext)} and the operation will succeed.\n+     *     </li>\n+     *     <li>\n+     *        Auto batching has been enabled via {@link #autobatch()} and a new process will be created and its ID\n+     *        will be returned.\n+     *     </li>\n+     *     <li>\n+     *        If neither a process is available nor one can be created, an exception is thrown.\n+     *     </li>\n+     * </ul>\n+     *\n+     * @return a process ID if a backkground process has been created to perform the operation. An empty optional if the\n+     * operation was either handled interactively or if a process context was already available.\n+     */\n+    public Optional<String> copy() {\n+        if (processContext == null && !canCopyInteractive()) {\n+            if (autobatch) {\n+                return createTransferFilesJob(false);\n+            } else {\n+                throw Exceptions.handle()\n+                                .to(StorageUtils.LOG)\n+                                .withSystemErrorMessage(\n+                                        \"Layer 3/VFS: Failed to copy '%s' to '%s': Contents too large to copy interactively!\",\n+                                        source,\n+                                        destination)\n+                                .handle();\n+            }\n+        }\n+\n+        transfer(false);\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Requests to move the children of the source directory into the destination directory.\n+     * <p>\n+     * If the children to be moved are large, the same rules as for {@link #move()} apply.\n+     *\n+     * @return a process ID if a backkground process has been created to perform the operation. An empty optional if the", "originalCommit": "416918af5f8ac289966e42d502c0130dd4ed46e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxMTA5Mg==", "url": "https://github.com/scireum/sirius-biz/pull/785#discussion_r441311092", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return a process ID if a backkground process has been created to perform the operation. An empty optional if the\n          \n          \n            \n                 * @return a process ID if a background process has been created to perform the operation. An empty optional if the", "author": "jmuscireum", "createdAt": "2020-06-17T06:33:47Z", "path": "src/main/java/sirius/biz/storage/layer3/Transfer.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Made with all the love in the world\n+ * by scireum in Remshalden, Germany\n+ *\n+ * Copyright by scireum GmbH\n+ * http://www.scireum.de - info@scireum.de\n+ */\n+\n+package sirius.biz.storage.layer3;\n+\n+import sirius.biz.jobs.Jobs;\n+import sirius.biz.process.ProcessContext;\n+import sirius.biz.storage.layer2.Blob;\n+import sirius.biz.storage.util.Attempt;\n+import sirius.biz.storage.util.StorageUtils;\n+import sirius.kernel.commons.Value;\n+import sirius.kernel.di.std.Part;\n+import sirius.kernel.health.Exceptions;\n+\n+import javax.annotation.CheckReturnValue;\n+import java.io.InputStream;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+\n+/**\n+ * Provides a configurable helper to either copy or move {@link VirtualFile virtual files} from one location to another.\n+ * <p>\n+ * A transfer is initiated using {@link VirtualFile#transferTo(VirtualFile)}.\n+ */\n+public class Transfer {\n+\n+    private static final int MAX_FILES_THRESHOLD = 128;\n+    private static final long MAX_SIZE_THRESHOLD = 32_768;\n+    private final VirtualFile source;\n+    private final VirtualFile destination;\n+    private boolean forceWrite = true;\n+    private ProcessContext processContext;\n+    private boolean autobatch = false;\n+\n+    @Part\n+    private static Jobs jobs;\n+\n+    protected Transfer(VirtualFile source, VirtualFile destination) {\n+        this.source = source;\n+        this.destination = destination;\n+    }\n+\n+    /**\n+     * Determines if moving the file to the destination could be performed interactive.\n+     * <p>\n+     * For interactive moves, we have an upper limit for the number of files to process and also their size.\n+     *\n+     * @return <tt>true</tt> if the file can be moved interactively\n+     * @see #MAX_FILES_THRESHOLD\n+     * @see #MAX_SIZE_THRESHOLD\n+     */\n+    public boolean canMoveInteractive() {\n+        return source.canFastMoveTo(destination) || canCopyInteractive();\n+    }\n+\n+    /**\n+     * Determines if a fast move can be performed.\n+     * <p>\n+     * A fast move is supported by the underlying implementation and won't juggle any bytes but rather perform a very\n+     * efficient implementation. A {@link Blob} of layer 2 for example will only update its directory field if moved\n+     * within the same space.\n+     *\n+     * @return <tt>true</tt> if a fast and efficient move is possible, <tt>false</tt> otherwise\n+     */\n+    public boolean canFastMove() {\n+        return source.canFastMoveTo(destination) || canCopyInteractive();\n+    }\n+\n+    /**\n+     * Determines if copying the file to the destination could be performed interactive.\n+     * <p>\n+     * For interactive copying, we have an upper limit for the number of files to process and also their size.\n+     *\n+     * @return <tt>true</tt> if the file can be moved interactively\n+     * @see #MAX_FILES_THRESHOLD\n+     * @see #MAX_SIZE_THRESHOLD\n+     */\n+    public boolean canCopyInteractive() {\n+        AtomicLong countOfFiles = new AtomicLong();\n+        AtomicLong sizeSum = new AtomicLong();\n+        source.tree().limit(MAX_FILES_THRESHOLD + 1).iterate(file -> {\n+            countOfFiles.incrementAndGet();\n+            return sizeSum.addAndGet(file.size()) < MAX_SIZE_THRESHOLD;\n+        });\n+\n+        return countOfFiles.get() < MAX_FILES_THRESHOLD && sizeSum.get() < MAX_SIZE_THRESHOLD;\n+    }\n+\n+    /**\n+     * Notifies the transfer that a batch/proces context is available.\n+     * <p>\n+     * As soon as a process context is available no limits are enforced anymore (e.g. {@link #canMoveInteractive()}.\n+     * Also, we provide some metrics and debug messages.\n+     *\n+     * @param processContext the process context to execute the transfer within\n+     * @return the transfer helper itself for fluent method calls\n+     */\n+    @CheckReturnValue\n+    public Transfer batch(ProcessContext processContext) {\n+        this.processContext = processContext;\n+        return this;\n+    }\n+\n+    /**\n+     * Signals that a process for the requested operation should be started if it isn't eligible for interactive\n+     * execution.\n+     *\n+     * @return the transfer helper itself for fluent method calls\n+     */\n+    @CheckReturnValue\n+    public Transfer autobatch() {\n+        this.autobatch = true;\n+        return this;\n+    }\n+\n+    /**\n+     * Enables smart transfers for copy operations.\n+     * <p>\n+     * Using this approach a copy will only happen if the source and destination sizes don't match or if the source\n+     * if newer than the destination. Otherwise the operation is skipped.\n+     *\n+     * @return the transfer helper itself for fluent method calls\n+     */\n+    @CheckReturnValue\n+    public Transfer smartTransfer() {\n+        this.forceWrite = false;\n+        return this;\n+    }\n+\n+    /**\n+     * Manually attempts a fast move.\n+     * <p>\n+     * Note that most probably calling {@link #move()} and letting the framework handle everything else is wiser.\n+     *\n+     * @return <tt>true</tt> if the fast move succeded, <tt>false</tt> otherwise\n+     */\n+    public boolean tryFastMove() {\n+        return source.tryFastMoveTo(destination);\n+    }\n+\n+    /**\n+     * Requests to move the source to/into the destination.\n+     * <p>\n+     * If the source is too large and cannot be moved interactively, one of three things will happen:\n+     * <ul>\n+     *     <li>\n+     *         A process context has been attached via {@link #batch(ProcessContext)} and the operation will succeed.\n+     *     </li>\n+     *     <li>\n+     *        Auto batching has been enabled via {@link #autobatch()} and a new process will be created and its ID\n+     *        will be returned.\n+     *     </li>\n+     *     <li>\n+     *        If neither a process is available nor one can be created, an exception is thrown.\n+     *     </li>\n+     * </ul>\n+     *\n+     * @return a process ID if a backkground process has been created to perform the operation. An empty optional if the\n+     * operation was either handled interactively or if a process context was already available.\n+     */\n+    public Optional<String> move() {\n+        if (source.tryFastMoveTo(destination)) {\n+            return Optional.empty();\n+        }\n+\n+        if (processContext == null && !canMoveInteractive()) {\n+            if (autobatch) {\n+                return createTransferFilesJob(true);\n+            } else {\n+                throw Exceptions.handle()\n+                                .to(StorageUtils.LOG)\n+                                .withSystemErrorMessage(\n+                                        \"Layer 3/VFS: Failed to move '%s' to '%s': Contents too large to move interactively!\",\n+                                        source,\n+                                        destination)\n+                                .handle();\n+            }\n+        }\n+        transfer(true);\n+        return Optional.empty();\n+    }\n+\n+    private Optional<String> createTransferFilesJob(boolean delete) {\n+        return Optional.of(jobs.findFactory(TransferFilesJob.NAME, TransferFilesJob.class)\n+                               .startInBackground(createParameterSource(delete ?\n+                                                                        TransferFilesJob.TransferMode.MOVE :\n+                                                                        TransferFilesJob.TransferMode.COPY)));\n+    }\n+\n+    /**\n+     * Requests to copy  the source to/into the destination.\n+     * <p>\n+     * If the source is too large and cannot be moved interactively, one of three things will happen:\n+     * <ul>\n+     *     <li>\n+     *         A process context has been attached via {@link #batch(ProcessContext)} and the operation will succeed.\n+     *     </li>\n+     *     <li>\n+     *        Auto batching has been enabled via {@link #autobatch()} and a new process will be created and its ID\n+     *        will be returned.\n+     *     </li>\n+     *     <li>\n+     *        If neither a process is available nor one can be created, an exception is thrown.\n+     *     </li>\n+     * </ul>\n+     *\n+     * @return a process ID if a backkground process has been created to perform the operation. An empty optional if the\n+     * operation was either handled interactively or if a process context was already available.\n+     */\n+    public Optional<String> copy() {\n+        if (processContext == null && !canCopyInteractive()) {\n+            if (autobatch) {\n+                return createTransferFilesJob(false);\n+            } else {\n+                throw Exceptions.handle()\n+                                .to(StorageUtils.LOG)\n+                                .withSystemErrorMessage(\n+                                        \"Layer 3/VFS: Failed to copy '%s' to '%s': Contents too large to copy interactively!\",\n+                                        source,\n+                                        destination)\n+                                .handle();\n+            }\n+        }\n+\n+        transfer(false);\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Requests to move the children of the source directory into the destination directory.\n+     * <p>\n+     * If the children to be moved are large, the same rules as for {@link #move()} apply.\n+     *\n+     * @return a process ID if a backkground process has been created to perform the operation. An empty optional if the\n+     * operation was either handled interactively or if a process context was already available.\n+     */\n+    @CheckReturnValue\n+    public Optional<String> moveContents() {\n+        if (processContext == null && !canMoveInteractive()) {\n+            if (autobatch) {\n+                return createTransferDirectoryContentsJob(true);\n+            } else {\n+                throw Exceptions.handle()\n+                                .to(StorageUtils.LOG)\n+                                .withSystemErrorMessage(\n+                                        \"Layer 3/VFS: Failed to move contents of '%s' into '%s': Contents too large to move interactively!\",\n+                                        source,\n+                                        destination)\n+                                .handle();\n+            }\n+        }\n+        transferContents(true);\n+        return Optional.empty();\n+    }\n+\n+    private Optional<String> createTransferDirectoryContentsJob(boolean delete) {\n+        return Optional.of(jobs.findFactory(TransferFilesJob.NAME, TransferFilesJob.class)\n+                               .startInBackground(createParameterSource(delete ?\n+                                                                        TransferFilesJob.TransferMode.MOVE_CONTENTS :\n+                                                                        TransferFilesJob.TransferMode.COPY_CONTENTS)));\n+    }\n+\n+    private Function<String, Value> createParameterSource(TransferFilesJob.TransferMode mode) {\n+        return param -> {\n+            switch (param) {\n+                case TransferFilesJob.SOURCE_PARAMETER_NAME:\n+                    return Value.of(source.path());\n+                case TransferFilesJob.DESTINATION_PARAMETER_NAME:\n+                    return Value.of(destination.path());\n+                case TransferFilesJob.MODE_PARAMETER_NAME:\n+                    return Value.of(mode.name());\n+                case TransferFilesJob.SMART_TRANSFER_PARAMETER_NAME:\n+                    return Value.of(!forceWrite);\n+                default:\n+                    return Value.EMPTY;\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Requests to copy the children of the source directory into the destination directory.\n+     * <p>\n+     * If the children to be moved are large, the same rules as for {@link #copy()} apply.\n+     *\n+     * @return a process ID if a backkground process has been created to perform the operation. An empty optional if the", "originalCommit": "416918af5f8ac289966e42d502c0130dd4ed46e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a1a9222dc27775642ff314c5fe6c67cb00e04f24", "url": "https://github.com/scireum/sirius-biz/commit/a1a9222dc27775642ff314c5fe6c67cb00e04f24", "message": "Apply suggestions from code review\n\nCo-authored-by: jmuscireum <31538484+jmuscireum@users.noreply.github.com>", "committedDate": "2020-06-17T07:32:17Z", "type": "commit"}, {"oid": "d77d8711630af006d2b37da423dcfee4638accda", "url": "https://github.com/scireum/sirius-biz/commit/d77d8711630af006d2b37da423dcfee4638accda", "message": "Adds some JavaDocs.", "committedDate": "2020-06-17T07:33:19Z", "type": "commit"}, {"oid": "565d7fb3a79c4a5e781aaf23c0086efbb5b50dfc", "url": "https://github.com/scireum/sirius-biz/commit/565d7fb3a79c4a5e781aaf23c0086efbb5b50dfc", "message": "Merge branch 'aha/vfs-cleanup' of https://github.com/scireum/sirius-biz into aha/vfs-cleanup", "committedDate": "2020-06-17T07:33:24Z", "type": "commit"}, {"oid": "ad357a9859d441f3ac2f611e565e333fc38ac4bc", "url": "https://github.com/scireum/sirius-biz/commit/ad357a9859d441f3ac2f611e565e333fc38ac4bc", "message": "Merge branch 'master' into aha/vfs-cleanup", "committedDate": "2020-06-17T12:34:40Z", "type": "commit"}]}