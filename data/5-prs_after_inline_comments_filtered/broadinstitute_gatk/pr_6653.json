{"pr_number": 6653, "pr_title": "Adding in ReadSanitizer tool.", "pr_createdAt": "2020-06-09T18:16:32Z", "pr_url": "https://github.com/broadinstitute/gatk/pull/6653", "timeline": [{"oid": "b967904de90c717cd0ca831b06bedf54d6226f50", "url": "https://github.com/broadinstitute/gatk/commit/b967904de90c717cd0ca831b06bedf54d6226f50", "message": "Adding in ReadSanitizer tool.", "committedDate": "2020-06-09T18:14:45Z", "type": "commit"}, {"oid": "e0b9fcbccf43e96e637af657f4881f9162ac45dd", "url": "https://github.com/broadinstitute/gatk/commit/e0b9fcbccf43e96e637af657f4881f9162ac45dd", "message": "Fixing typo.", "committedDate": "2020-06-09T18:18:52Z", "type": "commit"}, {"oid": "dec5c565d78b1eae6c8ff652272b3b7aecb3efbc", "url": "https://github.com/broadinstitute/gatk/commit/dec5c565d78b1eae6c8ff652272b3b7aecb3efbc", "message": "Renaming tool ReadAnonymizer.", "committedDate": "2020-06-09T18:58:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4ODg0OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r437688849", "bodyText": "I always go with lowercase variable names since they're not really immutable", "author": "lbergelson", "createdAt": "2020-06-09T20:10:04Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/ReadAnonymizer.java", "diffHunk": "@@ -0,0 +1,217 @@\n+package org.broadinstitute.hellbender.tools.walkers;\n+\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import org.apache.commons.lang.ArrayUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.engine.ReadWalker;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.filters.CountingReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.OtherProgramGroup;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Replace bases in reads with reference bases.\n+ *\n+ * Used to sanitize data from samples for the purposes of eliminating Personal Identifiable Information.\n+ */\n+@DocumentedFeature\n+@BetaFeature\n+@CommandLineProgramProperties(\n+        summary = \"Replace bases in reads with reference bases.\",\n+        oneLineSummary = \"Replace bases in reads with reference bases.\",\n+        programGroup = OtherProgramGroup.class\n+)\n+public final class ReadAnonymizer extends ReadWalker {\n+\n+    @Argument(\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Output bam file.\")\n+    public GATKPath OUTPUT;", "originalCommit": "dec5c565d78b1eae6c8ff652272b3b7aecb3efbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE1NDgxOA==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r438154818", "bodyText": "Yup.  Copy/Paste error.  Fixed!", "author": "jonn-smith", "createdAt": "2020-06-10T14:13:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4ODg0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5MDYzNw==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r437690637", "bodyText": "This should describe what operations it does so that it's more clear which data is removed.", "author": "lbergelson", "createdAt": "2020-06-09T20:13:29Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/ReadAnonymizer.java", "diffHunk": "@@ -0,0 +1,217 @@\n+package org.broadinstitute.hellbender.tools.walkers;\n+\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import org.apache.commons.lang.ArrayUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.engine.ReadWalker;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.filters.CountingReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.OtherProgramGroup;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Replace bases in reads with reference bases.\n+ *\n+ * Used to sanitize data from samples for the purposes of eliminating Personal Identifiable Information.", "originalCommit": "dec5c565d78b1eae6c8ff652272b3b7aecb3efbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE1ODUxNg==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r438158516", "bodyText": "Yup.  As I mentioned in my high-level comment I'm going to re-describe the tool to confirm explicitly to the guidance we were given.", "author": "jonn-smith", "createdAt": "2020-06-10T14:18:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5MDYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5MTAwMg==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r437691002", "bodyText": "if the default is true you should probably invert the argument", "author": "lbergelson", "createdAt": "2020-06-09T20:14:14Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/ReadAnonymizer.java", "diffHunk": "@@ -0,0 +1,217 @@\n+package org.broadinstitute.hellbender.tools.walkers;\n+\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import org.apache.commons.lang.ArrayUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.engine.ReadWalker;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.filters.CountingReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.OtherProgramGroup;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Replace bases in reads with reference bases.\n+ *\n+ * Used to sanitize data from samples for the purposes of eliminating Personal Identifiable Information.\n+ */\n+@DocumentedFeature\n+@BetaFeature\n+@CommandLineProgramProperties(\n+        summary = \"Replace bases in reads with reference bases.\",\n+        oneLineSummary = \"Replace bases in reads with reference bases.\",\n+        programGroup = OtherProgramGroup.class\n+)\n+public final class ReadAnonymizer extends ReadWalker {\n+\n+    @Argument(\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Output bam file.\")\n+    public GATKPath OUTPUT;\n+\n+    @Argument(\n+            fullName = \"ref-base-quality\",\n+            shortName = \"ref-base-quality\",\n+            doc = \"Quality for bases that are set to the reference base.\",\n+            minValue = 0,\n+            maxValue = 60,\n+            optional = true\n+    )\n+    public int refQual = 60;\n+\n+    @Argument(\n+            fullName = \"use-extended-cigar\",\n+            shortName = \"use-extended-cigar\",\n+            doc = \"If true, will produce `=` instead of `M` for matching bases.\",\n+            optional = true\n+    )\n+    public boolean useExtendedCigar = true;", "originalCommit": "dec5c565d78b1eae6c8ff652272b3b7aecb3efbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE1OTEyOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r438159129", "bodyText": "Sounds good.  I was wondering about this - in the past I've had to change variable names because they had \"not\" or similar in their names.\nI'll update it.", "author": "jonn-smith", "createdAt": "2020-06-10T14:19:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5MTAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5MzE4Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r437693183", "bodyText": "I think this chain of ifs should be a switch statement instead, it would be clear and maybe faster that way.  (Intellij will do that change automatically for you if you ask it nicely).", "author": "lbergelson", "createdAt": "2020-06-09T20:18:23Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/ReadAnonymizer.java", "diffHunk": "@@ -0,0 +1,217 @@\n+package org.broadinstitute.hellbender.tools.walkers;\n+\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import org.apache.commons.lang.ArrayUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.engine.ReadWalker;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.filters.CountingReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.OtherProgramGroup;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Replace bases in reads with reference bases.\n+ *\n+ * Used to sanitize data from samples for the purposes of eliminating Personal Identifiable Information.\n+ */\n+@DocumentedFeature\n+@BetaFeature\n+@CommandLineProgramProperties(\n+        summary = \"Replace bases in reads with reference bases.\",\n+        oneLineSummary = \"Replace bases in reads with reference bases.\",\n+        programGroup = OtherProgramGroup.class\n+)\n+public final class ReadAnonymizer extends ReadWalker {\n+\n+    @Argument(\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Output bam file.\")\n+    public GATKPath OUTPUT;\n+\n+    @Argument(\n+            fullName = \"ref-base-quality\",\n+            shortName = \"ref-base-quality\",\n+            doc = \"Quality for bases that are set to the reference base.\",\n+            minValue = 0,\n+            maxValue = 60,\n+            optional = true\n+    )\n+    public int refQual = 60;\n+\n+    @Argument(\n+            fullName = \"use-extended-cigar\",\n+            shortName = \"use-extended-cigar\",\n+            doc = \"If true, will produce `=` instead of `M` for matching bases.\",\n+            optional = true\n+    )\n+    public boolean useExtendedCigar = true;\n+\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public boolean requiresReference() { return true; }\n+\n+    @Override\n+    public CountingReadFilter makeReadFilter(){\n+        return new CountingReadFilter(ReadFilterLibrary.ALLOW_ALL_READS);\n+    }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        outputWriter = createSAMWriter(OUTPUT, false);\n+    }\n+\n+    @Override\n+    public void apply(final GATKRead read, final ReferenceContext referenceContext, final FeatureContext featureContext ) {\n+\n+        final GATKRead sanitizedRead = anonymizeRead(read, referenceContext);\n+\n+        // Write the read to the output file:\n+        outputWriter.addRead(sanitizedRead);\n+    }\n+\n+    private GATKRead anonymizeRead(final GATKRead read, final ReferenceContext referenceContext) {\n+        final SimpleInterval readInterval  = new SimpleInterval(read.getContig(), read.getStart(), read.getEnd());\n+        final byte[]         readBases     = read.getBasesNoCopy();\n+        final byte[]         readbaseQuals = read.getBaseQualitiesNoCopy();\n+        final byte[]         refBases      = referenceContext.getBases(readInterval);\n+\n+        final List<Byte>         newReadBases     = new ArrayList<>();\n+        final List<Byte>         newBaseQualities = new ArrayList<>();\n+        final List<CigarElement> newCigar         = new ArrayList<>();\n+\n+        int readIndex = 0;\n+        int refIndex = 0;\n+\n+        // Track our current cigar operator so we can accumulate cigars:\n+        CigarOperator currentNewCigarOp = null;\n+        int currentNewCigarOpCount = 0;\n+\n+        CigarOperator iterCigarOp = null;\n+        int iterCigarOpCount = 0;\n+\n+        for ( final CigarElement cigarElement :  read.getCigar().getCigarElements() ) {\n+\n+            // For these elements we don't have to do anything special:\n+            if (cigarElement.getOperator().equals(CigarOperator.H) ||", "originalCommit": "dec5c565d78b1eae6c8ff652272b3b7aecb3efbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE2NzMzNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r438167335", "bodyText": "Works for me.  I use switch statements so rarely I tend not to think of them.", "author": "jonn-smith", "createdAt": "2020-06-10T14:29:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5MzE4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE2NzM5MA==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r438167390", "bodyText": "Fixed!", "author": "jonn-smith", "createdAt": "2020-06-10T14:29:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5MzE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5NDA3OA==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r437694078", "bodyText": "The S case and the EQ case are identical and should be collapsed together.", "author": "lbergelson", "createdAt": "2020-06-09T20:20:06Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/ReadAnonymizer.java", "diffHunk": "@@ -0,0 +1,217 @@\n+package org.broadinstitute.hellbender.tools.walkers;\n+\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import org.apache.commons.lang.ArrayUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.engine.ReadWalker;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.filters.CountingReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.OtherProgramGroup;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Replace bases in reads with reference bases.\n+ *\n+ * Used to sanitize data from samples for the purposes of eliminating Personal Identifiable Information.\n+ */\n+@DocumentedFeature\n+@BetaFeature\n+@CommandLineProgramProperties(\n+        summary = \"Replace bases in reads with reference bases.\",\n+        oneLineSummary = \"Replace bases in reads with reference bases.\",\n+        programGroup = OtherProgramGroup.class\n+)\n+public final class ReadAnonymizer extends ReadWalker {\n+\n+    @Argument(\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Output bam file.\")\n+    public GATKPath OUTPUT;\n+\n+    @Argument(\n+            fullName = \"ref-base-quality\",\n+            shortName = \"ref-base-quality\",\n+            doc = \"Quality for bases that are set to the reference base.\",\n+            minValue = 0,\n+            maxValue = 60,\n+            optional = true\n+    )\n+    public int refQual = 60;\n+\n+    @Argument(\n+            fullName = \"use-extended-cigar\",\n+            shortName = \"use-extended-cigar\",\n+            doc = \"If true, will produce `=` instead of `M` for matching bases.\",\n+            optional = true\n+    )\n+    public boolean useExtendedCigar = true;\n+\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public boolean requiresReference() { return true; }\n+\n+    @Override\n+    public CountingReadFilter makeReadFilter(){\n+        return new CountingReadFilter(ReadFilterLibrary.ALLOW_ALL_READS);\n+    }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        outputWriter = createSAMWriter(OUTPUT, false);\n+    }\n+\n+    @Override\n+    public void apply(final GATKRead read, final ReferenceContext referenceContext, final FeatureContext featureContext ) {\n+\n+        final GATKRead sanitizedRead = anonymizeRead(read, referenceContext);\n+\n+        // Write the read to the output file:\n+        outputWriter.addRead(sanitizedRead);\n+    }\n+\n+    private GATKRead anonymizeRead(final GATKRead read, final ReferenceContext referenceContext) {\n+        final SimpleInterval readInterval  = new SimpleInterval(read.getContig(), read.getStart(), read.getEnd());\n+        final byte[]         readBases     = read.getBasesNoCopy();\n+        final byte[]         readbaseQuals = read.getBaseQualitiesNoCopy();\n+        final byte[]         refBases      = referenceContext.getBases(readInterval);\n+\n+        final List<Byte>         newReadBases     = new ArrayList<>();\n+        final List<Byte>         newBaseQualities = new ArrayList<>();\n+        final List<CigarElement> newCigar         = new ArrayList<>();\n+\n+        int readIndex = 0;\n+        int refIndex = 0;\n+\n+        // Track our current cigar operator so we can accumulate cigars:\n+        CigarOperator currentNewCigarOp = null;\n+        int currentNewCigarOpCount = 0;\n+\n+        CigarOperator iterCigarOp = null;\n+        int iterCigarOpCount = 0;\n+\n+        for ( final CigarElement cigarElement :  read.getCigar().getCigarElements() ) {\n+\n+            // For these elements we don't have to do anything special:\n+            if (cigarElement.getOperator().equals(CigarOperator.H) ||\n+                    cigarElement.getOperator().equals(CigarOperator.N) ||\n+                    cigarElement.getOperator().equals(CigarOperator.P)) {\n+\n+                iterCigarOp = cigarElement.getOperator();\n+                iterCigarOpCount = cigarElement.getLength();\n+            }\n+            else if ( cigarElement.getOperator().equals(CigarOperator.S) ) {", "originalCommit": "dec5c565d78b1eae6c8ff652272b3b7aecb3efbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE2MDk2OA==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r438160968", "bodyText": "Good catch!  Fixed!", "author": "jonn-smith", "createdAt": "2020-06-10T14:21:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5NDA3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5NDk0MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r437694941", "bodyText": "typo.  se teh", "author": "lbergelson", "createdAt": "2020-06-09T20:21:38Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/ReadAnonymizer.java", "diffHunk": "@@ -0,0 +1,217 @@\n+package org.broadinstitute.hellbender.tools.walkers;\n+\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import org.apache.commons.lang.ArrayUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.engine.ReadWalker;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.filters.CountingReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.OtherProgramGroup;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Replace bases in reads with reference bases.\n+ *\n+ * Used to sanitize data from samples for the purposes of eliminating Personal Identifiable Information.\n+ */\n+@DocumentedFeature\n+@BetaFeature\n+@CommandLineProgramProperties(\n+        summary = \"Replace bases in reads with reference bases.\",\n+        oneLineSummary = \"Replace bases in reads with reference bases.\",\n+        programGroup = OtherProgramGroup.class\n+)\n+public final class ReadAnonymizer extends ReadWalker {\n+\n+    @Argument(\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Output bam file.\")\n+    public GATKPath OUTPUT;\n+\n+    @Argument(\n+            fullName = \"ref-base-quality\",\n+            shortName = \"ref-base-quality\",\n+            doc = \"Quality for bases that are set to the reference base.\",\n+            minValue = 0,\n+            maxValue = 60,\n+            optional = true\n+    )\n+    public int refQual = 60;\n+\n+    @Argument(\n+            fullName = \"use-extended-cigar\",\n+            shortName = \"use-extended-cigar\",\n+            doc = \"If true, will produce `=` instead of `M` for matching bases.\",\n+            optional = true\n+    )\n+    public boolean useExtendedCigar = true;\n+\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public boolean requiresReference() { return true; }\n+\n+    @Override\n+    public CountingReadFilter makeReadFilter(){\n+        return new CountingReadFilter(ReadFilterLibrary.ALLOW_ALL_READS);\n+    }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        outputWriter = createSAMWriter(OUTPUT, false);\n+    }\n+\n+    @Override\n+    public void apply(final GATKRead read, final ReferenceContext referenceContext, final FeatureContext featureContext ) {\n+\n+        final GATKRead sanitizedRead = anonymizeRead(read, referenceContext);\n+\n+        // Write the read to the output file:\n+        outputWriter.addRead(sanitizedRead);\n+    }\n+\n+    private GATKRead anonymizeRead(final GATKRead read, final ReferenceContext referenceContext) {\n+        final SimpleInterval readInterval  = new SimpleInterval(read.getContig(), read.getStart(), read.getEnd());\n+        final byte[]         readBases     = read.getBasesNoCopy();\n+        final byte[]         readbaseQuals = read.getBaseQualitiesNoCopy();\n+        final byte[]         refBases      = referenceContext.getBases(readInterval);\n+\n+        final List<Byte>         newReadBases     = new ArrayList<>();\n+        final List<Byte>         newBaseQualities = new ArrayList<>();\n+        final List<CigarElement> newCigar         = new ArrayList<>();\n+\n+        int readIndex = 0;\n+        int refIndex = 0;\n+\n+        // Track our current cigar operator so we can accumulate cigars:\n+        CigarOperator currentNewCigarOp = null;\n+        int currentNewCigarOpCount = 0;\n+\n+        CigarOperator iterCigarOp = null;\n+        int iterCigarOpCount = 0;\n+\n+        for ( final CigarElement cigarElement :  read.getCigar().getCigarElements() ) {\n+\n+            // For these elements we don't have to do anything special:\n+            if (cigarElement.getOperator().equals(CigarOperator.H) ||\n+                    cigarElement.getOperator().equals(CigarOperator.N) ||\n+                    cigarElement.getOperator().equals(CigarOperator.P)) {\n+\n+                iterCigarOp = cigarElement.getOperator();\n+                iterCigarOpCount = cigarElement.getLength();\n+            }\n+            else if ( cigarElement.getOperator().equals(CigarOperator.S) ) {\n+                for (int i = 0; i < cigarElement.getLength(); ++i) {\n+                    newReadBases.add(readBases[readIndex + i]);\n+                    newBaseQualities.add(readbaseQuals[readIndex + i]);\n+                }\n+                iterCigarOp = cigarElement.getOperator();\n+                iterCigarOpCount = cigarElement.getLength();\n+            }\n+            else if ( cigarElement.getOperator().equals(CigarOperator.EQ) ) {\n+                for (int i = 0; i < cigarElement.getLength(); ++i) {\n+                    newReadBases.add(readBases[readIndex + i]);\n+                    newBaseQualities.add(readbaseQuals[readIndex + i]);\n+                }\n+                iterCigarOp = cigarElement.getOperator();\n+                iterCigarOpCount = cigarElement.getLength();\n+            }\n+            // For the rest of the elements, we have to do something more:\n+            else if (cigarElement.getOperator().equals(CigarOperator.M)) {\n+                for (int i = 0; i < cigarElement.getLength(); ++i) {\n+                    newReadBases.add(refBases[refIndex + i]);\n+\n+                    if (readBases[readIndex + i] == refBases[refIndex + i]) {\n+                        // Since the base is the same as the reference anyway, we keep the qual:\n+                        newBaseQualities.add(readbaseQuals[readIndex + i]);\n+                    }\n+                    else {\n+                        // Since we replaced the reference base we se teh quality to 60:", "originalCommit": "dec5c565d78b1eae6c8ff652272b3b7aecb3efbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE2ODc5Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r438168793", "bodyText": "Fixed!", "author": "jonn-smith", "createdAt": "2020-06-10T14:31:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5NDk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5NTI5Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r437695297", "bodyText": "If we really want this to be anonymizing we should really set it to a random value from a distribution that looks like the surrounding qualities or something along those lines.  It might need to be pretty sophisticated to really remove all information (the bqsr model might be a good starting point.)", "author": "lbergelson", "createdAt": "2020-06-09T20:22:16Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/ReadAnonymizer.java", "diffHunk": "@@ -0,0 +1,217 @@\n+package org.broadinstitute.hellbender.tools.walkers;\n+\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import org.apache.commons.lang.ArrayUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.engine.ReadWalker;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.filters.CountingReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.OtherProgramGroup;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Replace bases in reads with reference bases.\n+ *\n+ * Used to sanitize data from samples for the purposes of eliminating Personal Identifiable Information.\n+ */\n+@DocumentedFeature\n+@BetaFeature\n+@CommandLineProgramProperties(\n+        summary = \"Replace bases in reads with reference bases.\",\n+        oneLineSummary = \"Replace bases in reads with reference bases.\",\n+        programGroup = OtherProgramGroup.class\n+)\n+public final class ReadAnonymizer extends ReadWalker {\n+\n+    @Argument(\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Output bam file.\")\n+    public GATKPath OUTPUT;\n+\n+    @Argument(\n+            fullName = \"ref-base-quality\",\n+            shortName = \"ref-base-quality\",\n+            doc = \"Quality for bases that are set to the reference base.\",\n+            minValue = 0,\n+            maxValue = 60,\n+            optional = true\n+    )\n+    public int refQual = 60;\n+\n+    @Argument(\n+            fullName = \"use-extended-cigar\",\n+            shortName = \"use-extended-cigar\",\n+            doc = \"If true, will produce `=` instead of `M` for matching bases.\",\n+            optional = true\n+    )\n+    public boolean useExtendedCigar = true;\n+\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public boolean requiresReference() { return true; }\n+\n+    @Override\n+    public CountingReadFilter makeReadFilter(){\n+        return new CountingReadFilter(ReadFilterLibrary.ALLOW_ALL_READS);\n+    }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        outputWriter = createSAMWriter(OUTPUT, false);\n+    }\n+\n+    @Override\n+    public void apply(final GATKRead read, final ReferenceContext referenceContext, final FeatureContext featureContext ) {\n+\n+        final GATKRead sanitizedRead = anonymizeRead(read, referenceContext);\n+\n+        // Write the read to the output file:\n+        outputWriter.addRead(sanitizedRead);\n+    }\n+\n+    private GATKRead anonymizeRead(final GATKRead read, final ReferenceContext referenceContext) {\n+        final SimpleInterval readInterval  = new SimpleInterval(read.getContig(), read.getStart(), read.getEnd());\n+        final byte[]         readBases     = read.getBasesNoCopy();\n+        final byte[]         readbaseQuals = read.getBaseQualitiesNoCopy();\n+        final byte[]         refBases      = referenceContext.getBases(readInterval);\n+\n+        final List<Byte>         newReadBases     = new ArrayList<>();\n+        final List<Byte>         newBaseQualities = new ArrayList<>();\n+        final List<CigarElement> newCigar         = new ArrayList<>();\n+\n+        int readIndex = 0;\n+        int refIndex = 0;\n+\n+        // Track our current cigar operator so we can accumulate cigars:\n+        CigarOperator currentNewCigarOp = null;\n+        int currentNewCigarOpCount = 0;\n+\n+        CigarOperator iterCigarOp = null;\n+        int iterCigarOpCount = 0;\n+\n+        for ( final CigarElement cigarElement :  read.getCigar().getCigarElements() ) {\n+\n+            // For these elements we don't have to do anything special:\n+            if (cigarElement.getOperator().equals(CigarOperator.H) ||\n+                    cigarElement.getOperator().equals(CigarOperator.N) ||\n+                    cigarElement.getOperator().equals(CigarOperator.P)) {\n+\n+                iterCigarOp = cigarElement.getOperator();\n+                iterCigarOpCount = cigarElement.getLength();\n+            }\n+            else if ( cigarElement.getOperator().equals(CigarOperator.S) ) {\n+                for (int i = 0; i < cigarElement.getLength(); ++i) {\n+                    newReadBases.add(readBases[readIndex + i]);\n+                    newBaseQualities.add(readbaseQuals[readIndex + i]);\n+                }\n+                iterCigarOp = cigarElement.getOperator();\n+                iterCigarOpCount = cigarElement.getLength();\n+            }\n+            else if ( cigarElement.getOperator().equals(CigarOperator.EQ) ) {\n+                for (int i = 0; i < cigarElement.getLength(); ++i) {\n+                    newReadBases.add(readBases[readIndex + i]);\n+                    newBaseQualities.add(readbaseQuals[readIndex + i]);\n+                }\n+                iterCigarOp = cigarElement.getOperator();\n+                iterCigarOpCount = cigarElement.getLength();\n+            }\n+            // For the rest of the elements, we have to do something more:\n+            else if (cigarElement.getOperator().equals(CigarOperator.M)) {\n+                for (int i = 0; i < cigarElement.getLength(); ++i) {\n+                    newReadBases.add(refBases[refIndex + i]);\n+\n+                    if (readBases[readIndex + i] == refBases[refIndex + i]) {\n+                        // Since the base is the same as the reference anyway, we keep the qual:\n+                        newBaseQualities.add(readbaseQuals[readIndex + i]);\n+                    }\n+                    else {\n+                        // Since we replaced the reference base we se teh quality to 60:\n+                        newBaseQualities.add((byte)refQual);", "originalCommit": "dec5c565d78b1eae6c8ff652272b3b7aecb3efbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE3MzQxNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r438173415", "bodyText": "Yeah.  My scope for the tool was too overreaching.  By the rules handed down to us, we just need to change the bases that do not match the reference back to reference bases.", "author": "jonn-smith", "createdAt": "2020-06-10T14:36:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5NTI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5NzQxMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r437697411", "bodyText": "By using ALLOW_ALL_READS you're letting in reads that will crash this tool.  You need to either add back the filters:\nVALID_ALIGNMENT_START, VALID_ALIGNMENT_END,  alignmentAgreesWithHeader, HAS_MATCHING_BASES_AND_QUALS, READLENGTH_EQUALS_CIGARLENGTH, and SEQ_IS_STORED\nor make the tool handle discrepancies in these values.", "author": "lbergelson", "createdAt": "2020-06-09T20:26:25Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/ReadAnonymizer.java", "diffHunk": "@@ -0,0 +1,217 @@\n+package org.broadinstitute.hellbender.tools.walkers;\n+\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import org.apache.commons.lang.ArrayUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.engine.ReadWalker;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.filters.CountingReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.OtherProgramGroup;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Replace bases in reads with reference bases.\n+ *\n+ * Used to sanitize data from samples for the purposes of eliminating Personal Identifiable Information.\n+ */\n+@DocumentedFeature\n+@BetaFeature\n+@CommandLineProgramProperties(\n+        summary = \"Replace bases in reads with reference bases.\",\n+        oneLineSummary = \"Replace bases in reads with reference bases.\",\n+        programGroup = OtherProgramGroup.class\n+)\n+public final class ReadAnonymizer extends ReadWalker {\n+\n+    @Argument(\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Output bam file.\")\n+    public GATKPath OUTPUT;\n+\n+    @Argument(\n+            fullName = \"ref-base-quality\",\n+            shortName = \"ref-base-quality\",\n+            doc = \"Quality for bases that are set to the reference base.\",\n+            minValue = 0,\n+            maxValue = 60,\n+            optional = true\n+    )\n+    public int refQual = 60;\n+\n+    @Argument(\n+            fullName = \"use-extended-cigar\",\n+            shortName = \"use-extended-cigar\",\n+            doc = \"If true, will produce `=` instead of `M` for matching bases.\",\n+            optional = true\n+    )\n+    public boolean useExtendedCigar = true;\n+\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public boolean requiresReference() { return true; }\n+\n+    @Override\n+    public CountingReadFilter makeReadFilter(){\n+        return new CountingReadFilter(ReadFilterLibrary.ALLOW_ALL_READS);", "originalCommit": "dec5c565d78b1eae6c8ff652272b3b7aecb3efbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxNDY3NA==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r437714674", "bodyText": "You should filter out every unmapped read because they contain identifying kmers which cannot be corrected.", "author": "lbergelson", "createdAt": "2020-06-09T20:54:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5NzQxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxODYzNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r437718635", "bodyText": "You might want to filter everything aligned to alt contigs since their presence probably has identifying information about ethnicity.  Similarly you probably need to remove anything related to HLA.  You might also need to censor all of the MHC as well on chr6 since you can probably infer some information about HLA type from the coverage there.  I don't know how careful you have to be.  There may be other sites where coverage provides a strong identifying signal as well.", "author": "lbergelson", "createdAt": "2020-06-09T20:58:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5NzQxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE3NjIxMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r438176211", "bodyText": "Good point.  I'll update the filter to include those, as well as the unmapped reads.  I'm not going to add in any other filtering since that was not the guidance we were given.", "author": "jonn-smith", "createdAt": "2020-06-10T14:40:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5NzQxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcwNjA5NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r437706095", "bodyText": "Intellij says this condition is always true", "author": "lbergelson", "createdAt": "2020-06-09T20:43:22Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/ReadAnonymizer.java", "diffHunk": "@@ -0,0 +1,217 @@\n+package org.broadinstitute.hellbender.tools.walkers;\n+\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import org.apache.commons.lang.ArrayUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.engine.ReadWalker;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.filters.CountingReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.OtherProgramGroup;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Replace bases in reads with reference bases.\n+ *\n+ * Used to sanitize data from samples for the purposes of eliminating Personal Identifiable Information.\n+ */\n+@DocumentedFeature\n+@BetaFeature\n+@CommandLineProgramProperties(\n+        summary = \"Replace bases in reads with reference bases.\",\n+        oneLineSummary = \"Replace bases in reads with reference bases.\",\n+        programGroup = OtherProgramGroup.class\n+)\n+public final class ReadAnonymizer extends ReadWalker {\n+\n+    @Argument(\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Output bam file.\")\n+    public GATKPath OUTPUT;\n+\n+    @Argument(\n+            fullName = \"ref-base-quality\",\n+            shortName = \"ref-base-quality\",\n+            doc = \"Quality for bases that are set to the reference base.\",\n+            minValue = 0,\n+            maxValue = 60,\n+            optional = true\n+    )\n+    public int refQual = 60;\n+\n+    @Argument(\n+            fullName = \"use-extended-cigar\",\n+            shortName = \"use-extended-cigar\",\n+            doc = \"If true, will produce `=` instead of `M` for matching bases.\",\n+            optional = true\n+    )\n+    public boolean useExtendedCigar = true;\n+\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public boolean requiresReference() { return true; }\n+\n+    @Override\n+    public CountingReadFilter makeReadFilter(){\n+        return new CountingReadFilter(ReadFilterLibrary.ALLOW_ALL_READS);\n+    }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        outputWriter = createSAMWriter(OUTPUT, false);\n+    }\n+\n+    @Override\n+    public void apply(final GATKRead read, final ReferenceContext referenceContext, final FeatureContext featureContext ) {\n+\n+        final GATKRead sanitizedRead = anonymizeRead(read, referenceContext);\n+\n+        // Write the read to the output file:\n+        outputWriter.addRead(sanitizedRead);\n+    }\n+\n+    private GATKRead anonymizeRead(final GATKRead read, final ReferenceContext referenceContext) {\n+        final SimpleInterval readInterval  = new SimpleInterval(read.getContig(), read.getStart(), read.getEnd());\n+        final byte[]         readBases     = read.getBasesNoCopy();\n+        final byte[]         readbaseQuals = read.getBaseQualitiesNoCopy();\n+        final byte[]         refBases      = referenceContext.getBases(readInterval);\n+\n+        final List<Byte>         newReadBases     = new ArrayList<>();\n+        final List<Byte>         newBaseQualities = new ArrayList<>();\n+        final List<CigarElement> newCigar         = new ArrayList<>();\n+\n+        int readIndex = 0;\n+        int refIndex = 0;\n+\n+        // Track our current cigar operator so we can accumulate cigars:\n+        CigarOperator currentNewCigarOp = null;\n+        int currentNewCigarOpCount = 0;\n+\n+        CigarOperator iterCigarOp = null;\n+        int iterCigarOpCount = 0;\n+\n+        for ( final CigarElement cigarElement :  read.getCigar().getCigarElements() ) {\n+\n+            // For these elements we don't have to do anything special:\n+            if (cigarElement.getOperator().equals(CigarOperator.H) ||\n+                    cigarElement.getOperator().equals(CigarOperator.N) ||\n+                    cigarElement.getOperator().equals(CigarOperator.P)) {\n+\n+                iterCigarOp = cigarElement.getOperator();\n+                iterCigarOpCount = cigarElement.getLength();\n+            }\n+            else if ( cigarElement.getOperator().equals(CigarOperator.S) ) {\n+                for (int i = 0; i < cigarElement.getLength(); ++i) {\n+                    newReadBases.add(readBases[readIndex + i]);\n+                    newBaseQualities.add(readbaseQuals[readIndex + i]);\n+                }\n+                iterCigarOp = cigarElement.getOperator();\n+                iterCigarOpCount = cigarElement.getLength();\n+            }\n+            else if ( cigarElement.getOperator().equals(CigarOperator.EQ) ) {\n+                for (int i = 0; i < cigarElement.getLength(); ++i) {\n+                    newReadBases.add(readBases[readIndex + i]);\n+                    newBaseQualities.add(readbaseQuals[readIndex + i]);\n+                }\n+                iterCigarOp = cigarElement.getOperator();\n+                iterCigarOpCount = cigarElement.getLength();\n+            }\n+            // For the rest of the elements, we have to do something more:\n+            else if (cigarElement.getOperator().equals(CigarOperator.M)) {\n+                for (int i = 0; i < cigarElement.getLength(); ++i) {\n+                    newReadBases.add(refBases[refIndex + i]);\n+\n+                    if (readBases[readIndex + i] == refBases[refIndex + i]) {\n+                        // Since the base is the same as the reference anyway, we keep the qual:\n+                        newBaseQualities.add(readbaseQuals[readIndex + i]);\n+                    }\n+                    else {\n+                        // Since we replaced the reference base we se teh quality to 60:\n+                        newBaseQualities.add((byte)refQual);\n+                    }\n+                }\n+                iterCigarOp = useExtendedCigar ? CigarOperator.EQ : CigarOperator.M;\n+                iterCigarOpCount = cigarElement.getLength();\n+            }\n+            else if (cigarElement.getOperator().equals(CigarOperator.X) ||\n+                    cigarElement.getOperator().equals(CigarOperator.D) ) {\n+\n+                // For these operators we need to add in the reference bases as matches:\n+                for (int i = 0; i < cigarElement.getLength(); ++i) {\n+                    newReadBases.add(refBases[refIndex + i]);\n+                    // Since we know it's the reference base, we set it to the max quality (60):\n+                    newBaseQualities.add((byte)refQual);\n+                }\n+                iterCigarOp = useExtendedCigar ? CigarOperator.EQ : CigarOperator.M;\n+                iterCigarOpCount = cigarElement.getLength();\n+            }\n+            else if (cigarElement.getOperator().equals(CigarOperator.I)) {\n+                // Inserted bases are simply removed and ignored.\n+                iterCigarOp = currentNewCigarOp;\n+                iterCigarOpCount = 0;\n+            }\n+            else {\n+                throw new UserException.MalformedFile(\"Unexpected cigar operation: \" + cigarElement.toString());\n+            }\n+\n+            // Update Cigar:\n+            if ( iterCigarOp == currentNewCigarOp ) {\n+                currentNewCigarOpCount += iterCigarOpCount;\n+            }\n+            else {\n+                if ( currentNewCigarOp != null ) {\n+                    newCigar.add(new CigarElement(currentNewCigarOpCount, currentNewCigarOp));\n+                }\n+                currentNewCigarOp = iterCigarOp;\n+                currentNewCigarOpCount = iterCigarOpCount;\n+            }\n+\n+            // Update indices:\n+            if (cigarElement.getOperator().consumesReferenceBases()) {\n+                refIndex += cigarElement.getLength();\n+            }\n+            if (cigarElement.getOperator().consumesReadBases()) {\n+                readIndex += cigarElement.getLength();\n+            }\n+        }\n+\n+        // Add in the last cigar element now that we're done iterating:\n+        if ( iterCigarOp == currentNewCigarOp ) {", "originalCommit": "dec5c565d78b1eae6c8ff652272b3b7aecb3efbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIyMDExMw==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r438220113", "bodyText": "Yup.  I missed that warning.  If statement removed.", "author": "jonn-smith", "createdAt": "2020-06-10T15:37:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcwNjA5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxMTEzMg==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r437711132", "bodyText": "I think you need to remove all the tags from the reads as well as clean the header.  The tags contain a lot of information which could potentially be identifying (they include for instance an array saying what all the mismatching bases are and where they are...). The header could easily include personal information as well.\nI'm not sure how strict you have to be about anonymizing things.", "author": "lbergelson", "createdAt": "2020-06-09T20:49:56Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/ReadAnonymizer.java", "diffHunk": "@@ -0,0 +1,217 @@\n+package org.broadinstitute.hellbender.tools.walkers;\n+\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import org.apache.commons.lang.ArrayUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.engine.ReadWalker;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.filters.CountingReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.OtherProgramGroup;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Replace bases in reads with reference bases.\n+ *\n+ * Used to sanitize data from samples for the purposes of eliminating Personal Identifiable Information.\n+ */\n+@DocumentedFeature\n+@BetaFeature\n+@CommandLineProgramProperties(\n+        summary = \"Replace bases in reads with reference bases.\",\n+        oneLineSummary = \"Replace bases in reads with reference bases.\",\n+        programGroup = OtherProgramGroup.class\n+)\n+public final class ReadAnonymizer extends ReadWalker {", "originalCommit": "dec5c565d78b1eae6c8ff652272b3b7aecb3efbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyMTIzNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r437721235", "bodyText": "You might want to strip readnames as well.  Most people don't put the sample name in them probably, but you never know...", "author": "lbergelson", "createdAt": "2020-06-09T21:03:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxMTEzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIzMzUzOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r438233539", "bodyText": "I'll strip the tags (except for the read group).\nI'm not going to sanitize the header or the readnames - per the instructions I was given this isn't necessary.", "author": "jonn-smith", "createdAt": "2020-06-10T15:56:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxMTEzMg=="}], "type": "inlineReview"}, {"oid": "3333a1c680288fcdb81d6e06d47f859086172354", "url": "https://github.com/broadinstitute/gatk/commit/3333a1c680288fcdb81d6e06d47f859086172354", "message": "Addressing code review comments.", "committedDate": "2020-06-10T16:14:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1ODQ5MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r438258491", "bodyText": "this comment isn't quite right since the quality isn't necessarily max", "author": "lbergelson", "createdAt": "2020-06-10T16:31:49Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/ReadAnonymizer.java", "diffHunk": "@@ -108,66 +132,58 @@ private GATKRead anonymizeRead(final GATKRead read, final ReferenceContext refer\n \n         for ( final CigarElement cigarElement :  read.getCigar().getCigarElements() ) {\n \n-            // For these elements we don't have to do anything special:\n-            if (cigarElement.getOperator().equals(CigarOperator.H) ||\n-                    cigarElement.getOperator().equals(CigarOperator.N) ||\n-                    cigarElement.getOperator().equals(CigarOperator.P)) {\n-\n-                iterCigarOp = cigarElement.getOperator();\n-                iterCigarOpCount = cigarElement.getLength();\n-            }\n-            else if ( cigarElement.getOperator().equals(CigarOperator.S) ) {\n-                for (int i = 0; i < cigarElement.getLength(); ++i) {\n-                    newReadBases.add(readBases[readIndex + i]);\n-                    newBaseQualities.add(readbaseQuals[readIndex + i]);\n-                }\n-                iterCigarOp = cigarElement.getOperator();\n-                iterCigarOpCount = cigarElement.getLength();\n-            }\n-            else if ( cigarElement.getOperator().equals(CigarOperator.EQ) ) {\n-                for (int i = 0; i < cigarElement.getLength(); ++i) {\n-                    newReadBases.add(readBases[readIndex + i]);\n-                    newBaseQualities.add(readbaseQuals[readIndex + i]);\n-                }\n-                iterCigarOp = cigarElement.getOperator();\n-                iterCigarOpCount = cigarElement.getLength();\n-            }\n-            // For the rest of the elements, we have to do something more:\n-            else if (cigarElement.getOperator().equals(CigarOperator.M)) {\n-                for (int i = 0; i < cigarElement.getLength(); ++i) {\n-                    newReadBases.add(refBases[refIndex + i]);\n-\n-                    if (readBases[readIndex + i] == refBases[refIndex + i]) {\n-                        // Since the base is the same as the reference anyway, we keep the qual:\n+            switch (cigarElement.getOperator()) {\n+                // For these elements we don't have to do anything special:\n+                case H:\n+                case N:\n+                case P:\n+                    iterCigarOp = cigarElement.getOperator();\n+                    iterCigarOpCount = cigarElement.getLength();\n+                    break;\n+                case S:\n+                case EQ:\n+                    for (int i = 0; i < cigarElement.getLength(); ++i) {\n+                        newReadBases.add(readBases[readIndex + i]);\n                         newBaseQualities.add(readbaseQuals[readIndex + i]);\n                     }\n-                    else {\n-                        // Since we replaced the reference base we se teh quality to 60:\n+                    iterCigarOp = cigarElement.getOperator();\n+                    iterCigarOpCount = cigarElement.getLength();\n+                    break;\n+                // For the rest of the elements, we have to do something more:\n+                case M:\n+                    for (int i = 0; i < cigarElement.getLength(); ++i) {\n+                        newReadBases.add(refBases[refIndex + i]);\n+\n+                        if (readBases[readIndex + i] == refBases[refIndex + i]) {\n+                            // Since the base is the same as the reference anyway, we keep the qual:\n+                            newBaseQualities.add(readbaseQuals[readIndex + i]);\n+                        }\n+                        else {\n+                            // Since we replaced the reference base we set the quality to 60:\n+                            newBaseQualities.add((byte)refQual);\n+                        }\n+                    }\n+                    iterCigarOp = useSimpleCigar ? CigarOperator.M : CigarOperator.EQ;\n+                    iterCigarOpCount = cigarElement.getLength();\n+                    break;\n+                case X:\n+                case D:\n+                    // For these operators we need to add in the reference bases as matches:\n+                    for (int i = 0; i < cigarElement.getLength(); ++i) {\n+                        newReadBases.add(refBases[refIndex + i]);\n+                        // Since we know it's the reference base, we set it to the max quality (60):", "originalCommit": "3333a1c680288fcdb81d6e06d47f859086172354", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI2MjAyMA==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r438262020", "bodyText": "Ah.  Yeah - we just always use 60 as our max.  It's a parameter now anyway so it's inaccurate for two reasons.", "author": "jonn-smith", "createdAt": "2020-06-10T16:37:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1ODQ5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI2MDUyMA==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r438260520", "bodyText": "I might make this experimental instead of beta.  It seems like a very one-off sort of thing that isn't generally useful, since reads that have all the sequencing data removed are not a particularly in demand resources...", "author": "lbergelson", "createdAt": "2020-06-10T16:35:08Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/ReadAnonymizer.java", "diffHunk": "@@ -27,7 +29,20 @@\n /**\n  * Replace bases in reads with reference bases.\n  *\n- * Used to sanitize data from samples for the purposes of eliminating Personal Identifiable Information.\n+ * Used to anonymize reads with information from the reference.\n+ * This tool is useful in the case where you want to use data for analysis,\n+ * but cannot publish the data without anonymizing the sequence information.\n+ *\n+ * Reads are processed, then emitted in a new file.  For a read to be processed\n+ * it must have valid start/end positions, sequence information, and consistent\n+ * lengths between the sequence, base qualities, and CIGAR string.  In addition\n+ * reads must be consistent with the read file header's sequence dictionary.\n+ *\n+ * For each aligned read, any base that does not match the reference is transformed\n+ * to the reference base.  For any transformed bases, the quality is set to a constant\n+ * value ({@link #refQual}).  For bases not transformed, the quality is preserved.\n+ * Reads transformed in this way also have their CIGARs rewritten to match the new\n+ * sequence information.\n  */\n @DocumentedFeature\n @BetaFeature", "originalCommit": "3333a1c680288fcdb81d6e06d47f859086172354", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI2MjM2MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6653#discussion_r438262361", "bodyText": "Sure.  fixed.", "author": "jonn-smith", "createdAt": "2020-06-10T16:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI2MDUyMA=="}], "type": "inlineReview"}, {"oid": "2e7d02c7517dfe366171c0831e04198527476008", "url": "https://github.com/broadinstitute/gatk/commit/2e7d02c7517dfe366171c0831e04198527476008", "message": "Addressing final review comments.", "committedDate": "2020-06-10T16:39:23Z", "type": "commit"}]}