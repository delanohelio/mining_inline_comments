{"pr_number": 6611, "pr_title": "htsgetReader", "pr_createdAt": "2020-05-19T20:15:12Z", "pr_url": "https://github.com/broadinstitute/gatk/pull/6611", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxODQxNw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r428318417", "bodyText": "The enum options should be automatically listed in the help by the engine, no need to include them here unless they are a subset of what's allowed by the enum.", "author": "lbergelson", "createdAt": "2020-05-20T21:30:27Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2MjkyNw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432662927", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:27:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxODQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NDU4Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429464583", "bodyText": "Tools should all have a class level javadoc comment describing them in more detail and including a usage example.", "author": "lbergelson", "createdAt": "2020-05-22T21:45:44Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2MzAwMw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432663003", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NDU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NDk3NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429464975", "bodyText": "Nitpick and one that others might disagree with.  I'd probably leave the line breaks off after the ( and before the ) to save some space in this argument list.", "author": "lbergelson", "createdAt": "2020-05-22T21:47:03Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2NDI5MA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432664290", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:30:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NDk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NTQxMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429465411", "bodyText": "GATK for historical reasons uses 1-based inclusive intervals.  The tool should adapt the given intervals to match what htsget needs.", "author": "lbergelson", "createdAt": "2020-05-22T21:48:42Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2NDQ5MA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432664490", "bodyText": "The tool accepts a SimpleInterval now.", "author": "andersleung", "createdAt": "2020-05-29T18:30:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NTQxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3Mzg4NA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429473884", "bodyText": "Another historical oddity, when specifying multiple options to an argument we typically specify the argument multiple times rather than specifying a list and parsing it out.", "author": "lbergelson", "createdAt": "2020-05-22T22:04:31Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2NTUxMg==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432665512", "bodyText": "I had realized this but the doc comment was incorrectly phrased because I copied it verbatim from the spec. Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:33:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3Mzg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NDcyNw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429474727", "bodyText": "We typically call this the \"contig name\" because people confuse reference sequence with the entire reference sequence (i.e. hg19).", "author": "lbergelson", "createdAt": "2020-05-22T22:08:29Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2NTg4Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432665882", "bodyText": "Replaced with SimpleInterval argument. Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:33:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NDcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NTA3Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429475077", "bodyText": "So this tool is extending GATKTool, but it's not integrating with any of the functionality of GATKTool.  Ideally I think a final version of this tool maybe should be a GATKTool, but that means it has to understand the various arguments like \"-L\" for intervals and the various toggles, as well as things like integrating a progress meter.\nThose are all good goals, but since this isn't doing it yet I think it makes more sense to extend CommandLineProgram for the moment which has less implementation baggage.", "author": "lbergelson", "createdAt": "2020-05-22T22:10:15Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NjAwNg==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429666006", "bodyText": "Some additional thoughts about this.\n\n\nIt would be good if this could produce a complete bam /vcf with a header attached.  Ideally you could provide an interval list, and it would get the header, the data from all of the relevant intervals, and then combine them into a single file.  I think this is a good idea for a v2 of this tool.\n\n\nIs it safe to concatenate the file chunks that htsget returns?  If they are independent bam / cram files it's not generally safe to concatenate them.  Bams have bgzf terminator blocks at their end that have to be stripped.  I'm not certain about how concatenating crams works.  Similarly, compressed vcf chunks need to have terminators stripped.  I don't know if htsget does that for you?\n\n\nI don't see you filtering the returned data to the relevant interval anywhere.  Since htsget may return additional data around your interval you should either be extremely clear in the documentation that you may get more than you asked for OR we have to do the filtering within the tool.  (for v2 we should definitely do the filtering.)\n\n\nWe should be clear about how unmapped reads are handled.  GATK allows specifying UNMAPPED as an interval which is available as part of the traversal parameters from the interval argument collection.  You might want to deal with that or explain the special treatment of null reference vs * reference in the doc.", "author": "lbergelson", "createdAt": "2020-05-24T19:10:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NTA3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NTU2NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429475565", "bodyText": "We've mostly stopped adding shortname abbreviations for tool arguments that only are used in 1 tool.  They tend to be difficult to remember and not a huge benefit.", "author": "lbergelson", "createdAt": "2020-05-22T22:12:44Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2NTk0NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432665945", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:34:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NTU2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NTg4MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429475881", "bodyText": "You have to check for null here since it could have before variables are initialized.", "author": "lbergelson", "createdAt": "2020-05-22T22:14:30Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NjE1OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429476159", "bodyText": "GATKTool subclasses must call super.onShutDown() as part of their shutdown sequence.", "author": "lbergelson", "createdAt": "2020-05-22T22:15:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NTg4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1NjE5Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429656192", "bodyText": "Is it necessary to close the executor service here as well?  You might want to call shutdownNow().", "author": "lbergelson", "createdAt": "2020-05-24T17:07:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NTg4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2NjE5MA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432666190", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:34:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NTg4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NjI5MA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429476290", "bodyText": "You might want to attach the exception to the warning so people know WHAT error occurred.", "author": "lbergelson", "createdAt": "2020-05-22T22:16:21Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2NjI2NA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432666264", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:34:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NjI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NzI3MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429477271", "bodyText": "could you import the version of this from com.google.common.util.concurrent.ThreadFactoryBuilder instead of the shaded apache one that it's using now?", "author": "lbergelson", "createdAt": "2020-05-22T22:21:03Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2NjI5Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432666293", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:34:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NzI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NzY3Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429477676", "bodyText": "Could you include the error code in this message?  I'm not clear if it gets propagated to the user.", "author": "lbergelson", "createdAt": "2020-05-22T22:23:01Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2ODMzMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432668331", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:39:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NzY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NzgxNA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429477814", "bodyText": "Could you explain a bit more about this?  Is this the standard way to retry requests in this library?", "author": "lbergelson", "createdAt": "2020-05-22T22:23:48Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1MzUxMg==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429653512", "bodyText": "Some minor skimming of the library doc, isn't the RetryHandler the mechanism to control retry behavior?", "author": "lbergelson", "createdAt": "2020-05-24T16:32:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NzgxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2ODE5Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432668197", "bodyText": "Changed to use ServiceUnavailableRetryStrategy which allows retrying based on the contents of the HttpResponse, since we're only interested in retrying on 5xx error codes as per the spec, while the default retry handler will handle retrying on IOExceptions etc.", "author": "andersleung", "createdAt": "2020-05-29T18:38:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NzgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1NDE3MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429654171", "bodyText": "Needs a class comment, mention that this  list is defined by the spec.", "author": "lbergelson", "createdAt": "2020-05-24T16:41:20Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/htsgetreader/HtsgetFormat.java", "diffHunk": "@@ -0,0 +1,8 @@\n+package org.broadinstitute.hellbender.tools.htsgetreader;\n+\n+public enum HtsgetFormat {", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2ODM4OA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432668388", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:39:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1NDE3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1NDMwNw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429654307", "bodyText": "Nitpick: I'd probably add line breaks between things that have annotations on them for clarity.", "author": "lbergelson", "createdAt": "2020-05-24T16:43:05Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/htsgetreader/HtsgetErrorResponse.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.broadinstitute.hellbender.tools.htsgetreader;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonRootName;\n+\n+/**\n+ * Class allowing deserialization from json htsget error response\n+ */\n+@JsonRootName(value = \"htsget\")\n+public class HtsgetErrorResponse {\n+    @JsonProperty(\"error\")\n+    public String error;", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2ODQ1Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432668453", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:39:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1NDMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1NDM1Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429654356", "bodyText": "Add a class comment including the fact that these are named in the spec itself.", "author": "lbergelson", "createdAt": "2020-05-24T16:43:42Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/htsgetreader/HtsgetClass.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package org.broadinstitute.hellbender.tools.htsgetreader;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+public enum HtsgetClass {", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2OTMwOA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432669308", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:41:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1NDM1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1NDUzOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429654539", "bodyText": "This is unnecessary because the name is the same as the enum name.  Did you intend to ALL_CAPS the enum name  as recommended but then had weird argument parsing issues with the disparity between the toString and the object name?", "author": "lbergelson", "createdAt": "2020-05-24T16:46:32Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/htsgetreader/HtsgetClass.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package org.broadinstitute.hellbender.tools.htsgetreader;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+public enum HtsgetClass {\n+    @JsonProperty(\"body\")\n+    body(\"body\"),\n+    @JsonProperty(\"header\")\n+    header(\"header\");\n+\n+    private final String name;\n+\n+    private HtsgetClass(final String name) {", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2OTQ2OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432669469", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:41:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1NDUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1NDk4Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429654986", "bodyText": "This method should be part of HtsgetRequest.", "author": "lbergelson", "createdAt": "2020-05-24T16:52:49Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2OTUyOA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432669528", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:41:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1NDk4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1NTE2Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429655167", "bodyText": "Since the two request types are so different it might make sense to extract out a request interface or abstract class implement two concrete request classes.  One for header and one for body.   Optional.", "author": "lbergelson", "createdAt": "2020-05-24T16:55:10Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1NTg3NA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429655874", "bodyText": "In GATK we always bundle ranges into SimpleInterval or Locatable objects and pass them around together.  You could replace these 3 arguments with an OptionalIntervalArgumentCollection.  (your tool already accepts one of these since it extends GATK tool.  )  Then you can access the intervals using getIntervals (or better, getTraversalParameters).  There's a hitch though, getIntervals requires a SamSequenceDictionary for validation.  This is normally in the bam header, but since we don't have the header it means we'd have to either pass in a header or make an htsget query for it.   Either would work but both are kind of complicated.  Possibly that's a better idea for v2 of this tool.\nAlternatively you could accept a SimpleInterval as a commandline argument directly.\nNote that SimpleInterval (and all of gatk) use 1 -based inclusive intervals.  You should use this convention in most of the code and then convert internally in the classes that build the headers.", "author": "lbergelson", "createdAt": "2020-05-24T17:04:26Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3MDA0Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432670043", "bodyText": "Changed to accept a SimpleInterval. Fixed", "author": "andersleung", "createdAt": "2020-05-29T18:42:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1NTg3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1NjUxNA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429656514", "bodyText": "I think the error message is backwards.  Shouldn't it be \"start may not be greater than end\"?", "author": "lbergelson", "createdAt": "2020-05-24T17:12:11Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1NjY1NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429656655", "bodyText": "These errors are prevented if you use SimpleInterval since it does validation to ensure these conditions, although they still might be valuable since you're going to have to do an internal conversion from [1,2] -> [0,2) style coordinates", "author": "lbergelson", "createdAt": "2020-05-24T17:13:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1NjUxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3MDE1Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432670157", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:42:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1NjUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1Njg4OA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429656888", "bodyText": "it's good practice in gatk to make all variables final if they can be", "author": "lbergelson", "createdAt": "2020-05-24T17:15:57Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3MDIwMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432670201", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:43:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1Njg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1NjkyNg==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429656926", "bodyText": "this method doesn't actually throw IOException since it catches it", "author": "lbergelson", "createdAt": "2020-05-24T17:16:36Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3MDcxNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432670715", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:44:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1NjkyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1Njk4Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429656982", "bodyText": "Always attach the original exception when re-wrapping and propagating exceptions.", "author": "lbergelson", "createdAt": "2020-05-24T17:17:25Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Block block : response.getBlocks()) {\n+                InputStream istream;\n+                switch (block.getUri().getScheme()) {\n+                    case \"http\":\n+                    case \"https\":\n+                        HttpGet get = new HttpGet(block.getUri());\n+                        block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        istream = entity.getContent();\n+                        break;\n+                    case \"data\":\n+                        String dataUri = block.getUri().toString();\n+                        if (! dataUri.matches(\"^data:.*;base64,.*\")) {\n+                            throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                        }\n+                        istream = new ByteArrayInputStream(\n+                            Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                        break;\n+                    default:\n+                        throw new UserException(\"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+                }\n+                IOUtils.copy(istream, ostream);\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + outputFile);", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3MDc2Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432670763", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:44:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1Njk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2MjAzOA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429662038", "bodyText": "Does this only apply to BAM fields? Does it do anything for vcf?", "author": "lbergelson", "createdAt": "2020-05-24T18:21:43Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2MjkyMw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429662923", "bodyText": "I think this is an ideal opportunity for refactoring.  There is a ton of shared code between getData and getDataParallel.  It seems like it would make sense to push functionality for getting an output stream into the block class itself, then the getData method could call those in series and getDataParallel could call them as asynchronous futures.   It might make sense to have 2 different block implementations, 1 for data blocks and 1 for http url blocks.", "author": "lbergelson", "createdAt": "2020-05-24T18:31:57Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3MTM4Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432671387", "bodyText": "Changed by moving the code for getting an OutputStream to the Block class. I decided against splitting Block into two classes because this would complicate deserializing with Jackson more than it would be worth, in my opinion", "author": "andersleung", "createdAt": "2020-05-29T18:45:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2MjkyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2MzIwMw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429663203", "bodyText": "GATK provides IOUtils.createTempPath() which schedules the temporary files for deletion on shutdown.  This helps clean up in case of errors.  I would use that here.  I would also give the files some prefix to make it clear what they are if someone is debugging or if cleanup fails.  Something like \"htsget-temp\".", "author": "lbergelson", "createdAt": "2020-05-24T18:35:00Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Block block : response.getBlocks()) {\n+                InputStream istream;\n+                switch (block.getUri().getScheme()) {\n+                    case \"http\":\n+                    case \"https\":\n+                        HttpGet get = new HttpGet(block.getUri());\n+                        block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        istream = entity.getContent();\n+                        break;\n+                    case \"data\":\n+                        String dataUri = block.getUri().toString();\n+                        if (! dataUri.matches(\"^data:.*;base64,.*\")) {\n+                            throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                        }\n+                        istream = new ByteArrayInputStream(\n+                            Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                        break;\n+                    default:\n+                        throw new UserException(\"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+                }\n+                IOUtils.copy(istream, ostream);\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Downloads data blocks provided by response to outputFile in parallel,\n+     * using the number of threads specified by user\n+     */\n+    private void getDataParallel(HtsgetResponse response) throws IOException {\n+        List<Future<Path>> futures = new ArrayList<>(response.getBlocks().size());\n+        for (Block block : response.getBlocks()) {\n+            switch (block.getUri().getScheme()) {\n+                case \"http\":\n+                case \"https\":\n+                    HttpGet get = new HttpGet(block.getUri());\n+                    block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                    futures.add(this.executorService.submit(() -> {\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        byte[] bytes = IOUtils.toByteArray(entity.getContent());\n+                        EntityUtils.consume(entity);\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                IOUtils.copy(new ByteArrayInputStream(bytes), ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                case \"data\":\n+                    String dataUri = block.getUri().toString();\n+                    if (!dataUri.matches(\"^data:.*;base64,.*\")) {\n+                        throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                    }\n+                    futures.add(this.executorService.submit(() -> {\n+                        Path tempFile = Files.createTempFile(\"\", \"\");", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3MTcwMg==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432671702", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:46:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2MzIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2MzMxNw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429663317", "bodyText": "Attach the exception as well.", "author": "lbergelson", "createdAt": "2020-05-24T18:36:22Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Block block : response.getBlocks()) {\n+                InputStream istream;\n+                switch (block.getUri().getScheme()) {\n+                    case \"http\":\n+                    case \"https\":\n+                        HttpGet get = new HttpGet(block.getUri());\n+                        block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        istream = entity.getContent();\n+                        break;\n+                    case \"data\":\n+                        String dataUri = block.getUri().toString();\n+                        if (! dataUri.matches(\"^data:.*;base64,.*\")) {\n+                            throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                        }\n+                        istream = new ByteArrayInputStream(\n+                            Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                        break;\n+                    default:\n+                        throw new UserException(\"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+                }\n+                IOUtils.copy(istream, ostream);\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Downloads data blocks provided by response to outputFile in parallel,\n+     * using the number of threads specified by user\n+     */\n+    private void getDataParallel(HtsgetResponse response) throws IOException {\n+        List<Future<Path>> futures = new ArrayList<>(response.getBlocks().size());\n+        for (Block block : response.getBlocks()) {\n+            switch (block.getUri().getScheme()) {\n+                case \"http\":\n+                case \"https\":\n+                    HttpGet get = new HttpGet(block.getUri());\n+                    block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                    futures.add(this.executorService.submit(() -> {\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        byte[] bytes = IOUtils.toByteArray(entity.getContent());\n+                        EntityUtils.consume(entity);\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                IOUtils.copy(new ByteArrayInputStream(bytes), ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                case \"data\":\n+                    String dataUri = block.getUri().toString();\n+                    if (!dataUri.matches(\"^data:.*;base64,.*\")) {\n+                        throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                    }\n+                    futures.add(this.executorService.submit(() -> {\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                InputStream istream = new ByteArrayInputStream(\n+                                    Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                                IOUtils.copy(istream, ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                default:\n+                    throw new UserException(\n+                            \"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+            }\n+        }\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Future<Path> f : futures) {\n+                try (InputStream istream = Files.newInputStream(f.get())) {\n+                    try {\n+                        IOUtils.copy(istream, ostream);\n+                    } catch (IOException e) {\n+                        throw new UserException(\"Error copying block: \" + e.getMessage());", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3MTc0OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432671749", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:46:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2MzMxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2MzMyOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429663329", "bodyText": "Same here", "author": "lbergelson", "createdAt": "2020-05-24T18:36:35Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Block block : response.getBlocks()) {\n+                InputStream istream;\n+                switch (block.getUri().getScheme()) {\n+                    case \"http\":\n+                    case \"https\":\n+                        HttpGet get = new HttpGet(block.getUri());\n+                        block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        istream = entity.getContent();\n+                        break;\n+                    case \"data\":\n+                        String dataUri = block.getUri().toString();\n+                        if (! dataUri.matches(\"^data:.*;base64,.*\")) {\n+                            throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                        }\n+                        istream = new ByteArrayInputStream(\n+                            Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                        break;\n+                    default:\n+                        throw new UserException(\"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+                }\n+                IOUtils.copy(istream, ostream);\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Downloads data blocks provided by response to outputFile in parallel,\n+     * using the number of threads specified by user\n+     */\n+    private void getDataParallel(HtsgetResponse response) throws IOException {\n+        List<Future<Path>> futures = new ArrayList<>(response.getBlocks().size());\n+        for (Block block : response.getBlocks()) {\n+            switch (block.getUri().getScheme()) {\n+                case \"http\":\n+                case \"https\":\n+                    HttpGet get = new HttpGet(block.getUri());\n+                    block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                    futures.add(this.executorService.submit(() -> {\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        byte[] bytes = IOUtils.toByteArray(entity.getContent());\n+                        EntityUtils.consume(entity);\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                IOUtils.copy(new ByteArrayInputStream(bytes), ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                case \"data\":\n+                    String dataUri = block.getUri().toString();\n+                    if (!dataUri.matches(\"^data:.*;base64,.*\")) {\n+                        throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                    }\n+                    futures.add(this.executorService.submit(() -> {\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                InputStream istream = new ByteArrayInputStream(\n+                                    Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                                IOUtils.copy(istream, ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                default:\n+                    throw new UserException(\n+                            \"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+            }\n+        }\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Future<Path> f : futures) {\n+                try (InputStream istream = Files.newInputStream(f.get())) {\n+                    try {\n+                        IOUtils.copy(istream, ostream);\n+                    } catch (IOException e) {\n+                        throw new UserException(\"Error copying block: \" + e.getMessage());\n+                    }\n+                } catch (ExecutionException | InterruptedException e) {\n+                    throw new UserException(\"Error while waiting to download block: \" + e.getMessage());", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3MTc4NA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432671784", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:46:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2MzMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2MzMzNg==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429663336", "bodyText": "and here", "author": "lbergelson", "createdAt": "2020-05-24T18:36:41Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Block block : response.getBlocks()) {\n+                InputStream istream;\n+                switch (block.getUri().getScheme()) {\n+                    case \"http\":\n+                    case \"https\":\n+                        HttpGet get = new HttpGet(block.getUri());\n+                        block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        istream = entity.getContent();\n+                        break;\n+                    case \"data\":\n+                        String dataUri = block.getUri().toString();\n+                        if (! dataUri.matches(\"^data:.*;base64,.*\")) {\n+                            throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                        }\n+                        istream = new ByteArrayInputStream(\n+                            Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                        break;\n+                    default:\n+                        throw new UserException(\"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+                }\n+                IOUtils.copy(istream, ostream);\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Downloads data blocks provided by response to outputFile in parallel,\n+     * using the number of threads specified by user\n+     */\n+    private void getDataParallel(HtsgetResponse response) throws IOException {\n+        List<Future<Path>> futures = new ArrayList<>(response.getBlocks().size());\n+        for (Block block : response.getBlocks()) {\n+            switch (block.getUri().getScheme()) {\n+                case \"http\":\n+                case \"https\":\n+                    HttpGet get = new HttpGet(block.getUri());\n+                    block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                    futures.add(this.executorService.submit(() -> {\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        byte[] bytes = IOUtils.toByteArray(entity.getContent());\n+                        EntityUtils.consume(entity);\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                IOUtils.copy(new ByteArrayInputStream(bytes), ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                case \"data\":\n+                    String dataUri = block.getUri().toString();\n+                    if (!dataUri.matches(\"^data:.*;base64,.*\")) {\n+                        throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                    }\n+                    futures.add(this.executorService.submit(() -> {\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                InputStream istream = new ByteArrayInputStream(\n+                                    Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                                IOUtils.copy(istream, ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                default:\n+                    throw new UserException(\n+                            \"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+            }\n+        }\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Future<Path> f : futures) {\n+                try (InputStream istream = Files.newInputStream(f.get())) {\n+                    try {\n+                        IOUtils.copy(istream, ostream);\n+                    } catch (IOException e) {\n+                        throw new UserException(\"Error copying block: \" + e.getMessage());\n+                    }\n+                } catch (ExecutionException | InterruptedException e) {\n+                    throw new UserException(\"Error while waiting to download block: \" + e.getMessage());\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + this.outputFile);", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3MTgxOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432671819", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:46:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2MzMzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2MzQxOA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429663418", "bodyText": "compare with .equals", "author": "lbergelson", "createdAt": "2020-05-24T18:37:35Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Block block : response.getBlocks()) {\n+                InputStream istream;\n+                switch (block.getUri().getScheme()) {\n+                    case \"http\":\n+                    case \"https\":\n+                        HttpGet get = new HttpGet(block.getUri());\n+                        block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        istream = entity.getContent();\n+                        break;\n+                    case \"data\":\n+                        String dataUri = block.getUri().toString();\n+                        if (! dataUri.matches(\"^data:.*;base64,.*\")) {\n+                            throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                        }\n+                        istream = new ByteArrayInputStream(\n+                            Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                        break;\n+                    default:\n+                        throw new UserException(\"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+                }\n+                IOUtils.copy(istream, ostream);\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Downloads data blocks provided by response to outputFile in parallel,\n+     * using the number of threads specified by user\n+     */\n+    private void getDataParallel(HtsgetResponse response) throws IOException {\n+        List<Future<Path>> futures = new ArrayList<>(response.getBlocks().size());\n+        for (Block block : response.getBlocks()) {\n+            switch (block.getUri().getScheme()) {\n+                case \"http\":\n+                case \"https\":\n+                    HttpGet get = new HttpGet(block.getUri());\n+                    block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                    futures.add(this.executorService.submit(() -> {\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        byte[] bytes = IOUtils.toByteArray(entity.getContent());\n+                        EntityUtils.consume(entity);\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                IOUtils.copy(new ByteArrayInputStream(bytes), ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                case \"data\":\n+                    String dataUri = block.getUri().toString();\n+                    if (!dataUri.matches(\"^data:.*;base64,.*\")) {\n+                        throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                    }\n+                    futures.add(this.executorService.submit(() -> {\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                InputStream istream = new ByteArrayInputStream(\n+                                    Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                                IOUtils.copy(istream, ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                default:\n+                    throw new UserException(\n+                            \"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+            }\n+        }\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Future<Path> f : futures) {\n+                try (InputStream istream = Files.newInputStream(f.get())) {\n+                    try {\n+                        IOUtils.copy(istream, ostream);\n+                    } catch (IOException e) {\n+                        throw new UserException(\"Error copying block: \" + e.getMessage());\n+                    }\n+                } catch (ExecutionException | InterruptedException e) {\n+                    throw new UserException(\"Error while waiting to download block: \" + e.getMessage());\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + this.outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Checks md5 digest provided in response, if one exists, against calculated md5 hash\n+     * of downloaded file, warning user if they differ\n+     */\n+    private void checkMd5(HtsgetResponse resp) {\n+        String expectedMd5 = resp.getMd5();\n+        if (expectedMd5 == null) {\n+            logger.info(\"No md5 digest provided by response\");\n+        } else {\n+            try {\n+                String actualMd5 = Utils.calculateFileMD5(outputFile);\n+                if (actualMd5 != expectedMd5) {", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3MTk0Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432671943", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:46:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2MzQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2MzQ2NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429663465", "bodyText": "Throw an exception here instead of warning.", "author": "lbergelson", "createdAt": "2020-05-24T18:38:13Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Block block : response.getBlocks()) {\n+                InputStream istream;\n+                switch (block.getUri().getScheme()) {\n+                    case \"http\":\n+                    case \"https\":\n+                        HttpGet get = new HttpGet(block.getUri());\n+                        block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        istream = entity.getContent();\n+                        break;\n+                    case \"data\":\n+                        String dataUri = block.getUri().toString();\n+                        if (! dataUri.matches(\"^data:.*;base64,.*\")) {\n+                            throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                        }\n+                        istream = new ByteArrayInputStream(\n+                            Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                        break;\n+                    default:\n+                        throw new UserException(\"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+                }\n+                IOUtils.copy(istream, ostream);\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Downloads data blocks provided by response to outputFile in parallel,\n+     * using the number of threads specified by user\n+     */\n+    private void getDataParallel(HtsgetResponse response) throws IOException {\n+        List<Future<Path>> futures = new ArrayList<>(response.getBlocks().size());\n+        for (Block block : response.getBlocks()) {\n+            switch (block.getUri().getScheme()) {\n+                case \"http\":\n+                case \"https\":\n+                    HttpGet get = new HttpGet(block.getUri());\n+                    block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                    futures.add(this.executorService.submit(() -> {\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        byte[] bytes = IOUtils.toByteArray(entity.getContent());\n+                        EntityUtils.consume(entity);\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                IOUtils.copy(new ByteArrayInputStream(bytes), ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                case \"data\":\n+                    String dataUri = block.getUri().toString();\n+                    if (!dataUri.matches(\"^data:.*;base64,.*\")) {\n+                        throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                    }\n+                    futures.add(this.executorService.submit(() -> {\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                InputStream istream = new ByteArrayInputStream(\n+                                    Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                                IOUtils.copy(istream, ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                default:\n+                    throw new UserException(\n+                            \"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+            }\n+        }\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Future<Path> f : futures) {\n+                try (InputStream istream = Files.newInputStream(f.get())) {\n+                    try {\n+                        IOUtils.copy(istream, ostream);\n+                    } catch (IOException e) {\n+                        throw new UserException(\"Error copying block: \" + e.getMessage());\n+                    }\n+                } catch (ExecutionException | InterruptedException e) {\n+                    throw new UserException(\"Error while waiting to download block: \" + e.getMessage());\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + this.outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Checks md5 digest provided in response, if one exists, against calculated md5 hash\n+     * of downloaded file, warning user if they differ\n+     */\n+    private void checkMd5(HtsgetResponse resp) {\n+        String expectedMd5 = resp.getMd5();\n+        if (expectedMd5 == null) {\n+            logger.info(\"No md5 digest provided by response\");\n+        } else {\n+            try {\n+                String actualMd5 = Utils.calculateFileMD5(outputFile);\n+                if (actualMd5 != expectedMd5) {\n+                    logger.warn(\"Expected md5: \" + expectedMd5 + \" did not match actual md5: \" + actualMd5);", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3MjA2Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432672062", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:46:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2MzQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2MzUyNA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429663524", "bodyText": "This is unnecessary I think.  Program completion means that it matched.", "author": "lbergelson", "createdAt": "2020-05-24T18:38:49Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Block block : response.getBlocks()) {\n+                InputStream istream;\n+                switch (block.getUri().getScheme()) {\n+                    case \"http\":\n+                    case \"https\":\n+                        HttpGet get = new HttpGet(block.getUri());\n+                        block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        istream = entity.getContent();\n+                        break;\n+                    case \"data\":\n+                        String dataUri = block.getUri().toString();\n+                        if (! dataUri.matches(\"^data:.*;base64,.*\")) {\n+                            throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                        }\n+                        istream = new ByteArrayInputStream(\n+                            Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                        break;\n+                    default:\n+                        throw new UserException(\"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+                }\n+                IOUtils.copy(istream, ostream);\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Downloads data blocks provided by response to outputFile in parallel,\n+     * using the number of threads specified by user\n+     */\n+    private void getDataParallel(HtsgetResponse response) throws IOException {\n+        List<Future<Path>> futures = new ArrayList<>(response.getBlocks().size());\n+        for (Block block : response.getBlocks()) {\n+            switch (block.getUri().getScheme()) {\n+                case \"http\":\n+                case \"https\":\n+                    HttpGet get = new HttpGet(block.getUri());\n+                    block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                    futures.add(this.executorService.submit(() -> {\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        byte[] bytes = IOUtils.toByteArray(entity.getContent());\n+                        EntityUtils.consume(entity);\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                IOUtils.copy(new ByteArrayInputStream(bytes), ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                case \"data\":\n+                    String dataUri = block.getUri().toString();\n+                    if (!dataUri.matches(\"^data:.*;base64,.*\")) {\n+                        throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                    }\n+                    futures.add(this.executorService.submit(() -> {\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                InputStream istream = new ByteArrayInputStream(\n+                                    Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                                IOUtils.copy(istream, ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                default:\n+                    throw new UserException(\n+                            \"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+            }\n+        }\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Future<Path> f : futures) {\n+                try (InputStream istream = Files.newInputStream(f.get())) {\n+                    try {\n+                        IOUtils.copy(istream, ostream);\n+                    } catch (IOException e) {\n+                        throw new UserException(\"Error copying block: \" + e.getMessage());\n+                    }\n+                } catch (ExecutionException | InterruptedException e) {\n+                    throw new UserException(\"Error while waiting to download block: \" + e.getMessage());\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + this.outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Checks md5 digest provided in response, if one exists, against calculated md5 hash\n+     * of downloaded file, warning user if they differ\n+     */\n+    private void checkMd5(HtsgetResponse resp) {\n+        String expectedMd5 = resp.getMd5();\n+        if (expectedMd5 == null) {\n+            logger.info(\"No md5 digest provided by response\");\n+        } else {\n+            try {\n+                String actualMd5 = Utils.calculateFileMD5(outputFile);\n+                if (actualMd5 != expectedMd5) {\n+                    logger.warn(\"Expected md5: \" + expectedMd5 + \" did not match actual md5: \" + actualMd5);\n+                } else {\n+                    logger.info(\"Expected and actual md5 match\");", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3MjExOA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432672118", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:47:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2MzUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2MzU4Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429663583", "bodyText": "This should definitely be a warning at least, I might consider making this an exception, but you'd want to check it at the start of the run rather than after downloading everything.", "author": "lbergelson", "createdAt": "2020-05-24T18:39:46Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Block block : response.getBlocks()) {\n+                InputStream istream;\n+                switch (block.getUri().getScheme()) {\n+                    case \"http\":\n+                    case \"https\":\n+                        HttpGet get = new HttpGet(block.getUri());\n+                        block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        istream = entity.getContent();\n+                        break;\n+                    case \"data\":\n+                        String dataUri = block.getUri().toString();\n+                        if (! dataUri.matches(\"^data:.*;base64,.*\")) {\n+                            throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                        }\n+                        istream = new ByteArrayInputStream(\n+                            Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                        break;\n+                    default:\n+                        throw new UserException(\"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+                }\n+                IOUtils.copy(istream, ostream);\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Downloads data blocks provided by response to outputFile in parallel,\n+     * using the number of threads specified by user\n+     */\n+    private void getDataParallel(HtsgetResponse response) throws IOException {\n+        List<Future<Path>> futures = new ArrayList<>(response.getBlocks().size());\n+        for (Block block : response.getBlocks()) {\n+            switch (block.getUri().getScheme()) {\n+                case \"http\":\n+                case \"https\":\n+                    HttpGet get = new HttpGet(block.getUri());\n+                    block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                    futures.add(this.executorService.submit(() -> {\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        byte[] bytes = IOUtils.toByteArray(entity.getContent());\n+                        EntityUtils.consume(entity);\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                IOUtils.copy(new ByteArrayInputStream(bytes), ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                case \"data\":\n+                    String dataUri = block.getUri().toString();\n+                    if (!dataUri.matches(\"^data:.*;base64,.*\")) {\n+                        throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                    }\n+                    futures.add(this.executorService.submit(() -> {\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                InputStream istream = new ByteArrayInputStream(\n+                                    Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                                IOUtils.copy(istream, ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                default:\n+                    throw new UserException(\n+                            \"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+            }\n+        }\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Future<Path> f : futures) {\n+                try (InputStream istream = Files.newInputStream(f.get())) {\n+                    try {\n+                        IOUtils.copy(istream, ostream);\n+                    } catch (IOException e) {\n+                        throw new UserException(\"Error copying block: \" + e.getMessage());\n+                    }\n+                } catch (ExecutionException | InterruptedException e) {\n+                    throw new UserException(\"Error while waiting to download block: \" + e.getMessage());\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + this.outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Checks md5 digest provided in response, if one exists, against calculated md5 hash\n+     * of downloaded file, warning user if they differ\n+     */\n+    private void checkMd5(HtsgetResponse resp) {\n+        String expectedMd5 = resp.getMd5();\n+        if (expectedMd5 == null) {\n+            logger.info(\"No md5 digest provided by response\");", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2MzY1MA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429663650", "bodyText": "attach the exception", "author": "lbergelson", "createdAt": "2020-05-24T18:40:27Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Block block : response.getBlocks()) {\n+                InputStream istream;\n+                switch (block.getUri().getScheme()) {\n+                    case \"http\":\n+                    case \"https\":\n+                        HttpGet get = new HttpGet(block.getUri());\n+                        block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        istream = entity.getContent();\n+                        break;\n+                    case \"data\":\n+                        String dataUri = block.getUri().toString();\n+                        if (! dataUri.matches(\"^data:.*;base64,.*\")) {\n+                            throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                        }\n+                        istream = new ByteArrayInputStream(\n+                            Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                        break;\n+                    default:\n+                        throw new UserException(\"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+                }\n+                IOUtils.copy(istream, ostream);\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Downloads data blocks provided by response to outputFile in parallel,\n+     * using the number of threads specified by user\n+     */\n+    private void getDataParallel(HtsgetResponse response) throws IOException {\n+        List<Future<Path>> futures = new ArrayList<>(response.getBlocks().size());\n+        for (Block block : response.getBlocks()) {\n+            switch (block.getUri().getScheme()) {\n+                case \"http\":\n+                case \"https\":\n+                    HttpGet get = new HttpGet(block.getUri());\n+                    block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                    futures.add(this.executorService.submit(() -> {\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        byte[] bytes = IOUtils.toByteArray(entity.getContent());\n+                        EntityUtils.consume(entity);\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                IOUtils.copy(new ByteArrayInputStream(bytes), ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                case \"data\":\n+                    String dataUri = block.getUri().toString();\n+                    if (!dataUri.matches(\"^data:.*;base64,.*\")) {\n+                        throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                    }\n+                    futures.add(this.executorService.submit(() -> {\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                InputStream istream = new ByteArrayInputStream(\n+                                    Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                                IOUtils.copy(istream, ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                default:\n+                    throw new UserException(\n+                            \"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+            }\n+        }\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Future<Path> f : futures) {\n+                try (InputStream istream = Files.newInputStream(f.get())) {\n+                    try {\n+                        IOUtils.copy(istream, ostream);\n+                    } catch (IOException e) {\n+                        throw new UserException(\"Error copying block: \" + e.getMessage());\n+                    }\n+                } catch (ExecutionException | InterruptedException e) {\n+                    throw new UserException(\"Error while waiting to download block: \" + e.getMessage());\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + this.outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Checks md5 digest provided in response, if one exists, against calculated md5 hash\n+     * of downloaded file, warning user if they differ\n+     */\n+    private void checkMd5(HtsgetResponse resp) {\n+        String expectedMd5 = resp.getMd5();\n+        if (expectedMd5 == null) {\n+            logger.info(\"No md5 digest provided by response\");\n+        } else {\n+            try {\n+                String actualMd5 = Utils.calculateFileMD5(outputFile);\n+                if (actualMd5 != expectedMd5) {\n+                    logger.warn(\"Expected md5: \" + expectedMd5 + \" did not match actual md5: \" + actualMd5);\n+                } else {\n+                    logger.info(\"Expected and actual md5 match\");\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"Unable to calculate md5 digest\");", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3MzE5OA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432673198", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:49:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2MzY1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk4MzIzOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r433983239", "bodyText": "I think you forgot to commit this change.", "author": "lbergelson", "createdAt": "2020-06-02T15:50:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2MzY1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2Mzg1Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429663852", "bodyText": "It should probably run the validation when you call toUri.  I would consider renaming HtsgetRequest -> HtsgetRequestBuilder since it doesn't seem like the request is ever used except to build the URI, and it would clarify things if that's the expected use pattern.", "author": "lbergelson", "createdAt": "2020-05-24T18:42:42Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Block block : response.getBlocks()) {\n+                InputStream istream;\n+                switch (block.getUri().getScheme()) {\n+                    case \"http\":\n+                    case \"https\":\n+                        HttpGet get = new HttpGet(block.getUri());\n+                        block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        istream = entity.getContent();\n+                        break;\n+                    case \"data\":\n+                        String dataUri = block.getUri().toString();\n+                        if (! dataUri.matches(\"^data:.*;base64,.*\")) {\n+                            throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                        }\n+                        istream = new ByteArrayInputStream(\n+                            Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                        break;\n+                    default:\n+                        throw new UserException(\"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+                }\n+                IOUtils.copy(istream, ostream);\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Downloads data blocks provided by response to outputFile in parallel,\n+     * using the number of threads specified by user\n+     */\n+    private void getDataParallel(HtsgetResponse response) throws IOException {\n+        List<Future<Path>> futures = new ArrayList<>(response.getBlocks().size());\n+        for (Block block : response.getBlocks()) {\n+            switch (block.getUri().getScheme()) {\n+                case \"http\":\n+                case \"https\":\n+                    HttpGet get = new HttpGet(block.getUri());\n+                    block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                    futures.add(this.executorService.submit(() -> {\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        byte[] bytes = IOUtils.toByteArray(entity.getContent());\n+                        EntityUtils.consume(entity);\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                IOUtils.copy(new ByteArrayInputStream(bytes), ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                case \"data\":\n+                    String dataUri = block.getUri().toString();\n+                    if (!dataUri.matches(\"^data:.*;base64,.*\")) {\n+                        throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                    }\n+                    futures.add(this.executorService.submit(() -> {\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                InputStream istream = new ByteArrayInputStream(\n+                                    Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                                IOUtils.copy(istream, ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                default:\n+                    throw new UserException(\n+                            \"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+            }\n+        }\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Future<Path> f : futures) {\n+                try (InputStream istream = Files.newInputStream(f.get())) {\n+                    try {\n+                        IOUtils.copy(istream, ostream);\n+                    } catch (IOException e) {\n+                        throw new UserException(\"Error copying block: \" + e.getMessage());\n+                    }\n+                } catch (ExecutionException | InterruptedException e) {\n+                    throw new UserException(\"Error while waiting to download block: \" + e.getMessage());\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + this.outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Checks md5 digest provided in response, if one exists, against calculated md5 hash\n+     * of downloaded file, warning user if they differ\n+     */\n+    private void checkMd5(HtsgetResponse resp) {\n+        String expectedMd5 = resp.getMd5();\n+        if (expectedMd5 == null) {\n+            logger.info(\"No md5 digest provided by response\");\n+        } else {\n+            try {\n+                String actualMd5 = Utils.calculateFileMD5(outputFile);\n+                if (actualMd5 != expectedMd5) {\n+                    logger.warn(\"Expected md5: \" + expectedMd5 + \" did not match actual md5: \" + actualMd5);\n+                } else {\n+                    logger.info(\"Expected and actual md5 match\");\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"Unable to calculate md5 digest\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void traverse() {\n+        // construct request from command line args and convert to URI\n+        HtsgetRequest req = new HtsgetRequest(endpoint, id)\n+            .withFormat(format)\n+            .withDataClass(dataClass)\n+            .withReferenceName(referenceName)\n+            .withStart(start)\n+            .withEnd(end)\n+            .withFields(fields)\n+            .withTags(tags)\n+            .withNotags(notags);\n+        this.validateRequest(req);\n+        URI reqURI = req.toURI();", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3MzMyMA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432673320", "bodyText": "Fixed and changed name of class.", "author": "andersleung", "createdAt": "2020-05-29T18:49:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2Mzg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2Mzk3MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429663971", "bodyText": "I think this could be simplified as block.getHeaders().forEach(get::addHeader)", "author": "lbergelson", "createdAt": "2020-05-24T18:44:15Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Block block : response.getBlocks()) {\n+                InputStream istream;\n+                switch (block.getUri().getScheme()) {\n+                    case \"http\":\n+                    case \"https\":\n+                        HttpGet get = new HttpGet(block.getUri());\n+                        block.getHeaders().forEach((header, value) -> get.addHeader(header, value));", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3MzM3Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432673376", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:49:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2Mzk3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NDAyMg==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429664022", "bodyText": "Does the result of this.client.execute(get) need to be closed?  if so it should be wrapped in a try-with-resources block.", "author": "lbergelson", "createdAt": "2020-05-24T18:44:54Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Block block : response.getBlocks()) {\n+                InputStream istream;\n+                switch (block.getUri().getScheme()) {\n+                    case \"http\":\n+                    case \"https\":\n+                        HttpGet get = new HttpGet(block.getUri());\n+                        block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                        HttpEntity entity = this.client.execute(get).getEntity();", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3MzQ3Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432673477", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T18:49:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NDAyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NDc4NA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429664784", "bodyText": "When is .consume necessary?  It's not called every time you use .getEntity().  I'm a bit unclear on the interaction between closing the response, calling getContent, and consume. It seems like mayb we should be throwing in places we thought we consumed the stream but it actually still has some value that consume is dealing with.", "author": "lbergelson", "createdAt": "2020-05-24T18:53:58Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Block block : response.getBlocks()) {\n+                InputStream istream;\n+                switch (block.getUri().getScheme()) {\n+                    case \"http\":\n+                    case \"https\":\n+                        HttpGet get = new HttpGet(block.getUri());\n+                        block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        istream = entity.getContent();\n+                        break;\n+                    case \"data\":\n+                        String dataUri = block.getUri().toString();\n+                        if (! dataUri.matches(\"^data:.*;base64,.*\")) {\n+                            throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                        }\n+                        istream = new ByteArrayInputStream(\n+                            Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                        break;\n+                    default:\n+                        throw new UserException(\"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+                }\n+                IOUtils.copy(istream, ostream);\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Downloads data blocks provided by response to outputFile in parallel,\n+     * using the number of threads specified by user\n+     */\n+    private void getDataParallel(HtsgetResponse response) throws IOException {\n+        List<Future<Path>> futures = new ArrayList<>(response.getBlocks().size());\n+        for (Block block : response.getBlocks()) {\n+            switch (block.getUri().getScheme()) {\n+                case \"http\":\n+                case \"https\":\n+                    HttpGet get = new HttpGet(block.getUri());\n+                    block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                    futures.add(this.executorService.submit(() -> {\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        byte[] bytes = IOUtils.toByteArray(entity.getContent());\n+                        EntityUtils.consume(entity);\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                IOUtils.copy(new ByteArrayInputStream(bytes), ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                case \"data\":\n+                    String dataUri = block.getUri().toString();\n+                    if (!dataUri.matches(\"^data:.*;base64,.*\")) {\n+                        throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                    }\n+                    futures.add(this.executorService.submit(() -> {\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                InputStream istream = new ByteArrayInputStream(\n+                                    Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                                IOUtils.copy(istream, ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                default:\n+                    throw new UserException(\n+                            \"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+            }\n+        }\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Future<Path> f : futures) {\n+                try (InputStream istream = Files.newInputStream(f.get())) {\n+                    try {\n+                        IOUtils.copy(istream, ostream);\n+                    } catch (IOException e) {\n+                        throw new UserException(\"Error copying block: \" + e.getMessage());\n+                    }\n+                } catch (ExecutionException | InterruptedException e) {\n+                    throw new UserException(\"Error while waiting to download block: \" + e.getMessage());\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + this.outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Checks md5 digest provided in response, if one exists, against calculated md5 hash\n+     * of downloaded file, warning user if they differ\n+     */\n+    private void checkMd5(HtsgetResponse resp) {\n+        String expectedMd5 = resp.getMd5();\n+        if (expectedMd5 == null) {\n+            logger.info(\"No md5 digest provided by response\");\n+        } else {\n+            try {\n+                String actualMd5 = Utils.calculateFileMD5(outputFile);\n+                if (actualMd5 != expectedMd5) {\n+                    logger.warn(\"Expected md5: \" + expectedMd5 + \" did not match actual md5: \" + actualMd5);\n+                } else {\n+                    logger.info(\"Expected and actual md5 match\");\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"Unable to calculate md5 digest\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void traverse() {\n+        // construct request from command line args and convert to URI\n+        HtsgetRequest req = new HtsgetRequest(endpoint, id)\n+            .withFormat(format)\n+            .withDataClass(dataClass)\n+            .withReferenceName(referenceName)\n+            .withStart(start)\n+            .withEnd(end)\n+            .withFields(fields)\n+            .withTags(tags)\n+            .withNotags(notags);\n+        this.validateRequest(req);\n+        URI reqURI = req.toURI();\n+\n+        HttpGet getReq = new HttpGet(reqURI);\n+        try (CloseableHttpResponse resp = this.client.execute(getReq)) {\n+            // get content of response\n+            HttpEntity entity = resp.getEntity();\n+            Header encodingHeader = entity.getContentEncoding();\n+            Charset encoding = encodingHeader == null\n+                    ? StandardCharsets.UTF_8\n+                    : Charsets.toCharset(encodingHeader.getValue());\n+            String jsonBody = EntityUtils.toString(entity, encoding);\n+            EntityUtils.consume(entity);", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3NzgzOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432677839", "bodyText": "It was to make sure the InputStream is fully consumed and closed, but this should be taken care of by the EntityUtils.toString. The other times where consume was used were changed to use try-with-resources blocks to ensure the InputStream is closed.", "author": "andersleung", "createdAt": "2020-05-29T18:59:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NDc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NDg5NA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429664894", "bodyText": "I'd extract a method getObjectMapper that configures and returns this thing to simplify this method.", "author": "lbergelson", "createdAt": "2020-05-24T18:55:31Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Block block : response.getBlocks()) {\n+                InputStream istream;\n+                switch (block.getUri().getScheme()) {\n+                    case \"http\":\n+                    case \"https\":\n+                        HttpGet get = new HttpGet(block.getUri());\n+                        block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        istream = entity.getContent();\n+                        break;\n+                    case \"data\":\n+                        String dataUri = block.getUri().toString();\n+                        if (! dataUri.matches(\"^data:.*;base64,.*\")) {\n+                            throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                        }\n+                        istream = new ByteArrayInputStream(\n+                            Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                        break;\n+                    default:\n+                        throw new UserException(\"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+                }\n+                IOUtils.copy(istream, ostream);\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Downloads data blocks provided by response to outputFile in parallel,\n+     * using the number of threads specified by user\n+     */\n+    private void getDataParallel(HtsgetResponse response) throws IOException {\n+        List<Future<Path>> futures = new ArrayList<>(response.getBlocks().size());\n+        for (Block block : response.getBlocks()) {\n+            switch (block.getUri().getScheme()) {\n+                case \"http\":\n+                case \"https\":\n+                    HttpGet get = new HttpGet(block.getUri());\n+                    block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                    futures.add(this.executorService.submit(() -> {\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        byte[] bytes = IOUtils.toByteArray(entity.getContent());\n+                        EntityUtils.consume(entity);\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                IOUtils.copy(new ByteArrayInputStream(bytes), ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                case \"data\":\n+                    String dataUri = block.getUri().toString();\n+                    if (!dataUri.matches(\"^data:.*;base64,.*\")) {\n+                        throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                    }\n+                    futures.add(this.executorService.submit(() -> {\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                InputStream istream = new ByteArrayInputStream(\n+                                    Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                                IOUtils.copy(istream, ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                default:\n+                    throw new UserException(\n+                            \"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+            }\n+        }\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Future<Path> f : futures) {\n+                try (InputStream istream = Files.newInputStream(f.get())) {\n+                    try {\n+                        IOUtils.copy(istream, ostream);\n+                    } catch (IOException e) {\n+                        throw new UserException(\"Error copying block: \" + e.getMessage());\n+                    }\n+                } catch (ExecutionException | InterruptedException e) {\n+                    throw new UserException(\"Error while waiting to download block: \" + e.getMessage());\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + this.outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Checks md5 digest provided in response, if one exists, against calculated md5 hash\n+     * of downloaded file, warning user if they differ\n+     */\n+    private void checkMd5(HtsgetResponse resp) {\n+        String expectedMd5 = resp.getMd5();\n+        if (expectedMd5 == null) {\n+            logger.info(\"No md5 digest provided by response\");\n+        } else {\n+            try {\n+                String actualMd5 = Utils.calculateFileMD5(outputFile);\n+                if (actualMd5 != expectedMd5) {\n+                    logger.warn(\"Expected md5: \" + expectedMd5 + \" did not match actual md5: \" + actualMd5);\n+                } else {\n+                    logger.info(\"Expected and actual md5 match\");\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"Unable to calculate md5 digest\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void traverse() {\n+        // construct request from command line args and convert to URI\n+        HtsgetRequest req = new HtsgetRequest(endpoint, id)\n+            .withFormat(format)\n+            .withDataClass(dataClass)\n+            .withReferenceName(referenceName)\n+            .withStart(start)\n+            .withEnd(end)\n+            .withFields(fields)\n+            .withTags(tags)\n+            .withNotags(notags);\n+        this.validateRequest(req);\n+        URI reqURI = req.toURI();\n+\n+        HttpGet getReq = new HttpGet(reqURI);\n+        try (CloseableHttpResponse resp = this.client.execute(getReq)) {\n+            // get content of response\n+            HttpEntity entity = resp.getEntity();\n+            Header encodingHeader = entity.getContentEncoding();\n+            Charset encoding = encodingHeader == null\n+                    ? StandardCharsets.UTF_8\n+                    : Charsets.toCharset(encodingHeader.getValue());\n+            String jsonBody = EntityUtils.toString(entity, encoding);\n+            EntityUtils.consume(entity);\n+\n+            ObjectMapper mapper = new ObjectMapper();", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3ODIzOA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432678238", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T19:00:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NDg5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NDk3OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429664979", "bodyText": "is it possible for either of these to be null?", "author": "lbergelson", "createdAt": "2020-05-24T18:56:44Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Block block : response.getBlocks()) {\n+                InputStream istream;\n+                switch (block.getUri().getScheme()) {\n+                    case \"http\":\n+                    case \"https\":\n+                        HttpGet get = new HttpGet(block.getUri());\n+                        block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        istream = entity.getContent();\n+                        break;\n+                    case \"data\":\n+                        String dataUri = block.getUri().toString();\n+                        if (! dataUri.matches(\"^data:.*;base64,.*\")) {\n+                            throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                        }\n+                        istream = new ByteArrayInputStream(\n+                            Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                        break;\n+                    default:\n+                        throw new UserException(\"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+                }\n+                IOUtils.copy(istream, ostream);\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Downloads data blocks provided by response to outputFile in parallel,\n+     * using the number of threads specified by user\n+     */\n+    private void getDataParallel(HtsgetResponse response) throws IOException {\n+        List<Future<Path>> futures = new ArrayList<>(response.getBlocks().size());\n+        for (Block block : response.getBlocks()) {\n+            switch (block.getUri().getScheme()) {\n+                case \"http\":\n+                case \"https\":\n+                    HttpGet get = new HttpGet(block.getUri());\n+                    block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                    futures.add(this.executorService.submit(() -> {\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        byte[] bytes = IOUtils.toByteArray(entity.getContent());\n+                        EntityUtils.consume(entity);\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                IOUtils.copy(new ByteArrayInputStream(bytes), ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                case \"data\":\n+                    String dataUri = block.getUri().toString();\n+                    if (!dataUri.matches(\"^data:.*;base64,.*\")) {\n+                        throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                    }\n+                    futures.add(this.executorService.submit(() -> {\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                InputStream istream = new ByteArrayInputStream(\n+                                    Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                                IOUtils.copy(istream, ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                default:\n+                    throw new UserException(\n+                            \"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+            }\n+        }\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Future<Path> f : futures) {\n+                try (InputStream istream = Files.newInputStream(f.get())) {\n+                    try {\n+                        IOUtils.copy(istream, ostream);\n+                    } catch (IOException e) {\n+                        throw new UserException(\"Error copying block: \" + e.getMessage());\n+                    }\n+                } catch (ExecutionException | InterruptedException e) {\n+                    throw new UserException(\"Error while waiting to download block: \" + e.getMessage());\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + this.outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Checks md5 digest provided in response, if one exists, against calculated md5 hash\n+     * of downloaded file, warning user if they differ\n+     */\n+    private void checkMd5(HtsgetResponse resp) {\n+        String expectedMd5 = resp.getMd5();\n+        if (expectedMd5 == null) {\n+            logger.info(\"No md5 digest provided by response\");\n+        } else {\n+            try {\n+                String actualMd5 = Utils.calculateFileMD5(outputFile);\n+                if (actualMd5 != expectedMd5) {\n+                    logger.warn(\"Expected md5: \" + expectedMd5 + \" did not match actual md5: \" + actualMd5);\n+                } else {\n+                    logger.info(\"Expected and actual md5 match\");\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"Unable to calculate md5 digest\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void traverse() {\n+        // construct request from command line args and convert to URI\n+        HtsgetRequest req = new HtsgetRequest(endpoint, id)\n+            .withFormat(format)\n+            .withDataClass(dataClass)\n+            .withReferenceName(referenceName)\n+            .withStart(start)\n+            .withEnd(end)\n+            .withFields(fields)\n+            .withTags(tags)\n+            .withNotags(notags);\n+        this.validateRequest(req);\n+        URI reqURI = req.toURI();\n+\n+        HttpGet getReq = new HttpGet(reqURI);\n+        try (CloseableHttpResponse resp = this.client.execute(getReq)) {\n+            // get content of response\n+            HttpEntity entity = resp.getEntity();\n+            Header encodingHeader = entity.getContentEncoding();\n+            Charset encoding = encodingHeader == null\n+                    ? StandardCharsets.UTF_8\n+                    : Charsets.toCharset(encodingHeader.getValue());\n+            String jsonBody = EntityUtils.toString(entity, encoding);\n+            EntityUtils.consume(entity);\n+\n+            ObjectMapper mapper = new ObjectMapper();\n+            mapper.enable(DeserializationFeature.UNWRAP_ROOT_VALUE);\n+            mapper.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+\n+            int statusCode = resp.getStatusLine().getStatusCode();", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3ODgyOA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432678828", "bodyText": "Added null check for status line.", "author": "andersleung", "createdAt": "2020-05-29T19:01:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NDk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NTAzOA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429665038", "bodyText": "What if status code doesn't fall into either of these cases?", "author": "lbergelson", "createdAt": "2020-05-24T18:57:32Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Block block : response.getBlocks()) {\n+                InputStream istream;\n+                switch (block.getUri().getScheme()) {\n+                    case \"http\":\n+                    case \"https\":\n+                        HttpGet get = new HttpGet(block.getUri());\n+                        block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        istream = entity.getContent();\n+                        break;\n+                    case \"data\":\n+                        String dataUri = block.getUri().toString();\n+                        if (! dataUri.matches(\"^data:.*;base64,.*\")) {\n+                            throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                        }\n+                        istream = new ByteArrayInputStream(\n+                            Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                        break;\n+                    default:\n+                        throw new UserException(\"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+                }\n+                IOUtils.copy(istream, ostream);\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Downloads data blocks provided by response to outputFile in parallel,\n+     * using the number of threads specified by user\n+     */\n+    private void getDataParallel(HtsgetResponse response) throws IOException {\n+        List<Future<Path>> futures = new ArrayList<>(response.getBlocks().size());\n+        for (Block block : response.getBlocks()) {\n+            switch (block.getUri().getScheme()) {\n+                case \"http\":\n+                case \"https\":\n+                    HttpGet get = new HttpGet(block.getUri());\n+                    block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                    futures.add(this.executorService.submit(() -> {\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        byte[] bytes = IOUtils.toByteArray(entity.getContent());\n+                        EntityUtils.consume(entity);\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                IOUtils.copy(new ByteArrayInputStream(bytes), ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                case \"data\":\n+                    String dataUri = block.getUri().toString();\n+                    if (!dataUri.matches(\"^data:.*;base64,.*\")) {\n+                        throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                    }\n+                    futures.add(this.executorService.submit(() -> {\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                InputStream istream = new ByteArrayInputStream(\n+                                    Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                                IOUtils.copy(istream, ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                default:\n+                    throw new UserException(\n+                            \"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+            }\n+        }\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Future<Path> f : futures) {\n+                try (InputStream istream = Files.newInputStream(f.get())) {\n+                    try {\n+                        IOUtils.copy(istream, ostream);\n+                    } catch (IOException e) {\n+                        throw new UserException(\"Error copying block: \" + e.getMessage());\n+                    }\n+                } catch (ExecutionException | InterruptedException e) {\n+                    throw new UserException(\"Error while waiting to download block: \" + e.getMessage());\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + this.outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Checks md5 digest provided in response, if one exists, against calculated md5 hash\n+     * of downloaded file, warning user if they differ\n+     */\n+    private void checkMd5(HtsgetResponse resp) {\n+        String expectedMd5 = resp.getMd5();\n+        if (expectedMd5 == null) {\n+            logger.info(\"No md5 digest provided by response\");\n+        } else {\n+            try {\n+                String actualMd5 = Utils.calculateFileMD5(outputFile);\n+                if (actualMd5 != expectedMd5) {\n+                    logger.warn(\"Expected md5: \" + expectedMd5 + \" did not match actual md5: \" + actualMd5);\n+                } else {\n+                    logger.info(\"Expected and actual md5 match\");\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"Unable to calculate md5 digest\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void traverse() {\n+        // construct request from command line args and convert to URI\n+        HtsgetRequest req = new HtsgetRequest(endpoint, id)\n+            .withFormat(format)\n+            .withDataClass(dataClass)\n+            .withReferenceName(referenceName)\n+            .withStart(start)\n+            .withEnd(end)\n+            .withFields(fields)\n+            .withTags(tags)\n+            .withNotags(notags);\n+        this.validateRequest(req);\n+        URI reqURI = req.toURI();\n+\n+        HttpGet getReq = new HttpGet(reqURI);\n+        try (CloseableHttpResponse resp = this.client.execute(getReq)) {\n+            // get content of response\n+            HttpEntity entity = resp.getEntity();\n+            Header encodingHeader = entity.getContentEncoding();\n+            Charset encoding = encodingHeader == null\n+                    ? StandardCharsets.UTF_8\n+                    : Charsets.toCharset(encodingHeader.getValue());\n+            String jsonBody = EntityUtils.toString(entity, encoding);\n+            EntityUtils.consume(entity);\n+\n+            ObjectMapper mapper = new ObjectMapper();\n+            mapper.enable(DeserializationFeature.UNWRAP_ROOT_VALUE);\n+            mapper.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+\n+            int statusCode = resp.getStatusLine().getStatusCode();\n+            if (400 <= statusCode && statusCode < 500) {\n+                    HtsgetErrorResponse err = mapper.readValue(jsonBody, HtsgetErrorResponse.class);\n+                    throw new UserException(\n+                        \"Invalid request, received error code: \" + statusCode\n+                        + \", error type: \" + err.error\n+                        + \", message: \" + err.message);\n+            } else if (statusCode == 200) {", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NjU1MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429666551", "bodyText": "Do redirects get handled transparently?", "author": "lbergelson", "createdAt": "2020-05-24T19:18:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NTAzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3OTk3Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432679973", "bodyText": "Redirects are handled by the httpClient. An error is now thrown if an unrecognized status code that isn't an error or success is received.", "author": "andersleung", "createdAt": "2020-05-29T19:03:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NTAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NTA4NA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429665084", "bodyText": "This should throw instead of logging and suppressing the exception.  In general if we have an error the prevents successful completion we MUST throw so the user knows that something went wrong.  People only notice log messages when something forces them too (like the program crashing)", "author": "lbergelson", "createdAt": "2020-05-24T18:57:57Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Block block : response.getBlocks()) {\n+                InputStream istream;\n+                switch (block.getUri().getScheme()) {\n+                    case \"http\":\n+                    case \"https\":\n+                        HttpGet get = new HttpGet(block.getUri());\n+                        block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        istream = entity.getContent();\n+                        break;\n+                    case \"data\":\n+                        String dataUri = block.getUri().toString();\n+                        if (! dataUri.matches(\"^data:.*;base64,.*\")) {\n+                            throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                        }\n+                        istream = new ByteArrayInputStream(\n+                            Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                        break;\n+                    default:\n+                        throw new UserException(\"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+                }\n+                IOUtils.copy(istream, ostream);\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Downloads data blocks provided by response to outputFile in parallel,\n+     * using the number of threads specified by user\n+     */\n+    private void getDataParallel(HtsgetResponse response) throws IOException {\n+        List<Future<Path>> futures = new ArrayList<>(response.getBlocks().size());\n+        for (Block block : response.getBlocks()) {\n+            switch (block.getUri().getScheme()) {\n+                case \"http\":\n+                case \"https\":\n+                    HttpGet get = new HttpGet(block.getUri());\n+                    block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                    futures.add(this.executorService.submit(() -> {\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        byte[] bytes = IOUtils.toByteArray(entity.getContent());\n+                        EntityUtils.consume(entity);\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                IOUtils.copy(new ByteArrayInputStream(bytes), ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                case \"data\":\n+                    String dataUri = block.getUri().toString();\n+                    if (!dataUri.matches(\"^data:.*;base64,.*\")) {\n+                        throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                    }\n+                    futures.add(this.executorService.submit(() -> {\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                InputStream istream = new ByteArrayInputStream(\n+                                    Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                                IOUtils.copy(istream, ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                default:\n+                    throw new UserException(\n+                            \"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+            }\n+        }\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Future<Path> f : futures) {\n+                try (InputStream istream = Files.newInputStream(f.get())) {\n+                    try {\n+                        IOUtils.copy(istream, ostream);\n+                    } catch (IOException e) {\n+                        throw new UserException(\"Error copying block: \" + e.getMessage());\n+                    }\n+                } catch (ExecutionException | InterruptedException e) {\n+                    throw new UserException(\"Error while waiting to download block: \" + e.getMessage());\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + this.outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Checks md5 digest provided in response, if one exists, against calculated md5 hash\n+     * of downloaded file, warning user if they differ\n+     */\n+    private void checkMd5(HtsgetResponse resp) {\n+        String expectedMd5 = resp.getMd5();\n+        if (expectedMd5 == null) {\n+            logger.info(\"No md5 digest provided by response\");\n+        } else {\n+            try {\n+                String actualMd5 = Utils.calculateFileMD5(outputFile);\n+                if (actualMd5 != expectedMd5) {\n+                    logger.warn(\"Expected md5: \" + expectedMd5 + \" did not match actual md5: \" + actualMd5);\n+                } else {\n+                    logger.info(\"Expected and actual md5 match\");\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"Unable to calculate md5 digest\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void traverse() {\n+        // construct request from command line args and convert to URI\n+        HtsgetRequest req = new HtsgetRequest(endpoint, id)\n+            .withFormat(format)\n+            .withDataClass(dataClass)\n+            .withReferenceName(referenceName)\n+            .withStart(start)\n+            .withEnd(end)\n+            .withFields(fields)\n+            .withTags(tags)\n+            .withNotags(notags);\n+        this.validateRequest(req);\n+        URI reqURI = req.toURI();\n+\n+        HttpGet getReq = new HttpGet(reqURI);\n+        try (CloseableHttpResponse resp = this.client.execute(getReq)) {\n+            // get content of response\n+            HttpEntity entity = resp.getEntity();\n+            Header encodingHeader = entity.getContentEncoding();\n+            Charset encoding = encodingHeader == null\n+                    ? StandardCharsets.UTF_8\n+                    : Charsets.toCharset(encodingHeader.getValue());\n+            String jsonBody = EntityUtils.toString(entity, encoding);\n+            EntityUtils.consume(entity);\n+\n+            ObjectMapper mapper = new ObjectMapper();\n+            mapper.enable(DeserializationFeature.UNWRAP_ROOT_VALUE);\n+            mapper.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+\n+            int statusCode = resp.getStatusLine().getStatusCode();\n+            if (400 <= statusCode && statusCode < 500) {\n+                    HtsgetErrorResponse err = mapper.readValue(jsonBody, HtsgetErrorResponse.class);\n+                    throw new UserException(\n+                        \"Invalid request, received error code: \" + statusCode\n+                        + \", error type: \" + err.error\n+                        + \", message: \" + err.message);\n+            } else if (statusCode == 200) {\n+                HtsgetResponse response = mapper.readValue(jsonBody, HtsgetResponse.class);\n+                \n+                if (this.readerThreads > 1) {\n+                    this.getDataParallel(response);\n+                } else {\n+                    this.getData(response);\n+                }\n+\n+                logger.info(\"Successfully wrote to: \" + outputFile);\n+\n+                if (checkMd5) {\n+                    this.checkMd5(response);\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.error(e.getMessage());", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MDA5Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432680097", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T19:04:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NTA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NTI0Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429665243", "bodyText": "This is an expensive operation, it would be good to compute this on the fly as we download.  That can be a future optimization though.  NioFileCopierWithProgressMeter has an example of computing checksums as a stream is downloaded.  It also has a progress meter for file downloads.   I think it might be tricky to integrate into this though (especially the parallel operations) so don't feel like have to do it right now.", "author": "lbergelson", "createdAt": "2020-05-24T19:00:27Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Block block : response.getBlocks()) {\n+                InputStream istream;\n+                switch (block.getUri().getScheme()) {\n+                    case \"http\":\n+                    case \"https\":\n+                        HttpGet get = new HttpGet(block.getUri());\n+                        block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        istream = entity.getContent();\n+                        break;\n+                    case \"data\":\n+                        String dataUri = block.getUri().toString();\n+                        if (! dataUri.matches(\"^data:.*;base64,.*\")) {\n+                            throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                        }\n+                        istream = new ByteArrayInputStream(\n+                            Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                        break;\n+                    default:\n+                        throw new UserException(\"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+                }\n+                IOUtils.copy(istream, ostream);\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Downloads data blocks provided by response to outputFile in parallel,\n+     * using the number of threads specified by user\n+     */\n+    private void getDataParallel(HtsgetResponse response) throws IOException {\n+        List<Future<Path>> futures = new ArrayList<>(response.getBlocks().size());\n+        for (Block block : response.getBlocks()) {\n+            switch (block.getUri().getScheme()) {\n+                case \"http\":\n+                case \"https\":\n+                    HttpGet get = new HttpGet(block.getUri());\n+                    block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                    futures.add(this.executorService.submit(() -> {\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        byte[] bytes = IOUtils.toByteArray(entity.getContent());\n+                        EntityUtils.consume(entity);\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                IOUtils.copy(new ByteArrayInputStream(bytes), ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                case \"data\":\n+                    String dataUri = block.getUri().toString();\n+                    if (!dataUri.matches(\"^data:.*;base64,.*\")) {\n+                        throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                    }\n+                    futures.add(this.executorService.submit(() -> {\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                InputStream istream = new ByteArrayInputStream(\n+                                    Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                                IOUtils.copy(istream, ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                default:\n+                    throw new UserException(\n+                            \"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+            }\n+        }\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Future<Path> f : futures) {\n+                try (InputStream istream = Files.newInputStream(f.get())) {\n+                    try {\n+                        IOUtils.copy(istream, ostream);\n+                    } catch (IOException e) {\n+                        throw new UserException(\"Error copying block: \" + e.getMessage());\n+                    }\n+                } catch (ExecutionException | InterruptedException e) {\n+                    throw new UserException(\"Error while waiting to download block: \" + e.getMessage());\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + this.outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Checks md5 digest provided in response, if one exists, against calculated md5 hash\n+     * of downloaded file, warning user if they differ\n+     */\n+    private void checkMd5(HtsgetResponse resp) {", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NTMwOA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429665308", "bodyText": "make the fields that can be final final", "author": "lbergelson", "createdAt": "2020-05-24T19:01:13Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/htsgetreader/HtsgetRequest.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.broadinstitute.hellbender.tools.htsgetreader;\n+\n+import java.net.URI;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.UriBuilder;\n+\n+/**\n+ * A single htsget request\n+ * \n+ * Does not validate that request is properly formed or can be fulfilled\n+ */\n+public class HtsgetRequest {\n+    private URI endpoint;", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MDE1Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432680152", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T19:04:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NTMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NTMzNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429665335", "bodyText": "I would move the validation into this.  I can't see any reason to allow it to produce invalid requests.", "author": "lbergelson", "createdAt": "2020-05-24T19:01:36Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/htsgetreader/HtsgetRequest.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.broadinstitute.hellbender.tools.htsgetreader;\n+\n+import java.net.URI;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.UriBuilder;\n+\n+/**\n+ * A single htsget request\n+ * \n+ * Does not validate that request is properly formed or can be fulfilled", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MDE5Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432680197", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T19:04:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NTMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NTM4MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429665381", "bodyText": "Replace these with a single setInterval that computes the right bounds from the gatk style interval", "author": "lbergelson", "createdAt": "2020-05-24T19:02:13Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/htsgetreader/HtsgetRequest.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.broadinstitute.hellbender.tools.htsgetreader;\n+\n+import java.net.URI;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.UriBuilder;\n+\n+/**\n+ * A single htsget request\n+ * \n+ * Does not validate that request is properly formed or can be fulfilled\n+ */\n+public class HtsgetRequest {\n+    private URI endpoint;\n+    private String id;\n+\n+    // Query parameters\n+    private HtsgetFormat format;\n+    private HtsgetClass dataClass;\n+    private String referenceName;\n+    private Integer start;\n+    private Integer end;\n+    private EnumSet<HtsgetRequestField> fields;\n+    private Set<String> tags;\n+    private Set<String> notags;\n+\n+    public HtsgetRequest(URI endpoint, String id) {\n+        this.endpoint = endpoint;\n+        this.id = id;\n+        this.fields = EnumSet.noneOf(HtsgetRequestField.class);\n+        this.tags = new HashSet<>();\n+        this.notags = new HashSet<>();\n+    }\n+\n+    public URI getEndpoint() {\n+        return this.endpoint;\n+    }\n+\n+    public String getID() {\n+        return this.id;\n+    }\n+\n+    public HtsgetFormat getFormat() {\n+        return this.format;\n+    }\n+\n+    public HtsgetClass getDataClass() {\n+        return this.dataClass;\n+    }\n+\n+    public String getReferenceName() {", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MDI1Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432680253", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T19:04:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NTM4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NTUwMg==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429665502", "bodyText": "class comment\nexplain that this is only for bam (if that's correct)", "author": "lbergelson", "createdAt": "2020-05-24T19:03:38Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/htsgetreader/HtsgetRequestField.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.broadinstitute.hellbender.tools.htsgetreader;\n+\n+public enum HtsgetRequestField {", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NjQwOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429666409", "bodyText": "I would start refactoring this and getParalleleData by extracting methods for getting the block results and trying to unify them so they can be reused between the methods.  I think it would probably make sense to have the blocks themselves know how to get their own data so the code in this tool just has to worry about the sequence of things.", "author": "lbergelson", "createdAt": "2020-05-24T19:16:17Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Block block : response.getBlocks()) {\n+                InputStream istream;\n+                switch (block.getUri().getScheme()) {\n+                    case \"http\":\n+                    case \"https\":\n+                        HttpGet get = new HttpGet(block.getUri());", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MDM4Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432680383", "bodyText": "Done.", "author": "andersleung", "createdAt": "2020-05-29T19:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NjQwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NjQzMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429666431", "bodyText": "attach exception", "author": "lbergelson", "createdAt": "2020-05-24T19:16:40Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Block block : response.getBlocks()) {\n+                InputStream istream;\n+                switch (block.getUri().getScheme()) {\n+                    case \"http\":\n+                    case \"https\":\n+                        HttpGet get = new HttpGet(block.getUri());\n+                        block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        istream = entity.getContent();\n+                        break;\n+                    case \"data\":\n+                        String dataUri = block.getUri().toString();\n+                        if (! dataUri.matches(\"^data:.*;base64,.*\")) {\n+                            throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                        }\n+                        istream = new ByteArrayInputStream(\n+                            Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                        break;\n+                    default:\n+                        throw new UserException(\"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+                }\n+                IOUtils.copy(istream, ostream);\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Downloads data blocks provided by response to outputFile in parallel,\n+     * using the number of threads specified by user\n+     */\n+    private void getDataParallel(HtsgetResponse response) throws IOException {\n+        List<Future<Path>> futures = new ArrayList<>(response.getBlocks().size());\n+        for (Block block : response.getBlocks()) {\n+            switch (block.getUri().getScheme()) {\n+                case \"http\":\n+                case \"https\":\n+                    HttpGet get = new HttpGet(block.getUri());\n+                    block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                    futures.add(this.executorService.submit(() -> {\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        byte[] bytes = IOUtils.toByteArray(entity.getContent());\n+                        EntityUtils.consume(entity);\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                IOUtils.copy(new ByteArrayInputStream(bytes), ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                case \"data\":\n+                    String dataUri = block.getUri().toString();\n+                    if (!dataUri.matches(\"^data:.*;base64,.*\")) {\n+                        throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                    }\n+                    futures.add(this.executorService.submit(() -> {\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                InputStream istream = new ByteArrayInputStream(\n+                                    Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                                IOUtils.copy(istream, ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MDQyMw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432680423", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T19:04:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NjQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NjQ3Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429666476", "bodyText": "delete the temp file when the copy is finished", "author": "lbergelson", "createdAt": "2020-05-24T19:17:27Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -0,0 +1,441 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.commons.io.Charsets;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpResponseInterceptor;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.util.EntityUtils;\n+import org.broadinstitute.barclay.argparser.Advanced;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.Utils;\n+\n+import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+@ExperimentalFeature\n+@CommandLineProgramProperties(\n+        summary = \"Download a file using htsget\",\n+        oneLineSummary = \"Download a file using htsget\",\n+        programGroup = ExampleProgramGroup.class\n+)\n+public class HtsgetReader extends GATKTool {\n+\n+    public static final String URL_LONG_NAME = \"url\";\n+    public static final String ID_LONG_NAME = \"id\";\n+    public static final String FORMAT_LONG_NAME = \"format\";\n+    public static final String CLASS_LONG_NAME = \"class\";\n+    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n+    public static final String START_LONG_NAME = \"start\";\n+    public static final String END_LONG_NAME = \"end\";\n+    public static final String FIELDS_LONG_NAME = \"field\";\n+    public static final String TAGS_LONG_NAME = \"tag\";\n+    public static final String NOTAGS_LONG_NAME = \"notag\";\n+    public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n+    public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n+    public static final String URL_SHORT_NAME = \"U\";\n+    public static final String ID_SHORT_NAME = \"ID\";\n+    public static final String FORMAT_SHORT_NAME = \"FO\";\n+    public static final String CLASS_SHORT_NAME = \"C\";\n+    public static final String REFERENCE_SHORT_NAME = \"RN\";\n+    public static final String START_SHORT_NAME = \"S\";\n+    public static final String END_SHORT_NAME = \"E\";\n+    public static final String FIELDS_SHORT_NAME = \"FL\";\n+    public static final String TAGS_SHORT_NAME = \"T\";\n+    public static final String NOTAGS_SHORT_NAME = \"N\";\n+\n+    @Argument(\n+            doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n+    )\n+    private File outputFile;\n+\n+    @Argument(\n+            doc = \"URL of htsget endpoint.\",\n+            fullName = URL_LONG_NAME,\n+            shortName = URL_SHORT_NAME\n+    )\n+    private URI endpoint;\n+\n+    @Argument(\n+            doc = \"ID of record to request.\",\n+            fullName = ID_LONG_NAME,\n+            shortName = ID_SHORT_NAME\n+    )\n+    private String id;\n+\n+    @Argument(\n+            doc = \"Format to request record data in.\",\n+            fullName = FORMAT_LONG_NAME,\n+            shortName = FORMAT_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetFormat format;\n+\n+    @Argument(\n+            doc = \"Class of data to request. Should be either `header` or `body`\",\n+            fullName = CLASS_LONG_NAME,\n+            shortName = CLASS_SHORT_NAME,\n+            optional = true\n+    )\n+    private HtsgetClass dataClass;\n+\n+    @Argument(\n+            doc = \"Reference sequence name.\",\n+            fullName = REFERENCE_LONG_NAME,\n+            shortName = REFERENCE_SHORT_NAME,\n+            optional = true\n+    )\n+    private String referenceName;\n+\n+    @Argument(\n+            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n+            fullName = START_LONG_NAME,\n+            shortName = START_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer start;\n+\n+    @Argument(\n+            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n+            fullName = END_LONG_NAME,\n+            shortName = END_SHORT_NAME,\n+            optional = true\n+    )\n+    private Integer end;\n+\n+    @Argument(\n+            doc = \"A list of fields to include, default: all\",\n+            fullName = FIELDS_LONG_NAME,\n+            shortName = FIELDS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<HtsgetRequestField> fields;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to include, default: all.\",\n+            fullName = TAGS_LONG_NAME,\n+            shortName = TAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> tags;\n+\n+    @Argument(\n+            doc = \"A comma separated list of tags to exclude, default: none.\",\n+            fullName = NOTAGS_LONG_NAME,\n+            shortName = NOTAGS_SHORT_NAME,\n+            optional = true\n+    )\n+    private List<String> notags;\n+    \n+    @Advanced\n+    @Argument(\n+            fullName = NUM_THREADS_LONG_NAME,\n+            shortName = NUM_THREADS_LONG_NAME,\n+            doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n+                    \"higher values may improve performance when network latency is an issue.\",\n+            optional = true,\n+            minValue = 1)\n+    private int readerThreads = 1;\n+\n+    @Argument(\n+            fullName = CHECK_MD5_LONG_NAME,\n+            shortName = CHECK_MD5_LONG_NAME,\n+            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n+                \"and validate it against the provided md5 hash, if it exists.\",\n+            optional = true)\n+    private boolean checkMd5 = false;\n+\n+    private ExecutorService executorService;\n+    \n+    private CloseableHttpClient client;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        if (this.readerThreads > 1) {\n+            final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"htsgetReader-thread-%d\")\n+                    .setDaemon(true)\n+                    .build();\n+            this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n+        }\n+        this.client = HttpClientBuilder.create()\n+            .setConnectionManager(new PoolingHttpClientConnectionManager())\n+            // throw IOException on 5xx error codes so request is retried\n+            .addInterceptorLast(new HttpResponseInterceptor() {\n+                @Override\n+                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n+                    int statusCode = resp.getStatusLine().getStatusCode();\n+                    if (500 <= statusCode && statusCode < 600) {\n+                        throw new IOException(\"Retry on 5xx error code\");\n+                    }\n+                }\n+            })\n+            .build();\n+    }\n+\n+    @Override\n+    public void onShutdown() {\n+        try {\n+            this.client.close();\n+        } catch (IOException e) {\n+            logger.warn(\"Exception while closing httpClient\");\n+        }\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec \n+     */\n+    private void validateRequest(HtsgetRequest req) {\n+        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n+            req.getReferenceName() != null ||\n+            req.getStart() != null ||\n+            req.getEnd() != null ||\n+            ! req.getFields().isEmpty() ||\n+            ! req.getTags().isEmpty() ||\n+            ! req.getNoTags().isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+        if (req.getStart() != null && req.getStart() < 0) {\n+            throw new UserException(\"Invalid request: start must be non-negative\");\n+        }\n+        if (req.getEnd() != null && req.getEnd() < 0) {\n+            throw new UserException(\"Invalid request: end must be non-negative\");\n+        }\n+        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n+            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        }\n+        String intersections = req.getTags().stream()\n+            .filter(req.getNoTags()::contains)\n+            .collect(Collectors.joining(\", \"));\n+        if (! intersections.isEmpty()) {\n+            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        }\n+    }\n+\n+    /** \n+     * Downloads data blocks provided by response to outputFile in serial\n+    */\n+    private void getData(HtsgetResponse response) throws IOException {\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Block block : response.getBlocks()) {\n+                InputStream istream;\n+                switch (block.getUri().getScheme()) {\n+                    case \"http\":\n+                    case \"https\":\n+                        HttpGet get = new HttpGet(block.getUri());\n+                        block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        istream = entity.getContent();\n+                        break;\n+                    case \"data\":\n+                        String dataUri = block.getUri().toString();\n+                        if (! dataUri.matches(\"^data:.*;base64,.*\")) {\n+                            throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                        }\n+                        istream = new ByteArrayInputStream(\n+                            Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                        break;\n+                    default:\n+                        throw new UserException(\"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+                }\n+                IOUtils.copy(istream, ostream);\n+            }\n+        } catch (IOException e) {\n+            throw new UserException(\"Could not create output file: \" + outputFile);\n+        }\n+    }\n+\n+    /**\n+     * Downloads data blocks provided by response to outputFile in parallel,\n+     * using the number of threads specified by user\n+     */\n+    private void getDataParallel(HtsgetResponse response) throws IOException {\n+        List<Future<Path>> futures = new ArrayList<>(response.getBlocks().size());\n+        for (Block block : response.getBlocks()) {\n+            switch (block.getUri().getScheme()) {\n+                case \"http\":\n+                case \"https\":\n+                    HttpGet get = new HttpGet(block.getUri());\n+                    block.getHeaders().forEach((header, value) -> get.addHeader(header, value));\n+                    futures.add(this.executorService.submit(() -> {\n+                        HttpEntity entity = this.client.execute(get).getEntity();\n+                        byte[] bytes = IOUtils.toByteArray(entity.getContent());\n+                        EntityUtils.consume(entity);\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                IOUtils.copy(new ByteArrayInputStream(bytes), ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                case \"data\":\n+                    String dataUri = block.getUri().toString();\n+                    if (!dataUri.matches(\"^data:.*;base64,.*\")) {\n+                        throw new UserException(\"data URI must be base64 encoded: \" + dataUri);\n+                    }\n+                    futures.add(this.executorService.submit(() -> {\n+                        Path tempFile = Files.createTempFile(\"\", \"\");\n+                        try (OutputStream ostream = Files.newOutputStream(tempFile)) {\n+                            try {\n+                                InputStream istream = new ByteArrayInputStream(\n+                                    Base64.getDecoder().decode(dataUri.replaceFirst(\"^data:.*;base64,\", \"\")));\n+                                IOUtils.copy(istream, ostream);\n+                            } catch (IOException e) {\n+                                throw new UserException(\"Could not write to temp file: \" + e.getMessage());\n+                            }\n+                        }\n+                        return tempFile;\n+                    }));\n+                    break;\n+                default:\n+                    throw new UserException(\n+                            \"Unrecognized URI scheme in data block: \" + block.getUri().getScheme());\n+            }\n+        }\n+        try (OutputStream ostream = new FileOutputStream(this.outputFile)) {\n+            for (Future<Path> f : futures) {\n+                try (InputStream istream = Files.newInputStream(f.get())) {\n+                    try {\n+                        IOUtils.copy(istream, ostream);", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MDQ1Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432680457", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T19:04:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NjQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NjY5MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429666691", "bodyText": "I assume these can't be final due to the way jackson initializes things?  If they're not final they should be private and exposed through getters to prevent accidental alteration.", "author": "lbergelson", "createdAt": "2020-05-24T19:20:26Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/htsgetreader/HtsgetErrorResponse.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.broadinstitute.hellbender.tools.htsgetreader;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonRootName;\n+\n+/**\n+ * Class allowing deserialization from json htsget error response\n+ */\n+@JsonRootName(value = \"htsget\")\n+public class HtsgetErrorResponse {\n+    @JsonProperty(\"error\")\n+    public String error;", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MDUxMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432680511", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T19:04:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NjY5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2Njg2OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429666869", "bodyText": "You should wrap the return value in Collections.unmodifiableMap() to prevent clients from modifying it.", "author": "lbergelson", "createdAt": "2020-05-24T19:23:01Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/htsgetreader/HtsgetResponse.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package org.broadinstitute.hellbender.tools.htsgetreader;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonRootName;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+\n+/**\n+ * Class allowing deserialization from json htsget response\n+ */\n+@JsonRootName(value = \"htsget\")\n+public class HtsgetResponse {\n+    public static class Block {\n+        @JsonProperty(\"url\")\n+        private URI uri;\n+\n+        @JsonProperty(\"headers\")\n+        @JsonDeserialize(as = HashMap.class, keyAs = String.class, contentAs = String.class)\n+        private Map<String, String> headers;\n+\n+        @JsonProperty(\"class\")\n+        private HtsgetClass dataClass;\n+\n+        public URI getUri() {\n+            return this.uri;\n+        }\n+\n+        public Map<String, String> getHeaders() {\n+            return this.headers;", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MDU2Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432680563", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T19:05:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2Njg2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NjkwNg==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429666906", "bodyText": "wrap this in a Collections.unmodifiableList for safety.", "author": "lbergelson", "createdAt": "2020-05-24T19:23:36Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/htsgetreader/HtsgetResponse.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package org.broadinstitute.hellbender.tools.htsgetreader;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonRootName;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+\n+/**\n+ * Class allowing deserialization from json htsget response\n+ */\n+@JsonRootName(value = \"htsget\")\n+public class HtsgetResponse {\n+    public static class Block {\n+        @JsonProperty(\"url\")\n+        private URI uri;\n+\n+        @JsonProperty(\"headers\")\n+        @JsonDeserialize(as = HashMap.class, keyAs = String.class, contentAs = String.class)\n+        private Map<String, String> headers;\n+\n+        @JsonProperty(\"class\")\n+        private HtsgetClass dataClass;\n+\n+        public URI getUri() {\n+            return this.uri;\n+        }\n+\n+        public Map<String, String> getHeaders() {\n+            return this.headers;\n+        }\n+\n+        public HtsgetClass getDataClass() {\n+            return this.dataClass;\n+        }\n+    }\n+\n+    @JsonProperty(\"format\")\n+    private HtsgetFormat format;\n+\n+    @JsonProperty(\"urls\")\n+    @JsonDeserialize(as = ArrayList.class, contentAs = Block.class)\n+    private List<Block> blocks;\n+\n+    @JsonProperty(\"md5\")\n+    private String md5;\n+\n+    public HtsgetFormat getFormat() {\n+        return this.format;\n+    }\n+\n+    public List<Block> getBlocks() {\n+        return this.blocks;", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MDU5OA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432680598", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T19:05:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NjkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NzQ5MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429667491", "bodyText": "I think this class can better be thought of as a builder for requests since it doesn't really have any other functionality.  I might rename to capture that.", "author": "lbergelson", "createdAt": "2020-05-24T19:31:21Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/htsgetreader/HtsgetRequest.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.broadinstitute.hellbender.tools.htsgetreader;\n+\n+import java.net.URI;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.UriBuilder;\n+\n+/**\n+ * A single htsget request\n+ * \n+ * Does not validate that request is properly formed or can be fulfilled\n+ */\n+public class HtsgetRequest {", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MDY1Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432680652", "bodyText": "Renamed.", "author": "andersleung", "createdAt": "2020-05-29T19:05:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NzQ5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NzU1OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429667559", "bodyText": "typo: missing word, can be used to make something here request", "author": "lbergelson", "createdAt": "2020-05-24T19:32:05Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/htsgetreader/HtsgetRequest.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.broadinstitute.hellbender.tools.htsgetreader;\n+\n+import java.net.URI;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.UriBuilder;\n+\n+/**\n+ * A single htsget request\n+ * \n+ * Does not validate that request is properly formed or can be fulfilled\n+ */\n+public class HtsgetRequest {\n+    private URI endpoint;\n+    private String id;\n+\n+    // Query parameters\n+    private HtsgetFormat format;\n+    private HtsgetClass dataClass;\n+    private String referenceName;\n+    private Integer start;\n+    private Integer end;\n+    private EnumSet<HtsgetRequestField> fields;\n+    private Set<String> tags;\n+    private Set<String> notags;\n+\n+    public HtsgetRequest(URI endpoint, String id) {\n+        this.endpoint = endpoint;\n+        this.id = id;\n+        this.fields = EnumSet.noneOf(HtsgetRequestField.class);\n+        this.tags = new HashSet<>();\n+        this.notags = new HashSet<>();\n+    }\n+\n+    public URI getEndpoint() {\n+        return this.endpoint;\n+    }\n+\n+    public String getID() {\n+        return this.id;\n+    }\n+\n+    public HtsgetFormat getFormat() {\n+        return this.format;\n+    }\n+\n+    public HtsgetClass getDataClass() {\n+        return this.dataClass;\n+    }\n+\n+    public String getReferenceName() {\n+        return this.referenceName;\n+    }\n+\n+    public Integer getStart() {\n+        return this.start;\n+    }\n+\n+    public Integer getEnd() {\n+        return this.end;\n+    }\n+\n+    public EnumSet<HtsgetRequestField> getFields() {\n+        return this.fields;\n+    }\n+\n+    public Set<String> getTags() {\n+        return this.tags;\n+    }\n+\n+    public Set<String> getNoTags() {\n+        return this.notags;\n+    }\n+    \n+    public void setFormat(HtsgetFormat format) {\n+        this.format = format;\n+    }\n+\n+    public void setDataClass(HtsgetClass dataClass) {\n+        this.dataClass = dataClass;\n+    }\n+\n+    public void setReferenceName(String referenceName) {\n+        this.referenceName = referenceName;\n+    }\n+\n+    public void setStart(Integer start) {\n+        this.start = start;\n+    }\n+\n+    public void setEnd(Integer end) {\n+        this.end = end;\n+    }\n+\n+    public void addField(HtsgetRequestField field) {\n+        this.fields.add(field);\n+    }\n+\n+    public void addFields(Collection<HtsgetRequestField> fields) {\n+        this.fields.addAll(fields);\n+    }\n+\n+    public void addTag(String tag) {\n+        this.tags.add(tag);\n+    }\n+\n+    public void addTags(Collection<String> tags) {\n+        this.tags.addAll(tags);\n+    }\n+\n+    public void addNotag(String notag) {\n+        this.notags.add(notag);\n+    }\n+\n+    public void addNotags(Collection<String> notags) {\n+        this.notags.addAll(notags);\n+    }\n+\n+    public HtsgetRequest withFormat(HtsgetFormat format) {\n+        this.format = format;\n+        return this;\n+    }\n+\n+    public HtsgetRequest withDataClass(HtsgetClass dataClass) {\n+        this.dataClass = dataClass;\n+        return this;\n+    }\n+\n+    public HtsgetRequest withReferenceName(String referenceName) {\n+        this.referenceName = referenceName;\n+        return this;\n+    }\n+\n+    public HtsgetRequest withStart(Integer start) {\n+        this.start = start;\n+        return this;\n+    }\n+\n+    public HtsgetRequest withEnd(Integer end) {\n+        this.end = end;\n+        return this;\n+    }\n+\n+    public HtsgetRequest withField(HtsgetRequestField field) {\n+        this.fields.add(field);\n+        return this;\n+    }\n+\n+    public HtsgetRequest withFields(Collection<HtsgetRequestField> fields) {\n+        this.fields.addAll(fields);\n+        return this;\n+    }\n+\n+    public HtsgetRequest withTag(String tag) {\n+        this.tags.add(tag);\n+        return this;\n+    }\n+\n+    public HtsgetRequest withTags(Collection<String> tags) {\n+        this.tags.addAll(tags);\n+        return this;\n+    }\n+\n+    public HtsgetRequest withNotag(String notag) {\n+        this.notags.add(notag);\n+        return this;\n+    }\n+\n+    public HtsgetRequest withNotags(Collection<String> notags) {\n+        this.notags.addAll(notags);\n+        return this;\n+    }\n+\n+    /**\n+     * Convert request to a URI which can be used to make request", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MDcwMg==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432680702", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T19:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NzU1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2ODE1OA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429668158", "bodyText": "Is this @ used to filter header lines from the expected file since the downloaded file doesn't have them?", "author": "lbergelson", "createdAt": "2020-05-24T19:38:22Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/HtsgetReaderIntegrationTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.testutils.IntegrationTestSpec;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+public class HtsgetReaderIntegrationTest extends CommandLineProgramTest {\n+\n+    private static final String ENDPOINT = \"https://htsget.ga4gh.org/reads\";\n+\n+    // Test ability to initiate download with no aditional parameters\n+    @Test\n+    public void testBasicDownload() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MDg3MA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432680870", "bodyText": "Changed this to null since the files should be exactly identical.", "author": "andersleung", "createdAt": "2020-05-29T19:05:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2ODE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2ODIzMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429668231", "bodyText": "It's often a good idea to refer to the static argument constants in the tests so the IDE can help when you rename/refactor them.", "author": "lbergelson", "createdAt": "2020-05-24T19:39:36Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/HtsgetReaderIntegrationTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.testutils.IntegrationTestSpec;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+public class HtsgetReaderIntegrationTest extends CommandLineProgramTest {\n+\n+    private static final String ENDPOINT = \"https://htsget.ga4gh.org/reads\";\n+\n+    // Test ability to initiate download with no aditional parameters\n+    @Test\n+    public void testBasicDownload() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MDkyOA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432680928", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T19:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2ODIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2ODI1MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429668251", "bodyText": "Won't this filter the entire header as a comment?", "author": "lbergelson", "createdAt": "2020-05-24T19:39:54Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/HtsgetReaderIntegrationTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.testutils.IntegrationTestSpec;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+public class HtsgetReaderIntegrationTest extends CommandLineProgramTest {\n+\n+    private static final String ENDPOINT = \"https://htsget.ga4gh.org/reads\";\n+\n+    // Test ability to initiate download with no aditional parameters\n+    @Test\n+    public void testBasicDownload() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    // Test ability to filter by class\n+    @Test\n+    public void testHeaderOnly() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam.header\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .add(\"class\", \"header\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MTAyNw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432681027", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T19:06:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2ODI1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2ODUxOA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429668518", "bodyText": "You  should make this a constant so it's clear that the same bam is being read in every test.", "author": "lbergelson", "createdAt": "2020-05-24T19:42:59Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/HtsgetReaderIntegrationTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.testutils.IntegrationTestSpec;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+public class HtsgetReaderIntegrationTest extends CommandLineProgramTest {\n+\n+    private static final String ENDPOINT = \"https://htsget.ga4gh.org/reads\";\n+\n+    // Test ability to initiate download with no aditional parameters\n+    @Test\n+    public void testBasicDownload() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    // Test ability to filter by class\n+    @Test\n+    public void testHeaderOnly() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam.header\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MjI1Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432682256", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T19:09:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2ODUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2OTExMA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429669110", "bodyText": "Good to see tests for error conditions.", "author": "lbergelson", "createdAt": "2020-05-24T19:48:43Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/HtsgetReaderIntegrationTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.testutils.IntegrationTestSpec;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+public class HtsgetReaderIntegrationTest extends CommandLineProgramTest {\n+\n+    private static final String ENDPOINT = \"https://htsget.ga4gh.org/reads\";\n+\n+    // Test ability to initiate download with no aditional parameters\n+    @Test\n+    public void testBasicDownload() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    // Test ability to filter by class\n+    @Test\n+    public void testHeaderOnly() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam.header\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .add(\"class\", \"header\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    // Test ability to filter by reference name\n+    @Test\n+    public void testReferenceName() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam.refname\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .add(\"reference-name\", \"chr1\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    // Test ability to filter by field\n+    @Test\n+    public void testField() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam.field\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .add(\"field\", \"QNAME\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    // Test ability to filter by start and end\n+    @Test\n+    public void testStartEnd() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam.startend\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .add(\"reference-name\", \"chr1\")\n+                .add(\"start\", \"1000\")\n+                .add(\"end\", \"2000\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    @DataProvider(name = \"invalidParams\")\n+    public Object[][] invalidParams(){\n+        return new Object[][]{\n+                {ImmutableMap.of(\"class\", \"header\", \"reference-name\", \"chr1\")},", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2OTIyNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429669225", "bodyText": "The expected output file is empty.  You should choose a new range that includes data.", "author": "lbergelson", "createdAt": "2020-05-24T19:50:20Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/HtsgetReaderIntegrationTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.testutils.IntegrationTestSpec;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+public class HtsgetReaderIntegrationTest extends CommandLineProgramTest {\n+\n+    private static final String ENDPOINT = \"https://htsget.ga4gh.org/reads\";\n+\n+    // Test ability to initiate download with no aditional parameters\n+    @Test\n+    public void testBasicDownload() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    // Test ability to filter by class\n+    @Test\n+    public void testHeaderOnly() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam.header\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .add(\"class\", \"header\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    // Test ability to filter by reference name\n+    @Test\n+    public void testReferenceName() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam.refname\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .add(\"reference-name\", \"chr1\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    // Test ability to filter by field\n+    @Test\n+    public void testField() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam.field\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .add(\"field\", \"QNAME\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    // Test ability to filter by start and end\n+    @Test\n+    public void testStartEnd() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam.startend\");", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MzEyNg==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432683126", "bodyText": "Changed range and corresponding expected file to one that includes data.", "author": "andersleung", "createdAt": "2020-05-29T19:11:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2OTIyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2OTQ1Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429669457", "bodyText": "I assume if start/end are specified than reference must also be specified?  Could you add validation for that / a test for it?", "author": "lbergelson", "createdAt": "2020-05-24T19:52:49Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/HtsgetReaderIntegrationTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.testutils.IntegrationTestSpec;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+public class HtsgetReaderIntegrationTest extends CommandLineProgramTest {\n+\n+    private static final String ENDPOINT = \"https://htsget.ga4gh.org/reads\";\n+\n+    // Test ability to initiate download with no aditional parameters\n+    @Test\n+    public void testBasicDownload() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    // Test ability to filter by class\n+    @Test\n+    public void testHeaderOnly() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam.header\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .add(\"class\", \"header\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    // Test ability to filter by reference name\n+    @Test\n+    public void testReferenceName() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam.refname\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .add(\"reference-name\", \"chr1\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    // Test ability to filter by field\n+    @Test\n+    public void testField() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam.field\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .add(\"field\", \"QNAME\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    // Test ability to filter by start and end\n+    @Test\n+    public void testStartEnd() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam.startend\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .add(\"reference-name\", \"chr1\")\n+                .add(\"start\", \"1000\")\n+                .add(\"end\", \"2000\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    @DataProvider(name = \"invalidParams\")\n+    public Object[][] invalidParams(){\n+        return new Object[][]{", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3MDY0OA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429670648", "bodyText": "Is it valid to specify start but not end and viceversa?", "author": "lbergelson", "createdAt": "2020-05-24T20:08:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2OTQ1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MzYyMg==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432683622", "bodyText": "Start without end is valid but not vice versa. Start and end both require reference. This is taken care of by the switch to using a SimpleInterval since the spec behaves the same way.", "author": "andersleung", "createdAt": "2020-05-29T19:12:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2OTQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2OTQ4MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429669481", "bodyText": "Please add a test that subsets by tags.", "author": "lbergelson", "createdAt": "2020-05-24T19:53:11Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/HtsgetReaderIntegrationTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.testutils.IntegrationTestSpec;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+public class HtsgetReaderIntegrationTest extends CommandLineProgramTest {\n+\n+    private static final String ENDPOINT = \"https://htsget.ga4gh.org/reads\";\n+\n+    // Test ability to initiate download with no aditional parameters\n+    @Test\n+    public void testBasicDownload() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    // Test ability to filter by class\n+    @Test\n+    public void testHeaderOnly() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam.header\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .add(\"class\", \"header\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    // Test ability to filter by reference name\n+    @Test\n+    public void testReferenceName() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam.refname\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .add(\"reference-name\", \"chr1\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    // Test ability to filter by field\n+    @Test\n+    public void testField() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam.field\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .add(\"field\", \"QNAME\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    // Test ability to filter by start and end\n+    @Test\n+    public void testStartEnd() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam.startend\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .add(\"reference-name\", \"chr1\")\n+                .add(\"start\", \"1000\")\n+                .add(\"end\", \"2000\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2OTY3Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429669676", "bodyText": "It would be good to add tests with an alternate data type like vcf or cram.  What happens if you request a vcf but you specify you want a bam?", "author": "lbergelson", "createdAt": "2020-05-24T19:55:32Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/HtsgetReaderIntegrationTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.testutils.IntegrationTestSpec;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+public class HtsgetReaderIntegrationTest extends CommandLineProgramTest {", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3MDMxMw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429670313", "bodyText": "If you specify a field with a vcf request what happens?  Similarly with tags.  Should we have a warning?", "author": "lbergelson", "createdAt": "2020-05-24T20:03:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2OTY3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4ODYxMw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432688613", "bodyText": "I added validation code that prevents requesting files with extensions for reads while specifying a variant format and vice versa. I think the treatment of fields/tags with variant files in the htsget spec is still undecided so I haven't added any additional validation for this.", "author": "andersleung", "createdAt": "2020-05-29T19:24:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2OTY3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAwMzI5NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r434003295", "bodyText": "\ud83d\udc4d", "author": "lbergelson", "createdAt": "2020-06-02T16:13:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2OTY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2OTcxNg==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429669716", "bodyText": "Could you add the following tests:\n* a test that shows we get an error if you request a contig that doesn't exist in the file.\n* an invalid sample id\n* an invalid endpoint\n* an endpoint that's longer than the actual contig is\n* a start point that starts in the middle of one of the reads, to show if that read is returned or not\n* an end point that ends in the middle of one of the reads, to show if that read is returned or not", "author": "lbergelson", "createdAt": "2020-05-24T19:56:03Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/HtsgetReaderIntegrationTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.testutils.IntegrationTestSpec;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+public class HtsgetReaderIntegrationTest extends CommandLineProgramTest {\n+\n+    private static final String ENDPOINT = \"https://htsget.ga4gh.org/reads\";\n+\n+    // Test ability to initiate download with no aditional parameters\n+    @Test\n+    public void testBasicDownload() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    // Test ability to filter by class\n+    @Test\n+    public void testHeaderOnly() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam.header\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .add(\"class\", \"header\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    // Test ability to filter by reference name\n+    @Test\n+    public void testReferenceName() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam.refname\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .add(\"reference-name\", \"chr1\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    // Test ability to filter by field\n+    @Test\n+    public void testField() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam.field\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .add(\"field\", \"QNAME\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    // Test ability to filter by start and end\n+    @Test\n+    public void testStartEnd() throws IOException {\n+        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam.startend\");\n+        final File output = createTempFile(\"output\", \".bam\");\n+\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .add(\"reference-name\", \"chr1\")\n+                .add(\"start\", \"1000\")\n+                .add(\"end\", \"2000\")\n+                .addOutput(output);\n+\n+        runCommandLine(args);\n+        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    }\n+\n+    @DataProvider(name = \"invalidParams\")\n+    public Object[][] invalidParams(){\n+        return new Object[][]{\n+                {ImmutableMap.of(\"class\", \"header\", \"reference-name\", \"chr1\")},\n+                {ImmutableMap.of(\"class\", \"header\", \"start\", \"1000\")},\n+                {ImmutableMap.of(\"class\", \"header\", \"end\", \"2000\")},\n+                {ImmutableMap.of(\"class\", \"header\", \"field\", \"QNAME\")},\n+                {ImmutableMap.of(\"class\", \"header\", \"tag\", \"NH\")},\n+                {ImmutableMap.of(\"class\", \"header\", \"notag\", \"NH\")},\n+                {ImmutableMap.of(\"start\", \"-1\")},\n+                {ImmutableMap.of(\"end\", \"-1\")},\n+                {ImmutableMap.of(\"start\", \"2000\", \"end\", \"1000\")},\n+                {ImmutableMap.of(\"tag\", \"NH\", \"notag\", \"NH\")},\n+        };\n+    }\n+\n+    // Expect a validation failure for invalid combinations of query parameters\n+    @Test(dataProvider = \"invalidParams\", expectedExceptions = UserException.class)\n+    public void testValidationFailure(Map<String, String> queries) {\n+        ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"U\", ENDPOINT)\n+                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n+                .addOutput(\"out\");\n+        queries.forEach((k, v) -> args.add(k, v));\n+\n+        runCommandLine(args);\n+    }\n+    ", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2OTczMg==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429669732", "bodyText": "Some of the validation tests should move here when the validation moves here.", "author": "lbergelson", "createdAt": "2020-05-24T19:56:21Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/htsgetreader/HtsgetRequestUnitTest.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package org.broadinstitute.hellbender.tools.htsgetreader;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+\n+import org.broadinstitute.hellbender.GATKBaseTest;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+public class HtsgetRequestUnitTest extends GATKBaseTest {\n+\n+    @Test\n+    public void testOnlyId() throws URISyntaxException {\n+        HtsgetRequest req = new HtsgetRequest(new URI(\"https://example.com\"), \"1\");\n+        Assert.assertEquals(req.toURI().toString(), \"https://example.com/1\");\n+    }\n+\n+    @Test\n+    public void testBasicFields() throws URISyntaxException {\n+        HtsgetRequest req = new HtsgetRequest(new URI(\"https://example.com\"), \"1\")\n+            .withFormat(HtsgetFormat.BAM)\n+            .withDataClass(HtsgetClass.body)\n+            .withReferenceName(\"chr1\")\n+            .withStart(0)\n+            .withEnd(16);\n+        Assert.assertEquals(req.toURI().toString(), \"https://example.com/1?format=BAM&class=body&referenceName=chr1&start=0&end=16\");\n+    }\n+", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4ODY3Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432688677", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-05-29T19:24:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2OTczMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3MDYyNw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429670627", "bodyText": "These tests are good but are probably only downloading single chunks.  I think a lot of that is out of our control unless we can control the server or want to download really large files.\nHave you run large tests on full size files including in parallel?  Could you create some tests on large files that exercise downloading multiple blocks, and check them in disabled so people can run them manually if they want?\nIt would also be good to have tests for the response directly that show we are seeing both dataURI and httpUri responses.  Or if we're not, just clarifying which we're getting.", "author": "lbergelson", "createdAt": "2020-05-24T20:08:10Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/HtsgetReaderIntegrationTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.testutils.IntegrationTestSpec;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+public class HtsgetReaderIntegrationTest extends CommandLineProgramTest {", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3MDY2NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r429670665", "bodyText": "We need a test using the parallel code even if it's just a tiny file like this.", "author": "lbergelson", "createdAt": "2020-05-24T20:09:00Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/HtsgetReaderIntegrationTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.testutils.IntegrationTestSpec;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+public class HtsgetReaderIntegrationTest extends CommandLineProgramTest {\n+\n+    private static final String ENDPOINT = \"https://htsget.ga4gh.org/reads\";\n+\n+    // Test ability to initiate download with no aditional parameters\n+    @Test\n+    public void testBasicDownload() throws IOException {", "originalCommit": "46b832a2ce425495f7337c695d1385a027dd47e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4ODc0OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r432688749", "bodyText": "Added.", "author": "andersleung", "createdAt": "2020-05-29T19:24:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3MDY2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3ODY1MA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r433978650", "bodyText": "\ud83d\udc4d  Thanks", "author": "lbergelson", "createdAt": "2020-06-02T15:46:11Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -43,385 +38,271 @@\n import org.broadinstitute.barclay.argparser.Argument;\n import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.CommandLineProgram;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n import org.broadinstitute.hellbender.engine.GATKTool;\n import org.broadinstitute.hellbender.exceptions.UserException;\n import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n-import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestBuilder;\n import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n-import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n import org.broadinstitute.hellbender.utils.Utils;\n \n-import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+/**\n+ * A tool that downloads a file hosted on an htsget server to a local file", "originalCommit": "6da3cb5ee0e544b1859f4e61a0a4407884b01462", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk4MDI1OA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r433980258", "bodyText": "In the future we probably want to change this to an exponential backoff strategy to deal with transient issues / swarms of clients overloading the server.  That shouldn't hold up this pr though.", "author": "lbergelson", "createdAt": "2020-06-02T15:47:48Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -43,385 +38,271 @@\n import org.broadinstitute.barclay.argparser.Argument;\n import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.CommandLineProgram;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n import org.broadinstitute.hellbender.engine.GATKTool;\n import org.broadinstitute.hellbender.exceptions.UserException;\n import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n-import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestBuilder;\n import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n-import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n import org.broadinstitute.hellbender.utils.Utils;\n \n-import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+/**\n+ * A tool that downloads a file hosted on an htsget server to a local file\n+ * \n+ * <h3>Usage example</h3>\n+ * <pre>\n+ * gatk HtsgetReader \\\n+ *   --url htsget-server.org \\\n+ *   --id A1.bam \\\n+ *   --reference-name chr1\n+ *   -O output.bam\n+ * </pre>\n+ */\n \n @ExperimentalFeature\n @CommandLineProgramProperties(\n         summary = \"Download a file using htsget\",\n         oneLineSummary = \"Download a file using htsget\",\n         programGroup = ExampleProgramGroup.class\n )\n-public class HtsgetReader extends GATKTool {\n+public class HtsgetReader extends CommandLineProgram {\n \n     public static final String URL_LONG_NAME = \"url\";\n     public static final String ID_LONG_NAME = \"id\";\n     public static final String FORMAT_LONG_NAME = \"format\";\n     public static final String CLASS_LONG_NAME = \"class\";\n-    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n-    public static final String START_LONG_NAME = \"start\";\n-    public static final String END_LONG_NAME = \"end\";\n     public static final String FIELDS_LONG_NAME = \"field\";\n     public static final String TAGS_LONG_NAME = \"tag\";\n     public static final String NOTAGS_LONG_NAME = \"notag\";\n     public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n     public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n-    public static final String URL_SHORT_NAME = \"U\";\n-    public static final String ID_SHORT_NAME = \"ID\";\n-    public static final String FORMAT_SHORT_NAME = \"FO\";\n-    public static final String CLASS_SHORT_NAME = \"C\";\n-    public static final String REFERENCE_SHORT_NAME = \"RN\";\n-    public static final String START_SHORT_NAME = \"S\";\n-    public static final String END_SHORT_NAME = \"E\";\n-    public static final String FIELDS_SHORT_NAME = \"FL\";\n-    public static final String TAGS_SHORT_NAME = \"T\";\n-    public static final String NOTAGS_SHORT_NAME = \"N\";\n-\n-    @Argument(\n-            doc = \"Output file.\",\n-            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n-            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n-    )\n+\n+    @Argument(doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_LONG_NAME)\n     private File outputFile;\n \n-    @Argument(\n-            doc = \"URL of htsget endpoint.\",\n+    @Argument(doc = \"URL of htsget endpoint.\",\n             fullName = URL_LONG_NAME,\n-            shortName = URL_SHORT_NAME\n-    )\n+            shortName = URL_LONG_NAME)\n     private URI endpoint;\n \n-    @Argument(\n-            doc = \"ID of record to request.\",\n+    @Argument(doc = \"ID of record to request.\",\n             fullName = ID_LONG_NAME,\n-            shortName = ID_SHORT_NAME\n-    )\n+            shortName = ID_LONG_NAME)\n     private String id;\n \n-    @Argument(\n-            doc = \"Format to request record data in.\",\n+    @Argument(doc = \"Format to request record data in.\",\n             fullName = FORMAT_LONG_NAME,\n-            shortName = FORMAT_SHORT_NAME,\n-            optional = true\n-    )\n+            shortName = FORMAT_LONG_NAME,\n+            optional = true)\n     private HtsgetFormat format;\n \n-    @Argument(\n-            doc = \"Class of data to request. Should be either `header` or `body`\",\n+    @Argument(doc = \"Class of data to request.\",\n             fullName = CLASS_LONG_NAME,\n-            shortName = CLASS_SHORT_NAME,\n-            optional = true\n-    )\n+            shortName = CLASS_LONG_NAME,\n+            optional = true)\n     private HtsgetClass dataClass;\n \n-    @Argument(\n-            doc = \"Reference sequence name.\",\n-            fullName = REFERENCE_LONG_NAME,\n-            shortName = REFERENCE_SHORT_NAME,\n-            optional = true\n-    )\n-    private String referenceName;\n-\n-    @Argument(\n-            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n-            fullName = START_LONG_NAME,\n-            shortName = START_SHORT_NAME,\n-            optional = true\n-    )\n-    private Integer start;\n-\n-    @Argument(\n-            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n-            fullName = END_LONG_NAME,\n-            shortName = END_SHORT_NAME,\n-            optional = true\n-    )\n-    private Integer end;\n-\n-    @Argument(\n-            doc = \"A list of fields to include, default: all\",\n+    @Argument(doc = \"The interval and reference sequence to request\",\n+            fullName = StandardArgumentDefinitions.INTERVALS_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.INTERVALS_SHORT_NAME,\n+            optional = true)\n+    private SimpleInterval interval;\n+\n+    @Argument(doc = \"A field to include, default: all\",\n             fullName = FIELDS_LONG_NAME,\n-            shortName = FIELDS_SHORT_NAME,\n-            optional = true\n-    )\n+            shortName = FIELDS_LONG_NAME,\n+            optional = true)\n     private List<HtsgetRequestField> fields;\n \n-    @Argument(\n-            doc = \"A comma separated list of tags to include, default: all.\",\n+    @Argument(doc = \"A tag which should be included.\",\n             fullName = TAGS_LONG_NAME,\n-            shortName = TAGS_SHORT_NAME,\n-            optional = true\n-    )\n+            shortName = TAGS_LONG_NAME,\n+            optional = true)\n     private List<String> tags;\n \n-    @Argument(\n-            doc = \"A comma separated list of tags to exclude, default: none.\",\n+    @Argument(doc = \"A tag which should be excluded.\",\n             fullName = NOTAGS_LONG_NAME,\n-            shortName = NOTAGS_SHORT_NAME,\n-            optional = true\n-    )\n+            shortName = NOTAGS_LONG_NAME,\n+            optional = true)\n     private List<String> notags;\n     \n     @Advanced\n-    @Argument(\n-            fullName = NUM_THREADS_LONG_NAME,\n+    @Argument(fullName = NUM_THREADS_LONG_NAME,\n             shortName = NUM_THREADS_LONG_NAME,\n             doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n                     \"higher values may improve performance when network latency is an issue.\",\n             optional = true,\n             minValue = 1)\n     private int readerThreads = 1;\n \n-    @Argument(\n-            fullName = CHECK_MD5_LONG_NAME,\n-            shortName = CHECK_MD5_LONG_NAME,\n-            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n-                \"and validate it against the provided md5 hash, if it exists.\",\n-            optional = true)\n+    @Argument(fullName = CHECK_MD5_LONG_NAME, shortName = CHECK_MD5_LONG_NAME, doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \"\n+            + \"and validate it against the provided md5 hash, if it exists.\", optional = true)\n     private boolean checkMd5 = false;\n \n     private ExecutorService executorService;\n-    \n+\n     private CloseableHttpClient client;\n \n     @Override\n-    public void onTraversalStart() {\n+    public void onStartup() {\n         if (this.readerThreads > 1) {\n+            logger.info(\"Initializing with \" + this.readerThreads + \" threads\");\n             final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n-                    .setNameFormat(\"htsgetReader-thread-%d\")\n-                    .setDaemon(true)\n-                    .build();\n+                .setNameFormat(\"htsgetReader-thread-%d\")\n+                .setDaemon(true).build();\n             this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n         }\n         this.client = HttpClientBuilder.create()\n             .setConnectionManager(new PoolingHttpClientConnectionManager())\n-            // throw IOException on 5xx error codes so request is retried\n-            .addInterceptorLast(new HttpResponseInterceptor() {\n+            .setServiceUnavailableRetryStrategy(new ServiceUnavailableRetryStrategy() {\n                 @Override\n-                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n-                    int statusCode = resp.getStatusLine().getStatusCode();\n-                    if (500 <= statusCode && statusCode < 600) {\n-                        throw new IOException(\"Retry on 5xx error code\");\n+                // retry at most 4 times if a 5xx status code is received\n+                public boolean retryRequest(final HttpResponse resp, final int executionCount, final HttpContext context) {\n+                    if (executionCount > 4) {\n+                        return false;\n                     }\n+                    if (resp.getStatusLine() == null) {\n+                        return true;\n+                    }\n+                    final int statusCode = resp.getStatusLine().getStatusCode();\n+                    return 500 <= statusCode && statusCode < 600;\n+                }\n+\n+                @Override\n+                public long getRetryInterval() {", "originalCommit": "6da3cb5ee0e544b1859f4e61a0a4407884b01462", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4OTcwOA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r434589708", "bodyText": "Added simple exponential backoff.", "author": "andersleung", "createdAt": "2020-06-03T14:00:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk4MDI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk4NDA2Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r433984066", "bodyText": "The get data methods are so much clearer now.  Thank you.", "author": "lbergelson", "createdAt": "2020-06-02T15:51:34Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/HtsgetReader.java", "diffHunk": "@@ -43,385 +38,271 @@\n import org.broadinstitute.barclay.argparser.Argument;\n import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n import org.broadinstitute.barclay.argparser.ExperimentalFeature;\n+import org.broadinstitute.hellbender.cmdline.CommandLineProgram;\n import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n import org.broadinstitute.hellbender.cmdline.programgroups.ExampleProgramGroup;\n import org.broadinstitute.hellbender.engine.GATKTool;\n import org.broadinstitute.hellbender.exceptions.UserException;\n import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetClass;\n import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetErrorResponse;\n import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetFormat;\n-import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequest;\n+import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestBuilder;\n import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetRequestField;\n import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse;\n-import org.broadinstitute.hellbender.tools.htsgetreader.HtsgetResponse.Block;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n import org.broadinstitute.hellbender.utils.Utils;\n \n-import avro.shaded.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+/**\n+ * A tool that downloads a file hosted on an htsget server to a local file\n+ * \n+ * <h3>Usage example</h3>\n+ * <pre>\n+ * gatk HtsgetReader \\\n+ *   --url htsget-server.org \\\n+ *   --id A1.bam \\\n+ *   --reference-name chr1\n+ *   -O output.bam\n+ * </pre>\n+ */\n \n @ExperimentalFeature\n @CommandLineProgramProperties(\n         summary = \"Download a file using htsget\",\n         oneLineSummary = \"Download a file using htsget\",\n         programGroup = ExampleProgramGroup.class\n )\n-public class HtsgetReader extends GATKTool {\n+public class HtsgetReader extends CommandLineProgram {\n \n     public static final String URL_LONG_NAME = \"url\";\n     public static final String ID_LONG_NAME = \"id\";\n     public static final String FORMAT_LONG_NAME = \"format\";\n     public static final String CLASS_LONG_NAME = \"class\";\n-    public static final String REFERENCE_LONG_NAME = \"reference-name\";\n-    public static final String START_LONG_NAME = \"start\";\n-    public static final String END_LONG_NAME = \"end\";\n     public static final String FIELDS_LONG_NAME = \"field\";\n     public static final String TAGS_LONG_NAME = \"tag\";\n     public static final String NOTAGS_LONG_NAME = \"notag\";\n     public static final String NUM_THREADS_LONG_NAME = \"reader-threads\";\n     public static final String CHECK_MD5_LONG_NAME = \"check-md5\";\n-    public static final String URL_SHORT_NAME = \"U\";\n-    public static final String ID_SHORT_NAME = \"ID\";\n-    public static final String FORMAT_SHORT_NAME = \"FO\";\n-    public static final String CLASS_SHORT_NAME = \"C\";\n-    public static final String REFERENCE_SHORT_NAME = \"RN\";\n-    public static final String START_SHORT_NAME = \"S\";\n-    public static final String END_SHORT_NAME = \"E\";\n-    public static final String FIELDS_SHORT_NAME = \"FL\";\n-    public static final String TAGS_SHORT_NAME = \"T\";\n-    public static final String NOTAGS_SHORT_NAME = \"N\";\n-\n-    @Argument(\n-            doc = \"Output file.\",\n-            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n-            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME\n-    )\n+\n+    @Argument(doc = \"Output file.\",\n+            fullName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_LONG_NAME)\n     private File outputFile;\n \n-    @Argument(\n-            doc = \"URL of htsget endpoint.\",\n+    @Argument(doc = \"URL of htsget endpoint.\",\n             fullName = URL_LONG_NAME,\n-            shortName = URL_SHORT_NAME\n-    )\n+            shortName = URL_LONG_NAME)\n     private URI endpoint;\n \n-    @Argument(\n-            doc = \"ID of record to request.\",\n+    @Argument(doc = \"ID of record to request.\",\n             fullName = ID_LONG_NAME,\n-            shortName = ID_SHORT_NAME\n-    )\n+            shortName = ID_LONG_NAME)\n     private String id;\n \n-    @Argument(\n-            doc = \"Format to request record data in.\",\n+    @Argument(doc = \"Format to request record data in.\",\n             fullName = FORMAT_LONG_NAME,\n-            shortName = FORMAT_SHORT_NAME,\n-            optional = true\n-    )\n+            shortName = FORMAT_LONG_NAME,\n+            optional = true)\n     private HtsgetFormat format;\n \n-    @Argument(\n-            doc = \"Class of data to request. Should be either `header` or `body`\",\n+    @Argument(doc = \"Class of data to request.\",\n             fullName = CLASS_LONG_NAME,\n-            shortName = CLASS_SHORT_NAME,\n-            optional = true\n-    )\n+            shortName = CLASS_LONG_NAME,\n+            optional = true)\n     private HtsgetClass dataClass;\n \n-    @Argument(\n-            doc = \"Reference sequence name.\",\n-            fullName = REFERENCE_LONG_NAME,\n-            shortName = REFERENCE_SHORT_NAME,\n-            optional = true\n-    )\n-    private String referenceName;\n-\n-    @Argument(\n-            doc = \"Start position of the range on the reference, 0-based, inclusive\",\n-            fullName = START_LONG_NAME,\n-            shortName = START_SHORT_NAME,\n-            optional = true\n-    )\n-    private Integer start;\n-\n-    @Argument(\n-            doc = \"The end position of the range on the reference, 0-based exclusive.\",\n-            fullName = END_LONG_NAME,\n-            shortName = END_SHORT_NAME,\n-            optional = true\n-    )\n-    private Integer end;\n-\n-    @Argument(\n-            doc = \"A list of fields to include, default: all\",\n+    @Argument(doc = \"The interval and reference sequence to request\",\n+            fullName = StandardArgumentDefinitions.INTERVALS_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.INTERVALS_SHORT_NAME,\n+            optional = true)\n+    private SimpleInterval interval;\n+\n+    @Argument(doc = \"A field to include, default: all\",\n             fullName = FIELDS_LONG_NAME,\n-            shortName = FIELDS_SHORT_NAME,\n-            optional = true\n-    )\n+            shortName = FIELDS_LONG_NAME,\n+            optional = true)\n     private List<HtsgetRequestField> fields;\n \n-    @Argument(\n-            doc = \"A comma separated list of tags to include, default: all.\",\n+    @Argument(doc = \"A tag which should be included.\",\n             fullName = TAGS_LONG_NAME,\n-            shortName = TAGS_SHORT_NAME,\n-            optional = true\n-    )\n+            shortName = TAGS_LONG_NAME,\n+            optional = true)\n     private List<String> tags;\n \n-    @Argument(\n-            doc = \"A comma separated list of tags to exclude, default: none.\",\n+    @Argument(doc = \"A tag which should be excluded.\",\n             fullName = NOTAGS_LONG_NAME,\n-            shortName = NOTAGS_SHORT_NAME,\n-            optional = true\n-    )\n+            shortName = NOTAGS_LONG_NAME,\n+            optional = true)\n     private List<String> notags;\n     \n     @Advanced\n-    @Argument(\n-            fullName = NUM_THREADS_LONG_NAME,\n+    @Argument(fullName = NUM_THREADS_LONG_NAME,\n             shortName = NUM_THREADS_LONG_NAME,\n             doc = \"How many simultaneous threads to use when reading data from an htsget response;\" +\n                     \"higher values may improve performance when network latency is an issue.\",\n             optional = true,\n             minValue = 1)\n     private int readerThreads = 1;\n \n-    @Argument(\n-            fullName = CHECK_MD5_LONG_NAME,\n-            shortName = CHECK_MD5_LONG_NAME,\n-            doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \" +\n-                \"and validate it against the provided md5 hash, if it exists.\",\n-            optional = true)\n+    @Argument(fullName = CHECK_MD5_LONG_NAME, shortName = CHECK_MD5_LONG_NAME, doc = \"Boolean determining whether to calculate the md5 digest of the assembled file \"\n+            + \"and validate it against the provided md5 hash, if it exists.\", optional = true)\n     private boolean checkMd5 = false;\n \n     private ExecutorService executorService;\n-    \n+\n     private CloseableHttpClient client;\n \n     @Override\n-    public void onTraversalStart() {\n+    public void onStartup() {\n         if (this.readerThreads > 1) {\n+            logger.info(\"Initializing with \" + this.readerThreads + \" threads\");\n             final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n-                    .setNameFormat(\"htsgetReader-thread-%d\")\n-                    .setDaemon(true)\n-                    .build();\n+                .setNameFormat(\"htsgetReader-thread-%d\")\n+                .setDaemon(true).build();\n             this.executorService = Executors.newFixedThreadPool(readerThreads, threadFactory);\n         }\n         this.client = HttpClientBuilder.create()\n             .setConnectionManager(new PoolingHttpClientConnectionManager())\n-            // throw IOException on 5xx error codes so request is retried\n-            .addInterceptorLast(new HttpResponseInterceptor() {\n+            .setServiceUnavailableRetryStrategy(new ServiceUnavailableRetryStrategy() {\n                 @Override\n-                public void process(HttpResponse resp, HttpContext ctxt) throws HttpException, IOException {\n-                    int statusCode = resp.getStatusLine().getStatusCode();\n-                    if (500 <= statusCode && statusCode < 600) {\n-                        throw new IOException(\"Retry on 5xx error code\");\n+                // retry at most 4 times if a 5xx status code is received\n+                public boolean retryRequest(final HttpResponse resp, final int executionCount, final HttpContext context) {\n+                    if (executionCount > 4) {\n+                        return false;\n                     }\n+                    if (resp.getStatusLine() == null) {\n+                        return true;\n+                    }\n+                    final int statusCode = resp.getStatusLine().getStatusCode();\n+                    return 500 <= statusCode && statusCode < 600;\n+                }\n+\n+                @Override\n+                public long getRetryInterval() {\n+                    return 0;\n                 }\n             })\n-            .build();\n+           .build();\n     }\n \n     @Override\n     public void onShutdown() {\n-        try {\n-            this.client.close();\n-        } catch (IOException e) {\n-            logger.warn(\"Exception while closing httpClient\");\n-        }\n-    }\n-\n-    /**\n-     * Validates that the user query obeys htsget spec \n-     */\n-    private void validateRequest(HtsgetRequest req) {\n-        if (req.getDataClass() != null && req.getDataClass() == HtsgetClass.header && (\n-            req.getReferenceName() != null ||\n-            req.getStart() != null ||\n-            req.getEnd() != null ||\n-            ! req.getFields().isEmpty() ||\n-            ! req.getTags().isEmpty() ||\n-            ! req.getNoTags().isEmpty())) {\n-                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n-        }\n-        if (req.getStart() != null && req.getStart() < 0) {\n-            throw new UserException(\"Invalid request: start must be non-negative\");\n-        }\n-        if (req.getEnd() != null && req.getEnd() < 0) {\n-            throw new UserException(\"Invalid request: end must be non-negative\");\n-        }\n-        if (req.getStart() != null && req.getEnd() != null && req.getStart() > req.getEnd()) {\n-            throw new UserException(\"Invalid request: end may not be greater than start\");\n+        if (this.client != null) {\n+            try {\n+                this.client.close();\n+            } catch (final IOException e) {\n+                logger.warn(\"Exception while closing httpClient\", e);\n+            }\n         }\n-        String intersections = req.getTags().stream()\n-            .filter(req.getNoTags()::contains)\n-            .collect(Collectors.joining(\", \"));\n-        if (! intersections.isEmpty()) {\n-            throw new UserException(\"Invalid request: tags and notags overlap in the following fields: \" + intersections);\n+        if (this.executorService != null) {\n+            this.executorService.shutdownNow();\n         }\n+        super.onShutdown();\n     }\n \n-    /** \n+    /**\n      * Downloads data blocks provided by response to outputFile in serial\n-    */\n-    private void getData(HtsgetResponse response) throws IOException {\n+     */\n+    private void getData(final HtsgetResponse response) {", "originalCommit": "6da3cb5ee0e544b1859f4e61a0a4407884b01462", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk5MDUyMw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r433990523", "bodyText": "This comment is out of date I think.", "author": "lbergelson", "createdAt": "2020-06-02T15:57:54Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/htsgetreader/HtsgetRequestBuilder.java", "diffHunk": "@@ -0,0 +1,217 @@\n+package org.broadinstitute.hellbender.tools.htsgetreader;\n+\n+import java.net.URI;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.UriBuilder;\n+\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+\n+/**\n+ * A single htsget request", "originalCommit": "6da3cb5ee0e544b1859f4e61a0a4407884b01462", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4OTUxNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r434589515", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-06-03T14:00:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk5MDUyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk5MzcyMg==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r433993722", "bodyText": "do you need to include .vcf.gz as an option here?  There are a filename constants defined in  htsjdk.samtools.util.FileExtensions which are nice to reference instead of using raw strings. It make it easily searchable.", "author": "lbergelson", "createdAt": "2020-06-02T16:01:05Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/htsgetreader/HtsgetRequestBuilder.java", "diffHunk": "@@ -0,0 +1,217 @@\n+package org.broadinstitute.hellbender.tools.htsgetreader;\n+\n+import java.net.URI;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.UriBuilder;\n+\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+\n+/**\n+ * A single htsget request\n+ * \n+ * Can only be converted to a URI after validating that request is properly formed\n+ */\n+public class HtsgetRequestBuilder {\n+    final private URI endpoint;\n+    final private String id;\n+\n+    // Query parameters\n+    private HtsgetFormat format;\n+    private HtsgetClass dataClass;\n+    private SimpleInterval interval;\n+    private final EnumSet<HtsgetRequestField> fields;\n+    private final Set<String> tags;\n+    private final Set<String> notags;\n+\n+    public HtsgetRequestBuilder(final URI endpoint, final String id) {\n+        this.endpoint = endpoint;\n+        this.id = id;\n+        this.fields = EnumSet.noneOf(HtsgetRequestField.class);\n+        this.tags = new HashSet<>();\n+        this.notags = new HashSet<>();\n+    }\n+\n+    public URI getEndpoint() {\n+        return this.endpoint;\n+    }\n+\n+    public String getID() {\n+        return this.id;\n+    }\n+\n+    public HtsgetFormat getFormat() {\n+        return this.format;\n+    }\n+\n+    public HtsgetClass getDataClass() {\n+        return this.dataClass;\n+    }\n+\n+    public SimpleInterval getInterval() {\n+        return this.interval;\n+    }\n+\n+    public Set<HtsgetRequestField> getFields() {\n+        return Collections.unmodifiableSet(this.fields);\n+    }\n+\n+    public Set<String> getTags() {\n+        return Collections.unmodifiableSet(this.tags);\n+    }\n+\n+    public Set<String> getNoTags() {\n+        return Collections.unmodifiableSet(this.notags);\n+    }\n+\n+    public void setFormat(final HtsgetFormat format) {\n+        this.format = format;\n+    }\n+\n+    public void setDataClass(final HtsgetClass dataClass) {\n+        this.dataClass = dataClass;\n+    }\n+\n+    public void setInterval(final SimpleInterval interval) {\n+        this.interval = interval;\n+    }\n+\n+    public void addField(final HtsgetRequestField field) {\n+        this.fields.add(field);\n+    }\n+\n+    public void addFields(final Collection<HtsgetRequestField> fields) {\n+        this.fields.addAll(fields);\n+    }\n+\n+    public void addTag(final String tag) {\n+        this.tags.add(tag);\n+    }\n+\n+    public void addTags(final Collection<String> tags) {\n+        this.tags.addAll(tags);\n+    }\n+\n+    public void addNotag(final String notag) {\n+        this.notags.add(notag);\n+    }\n+\n+    public void addNotags(final Collection<String> notags) {\n+        this.notags.addAll(notags);\n+    }\n+\n+    public HtsgetRequestBuilder withFormat(final HtsgetFormat format) {\n+        this.format = format;\n+        return this;\n+    }\n+\n+    public HtsgetRequestBuilder withDataClass(final HtsgetClass dataClass) {\n+        this.dataClass = dataClass;\n+        return this;\n+    }\n+\n+    public HtsgetRequestBuilder withInterval(final SimpleInterval interval) {\n+        this.interval = interval;\n+        return this;\n+    }\n+\n+    public HtsgetRequestBuilder withField(final HtsgetRequestField field) {\n+        this.fields.add(field);\n+        return this;\n+    }\n+\n+    public HtsgetRequestBuilder withFields(final Collection<HtsgetRequestField> fields) {\n+        this.fields.addAll(fields);\n+        return this;\n+    }\n+\n+    public HtsgetRequestBuilder withTag(final String tag) {\n+        this.tags.add(tag);\n+        return this;\n+    }\n+\n+    public HtsgetRequestBuilder withTags(final Collection<String> tags) {\n+        this.tags.addAll(tags);\n+        return this;\n+    }\n+\n+    public HtsgetRequestBuilder withNotag(final String notag) {\n+        this.notags.add(notag);\n+        return this;\n+    }\n+\n+    public HtsgetRequestBuilder withNotags(final Collection<String> notags) {\n+        this.notags.addAll(notags);\n+        return this;\n+    }\n+\n+    /**\n+     * Validates that the user query obeys htsget spec\n+     */\n+    private void validateRequest() {\n+        if (this.dataClass != null && this.dataClass == HtsgetClass.header && (\n+            this.interval != null ||\n+            ! this.fields.isEmpty() ||\n+            ! this.tags.isEmpty() ||\n+            ! this.notags.isEmpty())) {\n+                throw new UserException(\"Invalid request: no query parameters except `format` may be specified when class=header\");\n+        }\n+\n+        if (this.format != null) {\n+            if ((this.id.endsWith(\".bam\") || this.id.endsWith(\".cram\") && (\n+                this.format != HtsgetFormat.BAM && this.format != HtsgetFormat.CRAM))\n+                ||\n+                (this.id.endsWith(\".vcf\") || this.id.endsWith(\".bcf\")) && (", "originalCommit": "6da3cb5ee0e544b1859f4e61a0a4407884b01462", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4OTQzNw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r434589437", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-06-03T14:00:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk5MzcyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAwMTc5Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r434001796", "bodyText": "Since this is a pretty substantial block of now duplicated code, let deduplicate it.  I would recommend just moving this getHttpClient method to a new class, maybe HttpUtils, and maybe just making it a singleton since it's threadsafe and we could share it.", "author": "lbergelson", "createdAt": "2020-06-02T16:11:31Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/htsgetreader/HtsgetResponse.java", "diffHunk": "@@ -26,17 +46,78 @@\n         @JsonProperty(\"class\")\n         private HtsgetClass dataClass;\n \n+        @JsonIgnore\n+        private static CloseableHttpClient client;\n+\n         public URI getUri() {\n             return this.uri;\n         }\n \n         public Map<String, String> getHeaders() {\n-            return this.headers;\n+            return Collections.unmodifiableMap(this.headers);\n         }\n \n         public HtsgetClass getDataClass() {\n             return this.dataClass;\n         }\n+\n+        private static synchronized CloseableHttpClient getHttpClient() {", "originalCommit": "6da3cb5ee0e544b1859f4e61a0a4407884b01462", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4OTE4Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r434589182", "bodyText": "Fixed.", "author": "andersleung", "createdAt": "2020-06-03T14:00:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAwMTc5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAwMzExMw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r434003113", "bodyText": "Could you add a comment to this method explaining what happens here?  It's useful to know that it potentially gets saved to a temp file and then you read from the tmp file and that's not obvious unless you read the code.", "author": "lbergelson", "createdAt": "2020-06-02T16:13:26Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/htsgetreader/HtsgetResponse.java", "diffHunk": "@@ -26,17 +46,78 @@\n         @JsonProperty(\"class\")\n         private HtsgetClass dataClass;\n \n+        @JsonIgnore\n+        private static CloseableHttpClient client;\n+\n         public URI getUri() {\n             return this.uri;\n         }\n \n         public Map<String, String> getHeaders() {\n-            return this.headers;\n+            return Collections.unmodifiableMap(this.headers);\n         }\n \n         public HtsgetClass getDataClass() {\n             return this.dataClass;\n         }\n+\n+        private static synchronized CloseableHttpClient getHttpClient() {\n+            if (Block.client == null) {\n+                Block.client = HttpClientBuilder.create()\n+                    .setConnectionManager(new PoolingHttpClientConnectionManager())\n+                    .setServiceUnavailableRetryStrategy(new ServiceUnavailableRetryStrategy() {\n+                        @Override\n+                        // retry at most 4 times if a 5xx status code is received, or no status line is present\n+                        public boolean retryRequest(final HttpResponse resp, final int executionCount, final HttpContext context) {\n+                            if (executionCount > 4) {\n+                                return false;\n+                            }\n+                            if (resp.getStatusLine() == null) {\n+                                return true;\n+                            }\n+                            final int statusCode = resp.getStatusLine().getStatusCode();\n+                            return 500 <= statusCode && statusCode < 600;\n+                        }\n+\n+                        @Override\n+                        public long getRetryInterval() {\n+                            return 0;\n+                        }\n+                    })\n+                    .build();\n+            }\n+            return Block.client;\n+        }\n+\n+        public InputStream getData() {", "originalCommit": "6da3cb5ee0e544b1859f4e61a0a4407884b01462", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4OTMxOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r434589319", "bodyText": "Added.", "author": "andersleung", "createdAt": "2020-06-03T14:00:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAwMzExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAwMzY0Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r434003643", "bodyText": "Good idea to make it a dataprovider.", "author": "lbergelson", "createdAt": "2020-06-02T16:14:18Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/HtsgetReaderIntegrationTest.java", "diffHunk": "@@ -13,117 +14,103 @@\n \n import com.google.common.collect.ImmutableMap;\n \n+\n public class HtsgetReaderIntegrationTest extends CommandLineProgramTest {\n \n     private static final String ENDPOINT = \"https://htsget.ga4gh.org/reads\";\n-\n-    // Test ability to initiate download with no aditional parameters\n-    @Test\n-    public void testBasicDownload() throws IOException {\n-        final File expected = new File(getToolTestDataDir(), \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\");\n-        final File output = createTempFile(\"output\", \".bam\");\n-\n-        final ArgumentsBuilder args = new ArgumentsBuilder()\n-                .add(\"U\", ENDPOINT)\n-                .add(\"ID\", \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\")\n-                .addOutput(output);\n-\n-        runCommandLine(args);\n-        IntegrationTestSpec.assertEqualTextFiles(output, expected, \"@\");\n+    private static final String FILE_ID = \"A1-B000168-3_57_F-1-1_R2.mus.Aligned.out.sorted.bam\";\n+\n+    @DataProvider(name = \"successfulParameters\")\n+    Object[][] successfulParameters() {", "originalCommit": "6da3cb5ee0e544b1859f4e61a0a4407884b01462", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE5MTc4Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r434191787", "bodyText": "This is dangerous.  It's a clever idea, but OutOfMemory error isn't predictable.  It's very possible that you start doing this operation in this thread and somewhere else we get an OutOfMemoryError.  In general it's good advice to never catch Error.  They indicate problems which you are not expected to be able to recover from.", "author": "lbergelson", "createdAt": "2020-06-02T21:41:47Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/Utils.java", "diffHunk": "@@ -565,7 +553,32 @@ public static String calculatePathMD5(final Path path) throws IOException{\n         if (!Files.isRegularFile(path)) {\n             throw new IOException(\"File '\" + fname + \"' exists but is not a regular file\");\n         }\n-        return Utils.calcMD5(Files.readAllBytes(path));\n+        try {\n+            return Utils.calcMD5(Files.readAllBytes(path));\n+        } catch (final OutOfMemoryError e) {", "originalCommit": "a833ed2507d3695e384a18442a5584463f977e6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE5MjQ3Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r434192477", "bodyText": "I somehow missed this in my last review.  Sorry about that!", "author": "lbergelson", "createdAt": "2020-06-02T21:43:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE5MTc4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4ODc3NA==", "url": "https://github.com/broadinstitute/gatk/pull/6611#discussion_r434588774", "bodyText": "Changed to always use a buffer when hashing files.", "author": "andersleung", "createdAt": "2020-06-03T13:59:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE5MTc4Nw=="}], "type": "inlineReview"}, {"oid": "9898151d10edddd209efc25fa790c62c934f5e91", "url": "https://github.com/broadinstitute/gatk/commit/9898151d10edddd209efc25fa790c62c934f5e91", "message": "Add basic HtsgetReader tool to gatk", "committedDate": "2020-06-05T15:30:25Z", "type": "commit"}, {"oid": "9898151d10edddd209efc25fa790c62c934f5e91", "url": "https://github.com/broadinstitute/gatk/commit/9898151d10edddd209efc25fa790c62c934f5e91", "message": "Add basic HtsgetReader tool to gatk", "committedDate": "2020-06-05T15:30:25Z", "type": "forcePushed"}]}