{"pr_number": 6812, "pr_title": "Tool for arrays QC metrics calculations", "pr_createdAt": "2020-09-12T00:22:36Z", "pr_url": "https://github.com/broadinstitute/gatk/pull/6812", "timeline": [{"oid": "9c87231eabde9e128303da0a769b079f37e9cf30", "url": "https://github.com/broadinstitute/gatk/commit/9c87231eabde9e128303da0a769b079f37e9cf30", "message": "Tool for arrays qc metrics calculations", "committedDate": "2020-09-12T00:19:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkzOTQwMw==", "url": "https://github.com/broadinstitute/gatk/pull/6812#discussion_r488939403", "bodyText": "Turns out that it's MUCH faster to use the storage API here (like 10-20 times) since you're pulling out the entire table.  You can see what I do for this in the ArrayExtractCohort for probe_info", "author": "kcibul", "createdAt": "2020-09-15T20:01:13Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/variantdb/arrays/ArrayCalculateMetrics.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package org.broadinstitute.hellbender.tools.variantdb.arrays;\n+\n+import com.google.cloud.bigquery.FieldValueList;\n+import com.google.cloud.bigquery.TableResult;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ShortVariantDiscoveryProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.variantdb.IngestConstants;\n+import org.broadinstitute.hellbender.tools.walkers.annotator.ExcessHet;\n+import org.broadinstitute.hellbender.utils.GenotypeCounts;\n+import org.broadinstitute.hellbender.utils.bigquery.BigQueryUtils;\n+import org.broadinstitute.hellbender.utils.tsv.SimpleXSVWriter;\n+\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+\n+@CommandLineProgramProperties(\n+        summary = \"(\\\"CalculateMetrics\\\") - Calculates HWE and Call rate per site.\",\n+        oneLineSummary = \"Tool to calculate metrics from big query and upload results\",\n+        programGroup = ShortVariantDiscoveryProgramGroup.class\n+)\n+@DocumentedFeature\n+public class ArrayCalculateMetrics extends GATKTool {\n+    @Argument(\n+            fullName = \"genotype-counts-table\",\n+            doc = \"Fully qualified name of the table where the genotype counts already exists\"\n+    )\n+    private String genotypeCountsTable = null;\n+\n+    @Argument(\n+            fullName = \"output\",\n+            doc = \"TSV file that will be output with metrics per probe_id\"\n+    )\n+    private GATKPath output = null;\n+\n+    private SimpleXSVWriter metricsTsvWriter = null;\n+\n+    public enum HeaderFieldEnum {\n+        probe_id,\n+        hwe_pval,\n+        call_rate,\n+        invariant\n+    }\n+\n+    @Override\n+    protected void onStartup() {\n+        super.onStartup();\n+\n+        try {\n+            metricsTsvWriter = new SimpleXSVWriter(output.toPath(), IngestConstants.SEPARATOR);\n+        } catch (IOException e) {\n+            throw new UserException(\"Can't write to output file\" + e);\n+        }\n+        metricsTsvWriter.setHeaderLine(Arrays.stream(HeaderFieldEnum.values()).map(String::valueOf).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    // maybe think about creating a BigQuery Row walker?\n+    public void traverse() {\n+        progressMeter.setRecordsBetweenTimeChecks(1000L);\n+\n+        final String genotypeCountQueryString =\n+                \"SELECT * FROM `\" + genotypeCountsTable + \"`\";\n+\n+        //Execute Query\n+        final TableResult result = BigQueryUtils.executeQuery(genotypeCountQueryString);", "originalCommit": "9c87231eabde9e128303da0a769b079f37e9cf30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4NTM1MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6812#discussion_r489085351", "bodyText": "Do you want to format these to any kind of fixed precision?  I know some of the GATK tools go to 3 decimal places.  Same fo all the doubles", "author": "kcibul", "createdAt": "2020-09-16T00:06:54Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/variantdb/arrays/ArrayCalculateMetrics.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package org.broadinstitute.hellbender.tools.variantdb.arrays;\n+\n+import com.google.cloud.bigquery.FieldValueList;\n+import com.google.cloud.bigquery.TableResult;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ShortVariantDiscoveryProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.variantdb.IngestConstants;\n+import org.broadinstitute.hellbender.tools.walkers.annotator.ExcessHet;\n+import org.broadinstitute.hellbender.utils.GenotypeCounts;\n+import org.broadinstitute.hellbender.utils.bigquery.BigQueryUtils;\n+import org.broadinstitute.hellbender.utils.tsv.SimpleXSVWriter;\n+\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+\n+@CommandLineProgramProperties(\n+        summary = \"(\\\"CalculateMetrics\\\") - Calculates HWE and Call rate per site.\",\n+        oneLineSummary = \"Tool to calculate metrics from big query and upload results\",\n+        programGroup = ShortVariantDiscoveryProgramGroup.class\n+)\n+@DocumentedFeature\n+public class ArrayCalculateMetrics extends GATKTool {\n+    @Argument(\n+            fullName = \"genotype-counts-table\",\n+            doc = \"Fully qualified name of the table where the genotype counts already exists\"\n+    )\n+    private String genotypeCountsTable = null;\n+\n+    @Argument(\n+            fullName = \"output\",\n+            doc = \"TSV file that will be output with metrics per probe_id\"\n+    )\n+    private GATKPath output = null;\n+\n+    private SimpleXSVWriter metricsTsvWriter = null;\n+\n+    public enum HeaderFieldEnum {\n+        probe_id,\n+        hwe_pval,\n+        call_rate,\n+        invariant\n+    }\n+\n+    @Override\n+    protected void onStartup() {\n+        super.onStartup();\n+\n+        try {\n+            metricsTsvWriter = new SimpleXSVWriter(output.toPath(), IngestConstants.SEPARATOR);\n+        } catch (IOException e) {\n+            throw new UserException(\"Can't write to output file\" + e);\n+        }\n+        metricsTsvWriter.setHeaderLine(Arrays.stream(HeaderFieldEnum.values()).map(String::valueOf).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    // maybe think about creating a BigQuery Row walker?\n+    public void traverse() {\n+        progressMeter.setRecordsBetweenTimeChecks(1000L);\n+\n+        final String genotypeCountQueryString =\n+                \"SELECT * FROM `\" + genotypeCountsTable + \"`\";\n+\n+        //Execute Query\n+        final TableResult result = BigQueryUtils.executeQuery(genotypeCountQueryString);\n+\n+        for (final FieldValueList row : result.iterateAll()) {\n+            List<String> thisRow = new ArrayList<>();\n+            Long probeId = row.get(0).getLongValue();\n+            thisRow.add(String.valueOf(probeId));\n+\n+            GenotypeCounts genotypeCounts = new GenotypeCounts(row.get(1).getDoubleValue(), row.get(2).getDoubleValue(), row.get(3).getDoubleValue());\n+            long noCalls = row.get(4).getLongValue();\n+            Integer sampleCount = (int) genotypeCounts.getRefs() + (int) genotypeCounts.getHets() + (int) genotypeCounts.getHoms() + (int) noCalls;\n+            Double excessHetPval = ExcessHet.calculateEH(genotypeCounts, sampleCount).getRight();\n+            thisRow.add(String.valueOf(excessHetPval));\n+\n+            Double callRate = 1.0 - ((double) noCalls / sampleCount);\n+            thisRow.add(String.valueOf(callRate));", "originalCommit": "9c87231eabde9e128303da0a769b079f37e9cf30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4NTQzOA==", "url": "https://github.com/broadinstitute/gatk/pull/6812#discussion_r489085438", "bodyText": "Double or double?", "author": "kcibul", "createdAt": "2020-09-16T00:07:11Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/variantdb/arrays/ArrayCalculateMetrics.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package org.broadinstitute.hellbender.tools.variantdb.arrays;\n+\n+import com.google.cloud.bigquery.FieldValueList;\n+import com.google.cloud.bigquery.TableResult;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.programgroups.ShortVariantDiscoveryProgramGroup;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.variantdb.IngestConstants;\n+import org.broadinstitute.hellbender.tools.walkers.annotator.ExcessHet;\n+import org.broadinstitute.hellbender.utils.GenotypeCounts;\n+import org.broadinstitute.hellbender.utils.bigquery.BigQueryUtils;\n+import org.broadinstitute.hellbender.utils.tsv.SimpleXSVWriter;\n+\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+\n+@CommandLineProgramProperties(\n+        summary = \"(\\\"CalculateMetrics\\\") - Calculates HWE and Call rate per site.\",\n+        oneLineSummary = \"Tool to calculate metrics from big query and upload results\",\n+        programGroup = ShortVariantDiscoveryProgramGroup.class\n+)\n+@DocumentedFeature\n+public class ArrayCalculateMetrics extends GATKTool {\n+    @Argument(\n+            fullName = \"genotype-counts-table\",\n+            doc = \"Fully qualified name of the table where the genotype counts already exists\"\n+    )\n+    private String genotypeCountsTable = null;\n+\n+    @Argument(\n+            fullName = \"output\",\n+            doc = \"TSV file that will be output with metrics per probe_id\"\n+    )\n+    private GATKPath output = null;\n+\n+    private SimpleXSVWriter metricsTsvWriter = null;\n+\n+    public enum HeaderFieldEnum {\n+        probe_id,\n+        hwe_pval,\n+        call_rate,\n+        invariant\n+    }\n+\n+    @Override\n+    protected void onStartup() {\n+        super.onStartup();\n+\n+        try {\n+            metricsTsvWriter = new SimpleXSVWriter(output.toPath(), IngestConstants.SEPARATOR);\n+        } catch (IOException e) {\n+            throw new UserException(\"Can't write to output file\" + e);\n+        }\n+        metricsTsvWriter.setHeaderLine(Arrays.stream(HeaderFieldEnum.values()).map(String::valueOf).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    // maybe think about creating a BigQuery Row walker?\n+    public void traverse() {\n+        progressMeter.setRecordsBetweenTimeChecks(1000L);\n+\n+        final String genotypeCountQueryString =\n+                \"SELECT * FROM `\" + genotypeCountsTable + \"`\";\n+\n+        //Execute Query\n+        final TableResult result = BigQueryUtils.executeQuery(genotypeCountQueryString);\n+\n+        for (final FieldValueList row : result.iterateAll()) {\n+            List<String> thisRow = new ArrayList<>();\n+            Long probeId = row.get(0).getLongValue();\n+            thisRow.add(String.valueOf(probeId));\n+\n+            GenotypeCounts genotypeCounts = new GenotypeCounts(row.get(1).getDoubleValue(), row.get(2).getDoubleValue(), row.get(3).getDoubleValue());\n+            long noCalls = row.get(4).getLongValue();\n+            Integer sampleCount = (int) genotypeCounts.getRefs() + (int) genotypeCounts.getHets() + (int) genotypeCounts.getHoms() + (int) noCalls;\n+            Double excessHetPval = ExcessHet.calculateEH(genotypeCounts, sampleCount).getRight();\n+            thisRow.add(String.valueOf(excessHetPval));\n+\n+            Double callRate = 1.0 - ((double) noCalls / sampleCount);", "originalCommit": "9c87231eabde9e128303da0a769b079f37e9cf30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4NTcwOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6812#discussion_r489085709", "bodyText": "same for other types.   If they can be null, use the object (Double) and be sure to handle the null case when you use them.  if not use the primitive (double) and you don't have to worry!", "author": "kcibul", "createdAt": "2020-09-16T00:08:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4NTQzOA=="}], "type": "inlineReview"}, {"oid": "038aca14434106d1069967813033009731a4155f", "url": "https://github.com/broadinstitute/gatk/commit/038aca14434106d1069967813033009731a4155f", "message": "addressing comments", "committedDate": "2020-09-16T18:18:51Z", "type": "commit"}]}