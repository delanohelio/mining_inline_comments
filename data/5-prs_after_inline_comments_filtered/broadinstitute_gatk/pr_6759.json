{"pr_number": 6759, "pr_title": "ah - big query utils and local sort", "pr_createdAt": "2020-08-19T18:43:31Z", "pr_url": "https://github.com/broadinstitute/gatk/pull/6759", "timeline": [{"oid": "272f582b6fd195dc7c27fed29e48e61ea867f929", "url": "https://github.com/broadinstitute/gatk/commit/272f582b6fd195dc7c27fed29e48e61ea867f929", "message": "add big query utils and update dependencies", "committedDate": "2020-08-19T18:35:30Z", "type": "commit"}, {"oid": "42823f240fb461e67f9188331aaec64a17484630", "url": "https://github.com/broadinstitute/gatk/commit/42823f240fb461e67f9188331aaec64a17484630", "message": "update math import", "committedDate": "2020-08-19T20:03:36Z", "type": "commit"}, {"oid": "82e4cf10713b4a4be419496491e08f4329d79918", "url": "https://github.com/broadinstitute/gatk/commit/82e4cf10713b4a4be419496491e08f4329d79918", "message": "remove commented out todo", "committedDate": "2020-08-19T21:13:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM1NjQyMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r481356421", "bodyText": "\"on the default instance of {@link BigQuery} as created by {@link #getBigQueryEndPoint()}.\"\nshould be:\n\"on the provided BigQuery instance\"\nfor this overload", "author": "droazen", "createdAt": "2020-09-01T18:47:03Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/bigquery/BigQueryUtils.java", "diffHunk": "@@ -0,0 +1,449 @@\n+package org.broadinstitute.hellbender.utils.bigquery;\n+\n+import com.google.cloud.bigquery.*;\n+import com.google.cloud.bigquery.storage.v1beta1.*;\n+import com.google.common.base.Preconditions;\n+import org.apache.avro.generic.GenericData;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.io.BinaryDecoder;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.ivy.util.StringUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Utility class for dealing with BigQuery connections / tables / queries /etc.\n+ *\n+ * Created by jonn on 4/17/19.\n+ */\n+public class BigQueryUtils {\n+    private static final Logger logger = LogManager.getLogger(BigQueryUtils.class);\n+\n+    //==================================================================================================================\n+    // Static Methods:\n+\n+    /**\n+     * @return A {@link BigQuery} object that can be used to interact with a BigQuery data set.\n+     */\n+    public static BigQuery getBigQueryEndPoint() {\n+        return BigQueryOptions.getDefaultInstance().getService();\n+    }\n+\n+    /**\n+     * Executes the given {@code queryString} on the default instance of {@link BigQuery} as created by {@link #getBigQueryEndPoint()}.\n+     * Will block until results are returned.\n+     * For more information on querying BigQuery tables, see: https://cloud.google.com/bigquery/sql-reference/\n+     * @param queryString The {@link BigQuery} query string to execute.  Must use standard SQL syntax.  Must contain the project ID, data set, and table name in the `FROM` clause for the table from which to retrieve data.\n+     * @return A {@link TableResult} object containing the results of the query executed.\n+     */\n+    public static TableResult executeQuery(final String queryString) {\n+        return executeQuery(getBigQueryEndPoint(), queryString, false);\n+    }\n+\n+    /**\n+     * Executes the given {@code queryString} on the default instance of {@link BigQuery} as created by {@link #getBigQueryEndPoint()}.\n+     * Will block until results are returned.\n+     * For more information on querying BigQuery tables, see: https://cloud.google.com/bigquery/sql-reference/\n+     * @param queryString The {@link BigQuery} query string to execute.  Must use standard SQL syntax.  Must contain the project ID, data set, and table name in the `FROM` clause for the table from which to retrieve data.\n+     * @param runQueryInBatchMode If true, run the query in batch mode, which is lower priority but has no limit on the number of concurrent queries\n+     * @return A {@link TableResult} object containing the results of the query executed.\n+     */\n+    public static TableResult executeQuery(final String queryString, final boolean runQueryInBatchMode) {\n+        return executeQuery(getBigQueryEndPoint(), queryString, runQueryInBatchMode);\n+    }\n+\n+    /**\n+     * Executes the given {@code queryString} on the default instance of {@link BigQuery} as created by {@link #getBigQueryEndPoint()}.", "originalCommit": "82e4cf10713b4a4be419496491e08f4329d79918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk4OTAzMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r492989031", "bodyText": "done", "author": "meganshand", "createdAt": "2020-09-22T19:42:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM1NjQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM1NzEwOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r481357109", "bodyText": "\"on the default instance of {@link BigQuery} as created by {@link #getBigQueryEndPoint()}.\"\nshould be:\n\"on the provided BigQuery instance\"\nfor this overload", "author": "droazen", "createdAt": "2020-09-01T18:48:20Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/bigquery/BigQueryUtils.java", "diffHunk": "@@ -0,0 +1,449 @@\n+package org.broadinstitute.hellbender.utils.bigquery;\n+\n+import com.google.cloud.bigquery.*;\n+import com.google.cloud.bigquery.storage.v1beta1.*;\n+import com.google.common.base.Preconditions;\n+import org.apache.avro.generic.GenericData;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.io.BinaryDecoder;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.ivy.util.StringUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Utility class for dealing with BigQuery connections / tables / queries /etc.\n+ *\n+ * Created by jonn on 4/17/19.\n+ */\n+public class BigQueryUtils {\n+    private static final Logger logger = LogManager.getLogger(BigQueryUtils.class);\n+\n+    //==================================================================================================================\n+    // Static Methods:\n+\n+    /**\n+     * @return A {@link BigQuery} object that can be used to interact with a BigQuery data set.\n+     */\n+    public static BigQuery getBigQueryEndPoint() {\n+        return BigQueryOptions.getDefaultInstance().getService();\n+    }\n+\n+    /**\n+     * Executes the given {@code queryString} on the default instance of {@link BigQuery} as created by {@link #getBigQueryEndPoint()}.\n+     * Will block until results are returned.\n+     * For more information on querying BigQuery tables, see: https://cloud.google.com/bigquery/sql-reference/\n+     * @param queryString The {@link BigQuery} query string to execute.  Must use standard SQL syntax.  Must contain the project ID, data set, and table name in the `FROM` clause for the table from which to retrieve data.\n+     * @return A {@link TableResult} object containing the results of the query executed.\n+     */\n+    public static TableResult executeQuery(final String queryString) {\n+        return executeQuery(getBigQueryEndPoint(), queryString, false);\n+    }\n+\n+    /**\n+     * Executes the given {@code queryString} on the default instance of {@link BigQuery} as created by {@link #getBigQueryEndPoint()}.\n+     * Will block until results are returned.\n+     * For more information on querying BigQuery tables, see: https://cloud.google.com/bigquery/sql-reference/\n+     * @param queryString The {@link BigQuery} query string to execute.  Must use standard SQL syntax.  Must contain the project ID, data set, and table name in the `FROM` clause for the table from which to retrieve data.\n+     * @param runQueryInBatchMode If true, run the query in batch mode, which is lower priority but has no limit on the number of concurrent queries\n+     * @return A {@link TableResult} object containing the results of the query executed.\n+     */\n+    public static TableResult executeQuery(final String queryString, final boolean runQueryInBatchMode) {\n+        return executeQuery(getBigQueryEndPoint(), queryString, runQueryInBatchMode);\n+    }\n+\n+    /**\n+     * Executes the given {@code queryString} on the default instance of {@link BigQuery} as created by {@link #getBigQueryEndPoint()}.\n+     * Will block until results are returned.\n+     * For more information on querying BigQuery tables, see: https://cloud.google.com/bigquery/sql-reference/\n+     * @param bigQuery The {@link BigQuery} instance against which to execute the given {@code queryString}.\n+     * @param queryString The {@link BigQuery} query string to execute.  Must use standard SQL syntax.  Must contain the project ID, data set, and table name in the `FROM` clause for the table from which to retrieve data.\n+     * @param runQueryInBatchMode If true, run the query in batch mode, which is lower priority but has no limit on the number of concurrent queries\n+     * @return A {@link TableResult} object containing the results of the query executed.\n+     */\n+    public static TableResult executeQuery(final BigQuery bigQuery, final String queryString, final boolean runQueryInBatchMode) {\n+\n+        // Create a query configuration we can run based on our query string:\n+        final QueryJobConfiguration queryConfig =\n+                QueryJobConfiguration.newBuilder( queryString )\n+                        .setUseLegacySql(false)\n+                        .setPriority(runQueryInBatchMode ? QueryJobConfiguration.Priority.BATCH : QueryJobConfiguration.Priority.INTERACTIVE)\n+                        .build();\n+\n+        logger.info(\"Executing Query: \\n\\n\" + queryString);\n+        final TableResult result = submitQueryAndWaitForResults( bigQuery, queryConfig );\n+        logger.info(\"Query returned \" + result.getTotalRows() + \" results.\");\n+        return result;\n+    }\n+\n+    /**\n+     * Executes the given {@code queryString} on the default instance of {@link BigQuery} as created by {@link #getBigQueryEndPoint()}.", "originalCommit": "82e4cf10713b4a4be419496491e08f4329d79918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk4OTMwOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r492989309", "bodyText": "done", "author": "meganshand", "createdAt": "2020-09-22T19:43:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM1NzEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2NzI2Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r481367262", "bodyText": "Keep fractions of a MB, and reword slightly:\n            logger.info(String.format(\"%.2f MB actually scanned\", bytesProcessed / 1000000.0));", "author": "droazen", "createdAt": "2020-09-01T19:02:03Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/bigquery/BigQueryUtils.java", "diffHunk": "@@ -0,0 +1,449 @@\n+package org.broadinstitute.hellbender.utils.bigquery;\n+\n+import com.google.cloud.bigquery.*;\n+import com.google.cloud.bigquery.storage.v1beta1.*;\n+import com.google.common.base.Preconditions;\n+import org.apache.avro.generic.GenericData;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.io.BinaryDecoder;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.ivy.util.StringUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Utility class for dealing with BigQuery connections / tables / queries /etc.\n+ *\n+ * Created by jonn on 4/17/19.\n+ */\n+public class BigQueryUtils {\n+    private static final Logger logger = LogManager.getLogger(BigQueryUtils.class);\n+\n+    //==================================================================================================================\n+    // Static Methods:\n+\n+    /**\n+     * @return A {@link BigQuery} object that can be used to interact with a BigQuery data set.\n+     */\n+    public static BigQuery getBigQueryEndPoint() {\n+        return BigQueryOptions.getDefaultInstance().getService();\n+    }\n+\n+    /**\n+     * Executes the given {@code queryString} on the default instance of {@link BigQuery} as created by {@link #getBigQueryEndPoint()}.\n+     * Will block until results are returned.\n+     * For more information on querying BigQuery tables, see: https://cloud.google.com/bigquery/sql-reference/\n+     * @param queryString The {@link BigQuery} query string to execute.  Must use standard SQL syntax.  Must contain the project ID, data set, and table name in the `FROM` clause for the table from which to retrieve data.\n+     * @return A {@link TableResult} object containing the results of the query executed.\n+     */\n+    public static TableResult executeQuery(final String queryString) {\n+        return executeQuery(getBigQueryEndPoint(), queryString, false);\n+    }\n+\n+    /**\n+     * Executes the given {@code queryString} on the default instance of {@link BigQuery} as created by {@link #getBigQueryEndPoint()}.\n+     * Will block until results are returned.\n+     * For more information on querying BigQuery tables, see: https://cloud.google.com/bigquery/sql-reference/\n+     * @param queryString The {@link BigQuery} query string to execute.  Must use standard SQL syntax.  Must contain the project ID, data set, and table name in the `FROM` clause for the table from which to retrieve data.\n+     * @param runQueryInBatchMode If true, run the query in batch mode, which is lower priority but has no limit on the number of concurrent queries\n+     * @return A {@link TableResult} object containing the results of the query executed.\n+     */\n+    public static TableResult executeQuery(final String queryString, final boolean runQueryInBatchMode) {\n+        return executeQuery(getBigQueryEndPoint(), queryString, runQueryInBatchMode);\n+    }\n+\n+    /**\n+     * Executes the given {@code queryString} on the default instance of {@link BigQuery} as created by {@link #getBigQueryEndPoint()}.\n+     * Will block until results are returned.\n+     * For more information on querying BigQuery tables, see: https://cloud.google.com/bigquery/sql-reference/\n+     * @param bigQuery The {@link BigQuery} instance against which to execute the given {@code queryString}.\n+     * @param queryString The {@link BigQuery} query string to execute.  Must use standard SQL syntax.  Must contain the project ID, data set, and table name in the `FROM` clause for the table from which to retrieve data.\n+     * @param runQueryInBatchMode If true, run the query in batch mode, which is lower priority but has no limit on the number of concurrent queries\n+     * @return A {@link TableResult} object containing the results of the query executed.\n+     */\n+    public static TableResult executeQuery(final BigQuery bigQuery, final String queryString, final boolean runQueryInBatchMode) {\n+\n+        // Create a query configuration we can run based on our query string:\n+        final QueryJobConfiguration queryConfig =\n+                QueryJobConfiguration.newBuilder( queryString )\n+                        .setUseLegacySql(false)\n+                        .setPriority(runQueryInBatchMode ? QueryJobConfiguration.Priority.BATCH : QueryJobConfiguration.Priority.INTERACTIVE)\n+                        .build();\n+\n+        logger.info(\"Executing Query: \\n\\n\" + queryString);\n+        final TableResult result = submitQueryAndWaitForResults( bigQuery, queryConfig );\n+        logger.info(\"Query returned \" + result.getTotalRows() + \" results.\");\n+        return result;\n+    }\n+\n+    /**\n+     * Executes the given {@code queryString} on the default instance of {@link BigQuery} as created by {@link #getBigQueryEndPoint()}.\n+     * Will block until results are returned.\n+     * For more information on querying BigQuery tables, see: https://cloud.google.com/bigquery/sql-reference/\n+     * @param bigQuery The {@link BigQuery} instance against which to execute the given {@code queryString}.  Must contain the table name in the `FROM` clause for the table from which to retrieve data.\n+     * @param projectID The BigQuery {@code project ID} containing the {@code dataSet} and table from which to query data.\n+     * @param dataSet The BigQuery {@code dataSet} containing the table from which to query data.\n+     * @param queryString The {@link BigQuery} query string to execute.  Must use standard SQL syntax.  Must contain the project ID, data set, and table ID in the `FROM` clause for the table from which to retrieve data.\n+     * @return A {@link TableResult} object containing the results of the query executed.\n+     */\n+    public static TableResult executeQuery(final BigQuery bigQuery,\n+                                           final String projectID,\n+                                           final String dataSet,\n+                                           final String queryString) {\n+\n+        // Create a query configuration we can run based on our query string:\n+        final QueryJobConfiguration queryConfig =\n+                QueryJobConfiguration.newBuilder( queryString )\n+                        .setUseLegacySql(false)\n+                        .setDefaultDataset(DatasetId.of(projectID, dataSet))\n+                        .build();\n+\n+        return submitQueryAndWaitForResults( bigQuery, queryConfig );\n+    }\n+\n+    /**\n+     * Creates a {@link String} containing the given results in a pretty ascii-art table.\n+     * @param result A {@link TableResult} object containing the results of a query that generated some data.\n+     * @return A {@link String} containing the contents of the given query result pretty-printed in an ascii-art table.\n+     */\n+    public static String getResultDataPrettyString(final TableResult result){\n+        final Schema schema = result.getSchema();\n+\n+        final List<Integer> columnWidths = calculateColumnWidths( result );\n+        final boolean rowsAllPrimitive =\n+                StreamSupport.stream(result.iterateAll().spliterator(), false)\n+                        .flatMap( row -> row.stream().map(v -> v.getAttribute() == FieldValue.Attribute.PRIMITIVE) )\n+                        .allMatch( b -> b );\n+\n+        // Create a separator string for the header and boarders:\n+        final String headerFooter = \"+\" + columnWidths.stream().map(\n+                l -> StringUtils.repeat(\"=\", l+2) + \"+\"\n+        ).collect(Collectors.joining(\"\"));\n+\n+        // Create a Row Separator:\n+        final String rowSeparator = headerFooter.replace('=', '-');\n+\n+        // Create a string builder to keep the pretty table:\n+        final StringBuilder sb = new StringBuilder();\n+\n+        // Now we can write our schema header and rows:\n+        addHeaderToStringBuilder(schema, columnWidths, headerFooter, sb);\n+\n+        // Write our data to the string builder:\n+        for ( final FieldValueList row : result.iterateAll() ) {\n+\n+            // If the row fields are all simple, then we can do the simple thing:\n+            if ( rowsAllPrimitive ) {\n+                addPrimitiveRowToStringBuilder(row, columnWidths, sb);\n+            }\n+            else {\n+                addComplexRowToStringBuilder(row, schema, columnWidths, sb);\n+                sb.append(rowSeparator);\n+            }\n+            sb.append(\"\\n\");\n+        }\n+\n+        sb.append( headerFooter );\n+        sb.append(\"\\n\");\n+\n+        return sb.toString();\n+    }\n+\n+    private static void addHeaderToStringBuilder(final Schema schema, final List<Integer> columnWidths, final String headerFooter, final StringBuilder sb) {\n+        sb.append( headerFooter );\n+        sb.append(\"\\n\");\n+        sb.append(\"|\");\n+        sb.append(\n+                IntStream.range(0, columnWidths.size()).boxed().map(\n+                        i -> String.format(\" %-\"+ columnWidths.get(i) +\"s |\", schema.getFields().get(i).getName())\n+                ).collect(Collectors.joining()) );\n+        sb.append(\"\\n\");\n+        sb.append( headerFooter );\n+        sb.append(\"\\n\");\n+    }\n+\n+    private static void addComplexRowToStringBuilder(final FieldValueList row, final Schema schema, final List<Integer> columnWidths, final StringBuilder sb) {\n+\n+        // TODO: Clean this up... Probably make a getStringValue(FIELD) method to use here, addPrimitiveRowToStringBuilder, and calculateColumnWidths\n+\n+        // For fields that have multiple values, we need to do something special.\n+        // In fact, we need to go through each value of each row and track how many fields it has.\n+        int maxNumValuesInRow = 1;\n+        for ( int i = 0; i < row.size(); ++i ) {\n+            final FieldValue value = row.get(schema.getFields().get(i).getName());\n+            if ( !value.isNull() && (value.getAttribute() != FieldValue.Attribute.PRIMITIVE) ) {\n+                if (maxNumValuesInRow <= value.getRecordValue().size()) {\n+                    maxNumValuesInRow = value.getRecordValue().size();\n+                }\n+            }\n+        }\n+\n+        for ( int currentFieldNum = 0; currentFieldNum < maxNumValuesInRow ; ++currentFieldNum ) {\n+            sb.append(\"|\");\n+            for ( int i = 0; i < row.size(); ++i ) {\n+                final FieldValue value = row.get(i);\n+                if ( value.isNull() ) {\n+                    sb.append(getEmptyColumnString(columnWidths, i));\n+                }\n+                else if (value.getAttribute() == FieldValue.Attribute.PRIMITIVE ) {\n+                    if ( currentFieldNum == 0 ) {\n+                        sb.append( String.format(\" %-\" + columnWidths.get(i) + \"s |\", value.getStringValue()) );\n+                    }\n+                    else {\n+                        sb.append(getEmptyColumnString(columnWidths, i));\n+                    }\n+                }\n+                else {\n+                    if ( value.getRepeatedValue().size() == 0 ) {\n+                        sb.append(getEmptyColumnString(columnWidths, i));\n+                    }\n+                    else if ( currentFieldNum < value.getRepeatedValue().size() ) {\n+                        if ( value.getRepeatedValue().get(currentFieldNum).getAttribute() == FieldValue.Attribute.PRIMITIVE ) {\n+                            sb.append(String.format(\" %-\" + columnWidths.get(i) + \"s |\",\n+                                    value.getRepeatedValue().get(currentFieldNum).getStringValue())\n+                            );\n+                        }\n+                        else {\n+                            // This is kind of gross, but it seems to be the only way to get a particular\n+                            // value of a field that is in an array:\n+                            sb.append(String.format(\" %-\" + columnWidths.get(i) + \"s |\",\n+                                    value.getRepeatedValue().get(currentFieldNum).getRecordValue().get(0).getStringValue())\n+                            );\n+                        }\n+                    }\n+                    else {\n+                        sb.append(getEmptyColumnString(columnWidths, i));\n+                    }\n+                }\n+            }\n+            sb.append(\"\\n\");\n+        }\n+    }\n+\n+    private static String getEmptyColumnString(final List<Integer> columnWidths, final int i) {\n+        return String.format(\" %-\" + columnWidths.get(i) + \"s |\", \"\");\n+    }\n+\n+    private static void addPrimitiveRowToStringBuilder(final FieldValueList row, final List<Integer> columnWidths, final StringBuilder sb) {\n+        sb.append(\"|\");\n+        sb.append(IntStream.range(0, row.size()).boxed().map(\n+                i -> String.format(\" %-\" + columnWidths.get(i) + \"s |\", row.get(i).getStringValue())\n+        ).collect(Collectors.joining()));\n+    }\n+\n+    /**\n+     * Creates a {@link String} containing the given results in a pretty ascii-art table.\n+     * @param result A {@link TableResult} object containing the results of a query that generated some data.\n+     * @param theLogger A {@link Logger} object with which to log the results contained in {@code result}.\n+     */\n+    public static void logResultDataPretty( final TableResult result, final Logger theLogger ){\n+        for ( final String line : getResultDataPrettyString(result).split(\"\\n\") ) {\n+            theLogger.info( line );\n+        }\n+    }\n+\n+    //==================================================================================================================\n+    // Helper Methods:\n+\n+    private static List<Integer> calculateColumnWidths( final TableResult result ) {\n+        // Go through all rows and get the length of each column:\n+        final List<Integer> columnWidths = new ArrayList<>(result.getSchema().getFields().size());\n+\n+        // Start with schema names:\n+        for ( final Field field : result.getSchema().getFields() ) {\n+            columnWidths.add( field.getName().length() );\n+        }\n+\n+        // Check each row and each row's array values (if applicable):\n+        for ( final FieldValueList row : result.iterateAll() ) {\n+            for ( int i = 0; i < row.size() ; ++i ) {\n+                // Only get the row size if it's not null:\n+                if ( !row.get(i).isNull() ) {\n+                    if ( row.get(i).getAttribute() == FieldValue.Attribute.PRIMITIVE ) {\n+                        if ( columnWidths.get(i) < row.get(i).getStringValue().length() ) {\n+                            columnWidths.set(i, row.get(i).getStringValue().length());\n+                        }\n+                    }\n+                    else {\n+                        for ( int j = 0; j < row.get(i).getRepeatedValue().size(); ++j ) {\n+                            final String stringValue;\n+                            if ( row.get(i).getRepeatedValue().get(j).getAttribute() == FieldValue.Attribute.PRIMITIVE ) {\n+                                stringValue = row.get(i).getRepeatedValue().get(j).getStringValue();\n+                            }\n+                            else {\n+                                stringValue = row.get(i).getRepeatedValue().get(j).getRecordValue().get(0).getStringValue();\n+                            }\n+                            if ( columnWidths.get(i) < stringValue.length() ) {\n+                                columnWidths.set(i, stringValue.length());\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return columnWidths;\n+    }\n+\n+    /**\n+     * Executes the given {@code queryJobConfiguration} on the given {@code bigQuery} instance.\n+     * @param bigQuery The instance of {@link BigQuery} to use to connect to BigQuery.\n+     * @param queryJobConfiguration The {@link QueryJobConfiguration} object containing all required information to retrieve data from a BigQuery table.\n+     * @return A {@link TableResult} object containing the results of the query executed.\n+     */\n+    private static TableResult submitQueryAndWaitForResults( final BigQuery bigQuery,\n+                                                             final QueryJobConfiguration queryJobConfiguration ) {\n+        // Create a job ID so that we can safely retry:\n+        final JobId jobId = JobId.of(UUID.randomUUID().toString());\n+\n+        logger.info(\"Sending query to server...\");\n+        Job   queryJob       = bigQuery.create(JobInfo.newBuilder(queryJobConfiguration).setJobId(jobId).build());\n+\n+        // Wait for the query to complete.\n+        try {\n+            logger.info(\"Waiting for query to complete...\");\n+            queryJob = queryJob.waitFor();\n+        }\n+        catch (final InterruptedException ex) {\n+            throw new GATKException(\"Interrupted while waiting for query job to complete\", ex);\n+        }\n+\n+        // Check for errors:\n+        if (queryJob == null) {\n+            throw new GATKException(\"Query job no longer exists\");\n+        } else if (queryJob.getStatus().getError() != null) {\n+\n+            // Get all the errors we found and log them:\n+            for ( final BigQueryError bigQueryError : queryJob.getStatus().getExecutionErrors() ) {\n+                logger.error( \"Encountered BigQuery Execution Error: \" + bigQueryError.toString() );\n+            }\n+\n+            // Since we found an error, we should stop and alert the user:\n+            throw new GATKException(queryJob.getStatus().getError().toString());\n+        }\n+\n+        // Get the results.\n+        logger.info(\"Retrieving query results...\");\n+        final QueryResponse response = bigQuery.getQueryResults(jobId);\n+        final TableResult result;\n+        try {\n+            result = queryJob.getQueryResults();\n+\n+            long bytesProcessed = ((JobStatistics.QueryStatistics) queryJob.getStatistics()).getTotalBytesProcessed();\n+            logger.info(String.format(\"Actual %s MB scanned\", bytesProcessed/1000000));", "originalCommit": "82e4cf10713b4a4be419496491e08f4329d79918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk4OTUwNg==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r492989506", "bodyText": "done", "author": "meganshand", "createdAt": "2020-09-22T19:43:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2NzI2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2OTIyOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r481369229", "bodyText": "You include the StorageAPIAvroReader in this branch, and yet you commented out the BigQueryUtils methods that actually use it. Can you explain? As I'm sure you know, the Storage API provides much better performance than the regular API, so it seems useful to have these utilities here. Are you going to be using the Storage API in your subsequent PRs?", "author": "droazen", "createdAt": "2020-09-01T19:05:55Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/bigquery/BigQueryUtils.java", "diffHunk": "@@ -0,0 +1,449 @@\n+package org.broadinstitute.hellbender.utils.bigquery;\n+\n+import com.google.cloud.bigquery.*;\n+import com.google.cloud.bigquery.storage.v1beta1.*;\n+import com.google.common.base.Preconditions;\n+import org.apache.avro.generic.GenericData;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.io.BinaryDecoder;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.ivy.util.StringUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Utility class for dealing with BigQuery connections / tables / queries /etc.\n+ *\n+ * Created by jonn on 4/17/19.\n+ */\n+public class BigQueryUtils {\n+    private static final Logger logger = LogManager.getLogger(BigQueryUtils.class);\n+\n+    //==================================================================================================================\n+    // Static Methods:\n+\n+    /**\n+     * @return A {@link BigQuery} object that can be used to interact with a BigQuery data set.\n+     */\n+    public static BigQuery getBigQueryEndPoint() {\n+        return BigQueryOptions.getDefaultInstance().getService();\n+    }\n+\n+    /**\n+     * Executes the given {@code queryString} on the default instance of {@link BigQuery} as created by {@link #getBigQueryEndPoint()}.\n+     * Will block until results are returned.\n+     * For more information on querying BigQuery tables, see: https://cloud.google.com/bigquery/sql-reference/\n+     * @param queryString The {@link BigQuery} query string to execute.  Must use standard SQL syntax.  Must contain the project ID, data set, and table name in the `FROM` clause for the table from which to retrieve data.\n+     * @return A {@link TableResult} object containing the results of the query executed.\n+     */\n+    public static TableResult executeQuery(final String queryString) {\n+        return executeQuery(getBigQueryEndPoint(), queryString, false);\n+    }\n+\n+    /**\n+     * Executes the given {@code queryString} on the default instance of {@link BigQuery} as created by {@link #getBigQueryEndPoint()}.\n+     * Will block until results are returned.\n+     * For more information on querying BigQuery tables, see: https://cloud.google.com/bigquery/sql-reference/\n+     * @param queryString The {@link BigQuery} query string to execute.  Must use standard SQL syntax.  Must contain the project ID, data set, and table name in the `FROM` clause for the table from which to retrieve data.\n+     * @param runQueryInBatchMode If true, run the query in batch mode, which is lower priority but has no limit on the number of concurrent queries\n+     * @return A {@link TableResult} object containing the results of the query executed.\n+     */\n+    public static TableResult executeQuery(final String queryString, final boolean runQueryInBatchMode) {\n+        return executeQuery(getBigQueryEndPoint(), queryString, runQueryInBatchMode);\n+    }\n+\n+    /**\n+     * Executes the given {@code queryString} on the default instance of {@link BigQuery} as created by {@link #getBigQueryEndPoint()}.\n+     * Will block until results are returned.\n+     * For more information on querying BigQuery tables, see: https://cloud.google.com/bigquery/sql-reference/\n+     * @param bigQuery The {@link BigQuery} instance against which to execute the given {@code queryString}.\n+     * @param queryString The {@link BigQuery} query string to execute.  Must use standard SQL syntax.  Must contain the project ID, data set, and table name in the `FROM` clause for the table from which to retrieve data.\n+     * @param runQueryInBatchMode If true, run the query in batch mode, which is lower priority but has no limit on the number of concurrent queries\n+     * @return A {@link TableResult} object containing the results of the query executed.\n+     */\n+    public static TableResult executeQuery(final BigQuery bigQuery, final String queryString, final boolean runQueryInBatchMode) {\n+\n+        // Create a query configuration we can run based on our query string:\n+        final QueryJobConfiguration queryConfig =\n+                QueryJobConfiguration.newBuilder( queryString )\n+                        .setUseLegacySql(false)\n+                        .setPriority(runQueryInBatchMode ? QueryJobConfiguration.Priority.BATCH : QueryJobConfiguration.Priority.INTERACTIVE)\n+                        .build();\n+\n+        logger.info(\"Executing Query: \\n\\n\" + queryString);\n+        final TableResult result = submitQueryAndWaitForResults( bigQuery, queryConfig );\n+        logger.info(\"Query returned \" + result.getTotalRows() + \" results.\");\n+        return result;\n+    }\n+\n+    /**\n+     * Executes the given {@code queryString} on the default instance of {@link BigQuery} as created by {@link #getBigQueryEndPoint()}.\n+     * Will block until results are returned.\n+     * For more information on querying BigQuery tables, see: https://cloud.google.com/bigquery/sql-reference/\n+     * @param bigQuery The {@link BigQuery} instance against which to execute the given {@code queryString}.  Must contain the table name in the `FROM` clause for the table from which to retrieve data.\n+     * @param projectID The BigQuery {@code project ID} containing the {@code dataSet} and table from which to query data.\n+     * @param dataSet The BigQuery {@code dataSet} containing the table from which to query data.\n+     * @param queryString The {@link BigQuery} query string to execute.  Must use standard SQL syntax.  Must contain the project ID, data set, and table ID in the `FROM` clause for the table from which to retrieve data.\n+     * @return A {@link TableResult} object containing the results of the query executed.\n+     */\n+    public static TableResult executeQuery(final BigQuery bigQuery,\n+                                           final String projectID,\n+                                           final String dataSet,\n+                                           final String queryString) {\n+\n+        // Create a query configuration we can run based on our query string:\n+        final QueryJobConfiguration queryConfig =\n+                QueryJobConfiguration.newBuilder( queryString )\n+                        .setUseLegacySql(false)\n+                        .setDefaultDataset(DatasetId.of(projectID, dataSet))\n+                        .build();\n+\n+        return submitQueryAndWaitForResults( bigQuery, queryConfig );\n+    }\n+\n+    /**\n+     * Creates a {@link String} containing the given results in a pretty ascii-art table.\n+     * @param result A {@link TableResult} object containing the results of a query that generated some data.\n+     * @return A {@link String} containing the contents of the given query result pretty-printed in an ascii-art table.\n+     */\n+    public static String getResultDataPrettyString(final TableResult result){\n+        final Schema schema = result.getSchema();\n+\n+        final List<Integer> columnWidths = calculateColumnWidths( result );\n+        final boolean rowsAllPrimitive =\n+                StreamSupport.stream(result.iterateAll().spliterator(), false)\n+                        .flatMap( row -> row.stream().map(v -> v.getAttribute() == FieldValue.Attribute.PRIMITIVE) )\n+                        .allMatch( b -> b );\n+\n+        // Create a separator string for the header and boarders:\n+        final String headerFooter = \"+\" + columnWidths.stream().map(\n+                l -> StringUtils.repeat(\"=\", l+2) + \"+\"\n+        ).collect(Collectors.joining(\"\"));\n+\n+        // Create a Row Separator:\n+        final String rowSeparator = headerFooter.replace('=', '-');\n+\n+        // Create a string builder to keep the pretty table:\n+        final StringBuilder sb = new StringBuilder();\n+\n+        // Now we can write our schema header and rows:\n+        addHeaderToStringBuilder(schema, columnWidths, headerFooter, sb);\n+\n+        // Write our data to the string builder:\n+        for ( final FieldValueList row : result.iterateAll() ) {\n+\n+            // If the row fields are all simple, then we can do the simple thing:\n+            if ( rowsAllPrimitive ) {\n+                addPrimitiveRowToStringBuilder(row, columnWidths, sb);\n+            }\n+            else {\n+                addComplexRowToStringBuilder(row, schema, columnWidths, sb);\n+                sb.append(rowSeparator);\n+            }\n+            sb.append(\"\\n\");\n+        }\n+\n+        sb.append( headerFooter );\n+        sb.append(\"\\n\");\n+\n+        return sb.toString();\n+    }\n+\n+    private static void addHeaderToStringBuilder(final Schema schema, final List<Integer> columnWidths, final String headerFooter, final StringBuilder sb) {\n+        sb.append( headerFooter );\n+        sb.append(\"\\n\");\n+        sb.append(\"|\");\n+        sb.append(\n+                IntStream.range(0, columnWidths.size()).boxed().map(\n+                        i -> String.format(\" %-\"+ columnWidths.get(i) +\"s |\", schema.getFields().get(i).getName())\n+                ).collect(Collectors.joining()) );\n+        sb.append(\"\\n\");\n+        sb.append( headerFooter );\n+        sb.append(\"\\n\");\n+    }\n+\n+    private static void addComplexRowToStringBuilder(final FieldValueList row, final Schema schema, final List<Integer> columnWidths, final StringBuilder sb) {\n+\n+        // TODO: Clean this up... Probably make a getStringValue(FIELD) method to use here, addPrimitiveRowToStringBuilder, and calculateColumnWidths\n+\n+        // For fields that have multiple values, we need to do something special.\n+        // In fact, we need to go through each value of each row and track how many fields it has.\n+        int maxNumValuesInRow = 1;\n+        for ( int i = 0; i < row.size(); ++i ) {\n+            final FieldValue value = row.get(schema.getFields().get(i).getName());\n+            if ( !value.isNull() && (value.getAttribute() != FieldValue.Attribute.PRIMITIVE) ) {\n+                if (maxNumValuesInRow <= value.getRecordValue().size()) {\n+                    maxNumValuesInRow = value.getRecordValue().size();\n+                }\n+            }\n+        }\n+\n+        for ( int currentFieldNum = 0; currentFieldNum < maxNumValuesInRow ; ++currentFieldNum ) {\n+            sb.append(\"|\");\n+            for ( int i = 0; i < row.size(); ++i ) {\n+                final FieldValue value = row.get(i);\n+                if ( value.isNull() ) {\n+                    sb.append(getEmptyColumnString(columnWidths, i));\n+                }\n+                else if (value.getAttribute() == FieldValue.Attribute.PRIMITIVE ) {\n+                    if ( currentFieldNum == 0 ) {\n+                        sb.append( String.format(\" %-\" + columnWidths.get(i) + \"s |\", value.getStringValue()) );\n+                    }\n+                    else {\n+                        sb.append(getEmptyColumnString(columnWidths, i));\n+                    }\n+                }\n+                else {\n+                    if ( value.getRepeatedValue().size() == 0 ) {\n+                        sb.append(getEmptyColumnString(columnWidths, i));\n+                    }\n+                    else if ( currentFieldNum < value.getRepeatedValue().size() ) {\n+                        if ( value.getRepeatedValue().get(currentFieldNum).getAttribute() == FieldValue.Attribute.PRIMITIVE ) {\n+                            sb.append(String.format(\" %-\" + columnWidths.get(i) + \"s |\",\n+                                    value.getRepeatedValue().get(currentFieldNum).getStringValue())\n+                            );\n+                        }\n+                        else {\n+                            // This is kind of gross, but it seems to be the only way to get a particular\n+                            // value of a field that is in an array:\n+                            sb.append(String.format(\" %-\" + columnWidths.get(i) + \"s |\",\n+                                    value.getRepeatedValue().get(currentFieldNum).getRecordValue().get(0).getStringValue())\n+                            );\n+                        }\n+                    }\n+                    else {\n+                        sb.append(getEmptyColumnString(columnWidths, i));\n+                    }\n+                }\n+            }\n+            sb.append(\"\\n\");\n+        }\n+    }\n+\n+    private static String getEmptyColumnString(final List<Integer> columnWidths, final int i) {\n+        return String.format(\" %-\" + columnWidths.get(i) + \"s |\", \"\");\n+    }\n+\n+    private static void addPrimitiveRowToStringBuilder(final FieldValueList row, final List<Integer> columnWidths, final StringBuilder sb) {\n+        sb.append(\"|\");\n+        sb.append(IntStream.range(0, row.size()).boxed().map(\n+                i -> String.format(\" %-\" + columnWidths.get(i) + \"s |\", row.get(i).getStringValue())\n+        ).collect(Collectors.joining()));\n+    }\n+\n+    /**\n+     * Creates a {@link String} containing the given results in a pretty ascii-art table.\n+     * @param result A {@link TableResult} object containing the results of a query that generated some data.\n+     * @param theLogger A {@link Logger} object with which to log the results contained in {@code result}.\n+     */\n+    public static void logResultDataPretty( final TableResult result, final Logger theLogger ){\n+        for ( final String line : getResultDataPrettyString(result).split(\"\\n\") ) {\n+            theLogger.info( line );\n+        }\n+    }\n+\n+    //==================================================================================================================\n+    // Helper Methods:\n+\n+    private static List<Integer> calculateColumnWidths( final TableResult result ) {\n+        // Go through all rows and get the length of each column:\n+        final List<Integer> columnWidths = new ArrayList<>(result.getSchema().getFields().size());\n+\n+        // Start with schema names:\n+        for ( final Field field : result.getSchema().getFields() ) {\n+            columnWidths.add( field.getName().length() );\n+        }\n+\n+        // Check each row and each row's array values (if applicable):\n+        for ( final FieldValueList row : result.iterateAll() ) {\n+            for ( int i = 0; i < row.size() ; ++i ) {\n+                // Only get the row size if it's not null:\n+                if ( !row.get(i).isNull() ) {\n+                    if ( row.get(i).getAttribute() == FieldValue.Attribute.PRIMITIVE ) {\n+                        if ( columnWidths.get(i) < row.get(i).getStringValue().length() ) {\n+                            columnWidths.set(i, row.get(i).getStringValue().length());\n+                        }\n+                    }\n+                    else {\n+                        for ( int j = 0; j < row.get(i).getRepeatedValue().size(); ++j ) {\n+                            final String stringValue;\n+                            if ( row.get(i).getRepeatedValue().get(j).getAttribute() == FieldValue.Attribute.PRIMITIVE ) {\n+                                stringValue = row.get(i).getRepeatedValue().get(j).getStringValue();\n+                            }\n+                            else {\n+                                stringValue = row.get(i).getRepeatedValue().get(j).getRecordValue().get(0).getStringValue();\n+                            }\n+                            if ( columnWidths.get(i) < stringValue.length() ) {\n+                                columnWidths.set(i, stringValue.length());\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return columnWidths;\n+    }\n+\n+    /**\n+     * Executes the given {@code queryJobConfiguration} on the given {@code bigQuery} instance.\n+     * @param bigQuery The instance of {@link BigQuery} to use to connect to BigQuery.\n+     * @param queryJobConfiguration The {@link QueryJobConfiguration} object containing all required information to retrieve data from a BigQuery table.\n+     * @return A {@link TableResult} object containing the results of the query executed.\n+     */\n+    private static TableResult submitQueryAndWaitForResults( final BigQuery bigQuery,\n+                                                             final QueryJobConfiguration queryJobConfiguration ) {\n+        // Create a job ID so that we can safely retry:\n+        final JobId jobId = JobId.of(UUID.randomUUID().toString());\n+\n+        logger.info(\"Sending query to server...\");\n+        Job   queryJob       = bigQuery.create(JobInfo.newBuilder(queryJobConfiguration).setJobId(jobId).build());\n+\n+        // Wait for the query to complete.\n+        try {\n+            logger.info(\"Waiting for query to complete...\");\n+            queryJob = queryJob.waitFor();\n+        }\n+        catch (final InterruptedException ex) {\n+            throw new GATKException(\"Interrupted while waiting for query job to complete\", ex);\n+        }\n+\n+        // Check for errors:\n+        if (queryJob == null) {\n+            throw new GATKException(\"Query job no longer exists\");\n+        } else if (queryJob.getStatus().getError() != null) {\n+\n+            // Get all the errors we found and log them:\n+            for ( final BigQueryError bigQueryError : queryJob.getStatus().getExecutionErrors() ) {\n+                logger.error( \"Encountered BigQuery Execution Error: \" + bigQueryError.toString() );\n+            }\n+\n+            // Since we found an error, we should stop and alert the user:\n+            throw new GATKException(queryJob.getStatus().getError().toString());\n+        }\n+\n+        // Get the results.\n+        logger.info(\"Retrieving query results...\");\n+        final QueryResponse response = bigQuery.getQueryResults(jobId);\n+        final TableResult result;\n+        try {\n+            result = queryJob.getQueryResults();\n+\n+            long bytesProcessed = ((JobStatistics.QueryStatistics) queryJob.getStatistics()).getTotalBytesProcessed();\n+            logger.info(String.format(\"Actual %s MB scanned\", bytesProcessed/1000000));\n+\n+        }\n+        catch (final InterruptedException ex) {\n+            throw new GATKException(\"Interrupted while waiting for query job to complete\", ex);\n+        }\n+\n+        return result;\n+    }\n+\n+    private static long getQueryCostBytesProcessedEstimate(String queryString) {\n+        final QueryJobConfiguration dryRunQueryConfig =\n+                QueryJobConfiguration.newBuilder( queryString )\n+                        .setUseLegacySql(false)\n+                        .setDryRun(true)\n+                        .setUseQueryCache(false)\n+                        .setPriority(QueryJobConfiguration.Priority.INTERACTIVE)\n+                        .build();\n+\n+        Job dryRunJob = getBigQueryEndPoint().create(JobInfo.newBuilder(dryRunQueryConfig).build());\n+        long bytesProcessed = ((JobStatistics.QueryStatistics) dryRunJob.getStatistics()).getTotalBytesProcessed();\n+        return bytesProcessed;\n+    }\n+\n+//    public static StorageAPIAvroReader executeQueryWithStorageAPI(final String queryString, final List<String> fieldsToRetrieve, final String projectID) {\n+//\n+//        return executeQueryWithStorageAPI(queryString, fieldsToRetrieve, projectID, false);\n+//    }\n+//\n+//    public static StorageAPIAvroReader executeQueryWithStorageAPI(final String queryString, final List<String> fieldsToRetrieve, final String projectID, final boolean runQueryInBatchMode) {", "originalCommit": "82e4cf10713b4a4be419496491e08f4329d79918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU2NDg1OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r493564859", "bodyText": "I uncommented this out, although it's currently not used in the rest of the code on ah_var_store because the places we currently use the Storage API are only pulling down the full table (rather than running a specific query). I think we could clean up the code in future PRs to use the StorageAPI in places where we are running a query so this will still be useful.", "author": "meganshand", "createdAt": "2020-09-23T13:05:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2OTIyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3MDExMA==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r481370110", "bodyText": "Is this class used anywhere?", "author": "droazen", "createdAt": "2020-09-01T19:07:31Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/bigquery/BigQueryUtils.java", "diffHunk": "@@ -0,0 +1,449 @@\n+package org.broadinstitute.hellbender.utils.bigquery;\n+\n+import com.google.cloud.bigquery.*;\n+import com.google.cloud.bigquery.storage.v1beta1.*;\n+import com.google.common.base.Preconditions;\n+import org.apache.avro.generic.GenericData;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.io.BinaryDecoder;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.ivy.util.StringUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Utility class for dealing with BigQuery connections / tables / queries /etc.\n+ *\n+ * Created by jonn on 4/17/19.\n+ */\n+public class BigQueryUtils {\n+    private static final Logger logger = LogManager.getLogger(BigQueryUtils.class);\n+\n+    //==================================================================================================================\n+    // Static Methods:\n+\n+    /**\n+     * @return A {@link BigQuery} object that can be used to interact with a BigQuery data set.\n+     */\n+    public static BigQuery getBigQueryEndPoint() {\n+        return BigQueryOptions.getDefaultInstance().getService();\n+    }\n+\n+    /**\n+     * Executes the given {@code queryString} on the default instance of {@link BigQuery} as created by {@link #getBigQueryEndPoint()}.\n+     * Will block until results are returned.\n+     * For more information on querying BigQuery tables, see: https://cloud.google.com/bigquery/sql-reference/\n+     * @param queryString The {@link BigQuery} query string to execute.  Must use standard SQL syntax.  Must contain the project ID, data set, and table name in the `FROM` clause for the table from which to retrieve data.\n+     * @return A {@link TableResult} object containing the results of the query executed.\n+     */\n+    public static TableResult executeQuery(final String queryString) {\n+        return executeQuery(getBigQueryEndPoint(), queryString, false);\n+    }\n+\n+    /**\n+     * Executes the given {@code queryString} on the default instance of {@link BigQuery} as created by {@link #getBigQueryEndPoint()}.\n+     * Will block until results are returned.\n+     * For more information on querying BigQuery tables, see: https://cloud.google.com/bigquery/sql-reference/\n+     * @param queryString The {@link BigQuery} query string to execute.  Must use standard SQL syntax.  Must contain the project ID, data set, and table name in the `FROM` clause for the table from which to retrieve data.\n+     * @param runQueryInBatchMode If true, run the query in batch mode, which is lower priority but has no limit on the number of concurrent queries\n+     * @return A {@link TableResult} object containing the results of the query executed.\n+     */\n+    public static TableResult executeQuery(final String queryString, final boolean runQueryInBatchMode) {\n+        return executeQuery(getBigQueryEndPoint(), queryString, runQueryInBatchMode);\n+    }\n+\n+    /**\n+     * Executes the given {@code queryString} on the default instance of {@link BigQuery} as created by {@link #getBigQueryEndPoint()}.\n+     * Will block until results are returned.\n+     * For more information on querying BigQuery tables, see: https://cloud.google.com/bigquery/sql-reference/\n+     * @param bigQuery The {@link BigQuery} instance against which to execute the given {@code queryString}.\n+     * @param queryString The {@link BigQuery} query string to execute.  Must use standard SQL syntax.  Must contain the project ID, data set, and table name in the `FROM` clause for the table from which to retrieve data.\n+     * @param runQueryInBatchMode If true, run the query in batch mode, which is lower priority but has no limit on the number of concurrent queries\n+     * @return A {@link TableResult} object containing the results of the query executed.\n+     */\n+    public static TableResult executeQuery(final BigQuery bigQuery, final String queryString, final boolean runQueryInBatchMode) {\n+\n+        // Create a query configuration we can run based on our query string:\n+        final QueryJobConfiguration queryConfig =\n+                QueryJobConfiguration.newBuilder( queryString )\n+                        .setUseLegacySql(false)\n+                        .setPriority(runQueryInBatchMode ? QueryJobConfiguration.Priority.BATCH : QueryJobConfiguration.Priority.INTERACTIVE)\n+                        .build();\n+\n+        logger.info(\"Executing Query: \\n\\n\" + queryString);\n+        final TableResult result = submitQueryAndWaitForResults( bigQuery, queryConfig );\n+        logger.info(\"Query returned \" + result.getTotalRows() + \" results.\");\n+        return result;\n+    }\n+\n+    /**\n+     * Executes the given {@code queryString} on the default instance of {@link BigQuery} as created by {@link #getBigQueryEndPoint()}.\n+     * Will block until results are returned.\n+     * For more information on querying BigQuery tables, see: https://cloud.google.com/bigquery/sql-reference/\n+     * @param bigQuery The {@link BigQuery} instance against which to execute the given {@code queryString}.  Must contain the table name in the `FROM` clause for the table from which to retrieve data.\n+     * @param projectID The BigQuery {@code project ID} containing the {@code dataSet} and table from which to query data.\n+     * @param dataSet The BigQuery {@code dataSet} containing the table from which to query data.\n+     * @param queryString The {@link BigQuery} query string to execute.  Must use standard SQL syntax.  Must contain the project ID, data set, and table ID in the `FROM` clause for the table from which to retrieve data.\n+     * @return A {@link TableResult} object containing the results of the query executed.\n+     */\n+    public static TableResult executeQuery(final BigQuery bigQuery,\n+                                           final String projectID,\n+                                           final String dataSet,\n+                                           final String queryString) {\n+\n+        // Create a query configuration we can run based on our query string:\n+        final QueryJobConfiguration queryConfig =\n+                QueryJobConfiguration.newBuilder( queryString )\n+                        .setUseLegacySql(false)\n+                        .setDefaultDataset(DatasetId.of(projectID, dataSet))\n+                        .build();\n+\n+        return submitQueryAndWaitForResults( bigQuery, queryConfig );\n+    }\n+\n+    /**\n+     * Creates a {@link String} containing the given results in a pretty ascii-art table.\n+     * @param result A {@link TableResult} object containing the results of a query that generated some data.\n+     * @return A {@link String} containing the contents of the given query result pretty-printed in an ascii-art table.\n+     */\n+    public static String getResultDataPrettyString(final TableResult result){\n+        final Schema schema = result.getSchema();\n+\n+        final List<Integer> columnWidths = calculateColumnWidths( result );\n+        final boolean rowsAllPrimitive =\n+                StreamSupport.stream(result.iterateAll().spliterator(), false)\n+                        .flatMap( row -> row.stream().map(v -> v.getAttribute() == FieldValue.Attribute.PRIMITIVE) )\n+                        .allMatch( b -> b );\n+\n+        // Create a separator string for the header and boarders:\n+        final String headerFooter = \"+\" + columnWidths.stream().map(\n+                l -> StringUtils.repeat(\"=\", l+2) + \"+\"\n+        ).collect(Collectors.joining(\"\"));\n+\n+        // Create a Row Separator:\n+        final String rowSeparator = headerFooter.replace('=', '-');\n+\n+        // Create a string builder to keep the pretty table:\n+        final StringBuilder sb = new StringBuilder();\n+\n+        // Now we can write our schema header and rows:\n+        addHeaderToStringBuilder(schema, columnWidths, headerFooter, sb);\n+\n+        // Write our data to the string builder:\n+        for ( final FieldValueList row : result.iterateAll() ) {\n+\n+            // If the row fields are all simple, then we can do the simple thing:\n+            if ( rowsAllPrimitive ) {\n+                addPrimitiveRowToStringBuilder(row, columnWidths, sb);\n+            }\n+            else {\n+                addComplexRowToStringBuilder(row, schema, columnWidths, sb);\n+                sb.append(rowSeparator);\n+            }\n+            sb.append(\"\\n\");\n+        }\n+\n+        sb.append( headerFooter );\n+        sb.append(\"\\n\");\n+\n+        return sb.toString();\n+    }\n+\n+    private static void addHeaderToStringBuilder(final Schema schema, final List<Integer> columnWidths, final String headerFooter, final StringBuilder sb) {\n+        sb.append( headerFooter );\n+        sb.append(\"\\n\");\n+        sb.append(\"|\");\n+        sb.append(\n+                IntStream.range(0, columnWidths.size()).boxed().map(\n+                        i -> String.format(\" %-\"+ columnWidths.get(i) +\"s |\", schema.getFields().get(i).getName())\n+                ).collect(Collectors.joining()) );\n+        sb.append(\"\\n\");\n+        sb.append( headerFooter );\n+        sb.append(\"\\n\");\n+    }\n+\n+    private static void addComplexRowToStringBuilder(final FieldValueList row, final Schema schema, final List<Integer> columnWidths, final StringBuilder sb) {\n+\n+        // TODO: Clean this up... Probably make a getStringValue(FIELD) method to use here, addPrimitiveRowToStringBuilder, and calculateColumnWidths\n+\n+        // For fields that have multiple values, we need to do something special.\n+        // In fact, we need to go through each value of each row and track how many fields it has.\n+        int maxNumValuesInRow = 1;\n+        for ( int i = 0; i < row.size(); ++i ) {\n+            final FieldValue value = row.get(schema.getFields().get(i).getName());\n+            if ( !value.isNull() && (value.getAttribute() != FieldValue.Attribute.PRIMITIVE) ) {\n+                if (maxNumValuesInRow <= value.getRecordValue().size()) {\n+                    maxNumValuesInRow = value.getRecordValue().size();\n+                }\n+            }\n+        }\n+\n+        for ( int currentFieldNum = 0; currentFieldNum < maxNumValuesInRow ; ++currentFieldNum ) {\n+            sb.append(\"|\");\n+            for ( int i = 0; i < row.size(); ++i ) {\n+                final FieldValue value = row.get(i);\n+                if ( value.isNull() ) {\n+                    sb.append(getEmptyColumnString(columnWidths, i));\n+                }\n+                else if (value.getAttribute() == FieldValue.Attribute.PRIMITIVE ) {\n+                    if ( currentFieldNum == 0 ) {\n+                        sb.append( String.format(\" %-\" + columnWidths.get(i) + \"s |\", value.getStringValue()) );\n+                    }\n+                    else {\n+                        sb.append(getEmptyColumnString(columnWidths, i));\n+                    }\n+                }\n+                else {\n+                    if ( value.getRepeatedValue().size() == 0 ) {\n+                        sb.append(getEmptyColumnString(columnWidths, i));\n+                    }\n+                    else if ( currentFieldNum < value.getRepeatedValue().size() ) {\n+                        if ( value.getRepeatedValue().get(currentFieldNum).getAttribute() == FieldValue.Attribute.PRIMITIVE ) {\n+                            sb.append(String.format(\" %-\" + columnWidths.get(i) + \"s |\",\n+                                    value.getRepeatedValue().get(currentFieldNum).getStringValue())\n+                            );\n+                        }\n+                        else {\n+                            // This is kind of gross, but it seems to be the only way to get a particular\n+                            // value of a field that is in an array:\n+                            sb.append(String.format(\" %-\" + columnWidths.get(i) + \"s |\",\n+                                    value.getRepeatedValue().get(currentFieldNum).getRecordValue().get(0).getStringValue())\n+                            );\n+                        }\n+                    }\n+                    else {\n+                        sb.append(getEmptyColumnString(columnWidths, i));\n+                    }\n+                }\n+            }\n+            sb.append(\"\\n\");\n+        }\n+    }\n+\n+    private static String getEmptyColumnString(final List<Integer> columnWidths, final int i) {\n+        return String.format(\" %-\" + columnWidths.get(i) + \"s |\", \"\");\n+    }\n+\n+    private static void addPrimitiveRowToStringBuilder(final FieldValueList row, final List<Integer> columnWidths, final StringBuilder sb) {\n+        sb.append(\"|\");\n+        sb.append(IntStream.range(0, row.size()).boxed().map(\n+                i -> String.format(\" %-\" + columnWidths.get(i) + \"s |\", row.get(i).getStringValue())\n+        ).collect(Collectors.joining()));\n+    }\n+\n+    /**\n+     * Creates a {@link String} containing the given results in a pretty ascii-art table.\n+     * @param result A {@link TableResult} object containing the results of a query that generated some data.\n+     * @param theLogger A {@link Logger} object with which to log the results contained in {@code result}.\n+     */\n+    public static void logResultDataPretty( final TableResult result, final Logger theLogger ){\n+        for ( final String line : getResultDataPrettyString(result).split(\"\\n\") ) {\n+            theLogger.info( line );\n+        }\n+    }\n+\n+    //==================================================================================================================\n+    // Helper Methods:\n+\n+    private static List<Integer> calculateColumnWidths( final TableResult result ) {\n+        // Go through all rows and get the length of each column:\n+        final List<Integer> columnWidths = new ArrayList<>(result.getSchema().getFields().size());\n+\n+        // Start with schema names:\n+        for ( final Field field : result.getSchema().getFields() ) {\n+            columnWidths.add( field.getName().length() );\n+        }\n+\n+        // Check each row and each row's array values (if applicable):\n+        for ( final FieldValueList row : result.iterateAll() ) {\n+            for ( int i = 0; i < row.size() ; ++i ) {\n+                // Only get the row size if it's not null:\n+                if ( !row.get(i).isNull() ) {\n+                    if ( row.get(i).getAttribute() == FieldValue.Attribute.PRIMITIVE ) {\n+                        if ( columnWidths.get(i) < row.get(i).getStringValue().length() ) {\n+                            columnWidths.set(i, row.get(i).getStringValue().length());\n+                        }\n+                    }\n+                    else {\n+                        for ( int j = 0; j < row.get(i).getRepeatedValue().size(); ++j ) {\n+                            final String stringValue;\n+                            if ( row.get(i).getRepeatedValue().get(j).getAttribute() == FieldValue.Attribute.PRIMITIVE ) {\n+                                stringValue = row.get(i).getRepeatedValue().get(j).getStringValue();\n+                            }\n+                            else {\n+                                stringValue = row.get(i).getRepeatedValue().get(j).getRecordValue().get(0).getStringValue();\n+                            }\n+                            if ( columnWidths.get(i) < stringValue.length() ) {\n+                                columnWidths.set(i, stringValue.length());\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return columnWidths;\n+    }\n+\n+    /**\n+     * Executes the given {@code queryJobConfiguration} on the given {@code bigQuery} instance.\n+     * @param bigQuery The instance of {@link BigQuery} to use to connect to BigQuery.\n+     * @param queryJobConfiguration The {@link QueryJobConfiguration} object containing all required information to retrieve data from a BigQuery table.\n+     * @return A {@link TableResult} object containing the results of the query executed.\n+     */\n+    private static TableResult submitQueryAndWaitForResults( final BigQuery bigQuery,\n+                                                             final QueryJobConfiguration queryJobConfiguration ) {\n+        // Create a job ID so that we can safely retry:\n+        final JobId jobId = JobId.of(UUID.randomUUID().toString());\n+\n+        logger.info(\"Sending query to server...\");\n+        Job   queryJob       = bigQuery.create(JobInfo.newBuilder(queryJobConfiguration).setJobId(jobId).build());\n+\n+        // Wait for the query to complete.\n+        try {\n+            logger.info(\"Waiting for query to complete...\");\n+            queryJob = queryJob.waitFor();\n+        }\n+        catch (final InterruptedException ex) {\n+            throw new GATKException(\"Interrupted while waiting for query job to complete\", ex);\n+        }\n+\n+        // Check for errors:\n+        if (queryJob == null) {\n+            throw new GATKException(\"Query job no longer exists\");\n+        } else if (queryJob.getStatus().getError() != null) {\n+\n+            // Get all the errors we found and log them:\n+            for ( final BigQueryError bigQueryError : queryJob.getStatus().getExecutionErrors() ) {\n+                logger.error( \"Encountered BigQuery Execution Error: \" + bigQueryError.toString() );\n+            }\n+\n+            // Since we found an error, we should stop and alert the user:\n+            throw new GATKException(queryJob.getStatus().getError().toString());\n+        }\n+\n+        // Get the results.\n+        logger.info(\"Retrieving query results...\");\n+        final QueryResponse response = bigQuery.getQueryResults(jobId);\n+        final TableResult result;\n+        try {\n+            result = queryJob.getQueryResults();\n+\n+            long bytesProcessed = ((JobStatistics.QueryStatistics) queryJob.getStatistics()).getTotalBytesProcessed();\n+            logger.info(String.format(\"Actual %s MB scanned\", bytesProcessed/1000000));\n+\n+        }\n+        catch (final InterruptedException ex) {\n+            throw new GATKException(\"Interrupted while waiting for query job to complete\", ex);\n+        }\n+\n+        return result;\n+    }\n+\n+    private static long getQueryCostBytesProcessedEstimate(String queryString) {\n+        final QueryJobConfiguration dryRunQueryConfig =\n+                QueryJobConfiguration.newBuilder( queryString )\n+                        .setUseLegacySql(false)\n+                        .setDryRun(true)\n+                        .setUseQueryCache(false)\n+                        .setPriority(QueryJobConfiguration.Priority.INTERACTIVE)\n+                        .build();\n+\n+        Job dryRunJob = getBigQueryEndPoint().create(JobInfo.newBuilder(dryRunQueryConfig).build());\n+        long bytesProcessed = ((JobStatistics.QueryStatistics) dryRunJob.getStatistics()).getTotalBytesProcessed();\n+        return bytesProcessed;\n+    }\n+\n+//    public static StorageAPIAvroReader executeQueryWithStorageAPI(final String queryString, final List<String> fieldsToRetrieve, final String projectID) {\n+//\n+//        return executeQueryWithStorageAPI(queryString, fieldsToRetrieve, projectID, false);\n+//    }\n+//\n+//    public static StorageAPIAvroReader executeQueryWithStorageAPI(final String queryString, final List<String> fieldsToRetrieve, final String projectID, final boolean runQueryInBatchMode) {\n+//        final String tempTableDataset = \"temp_tables\";\n+//        final String tempTableName = UUID.randomUUID().toString().replace('-', '_');\n+//        final String tempTableFullyQualified = String.format(\"%s.%s.%s\", projectID, tempTableDataset, tempTableName);\n+//\n+//        long bytesProcessed = getQueryCostBytesProcessedEstimate(queryString);\n+//        logger.info(String.format(\"Estimated %s MB scanned\", bytesProcessed/1000000));\n+//\n+//        final String queryStringIntoTempTable = \"CREATE TABLE `\" + tempTableFullyQualified + \"`\\n\" +\n+//                \"OPTIONS(\\n\" +\n+//                \"  expiration_timestamp=TIMESTAMP_ADD(CURRENT_TIMESTAMP(), INTERVAL 1 DAY)\\n\" +\n+//                \") AS\\n\" +\n+//                queryString;\n+//\n+//        final TableResult result = executeQuery(queryStringIntoTempTable, runQueryInBatchMode);\n+//\n+//        final Table tableInfo = getBigQueryEndPoint().getTable( TableId.of(projectID, tempTableDataset, tempTableName) );\n+//        logger.info(String.format(\"Query temp table created with %s rows and %s bytes in size\", tableInfo.getNumRows(), tableInfo.getNumBytes()));\n+//\n+//        return new StorageAPIAvroReader(projectID, tempTableDataset, tempTableName, fieldsToRetrieve);\n+//    }\n+\n+    private static class SimpleRowReader {", "originalCommit": "82e4cf10713b4a4be419496491e08f4329d79918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwNDY2OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r493804669", "bodyText": "no, I removed it", "author": "meganshand", "createdAt": "2020-09-23T18:33:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3MDExMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3MDM2OA==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r481370368", "bodyText": "Make final, and add a private default constructor to prevent instantiation.", "author": "droazen", "createdAt": "2020-09-01T19:07:55Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/bigquery/BigQueryUtils.java", "diffHunk": "@@ -0,0 +1,449 @@\n+package org.broadinstitute.hellbender.utils.bigquery;\n+\n+import com.google.cloud.bigquery.*;\n+import com.google.cloud.bigquery.storage.v1beta1.*;\n+import com.google.common.base.Preconditions;\n+import org.apache.avro.generic.GenericData;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.io.BinaryDecoder;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.ivy.util.StringUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Utility class for dealing with BigQuery connections / tables / queries /etc.\n+ *\n+ * Created by jonn on 4/17/19.\n+ */\n+public class BigQueryUtils {", "originalCommit": "82e4cf10713b4a4be419496491e08f4329d79918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk4ODk2MA==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r492988960", "bodyText": "done", "author": "meganshand", "createdAt": "2020-09-22T19:42:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3MDM2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3MjcxMg==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r481372712", "bodyText": "In the original Evoquer PR #6011 there was a basic unit test for this branch:\nhttps://github.com/broadinstitute/gatk/blob/111e6875cb29da5e7c75a5d113d217931ecd2c10/src/test/java/org/broadinstitute/hellbender/utils/bigquery/BigQueryUtilsUnitTest.java\nWe need some test coverage on this class, so we should either restore and expand BigQueryUtilsUnitTest or write a new set of tests from scratch. If we restore BigQueryUtilsUnitTest you should expand it slightly to cover additional overloads of executeQuery().", "author": "droazen", "createdAt": "2020-09-01T19:12:25Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/bigquery/BigQueryUtils.java", "diffHunk": "@@ -0,0 +1,449 @@\n+package org.broadinstitute.hellbender.utils.bigquery;\n+\n+import com.google.cloud.bigquery.*;\n+import com.google.cloud.bigquery.storage.v1beta1.*;\n+import com.google.common.base.Preconditions;\n+import org.apache.avro.generic.GenericData;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.io.BinaryDecoder;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.ivy.util.StringUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Utility class for dealing with BigQuery connections / tables / queries /etc.", "originalCommit": "82e4cf10713b4a4be419496491e08f4329d79918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk4NzY2MA==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r492987660", "bodyText": "I copied that unit test file into this branch and added more tests for executeQuery(). I don't know how to change the author in git, but I'm happy to do it if you can point me to a reference.", "author": "meganshand", "createdAt": "2020-09-22T19:39:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3MjcxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3NDEwMg==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r481374102", "bodyText": "iterator() should return a new iterator on each call, not an existing iterator instance", "author": "droazen", "createdAt": "2020-09-01T19:15:04Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/bigquery/QueryAPIRowReader.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package org.broadinstitute.hellbender.utils.bigquery;\n+\n+import com.google.cloud.bigquery.*;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.Iterator;\n+\n+public class QueryAPIRowReader implements Iterable<FieldValueList>, Iterator<FieldValueList> {\n+    private static final Logger logger = LogManager.getLogger(QueryAPIRowReader.class);\n+\n+    private Iterator<FieldValueList> rowIterator;\n+\n+    public QueryAPIRowReader(TableResult tableResult) {\n+        rowIterator = tableResult.iterateAll().iterator();\n+\n+    }\n+    @Override\n+    public Iterator<FieldValueList> iterator() {\n+        return rowIterator;", "originalCommit": "82e4cf10713b4a4be419496491e08f4329d79918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYwMzk0MA==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r493603940", "bodyText": "code deleted", "author": "meganshand", "createdAt": "2020-09-23T13:44:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3NDEwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3NTA5Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r481375097", "bodyText": "Can you explain why this class is needed? Eg., why can't you just use the TableResult iterator directly instead of having this wrapper?", "author": "droazen", "createdAt": "2020-09-01T19:17:01Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/bigquery/QueryAPIRowReader.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package org.broadinstitute.hellbender.utils.bigquery;\n+\n+import com.google.cloud.bigquery.*;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.Iterator;\n+\n+public class QueryAPIRowReader implements Iterable<FieldValueList>, Iterator<FieldValueList> {", "originalCommit": "82e4cf10713b4a4be419496491e08f4329d79918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk5NTkyMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r492995921", "bodyText": "I looked through the uses on the ah_var_store branch and I don't think this class is necessary so I removed it. We will have to update the couple of uses in the ah_var_store branch though.", "author": "meganshand", "createdAt": "2020-09-22T19:55:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3NTA5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3NTIyNA==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r481375224", "bodyText": "Add javadoc for this class, explaining how it's different from GenericRecord", "author": "droazen", "createdAt": "2020-09-01T19:17:15Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/bigquery/QueryRecord.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package org.broadinstitute.hellbender.utils.bigquery;\n+\n+import com.google.cloud.bigquery.FieldValueList;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericRecord;\n+\n+public class QueryRecord implements GenericRecord {", "originalCommit": "82e4cf10713b4a4be419496491e08f4329d79918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzEwMjgxNw==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r493102817", "bodyText": "added comment", "author": "meganshand", "createdAt": "2020-09-23T00:15:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3NTIyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3NTYzOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r481375639", "bodyText": "Remove commented-out code", "author": "droazen", "createdAt": "2020-09-01T19:18:12Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/bigquery/QueryRecord.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package org.broadinstitute.hellbender.utils.bigquery;\n+\n+import com.google.cloud.bigquery.FieldValueList;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericRecord;\n+\n+public class QueryRecord implements GenericRecord {\n+    private final FieldValueList fields;\n+\n+    public QueryRecord(FieldValueList fields) {\n+        this.fields = fields;\n+    }\n+    @Override\n+    public void put(String key, Object v) {\n+        throw new RuntimeException(\"Not implemented\");\n+    }\n+\n+    @Override\n+    public Object get(String key) {\n+        return fields.get(key).getStringValue();\n+    }\n+\n+//    public long getLong(String key) { return fields.get(key).getLongValue(); }", "originalCommit": "82e4cf10713b4a4be419496491e08f4329d79918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzEwMjgzOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r493102839", "bodyText": "done", "author": "meganshand", "createdAt": "2020-09-23T00:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3NTYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3Njc1OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r481376759", "bodyText": "If this class is used in subsequent branches, we'll need to add a test for it. A basic unit test for BigQueryUtils that exercises the (currently commented-out) executeQueryWithStorageAPI() method would suffice.", "author": "droazen", "createdAt": "2020-09-01T19:20:20Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/bigquery/StorageAPIAvroReader.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.broadinstitute.hellbender.utils.bigquery;\n+\n+import com.google.cloud.bigquery.storage.v1beta1.*;\n+import com.google.common.base.Preconditions;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.io.BinaryDecoder;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+public class StorageAPIAvroReader implements GATKAvroReader {", "originalCommit": "82e4cf10713b4a4be419496491e08f4329d79918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU2MTAxNA==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r493561014", "bodyText": "Uncommented out executeQueryWithStorageAPI() and added a test.", "author": "meganshand", "createdAt": "2020-09-23T13:01:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3Njc1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3NzQxNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r481377415", "bodyText": "Do we know the answer to this?", "author": "droazen", "createdAt": "2020-09-01T19:21:37Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/bigquery/StorageAPIAvroReader.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.broadinstitute.hellbender.utils.bigquery;\n+\n+import com.google.cloud.bigquery.storage.v1beta1.*;\n+import com.google.common.base.Preconditions;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.io.BinaryDecoder;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+public class StorageAPIAvroReader implements GATKAvroReader {\n+\n+    private static final Logger logger = LogManager.getLogger(StorageAPIAvroReader.class);\n+\n+    private static int rowCount = 0;\n+\n+    private BigQueryStorageClient client;\n+\n+    private Iterator<Storage.ReadRowsResponse> serverStream;\n+\n+    private org.apache.avro.Schema schema;\n+\n+    private DatumReader<GenericRecord> datumReader;\n+\n+    // Decoder object will be reused to avoid re-allocation and too much garbage collection.\n+    private BinaryDecoder decoder = null;\n+\n+    private AvroProto.AvroRows currentAvroRows;\n+\n+    // GenericRecord object will be reused.\n+    private GenericRecord nextRow = null;\n+\n+    public StorageAPIAvroReader(final TableReference tableRef) {\n+\n+        try {\n+            this.client = BigQueryStorageClient.create();\n+\n+            final String parent = String.format(\"projects/%s\", tableRef.tableProject);\n+\n+            final TableReferenceProto.TableReference tableReference = TableReferenceProto.TableReference.newBuilder()\n+                    .setProjectId(tableRef.tableProject)\n+                    .setDatasetId(tableRef.tableDataset)\n+                    .setTableId(tableRef.tableName)\n+                    .build();\n+\n+            final ReadOptions.TableReadOptions tableReadOptions =\n+                    ReadOptions.TableReadOptions.newBuilder()\n+                            .addAllSelectedFields(tableRef.fields)\n+                            .build();\n+\n+            final Storage.CreateReadSessionRequest.Builder builder = Storage.CreateReadSessionRequest.newBuilder()\n+                    .setParent(parent)\n+                    .setTableReference(tableReference)\n+                    .setReadOptions(tableReadOptions)\n+                    .setRequestedStreams(1)\n+                    .setFormat(Storage.DataFormat.AVRO);\n+\n+            final Storage.ReadSession session = client.createReadSession(builder.build());\n+            Preconditions.checkState(session.getStreamsCount() > 0);\n+\n+            this.schema = new org.apache.avro.Schema.Parser().parse(session.getAvroSchema().getSchema());\n+\n+            this.datumReader = new GenericDatumReader<>(\n+                    new org.apache.avro.Schema.Parser().parse(session.getAvroSchema().getSchema()));\n+\n+            // Use the first stream to perform reading.\n+            Storage.StreamPosition readPosition = Storage.StreamPosition.newBuilder()\n+                    .setStream(session.getStreams(0))\n+                    .build();\n+\n+            Storage.ReadRowsRequest readRowsRequest = Storage.ReadRowsRequest.newBuilder()\n+                    .setReadPosition(readPosition)\n+                    .build();\n+\n+            this.serverStream = client.readRowsCallable().call(readRowsRequest).iterator();\n+\n+            loadNextRow();\n+        } catch ( IOException e ) {\n+            throw new GATKException(\"I/O Error\", e);\n+        }\n+    }\n+\n+    private void loadNextRow() {\n+        try {\n+            if ( decoder != null && ! decoder.isEnd() ) {\n+                nextRow = datumReader.read(null, decoder);\n+            } else {\n+                fetchNextAvroRows();\n+\n+                if ( decoder != null && ! decoder.isEnd() ) {\n+                    nextRow = datumReader.read(null, decoder);\n+                } else {\n+                    nextRow = null; // end of traversal\n+                }\n+            }\n+        } catch ( IOException e ) {\n+            throw new GATKException(\"I/O error\", e);\n+        }\n+    }\n+\n+    private void fetchNextAvroRows() {\n+        if ( serverStream.hasNext() ) {\n+            currentAvroRows = serverStream.next().getAvroRows();\n+            decoder = DecoderFactory.get()\n+                    .binaryDecoder(currentAvroRows.getSerializedBinaryRows().toByteArray(), decoder);\n+        } else {\n+            currentAvroRows = null;\n+            decoder = null;\n+        }\n+    }\n+\n+    @Override\n+    public org.apache.avro.Schema getSchema() {\n+        return schema;\n+    }\n+\n+    @Override\n+    public Iterator<GenericRecord> iterator() {\n+        return this;\n+    }\n+\n+    @Override\n+    public boolean hasNext() {\n+        return nextRow != null;\n+    }\n+\n+    @Override\n+    public GenericRecord next() {\n+        if ( ! hasNext() ) {\n+            throw new NoSuchElementException(\"next() called when ! hasNext()\");\n+        }\n+\n+        final GenericRecord recordToReturn = nextRow;\n+        loadNextRow();\n+        return recordToReturn;\n+    }\n+\n+    @Override\n+    public void close() {\n+        client.shutdownNow();\n+        /* TODO: do we need to wait for termination here?", "originalCommit": "82e4cf10713b4a4be419496491e08f4329d79918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc5MTE4OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r493791189", "bodyText": "I don't think we know the answer to this at this point, so could we leave the TODO for now?", "author": "meganshand", "createdAt": "2020-09-23T18:10:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3NzQxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3NzUzNA==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r481377534", "bodyText": "Add javadoc for this class", "author": "droazen", "createdAt": "2020-09-01T19:21:50Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/bigquery/TableReference.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package org.broadinstitute.hellbender.utils.bigquery;\n+\n+import java.util.List;\n+\n+public class TableReference {", "originalCommit": "82e4cf10713b4a4be419496491e08f4329d79918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU3MjA1Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r493572052", "bodyText": "done", "author": "meganshand", "createdAt": "2020-09-23T13:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3NzUzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3Nzg4MA==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r481377880", "bodyText": "Add javadoc explaining the format of fullyQualifiedTableName", "author": "droazen", "createdAt": "2020-09-01T19:22:31Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/bigquery/TableReference.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package org.broadinstitute.hellbender.utils.bigquery;\n+\n+import java.util.List;\n+\n+public class TableReference {\n+    public final String tableProject;\n+    public final String tableDataset;\n+    public final String tableName;\n+    public final List<String> fields;\n+\n+    public TableReference(String fullyQualifiedTableName, List<String> fields) {", "originalCommit": "82e4cf10713b4a4be419496491e08f4329d79918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU3ODE3MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r493578171", "bodyText": "done", "author": "meganshand", "createdAt": "2020-09-23T13:19:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3Nzg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3ODE1NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r481378155", "bodyText": "Handle the case where there aren't enough tokens after splitting by throwing an IllegalArgumentException. Also check for empty tokens.", "author": "droazen", "createdAt": "2020-09-01T19:23:05Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/bigquery/TableReference.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package org.broadinstitute.hellbender.utils.bigquery;\n+\n+import java.util.List;\n+\n+public class TableReference {\n+    public final String tableProject;\n+    public final String tableDataset;\n+    public final String tableName;\n+    public final List<String> fields;\n+\n+    public TableReference(String fullyQualifiedTableName, List<String> fields) {\n+        String[] vals = fullyQualifiedTableName.split(\"\\\\.\");\n+        tableProject = vals[0];\n+        tableDataset = vals[1];\n+        tableName = vals[2];", "originalCommit": "82e4cf10713b4a4be419496491e08f4329d79918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU5MDA1Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r493590057", "bodyText": "done", "author": "meganshand", "createdAt": "2020-09-23T13:30:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3ODE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3ODQzNA==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r481378434", "bodyText": "If fields is going to be public like this, you should wrap it in an ImmutableList or similar.", "author": "droazen", "createdAt": "2020-09-01T19:23:38Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/bigquery/TableReference.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package org.broadinstitute.hellbender.utils.bigquery;\n+\n+import java.util.List;\n+\n+public class TableReference {\n+    public final String tableProject;\n+    public final String tableDataset;\n+    public final String tableName;\n+    public final List<String> fields;", "originalCommit": "82e4cf10713b4a4be419496491e08f4329d79918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU3NjM1MA==", "url": "https://github.com/broadinstitute/gatk/pull/6759#discussion_r493576350", "bodyText": "done", "author": "meganshand", "createdAt": "2020-09-23T13:17:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3ODQzNA=="}], "type": "inlineReview"}, {"oid": "b70d89a771b1395cc923edc938d36199427b7eeb", "url": "https://github.com/broadinstitute/gatk/commit/b70d89a771b1395cc923edc938d36199427b7eeb", "message": "updates from ah_var_store branch", "committedDate": "2020-09-11T18:57:37Z", "type": "commit"}, {"oid": "e4121ea39d070485660bee75aa23fdd7243cd39d", "url": "https://github.com/broadinstitute/gatk/commit/e4121ea39d070485660bee75aa23fdd7243cd39d", "message": "Addressing comments", "committedDate": "2020-09-23T18:43:10Z", "type": "commit"}]}