{"pr_number": 6943, "pr_title": "Fixed a bug where overlapping reads in subsequent regions can have invalid base qualities", "pr_createdAt": "2020-11-06T18:36:16Z", "pr_url": "https://github.com/broadinstitute/gatk/pull/6943", "timeline": [{"oid": "7c38242dc738428ceb63fd7cb97be56bbc3f1165", "url": "https://github.com/broadinstitute/gatk/commit/7c38242dc738428ceb63fd7cb97be56bbc3f1165", "message": "Added a hack involving transient attributes to make sure everything gets coppied without doing it again for every read", "committedDate": "2020-11-06T18:33:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkzODU5Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6943#discussion_r518938596", "bodyText": "Instead of relying on transient attributes (which, in my opinion, is brittle and a recipe for future problems), compare the memory address of the read pre/post clipping, and make a copy only if the address hasn't changed, as in the original patch in #4926. Rewrite this method to use a loop instead of streaming, if necessary.", "author": "droazen", "createdAt": "2020-11-06T18:46:42Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -114,6 +118,9 @@ public static void finalizeRegion(final AssemblyRegion region,\n                 .filter(read ->  !read.isEmpty() && read.getCigar().getReadLength() > 0)\n                 .map(read -> ReadClipper.hardClipToRegion(read, region.getPaddedSpan().getStart(), region.getPaddedSpan().getEnd() ))\n                 .filter(read -> read.getStart() <= read.getEnd() && read.getLength() > 0 && read.overlaps(region.getPaddedSpan()))\n+                // The transient attribute is preserved across copy operations and all of the previous alterations make copies, this simple ensures\n+                // that any reads that have not been copied along the way are copied here for safety.\n+                .map(read -> (read.getTransientAttribute(\"Original\") != read? read : read.copy()))", "originalCommit": "7c38242dc738428ceb63fd7cb97be56bbc3f1165", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkwMjEwNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6943#discussion_r519902105", "bodyText": "I have rewritten it as a loop at the expense of angering the Aesthetic gods. Can you re-review?", "author": "jamesemery", "createdAt": "2020-11-09T15:32:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkzODU5Ng=="}], "type": "inlineReview"}, {"oid": "a55a266569dce93ecf0024ee962ca25fbd6fc3c3", "url": "https://github.com/broadinstitute/gatk/commit/a55a266569dce93ecf0024ee962ca25fbd6fc3c3", "message": "no more transient attributes...", "committedDate": "2020-11-06T19:50:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA3NzM3Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6943#discussion_r527077373", "bodyText": "The copy() method performs a shallow copy -- it ends up calling SAMRecord.clone(), which copies all fields in the SAMRecord as if by assignment (the exception is the attributes array, which is explicitly copied). So the byte[] arrays for the bases and quals point to the same memory location in the copy as in the original. Is this a problem? Do we later modify the bases/quals in-place somewhere, or do we always copy the bases/quals arrays due to the defensive copies in SAMRecordToGATKReadAdapter?", "author": "droazen", "createdAt": "2020-11-19T17:42:15Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -102,20 +102,31 @@ public static void finalizeRegion(final AssemblyRegion region,\n         }\n \n         final byte minTailQualityToUse = errorCorrectReads ? HaplotypeCallerEngine.MIN_TAIL_QUALITY_WITH_ERROR_CORRECTION : minTailQuality;\n-        final List<GATKRead> readsToUse = region.getReads().stream()\n-                // TODO unclipping soft clips may introduce bases that aren't in the extended region if the unclipped bases\n-                // TODO include a deletion w.r.t. the reference.  We must remove kmers that occur before the reference haplotype start\n-                .map(read -> dontUseSoftClippedBases || ! ReadUtils.hasWellDefinedFragmentSize(read) ?\n-                    ReadClipper.hardClipSoftClippedBases(read) : ReadClipper.revertSoftClippedBases(read))\n-                .map(read -> softClipLowQualityEnds ? ReadClipper.softClipLowQualEnds(read, minTailQualityToUse) :\n-                        ReadClipper.hardClipLowQualEnds(read, minTailQualityToUse))\n-                .filter(read -> read.getStart() <= read.getEnd())\n-                .map(read -> read.isUnmapped() ? read : ReadClipper.hardClipAdaptorSequence(read))\n-                .filter(read ->  !read.isEmpty() && read.getCigar().getReadLength() > 0)\n-                .map(read -> ReadClipper.hardClipToRegion(read, region.getPaddedSpan().getStart(), region.getPaddedSpan().getEnd() ))\n-                .filter(read -> read.getStart() <= read.getEnd() && read.getLength() > 0 && read.overlaps(region.getPaddedSpan()))\n-                .sorted(new ReadCoordinateComparator(readsHeader)) // TODO: sort may be unnecessary here\n-                .collect(Collectors.toList());\n+\n+        final List<GATKRead> readsToUse = new ArrayList<>();\n+        for (GATKRead originalRead : region.getReads()) {\n+            // TODO unclipping soft clips may introduce bases that aren't in the extended region if the unclipped bases\n+            // TODO include a deletion w.r.t. the reference.  We must remove kmers that occur before the reference haplotype start\n+            GATKRead read = (dontUseSoftClippedBases || ! ReadUtils.hasWellDefinedFragmentSize(originalRead) ?\n+                    ReadClipper.hardClipSoftClippedBases(originalRead) : ReadClipper.revertSoftClippedBases(originalRead));\n+            read = (softClipLowQualityEnds ? ReadClipper.softClipLowQualEnds(read, minTailQualityToUse) :\n+                    ReadClipper.hardClipLowQualEnds(read, minTailQualityToUse));\n+\n+            if (read.getStart() <= read.getEnd()) {\n+                read = (read.isUnmapped() ? read : ReadClipper.hardClipAdaptorSequence(read));\n+\n+                if (!read.isEmpty() && read.getCigar().getReadLength() > 0) {\n+                    read = ReadClipper.hardClipToRegion(read, region.getPaddedSpan().getStart(), region.getPaddedSpan().getEnd() );\n+\n+                    if (read.getStart() <= read.getEnd() && read.getLength() > 0 && read.overlaps(region.getPaddedSpan())) {\n+                        // NOTE: here we make a defensive copy of the read if it has not been modified by the above operations\n+                        // which might only make copies in the case that the read is actually clipped\n+                        readsToUse.add(read == originalRead? read.copy() : read);", "originalCommit": "a55a266569dce93ecf0024ee962ca25fbd6fc3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA4MTA0Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6943#discussion_r527081043", "bodyText": "We do modify them later, specifically when we call cleanOverlappingReadPairs() we modify the base qualities in place for reads that overlap and if any of those reads have not been clipped bby the clipping code here this could result in the next assembly region having invalid/wrong base qualities for the same read. Given how that method is structured it is non-trivial to refactor it to make the copy only in the event it needs to be modified and it seemed easier to just put a check in to make sure that every read is deeply copied at least once.", "author": "jamesemery", "createdAt": "2020-11-19T17:47:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA3NzM3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA4NDc3NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6943#discussion_r527084775", "bodyText": "@jamesemery I disagree with your assessment that cleanOverlappingReadPairs() changes the bases/quals in-place -- it calls getBases() and getBaseQualities() on the read, which perform defensive copies. The question is: is there any code that calls getBasesNoCopy() and/or getBaseQualitiesNoCopy() and truly modifies the bases/quals arrays in place?", "author": "droazen", "createdAt": "2020-11-19T17:53:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA3NzM3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEwMjc3NA==", "url": "https://github.com/broadinstitute/gatk/pull/6943#discussion_r527102774", "bodyText": "I see that the PileupReadErrorCorrector calls getBaseQualitiesNoCopy() and getBasesNoCopy() and then modifies the bases/quals in-place. This could have the effect of modifying the base/qual arrays in the original reads that will be used in subsequent assembly regions. I think as part of this PR we should patch PileupReadErrorCorrector to call the getters that make copies, and then call the setter methods to update the bases/quals.\nWe should also check for additional problematic usages of the *NoCopy() methods in the HC/M2 codepaths.", "author": "droazen", "createdAt": "2020-11-19T18:21:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA3NzM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA3NzY1Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6943#discussion_r527077652", "bodyText": "Can you confirm that the modified version of this test fails without the copy() call you added above?", "author": "droazen", "createdAt": "2020-11-19T17:42:40Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtilsUnitTest.java", "diffHunk": "@@ -64,7 +64,7 @@ public void testfinalizeRegion() {\n         activeRegion.addAll(reads);\n         SampleList sampleList = SampleList.singletonSampleList(\"tumor\");\n         Byte minbq = 9;\n-        AssemblyBasedCallerUtils.finalizeRegion(activeRegion, false, false, minbq, header, sampleList, false, false);\n+        AssemblyBasedCallerUtils.finalizeRegion(activeRegion, false, false, minbq, header, sampleList, true, false);", "originalCommit": "a55a266569dce93ecf0024ee962ca25fbd6fc3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA4MzE4Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6943#discussion_r527083183", "bodyText": "I have already tested it. It does fail without the above fix. the problem is that when we added correctOverlappingBaseQualities as an argument to finalizeRegion() it was mistakenly set to false for this method, which means this test was doing nothing and thus we missed that the last round of refactoring broke the assertion in this test by allowing un-coppied base qualities to be adjusted.", "author": "jamesemery", "createdAt": "2020-11-19T17:51:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA3NzY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA4NzQ1OA==", "url": "https://github.com/broadinstitute/gatk/pull/6943#discussion_r527087458", "bodyText": "Can you add a comment then mentioning that that boolean argument is critical for the test to be meaningful?", "author": "droazen", "createdAt": "2020-11-19T17:57:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA3NzY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc4NDAzNg==", "url": "https://github.com/broadinstitute/gatk/pull/6943#discussion_r527784036", "bodyText": "@droazen I added comments better explaining how the test works. Is this okay to merge?", "author": "jamesemery", "createdAt": "2020-11-20T15:51:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA3NzY1Mg=="}], "type": "inlineReview"}, {"oid": "62ddfcf02de25aeab3d508c96e044f53f1e76bf2", "url": "https://github.com/broadinstitute/gatk/commit/62ddfcf02de25aeab3d508c96e044f53f1e76bf2", "message": "responding to comments by clarifying the tests", "committedDate": "2020-11-19T19:21:05Z", "type": "commit"}]}