{"pr_number": 6802, "pr_title": "ReferenceBlockConcordance - new tool to evaluate concordance of reference block in GVCF files", "pr_createdAt": "2020-09-09T13:02:37Z", "pr_url": "https://github.com/broadinstitute/gatk/pull/6802", "timeline": [{"oid": "3146dabf366156d1ad5743ce786f475a525804c4", "url": "https://github.com/broadinstitute/gatk/commit/3146dabf366156d1ad5743ce786f475a525804c4", "message": "Added new tool ReferenceBlockConcordance to evaluate concordance of GVCF files\n\n- Tool creates histograms to reflect differences in the composition reference blocks in GVCF files\n- Integration tests", "committedDate": "2020-09-09T12:58:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5ODQwOA==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r485598408", "bodyText": "Writing a MetricsFile histogram works with Pair<Integer, Integer>, however, reading that is currently not supported. I could modify htsjdk (specifically FormatUtil) to add support for reading generic objects, or should we just use a string instead?", "author": "michaelgatzen", "createdAt": "2020-09-09T13:10:37Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();", "originalCommit": "3146dabf366156d1ad5743ce786f475a525804c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzOTkwMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r486639901", "bodyText": "It's not thrilling that the write -> read cycle will result in a different type than was started with, but I think making this a Histogram<String> instead of a Histogram<Pair<Integer, Integer>> isn't really necessary.  It feels better to have these private fields be clearer even if technically when you read in the metric later (in your tests for example) the type is different.", "author": "kachulis", "createdAt": "2020-09-10T21:19:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5ODQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4NTYyOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487185629", "bodyText": "though I could certainly be convinced differently on this", "author": "kachulis", "createdAt": "2020-09-11T17:24:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5ODQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2NTgyNw==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487865827", "bodyText": "I absolutely agree with you that it would be better to use pairs internally, the problem is that Picard writes the type into the header of the metrics file, so it's not possible to write a Histogram and read a Histogram unfortunately...", "author": "michaelgatzen", "createdAt": "2020-09-14T12:17:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5ODQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5OTg2Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r485599862", "bodyText": "In every case I have come across the number of genotypes is always 1 for a symbolic variant, otherwise it would be of type \"mixed\". Or is there a case I haven't considered?", "author": "michaelgatzen", "createdAt": "2020-09-09T13:12:48Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();\n+    private final Histogram<String> confidenceConcordanceHistogram = new Histogram<>();\n+\n+    private VariantContext currentTruthVariantContext = null;\n+    private VariantContext currentEvalVariantContext = null;\n+    private String currentContig = null;\n+\n+    @Override\n+    protected Predicate<VariantContext> makeTruthVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return vc -> !vc.isStructuralIndel();\n+    }\n+\n+    @Override\n+    protected Predicate<VariantContext> makeEvalVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return vc -> !vc.isStructuralIndel();\n+    }\n+\n+    private boolean isNonRef(VariantContext variantContext) {\n+        return variantContext.isSymbolic() && variantContext.getAlternateAllele(0).isNonRefAllele();\n+    }\n+\n+    private void evaluateEndOfContig() {\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), jointBlockLength);\n+            }\n+        }\n+\n+        currentTruthVariantContext = null;\n+        currentEvalVariantContext = null;\n+        currentContig = null;\n+    }\n+\n+    private void evaluateNewContig(TruthVersusEval truthVersusEval) {\n+        // If not beginning of file\n+        if (currentContig != null) {\n+            evaluateEndOfContig();\n+        }\n+\n+        currentContig = truthVersusEval.getTruthIfPresentElseEval().getContig();\n+    }\n+\n+    @Override\n+    protected void apply(TruthVersusEval truthVersusEval, ReadsContext readsContext, ReferenceContext refContext) {\n+        // New contig or beginning of file\n+        if (!truthVersusEval.getTruthIfPresentElseEval().getContig().equals(currentContig)) {\n+            evaluateNewContig(truthVersusEval);\n+        }\n+\n+        // Evaluate only when currently seeing two NON_REF blocks\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            // It is possible that jointBlockLength is negative if there is a gap in one file and the start of a new block in the other file.\n+            // Since there is no overlap though, we can just skip that case.\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), blockEnd - blockStart + 1);\n+            }\n+\n+            int currentPosition = truthVersusEval.getTruthIfPresentElseEval().getStart();\n+            if (truthVersusEval.hasTruth() || currentPosition >= currentTruthVariantContext.getEnd()) {\n+                currentTruthVariantContext = null;\n+            }\n+            if (truthVersusEval.hasEval() || currentPosition >= currentEvalVariantContext.getEnd()) {\n+                currentEvalVariantContext = null;\n+            }\n+        }\n+\n+        // Truth\n+        if (truthVersusEval.hasTruth() && isNonRef(truthVersusEval.getTruth())) {\n+            currentTruthVariantContext = truthVersusEval.getTruth();\n+\n+            // The end is inclusive, thus the plus one when calculating the length\n+            int blockLength = truthVersusEval.getTruth().getEnd() - truthVersusEval.getTruth().getStart() + 1;\n+\n+            // TODO can a non_ref block ever have a number of genotypes != 1?\n+            if(truthVersusEval.getTruth().getGenotypes().size() != 1) {\n+                throw new IllegalStateException(String.format(\"The NON_REF block \\\"%s\\\" has more than one genotype, which is not supported.\", truthVersusEval.getTruth().toStringDecodeGenotypes()));\n+            }", "originalCommit": "3146dabf366156d1ad5743ce786f475a525804c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzNTg4Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487135887", "bodyText": "The number of genotypes is actually the number of samples in the gvcf (one genotype per sample).  At the moment I think it's reasonable to focus this tool on single sample gvcfs only, so keeping this check is good (though should adjust the error message to clarify that we have been given a multisample gvcf, which isn't yet supported).  could add support for multisample gvcf in the future if the need arises.", "author": "kachulis", "createdAt": "2020-09-11T15:51:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5OTg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3MTAzMw==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487871033", "bodyText": "done", "author": "michaelgatzen", "createdAt": "2020-09-14T12:26:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5OTg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYwMDAyNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r485600025", "bodyText": "Is it fine to use a test file from a different tool or should I copy it?", "author": "michaelgatzen", "createdAt": "2020-09-09T13:13:03Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -0,0 +1,436 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Created by Michael Gatzen on 9/9/20.\n+ */\n+public class ReferenceBlockConcordanceIntegrationTest extends CommandLineProgramTest{\n+\n+    private static final String CONCORDANCE_TEST_DIR = toolsTestDir + \"concordance/\";\n+    private static final String HAPLOTYPECALLER_TEST_DIR = toolsTestDir + \"haplotypecaller/\";\n+\n+    @Test\n+    public void testIdentical() throws Exception {\n+        // TODO Is it fine to use a test file from a different tool or should I copy it?\n+        final File truthVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final File evalVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");", "originalCommit": "3146dabf366156d1ad5743ce786f475a525804c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1NzY0MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487157641", "bodyText": "Seems fine to me, no reason to be duplicating storage", "author": "kachulis", "createdAt": "2020-09-11T16:31:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYwMDAyNQ=="}], "type": "inlineReview"}, {"oid": "df904bc0857d2939326188ce3932e9f3601838fd", "url": "https://github.com/broadinstitute/gatk/commit/df904bc0857d2939326188ce3932e9f3601838fd", "message": "Update to variant filtering\n\n- Adjusted filtering to only include symbolic variants, as other variants are irrelevant to this tool", "committedDate": "2020-09-11T15:23:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4MjA0NA==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r486582044", "bodyText": "occurrences", "author": "kachulis", "createdAt": "2020-09-10T19:24:30Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>", "originalCommit": "3146dabf366156d1ad5743ce786f475a525804c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4MzQwMw==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r486583403", "bodyText": "could you clarify the only bases in reference blocks in both files are considered", "author": "kachulis", "createdAt": "2020-09-10T19:27:02Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>", "originalCommit": "3146dabf366156d1ad5743ce786f475a525804c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4NDQzMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r486584431", "bodyText": "I think this could be slightly clearer.  Something like \"... means that there are 10 bases which sumultaneously have a reference confidence of 80 in the truth GVCF and a reference confidence of 90 in the evalGVCF\"", "author": "kachulis", "createdAt": "2020-09-10T19:29:08Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +", "originalCommit": "3146dabf366156d1ad5743ce786f475a525804c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3NTE5Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487075193", "bodyText": "I think the Truth and Eval code here could be refactored into a single method", "author": "kachulis", "createdAt": "2020-09-11T14:16:31Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();\n+    private final Histogram<String> confidenceConcordanceHistogram = new Histogram<>();\n+\n+    private VariantContext currentTruthVariantContext = null;\n+    private VariantContext currentEvalVariantContext = null;\n+    private String currentContig = null;\n+\n+    @Override\n+    protected Predicate<VariantContext> makeTruthVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return vc -> !vc.isStructuralIndel();\n+    }\n+\n+    @Override\n+    protected Predicate<VariantContext> makeEvalVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return vc -> !vc.isStructuralIndel();\n+    }\n+\n+    private boolean isNonRef(VariantContext variantContext) {\n+        return variantContext.isSymbolic() && variantContext.getAlternateAllele(0).isNonRefAllele();\n+    }\n+\n+    private void evaluateEndOfContig() {\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), jointBlockLength);\n+            }\n+        }\n+\n+        currentTruthVariantContext = null;\n+        currentEvalVariantContext = null;\n+        currentContig = null;\n+    }\n+\n+    private void evaluateNewContig(TruthVersusEval truthVersusEval) {\n+        // If not beginning of file\n+        if (currentContig != null) {\n+            evaluateEndOfContig();\n+        }\n+\n+        currentContig = truthVersusEval.getTruthIfPresentElseEval().getContig();\n+    }\n+\n+    @Override\n+    protected void apply(TruthVersusEval truthVersusEval, ReadsContext readsContext, ReferenceContext refContext) {\n+        // New contig or beginning of file\n+        if (!truthVersusEval.getTruthIfPresentElseEval().getContig().equals(currentContig)) {\n+            evaluateNewContig(truthVersusEval);\n+        }\n+\n+        // Evaluate only when currently seeing two NON_REF blocks\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            // It is possible that jointBlockLength is negative if there is a gap in one file and the start of a new block in the other file.\n+            // Since there is no overlap though, we can just skip that case.\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), blockEnd - blockStart + 1);\n+            }\n+\n+            int currentPosition = truthVersusEval.getTruthIfPresentElseEval().getStart();\n+            if (truthVersusEval.hasTruth() || currentPosition >= currentTruthVariantContext.getEnd()) {\n+                currentTruthVariantContext = null;\n+            }\n+            if (truthVersusEval.hasEval() || currentPosition >= currentEvalVariantContext.getEnd()) {\n+                currentEvalVariantContext = null;\n+            }\n+        }\n+\n+        // Truth", "originalCommit": "3146dabf366156d1ad5743ce786f475a525804c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3NjE1Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487076152", "bodyText": "Would be easier to get a SimpleInterval object for each vc, and then use those for intersection/length instead of calculating those yourself", "author": "kachulis", "createdAt": "2020-09-11T14:17:59Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();\n+    private final Histogram<String> confidenceConcordanceHistogram = new Histogram<>();\n+\n+    private VariantContext currentTruthVariantContext = null;\n+    private VariantContext currentEvalVariantContext = null;\n+    private String currentContig = null;\n+\n+    @Override\n+    protected Predicate<VariantContext> makeTruthVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return vc -> !vc.isStructuralIndel();\n+    }\n+\n+    @Override\n+    protected Predicate<VariantContext> makeEvalVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return vc -> !vc.isStructuralIndel();\n+    }\n+\n+    private boolean isNonRef(VariantContext variantContext) {\n+        return variantContext.isSymbolic() && variantContext.getAlternateAllele(0).isNonRefAllele();\n+    }\n+\n+    private void evaluateEndOfContig() {\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), jointBlockLength);\n+            }\n+        }\n+\n+        currentTruthVariantContext = null;\n+        currentEvalVariantContext = null;\n+        currentContig = null;\n+    }\n+\n+    private void evaluateNewContig(TruthVersusEval truthVersusEval) {\n+        // If not beginning of file\n+        if (currentContig != null) {\n+            evaluateEndOfContig();\n+        }\n+\n+        currentContig = truthVersusEval.getTruthIfPresentElseEval().getContig();\n+    }\n+\n+    @Override\n+    protected void apply(TruthVersusEval truthVersusEval, ReadsContext readsContext, ReferenceContext refContext) {\n+        // New contig or beginning of file\n+        if (!truthVersusEval.getTruthIfPresentElseEval().getContig().equals(currentContig)) {\n+            evaluateNewContig(truthVersusEval);\n+        }\n+\n+        // Evaluate only when currently seeing two NON_REF blocks\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());", "originalCommit": "3146dabf366156d1ad5743ce786f475a525804c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA4NDYwOA==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487084608", "bodyText": "input/output files should be GATKPath", "author": "kachulis", "createdAt": "2020-09-11T14:31:20Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;", "originalCommit": "3146dabf366156d1ad5743ce786f475a525804c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NTUzOA==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487145538", "bodyText": "I think that instead of checking for a symbolic variant you want to instead check that the genotype of the single sample is homref", "author": "kachulis", "createdAt": "2020-09-11T16:08:49Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();\n+    private final Histogram<String> confidenceConcordanceHistogram = new Histogram<>();\n+\n+    private VariantContext currentTruthVariantContext = null;\n+    private VariantContext currentEvalVariantContext = null;\n+    private String currentContig = null;\n+\n+    @Override\n+    protected Predicate<VariantContext> makeTruthVariantFilter() {", "originalCommit": "df904bc0857d2939326188ce3932e9f3601838fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NjA4Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487146083", "bodyText": "instead of checking for the <NON_REF> symbolic allele, just check that the called genotype is hom_ref.  would change the name of the method to reflect this as well.", "author": "kachulis", "createdAt": "2020-09-11T16:09:52Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();\n+    private final Histogram<String> confidenceConcordanceHistogram = new Histogram<>();\n+\n+    private VariantContext currentTruthVariantContext = null;\n+    private VariantContext currentEvalVariantContext = null;\n+    private String currentContig = null;\n+\n+    @Override\n+    protected Predicate<VariantContext> makeTruthVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    @Override\n+    protected Predicate<VariantContext> makeEvalVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    private boolean isNonRef(VariantContext variantContext) {", "originalCommit": "df904bc0857d2939326188ce3932e9f3601838fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM2Njk4MA==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r489366980", "bodyText": "I agree with moving the checks into the filter, but checking for hom_ref is actually different than checking if the first alt allele is non_ref. There are for instance variants with alt alleles <NON_REF>, A which have type mixed (and not hom_ref). Should these be treated as reference blocks?", "author": "michaelgatzen", "createdAt": "2020-09-16T11:34:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NjA4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM3ODAzNw==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r489378037", "bodyText": "After digging into this question a bit more, there is a tool ReblockGVCF which has a has a method isHomRefBlock which returns variantContext.getLog10PError() == VariantContext.NO_LOG10_PERROR, which seems an interesting criterion to me?", "author": "michaelgatzen", "createdAt": "2020-09-16T11:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NjA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NzYyMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487147621", "bodyText": "move the isNonRef (or isHomRef) check into the VariantFilters", "author": "kachulis", "createdAt": "2020-09-11T16:12:42Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();\n+    private final Histogram<String> confidenceConcordanceHistogram = new Histogram<>();\n+\n+    private VariantContext currentTruthVariantContext = null;\n+    private VariantContext currentEvalVariantContext = null;\n+    private String currentContig = null;\n+\n+    @Override\n+    protected Predicate<VariantContext> makeTruthVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    @Override\n+    protected Predicate<VariantContext> makeEvalVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    private boolean isNonRef(VariantContext variantContext) {\n+        return variantContext.isSymbolic() && variantContext.getAlternateAllele(0).isNonRefAllele();\n+    }\n+\n+    private void evaluateEndOfContig() {\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), jointBlockLength);\n+            }\n+        }\n+\n+        currentTruthVariantContext = null;\n+        currentEvalVariantContext = null;\n+        currentContig = null;\n+    }\n+\n+    private void evaluateNewContig(TruthVersusEval truthVersusEval) {\n+        // If not beginning of file\n+        if (currentContig != null) {\n+            evaluateEndOfContig();\n+        }\n+\n+        currentContig = truthVersusEval.getTruthIfPresentElseEval().getContig();\n+    }\n+\n+    @Override\n+    protected void apply(TruthVersusEval truthVersusEval, ReadsContext readsContext, ReferenceContext refContext) {\n+        // New contig or beginning of file\n+        if (!truthVersusEval.getTruthIfPresentElseEval().getContig().equals(currentContig)) {\n+            evaluateNewContig(truthVersusEval);\n+        }\n+\n+        // Evaluate only when currently seeing two NON_REF blocks\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            // It is possible that jointBlockLength is negative if there is a gap in one file and the start of a new block in the other file.\n+            // Since there is no overlap though, we can just skip that case.\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), blockEnd - blockStart + 1);\n+            }\n+\n+            int currentPosition = truthVersusEval.getTruthIfPresentElseEval().getStart();\n+            if (truthVersusEval.hasTruth() || currentPosition >= currentTruthVariantContext.getEnd()) {\n+                currentTruthVariantContext = null;\n+            }\n+            if (truthVersusEval.hasEval() || currentPosition >= currentEvalVariantContext.getEnd()) {\n+                currentEvalVariantContext = null;\n+            }\n+        }\n+\n+        // Truth\n+        if (truthVersusEval.hasTruth() && isNonRef(truthVersusEval.getTruth())) {", "originalCommit": "df904bc0857d2939326188ce3932e9f3601838fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0ODA3Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487148073", "bodyText": "final", "author": "kachulis", "createdAt": "2020-09-11T16:13:34Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();\n+    private final Histogram<String> confidenceConcordanceHistogram = new Histogram<>();\n+\n+    private VariantContext currentTruthVariantContext = null;\n+    private VariantContext currentEvalVariantContext = null;\n+    private String currentContig = null;\n+\n+    @Override\n+    protected Predicate<VariantContext> makeTruthVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    @Override\n+    protected Predicate<VariantContext> makeEvalVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    private boolean isNonRef(VariantContext variantContext) {\n+        return variantContext.isSymbolic() && variantContext.getAlternateAllele(0).isNonRefAllele();\n+    }\n+\n+    private void evaluateEndOfContig() {\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), jointBlockLength);\n+            }\n+        }\n+\n+        currentTruthVariantContext = null;\n+        currentEvalVariantContext = null;\n+        currentContig = null;\n+    }\n+\n+    private void evaluateNewContig(TruthVersusEval truthVersusEval) {\n+        // If not beginning of file\n+        if (currentContig != null) {\n+            evaluateEndOfContig();\n+        }\n+\n+        currentContig = truthVersusEval.getTruthIfPresentElseEval().getContig();\n+    }\n+\n+    @Override\n+    protected void apply(TruthVersusEval truthVersusEval, ReadsContext readsContext, ReferenceContext refContext) {\n+        // New contig or beginning of file\n+        if (!truthVersusEval.getTruthIfPresentElseEval().getContig().equals(currentContig)) {\n+            evaluateNewContig(truthVersusEval);\n+        }\n+\n+        // Evaluate only when currently seeing two NON_REF blocks\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            // It is possible that jointBlockLength is negative if there is a gap in one file and the start of a new block in the other file.\n+            // Since there is no overlap though, we can just skip that case.\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), blockEnd - blockStart + 1);\n+            }\n+\n+            int currentPosition = truthVersusEval.getTruthIfPresentElseEval().getStart();\n+            if (truthVersusEval.hasTruth() || currentPosition >= currentTruthVariantContext.getEnd()) {\n+                currentTruthVariantContext = null;\n+            }\n+            if (truthVersusEval.hasEval() || currentPosition >= currentEvalVariantContext.getEnd()) {\n+                currentEvalVariantContext = null;\n+            }\n+        }\n+\n+        // Truth\n+        if (truthVersusEval.hasTruth() && isNonRef(truthVersusEval.getTruth())) {\n+            currentTruthVariantContext = truthVersusEval.getTruth();\n+\n+            // The end is inclusive, thus the plus one when calculating the length\n+            int blockLength = truthVersusEval.getTruth().getEnd() - truthVersusEval.getTruth().getStart() + 1;\n+\n+            // TODO can a non_ref block ever have a number of genotypes != 1?\n+            if(truthVersusEval.getTruth().getGenotypes().size() != 1) {\n+                throw new IllegalStateException(String.format(\"The NON_REF block \\\"%s\\\" has more than one genotype, which is not supported.\", truthVersusEval.getTruth().toStringDecodeGenotypes()));\n+            }\n+            Genotype genotype = truthVersusEval.getTruth().getGenotype(0);", "originalCommit": "df904bc0857d2939326188ce3932e9f3601838fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0ODEzOA==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487148138", "bodyText": "final (and wherever else possible as well)", "author": "kachulis", "createdAt": "2020-09-11T16:13:41Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();\n+    private final Histogram<String> confidenceConcordanceHistogram = new Histogram<>();\n+\n+    private VariantContext currentTruthVariantContext = null;\n+    private VariantContext currentEvalVariantContext = null;\n+    private String currentContig = null;\n+\n+    @Override\n+    protected Predicate<VariantContext> makeTruthVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    @Override\n+    protected Predicate<VariantContext> makeEvalVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    private boolean isNonRef(VariantContext variantContext) {\n+        return variantContext.isSymbolic() && variantContext.getAlternateAllele(0).isNonRefAllele();\n+    }\n+\n+    private void evaluateEndOfContig() {\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), jointBlockLength);\n+            }\n+        }\n+\n+        currentTruthVariantContext = null;\n+        currentEvalVariantContext = null;\n+        currentContig = null;\n+    }\n+\n+    private void evaluateNewContig(TruthVersusEval truthVersusEval) {\n+        // If not beginning of file\n+        if (currentContig != null) {\n+            evaluateEndOfContig();\n+        }\n+\n+        currentContig = truthVersusEval.getTruthIfPresentElseEval().getContig();\n+    }\n+\n+    @Override\n+    protected void apply(TruthVersusEval truthVersusEval, ReadsContext readsContext, ReferenceContext refContext) {\n+        // New contig or beginning of file\n+        if (!truthVersusEval.getTruthIfPresentElseEval().getContig().equals(currentContig)) {\n+            evaluateNewContig(truthVersusEval);\n+        }\n+\n+        // Evaluate only when currently seeing two NON_REF blocks\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            // It is possible that jointBlockLength is negative if there is a gap in one file and the start of a new block in the other file.\n+            // Since there is no overlap though, we can just skip that case.\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), blockEnd - blockStart + 1);\n+            }\n+\n+            int currentPosition = truthVersusEval.getTruthIfPresentElseEval().getStart();\n+            if (truthVersusEval.hasTruth() || currentPosition >= currentTruthVariantContext.getEnd()) {\n+                currentTruthVariantContext = null;\n+            }\n+            if (truthVersusEval.hasEval() || currentPosition >= currentEvalVariantContext.getEnd()) {\n+                currentEvalVariantContext = null;\n+            }\n+        }\n+\n+        // Truth\n+        if (truthVersusEval.hasTruth() && isNonRef(truthVersusEval.getTruth())) {\n+            currentTruthVariantContext = truthVersusEval.getTruth();\n+\n+            // The end is inclusive, thus the plus one when calculating the length\n+            int blockLength = truthVersusEval.getTruth().getEnd() - truthVersusEval.getTruth().getStart() + 1;\n+\n+            // TODO can a non_ref block ever have a number of genotypes != 1?\n+            if(truthVersusEval.getTruth().getGenotypes().size() != 1) {\n+                throw new IllegalStateException(String.format(\"The NON_REF block \\\"%s\\\" has more than one genotype, which is not supported.\", truthVersusEval.getTruth().toStringDecodeGenotypes()));\n+            }\n+            Genotype genotype = truthVersusEval.getTruth().getGenotype(0);\n+            int gq = genotype.getGQ();", "originalCommit": "df904bc0857d2939326188ce3932e9f3601838fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1MDM4OA==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487150388", "bodyText": "SimpleInterval instead", "author": "kachulis", "createdAt": "2020-09-11T16:17:46Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();\n+    private final Histogram<String> confidenceConcordanceHistogram = new Histogram<>();\n+\n+    private VariantContext currentTruthVariantContext = null;\n+    private VariantContext currentEvalVariantContext = null;\n+    private String currentContig = null;\n+\n+    @Override\n+    protected Predicate<VariantContext> makeTruthVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    @Override\n+    protected Predicate<VariantContext> makeEvalVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    private boolean isNonRef(VariantContext variantContext) {\n+        return variantContext.isSymbolic() && variantContext.getAlternateAllele(0).isNonRefAllele();\n+    }\n+\n+    private void evaluateEndOfContig() {\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), jointBlockLength);\n+            }\n+        }\n+\n+        currentTruthVariantContext = null;\n+        currentEvalVariantContext = null;\n+        currentContig = null;\n+    }\n+\n+    private void evaluateNewContig(TruthVersusEval truthVersusEval) {\n+        // If not beginning of file\n+        if (currentContig != null) {\n+            evaluateEndOfContig();\n+        }\n+\n+        currentContig = truthVersusEval.getTruthIfPresentElseEval().getContig();\n+    }\n+\n+    @Override\n+    protected void apply(TruthVersusEval truthVersusEval, ReadsContext readsContext, ReferenceContext refContext) {\n+        // New contig or beginning of file\n+        if (!truthVersusEval.getTruthIfPresentElseEval().getContig().equals(currentContig)) {\n+            evaluateNewContig(truthVersusEval);\n+        }\n+\n+        // Evaluate only when currently seeing two NON_REF blocks\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            // It is possible that jointBlockLength is negative if there is a gap in one file and the start of a new block in the other file.\n+            // Since there is no overlap though, we can just skip that case.\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), blockEnd - blockStart + 1);\n+            }\n+\n+            int currentPosition = truthVersusEval.getTruthIfPresentElseEval().getStart();\n+            if (truthVersusEval.hasTruth() || currentPosition >= currentTruthVariantContext.getEnd()) {\n+                currentTruthVariantContext = null;\n+            }\n+            if (truthVersusEval.hasEval() || currentPosition >= currentEvalVariantContext.getEnd()) {\n+                currentEvalVariantContext = null;\n+            }\n+        }\n+\n+        // Truth\n+        if (truthVersusEval.hasTruth() && isNonRef(truthVersusEval.getTruth())) {\n+            currentTruthVariantContext = truthVersusEval.getTruth();\n+\n+            // The end is inclusive, thus the plus one when calculating the length\n+            int blockLength = truthVersusEval.getTruth().getEnd() - truthVersusEval.getTruth().getStart() + 1;\n+\n+            // TODO can a non_ref block ever have a number of genotypes != 1?\n+            if(truthVersusEval.getTruth().getGenotypes().size() != 1) {\n+                throw new IllegalStateException(String.format(\"The NON_REF block \\\"%s\\\" has more than one genotype, which is not supported.\", truthVersusEval.getTruth().toStringDecodeGenotypes()));\n+            }\n+            Genotype genotype = truthVersusEval.getTruth().getGenotype(0);\n+            int gq = genotype.getGQ();\n+            truthBlockHistogram.increment(new Pair<>(blockLength, gq).toString());\n+        }\n+\n+        // Eval\n+        if (truthVersusEval.hasEval() && isNonRef(truthVersusEval.getEval())) {\n+            currentEvalVariantContext = truthVersusEval.getEval();\n+\n+            // The end is inclusive, thus the plus one when calculating the length\n+            int blockLength = truthVersusEval.getEval().getEnd() - truthVersusEval.getEval().getStart() + 1;", "originalCommit": "df904bc0857d2939326188ce3932e9f3601838fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1ODI0NA==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487158244", "bodyText": "Use GVCFWriter instead or rolling you own vcf writer here.", "author": "kachulis", "createdAt": "2020-09-11T16:32:23Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -0,0 +1,436 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Created by Michael Gatzen on 9/9/20.\n+ */\n+public class ReferenceBlockConcordanceIntegrationTest extends CommandLineProgramTest{\n+\n+    private static final String CONCORDANCE_TEST_DIR = toolsTestDir + \"concordance/\";\n+    private static final String HAPLOTYPECALLER_TEST_DIR = toolsTestDir + \"haplotypecaller/\";\n+\n+    @Test\n+    public void testIdentical() throws Exception {\n+        // TODO Is it fine to use a test file from a different tool or should I copy it?\n+        final File truthVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final File evalVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final Path truthBlockHistogramFile = createTempPath(\"truth_block_histogram\", \".tsv\");\n+        final Path evalBlockHistogramFile = createTempPath(\"eval_block_histogram\", \".tsv\");\n+        final Path confidenceConcordanceHistogramFile = createTempPath(\"confidence_concordance_histogram\", \".tsv\");\n+\n+        final String[] args = {\n+                \"--\" + AbstractConcordanceWalker.EVAL_VARIANTS_LONG_NAME, evalVcf.toString(),\n+                \"--\" + AbstractConcordanceWalker.TRUTH_VARIANTS_LONG_NAME, truthVcf.toString(),\n+                \"--\" + ReferenceBlockConcordance.TRUTH_BLOCK_HISTOGRAM_LONG_NAME, truthBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.EVAL_BLOCK_HISTOGRAM_LONG_NAME, evalBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME, confidenceConcordanceHistogramFile.toString(),\n+        };\n+        runCommandLine(args);\n+\n+        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n+        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n+\n+        Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n+        Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n+\n+        Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+        Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+\n+        // Got this number by counting the <NON_REF> alt alleles in the test GVCF file\n+        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1034);\n+        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1034);\n+\n+        // Check block histograms both ways, in case one histogram has more entries than the other\n+        truthBlockHistogram.values().forEach(bin -> {\n+            Assert.assertTrue(evalBlockHistogram.containsKey(bin.getId()));\n+            Assert.assertEquals(bin.getValue(), evalBlockHistogram.get(bin.getId()).getValue());\n+        });\n+\n+        evalBlockHistogram.values().forEach(bin -> {\n+            Assert.assertTrue(truthBlockHistogram.containsKey(bin.getId()));\n+            Assert.assertEquals(bin.getValue(), truthBlockHistogram.get(bin.getId()).getValue());\n+        });\n+\n+        MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n+        confidenceConcordanceMetrics.read(new FileReader(confidenceConcordanceHistogramFile.toFile()));\n+        Assert.assertEquals(confidenceConcordanceMetrics.getNumHistograms(), 1);\n+        Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n+\n+        confidenceConcordanceHistogram.values().forEach(bin -> {\n+            String[] confidenceValues = bin.getId().split(\",\");\n+            Assert.assertEquals(confidenceValues[0], confidenceValues[1]);\n+        });\n+    }\n+\n+    private Pair<File, File> writeTestGVCFs(List<TestReferenceBlockConcordanceVariant> truthVariants, List<TestReferenceBlockConcordanceVariant> evalVariants) throws Exception {\n+        File truthFile = createTempFile(\"truth\", \".gvcf\");\n+        FileWriter writer = new FileWriter(truthFile);\n+        writer.write(\"##fileformat=VCFv4.2\\n\");", "originalCommit": "df904bc0857d2939326188ce3932e9f3601838fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDEzNjk1Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r490136956", "bodyText": "I converted it to use a GVCFWriter but I'm going to leave this comment open, because the code is much much more complicated than the primitive self-made gvcf writer. I agree that in production code we should use existing APIs, but maybe for a test it would be clearer and more fail-safe if it is actually understandable what's happening? You can make the call (once I push the changes), I'm fine either way", "author": "michaelgatzen", "createdAt": "2020-09-17T10:25:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1ODI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2MTEwMw==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487161103", "bodyText": "This looks like something you could just use VariantContext for instead.", "author": "kachulis", "createdAt": "2020-09-11T16:37:55Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -0,0 +1,436 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Created by Michael Gatzen on 9/9/20.\n+ */\n+public class ReferenceBlockConcordanceIntegrationTest extends CommandLineProgramTest{\n+\n+    private static final String CONCORDANCE_TEST_DIR = toolsTestDir + \"concordance/\";\n+    private static final String HAPLOTYPECALLER_TEST_DIR = toolsTestDir + \"haplotypecaller/\";\n+\n+    @Test\n+    public void testIdentical() throws Exception {\n+        // TODO Is it fine to use a test file from a different tool or should I copy it?\n+        final File truthVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final File evalVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final Path truthBlockHistogramFile = createTempPath(\"truth_block_histogram\", \".tsv\");\n+        final Path evalBlockHistogramFile = createTempPath(\"eval_block_histogram\", \".tsv\");\n+        final Path confidenceConcordanceHistogramFile = createTempPath(\"confidence_concordance_histogram\", \".tsv\");\n+\n+        final String[] args = {\n+                \"--\" + AbstractConcordanceWalker.EVAL_VARIANTS_LONG_NAME, evalVcf.toString(),\n+                \"--\" + AbstractConcordanceWalker.TRUTH_VARIANTS_LONG_NAME, truthVcf.toString(),\n+                \"--\" + ReferenceBlockConcordance.TRUTH_BLOCK_HISTOGRAM_LONG_NAME, truthBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.EVAL_BLOCK_HISTOGRAM_LONG_NAME, evalBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME, confidenceConcordanceHistogramFile.toString(),\n+        };\n+        runCommandLine(args);\n+\n+        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n+        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n+\n+        Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n+        Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n+\n+        Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+        Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+\n+        // Got this number by counting the <NON_REF> alt alleles in the test GVCF file\n+        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1034);\n+        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1034);\n+\n+        // Check block histograms both ways, in case one histogram has more entries than the other\n+        truthBlockHistogram.values().forEach(bin -> {\n+            Assert.assertTrue(evalBlockHistogram.containsKey(bin.getId()));\n+            Assert.assertEquals(bin.getValue(), evalBlockHistogram.get(bin.getId()).getValue());\n+        });\n+\n+        evalBlockHistogram.values().forEach(bin -> {\n+            Assert.assertTrue(truthBlockHistogram.containsKey(bin.getId()));\n+            Assert.assertEquals(bin.getValue(), truthBlockHistogram.get(bin.getId()).getValue());\n+        });\n+\n+        MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n+        confidenceConcordanceMetrics.read(new FileReader(confidenceConcordanceHistogramFile.toFile()));\n+        Assert.assertEquals(confidenceConcordanceMetrics.getNumHistograms(), 1);\n+        Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n+\n+        confidenceConcordanceHistogram.values().forEach(bin -> {\n+            String[] confidenceValues = bin.getId().split(\",\");\n+            Assert.assertEquals(confidenceValues[0], confidenceValues[1]);\n+        });\n+    }\n+\n+    private Pair<File, File> writeTestGVCFs(List<TestReferenceBlockConcordanceVariant> truthVariants, List<TestReferenceBlockConcordanceVariant> evalVariants) throws Exception {\n+        File truthFile = createTempFile(\"truth\", \".gvcf\");\n+        FileWriter writer = new FileWriter(truthFile);\n+        writer.write(\"##fileformat=VCFv4.2\\n\");\n+        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n+        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n+        for (TestReferenceBlockConcordanceVariant variant : truthVariants) {\n+            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n+                    variant.start,\n+                    variant.getAltAllele(),\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n+                    variant.getConfidence()));\n+        }\n+        writer.close();\n+\n+        File evalFile = createTempFile(\"eval\", \".gvcf\");\n+        writer = new FileWriter(evalFile);\n+        writer.write(\"##fileformat=VCFv4.2\\n\");\n+        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n+        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n+        for (TestReferenceBlockConcordanceVariant variant : evalVariants) {\n+            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n+                    variant.start,\n+                    variant.getAltAllele(),\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n+                    variant.getConfidence()));\n+        }\n+        writer.close();\n+\n+        return new Pair<>(truthFile, evalFile);\n+    }\n+\n+    @DataProvider\n+    public Object[][] provideSyntheticGVCFs() {\n+        return new Object[][] {\n+                // No non_ref blocks\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 1, 1, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 1, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"1,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Two non_ref blocks\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 1, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 1, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"1,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"1,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Start with gap then variant\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 5, 5, 99),\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 6, 10, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"5,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 5}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Start with gap then non_ref\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 6, 10, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"5,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 5}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Start with single block\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 11, 20, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 3, 6, 98),\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 11, 20, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"4,98\", 1},\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 10}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // No overlap at all\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 11, 20, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 3, 6, 98)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"4,98\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // End with var\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 9, 99),\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 10, 10, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"9,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 9}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // End with var then gap\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 7, 99),\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 8, 8, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"7,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 7}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // End with gap then var\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 7, 99),\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 10, 10, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"7,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 7}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"provideSyntheticGVCFs\")\n+    public void testSyntheticGVCFs(final List<TestReferenceBlockConcordanceVariant> truthVariants, final List<TestReferenceBlockConcordanceVariant> evalVariants, final Map<String, Integer> expectedTruthBlockHistogram, final Map<String, Integer> expectedEvalBlockHistogram, final Map<String, Integer> expectedConfidenceConcordance) throws Exception {\n+        Pair<File, File> inputFiles = writeTestGVCFs(truthVariants, evalVariants);\n+\n+        final Path truthBlockHistogramFile = createTempPath(\"truth_block_histogram\", \".tsv\");\n+        final Path evalBlockHistogramFile = createTempPath(\"eval_block_histogram\", \".tsv\");\n+        final Path confidenceConcordanceHistogramFile = createTempPath(\"confidence_concordance_histogram\", \".tsv\");\n+\n+        final String[] args = {\n+                \"--\" + AbstractConcordanceWalker.TRUTH_VARIANTS_LONG_NAME, inputFiles.getLeft().toString(),\n+                \"--\" + AbstractConcordanceWalker.EVAL_VARIANTS_LONG_NAME, inputFiles.getRight().toString(),\n+                \"--\" + ReferenceBlockConcordance.TRUTH_BLOCK_HISTOGRAM_LONG_NAME, truthBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.EVAL_BLOCK_HISTOGRAM_LONG_NAME, evalBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME, confidenceConcordanceHistogramFile.toString(),\n+        };\n+        runCommandLine(args);\n+\n+        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n+        if (truthBlockMetrics.getNumHistograms() > 0) {\n+            Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n+            Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+            // Check value and remove entry from expected histogram...\n+            truthBlockHistogram.values().forEach(bin -> {\n+                Assert.assertTrue(expectedTruthBlockHistogram.containsKey(bin.getId()));\n+                Assert.assertEquals(bin.getValue(), (double) expectedTruthBlockHistogram.get(bin.getId()));\n+                expectedTruthBlockHistogram.remove(bin.getId());\n+            });\n+            // ... and make sure it is empty and all values have been visited\n+        }\n+        Assert.assertEquals(expectedTruthBlockHistogram.size(), 0);\n+\n+        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n+        if (evalBlockMetrics.getNumHistograms() > 0) {\n+            Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n+            Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+            // Check value and remove entry from expected histogram...\n+            evalBlockHistogram.values().forEach(bin -> {\n+                Assert.assertTrue(expectedEvalBlockHistogram.containsKey(bin.getId()));\n+                Assert.assertEquals(bin.getValue(), (double) expectedEvalBlockHistogram.get(bin.getId()));\n+                expectedEvalBlockHistogram.remove(bin.getId());\n+            });\n+            // ... and make sure it is empty and all values have been visited\n+        }\n+        Assert.assertEquals(expectedEvalBlockHistogram.size(), 0);\n+\n+        MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n+        confidenceConcordanceMetrics.read(new FileReader(confidenceConcordanceHistogramFile.toFile()));\n+        if (confidenceConcordanceMetrics.getNumHistograms() > 0) {\n+            Assert.assertEquals(confidenceConcordanceMetrics.getNumHistograms(), 1);\n+            Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n+            // Check value and remove entry from expected histogram...\n+            confidenceConcordanceHistogram.values().forEach(bin -> {\n+                Assert.assertTrue(expectedConfidenceConcordance.containsKey(bin.getId()));\n+                Assert.assertEquals(bin.getValue(), (double) expectedConfidenceConcordance.get(bin.getId()));\n+                expectedConfidenceConcordance.remove(bin.getId());\n+            });\n+            // ... and make sure it is empty and all values have been visited\n+        }\n+        Assert.assertEquals(expectedConfidenceConcordance.size(), 0);\n+    }\n+\n+    @Test\n+    public void testDoesNotCrashWithNO_VARIATIONAlleles() {\n+        final File evalVcf = new File(CONCORDANCE_TEST_DIR, \"noVariationAlleles.vcf\");\n+        final File truthVcf = new File(CONCORDANCE_TEST_DIR, \"noVariationAlleles.vcf\");\n+\n+        final String[] args = {\n+                \"--\" + AbstractConcordanceWalker.EVAL_VARIANTS_LONG_NAME, evalVcf.toString(),\n+                \"--\" + AbstractConcordanceWalker.TRUTH_VARIANTS_LONG_NAME, truthVcf.toString(),\n+                \"--\" + ReferenceBlockConcordance.TRUTH_BLOCK_HISTOGRAM_LONG_NAME, \"/dev/null\",\n+                \"--\" + ReferenceBlockConcordance.EVAL_BLOCK_HISTOGRAM_LONG_NAME, \"/dev/null\",\n+                \"--\" + ReferenceBlockConcordance.CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME, \"/dev/null\",\n+        };\n+\n+        runCommandLine(args);\n+    }\n+\n+    static class TestReferenceBlockConcordanceVariant {", "originalCommit": "df904bc0857d2939326188ce3932e9f3601838fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE0NjE4MA==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r490146180", "bodyText": "see below", "author": "michaelgatzen", "createdAt": "2020-09-17T10:43:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2MTEwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2MTQ5Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487161492", "bodyText": "Aren't these just VariantContexts?  Is there are reason you need your own class for these?", "author": "kachulis", "createdAt": "2020-09-11T16:38:34Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -0,0 +1,436 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Created by Michael Gatzen on 9/9/20.\n+ */\n+public class ReferenceBlockConcordanceIntegrationTest extends CommandLineProgramTest{\n+\n+    private static final String CONCORDANCE_TEST_DIR = toolsTestDir + \"concordance/\";\n+    private static final String HAPLOTYPECALLER_TEST_DIR = toolsTestDir + \"haplotypecaller/\";\n+\n+    @Test\n+    public void testIdentical() throws Exception {\n+        // TODO Is it fine to use a test file from a different tool or should I copy it?\n+        final File truthVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final File evalVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final Path truthBlockHistogramFile = createTempPath(\"truth_block_histogram\", \".tsv\");\n+        final Path evalBlockHistogramFile = createTempPath(\"eval_block_histogram\", \".tsv\");\n+        final Path confidenceConcordanceHistogramFile = createTempPath(\"confidence_concordance_histogram\", \".tsv\");\n+\n+        final String[] args = {\n+                \"--\" + AbstractConcordanceWalker.EVAL_VARIANTS_LONG_NAME, evalVcf.toString(),\n+                \"--\" + AbstractConcordanceWalker.TRUTH_VARIANTS_LONG_NAME, truthVcf.toString(),\n+                \"--\" + ReferenceBlockConcordance.TRUTH_BLOCK_HISTOGRAM_LONG_NAME, truthBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.EVAL_BLOCK_HISTOGRAM_LONG_NAME, evalBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME, confidenceConcordanceHistogramFile.toString(),\n+        };\n+        runCommandLine(args);\n+\n+        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n+        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n+\n+        Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n+        Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n+\n+        Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+        Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+\n+        // Got this number by counting the <NON_REF> alt alleles in the test GVCF file\n+        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1034);\n+        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1034);\n+\n+        // Check block histograms both ways, in case one histogram has more entries than the other\n+        truthBlockHistogram.values().forEach(bin -> {\n+            Assert.assertTrue(evalBlockHistogram.containsKey(bin.getId()));\n+            Assert.assertEquals(bin.getValue(), evalBlockHistogram.get(bin.getId()).getValue());\n+        });\n+\n+        evalBlockHistogram.values().forEach(bin -> {\n+            Assert.assertTrue(truthBlockHistogram.containsKey(bin.getId()));\n+            Assert.assertEquals(bin.getValue(), truthBlockHistogram.get(bin.getId()).getValue());\n+        });\n+\n+        MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n+        confidenceConcordanceMetrics.read(new FileReader(confidenceConcordanceHistogramFile.toFile()));\n+        Assert.assertEquals(confidenceConcordanceMetrics.getNumHistograms(), 1);\n+        Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n+\n+        confidenceConcordanceHistogram.values().forEach(bin -> {\n+            String[] confidenceValues = bin.getId().split(\",\");\n+            Assert.assertEquals(confidenceValues[0], confidenceValues[1]);\n+        });\n+    }\n+\n+    private Pair<File, File> writeTestGVCFs(List<TestReferenceBlockConcordanceVariant> truthVariants, List<TestReferenceBlockConcordanceVariant> evalVariants) throws Exception {\n+        File truthFile = createTempFile(\"truth\", \".gvcf\");\n+        FileWriter writer = new FileWriter(truthFile);\n+        writer.write(\"##fileformat=VCFv4.2\\n\");\n+        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n+        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n+        for (TestReferenceBlockConcordanceVariant variant : truthVariants) {\n+            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n+                    variant.start,\n+                    variant.getAltAllele(),\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n+                    variant.getConfidence()));\n+        }\n+        writer.close();\n+\n+        File evalFile = createTempFile(\"eval\", \".gvcf\");\n+        writer = new FileWriter(evalFile);\n+        writer.write(\"##fileformat=VCFv4.2\\n\");\n+        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n+        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n+        for (TestReferenceBlockConcordanceVariant variant : evalVariants) {\n+            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n+                    variant.start,\n+                    variant.getAltAllele(),\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n+                    variant.getConfidence()));\n+        }\n+        writer.close();\n+\n+        return new Pair<>(truthFile, evalFile);\n+    }\n+\n+    @DataProvider\n+    public Object[][] provideSyntheticGVCFs() {\n+        return new Object[][] {\n+                // No non_ref blocks\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 1, 1, 99)", "originalCommit": "df904bc0857d2939326188ce3932e9f3601838fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE0NjExMw==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r490146113", "bodyText": "Similar issue to the GVCFWriter. Yes, a VariantContext can definitely hold all necessary information, but you can't just initialize it in one line. Instead you have to use a VariantContextBuilder and then add to that the genotypes and for that you have to use a GenotypeBuilder. My reasoning here was to be able to create test conditions easily and in a way that makes it absolutely clear what is happening, so that you can check the expected outcome by simply looking at the lines above.\nAgain, I agree that this is not the most efficient programming, but for the sake of clarity and robustness in test code maybe acceptable? What I did now is convert these four arguments (ALT allele, start, end, confidence) to an Object[], which achieves the goal of having all information in one line and getting rid of the extra class. Let me know what you think", "author": "michaelgatzen", "createdAt": "2020-09-17T10:42:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2MTQ5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI0ODAwMw==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r490248003", "bodyText": "Actually never mind, I moved the construction of a VariantContext to a static method, so you can create that object easily in the test condition definition, which is much more elegant than my original solution.", "author": "michaelgatzen", "createdAt": "2020-09-17T13:31:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2MTQ5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4MDA5Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487180093", "bodyText": "Histogram has an equals method you can use instead", "author": "kachulis", "createdAt": "2020-09-11T17:14:09Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -0,0 +1,436 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Created by Michael Gatzen on 9/9/20.\n+ */\n+public class ReferenceBlockConcordanceIntegrationTest extends CommandLineProgramTest{\n+\n+    private static final String CONCORDANCE_TEST_DIR = toolsTestDir + \"concordance/\";\n+    private static final String HAPLOTYPECALLER_TEST_DIR = toolsTestDir + \"haplotypecaller/\";\n+\n+    @Test\n+    public void testIdentical() throws Exception {\n+        // TODO Is it fine to use a test file from a different tool or should I copy it?\n+        final File truthVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final File evalVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final Path truthBlockHistogramFile = createTempPath(\"truth_block_histogram\", \".tsv\");\n+        final Path evalBlockHistogramFile = createTempPath(\"eval_block_histogram\", \".tsv\");\n+        final Path confidenceConcordanceHistogramFile = createTempPath(\"confidence_concordance_histogram\", \".tsv\");\n+\n+        final String[] args = {\n+                \"--\" + AbstractConcordanceWalker.EVAL_VARIANTS_LONG_NAME, evalVcf.toString(),\n+                \"--\" + AbstractConcordanceWalker.TRUTH_VARIANTS_LONG_NAME, truthVcf.toString(),\n+                \"--\" + ReferenceBlockConcordance.TRUTH_BLOCK_HISTOGRAM_LONG_NAME, truthBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.EVAL_BLOCK_HISTOGRAM_LONG_NAME, evalBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME, confidenceConcordanceHistogramFile.toString(),\n+        };\n+        runCommandLine(args);\n+\n+        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n+        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n+\n+        Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n+        Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n+\n+        Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+        Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+\n+        // Got this number by counting the <NON_REF> alt alleles in the test GVCF file\n+        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1034);\n+        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1034);\n+\n+        // Check block histograms both ways, in case one histogram has more entries than the other\n+        truthBlockHistogram.values().forEach(bin -> {", "originalCommit": "df904bc0857d2939326188ce3932e9f3601838fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4MzYwMw==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487183603", "bodyText": "if you make the expected histograms actual Histogram objects you can just use the Histogram::equals method.", "author": "kachulis", "createdAt": "2020-09-11T17:20:52Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -0,0 +1,436 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Created by Michael Gatzen on 9/9/20.\n+ */\n+public class ReferenceBlockConcordanceIntegrationTest extends CommandLineProgramTest{\n+\n+    private static final String CONCORDANCE_TEST_DIR = toolsTestDir + \"concordance/\";\n+    private static final String HAPLOTYPECALLER_TEST_DIR = toolsTestDir + \"haplotypecaller/\";\n+\n+    @Test\n+    public void testIdentical() throws Exception {\n+        // TODO Is it fine to use a test file from a different tool or should I copy it?\n+        final File truthVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final File evalVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final Path truthBlockHistogramFile = createTempPath(\"truth_block_histogram\", \".tsv\");\n+        final Path evalBlockHistogramFile = createTempPath(\"eval_block_histogram\", \".tsv\");\n+        final Path confidenceConcordanceHistogramFile = createTempPath(\"confidence_concordance_histogram\", \".tsv\");\n+\n+        final String[] args = {\n+                \"--\" + AbstractConcordanceWalker.EVAL_VARIANTS_LONG_NAME, evalVcf.toString(),\n+                \"--\" + AbstractConcordanceWalker.TRUTH_VARIANTS_LONG_NAME, truthVcf.toString(),\n+                \"--\" + ReferenceBlockConcordance.TRUTH_BLOCK_HISTOGRAM_LONG_NAME, truthBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.EVAL_BLOCK_HISTOGRAM_LONG_NAME, evalBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME, confidenceConcordanceHistogramFile.toString(),\n+        };\n+        runCommandLine(args);\n+\n+        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n+        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n+\n+        Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n+        Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n+\n+        Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+        Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+\n+        // Got this number by counting the <NON_REF> alt alleles in the test GVCF file\n+        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1034);\n+        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1034);\n+\n+        // Check block histograms both ways, in case one histogram has more entries than the other\n+        truthBlockHistogram.values().forEach(bin -> {\n+            Assert.assertTrue(evalBlockHistogram.containsKey(bin.getId()));\n+            Assert.assertEquals(bin.getValue(), evalBlockHistogram.get(bin.getId()).getValue());\n+        });\n+\n+        evalBlockHistogram.values().forEach(bin -> {\n+            Assert.assertTrue(truthBlockHistogram.containsKey(bin.getId()));\n+            Assert.assertEquals(bin.getValue(), truthBlockHistogram.get(bin.getId()).getValue());\n+        });\n+\n+        MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n+        confidenceConcordanceMetrics.read(new FileReader(confidenceConcordanceHistogramFile.toFile()));\n+        Assert.assertEquals(confidenceConcordanceMetrics.getNumHistograms(), 1);\n+        Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n+\n+        confidenceConcordanceHistogram.values().forEach(bin -> {\n+            String[] confidenceValues = bin.getId().split(\",\");\n+            Assert.assertEquals(confidenceValues[0], confidenceValues[1]);\n+        });\n+    }\n+\n+    private Pair<File, File> writeTestGVCFs(List<TestReferenceBlockConcordanceVariant> truthVariants, List<TestReferenceBlockConcordanceVariant> evalVariants) throws Exception {\n+        File truthFile = createTempFile(\"truth\", \".gvcf\");\n+        FileWriter writer = new FileWriter(truthFile);\n+        writer.write(\"##fileformat=VCFv4.2\\n\");\n+        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n+        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n+        for (TestReferenceBlockConcordanceVariant variant : truthVariants) {\n+            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n+                    variant.start,\n+                    variant.getAltAllele(),\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n+                    variant.getConfidence()));\n+        }\n+        writer.close();\n+\n+        File evalFile = createTempFile(\"eval\", \".gvcf\");\n+        writer = new FileWriter(evalFile);\n+        writer.write(\"##fileformat=VCFv4.2\\n\");\n+        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n+        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n+        for (TestReferenceBlockConcordanceVariant variant : evalVariants) {\n+            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n+                    variant.start,\n+                    variant.getAltAllele(),\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n+                    variant.getConfidence()));\n+        }\n+        writer.close();\n+\n+        return new Pair<>(truthFile, evalFile);\n+    }\n+\n+    @DataProvider\n+    public Object[][] provideSyntheticGVCFs() {\n+        return new Object[][] {\n+                // No non_ref blocks\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 1, 1, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 1, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"1,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Two non_ref blocks\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 1, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 1, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"1,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"1,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Start with gap then variant\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 5, 5, 99),\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 6, 10, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"5,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 5}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Start with gap then non_ref\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 6, 10, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"5,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 5}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Start with single block\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 11, 20, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 3, 6, 98),\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 11, 20, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"4,98\", 1},\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 10}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // No overlap at all\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 11, 20, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 3, 6, 98)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"4,98\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // End with var\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 9, 99),\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 10, 10, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"9,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 9}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // End with var then gap\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 7, 99),\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 8, 8, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"7,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 7}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // End with gap then var\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 7, 99),\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 10, 10, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"7,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 7}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"provideSyntheticGVCFs\")\n+    public void testSyntheticGVCFs(final List<TestReferenceBlockConcordanceVariant> truthVariants, final List<TestReferenceBlockConcordanceVariant> evalVariants, final Map<String, Integer> expectedTruthBlockHistogram, final Map<String, Integer> expectedEvalBlockHistogram, final Map<String, Integer> expectedConfidenceConcordance) throws Exception {\n+        Pair<File, File> inputFiles = writeTestGVCFs(truthVariants, evalVariants);\n+\n+        final Path truthBlockHistogramFile = createTempPath(\"truth_block_histogram\", \".tsv\");\n+        final Path evalBlockHistogramFile = createTempPath(\"eval_block_histogram\", \".tsv\");\n+        final Path confidenceConcordanceHistogramFile = createTempPath(\"confidence_concordance_histogram\", \".tsv\");\n+\n+        final String[] args = {\n+                \"--\" + AbstractConcordanceWalker.TRUTH_VARIANTS_LONG_NAME, inputFiles.getLeft().toString(),\n+                \"--\" + AbstractConcordanceWalker.EVAL_VARIANTS_LONG_NAME, inputFiles.getRight().toString(),\n+                \"--\" + ReferenceBlockConcordance.TRUTH_BLOCK_HISTOGRAM_LONG_NAME, truthBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.EVAL_BLOCK_HISTOGRAM_LONG_NAME, evalBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME, confidenceConcordanceHistogramFile.toString(),\n+        };\n+        runCommandLine(args);\n+\n+        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n+        if (truthBlockMetrics.getNumHistograms() > 0) {\n+            Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n+            Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+            // Check value and remove entry from expected histogram...\n+            truthBlockHistogram.values().forEach(bin -> {", "originalCommit": "df904bc0857d2939326188ce3932e9f3601838fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4NDExMg==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487184112", "bodyText": "good to see all these different test cases \ud83d\udc4d", "author": "kachulis", "createdAt": "2020-09-11T17:21:53Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -0,0 +1,436 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Created by Michael Gatzen on 9/9/20.\n+ */\n+public class ReferenceBlockConcordanceIntegrationTest extends CommandLineProgramTest{\n+\n+    private static final String CONCORDANCE_TEST_DIR = toolsTestDir + \"concordance/\";\n+    private static final String HAPLOTYPECALLER_TEST_DIR = toolsTestDir + \"haplotypecaller/\";\n+\n+    @Test\n+    public void testIdentical() throws Exception {\n+        // TODO Is it fine to use a test file from a different tool or should I copy it?\n+        final File truthVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final File evalVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final Path truthBlockHistogramFile = createTempPath(\"truth_block_histogram\", \".tsv\");\n+        final Path evalBlockHistogramFile = createTempPath(\"eval_block_histogram\", \".tsv\");\n+        final Path confidenceConcordanceHistogramFile = createTempPath(\"confidence_concordance_histogram\", \".tsv\");\n+\n+        final String[] args = {\n+                \"--\" + AbstractConcordanceWalker.EVAL_VARIANTS_LONG_NAME, evalVcf.toString(),\n+                \"--\" + AbstractConcordanceWalker.TRUTH_VARIANTS_LONG_NAME, truthVcf.toString(),\n+                \"--\" + ReferenceBlockConcordance.TRUTH_BLOCK_HISTOGRAM_LONG_NAME, truthBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.EVAL_BLOCK_HISTOGRAM_LONG_NAME, evalBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME, confidenceConcordanceHistogramFile.toString(),\n+        };\n+        runCommandLine(args);\n+\n+        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n+        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n+\n+        Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n+        Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n+\n+        Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+        Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+\n+        // Got this number by counting the <NON_REF> alt alleles in the test GVCF file\n+        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1034);\n+        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1034);\n+\n+        // Check block histograms both ways, in case one histogram has more entries than the other\n+        truthBlockHistogram.values().forEach(bin -> {\n+            Assert.assertTrue(evalBlockHistogram.containsKey(bin.getId()));\n+            Assert.assertEquals(bin.getValue(), evalBlockHistogram.get(bin.getId()).getValue());\n+        });\n+\n+        evalBlockHistogram.values().forEach(bin -> {\n+            Assert.assertTrue(truthBlockHistogram.containsKey(bin.getId()));\n+            Assert.assertEquals(bin.getValue(), truthBlockHistogram.get(bin.getId()).getValue());\n+        });\n+\n+        MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n+        confidenceConcordanceMetrics.read(new FileReader(confidenceConcordanceHistogramFile.toFile()));\n+        Assert.assertEquals(confidenceConcordanceMetrics.getNumHistograms(), 1);\n+        Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n+\n+        confidenceConcordanceHistogram.values().forEach(bin -> {\n+            String[] confidenceValues = bin.getId().split(\",\");\n+            Assert.assertEquals(confidenceValues[0], confidenceValues[1]);\n+        });\n+    }\n+\n+    private Pair<File, File> writeTestGVCFs(List<TestReferenceBlockConcordanceVariant> truthVariants, List<TestReferenceBlockConcordanceVariant> evalVariants) throws Exception {\n+        File truthFile = createTempFile(\"truth\", \".gvcf\");\n+        FileWriter writer = new FileWriter(truthFile);\n+        writer.write(\"##fileformat=VCFv4.2\\n\");\n+        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n+        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n+        for (TestReferenceBlockConcordanceVariant variant : truthVariants) {\n+            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n+                    variant.start,\n+                    variant.getAltAllele(),\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n+                    variant.getConfidence()));\n+        }\n+        writer.close();\n+\n+        File evalFile = createTempFile(\"eval\", \".gvcf\");\n+        writer = new FileWriter(evalFile);\n+        writer.write(\"##fileformat=VCFv4.2\\n\");\n+        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n+        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n+        for (TestReferenceBlockConcordanceVariant variant : evalVariants) {\n+            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n+                    variant.start,\n+                    variant.getAltAllele(),\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n+                    variant.getConfidence()));\n+        }\n+        writer.close();\n+\n+        return new Pair<>(truthFile, evalFile);\n+    }\n+\n+    @DataProvider\n+    public Object[][] provideSyntheticGVCFs() {\n+        return new Object[][] {\n+                // No non_ref blocks\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 1, 1, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 1, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"1,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Two non_ref blocks\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 1, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 1, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"1,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"1,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Start with gap then variant\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 5, 5, 99),\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 6, 10, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"5,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 5}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Start with gap then non_ref\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 6, 10, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"5,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 5}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Start with single block\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 11, 20, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 3, 6, 98),\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 11, 20, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"4,98\", 1},\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 10}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // No overlap at all\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 11, 20, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 3, 6, 98)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"4,98\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // End with var\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 9, 99),\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 10, 10, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"9,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 9}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // End with var then gap\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 7, 99),\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 8, 8, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"7,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 7}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // End with gap then var", "originalCommit": "df904bc0857d2939326188ce3932e9f3601838fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4NzQ3OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487187479", "bodyText": "could the setting of currentTruthVariantContext and currentEvalVariantContext be moved before the incrementing of confidenceConcordanceHistogram.  Then you wouldn't need to additionally increment confidenceConcordanceHistogram in evaluateEndOfContig, or call evaluateEndOfContig from onTraversalSuccess", "author": "kachulis", "createdAt": "2020-09-11T17:28:40Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();\n+    private final Histogram<String> confidenceConcordanceHistogram = new Histogram<>();\n+\n+    private VariantContext currentTruthVariantContext = null;\n+    private VariantContext currentEvalVariantContext = null;\n+    private String currentContig = null;\n+\n+    @Override\n+    protected Predicate<VariantContext> makeTruthVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    @Override\n+    protected Predicate<VariantContext> makeEvalVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    private boolean isNonRef(VariantContext variantContext) {\n+        return variantContext.isSymbolic() && variantContext.getAlternateAllele(0).isNonRefAllele();\n+    }\n+\n+    private void evaluateEndOfContig() {\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), jointBlockLength);\n+            }\n+        }\n+\n+        currentTruthVariantContext = null;\n+        currentEvalVariantContext = null;\n+        currentContig = null;\n+    }\n+\n+    private void evaluateNewContig(TruthVersusEval truthVersusEval) {\n+        // If not beginning of file\n+        if (currentContig != null) {\n+            evaluateEndOfContig();\n+        }\n+\n+        currentContig = truthVersusEval.getTruthIfPresentElseEval().getContig();\n+    }\n+\n+    @Override\n+    protected void apply(TruthVersusEval truthVersusEval, ReadsContext readsContext, ReferenceContext refContext) {\n+        // New contig or beginning of file\n+        if (!truthVersusEval.getTruthIfPresentElseEval().getContig().equals(currentContig)) {\n+            evaluateNewContig(truthVersusEval);\n+        }\n+\n+        // Evaluate only when currently seeing two NON_REF blocks\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            // It is possible that jointBlockLength is negative if there is a gap in one file and the start of a new block in the other file.\n+            // Since there is no overlap though, we can just skip that case.\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), blockEnd - blockStart + 1);\n+            }\n+\n+            int currentPosition = truthVersusEval.getTruthIfPresentElseEval().getStart();\n+            if (truthVersusEval.hasTruth() || currentPosition >= currentTruthVariantContext.getEnd()) {\n+                currentTruthVariantContext = null;\n+            }\n+            if (truthVersusEval.hasEval() || currentPosition >= currentEvalVariantContext.getEnd()) {\n+                currentEvalVariantContext = null;\n+            }\n+        }\n+\n+        // Truth\n+        if (truthVersusEval.hasTruth() && isNonRef(truthVersusEval.getTruth())) {\n+            currentTruthVariantContext = truthVersusEval.getTruth();", "originalCommit": "df904bc0857d2939326188ce3932e9f3601838fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "deb363bc7c7049adadb7d56463c728bcbce57e82", "url": "https://github.com/broadinstitute/gatk/commit/deb363bc7c7049adadb7d56463c728bcbce57e82", "message": "Incorporated PR comments\n\n- Use of more existing GATK tools, such as GVCFWriter and SimpleInterval throughout the tool and its integration test\n- final correctness\n- Arguments as GATKPath\n- Refactoring of integration tests\n- Correct variant filters for traversal\n- Rearranged and simplified the counting\n- Aligned expected values for integration test to new variant filters", "committedDate": "2020-09-24T11:29:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkxNzcwMA==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r495917700", "bodyText": "Don't need to extract currentPosition, can just check that  !currentTruthVariantContext.overlaps(truthVersusEval);\nBy doing this, you also don't need to check yourself that you are still on the same contig, since Locatable::overlaps will check contigs for you.  So you can remove the evaluateNewContig method.", "author": "kachulis", "createdAt": "2020-09-28T12:58:11Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -131,56 +127,35 @@ protected void apply(TruthVersusEval truthVersusEval, ReadsContext readsContext,\n             evaluateNewContig(truthVersusEval);\n         }\n \n-        // Evaluate only when currently seeing two NON_REF blocks\n-        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n-            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n-            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n-            int jointBlockLength = blockEnd - blockStart + 1;\n-            // It is possible that jointBlockLength is negative if there is a gap in one file and the start of a new block in the other file.\n-            // Since there is no overlap though, we can just skip that case.\n-            if (jointBlockLength > 0) {\n-                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), blockEnd - blockStart + 1);\n-            }\n-\n-            int currentPosition = truthVersusEval.getTruthIfPresentElseEval().getStart();\n-            if (truthVersusEval.hasTruth() || currentPosition >= currentTruthVariantContext.getEnd()) {\n-                currentTruthVariantContext = null;\n-            }\n-            if (truthVersusEval.hasEval() || currentPosition >= currentEvalVariantContext.getEnd()) {\n-                currentEvalVariantContext = null;\n-            }\n-        }\n-\n         // Truth\n-        if (truthVersusEval.hasTruth() && isNonRef(truthVersusEval.getTruth())) {\n+        if (truthVersusEval.hasTruth()) {\n             currentTruthVariantContext = truthVersusEval.getTruth();\n \n-            // The end is inclusive, thus the plus one when calculating the length\n-            int blockLength = truthVersusEval.getTruth().getEnd() - truthVersusEval.getTruth().getStart() + 1;\n-\n-            // TODO can a non_ref block ever have a number of genotypes != 1?\n-            if(truthVersusEval.getTruth().getGenotypes().size() != 1) {\n-                throw new IllegalStateException(String.format(\"The NON_REF block \\\"%s\\\" has more than one genotype, which is not supported.\", truthVersusEval.getTruth().toStringDecodeGenotypes()));\n-            }\n-            Genotype genotype = truthVersusEval.getTruth().getGenotype(0);\n-            int gq = genotype.getGQ();\n-            truthBlockHistogram.increment(new Pair<>(blockLength, gq).toString());\n+            truthBlockHistogram.increment(extractLengthAndGQ(truthVersusEval.getTruth()).toString());\n         }\n \n         // Eval\n-        if (truthVersusEval.hasEval() && isNonRef(truthVersusEval.getEval())) {\n+        if (truthVersusEval.hasEval()) {\n             currentEvalVariantContext = truthVersusEval.getEval();\n \n-            // The end is inclusive, thus the plus one when calculating the length\n-            int blockLength = truthVersusEval.getEval().getEnd() - truthVersusEval.getEval().getStart() + 1;\n+            evalBlockHistogram.increment(extractLengthAndGQ(truthVersusEval.getEval()).toString());\n+        }\n+\n+        final int currentPosition = truthVersusEval.getTruthIfPresentElseEval().getStart();\n+        if (currentTruthVariantContext != null && currentPosition > currentTruthVariantContext.getEnd()) {", "originalCommit": "deb363bc7c7049adadb7d56463c728bcbce57e82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkyMTY2MA==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r495921660", "bodyText": "since you are only using this to get the length on reference, which is a method of Locatable, you don't need to create a SimpleInterval here, since VariantContext is a subclass of Locatable", "author": "kachulis", "createdAt": "2020-09-28T13:03:49Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -87,41 +89,35 @@\n     @Override\n     protected Predicate<VariantContext> makeTruthVariantFilter() {\n         // Explicitly allow symbolic variants\n-        return VariantContext::isSymbolic;\n+        return this::isHomRef;\n     }\n \n     @Override\n     protected Predicate<VariantContext> makeEvalVariantFilter() {\n         // Explicitly allow symbolic variants\n-        return VariantContext::isSymbolic;\n+        return this::isHomRef;\n     }\n \n-    private boolean isNonRef(VariantContext variantContext) {\n-        return variantContext.isSymbolic() && variantContext.getAlternateAllele(0).isNonRefAllele();\n+    private boolean isHomRef(VariantContext variantContext) {\n+        return variantContext.getGenotypes().get(0).isHomRef();\n     }\n \n-    private void evaluateEndOfContig() {\n-        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n-            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n-            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n-            int jointBlockLength = blockEnd - blockStart + 1;\n-            if (jointBlockLength > 0) {\n-                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), jointBlockLength);\n-            }\n-        }\n-\n+    private void evaluateNewContig(TruthVersusEval truthVersusEval) {\n         currentTruthVariantContext = null;\n         currentEvalVariantContext = null;\n-        currentContig = null;\n+\n+        currentContig = truthVersusEval.getTruthIfPresentElseEval().getContig();\n     }\n \n-    private void evaluateNewContig(TruthVersusEval truthVersusEval) {\n-        // If not beginning of file\n-        if (currentContig != null) {\n-            evaluateEndOfContig();\n-        }\n+    private Pair<Integer, Integer> extractLengthAndGQ(VariantContext variant) {\n+        final SimpleInterval interval = new SimpleInterval(variant);", "originalCommit": "deb363bc7c7049adadb7d56463c728bcbce57e82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkyMzQ2Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r495923466", "bodyText": "Do you understand why this number changed from 1034 in the test originally?", "author": "kachulis", "createdAt": "2020-09-28T13:06:30Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -45,91 +49,99 @@ public void testIdentical() throws Exception {\n         };\n         runCommandLine(args);\n \n-        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        final MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n         truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n-        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        final MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n         evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n \n         Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n         Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n \n-        Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n-        Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+        final Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+        final Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n \n         // Got this number by counting the <NON_REF> alt alleles in the test GVCF file\n-        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1034);\n-        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1034);\n+        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1038);", "originalCommit": "deb363bc7c7049adadb7d56463c728bcbce57e82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzMzIwNw==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r495933207", "bodyText": "Use static Allele fields and pass as Allele instead of as String", "author": "kachulis", "createdAt": "2020-09-28T13:20:39Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -45,91 +49,99 @@ public void testIdentical() throws Exception {\n         };\n         runCommandLine(args);\n \n-        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        final MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n         truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n-        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        final MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n         evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n \n         Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n         Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n \n-        Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n-        Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+        final Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+        final Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n \n         // Got this number by counting the <NON_REF> alt alleles in the test GVCF file\n-        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1034);\n-        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1034);\n+        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1038);\n+        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1038);\n \n-        // Check block histograms both ways, in case one histogram has more entries than the other\n-        truthBlockHistogram.values().forEach(bin -> {\n-            Assert.assertTrue(evalBlockHistogram.containsKey(bin.getId()));\n-            Assert.assertEquals(bin.getValue(), evalBlockHistogram.get(bin.getId()).getValue());\n-        });\n-\n-        evalBlockHistogram.values().forEach(bin -> {\n-            Assert.assertTrue(truthBlockHistogram.containsKey(bin.getId()));\n-            Assert.assertEquals(bin.getValue(), truthBlockHistogram.get(bin.getId()).getValue());\n-        });\n+        Assert.assertEquals(truthBlockHistogram, evalBlockHistogram);\n \n-        MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n+        // For confidence concordance, check that there are only values on the diagonal\n+        final MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n         confidenceConcordanceMetrics.read(new FileReader(confidenceConcordanceHistogramFile.toFile()));\n         Assert.assertEquals(confidenceConcordanceMetrics.getNumHistograms(), 1);\n-        Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n-\n+        final Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n         confidenceConcordanceHistogram.values().forEach(bin -> {\n-            String[] confidenceValues = bin.getId().split(\",\");\n+            final String[] confidenceValues = bin.getId().split(\",\");\n             Assert.assertEquals(confidenceValues[0], confidenceValues[1]);\n         });\n     }\n \n-    private Pair<File, File> writeTestGVCFs(List<TestReferenceBlockConcordanceVariant> truthVariants, List<TestReferenceBlockConcordanceVariant> evalVariants) throws Exception {\n-        File truthFile = createTempFile(\"truth\", \".gvcf\");\n-        FileWriter writer = new FileWriter(truthFile);\n-        writer.write(\"##fileformat=VCFv4.2\\n\");\n-        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n-        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n-        for (TestReferenceBlockConcordanceVariant variant : truthVariants) {\n-            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n-                    variant.start,\n-                    variant.getAltAllele(),\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n-                    variant.getConfidence()));\n-        }\n-        writer.close();\n-\n-        File evalFile = createTempFile(\"eval\", \".gvcf\");\n-        writer = new FileWriter(evalFile);\n-        writer.write(\"##fileformat=VCFv4.2\\n\");\n-        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n-        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n-        for (TestReferenceBlockConcordanceVariant variant : evalVariants) {\n-            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n-                    variant.start,\n-                    variant.getAltAllele(),\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n-                    variant.getConfidence()));\n-        }\n-        writer.close();\n+    private Pair<File, File> writeTestGVCFs(List<VariantContext> truthVariants, List<VariantContext> evalVariants) {\n+        final File truthFile = createTempFile(\"truth\", \".gvcf\");\n+        final GVCFWriter truthWriter = new GVCFWriter(\n+                GATKVariantContextUtils.createVCFWriter(truthFile.toPath(), null, false, Options.ALLOW_MISSING_FIELDS_IN_HEADER),\n+                IntStream.range(1, 100).boxed().collect(Collectors.toList()),\n+                2,\n+                true\n+                );\n+        truthWriter.writeHeader(new VCFHeader(new HashSet<>(Arrays.asList(\n+                new VCFHeaderLine(\"fileformat\", \"VCFv4.2\"),\n+                new VCFHeaderLine(\"contig\", \"<ID=test_contig,length=1000>\")\n+            )), Collections.singletonList(\"TESTSAMPLE\")));\n+\n+        truthVariants.forEach(truthWriter::add);\n+        truthWriter.close();\n+\n+        final File evalFile = createTempFile(\"eval\", \".gvcf\");\n+        final GVCFWriter evalWriter = new GVCFWriter(\n+                GATKVariantContextUtils.createVCFWriter(evalFile.toPath(), null, false, Options.ALLOW_MISSING_FIELDS_IN_HEADER),\n+                IntStream.range(1, 100).boxed().collect(Collectors.toList()),\n+                2,\n+                true\n+        );\n+        evalWriter.writeHeader(new VCFHeader(new HashSet<>(Arrays.asList(\n+                new VCFHeaderLine(\"fileformat\", \"VCFv4.2\"),\n+                new VCFHeaderLine(\"contig\", \"<ID=test_contig,length=1000>\")\n+        )), Collections.singletonList(\"TESTSAMPLE\")));\n+\n+        evalVariants.forEach(evalWriter::add);\n+        evalWriter.close();\n \n         return new Pair<>(truthFile, evalFile);\n     }\n \n+    private static VariantContext constructTestVariantContext(final String altAllele, final int start, final int stop, final int confidence) {\n+        final boolean isNonRef = altAllele.equals(\"<NON_REF>\");\n+        final Allele refAllele = Allele.create(\"A\", true);\n+        final List<Allele> alleles = Arrays.asList(\n+                refAllele,\n+                isNonRef ? Allele.NON_REF_ALLELE : Allele.create(altAllele)\n+        );\n+        final VariantContextBuilder variantContextBuilder = new VariantContextBuilder(\"TEST\", \"test_contig\", start, stop, alleles);\n+        final GenotypeBuilder genotypeBuilder = new GenotypeBuilder(\"TESTSAMPLE\", isNonRef ? GATKVariantContextUtils.homozygousAlleleList(refAllele, 2) : alleles);\n+        if (isNonRef) {\n+            genotypeBuilder.GQ(confidence);\n+            genotypeBuilder.PL(new int[] { 0, 0, 0 });\n+            variantContextBuilder.attribute(VCFConstants.END_KEY, stop);\n+        }\n+        final Genotype gt = genotypeBuilder.DP(30).make();\n+        variantContextBuilder.genotypes(gt);\n+        return variantContextBuilder.make();\n+    }\n+\n     @DataProvider\n     public Object[][] provideSyntheticGVCFs() {\n         return new Object[][] {\n                 // No non_ref blocks\n                 {\n                         // Truth variants\n                         Arrays.asList(\n-                                new TestReferenceBlockConcordanceVariant(\"C\", 1, 1, 99)\n+                                constructTestVariantContext(\"C\", 1, 1, 99)", "originalCommit": "deb363bc7c7049adadb7d56463c728bcbce57e82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzNzY3Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r495937676", "bodyText": "if you pass a SAMSequenceDictionary to the constructor here (like new SAMSequenceDictionary(Collections.singletonList(new SAMSequenceRecord(\"test_contig\", 1000)))) then you don't need to add the dictionary line by hand to the header below.", "author": "kachulis", "createdAt": "2020-09-28T13:26:56Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -45,91 +49,99 @@ public void testIdentical() throws Exception {\n         };\n         runCommandLine(args);\n \n-        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        final MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n         truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n-        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        final MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n         evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n \n         Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n         Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n \n-        Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n-        Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+        final Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+        final Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n \n         // Got this number by counting the <NON_REF> alt alleles in the test GVCF file\n-        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1034);\n-        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1034);\n+        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1038);\n+        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1038);\n \n-        // Check block histograms both ways, in case one histogram has more entries than the other\n-        truthBlockHistogram.values().forEach(bin -> {\n-            Assert.assertTrue(evalBlockHistogram.containsKey(bin.getId()));\n-            Assert.assertEquals(bin.getValue(), evalBlockHistogram.get(bin.getId()).getValue());\n-        });\n-\n-        evalBlockHistogram.values().forEach(bin -> {\n-            Assert.assertTrue(truthBlockHistogram.containsKey(bin.getId()));\n-            Assert.assertEquals(bin.getValue(), truthBlockHistogram.get(bin.getId()).getValue());\n-        });\n+        Assert.assertEquals(truthBlockHistogram, evalBlockHistogram);\n \n-        MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n+        // For confidence concordance, check that there are only values on the diagonal\n+        final MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n         confidenceConcordanceMetrics.read(new FileReader(confidenceConcordanceHistogramFile.toFile()));\n         Assert.assertEquals(confidenceConcordanceMetrics.getNumHistograms(), 1);\n-        Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n-\n+        final Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n         confidenceConcordanceHistogram.values().forEach(bin -> {\n-            String[] confidenceValues = bin.getId().split(\",\");\n+            final String[] confidenceValues = bin.getId().split(\",\");\n             Assert.assertEquals(confidenceValues[0], confidenceValues[1]);\n         });\n     }\n \n-    private Pair<File, File> writeTestGVCFs(List<TestReferenceBlockConcordanceVariant> truthVariants, List<TestReferenceBlockConcordanceVariant> evalVariants) throws Exception {\n-        File truthFile = createTempFile(\"truth\", \".gvcf\");\n-        FileWriter writer = new FileWriter(truthFile);\n-        writer.write(\"##fileformat=VCFv4.2\\n\");\n-        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n-        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n-        for (TestReferenceBlockConcordanceVariant variant : truthVariants) {\n-            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n-                    variant.start,\n-                    variant.getAltAllele(),\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n-                    variant.getConfidence()));\n-        }\n-        writer.close();\n-\n-        File evalFile = createTempFile(\"eval\", \".gvcf\");\n-        writer = new FileWriter(evalFile);\n-        writer.write(\"##fileformat=VCFv4.2\\n\");\n-        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n-        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n-        for (TestReferenceBlockConcordanceVariant variant : evalVariants) {\n-            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n-                    variant.start,\n-                    variant.getAltAllele(),\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n-                    variant.getConfidence()));\n-        }\n-        writer.close();\n+    private Pair<File, File> writeTestGVCFs(List<VariantContext> truthVariants, List<VariantContext> evalVariants) {\n+        final File truthFile = createTempFile(\"truth\", \".gvcf\");\n+        final GVCFWriter truthWriter = new GVCFWriter(", "originalCommit": "deb363bc7c7049adadb7d56463c728bcbce57e82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1NTYzNg==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r499455636", "bodyText": "It wasn't just as easy as that (or at least I couldn't figure it out), but I found a two-line solution that avoids adding the header lines manually", "author": "michaelgatzen", "createdAt": "2020-10-05T09:17:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzNzY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzODU2Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r495938567", "bodyText": "same comment about passing a reference dictionary", "author": "kachulis", "createdAt": "2020-09-28T13:28:14Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -45,91 +49,99 @@ public void testIdentical() throws Exception {\n         };\n         runCommandLine(args);\n \n-        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        final MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n         truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n-        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        final MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n         evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n \n         Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n         Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n \n-        Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n-        Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+        final Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+        final Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n \n         // Got this number by counting the <NON_REF> alt alleles in the test GVCF file\n-        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1034);\n-        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1034);\n+        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1038);\n+        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1038);\n \n-        // Check block histograms both ways, in case one histogram has more entries than the other\n-        truthBlockHistogram.values().forEach(bin -> {\n-            Assert.assertTrue(evalBlockHistogram.containsKey(bin.getId()));\n-            Assert.assertEquals(bin.getValue(), evalBlockHistogram.get(bin.getId()).getValue());\n-        });\n-\n-        evalBlockHistogram.values().forEach(bin -> {\n-            Assert.assertTrue(truthBlockHistogram.containsKey(bin.getId()));\n-            Assert.assertEquals(bin.getValue(), truthBlockHistogram.get(bin.getId()).getValue());\n-        });\n+        Assert.assertEquals(truthBlockHistogram, evalBlockHistogram);\n \n-        MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n+        // For confidence concordance, check that there are only values on the diagonal\n+        final MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n         confidenceConcordanceMetrics.read(new FileReader(confidenceConcordanceHistogramFile.toFile()));\n         Assert.assertEquals(confidenceConcordanceMetrics.getNumHistograms(), 1);\n-        Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n-\n+        final Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n         confidenceConcordanceHistogram.values().forEach(bin -> {\n-            String[] confidenceValues = bin.getId().split(\",\");\n+            final String[] confidenceValues = bin.getId().split(\",\");\n             Assert.assertEquals(confidenceValues[0], confidenceValues[1]);\n         });\n     }\n \n-    private Pair<File, File> writeTestGVCFs(List<TestReferenceBlockConcordanceVariant> truthVariants, List<TestReferenceBlockConcordanceVariant> evalVariants) throws Exception {\n-        File truthFile = createTempFile(\"truth\", \".gvcf\");\n-        FileWriter writer = new FileWriter(truthFile);\n-        writer.write(\"##fileformat=VCFv4.2\\n\");\n-        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n-        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n-        for (TestReferenceBlockConcordanceVariant variant : truthVariants) {\n-            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n-                    variant.start,\n-                    variant.getAltAllele(),\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n-                    variant.getConfidence()));\n-        }\n-        writer.close();\n-\n-        File evalFile = createTempFile(\"eval\", \".gvcf\");\n-        writer = new FileWriter(evalFile);\n-        writer.write(\"##fileformat=VCFv4.2\\n\");\n-        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n-        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n-        for (TestReferenceBlockConcordanceVariant variant : evalVariants) {\n-            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n-                    variant.start,\n-                    variant.getAltAllele(),\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n-                    variant.getConfidence()));\n-        }\n-        writer.close();\n+    private Pair<File, File> writeTestGVCFs(List<VariantContext> truthVariants, List<VariantContext> evalVariants) {\n+        final File truthFile = createTempFile(\"truth\", \".gvcf\");\n+        final GVCFWriter truthWriter = new GVCFWriter(\n+                GATKVariantContextUtils.createVCFWriter(truthFile.toPath(), null, false, Options.ALLOW_MISSING_FIELDS_IN_HEADER),\n+                IntStream.range(1, 100).boxed().collect(Collectors.toList()),\n+                2,\n+                true\n+                );\n+        truthWriter.writeHeader(new VCFHeader(new HashSet<>(Arrays.asList(\n+                new VCFHeaderLine(\"fileformat\", \"VCFv4.2\"),\n+                new VCFHeaderLine(\"contig\", \"<ID=test_contig,length=1000>\")\n+            )), Collections.singletonList(\"TESTSAMPLE\")));\n+\n+        truthVariants.forEach(truthWriter::add);\n+        truthWriter.close();\n+\n+        final File evalFile = createTempFile(\"eval\", \".gvcf\");\n+        final GVCFWriter evalWriter = new GVCFWriter(\n+                GATKVariantContextUtils.createVCFWriter(evalFile.toPath(), null, false, Options.ALLOW_MISSING_FIELDS_IN_HEADER),", "originalCommit": "deb363bc7c7049adadb7d56463c728bcbce57e82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzOTg1Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r495939852", "bodyText": "passing an Allele instead of a String will allow you to just use Allele::isNonReference", "author": "kachulis", "createdAt": "2020-09-28T13:30:03Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -45,91 +49,99 @@ public void testIdentical() throws Exception {\n         };\n         runCommandLine(args);\n \n-        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        final MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n         truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n-        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        final MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n         evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n \n         Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n         Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n \n-        Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n-        Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+        final Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+        final Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n \n         // Got this number by counting the <NON_REF> alt alleles in the test GVCF file\n-        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1034);\n-        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1034);\n+        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1038);\n+        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1038);\n \n-        // Check block histograms both ways, in case one histogram has more entries than the other\n-        truthBlockHistogram.values().forEach(bin -> {\n-            Assert.assertTrue(evalBlockHistogram.containsKey(bin.getId()));\n-            Assert.assertEquals(bin.getValue(), evalBlockHistogram.get(bin.getId()).getValue());\n-        });\n-\n-        evalBlockHistogram.values().forEach(bin -> {\n-            Assert.assertTrue(truthBlockHistogram.containsKey(bin.getId()));\n-            Assert.assertEquals(bin.getValue(), truthBlockHistogram.get(bin.getId()).getValue());\n-        });\n+        Assert.assertEquals(truthBlockHistogram, evalBlockHistogram);\n \n-        MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n+        // For confidence concordance, check that there are only values on the diagonal\n+        final MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n         confidenceConcordanceMetrics.read(new FileReader(confidenceConcordanceHistogramFile.toFile()));\n         Assert.assertEquals(confidenceConcordanceMetrics.getNumHistograms(), 1);\n-        Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n-\n+        final Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n         confidenceConcordanceHistogram.values().forEach(bin -> {\n-            String[] confidenceValues = bin.getId().split(\",\");\n+            final String[] confidenceValues = bin.getId().split(\",\");\n             Assert.assertEquals(confidenceValues[0], confidenceValues[1]);\n         });\n     }\n \n-    private Pair<File, File> writeTestGVCFs(List<TestReferenceBlockConcordanceVariant> truthVariants, List<TestReferenceBlockConcordanceVariant> evalVariants) throws Exception {\n-        File truthFile = createTempFile(\"truth\", \".gvcf\");\n-        FileWriter writer = new FileWriter(truthFile);\n-        writer.write(\"##fileformat=VCFv4.2\\n\");\n-        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n-        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n-        for (TestReferenceBlockConcordanceVariant variant : truthVariants) {\n-            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n-                    variant.start,\n-                    variant.getAltAllele(),\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n-                    variant.getConfidence()));\n-        }\n-        writer.close();\n-\n-        File evalFile = createTempFile(\"eval\", \".gvcf\");\n-        writer = new FileWriter(evalFile);\n-        writer.write(\"##fileformat=VCFv4.2\\n\");\n-        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n-        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n-        for (TestReferenceBlockConcordanceVariant variant : evalVariants) {\n-            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n-                    variant.start,\n-                    variant.getAltAllele(),\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n-                    variant.getConfidence()));\n-        }\n-        writer.close();\n+    private Pair<File, File> writeTestGVCFs(List<VariantContext> truthVariants, List<VariantContext> evalVariants) {\n+        final File truthFile = createTempFile(\"truth\", \".gvcf\");\n+        final GVCFWriter truthWriter = new GVCFWriter(\n+                GATKVariantContextUtils.createVCFWriter(truthFile.toPath(), null, false, Options.ALLOW_MISSING_FIELDS_IN_HEADER),\n+                IntStream.range(1, 100).boxed().collect(Collectors.toList()),\n+                2,\n+                true\n+                );\n+        truthWriter.writeHeader(new VCFHeader(new HashSet<>(Arrays.asList(\n+                new VCFHeaderLine(\"fileformat\", \"VCFv4.2\"),\n+                new VCFHeaderLine(\"contig\", \"<ID=test_contig,length=1000>\")\n+            )), Collections.singletonList(\"TESTSAMPLE\")));\n+\n+        truthVariants.forEach(truthWriter::add);\n+        truthWriter.close();\n+\n+        final File evalFile = createTempFile(\"eval\", \".gvcf\");\n+        final GVCFWriter evalWriter = new GVCFWriter(\n+                GATKVariantContextUtils.createVCFWriter(evalFile.toPath(), null, false, Options.ALLOW_MISSING_FIELDS_IN_HEADER),\n+                IntStream.range(1, 100).boxed().collect(Collectors.toList()),\n+                2,\n+                true\n+        );\n+        evalWriter.writeHeader(new VCFHeader(new HashSet<>(Arrays.asList(\n+                new VCFHeaderLine(\"fileformat\", \"VCFv4.2\"),\n+                new VCFHeaderLine(\"contig\", \"<ID=test_contig,length=1000>\")\n+        )), Collections.singletonList(\"TESTSAMPLE\")));\n+\n+        evalVariants.forEach(evalWriter::add);\n+        evalWriter.close();\n \n         return new Pair<>(truthFile, evalFile);\n     }\n \n+    private static VariantContext constructTestVariantContext(final String altAllele, final int start, final int stop, final int confidence) {\n+        final boolean isNonRef = altAllele.equals(\"<NON_REF>\");", "originalCommit": "deb363bc7c7049adadb7d56463c728bcbce57e82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6c79f60a71a7473d9d069c7a5943b0d8d437c057", "url": "https://github.com/broadinstitute/gatk/commit/6c79f60a71a7473d9d069c7a5943b0d8d437c057", "message": "Incorporated second round of PR comments\n\n- Also added new integration test to verify functionality when encountering multiple contigs", "committedDate": "2020-10-05T09:21:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2NDczNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r499764735", "bodyText": "currentPosition now unused, can be removed", "author": "kachulis", "createdAt": "2020-10-05T17:39:46Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -142,10 +127,10 @@ protected void apply(TruthVersusEval truthVersusEval, ReadsContext readsContext,\n         }\n \n         final int currentPosition = truthVersusEval.getTruthIfPresentElseEval().getStart();", "originalCommit": "6c79f60a71a7473d9d069c7a5943b0d8d437c057", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "15bed5962e567cf983b2b8958416e059d814303c", "url": "https://github.com/broadinstitute/gatk/commit/15bed5962e567cf983b2b8958416e059d814303c", "message": "Final cleanup", "committedDate": "2020-10-06T09:36:31Z", "type": "commit"}]}