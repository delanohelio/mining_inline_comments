{"pr_number": 6694, "pr_title": "add microbial mode", "pr_createdAt": "2020-07-02T20:07:45Z", "pr_url": "https://github.com/broadinstitute/gatk/pull/6694", "timeline": [{"oid": "7dc51cd8d9360cb2b10ccca5ee033bf29dbfeea6", "url": "https://github.com/broadinstitute/gatk/commit/7dc51cd8d9360cb2b10ccca5ee033bf29dbfeea6", "message": "add microbial mode", "committedDate": "2020-10-01T14:18:08Z", "type": "forcePushed"}, {"oid": "4c6f006fbdbf18b69c3c46b5cc4037488fd21c4b", "url": "https://github.com/broadinstitute/gatk/commit/4c6f006fbdbf18b69c3c46b5cc4037488fd21c4b", "message": "add microbial mode", "committedDate": "2020-11-17T14:52:45Z", "type": "forcePushed"}, {"oid": "ff60e320f857fb45ad04eda380dbb9f072568f86", "url": "https://github.com/broadinstitute/gatk/commit/ff60e320f857fb45ad04eda380dbb9f072568f86", "message": "manual rebase", "committedDate": "2020-11-17T15:35:49Z", "type": "forcePushed"}, {"oid": "9690dac82192ab6e8199330adddb813e7064fd30", "url": "https://github.com/broadinstitute/gatk/commit/9690dac82192ab6e8199330adddb813e7064fd30", "message": "manual rebase", "committedDate": "2021-01-26T16:31:39Z", "type": "forcePushed"}, {"oid": "4acfd7a593e7b6d305f663bd3cdf085bdfcd3d19", "url": "https://github.com/broadinstitute/gatk/commit/4acfd7a593e7b6d305f663bd3cdf085bdfcd3d19", "message": "manual rebase", "committedDate": "2021-01-26T19:16:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc3NzI5OA==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r564777298", "bodyText": "I would recommend removing the changes to this class since they are holdovers from before the rebase of the dangling head branch.", "author": "jamesemery", "createdAt": "2021-01-26T19:32:00Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/readthreading/AbstractReadThreadingGraph.java", "diffHunk": "@@ -594,25 +594,25 @@ int mergeDanglingHeadLegacy(final DanglingChainMergeHelper danglingHeadMergeResu\n \n         final List<CigarElement> elements = danglingHeadMergeResult.cigar.getCigarElements();\n         final CigarElement firstElement = elements.get(0);\n-        Utils.validateArg(firstElement.getOperator() == CigarOperator.M, \"The first Cigar element must be an M\");", "originalCommit": "4acfd7a593e7b6d305f663bd3cdf085bdfcd3d19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQyMjgzMA==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570422830", "bodyText": "Thank you for correcting this spelling error... i have no idea how that could have happened in the first place...", "author": "jamesemery", "createdAt": "2021-02-04T17:47:28Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/readthreading/ReadThreadingGraphUnitTest.java", "diffHunk": "@@ -293,7 +293,7 @@ public void testDanglingTails(final String refEnd,\n         final GATKRead read = ArtificialReadUtils.createArtificialRead(alt.getBytes(), Utils.dupBytes((byte) 30, alt.length()), alt.length() + \"M\");\n         final SAMFileHeader header = ArtificialReadUtils.createArtificialSamHeader();\n         rtgraph.addRead(read, header);\n-        rtgraph.setMinMatchingBasesToDangingEndRecovery(numLeadingMatchesAllowed);", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQyNTI0Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570425247", "bodyText": "it looks like there might still be some code leftover in this class as a result of the rebase... Can you try resetting this class and make sure the only change is the misspelled argument that you fixed?", "author": "jamesemery", "createdAt": "2021-02-04T17:50:39Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/readthreading/AbstractReadThreadingGraph.java", "diffHunk": "@@ -594,25 +594,24 @@ int mergeDanglingHeadLegacy(final DanglingChainMergeHelper danglingHeadMergeResu\n \n         final List<CigarElement> elements = danglingHeadMergeResult.cigar.getCigarElements();\n         final CigarElement firstElement = elements.get(0);\n-        Utils.validateArg(firstElement.getOperator() == CigarOperator.M, \"The first Cigar element must be an M\");\n \n         final int indexesToMerge = bestPrefixMatchLegacy(danglingHeadMergeResult.referencePathString, danglingHeadMergeResult.danglingPathString, firstElement.getLength());\n         if (indexesToMerge <= 0) {\n             return 0;\n         }\n \n         // we can't push back the reference path\n-        if (indexesToMerge >= danglingHeadMergeResult.referencePath.size() - 1) {\n+        if ( indexesToMerge >= danglingHeadMergeResult.referencePath.size() - 1 ) {\n             return 0;\n         }\n \n         // but we can manipulate the dangling path if we need to\n-        if (indexesToMerge >= danglingHeadMergeResult.danglingPath.size() &&\n-                !extendDanglingPathAgainstReference(danglingHeadMergeResult, indexesToMerge - danglingHeadMergeResult.danglingPath.size() + 2)) {\n+        if ( indexesToMerge >= danglingHeadMergeResult.danglingPath.size() &&\n+                ! extendDanglingPathAgainstReference(danglingHeadMergeResult, indexesToMerge - danglingHeadMergeResult.danglingPath.size() + 2) ) {\n             return 0;\n         }\n \n-        addEdge(danglingHeadMergeResult.referencePath.get(indexesToMerge + 1), danglingHeadMergeResult.danglingPath.get(indexesToMerge), ((MyEdgeFactory) getEdgeFactory()).createEdge(false, 1));\n+        addEdge(danglingHeadMergeResult.referencePath.get(indexesToMerge), danglingHeadMergeResult.danglingPath.get(indexesToMerge), ((MyEdgeFactory)getEdgeFactory()).createEdge(false, 1));", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQyNjI2Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570426263", "bodyText": "Can you update this list to be comprehensive to all the changes?\nAlso were you not going to make this argument affect the graph code at all? I thought bacterial mode would want to use the new dangling end pruning code and that doesn't seem to be linked to microbial mode at all.", "author": "jamesemery", "createdAt": "2021-02-04T17:52:11Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/filtering/M2FiltersArgumentCollection.java", "diffHunk": "@@ -43,6 +43,13 @@\n     @Argument(fullName = M2ArgumentCollection.MITOCHONDRIA_MODE_LONG_NAME, optional = true, doc = \"Set filters to mitochondrial defaults\")\n     public boolean mitochondria = false;\n \n+    /**\n+     * Mitochondria mode excludes the filters {@link ClusteredEventsFilter}, {@link MultiallelicFilter},", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQyNjU4NA==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570426584", "bodyText": "This also doesn't refrence the median mapping wquality change.", "author": "jamesemery", "createdAt": "2021-02-04T17:52:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQyNjI2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3NDMwODg2Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r674308862", "bodyText": "right now that flag is specified in the wdl for microbial mutect. We may decide to add it to the code when using this mode in a later PR", "author": "ahaessly", "createdAt": "2021-07-21T20:18:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQyNjI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQyNjcyNg==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570426726", "bodyText": "Why was this commented out?", "author": "jamesemery", "createdAt": "2021-02-04T17:52:55Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/filtering/M2FiltersArgumentCollection.java", "diffHunk": "@@ -62,12 +69,13 @@\n     private static final int DEFAULT_MAX_ALT_ALLELES = 1;\n     private static final int DEFAULT_MIN_UNIQUE_ALT_READS = 0;\n     private static final int DEFAULT_MIN_MEDIAN_MAPPING_QUALITY = 30;\n+    private static final int DEFAULT_MIN_MEDIAN_MAPPING_QUALITY_FOR_MICROBIAL = 20;\n     private static final int DEFAULT_MIN_MEDIAN_BASE_QUALITY = 20;\n     private static final int DEFAULT_MAX_MEDIAN_FRAGMENT_LENGTH_DIFFERENCE = 10000;\n     private static final int DEFAULT_MIN_MEDIAN_READ_POSITION = 1;\n     private static final double DEFAULT_MAX_N_RATIO = Double.POSITIVE_INFINITY;\n     private static final int DEFAULT_MIN_READS_ON_EACH_STRAND = 0;\n-    private static final double DEFAULT_MAX_NUMT_FRACTION = 0.85;\n+//    private static final double DEFAULT_MAX_NUMT_FRACTION = 0.85;", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3NDMwOTc4NA==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r674309784", "bodyText": "This filter is no longer used. Clean up from microbial PR", "author": "ahaessly", "createdAt": "2021-07-21T20:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQyNjcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQzMDA1Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570430056", "bodyText": "A few questions about this tool? Does it do this operation on all contigs in the fasta? The documentation doesn't seem to specify that? Perhaps there should be a mechanism to update that.", "author": "jamesemery", "createdAt": "2021-02-04T17:57:21Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQzMzAxNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570433015", "bodyText": "Why are you catching the se IllegalStateExceptions?", "author": "jamesemery", "createdAt": "2021-02-04T18:01:18Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n+        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n+        programGroup = ReferenceProgramGroup.class\n+)\n+public class ShiftFasta extends GATKTool {\n+\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Path to write the output fasta to\")\n+    protected String output;\n+\n+    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n+    @Argument(fullName = SHIFT_BACK_OUTPUT,\n+            doc = \"Path to write the shift_back file to\")\n+    protected String shiftBackOutput;\n+\n+    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n+    @Argument(fullName = SHIFT_OFFSET_LIST,\n+            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n+    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n+    private List<Integer> shiftOffsets = null;\n+\n+    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n+    @Argument(fullName = INTERAL_FILE_NAME,\n+            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n+    private String intervalFilename;\n+\n+    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n+    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n+    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n+\n+    ReferenceDataSource refSource;\n+    FastaReferenceWriter refWriter;\n+    FileWriter chainFileWriter;\n+    FileWriter intervalRegularWriter;\n+    FileWriter intervalShiftedWriter;\n+\n+    int chainId = 0;\n+\n+    @Override\n+    public boolean requiresReference() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n+        final Path path = IOUtils.getPath(output);\n+        chainId = 1;\n+        try {\n+            refWriter = new FastaReferenceWriterBuilder()\n+                    .setFastaFile(path)\n+                    .setBasesPerLine(basesPerLine)\n+                    .build();\n+            chainFileWriter = new FileWriter(shiftBackOutput);\n+            if (intervalFilename != null) {\n+                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n+                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n+            }\n+        } catch (IOException e) {\n+            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public void traverse() {\n+        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n+        long refLengthLong = refDict.getReferenceLength();\n+        if (refLengthLong > Integer.MAX_VALUE) {\n+            // TODO fix this??\n+            throw new UserException.BadInput(\"Reference length is too long\");\n+        }\n+        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n+        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n+                shiftOffsets.listIterator() : null;\n+        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n+    }\n+\n+    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n+        int contigLength = seq.getSequenceLength();\n+        int shiftOffset = shiftOffsetsIt == null ? contigLength/2 : shiftOffsetsIt.next();\n+        if (shiftOffset != 0) {\n+            byte[] bases = refSource.queryAndPrefetch(new SimpleInterval(seq.getSequenceName(), 1, contigLength)).getBases();\n+            byte[] basesAtEnd = Arrays.copyOfRange(bases, shiftOffset, bases.length);\n+            byte[] basesAtStart = Arrays.copyOf(bases, shiftOffset);\n+            int shiftBackOffset = bases.length - shiftOffset;\n+\n+            try {\n+                refWriter.startSequence(seq.getSequenceName(), basesPerLine);\n+                refWriter.appendBases(basesAtEnd).appendBases(basesAtStart);\n+                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftBackOffset, contigLength, shiftOffset, bases.length, 0, shiftBackOffset, chainId++));\n+                chainFileWriter.append(\"\\n\" + shiftBackOffset + \"\\n\\n\");\n+                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftOffset - 1, contigLength, 0, shiftOffset, shiftBackOffset, bases.length, chainId++));\n+                chainFileWriter.append(\"\\n\" + shiftOffset + \"\\n\\n\");\n+                if (intervalFilename != null && shiftOffsetsIt == null) {\n+                    int intervalStart = shiftOffset/2;\n+                    int intervalEnd = intervalStart + contigLength/2 - 1;\n+                    int shiftedIntervalStart = intervalStart;\n+                    int shiftedIntervalEnd = intervalEnd + contigLength % 2;\n+                    intervalRegularWriter.append(seq.getSequenceName() + \":\" + intervalStart + \"-\" + intervalEnd + \"\\n\");\n+                    intervalShiftedWriter.append(seq.getSequenceName() + \":\" + shiftedIntervalStart + \"-\" + shiftedIntervalEnd + \"\\n\");\n+                }\n+            } catch (IOException e) {\n+                throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n+            }\n+        }\n+    }\n+\n+    private String createChainString(String name, int score, int length, int start, int end, int shiftBackStart, int shiftBackEnd, int id) {\n+        String[] items = new String[] { \"chain\",\n+                Integer.toString(score),\n+                name,\n+                Integer.toString(length),\n+                \"+\",\n+                Integer.toString(shiftBackStart),\n+                Integer.toString(shiftBackEnd),\n+                name,\n+                Integer.toString(length),\n+                \"+\",\n+                Integer.toString(start),\n+                Integer.toString(end),\n+                Integer.toString(id)\n+        };\n+        return String.join(\"\\t\", items);\n+    }\n+\n+    @Override\n+    public Object onTraversalSuccess(){\n+        // TODO is this right?\n+        return null;\n+    }\n+\n+    @Override\n+    public void closeTool() {\n+        super.closeTool();\n+        try{\n+            if( refWriter != null ) {\n+                refWriter.close();\n+            }\n+        } catch (IllegalStateException e){\n+            //sink this\n+        } catch (IOException e) {\n+            throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n+        }\n+        try{\n+            if (chainFileWriter != null) {\n+                chainFileWriter.close();\n+            }\n+        } catch (IllegalStateException e){", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQzNDQ5OA==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570434498", "bodyText": "I would get rid of most of these try-catch blocks.", "author": "jamesemery", "createdAt": "2021-02-04T18:03:36Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n+        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n+        programGroup = ReferenceProgramGroup.class\n+)\n+public class ShiftFasta extends GATKTool {\n+\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Path to write the output fasta to\")\n+    protected String output;\n+\n+    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n+    @Argument(fullName = SHIFT_BACK_OUTPUT,\n+            doc = \"Path to write the shift_back file to\")\n+    protected String shiftBackOutput;\n+\n+    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n+    @Argument(fullName = SHIFT_OFFSET_LIST,\n+            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n+    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n+    private List<Integer> shiftOffsets = null;\n+\n+    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n+    @Argument(fullName = INTERAL_FILE_NAME,\n+            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n+    private String intervalFilename;\n+\n+    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n+    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n+    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n+\n+    ReferenceDataSource refSource;\n+    FastaReferenceWriter refWriter;\n+    FileWriter chainFileWriter;\n+    FileWriter intervalRegularWriter;\n+    FileWriter intervalShiftedWriter;\n+\n+    int chainId = 0;\n+\n+    @Override\n+    public boolean requiresReference() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n+        final Path path = IOUtils.getPath(output);\n+        chainId = 1;\n+        try {\n+            refWriter = new FastaReferenceWriterBuilder()\n+                    .setFastaFile(path)\n+                    .setBasesPerLine(basesPerLine)\n+                    .build();\n+            chainFileWriter = new FileWriter(shiftBackOutput);\n+            if (intervalFilename != null) {\n+                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n+                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n+            }\n+        } catch (IOException e) {\n+            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public void traverse() {\n+        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n+        long refLengthLong = refDict.getReferenceLength();\n+        if (refLengthLong > Integer.MAX_VALUE) {\n+            // TODO fix this??\n+            throw new UserException.BadInput(\"Reference length is too long\");\n+        }\n+        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n+        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n+                shiftOffsets.listIterator() : null;\n+        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n+    }\n+\n+    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n+        int contigLength = seq.getSequenceLength();\n+        int shiftOffset = shiftOffsetsIt == null ? contigLength/2 : shiftOffsetsIt.next();\n+        if (shiftOffset != 0) {\n+            byte[] bases = refSource.queryAndPrefetch(new SimpleInterval(seq.getSequenceName(), 1, contigLength)).getBases();\n+            byte[] basesAtEnd = Arrays.copyOfRange(bases, shiftOffset, bases.length);\n+            byte[] basesAtStart = Arrays.copyOf(bases, shiftOffset);\n+            int shiftBackOffset = bases.length - shiftOffset;\n+\n+            try {\n+                refWriter.startSequence(seq.getSequenceName(), basesPerLine);\n+                refWriter.appendBases(basesAtEnd).appendBases(basesAtStart);\n+                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftBackOffset, contigLength, shiftOffset, bases.length, 0, shiftBackOffset, chainId++));\n+                chainFileWriter.append(\"\\n\" + shiftBackOffset + \"\\n\\n\");\n+                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftOffset - 1, contigLength, 0, shiftOffset, shiftBackOffset, bases.length, chainId++));\n+                chainFileWriter.append(\"\\n\" + shiftOffset + \"\\n\\n\");\n+                if (intervalFilename != null && shiftOffsetsIt == null) {\n+                    int intervalStart = shiftOffset/2;\n+                    int intervalEnd = intervalStart + contigLength/2 - 1;\n+                    int shiftedIntervalStart = intervalStart;\n+                    int shiftedIntervalEnd = intervalEnd + contigLength % 2;\n+                    intervalRegularWriter.append(seq.getSequenceName() + \":\" + intervalStart + \"-\" + intervalEnd + \"\\n\");\n+                    intervalShiftedWriter.append(seq.getSequenceName() + \":\" + shiftedIntervalStart + \"-\" + shiftedIntervalEnd + \"\\n\");\n+                }\n+            } catch (IOException e) {\n+                throw new UserException(\"Failed to write fasta due to \" + e.getMessage(), e);\n+            }\n+        }\n+    }\n+\n+    private String createChainString(String name, int score, int length, int start, int end, int shiftBackStart, int shiftBackEnd, int id) {\n+        String[] items = new String[] { \"chain\",\n+                Integer.toString(score),\n+                name,\n+                Integer.toString(length),\n+                \"+\",\n+                Integer.toString(shiftBackStart),\n+                Integer.toString(shiftBackEnd),\n+                name,\n+                Integer.toString(length),\n+                \"+\",\n+                Integer.toString(start),\n+                Integer.toString(end),\n+                Integer.toString(id)\n+        };\n+        return String.join(\"\\t\", items);\n+    }\n+\n+    @Override\n+    public Object onTraversalSuccess(){\n+        // TODO is this right?\n+        return null;\n+    }\n+\n+    @Override\n+    public void closeTool() {\n+        super.closeTool();\n+        try{\n+            if( refWriter != null ) {\n+                refWriter.close();\n+            }\n+        } catch (IllegalStateException e){\n+            //sink this", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQzNzE3Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570437176", "bodyText": "This method needs some comments.", "author": "jamesemery", "createdAt": "2021-02-04T18:07:35Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n+        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n+        programGroup = ReferenceProgramGroup.class\n+)\n+public class ShiftFasta extends GATKTool {\n+\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Path to write the output fasta to\")\n+    protected String output;\n+\n+    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n+    @Argument(fullName = SHIFT_BACK_OUTPUT,\n+            doc = \"Path to write the shift_back file to\")\n+    protected String shiftBackOutput;\n+\n+    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n+    @Argument(fullName = SHIFT_OFFSET_LIST,\n+            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n+    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n+    private List<Integer> shiftOffsets = null;\n+\n+    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n+    @Argument(fullName = INTERAL_FILE_NAME,\n+            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n+    private String intervalFilename;\n+\n+    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n+    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n+    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n+\n+    ReferenceDataSource refSource;\n+    FastaReferenceWriter refWriter;\n+    FileWriter chainFileWriter;\n+    FileWriter intervalRegularWriter;\n+    FileWriter intervalShiftedWriter;\n+\n+    int chainId = 0;\n+\n+    @Override\n+    public boolean requiresReference() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n+        final Path path = IOUtils.getPath(output);\n+        chainId = 1;\n+        try {\n+            refWriter = new FastaReferenceWriterBuilder()\n+                    .setFastaFile(path)\n+                    .setBasesPerLine(basesPerLine)\n+                    .build();\n+            chainFileWriter = new FileWriter(shiftBackOutput);\n+            if (intervalFilename != null) {\n+                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n+                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n+            }\n+        } catch (IOException e) {\n+            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public void traverse() {\n+        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n+        long refLengthLong = refDict.getReferenceLength();\n+        if (refLengthLong > Integer.MAX_VALUE) {\n+            // TODO fix this??\n+            throw new UserException.BadInput(\"Reference length is too long\");\n+        }\n+        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n+        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n+                shiftOffsets.listIterator() : null;\n+        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n+    }\n+\n+    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQzNzI4OA==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570437288", "bodyText": "final", "author": "jamesemery", "createdAt": "2021-02-04T18:07:45Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n+        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n+        programGroup = ReferenceProgramGroup.class\n+)\n+public class ShiftFasta extends GATKTool {\n+\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Path to write the output fasta to\")\n+    protected String output;\n+\n+    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n+    @Argument(fullName = SHIFT_BACK_OUTPUT,\n+            doc = \"Path to write the shift_back file to\")\n+    protected String shiftBackOutput;\n+\n+    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n+    @Argument(fullName = SHIFT_OFFSET_LIST,\n+            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n+    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n+    private List<Integer> shiftOffsets = null;\n+\n+    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n+    @Argument(fullName = INTERAL_FILE_NAME,\n+            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n+    private String intervalFilename;\n+\n+    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n+    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n+    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n+\n+    ReferenceDataSource refSource;\n+    FastaReferenceWriter refWriter;\n+    FileWriter chainFileWriter;\n+    FileWriter intervalRegularWriter;\n+    FileWriter intervalShiftedWriter;\n+\n+    int chainId = 0;\n+\n+    @Override\n+    public boolean requiresReference() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n+        final Path path = IOUtils.getPath(output);\n+        chainId = 1;\n+        try {\n+            refWriter = new FastaReferenceWriterBuilder()\n+                    .setFastaFile(path)\n+                    .setBasesPerLine(basesPerLine)\n+                    .build();\n+            chainFileWriter = new FileWriter(shiftBackOutput);\n+            if (intervalFilename != null) {\n+                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n+                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n+            }\n+        } catch (IOException e) {\n+            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public void traverse() {\n+        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n+        long refLengthLong = refDict.getReferenceLength();\n+        if (refLengthLong > Integer.MAX_VALUE) {\n+            // TODO fix this??\n+            throw new UserException.BadInput(\"Reference length is too long\");\n+        }\n+        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n+        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n+                shiftOffsets.listIterator() : null;\n+        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n+    }\n+\n+    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n+        int contigLength = seq.getSequenceLength();", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQzODMyMw==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570438323", "bodyText": "I would pull this int a method \"writechainfileline(etc..)\"", "author": "jamesemery", "createdAt": "2021-02-04T18:09:13Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n+        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n+        programGroup = ReferenceProgramGroup.class\n+)\n+public class ShiftFasta extends GATKTool {\n+\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Path to write the output fasta to\")\n+    protected String output;\n+\n+    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n+    @Argument(fullName = SHIFT_BACK_OUTPUT,\n+            doc = \"Path to write the shift_back file to\")\n+    protected String shiftBackOutput;\n+\n+    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n+    @Argument(fullName = SHIFT_OFFSET_LIST,\n+            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n+    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n+    private List<Integer> shiftOffsets = null;\n+\n+    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n+    @Argument(fullName = INTERAL_FILE_NAME,\n+            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n+    private String intervalFilename;\n+\n+    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n+    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n+    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n+\n+    ReferenceDataSource refSource;\n+    FastaReferenceWriter refWriter;\n+    FileWriter chainFileWriter;\n+    FileWriter intervalRegularWriter;\n+    FileWriter intervalShiftedWriter;\n+\n+    int chainId = 0;\n+\n+    @Override\n+    public boolean requiresReference() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n+        final Path path = IOUtils.getPath(output);\n+        chainId = 1;\n+        try {\n+            refWriter = new FastaReferenceWriterBuilder()\n+                    .setFastaFile(path)\n+                    .setBasesPerLine(basesPerLine)\n+                    .build();\n+            chainFileWriter = new FileWriter(shiftBackOutput);\n+            if (intervalFilename != null) {\n+                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n+                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n+            }\n+        } catch (IOException e) {\n+            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public void traverse() {\n+        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n+        long refLengthLong = refDict.getReferenceLength();\n+        if (refLengthLong > Integer.MAX_VALUE) {\n+            // TODO fix this??\n+            throw new UserException.BadInput(\"Reference length is too long\");\n+        }\n+        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n+        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n+                shiftOffsets.listIterator() : null;\n+        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n+    }\n+\n+    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n+        int contigLength = seq.getSequenceLength();\n+        int shiftOffset = shiftOffsetsIt == null ? contigLength/2 : shiftOffsetsIt.next();\n+        if (shiftOffset != 0) {\n+            byte[] bases = refSource.queryAndPrefetch(new SimpleInterval(seq.getSequenceName(), 1, contigLength)).getBases();\n+            byte[] basesAtEnd = Arrays.copyOfRange(bases, shiftOffset, bases.length);\n+            byte[] basesAtStart = Arrays.copyOf(bases, shiftOffset);\n+            int shiftBackOffset = bases.length - shiftOffset;\n+\n+            try {\n+                refWriter.startSequence(seq.getSequenceName(), basesPerLine);\n+                refWriter.appendBases(basesAtEnd).appendBases(basesAtStart);\n+                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftBackOffset, contigLength, shiftOffset, bases.length, 0, shiftBackOffset, chainId++));", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQzOTc1MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570439751", "bodyText": "I would compartmentalize these writers into their own methods to make it a bit clearer and safer.", "author": "jamesemery", "createdAt": "2021-02-04T18:11:26Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n+        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n+        programGroup = ReferenceProgramGroup.class\n+)\n+public class ShiftFasta extends GATKTool {\n+\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Path to write the output fasta to\")\n+    protected String output;\n+\n+    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n+    @Argument(fullName = SHIFT_BACK_OUTPUT,\n+            doc = \"Path to write the shift_back file to\")\n+    protected String shiftBackOutput;\n+\n+    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n+    @Argument(fullName = SHIFT_OFFSET_LIST,\n+            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n+    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n+    private List<Integer> shiftOffsets = null;\n+\n+    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n+    @Argument(fullName = INTERAL_FILE_NAME,\n+            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n+    private String intervalFilename;\n+\n+    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n+    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n+    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n+\n+    ReferenceDataSource refSource;\n+    FastaReferenceWriter refWriter;\n+    FileWriter chainFileWriter;\n+    FileWriter intervalRegularWriter;\n+    FileWriter intervalShiftedWriter;\n+\n+    int chainId = 0;\n+\n+    @Override\n+    public boolean requiresReference() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n+        final Path path = IOUtils.getPath(output);\n+        chainId = 1;\n+        try {\n+            refWriter = new FastaReferenceWriterBuilder()\n+                    .setFastaFile(path)\n+                    .setBasesPerLine(basesPerLine)\n+                    .build();\n+            chainFileWriter = new FileWriter(shiftBackOutput);\n+            if (intervalFilename != null) {\n+                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n+                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n+            }\n+        } catch (IOException e) {\n+            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public void traverse() {\n+        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n+        long refLengthLong = refDict.getReferenceLength();\n+        if (refLengthLong > Integer.MAX_VALUE) {\n+            // TODO fix this??\n+            throw new UserException.BadInput(\"Reference length is too long\");\n+        }\n+        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n+        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n+                shiftOffsets.listIterator() : null;\n+        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n+    }\n+\n+    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n+        int contigLength = seq.getSequenceLength();\n+        int shiftOffset = shiftOffsetsIt == null ? contigLength/2 : shiftOffsetsIt.next();\n+        if (shiftOffset != 0) {\n+            byte[] bases = refSource.queryAndPrefetch(new SimpleInterval(seq.getSequenceName(), 1, contigLength)).getBases();\n+            byte[] basesAtEnd = Arrays.copyOfRange(bases, shiftOffset, bases.length);\n+            byte[] basesAtStart = Arrays.copyOf(bases, shiftOffset);\n+            int shiftBackOffset = bases.length - shiftOffset;\n+\n+            try {\n+                refWriter.startSequence(seq.getSequenceName(), basesPerLine);\n+                refWriter.appendBases(basesAtEnd).appendBases(basesAtStart);\n+                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftBackOffset, contigLength, shiftOffset, bases.length, 0, shiftBackOffset, chainId++));\n+                chainFileWriter.append(\"\\n\" + shiftBackOffset + \"\\n\\n\");\n+                chainFileWriter.append(createChainString(seq.getSequenceName(), shiftOffset - 1, contigLength, 0, shiftOffset, shiftBackOffset, bases.length, chainId++));\n+                chainFileWriter.append(\"\\n\" + shiftOffset + \"\\n\\n\");\n+                if (intervalFilename != null && shiftOffsetsIt == null) {\n+                    int intervalStart = shiftOffset/2;", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQ0MDI5Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570440292", "bodyText": "all these can be private", "author": "jamesemery", "createdAt": "2021-02-04T18:12:14Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n+        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n+        programGroup = ReferenceProgramGroup.class\n+)\n+public class ShiftFasta extends GATKTool {\n+\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Path to write the output fasta to\")\n+    protected String output;\n+\n+    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n+    @Argument(fullName = SHIFT_BACK_OUTPUT,\n+            doc = \"Path to write the shift_back file to\")\n+    protected String shiftBackOutput;\n+\n+    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n+    @Argument(fullName = SHIFT_OFFSET_LIST,\n+            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n+    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n+    private List<Integer> shiftOffsets = null;\n+\n+    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n+    @Argument(fullName = INTERAL_FILE_NAME,\n+            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n+    private String intervalFilename;\n+\n+    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n+    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n+    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n+\n+    ReferenceDataSource refSource;", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQ0MDU1Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570440557", "bodyText": "Can you add a CLI example here? That would make it a little easier for users to tell how this tool works.", "author": "jamesemery", "createdAt": "2021-02-04T18:12:43Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQ0MTYyNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570441625", "bodyText": "Can you add a integration test for this tool? It seems pretty straightforward but as of right now it seems to pretty simply shift whatever contigs are in the fasta that is provided. It would be nice to have a test on one of the existing small fasta files in the test suite to check that the tool is doing something correctly. At worst you could simply make the liftover files etc for the mitochondria which would be nice to have checked in anyway.", "author": "jamesemery", "createdAt": "2021-02-04T18:14:22Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n+        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQ0MjkwOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570442909", "bodyText": "Can you put a check here that makes sure the list is the same size as the length of the fasta file?", "author": "jamesemery", "createdAt": "2021-02-04T18:16:20Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n+        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n+        programGroup = ReferenceProgramGroup.class\n+)\n+public class ShiftFasta extends GATKTool {\n+\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Path to write the output fasta to\")\n+    protected String output;\n+\n+    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n+    @Argument(fullName = SHIFT_BACK_OUTPUT,\n+            doc = \"Path to write the shift_back file to\")\n+    protected String shiftBackOutput;\n+\n+    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n+    @Argument(fullName = SHIFT_OFFSET_LIST,\n+            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n+    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n+    private List<Integer> shiftOffsets = null;\n+\n+    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n+    @Argument(fullName = INTERAL_FILE_NAME,\n+            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n+    private String intervalFilename;\n+\n+    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n+    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n+    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n+\n+    ReferenceDataSource refSource;\n+    FastaReferenceWriter refWriter;\n+    FileWriter chainFileWriter;\n+    FileWriter intervalRegularWriter;\n+    FileWriter intervalShiftedWriter;\n+\n+    int chainId = 0;\n+\n+    @Override\n+    public boolean requiresReference() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n+        final Path path = IOUtils.getPath(output);\n+        chainId = 1;\n+        try {\n+            refWriter = new FastaReferenceWriterBuilder()\n+                    .setFastaFile(path)\n+                    .setBasesPerLine(basesPerLine)\n+                    .build();\n+            chainFileWriter = new FileWriter(shiftBackOutput);\n+            if (intervalFilename != null) {\n+                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n+                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n+            }\n+        } catch (IOException e) {\n+            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public void traverse() {\n+        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n+        long refLengthLong = refDict.getReferenceLength();\n+        if (refLengthLong > Integer.MAX_VALUE) {\n+            // TODO fix this??\n+            throw new UserException.BadInput(\"Reference length is too long\");\n+        }\n+        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n+        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjk5Njg0MA==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r572996840", "bodyText": "isn't that what this check is doing? making sure that we have a shift offset for each contig:\nshiftOffsets.size() == contigs.size()", "author": "ahaessly", "createdAt": "2021-02-09T15:43:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQ0MjkwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzAxMTIwMA==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r573011200", "bodyText": "You are right. However I still think we should be very careful about the shift offsets input. I think we should put a check here that asserts it is either empty OR it is exactly the lenght of the contigs in the file, otherwise if it is the wrong size we should throw a user exception since clearly there was a mistake.", "author": "jamesemery", "createdAt": "2021-02-09T15:59:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQ0MjkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQ0NDM4Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570444382", "bodyText": "How difficult would it be to add an integration test to M2 that asserts this argument is doing something reasonable?", "author": "jamesemery", "createdAt": "2021-02-04T18:18:32Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/filtering/M2FiltersArgumentCollection.java", "diffHunk": "@@ -43,6 +43,13 @@\n     @Argument(fullName = M2ArgumentCollection.MITOCHONDRIA_MODE_LONG_NAME, optional = true, doc = \"Set filters to mitochondrial defaults\")\n     public boolean mitochondria = false;\n \n+    /**\n+     * Mitochondria mode excludes the filters {@link ClusteredEventsFilter}, {@link MultiallelicFilter},\n+     * {@link FilteredHaplotypeFilter}, {@link FragmentLengthFilter}, and {@link GermlineFilter}\n+     */\n+    @Argument(fullName = M2ArgumentCollection.MICROBIAL_MODE_LONG_NAME, optional = true, doc = \"Set filters to microbial defaults\")", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQ0NTYwNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r570445605", "bodyText": "Here you need to add some tests that assert the offset is within the range of the actual file? There seems to be no check that the user cant specify a bogus value in the list input.", "author": "jamesemery", "createdAt": "2021-02-04T18:20:28Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"Create a new fasta starting at the shift-offset +1 position and a shift_back chain file that can be used with the Liftover tool\",\n+        oneLineSummary = \"Creates a shifted fasta file and shift_back file\",\n+        programGroup = ReferenceProgramGroup.class\n+)\n+public class ShiftFasta extends GATKTool {\n+\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Path to write the output fasta to\")\n+    protected String output;\n+\n+    public static final String SHIFT_BACK_OUTPUT = \"shift-back-output\";\n+    @Argument(fullName = SHIFT_BACK_OUTPUT,\n+            doc = \"Path to write the shift_back file to\")\n+    protected String shiftBackOutput;\n+\n+    public static final String SHIFT_OFFSET_LIST = \"shift-offset-list\";\n+    @Argument(fullName = SHIFT_OFFSET_LIST,\n+            doc=\"Number of bases to skip in the reference before starting the shifted reference. For example, if 300 is specified, the new fasta will start at the 301th base (count starting at 1).\" +\n+    \"If not specified, the contig will be shifted by half the number of bases. To skip the shifting of a contig, specify 0 in the list.\", optional = true)\n+    private List<Integer> shiftOffsets = null;\n+\n+    public static final String INTERAL_FILE_NAME = \"interval-file-name\";\n+    @Argument(fullName = INTERAL_FILE_NAME,\n+            doc=\"Base name for interval files. Intervals will be midway between beginning and computed offset. If not specified or if custom offsets are specified, no interval files will be written.\", optional = true)\n+    private String intervalFilename;\n+\n+    public static final String LINE_WIDTH_LONG_NAME = \"line-width\";\n+    @Argument(fullName= LINE_WIDTH_LONG_NAME, doc=\"Maximum length of sequence to write per line\", optional=true)\n+    public int basesPerLine = FastaReferenceWriter.DEFAULT_BASES_PER_LINE;\n+\n+    ReferenceDataSource refSource;\n+    FastaReferenceWriter refWriter;\n+    FileWriter chainFileWriter;\n+    FileWriter intervalRegularWriter;\n+    FileWriter intervalShiftedWriter;\n+\n+    int chainId = 0;\n+\n+    @Override\n+    public boolean requiresReference() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        refSource = referenceArguments.getReferencePath() != null ? ReferenceDataSource.of(referenceArguments.getReferencePath()) : null;\n+        final Path path = IOUtils.getPath(output);\n+        chainId = 1;\n+        try {\n+            refWriter = new FastaReferenceWriterBuilder()\n+                    .setFastaFile(path)\n+                    .setBasesPerLine(basesPerLine)\n+                    .build();\n+            chainFileWriter = new FileWriter(shiftBackOutput);\n+            if (intervalFilename != null) {\n+                intervalRegularWriter = new FileWriter(intervalFilename+ \".intervals\");\n+                intervalShiftedWriter = new FileWriter(intervalFilename + \".shifted.intervals\");\n+            }\n+        } catch (IOException e) {\n+            throw new UserException.CouldNotCreateOutputFile(\"Couldn't create \" + output + \", encountered exception: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public void traverse() {\n+        SAMSequenceDictionary refDict = refSource.getSequenceDictionary();\n+        long refLengthLong = refDict.getReferenceLength();\n+        if (refLengthLong > Integer.MAX_VALUE) {\n+            // TODO fix this??\n+            throw new UserException.BadInput(\"Reference length is too long\");\n+        }\n+        List<SAMSequenceRecord> contigs = refSource.getSequenceDictionary().getSequences();\n+        final ListIterator<Integer> shiftOffsetsIt = (shiftOffsets != null && shiftOffsets.size() == contigs.size()) ?\n+                shiftOffsets.listIterator() : null;\n+        refSource.getSequenceDictionary().getSequences().forEach(seq -> shiftContig(seq, shiftOffsetsIt));\n+    }\n+\n+    protected void shiftContig(SAMSequenceRecord seq, ListIterator<Integer> shiftOffsetsIt) {\n+        int contigLength = seq.getSequenceLength();\n+        int shiftOffset = shiftOffsetsIt == null ? contigLength/2 : shiftOffsetsIt.next();\n+        if (shiftOffset != 0) {\n+            byte[] bases = refSource.queryAndPrefetch(new SimpleInterval(seq.getSequenceName(), 1, contigLength)).getBases();\n+            byte[] basesAtEnd = Arrays.copyOfRange(bases, shiftOffset, bases.length);\n+            byte[] basesAtStart = Arrays.copyOf(bases, shiftOffset);\n+            int shiftBackOffset = bases.length - shiftOffset;", "originalCommit": "f3737bb3e2c6cd2697fa6cf83402ff612884fc13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3f39bee1600efd798400dfedcb3aeb107eaa577b", "url": "https://github.com/broadinstitute/gatk/commit/3f39bee1600efd798400dfedcb3aeb107eaa577b", "message": "parent 6d4310368601f28c9557746307fe1ac089156fe4\nauthor Andrea Haessly <ahaessly@broadinstitute.org> 1582141271 -0500\ncommitter Andrea Haessly <ahaessly@broadinstitute.org> 1611852899 -0500\n\nparent 6d4310368601f28c9557746307fe1ac089156fe4\nauthor Andrea Haessly <ahaessly@broadinstitute.org> 1582141271 -0500\ncommitter Andrea Haessly <ahaessly@broadinstitute.org> 1611852778 -0500\n\ninitial impl\ntested shift and chain\nmake offset optional\nfix format of chain file\nmake offset optional\nfix format of chain file\nadd interval output", "committedDate": "2021-03-15T19:55:28Z", "type": "forcePushed"}, {"oid": "0558f716d17af39e183a7b0580c8b787ec7abe1f", "url": "https://github.com/broadinstitute/gatk/commit/0558f716d17af39e183a7b0580c8b787ec7abe1f", "message": "rebased version of this code", "committedDate": "2021-03-19T17:53:17Z", "type": "commit"}, {"oid": "c7d014fa4f482a57d11c5f8deda44e245f3b98b4", "url": "https://github.com/broadinstitute/gatk/commit/c7d014fa4f482a57d11c5f8deda44e245f3b98b4", "message": "fixed an issue where the logic for suffix ends was incorrect for dangling tails", "committedDate": "2021-03-19T17:53:22Z", "type": "commit"}, {"oid": "dd6907dbfc0196f7e6b9a4dc6119fd324a1c6e36", "url": "https://github.com/broadinstitute/gatk/commit/dd6907dbfc0196f7e6b9a4dc6119fd324a1c6e36", "message": "responding to review comments", "committedDate": "2021-03-19T17:53:26Z", "type": "commit"}, {"oid": "e94783ae99012ec1341c2b23100daf21f40b37ec", "url": "https://github.com/broadinstitute/gatk/commit/e94783ae99012ec1341c2b23100daf21f40b37ec", "message": "manual rebase", "committedDate": "2021-03-19T17:53:32Z", "type": "commit"}, {"oid": "e3865a05e986f8d7b7c64fdf232adb188abe7cf3", "url": "https://github.com/broadinstitute/gatk/commit/e3865a05e986f8d7b7c64fdf232adb188abe7cf3", "message": "change misspellings of dangling to the correct spelling", "committedDate": "2021-03-19T17:53:36Z", "type": "commit"}, {"oid": "14f82aeda2087989b2812a3519fd9ea12e9c52ea", "url": "https://github.com/broadinstitute/gatk/commit/14f82aeda2087989b2812a3519fd9ea12e9c52ea", "message": "remove change from bad merge", "committedDate": "2021-03-19T17:53:41Z", "type": "commit"}, {"oid": "e389981dfa26d5346daf3cc498eb32dcef145f7c", "url": "https://github.com/broadinstitute/gatk/commit/e389981dfa26d5346daf3cc498eb32dcef145f7c", "message": "parent 6d4310368601f28c9557746307fe1ac089156fe4\nauthor Andrea Haessly <ahaessly@broadinstitute.org> 1582141271 -0500\ncommitter Andrea Haessly <ahaessly@broadinstitute.org> 1611852899 -0500\n\nparent 6d4310368601f28c9557746307fe1ac089156fe4\nauthor Andrea Haessly <ahaessly@broadinstitute.org> 1582141271 -0500\ncommitter Andrea Haessly <ahaessly@broadinstitute.org> 1611852778 -0500\n\ninitial impl\ntested shift and chain\nmake offset optional\nfix format of chain file\nmake offset optional\nfix format of chain file\nadd interval output", "committedDate": "2021-03-19T17:53:46Z", "type": "commit"}, {"oid": "a4f8290f1c2760eb028efd7c960e214f4e2a0586", "url": "https://github.com/broadinstitute/gatk/commit/a4f8290f1c2760eb028efd7c960e214f4e2a0586", "message": "check for is empty", "committedDate": "2021-03-19T17:53:51Z", "type": "commit"}, {"oid": "a4f8290f1c2760eb028efd7c960e214f4e2a0586", "url": "https://github.com/broadinstitute/gatk/commit/a4f8290f1c2760eb028efd7c960e214f4e2a0586", "message": "check for is empty", "committedDate": "2021-03-19T17:53:51Z", "type": "forcePushed"}, {"oid": "ea496546f3ad8b66a9b710019a0bea0b6863f315", "url": "https://github.com/broadinstitute/gatk/commit/ea496546f3ad8b66a9b710019a0bea0b6863f315", "message": "add test, update from PR", "committedDate": "2021-03-19T18:09:25Z", "type": "commit"}, {"oid": "c9947f5a2596f71796877fd36757a590af50cf69", "url": "https://github.com/broadinstitute/gatk/commit/c9947f5a2596f71796877fd36757a590af50cf69", "message": "update from PR", "committedDate": "2021-03-22T15:08:25Z", "type": "commit"}, {"oid": "e77cda46991075b3625604a59343c2a784268e1e", "url": "https://github.com/broadinstitute/gatk/commit/e77cda46991075b3625604a59343c2a784268e1e", "message": "update from PR", "committedDate": "2021-04-01T17:52:38Z", "type": "commit"}, {"oid": "0f5d2180644190730cf9461ff35a5244518b1f72", "url": "https://github.com/broadinstitute/gatk/commit/0f5d2180644190730cf9461ff35a5244518b1f72", "message": "update documentation", "committedDate": "2021-07-21T20:27:32Z", "type": "commit"}, {"oid": "3652446773f28f6a79c12fef515364f0b3aca5f3", "url": "https://github.com/broadinstitute/gatk/commit/3652446773f28f6a79c12fef515364f0b3aca5f3", "message": "add pruner fix", "committedDate": "2021-07-21T20:29:18Z", "type": "commit"}, {"oid": "a1261ae54b4e6c7e3b71394c19336c73e73cd469", "url": "https://github.com/broadinstitute/gatk/commit/a1261ae54b4e6c7e3b71394c19336c73e73cd469", "message": "remove unfinished code", "committedDate": "2021-07-21T20:34:12Z", "type": "commit"}, {"oid": "bd288381be7b071754fd8ca9552af24500044e63", "url": "https://github.com/broadinstitute/gatk/commit/bd288381be7b071754fd8ca9552af24500044e63", "message": "test microbial mode", "committedDate": "2021-07-21T21:43:15Z", "type": "commit"}, {"oid": "af9f90aad04a9366a867dc67fb941e641b648813", "url": "https://github.com/broadinstitute/gatk/commit/af9f90aad04a9366a867dc67fb941e641b648813", "message": "fix bug", "committedDate": "2021-07-21T22:32:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3NTcyNzA2NA==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r675727064", "bodyText": "I would scrub out the folder references here and replace them with something like (<CIRCULAR.FASTA> etc...). Its generally confusing to see references like these in the docs especially when the data aren't checked into our repo.", "author": "jamesemery", "createdAt": "2021-07-23T17:34:00Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,245 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ * Example command line:\n+ * ShiftFasta\n+ * -R \"testfiles/shift/ecoli/Escherichia_coli_2017C-4173W12.fa\"   // the reference to shift\n+ * -O \"testfiles/shift/ecoli/shifted.fa\"                          // the shifted fasta\n+ * --shift-back-output \"testfiles/shift/ecoli/shiftback.chain\"    // the shiftback chain file to use when lifting over", "originalCommit": "af9f90aad04a9366a867dc67fb941e641b648813", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3NTczMTg1Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r675731856", "bodyText": "Rename to \"ShiftFastaIntegrationTest\" the test suite uses reflection to decide where to run tests so naming them correctly is important.", "author": "jamesemery", "createdAt": "2021-07-23T17:42:35Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFastaTest.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.GATKBaseTest;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.testutils.BaseTest;\n+import org.broadinstitute.hellbender.testutils.FastaTestUtils;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+\n+public class ShiftFastaTest extends CommandLineProgramTest {", "originalCommit": "af9f90aad04a9366a867dc67fb941e641b648813", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3NTczMzc0MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r675733741", "bodyText": "Can you make sure this is properly checked in? It may be an issue with github display but I don't see those files being checked in for this PR so you may have forgotten to add them properly through lfs.", "author": "jamesemery", "createdAt": "2021-07-23T17:46:09Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFastaTest.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.GATKBaseTest;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.testutils.BaseTest;\n+import org.broadinstitute.hellbender.testutils.FastaTestUtils;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+\n+public class ShiftFastaTest extends CommandLineProgramTest {\n+\n+    private static final File MITO_REF = new File(toolsTestDir, \"mutect/mito/Homo_sapiens_assembly38.mt_only.fasta\");\n+    private static final File SHIFTED_MITO_REF = new File(largeFileTestDir + \"mitochondria_references/Homo_sapiens_assembly38.chrM.shifted_by_8000_bases.fasta\");", "originalCommit": "af9f90aad04a9366a867dc67fb941e641b648813", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3NTczODE4OA==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r675738188", "bodyText": "This is up to you but you may consider adding the @BetaFeature tag to this tool since its a new tool part of an in-development pipeline.", "author": "jamesemery", "createdAt": "2021-07-23T17:54:11Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/fasta/ShiftFasta.java", "diffHunk": "@@ -0,0 +1,245 @@\n+package org.broadinstitute.hellbender.tools.walkers.fasta;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.SAMSequenceRecord;\n+import htsjdk.samtools.reference.FastaReferenceWriter;\n+import htsjdk.samtools.reference.FastaReferenceWriterBuilder;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.GATKTool;\n+import org.broadinstitute.hellbender.engine.ReferenceDataSource;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import picard.cmdline.programgroups.ReferenceProgramGroup;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Create a fasta with the bases shifted by offset\n+ *\n+ * delta1 = offset - 1\n+ * delta2 = total - delta1\n+ *\n+ * To shift forward:\n+ * if you are given a position in the regular fasta (pos_r) and want the position in the shifted fasta (pos_s):\n+ * if pos_r > delta1 => pos_s = pos_r - delta1  ==   pos_r - offset +1\n+ *   otherwise          pos_s = pos_r + delta2  ==   pos_r + total - offset + 1\n+ *\n+ * To shift back:\n+ * if you are given a position in the shifted fasta (pos_s) and want the position in the regular fasta (pos_r):\n+ * if pos_s > delta2 => pos_r = pos_s - delta2  ==   pos_s - total + offset - 1\n+ *   otherwise          pos_r = pos_s + delta1  ==   pos_s + offset - 1\n+ *\n+ * Example command line:\n+ * ShiftFasta\n+ * -R \"testfiles/shift/ecoli/Escherichia_coli_2017C-4173W12.fa\"   // the reference to shift\n+ * -O \"testfiles/shift/ecoli/shifted.fa\"                          // the shifted fasta\n+ * --shift-back-output \"testfiles/shift/ecoli/shiftback.chain\"    // the shiftback chain file to use when lifting over\n+ * --interval-file-name \"testfiles/shift/ecoli/ecoli\"             // base name for output interval files (one for regular and one for shifted)\n+ * --line-width 100\n+ */\n+@DocumentedFeature\n+@CommandLineProgramProperties(", "originalCommit": "af9f90aad04a9366a867dc67fb941e641b648813", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY3NTc0MDYzMA==", "url": "https://github.com/broadinstitute/gatk/pull/6694#discussion_r675740630", "bodyText": "Right I remember this change. When you do the squash + merge of this branch can you make sure its clearly stated in the commit description that this changes the behavior of the adaptive pruner at low/patchy reference coverage sites? This somewhat of a substantial fix to that method and it will be buried by this commit if we aren't careful.", "author": "jamesemery", "createdAt": "2021-07-23T17:56:38Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/graphs/AdaptiveChainPruner.java", "diffHunk": "@@ -56,11 +56,11 @@ public AdaptiveChainPruner(final double initialErrorProbability, final double lo\n         final Multimap<V, Path<V,E>> vertexToGoodOutgoingChains = ArrayListMultimap.create();\n \n         for (final Path<V,E> chain : chains) {\n-            if (chainLogOdds.get(chain).getRight() >= logOddsThreshold) {", "originalCommit": "af9f90aad04a9366a867dc67fb941e641b648813", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c0c54745029ffb2c63492ee85e563710a12c1d22", "url": "https://github.com/broadinstitute/gatk/commit/c0c54745029ffb2c63492ee85e563710a12c1d22", "message": "this changes the behavior of the adaptive pruner at low/patchy reference coverage sites\\nAdd large files to resources", "committedDate": "2021-07-27T17:52:16Z", "type": "commit"}, {"oid": "b08dc270ab2b1495047ff97e3dc04d7d29ab1421", "url": "https://github.com/broadinstitute/gatk/commit/b08dc270ab2b1495047ff97e3dc04d7d29ab1421", "message": "doc as beta feature", "committedDate": "2021-07-29T15:16:14Z", "type": "commit"}]}