{"pr_number": 11480, "pr_title": "Add an HDFS validation tool", "pr_createdAt": "2020-05-27T15:35:16Z", "pr_url": "https://github.com/Alluxio/alluxio/pull/11480", "timeline": [{"oid": "787730a5f680c44da066e6f5f6de3a1cf558fdc0", "url": "https://github.com/Alluxio/alluxio/commit/787730a5f680c44da066e6f5f6de3a1cf558fdc0", "message": "testing", "committedDate": "2020-05-18T15:00:32Z", "type": "commit"}, {"oid": "8aa0986241bcc1b4e8b259aab045398513d15c72", "url": "https://github.com/Alluxio/alluxio/commit/8aa0986241bcc1b4e8b259aab045398513d15c72", "message": "add driver command", "committedDate": "2020-05-19T07:02:24Z", "type": "commit"}, {"oid": "64f17091ac173f98a2d7c55c12146c6d8a662415", "url": "https://github.com/Alluxio/alluxio/commit/64f17091ac173f98a2d7c55c12146c6d8a662415", "message": "core logic, doesn't compile", "committedDate": "2020-05-27T15:32:38Z", "type": "commit"}, {"oid": "53b595426200dfdc63002a8cf3ac9695f80f9450", "url": "https://github.com/Alluxio/alluxio/commit/53b595426200dfdc63002a8cf3ac9695f80f9450", "message": "refactor ValidationTask to use TaskResult", "committedDate": "2020-05-28T08:04:49Z", "type": "commit"}, {"oid": "025995aaf9aab07b3d72cb5f014ec26970e9a015", "url": "https://github.com/Alluxio/alluxio/commit/025995aaf9aab07b3d72cb5f014ec26970e9a015", "message": "restructure hdfs val tasks", "committedDate": "2020-05-28T13:06:17Z", "type": "commit"}, {"oid": "32fcb8b4c7e00e454ba35aaa3879d7898bf68a9d", "url": "https://github.com/Alluxio/alluxio/commit/32fcb8b4c7e00e454ba35aaa3879d7898bf68a9d", "message": "add dependency to ufs-hdfs", "committedDate": "2020-05-28T13:08:44Z", "type": "commit"}, {"oid": "b1749eaf2873328273c90a984475667d97d00c30", "url": "https://github.com/Alluxio/alluxio/commit/b1749eaf2873328273c90a984475667d97d00c30", "message": "compiles", "committedDate": "2020-06-01T11:01:10Z", "type": "commit"}, {"oid": "2d651568c62e65187fad953abc55046260af4fb4", "url": "https://github.com/Alluxio/alluxio/commit/2d651568c62e65187fad953abc55046260af4fb4", "message": "adding unit tests", "committedDate": "2020-06-02T02:25:54Z", "type": "commit"}, {"oid": "2da4e2867fa11e9a776733e09e76b04e5ec782f2", "url": "https://github.com/Alluxio/alluxio/commit/2da4e2867fa11e9a776733e09e76b04e5ec782f2", "message": "added some more unit tests", "committedDate": "2020-06-02T13:48:56Z", "type": "commit"}, {"oid": "dcbbcffaac1fb2d2d5c3e9faa43022d9e1bd8561", "url": "https://github.com/Alluxio/alluxio/commit/dcbbcffaac1fb2d2d5c3e9faa43022d9e1bd8561", "message": "add unit tests", "committedDate": "2020-06-02T13:49:54Z", "type": "commit"}, {"oid": "cef53099ad91c584eeac77e07072362d6784aa75", "url": "https://github.com/Alluxio/alluxio/commit/cef53099ad91c584eeac77e07072362d6784aa75", "message": "Merge remote-tracking branch 'upstream/master' into hdfs-validation", "committedDate": "2020-06-04T14:17:40Z", "type": "commit"}, {"oid": "6c4b1d4045bd9fef87c80fe69e6d9a5e41a8681f", "url": "https://github.com/Alluxio/alluxio/commit/6c4b1d4045bd9fef87c80fe69e6d9a5e41a8681f", "message": "rebase and use new TaskResult", "committedDate": "2020-06-04T15:01:21Z", "type": "commit"}, {"oid": "fe04aba03fc54a82a83cf6fa19f0c8fac9bead4f", "url": "https://github.com/Alluxio/alluxio/commit/fe04aba03fc54a82a83cf6fa19f0c8fac9bead4f", "message": "cluster mode collect results", "committedDate": "2020-06-04T15:46:50Z", "type": "commit"}, {"oid": "c28018ea95f6933c45efc225a199233858725f46", "url": "https://github.com/Alluxio/alluxio/commit/c28018ea95f6933c45efc225a199233858725f46", "message": "use annotation to tag ufs tests", "committedDate": "2020-06-05T16:03:48Z", "type": "commit"}, {"oid": "2c760c29d86a603574d96c5486b5ae1db3ccb640", "url": "https://github.com/Alluxio/alluxio/commit/2c760c29d86a603574d96c5486b5ae1db3ccb640", "message": "runUfsTests return TaskResult", "committedDate": "2020-06-06T05:53:58Z", "type": "commit"}, {"oid": "d93f2a1730c55b626344707fe9f6711fd76818c8", "url": "https://github.com/Alluxio/alluxio/commit/d93f2a1730c55b626344707fe9f6711fd76818c8", "message": "fixed on tests", "committedDate": "2020-06-07T07:22:45Z", "type": "commit"}, {"oid": "f6a2818d4d71c313a6b01514506cb181eff35c78", "url": "https://github.com/Alluxio/alluxio/commit/f6a2818d4d71c313a6b01514506cb181eff35c78", "message": "move the tool to another path", "committedDate": "2020-06-07T07:52:54Z", "type": "commit"}, {"oid": "a98d3e8a712ba7ee41ab0cc00e3a07255e4dd862", "url": "https://github.com/Alluxio/alluxio/commit/a98d3e8a712ba7ee41ab0cc00e3a07255e4dd862", "message": "resolve checkstyle", "committedDate": "2020-06-07T10:54:28Z", "type": "commit"}, {"oid": "f988a9410d08d25197d7e54b478398f5cc0bc4c7", "url": "https://github.com/Alluxio/alluxio/commit/f988a9410d08d25197d7e54b478398f5cc0bc4c7", "message": "ser/de from remote hosts", "committedDate": "2020-06-07T13:48:06Z", "type": "commit"}, {"oid": "1137a7ca2d78354e16d760d4ce61eb00676813a3", "url": "https://github.com/Alluxio/alluxio/commit/1137a7ca2d78354e16d760d4ce61eb00676813a3", "message": "print command return", "committedDate": "2020-06-07T13:57:00Z", "type": "commit"}, {"oid": "e8b619001845e62dc02e117ec9730f84dae2c6ac", "url": "https://github.com/Alluxio/alluxio/commit/e8b619001845e62dc02e117ec9730f84dae2c6ac", "message": "use a marker for json", "committedDate": "2020-06-07T14:07:44Z", "type": "commit"}, {"oid": "2eb97e3ad18c8beae94baf481b18120f55e4aa7b", "url": "https://github.com/Alluxio/alluxio/commit/2eb97e3ad18c8beae94baf481b18120f55e4aa7b", "message": "debug printouts", "committedDate": "2020-06-07T14:12:34Z", "type": "commit"}, {"oid": "3cd097302eb6f76a7955a070573fd50441f304c2", "url": "https://github.com/Alluxio/alluxio/commit/3cd097302eb6f76a7955a070573fd50441f304c2", "message": "replace marker", "committedDate": "2020-06-08T05:57:05Z", "type": "commit"}, {"oid": "860c044d90de2bd3ca4734669b91fbf9054afa7f", "url": "https://github.com/Alluxio/alluxio/commit/860c044d90de2bd3ca4734669b91fbf9054afa7f", "message": "handle unknown host", "committedDate": "2020-06-08T06:05:33Z", "type": "commit"}, {"oid": "142db925bc9d2ec39fc536ef2f0172a78127b836", "url": "https://github.com/Alluxio/alluxio/commit/142db925bc9d2ec39fc536ef2f0172a78127b836", "message": "fix unit tests", "committedDate": "2020-06-08T06:26:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY3NDM5NA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436674394", "bodyText": "Moved to a more generalized path", "author": "jiacheliu3", "createdAt": "2020-06-08T12:59:45Z", "path": "core/common/src/main/java/alluxio/cli/JsonSerializable.java", "diffHunk": "@@ -9,14 +9,16 @@\n  * See the NOTICE file distributed with this work for information regarding copyright ownership.\n  */\n \n-package alluxio.stress;\n+package alluxio.cli;", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyMDE3Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r437020176", "bodyText": "this class is also used by job_server, may be moved to alluxio.utils?", "author": "LuQQiu", "createdAt": "2020-06-08T21:47:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY3NDM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI2OTYxMA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438269610", "bodyText": "SGTM", "author": "jiacheliu3", "createdAt": "2020-06-10T16:50:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY3NDM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY3NjIzNA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436676234", "bodyText": "Is there a better way for this kind of wrapper methods?", "author": "jiacheliu3", "createdAt": "2020-06-08T13:01:38Z", "path": "core/common/src/main/java/alluxio/cli/JsonSerializable.java", "diffHunk": "@@ -51,6 +53,12 @@ default String toJson() throws JsonProcessingException {\n     return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(this);\n   }\n \n+  static <T extends JsonSerializable> String listToJson(List<T> list) throws JsonProcessingException {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n+    return objectMapper.writeValueAsString(list);\n+  }", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY3Njg1OQ==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436676859", "bodyText": "Setting these two to public and using this class to parse Alluxio impersonation properties", "author": "jiacheliu3", "createdAt": "2020-06-08T13:02:23Z", "path": "core/common/src/main/java/alluxio/security/authentication/ImpersonationAuthenticator.java", "diffHunk": "@@ -146,4 +148,12 @@ public void authenticate(String connectionUser, String impersonationUser)\n         connectionUser, impersonationUser, connectionUser, impersonationUser,\n         RuntimeConstants.ALLUXIO_SECURITY_DOCS_URL));\n   }\n+\n+  public Map<String, Set<String>> getImpersonationUsers() {\n+    return Collections.unmodifiableMap(mImpersonationUsers);\n+  }\n+\n+  public Map<String, Set<String>> getmImpersonationGroups() {\n+    return Collections.unmodifiableMap(mImpersonationGroups);\n+  }", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY3NzIwNg==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436677206", "bodyText": "Moved to a util class", "author": "jiacheliu3", "createdAt": "2020-06-08T13:02:47Z", "path": "integration/tools/src/main/java/alluxio/cli/ValidateHms.java", "diffHunk": "@@ -154,7 +154,7 @@ private boolean checkHmsUri(String uriAddress) throws Exception {\n       uri = new URI(uriAddress);\n     } catch (Throwable t) {\n       mResults.computeIfAbsent(State.FAILED, k -> new ArrayList<>()).add(\n-          new TaskResult(State.FAILED, \"HmsUrisSyntaxCheck\", getErrorInfo(t),\n+          new TaskResult(State.FAILED, \"HmsUrisSyntaxCheck\", ValidateUtils.getErrorInfo(t),", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY3NzY0Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436677646", "bodyText": "Using JsonSerializable to do serialization.", "author": "jiacheliu3", "createdAt": "2020-06-08T13:03:16Z", "path": "integration/tools/src/main/java/alluxio/cli/ValidateUtils.java", "diffHunk": "@@ -37,7 +41,7 @@ private ValidateUtils() {} // prevent instantiation\n   /**\n    * Represents the result of a given task.\n    */\n-  public static class TaskResult implements Serializable {\n+  public static class TaskResult implements JsonSerializable {", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY3ODM5MA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436678390", "bodyText": "Updated this test to be able to validate a nested mount path", "author": "jiacheliu3", "createdAt": "2020-06-08T13:04:06Z", "path": "shell/src/main/java/alluxio/cli/UnderFileSystemContractTest.java", "diffHunk": "@@ -52,14 +60,31 @@\n   @Parameter(names = {\"--help\"}, help = true)\n   private boolean mHelp = false;\n \n-  private InstancedConfiguration mConf\n-      = new InstancedConfiguration(ConfigurationUtils.defaults());\n-\n+  private InstancedConfiguration mConf;\n   private UnderFileSystem mUfs;\n \n-  private UnderFileSystemContractTest() {}\n+  /**\n+   * A constructor from default.\n+   * */\n+  public UnderFileSystemContractTest() {\n+    mConf = new InstancedConfiguration(ConfigurationUtils.defaults());\n+  }\n \n-  private void run() throws Exception {\n+  /**\n+   * Initiate the tests for a specific UFS path and UFS configs.\n+   *\n+   * @param path the UFS path\n+   * @param conf the UFs configurations\n+   * */\n+  public UnderFileSystemContractTest(String path, InstancedConfiguration conf) {\n+    mUfsPath = path;\n+    mConf = conf;\n+  }", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY3OTY3NQ==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436679675", "bodyText": "Use a constructor now instead of static block, as the validation can be against a nested mount.", "author": "jiacheliu3", "createdAt": "2020-06-08T13:05:31Z", "path": "shell/src/main/java/alluxio/cli/ValidateEnv.java", "diffHunk": "@@ -87,80 +93,108 @@\n   private static final List<ValidationTask> MASTER_TASKS = new ArrayList<>();\n   private static final List<ValidationTask> WORKER_TASKS = new ArrayList<>();\n \n-  private static final AlluxioConfiguration CONF;\n+  private final AlluxioConfiguration mConf;\n+  private final String mPath;\n \n-  static {\n-    CONF = InstancedConfiguration.defaults();", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4MDU1Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436680552", "bodyText": "After some tests I find JCommand to be better. Will refactor this to use JCommand.", "author": "jiacheliu3", "createdAt": "2020-06-08T13:06:29Z", "path": "shell/src/main/java/alluxio/cli/ValidateHdfsMount.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package alluxio.cli;\n+\n+import alluxio.cli.validation.ApplicableUfsType;\n+import alluxio.conf.InstancedConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.Source;\n+import alluxio.shell.CommandReturn;\n+import alluxio.underfs.UnderFileSystemConfiguration;\n+import alluxio.util.ConfigurationUtils;\n+import alluxio.util.ShellUtils;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.commons.lang.ArrayUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+/**\n+ * A tool to validate an HDFS mount, before the paths is mounted to Alluxio.\n+ * */\n+public class ValidateHdfsMount {\n+  private static final Logger LOG = LoggerFactory.getLogger(ValidateHdfsMount.class);\n+  private static final String JSON_START_POS_MARKER = \"ValidateHdfsMount task results: \\n\";\n+\n+  private static final Option READONLY_OPTION =\n+          Option.builder()\n+                  .longOpt(\"readonly\")\n+                  .required(false)\n+                  .hasArg(false)\n+                  .desc(\"mount point is readonly in Alluxio\")\n+                  .build();\n+  private static final Option SHARED_OPTION =\n+          Option.builder()\n+                  .longOpt(\"shared\")\n+                  .required(false)\n+                  .hasArg(false)\n+                  .desc(\"mount point is shared\")\n+                  .build();\n+  private static final Option OPTION_OPTION =\n+          Option.builder()\n+                  .longOpt(\"option\")\n+                  .required(false)\n+                  .hasArg(true)\n+                  .numberOfArgs(2)\n+                  .argName(\"key=value\")\n+                  .valueSeparator('=')\n+                  .desc(\"options associated with this mount point\")\n+                  .build();\n+  private static final Option LOCAL_OPTION =\n+          Option.builder().required(false).longOpt(\"local\").hasArg(false)\n+                  .desc(\"running only on localhost\").build();\n+  private static final Options OPTIONS =\n+          new Options().addOption(READONLY_OPTION).addOption(SHARED_OPTION)\n+                  .addOption(OPTION_OPTION).addOption(LOCAL_OPTION);\n+\n+  /**\n+   * Invokes {@link UnderFileSystemContractTest} to validate UFS operations.\n+   *\n+   * @param path the UFS path\n+   * @param conf the UFS conf\n+   * @return a {@link alluxio.cli.ValidateUtils.TaskResult} containing the validation result\n+   *        of the UFS operations\n+   * */\n+  public static ValidateUtils.TaskResult runUfsTests(String path, InstancedConfiguration conf) {\n+    try {\n+      UnderFileSystemContractTest test = new UnderFileSystemContractTest(path, conf);\n+      return test.runValidationTask();\n+    } catch (IOException e) {\n+      return new ValidateUtils.TaskResult(ValidateUtils.State.FAILED, \"ufsTests\",\n+              ValidateUtils.getErrorInfo(e), \"\");\n+    }\n+  }\n+\n+  /**\n+   * The entrance.\n+   *\n+   * @param args command line arguments\n+   * */\n+  public static void main(String[] args) throws Exception {\n+    // TODO(jiacheng): use jccommand?", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4MDY0OA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438280648", "bodyText": "do you still plan on addressing this?", "author": "madanadit", "createdAt": "2020-06-10T17:08:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4MDU1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2MTgzMQ==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438761831", "bodyText": "Not really, i'll remove this TODO. I found the existing cmdline works just fine. JCommand is not a better option anymore.", "author": "jiacheliu3", "createdAt": "2020-06-11T12:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4MDU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4MTExMQ==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436681111", "bodyText": "This will be resolved", "author": "jiacheliu3", "createdAt": "2020-06-08T13:07:04Z", "path": "shell/src/main/java/alluxio/cli/validation/HadoopConfigurationFileParser.java", "diffHunk": "@@ -87,4 +87,32 @@ public HadoopConfigurationFileParser() {}\n     }\n     return ret;\n   }\n+\n+  // TODO(jiacheng): keep only one", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4MjY2OA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436682668", "bodyText": "This is the previous alluxio.cli.validation.HdfsValidationTask where the hdfs configs defined in Alluxio property are compared against the hadoop config defined in hadoop env variables.", "author": "jiacheliu3", "createdAt": "2020-06-08T13:08:44Z", "path": "shell/src/main/java/alluxio/cli/validation/HdfsConfParityValidationTask.java", "diffHunk": "@@ -0,0 +1,140 @@\n+package alluxio.cli.validation;\n+\n+import alluxio.cli.ValidateUtils;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.util.io.PathUtils;\n+\n+import org.apache.commons.cli.Option;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Compares HDFS configuration in Alluxio and in HDFS environment variables.\n+ * */\n+@ApplicableUfsType(ApplicableUfsType.Type.HDFS)\n+public class HdfsConfParityValidationTask extends HdfsConfValidationTask {", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4NTIzNA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436685234", "bodyText": "Do we want to assume the current running user needs impersonation? I don't think so.", "author": "jiacheliu3", "createdAt": "2020-06-08T13:11:26Z", "path": "shell/src/main/java/alluxio/cli/validation/HdfsImpersonationValidationTask.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package alluxio.cli.validation;\n+\n+import alluxio.cli.ValidateUtils;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.security.authentication.ImpersonationAuthenticator;\n+import alluxio.util.network.NetworkAddressUtils;\n+\n+import com.google.common.collect.Sets;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Validates the impersonation configurations in alluxio and hdfs.\n+ * */\n+@ApplicableUfsType(ApplicableUfsType.Type.HDFS)\n+public class HdfsImpersonationValidationTask extends HdfsConfValidationTask {\n+  private final Map<String, Set<String>> mImpersonationUsers;\n+  private final Map<String, Set<String>> mImpersonationGroups;\n+  private final Mode mMode;\n+\n+  /**\n+   * Creates a new instance of {@link HdfsImpersonationValidationTask}\n+   * for validating impersonation configuration.\n+   *\n+   * @param path the UFS path\n+   * @param conf the UFS configuration\n+   * @param mode the mode for validation\n+   */\n+  public HdfsImpersonationValidationTask(String path, AlluxioConfiguration conf, Mode mode) {\n+    super(path, conf);\n+    mMode = mode;\n+    ImpersonationAuthenticator ia = new ImpersonationAuthenticator(mConf);\n+    mImpersonationUsers = ia.getImpersonationUsers();\n+    mImpersonationGroups = ia.getmImpersonationGroups();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return String.format(\"ValidateImpersonationConf%s\", mMode);\n+  }\n+\n+  private boolean shouldSkip() {\n+    // If no impersonation setting in Alluxio, skip the check\n+    if (mImpersonationUsers.entrySet().size() == 0\n+            && mImpersonationGroups.size() == 0) {\n+      mMsg.append(\"No impersonation setting found in Alluxio. \"\n+              + \"Skip the impersonation validation step.\\n\");\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  private ValidateUtils.TaskResult validateImpersonationUsers() {\n+    String taskName = \"Validate alluxio impersonation users\";\n+    ValidateUtils.State state = ValidateUtils.State.OK;\n+    StringBuilder msg = new StringBuilder();\n+    StringBuilder advice = new StringBuilder();\n+    for (Map.Entry<String, Set<String>> entry : mImpersonationUsers.entrySet()) {\n+      String userName = entry.getKey();\n+      Set<String> impUsers = entry.getValue();\n+      PropertyKey alluxioKey =\n+              PropertyKey.Template.MASTER_IMPERSONATION_USERS_OPTION.format(userName);\n+      String hdfsKey = String.format(\"hadoop.proxyuser.%s.users\", userName);\n+      msg.append(String.format(\"User %s has impersonation configured in Alluxio property %s=%s. %n\",\n+              userName, alluxioKey.toString(), mConf.get(alluxioKey)));\n+\n+      // The impersonation user is not configured in core-site.xml\n+      if (!mCoreConf.containsKey(hdfsKey)) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(String.format(\"But %s is not configured in hadoop proxyuser.%n\",\n+                hdfsKey));\n+        advice.append(String.format(\"Please configure %s to match %s.%n\",\n+                hdfsKey, alluxioKey.toString()));\n+        continue;\n+      }\n+      String hdfsImpUsers = mCoreConf.get(hdfsKey);\n+\n+      // Consider wildcard separately\n+      if (impUsers.contains(ImpersonationAuthenticator.WILDCARD)) {\n+        if (hdfsImpUsers.equals(ImpersonationAuthenticator.WILDCARD)) {\n+          // If impersonation is enabled for all users in Alluxio and HDFS, succeed\n+          msg.append(String.format(\"User %s can impersonate any user in Alluxio and HDFS.%n\",\n+                  userName));\n+        } else {\n+          state = ValidateUtils.State.FAILED;\n+          msg.append(String.format(\"User %s can impersonate any user in \"\n+                  + \"Alluxio but only %s in HDFS.%n\", userName, hdfsImpUsers));\n+          advice.append(String.format(\"Please set %s to %s. \",\n+                  hdfsKey, ImpersonationAuthenticator.WILDCARD));\n+        }\n+        continue;\n+      } else if (hdfsImpUsers.equals(ImpersonationAuthenticator.WILDCARD)) {\n+        msg.append(String.format(\"User %s can impersonate any user in HDFS.%n\", userName));\n+        continue;\n+      }\n+\n+      // Not using wildcard, compare the exact usernames\n+      Set<String> nameSet = new HashSet<>(Arrays.asList(hdfsImpUsers.split(\",\")));\n+      System.out.format(\"Impersonable users: %s%n\", nameSet);\n+      // The proxyuser can be enabled to impersonate more users than defined in Alluxio\n+      Set<String> missedUsers = Sets.difference(impUsers, nameSet); // in alluxio not in hdfs\n+      System.out.format(\"Found missed users %s%n\", missedUsers);\n+      if (missedUsers.size() > 0) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(String.format(\"User %s can impersonate as users %s in Alluxio but \"\n+                + \"not in HDFS.%n\", userName, missedUsers));\n+        advice.append(String.format(\"Please add the missing users to %s. \", hdfsKey));\n+        continue;\n+      }\n+\n+      // All checks passed\n+      msg.append(\"All impersonable users in Alluxio are found in HDFS. \\n\");\n+    }\n+\n+    return new ValidateUtils.TaskResult(state, taskName, msg.toString(), advice.toString());\n+  }\n+\n+  // TODO(jiacheng): refactor with users logic\n+  private ValidateUtils.TaskResult validateImpersonationGroups() {\n+    String taskName = \"Validate alluxio impersonation groups\";\n+    ValidateUtils.State state = ValidateUtils.State.OK;\n+    StringBuilder msg = new StringBuilder();\n+    StringBuilder advice = new StringBuilder();\n+    for (Map.Entry<String, Set<String>> entry : mImpersonationGroups.entrySet()) {\n+      String userName = entry.getKey();\n+      Set<String> impGroups = entry.getValue();\n+      PropertyKey alluxioKey = PropertyKey.Template\n+              .MASTER_IMPERSONATION_GROUPS_OPTION.format(userName);\n+      String hdfsKey = String.format(\"hadoop.proxyuser.%s.groups\", userName);\n+      msg.append(String.format(\"User %s has impersonation configured in Alluxio property %s=%s. \",\n+              userName, alluxioKey.toString(), mConf.get(alluxioKey)));\n+\n+      // The impersonation group is not configured in core-site.xml\n+      if (!mCoreConf.containsKey(hdfsKey)) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(String.format(\"But %s is not configured in hadoop proxyuser. \", hdfsKey));\n+        advice.append(String.format(\"Please configure %s to match %s\",\n+                hdfsKey, alluxioKey.toString()));\n+        continue;\n+      }\n+      String hdfsImpGroups = mCoreConf.get(hdfsKey);\n+\n+      // Consider wildcard separately\n+      if (impGroups.contains(ImpersonationAuthenticator.WILDCARD)) {\n+        if (hdfsImpGroups.equals(ImpersonationAuthenticator.WILDCARD)) {\n+          // If impersonation is enabled for all users in Alluxio and HDFS, succeed\n+          msg.append(String.format(\"User %s can impersonate any group in \"\n+                  + \"Alluxio and HDFS. \", userName));\n+        } else {\n+          msg.append(String.format(\"User %s can impersonate any group \"\n+                  + \"in Alluxio but not in HDFS. \", userName));\n+          advice.append(String.format(\"Please set %s to %s. \",\n+                  hdfsKey, ImpersonationAuthenticator.WILDCARD));\n+        }\n+        continue;\n+      } else if (hdfsImpGroups.equals(ImpersonationAuthenticator.WILDCARD)) {\n+        msg.append(String.format(\"User %s can impersonate any group in HDFS.%n\", userName));\n+        continue;\n+      }\n+\n+      // The impersonation group has different configuration in core-site.xml\n+      Set<String> nameSet = new HashSet<>(Arrays.asList(hdfsImpGroups.split(\",\")));\n+      System.out.format(\"Impersonable groups: %s%n\", nameSet);\n+      // The proxyuser can be enabled to impersonate more groups than defined in Alluxio\n+      Set<String> missedGroups = Sets.difference(impGroups, nameSet); // in alluxio not in hdfs\n+      System.out.format(\"Found missed groups %s%n\", missedGroups);\n+      if (missedGroups.size() > 0) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(String.format(\"User %s can impersonate as groups %s \"\n+                + \"in Alluxio but not in HDFS.\", userName, missedGroups));\n+        advice.append(String.format(\"Please add the missing groups to %s. \", hdfsKey));\n+        continue;\n+      }\n+\n+      // All checks passed\n+      msg.append(String.format(\"Found matching configuration in %s and %s. \",\n+              alluxioKey.toString(), hdfsKey));\n+    }\n+    return new ValidateUtils.TaskResult(state, taskName, msg.toString(), advice.toString());\n+  }\n+\n+  // At least the current host should be in hadoop.proxy.<username>.hosts\n+  private ValidateUtils.TaskResult validateImpersonationHosts() {\n+    String taskName = \"Validate proxyuser hosts\";\n+    ValidateUtils.State state = ValidateUtils.State.OK;\n+    StringBuilder msg = new StringBuilder();\n+    StringBuilder advice = new StringBuilder();\n+\n+    // current host\n+    String localhost = NetworkAddressUtils.getLocalHostName(1000);\n+\n+    // All the possible users Alluxio needs\n+    Set<String> allUsers = Sets.union(mImpersonationUsers.keySet(), mImpersonationGroups.keySet());\n+    for (String userName : allUsers) {\n+      msg.append(String.format(\"User %s is configured to allow impersonation is Alluxio. \",\n+              userName));\n+\n+      String hdfsKey = String.format(\"hadoop.proxyuser.%s.hosts\", userName);\n+      if (!mCoreConf.containsKey(hdfsKey)) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(\"But the user is not allowed to use impersonation on this host.\");\n+        advice.append(String.format(\"Please configure %s to contain %s. \", hdfsKey, localhost));\n+        continue;\n+      }\n+\n+      String proxyHosts = mCoreConf.get(hdfsKey);\n+      // Consider wildcard separately\n+      if (proxyHosts.equals(ImpersonationAuthenticator.WILDCARD)) {\n+        msg.append(String.format(\"The user is enabled for impersonation from all hosts. \"));\n+        continue;\n+      }\n+      // If wildcard is not used and the localhost is not in the permitted list\n+      if (!proxyHosts.contains(localhost)) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(String.format(\"But %s does not contain host %s. \", hdfsKey, localhost));\n+        advice.append(String.format(\"Please enable host %s in %s. \", localhost, hdfsKey));\n+        continue;\n+      }\n+\n+      // Passed all checks\n+      msg.append(String.format(\"Host %s is enabled to use impersonation in HDFS. \", localhost));\n+    }\n+    return new ValidateUtils.TaskResult(state, taskName, msg.toString(), advice.toString());\n+  }\n+\n+  @Override\n+  public ValidateUtils.TaskResult validate(Map<String, String> optionMap) {\n+    if (shouldSkip()) {\n+      return new ValidateUtils.TaskResult(ValidateUtils.State.SKIPPED, getName(),\n+              mMsg.toString(), mAdvice.toString());\n+    }\n+\n+    ValidateUtils.TaskResult loadConfig = loadHdfsConfig();\n+    if (loadConfig.getState() != ValidateUtils.State.OK) {\n+      return loadConfig;\n+    }\n+\n+    // TODO(jiacheng): do we want to check the current user even if", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4NjcxMw==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436686713", "bodyText": "One limitation of the current check is, we can only know which users need impersonation based on the Alluxio properties. If the user does not define alluxio.security.impersonation.bob.users field, there's no way to know if bob needs to be validated.", "author": "jiacheliu3", "createdAt": "2020-06-08T13:13:02Z", "path": "shell/src/main/java/alluxio/cli/validation/HdfsImpersonationValidationTask.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package alluxio.cli.validation;\n+\n+import alluxio.cli.ValidateUtils;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.security.authentication.ImpersonationAuthenticator;\n+import alluxio.util.network.NetworkAddressUtils;\n+\n+import com.google.common.collect.Sets;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Validates the impersonation configurations in alluxio and hdfs.\n+ * */\n+@ApplicableUfsType(ApplicableUfsType.Type.HDFS)\n+public class HdfsImpersonationValidationTask extends HdfsConfValidationTask {\n+  private final Map<String, Set<String>> mImpersonationUsers;\n+  private final Map<String, Set<String>> mImpersonationGroups;\n+  private final Mode mMode;\n+\n+  /**\n+   * Creates a new instance of {@link HdfsImpersonationValidationTask}\n+   * for validating impersonation configuration.\n+   *\n+   * @param path the UFS path\n+   * @param conf the UFS configuration\n+   * @param mode the mode for validation\n+   */\n+  public HdfsImpersonationValidationTask(String path, AlluxioConfiguration conf, Mode mode) {\n+    super(path, conf);\n+    mMode = mode;\n+    ImpersonationAuthenticator ia = new ImpersonationAuthenticator(mConf);\n+    mImpersonationUsers = ia.getImpersonationUsers();\n+    mImpersonationGroups = ia.getmImpersonationGroups();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return String.format(\"ValidateImpersonationConf%s\", mMode);\n+  }\n+\n+  private boolean shouldSkip() {\n+    // If no impersonation setting in Alluxio, skip the check\n+    if (mImpersonationUsers.entrySet().size() == 0\n+            && mImpersonationGroups.size() == 0) {\n+      mMsg.append(\"No impersonation setting found in Alluxio. \"\n+              + \"Skip the impersonation validation step.\\n\");\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  private ValidateUtils.TaskResult validateImpersonationUsers() {\n+    String taskName = \"Validate alluxio impersonation users\";\n+    ValidateUtils.State state = ValidateUtils.State.OK;\n+    StringBuilder msg = new StringBuilder();\n+    StringBuilder advice = new StringBuilder();\n+    for (Map.Entry<String, Set<String>> entry : mImpersonationUsers.entrySet()) {\n+      String userName = entry.getKey();\n+      Set<String> impUsers = entry.getValue();\n+      PropertyKey alluxioKey =\n+              PropertyKey.Template.MASTER_IMPERSONATION_USERS_OPTION.format(userName);\n+      String hdfsKey = String.format(\"hadoop.proxyuser.%s.users\", userName);\n+      msg.append(String.format(\"User %s has impersonation configured in Alluxio property %s=%s. %n\",\n+              userName, alluxioKey.toString(), mConf.get(alluxioKey)));\n+\n+      // The impersonation user is not configured in core-site.xml\n+      if (!mCoreConf.containsKey(hdfsKey)) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(String.format(\"But %s is not configured in hadoop proxyuser.%n\",\n+                hdfsKey));\n+        advice.append(String.format(\"Please configure %s to match %s.%n\",\n+                hdfsKey, alluxioKey.toString()));\n+        continue;\n+      }\n+      String hdfsImpUsers = mCoreConf.get(hdfsKey);\n+\n+      // Consider wildcard separately\n+      if (impUsers.contains(ImpersonationAuthenticator.WILDCARD)) {\n+        if (hdfsImpUsers.equals(ImpersonationAuthenticator.WILDCARD)) {\n+          // If impersonation is enabled for all users in Alluxio and HDFS, succeed\n+          msg.append(String.format(\"User %s can impersonate any user in Alluxio and HDFS.%n\",\n+                  userName));\n+        } else {\n+          state = ValidateUtils.State.FAILED;\n+          msg.append(String.format(\"User %s can impersonate any user in \"\n+                  + \"Alluxio but only %s in HDFS.%n\", userName, hdfsImpUsers));\n+          advice.append(String.format(\"Please set %s to %s. \",\n+                  hdfsKey, ImpersonationAuthenticator.WILDCARD));\n+        }\n+        continue;\n+      } else if (hdfsImpUsers.equals(ImpersonationAuthenticator.WILDCARD)) {\n+        msg.append(String.format(\"User %s can impersonate any user in HDFS.%n\", userName));\n+        continue;\n+      }\n+\n+      // Not using wildcard, compare the exact usernames\n+      Set<String> nameSet = new HashSet<>(Arrays.asList(hdfsImpUsers.split(\",\")));\n+      System.out.format(\"Impersonable users: %s%n\", nameSet);\n+      // The proxyuser can be enabled to impersonate more users than defined in Alluxio\n+      Set<String> missedUsers = Sets.difference(impUsers, nameSet); // in alluxio not in hdfs\n+      System.out.format(\"Found missed users %s%n\", missedUsers);\n+      if (missedUsers.size() > 0) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(String.format(\"User %s can impersonate as users %s in Alluxio but \"\n+                + \"not in HDFS.%n\", userName, missedUsers));\n+        advice.append(String.format(\"Please add the missing users to %s. \", hdfsKey));\n+        continue;\n+      }\n+\n+      // All checks passed\n+      msg.append(\"All impersonable users in Alluxio are found in HDFS. \\n\");\n+    }\n+\n+    return new ValidateUtils.TaskResult(state, taskName, msg.toString(), advice.toString());\n+  }\n+\n+  // TODO(jiacheng): refactor with users logic\n+  private ValidateUtils.TaskResult validateImpersonationGroups() {\n+    String taskName = \"Validate alluxio impersonation groups\";\n+    ValidateUtils.State state = ValidateUtils.State.OK;\n+    StringBuilder msg = new StringBuilder();\n+    StringBuilder advice = new StringBuilder();\n+    for (Map.Entry<String, Set<String>> entry : mImpersonationGroups.entrySet()) {\n+      String userName = entry.getKey();\n+      Set<String> impGroups = entry.getValue();\n+      PropertyKey alluxioKey = PropertyKey.Template\n+              .MASTER_IMPERSONATION_GROUPS_OPTION.format(userName);\n+      String hdfsKey = String.format(\"hadoop.proxyuser.%s.groups\", userName);\n+      msg.append(String.format(\"User %s has impersonation configured in Alluxio property %s=%s. \",\n+              userName, alluxioKey.toString(), mConf.get(alluxioKey)));\n+\n+      // The impersonation group is not configured in core-site.xml\n+      if (!mCoreConf.containsKey(hdfsKey)) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(String.format(\"But %s is not configured in hadoop proxyuser. \", hdfsKey));\n+        advice.append(String.format(\"Please configure %s to match %s\",\n+                hdfsKey, alluxioKey.toString()));\n+        continue;\n+      }\n+      String hdfsImpGroups = mCoreConf.get(hdfsKey);\n+\n+      // Consider wildcard separately\n+      if (impGroups.contains(ImpersonationAuthenticator.WILDCARD)) {\n+        if (hdfsImpGroups.equals(ImpersonationAuthenticator.WILDCARD)) {\n+          // If impersonation is enabled for all users in Alluxio and HDFS, succeed\n+          msg.append(String.format(\"User %s can impersonate any group in \"\n+                  + \"Alluxio and HDFS. \", userName));\n+        } else {\n+          msg.append(String.format(\"User %s can impersonate any group \"\n+                  + \"in Alluxio but not in HDFS. \", userName));\n+          advice.append(String.format(\"Please set %s to %s. \",\n+                  hdfsKey, ImpersonationAuthenticator.WILDCARD));\n+        }\n+        continue;\n+      } else if (hdfsImpGroups.equals(ImpersonationAuthenticator.WILDCARD)) {\n+        msg.append(String.format(\"User %s can impersonate any group in HDFS.%n\", userName));\n+        continue;\n+      }\n+\n+      // The impersonation group has different configuration in core-site.xml\n+      Set<String> nameSet = new HashSet<>(Arrays.asList(hdfsImpGroups.split(\",\")));\n+      System.out.format(\"Impersonable groups: %s%n\", nameSet);\n+      // The proxyuser can be enabled to impersonate more groups than defined in Alluxio\n+      Set<String> missedGroups = Sets.difference(impGroups, nameSet); // in alluxio not in hdfs\n+      System.out.format(\"Found missed groups %s%n\", missedGroups);\n+      if (missedGroups.size() > 0) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(String.format(\"User %s can impersonate as groups %s \"\n+                + \"in Alluxio but not in HDFS.\", userName, missedGroups));\n+        advice.append(String.format(\"Please add the missing groups to %s. \", hdfsKey));\n+        continue;\n+      }\n+\n+      // All checks passed\n+      msg.append(String.format(\"Found matching configuration in %s and %s. \",\n+              alluxioKey.toString(), hdfsKey));\n+    }\n+    return new ValidateUtils.TaskResult(state, taskName, msg.toString(), advice.toString());\n+  }\n+\n+  // At least the current host should be in hadoop.proxy.<username>.hosts\n+  private ValidateUtils.TaskResult validateImpersonationHosts() {\n+    String taskName = \"Validate proxyuser hosts\";\n+    ValidateUtils.State state = ValidateUtils.State.OK;\n+    StringBuilder msg = new StringBuilder();\n+    StringBuilder advice = new StringBuilder();\n+\n+    // current host\n+    String localhost = NetworkAddressUtils.getLocalHostName(1000);\n+\n+    // All the possible users Alluxio needs\n+    Set<String> allUsers = Sets.union(mImpersonationUsers.keySet(), mImpersonationGroups.keySet());\n+    for (String userName : allUsers) {\n+      msg.append(String.format(\"User %s is configured to allow impersonation is Alluxio. \",\n+              userName));\n+\n+      String hdfsKey = String.format(\"hadoop.proxyuser.%s.hosts\", userName);\n+      if (!mCoreConf.containsKey(hdfsKey)) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(\"But the user is not allowed to use impersonation on this host.\");\n+        advice.append(String.format(\"Please configure %s to contain %s. \", hdfsKey, localhost));\n+        continue;\n+      }\n+\n+      String proxyHosts = mCoreConf.get(hdfsKey);\n+      // Consider wildcard separately\n+      if (proxyHosts.equals(ImpersonationAuthenticator.WILDCARD)) {\n+        msg.append(String.format(\"The user is enabled for impersonation from all hosts. \"));\n+        continue;\n+      }\n+      // If wildcard is not used and the localhost is not in the permitted list\n+      if (!proxyHosts.contains(localhost)) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(String.format(\"But %s does not contain host %s. \", hdfsKey, localhost));\n+        advice.append(String.format(\"Please enable host %s in %s. \", localhost, hdfsKey));\n+        continue;\n+      }\n+\n+      // Passed all checks\n+      msg.append(String.format(\"Host %s is enabled to use impersonation in HDFS. \", localhost));\n+    }\n+    return new ValidateUtils.TaskResult(state, taskName, msg.toString(), advice.toString());\n+  }\n+\n+  @Override\n+  public ValidateUtils.TaskResult validate(Map<String, String> optionMap) {\n+    if (shouldSkip()) {\n+      return new ValidateUtils.TaskResult(ValidateUtils.State.SKIPPED, getName(),\n+              mMsg.toString(), mAdvice.toString());\n+    }\n+\n+    ValidateUtils.TaskResult loadConfig = loadHdfsConfig();\n+    if (loadConfig.getState() != ValidateUtils.State.OK) {\n+      return loadConfig;\n+    }\n+\n+    // TODO(jiacheng): do we want to check the current user even if\n+    //  there's no impersonation setting?\n+    switch (mMode) {\n+      case USERS:\n+        return validateImpersonationUsers();\n+      case GROUPS:\n+        return validateImpersonationGroups();\n+      case HOSTS:\n+        return validateImpersonationHosts();", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4OTMwNA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436689304", "bodyText": "@LuQQiu One slightly better way is to define a list of users that we \"think\" should have impersonation, like \"presto, yarn, spark\", and give a warning if they are not configured. But then the drawback is, we will subsequently complain if those users are not configured in hadoop core-site.xml, which may be confusing to those who don't need these users.", "author": "jiacheliu3", "createdAt": "2020-06-08T13:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4NjcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4OTc2Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436689763", "bodyText": "Need to double check if the same format holds true in CDH.", "author": "jiacheliu3", "createdAt": "2020-06-08T13:16:21Z", "path": "shell/src/main/java/alluxio/cli/validation/HdfsVersionValidationTask.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package alluxio.cli.validation;\n+\n+import alluxio.cli.ValidateUtils;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.util.ShellUtils;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Validates if the HDFS version works with the UFS version specified in\n+ * alluxio configuration.\n+ * */\n+@ApplicableUfsType(ApplicableUfsType.Type.HDFS)\n+public class HdfsVersionValidationTask extends AbstractValidationTask {\n+  private final AlluxioConfiguration mConf;\n+\n+  /**\n+   * Creates a new instance of {@link HdfsVersionValidationTask}\n+   * for validating HDFS version.\n+   * @param conf configuration\n+   */\n+  public HdfsVersionValidationTask(AlluxioConfiguration conf) {\n+    mConf = conf;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return \"ValidateHdfsVersion\";\n+  }\n+\n+  protected String parseVersion(String output) {\n+    // An example output from \"hadoop version\" command:\n+    //    Hadoop 2.7.2", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY5MTMzMQ==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436691331", "bodyText": "Hadoop native lib may be defined here.", "author": "jiacheliu3", "createdAt": "2020-06-08T13:18:04Z", "path": "shell/src/main/java/alluxio/cli/validation/NativeLibValidationTask.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package alluxio.cli.validation;\n+\n+import alluxio.cli.ValidateUtils;\n+import alluxio.conf.AlluxioConfiguration;\n+\n+import java.io.File;\n+import java.util.Map;\n+import java.util.StringTokenizer;\n+\n+/**\n+ * Validates the Java native libs defined in the system property.", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY5MjAzNg==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436692036", "bodyText": "But then the drawback is for the default value for your JVM, there's a good chance you don't have them all in your env and you always see this warning.......", "author": "jiacheliu3", "createdAt": "2020-06-08T13:18:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY5MTMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY5MjkyOA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436692928", "bodyText": "Partially updated classes like this are from validateEnv. They are not all run in this validateHdfsMount tool.", "author": "jiacheliu3", "createdAt": "2020-06-08T13:19:48Z", "path": "shell/src/main/java/alluxio/cli/validation/SecureHdfsValidationTask.java", "diffHunk": "@@ -27,7 +27,8 @@\n /**\n  * Task for validating security configurations.\n  */\n-public final class SecureHdfsValidationTask extends HdfsValidationTask {\n+@ApplicableUfsType(ApplicableUfsType.Type.HDFS)\n+public final class SecureHdfsValidationTask extends AbstractValidationTask {", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY5NjYwNA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436696604", "bodyText": "Now if the namenode / nameservice is not accessible there will be an exception here. I'm trying to add another test using hadoopClient.isHealthy() in hadoop client, which should be more verbose and specific.", "author": "jiacheliu3", "createdAt": "2020-06-08T13:23:43Z", "path": "shell/src/main/java/alluxio/cli/validation/UfsDirectoryValidationTask.java", "diffHunk": "@@ -30,27 +31,41 @@\n    * Creates a new instance of {@link UfsDirectoryValidationTask}\n    * for validating root under file system.\n    *\n-   * @param conf configuration\n+   * @param path the UFS path\n+   * @param conf the UFS configuration\n    */\n-  public UfsDirectoryValidationTask(AlluxioConfiguration conf) {\n-    mUfs = UnderFileSystem.Factory.createForRoot(conf);\n-    mPath = conf.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);\n+  public UfsDirectoryValidationTask(String path, AlluxioConfiguration conf) {\n+    mPath = path;\n+    mUfs = UnderFileSystem.Factory.create(mPath, conf);\n   }\n \n   @Override\n-  public TaskResult validate(Map<String, String> optionsMap) {\n+  public String getName() {\n+    return \"ValidateUfsDir\";\n+  }\n+\n+  @Override\n+  public ValidateUtils.TaskResult validate(Map<String, String> optionsMap) {\n+    StringBuilder msg = new StringBuilder();\n+    StringBuilder advice = new StringBuilder();\n     try {\n       UfsStatus[] listStatus = mUfs.listStatus(mPath);\n       if (listStatus == null) {\n-        System.err.format(\"Unable to list under file system path %s.%n\", mPath);\n-        return TaskResult.FAILED;\n+        msg.append(String.format(\"Unable to list under file system path %s. \", mPath));", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3b3f1f26f81c40a8da58a62e0e942c226c3047c9", "url": "https://github.com/Alluxio/alluxio/commit/3b3f1f26f81c40a8da58a62e0e942c226c3047c9", "message": "improvements", "committedDate": "2020-06-08T13:26:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA1Mjk2Nw==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r437052967", "bodyText": "what does errStream use for ?", "author": "LuQQiu", "createdAt": "2020-06-08T23:20:06Z", "path": "shell/src/main/java/alluxio/cli/RunTestUtils.java", "diffHunk": "@@ -27,18 +28,29 @@\n   private RunTestUtils() {} // prevent instantiation\n \n   /**\n-   * Prints information of the test result.\n+   * Prints information of the test result to redirected streams.\n    *\n    * @param pass the test result\n+   * @param outStream stream for stdout\n+   * @param errStream stream for stderr\n    */\n-  public static void printPassInfo(boolean pass) {\n+  public static void printPassInfo(boolean pass, PrintStream outStream, PrintStream errStream) {", "originalCommit": "3b3f1f26f81c40a8da58a62e0e942c226c3047c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI2MzU1NA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438263554", "bodyText": "Nothing, for now. I think it's better to hijack stdout and stderr together?", "author": "jiacheliu3", "createdAt": "2020-06-10T16:40:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA1Mjk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA1MzE2Nw==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r437053167", "bodyText": "this function only prints the succeed (== pass) information?", "author": "LuQQiu", "createdAt": "2020-06-08T23:20:39Z", "path": "shell/src/main/java/alluxio/cli/RunTestUtils.java", "diffHunk": "@@ -27,18 +28,29 @@\n   private RunTestUtils() {} // prevent instantiation\n \n   /**\n-   * Prints information of the test result.\n+   * Prints information of the test result to redirected streams.\n    *\n    * @param pass the test result\n+   * @param outStream stream for stdout\n+   * @param errStream stream for stderr\n    */\n-  public static void printPassInfo(boolean pass) {\n+  public static void printPassInfo(boolean pass, PrintStream outStream, PrintStream errStream) {\n     if (pass) {\n-      System.out.println(Constants.ANSI_GREEN + \"Passed the test!\" + Constants.ANSI_RESET);\n+      outStream.println(Constants.ANSI_GREEN + \"Passed the test!\" + Constants.ANSI_RESET);\n     } else {\n-      System.out.println(Constants.ANSI_RED + \"Failed the test!\" + Constants.ANSI_RESET);\n+      outStream.println(Constants.ANSI_RED + \"Failed the test!\" + Constants.ANSI_RESET);\n     }\n   }\n \n+  /**\n+   * Prints information of the test result.\n+   *\n+   * @param pass the test result\n+   */\n+  public static void printPassInfo(boolean pass) {", "originalCommit": "3b3f1f26f81c40a8da58a62e0e942c226c3047c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI2NTE5MA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438265190", "bodyText": "You mean the name is not very helpful? How about printTestStatus?", "author": "jiacheliu3", "createdAt": "2020-06-10T16:42:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA1MzE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA1OTUzOQ==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r437059539", "bodyText": "license header", "author": "LuQQiu", "createdAt": "2020-06-08T23:42:34Z", "path": "shell/src/main/java/alluxio/cli/ValidateHdfsMount.java", "diffHunk": "@@ -0,0 +1,235 @@\n+package alluxio.cli;", "originalCommit": "3b3f1f26f81c40a8da58a62e0e942c226c3047c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA1OTY5NA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r437059694", "bodyText": "The path", "author": "LuQQiu", "createdAt": "2020-06-08T23:43:02Z", "path": "shell/src/main/java/alluxio/cli/ValidateHdfsMount.java", "diffHunk": "@@ -0,0 +1,235 @@\n+package alluxio.cli;\n+\n+import alluxio.cli.validation.ApplicableUfsType;\n+import alluxio.conf.InstancedConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.Source;\n+import alluxio.shell.CommandReturn;\n+import alluxio.underfs.UnderFileSystemConfiguration;\n+import alluxio.util.ConfigurationUtils;\n+import alluxio.util.ShellUtils;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.commons.lang.ArrayUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+/**\n+ * A tool to validate an HDFS mount, before the paths is mounted to Alluxio.", "originalCommit": "3b3f1f26f81c40a8da58a62e0e942c226c3047c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2ODA5MA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r437068090", "bodyText": "@madanadit Is the ValidateHdfs required to run on all nodes? @jiacheliu3 I saw the local option and validate hdfs will run by default on local and remote nodes. The problem is this requires SSH and file permissions which is hard to fulfill in real env. I would suggest either remove the remote check (or at least make it optional) or expose validateHdfs rpcs in master/worker. Then we can ask for the server check through rpc channel.", "author": "LuQQiu", "createdAt": "2020-06-09T00:14:06Z", "path": "shell/src/main/java/alluxio/cli/ValidateHdfsMount.java", "diffHunk": "@@ -0,0 +1,235 @@\n+package alluxio.cli;\n+\n+import alluxio.cli.validation.ApplicableUfsType;\n+import alluxio.conf.InstancedConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.Source;\n+import alluxio.shell.CommandReturn;\n+import alluxio.underfs.UnderFileSystemConfiguration;\n+import alluxio.util.ConfigurationUtils;\n+import alluxio.util.ShellUtils;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.commons.lang.ArrayUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+/**\n+ * A tool to validate an HDFS mount, before the paths is mounted to Alluxio.\n+ * */\n+public class ValidateHdfsMount {\n+  private static final Logger LOG = LoggerFactory.getLogger(ValidateHdfsMount.class);\n+  private static final String JSON_START_POS_MARKER = \"ValidateHdfsMount task results: \\n\";\n+\n+  private static final Option READONLY_OPTION =\n+          Option.builder()\n+                  .longOpt(\"readonly\")\n+                  .required(false)\n+                  .hasArg(false)\n+                  .desc(\"mount point is readonly in Alluxio\")\n+                  .build();\n+  private static final Option SHARED_OPTION =\n+          Option.builder()\n+                  .longOpt(\"shared\")\n+                  .required(false)\n+                  .hasArg(false)\n+                  .desc(\"mount point is shared\")\n+                  .build();\n+  private static final Option OPTION_OPTION =\n+          Option.builder()\n+                  .longOpt(\"option\")\n+                  .required(false)\n+                  .hasArg(true)\n+                  .numberOfArgs(2)\n+                  .argName(\"key=value\")\n+                  .valueSeparator('=')\n+                  .desc(\"options associated with this mount point\")\n+                  .build();\n+  private static final Option LOCAL_OPTION =\n+          Option.builder().required(false).longOpt(\"local\").hasArg(false)\n+                  .desc(\"running only on localhost\").build();\n+  private static final Options OPTIONS =\n+          new Options().addOption(READONLY_OPTION).addOption(SHARED_OPTION)\n+                  .addOption(OPTION_OPTION).addOption(LOCAL_OPTION);\n+\n+  /**\n+   * Invokes {@link UnderFileSystemContractTest} to validate UFS operations.\n+   *\n+   * @param path the UFS path\n+   * @param conf the UFS conf\n+   * @return a {@link alluxio.cli.ValidateUtils.TaskResult} containing the validation result\n+   *        of the UFS operations\n+   * */\n+  public static ValidateUtils.TaskResult runUfsTests(String path, InstancedConfiguration conf) {\n+    try {\n+      UnderFileSystemContractTest test = new UnderFileSystemContractTest(path, conf);\n+      return test.runValidationTask();\n+    } catch (IOException e) {\n+      return new ValidateUtils.TaskResult(ValidateUtils.State.FAILED, \"ufsTests\",\n+              ValidateUtils.getErrorInfo(e), \"\");\n+    }\n+  }\n+\n+  /**\n+   * The entrance.\n+   *\n+   * @param args command line arguments\n+   * */\n+  public static void main(String[] args) throws Exception {\n+    // TODO(jiacheng): use jccommand?\n+    CommandLineParser parser = new DefaultParser();\n+    CommandLine cmd = null;\n+    try {\n+      cmd = parser.parse(OPTIONS, args, true /* stopAtNonOption */);\n+    } catch (ParseException e) {\n+      System.exit(1);\n+    }\n+    args = cmd.getArgs();\n+    String ufsPath = args[0];\n+\n+    InstancedConfiguration conf = InstancedConfiguration.defaults();\n+    if (cmd.hasOption(LOCAL_OPTION.getLongOpt())) {\n+      // Merge options from the command line option\n+      UnderFileSystemConfiguration ufsConf = UnderFileSystemConfiguration.defaults(conf);\n+      if (cmd.hasOption(READONLY_OPTION.getLongOpt())) {\n+        ufsConf.setReadOnly(true);\n+      }\n+      if (cmd.hasOption(SHARED_OPTION.getLongOpt())) {\n+        ufsConf.setShared(true);\n+      }\n+      if (cmd.hasOption(OPTION_OPTION.getLongOpt())) {\n+        Properties properties = cmd.getOptionProperties(OPTION_OPTION.getLongOpt());\n+        ufsConf.merge(properties, Source.MOUNT_OPTION);\n+        LOG.debug(\"Options from cmdline: {}\", properties);\n+      }\n+\n+      // Run validateEnv\n+      Map<String, String> validateOpts = ImmutableMap.of();\n+      ValidateEnv validate = new ValidateEnv(ufsPath, ufsConf);\n+      List<ValidateUtils.TaskResult> results = validate.validateUfs(\n+              ApplicableUfsType.Type.HDFS, validateOpts);\n+\n+      // Run runUfsTests\n+      if (ufsConf.isReadOnly()) {\n+        LOG.debug(\"Ufs operations are skipped because the path is readonly.\");\n+        results.add(new ValidateUtils.TaskResult(ValidateUtils.State.SKIPPED,\n+                UnderFileSystemContractTest.TASK_NAME,\n+                String.format(\"UFS path %s is readonly, skipped UFS operation tests.\", ufsPath),\n+                \"\"));\n+      } else {\n+        results.add(runUfsTests(ufsPath, new InstancedConfiguration(ufsConf)));\n+      }\n+\n+      // Serialize the results back to the calling node\n+      printResults(results);\n+\n+      System.exit(0);\n+    }\n+\n+    // Cluster mode\n+    LOG.info(\"Invoking the command remotely on the Alluxio cluster.\");\n+\n+    // how many nodes in the cluster\n+    Set<String> hosts = ConfigurationUtils.getServerHostnames(conf);\n+    ExecutorService executor = Executors.newFixedThreadPool(hosts.size());\n+\n+    // Invoke validateHdfsMount locally on each host\n+    Map<String, CompletableFuture<CommandReturn>> resultFuture = new HashMap<>();\n+    for (String host : hosts) {\n+      LOG.info(\"validate hdfs mount on host {}\", host);\n+\n+      // We make the assumption that the Alluxio WORK_DIR is the same\n+      String workDir = conf.get(PropertyKey.WORK_DIR);\n+      String alluxioBinPath = Paths.get(workDir, \"bin/alluxio\")", "originalCommit": "3b3f1f26f81c40a8da58a62e0e942c226c3047c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4MDEzNA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r437080134", "bodyText": "In this release (2.3) we target single node (local) validation with no ssh requirement. I agree, remove the remote check.", "author": "madanadit", "createdAt": "2020-06-09T01:01:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2ODA5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0NTA5MQ==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438245091", "bodyText": "Makes sense to me", "author": "jiacheliu3", "createdAt": "2020-06-10T16:11:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2ODA5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyODk3Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438728972", "bodyText": "Removed remote check", "author": "jiacheliu3", "createdAt": "2020-06-11T11:53:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2ODA5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2ODYzOQ==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r437068639", "bodyText": "Why we choose to put the validateHdfs logic inside validateEnv?\npersonally i will prefer to have a separate class for the hdfs<>ValidationTask. and ValidateEnv can call the hdfs<>ValidationTasks if it's root ufs is hdfs. This is because many of the ValidateEnv tasks are not related to hdfs.", "author": "LuQQiu", "createdAt": "2020-06-09T00:16:11Z", "path": "shell/src/main/java/alluxio/cli/ValidateEnv.java", "diffHunk": "@@ -87,80 +93,108 @@\n   private static final List<ValidationTask> MASTER_TASKS = new ArrayList<>();\n   private static final List<ValidationTask> WORKER_TASKS = new ArrayList<>();\n \n-  private static final AlluxioConfiguration CONF;\n+  private final AlluxioConfiguration mConf;\n+  private final String mPath;\n \n-  static {\n-    CONF = InstancedConfiguration.defaults();\n+  /**\n+   * Initializes from the target UFS path and configurations.\n+   *\n+   * @param path the UFS path\n+   * @param conf the UFS configurtions\n+   * */\n+  public ValidateEnv(String path, AlluxioConfiguration conf) {", "originalCommit": "3b3f1f26f81c40a8da58a62e0e942c226c3047c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0NDkyMg==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438244922", "bodyText": "Good call. I'm thinking about that too. Will extract them into a better place and we can discuss.", "author": "jiacheliu3", "createdAt": "2020-06-10T16:11:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2ODYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4MzgzNg==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438283836", "bodyText": "i had a similar question about the method runValidationTask defined in UfsContractTest instead of ValidateHdfsMount where it is actually used", "author": "madanadit", "createdAt": "2020-06-10T17:14:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2ODYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgyNzY4Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438827683", "bodyText": "Actually I tried to move that into ValidateHdfsMount but turned out to be very hard. It's hard because the UfsContractTest is not providing a \"functional\" interface where you just feed it parameters and get results. It has much internal logic and using its embedded fields. Another reason for adding a method to UfsContractTest is, actually most of its tests are run.\nLeft a TODO tho. I will have to refactor much of that class to achieve this.", "author": "jiacheliu3", "createdAt": "2020-06-11T14:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2ODYzOQ=="}], "type": "inlineReview"}, {"oid": "cf3fc88f206e946eea54a89741a459b9402f3647", "url": "https://github.com/Alluxio/alluxio/commit/cf3fc88f206e946eea54a89741a459b9402f3647", "message": "update pom", "committedDate": "2020-06-10T16:35:22Z", "type": "commit"}, {"oid": "99680346c71c20366e5a2065290e915e0e15ea84", "url": "https://github.com/Alluxio/alluxio/commit/99680346c71c20366e5a2065290e915e0e15ea84", "message": "resolve some comments", "committedDate": "2020-06-10T16:51:55Z", "type": "commit"}, {"oid": "09347fc6566bc4e860da132e206cd9d4d895e0cf", "url": "https://github.com/Alluxio/alluxio/commit/09347fc6566bc4e860da132e206cd9d4d895e0cf", "message": "remove cluster mode", "committedDate": "2020-06-10T17:00:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4MTkxOQ==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438281919", "bodyText": "why do you need to set these properties?", "author": "madanadit", "createdAt": "2020-06-10T17:10:57Z", "path": "shell/src/main/java/alluxio/cli/UnderFileSystemContractTest.java", "diffHunk": "@@ -84,6 +109,63 @@ private void run() throws Exception {\n     System.out.printf(\"Tests completed with %d failed.%n\", failedCnt);\n   }\n \n+  /**\n+   * Runs the tests and return a {@link alluxio.cli.ValidateUtils.TaskResult}.\n+   *\n+   * @return a task result for all UFS tests\n+   * */\n+  public ValidateUtils.TaskResult runValidationTask() throws IOException {\n+    Closer closer = Closer.create();\n+    final ByteArrayOutputStream msgBuf = new ByteArrayOutputStream();\n+    final ByteArrayOutputStream adviceBuf = new ByteArrayOutputStream();\n+    PrintStream msgStream = new PrintStream(msgBuf, true);\n+    PrintStream adviceStream = new PrintStream(adviceBuf, true);\n+    closer.register(msgStream);\n+    closer.register(adviceStream);\n+    closer.register(msgBuf);\n+    closer.register(adviceBuf);\n+    try {\n+      UnderFileSystemConfiguration ufsConf = getUfsConf();\n+      UnderFileSystemFactory factory = UnderFileSystemFactoryRegistry.find(mUfsPath, ufsConf);\n+      // Check if the ufs path is valid\n+      if (factory == null || !factory.supportsPath(mUfsPath)) {\n+        msgStream.append(String.format(\"%s is not a valid path%n\", mUfsPath));\n+        adviceStream.append(String.format(\"Please validate if %s is a correct path\\n\", mUfsPath));\n+        return new ValidateUtils.TaskResult(ValidateUtils.State.FAILED, TASK_NAME,\n+                msgBuf.toString(), adviceBuf.toString());\n+      }\n+\n+      // Set common properties\n+      mConf.set(PropertyKey.UNDERFS_LISTING_LENGTH, \"50\");", "originalCommit": "09347fc6566bc4e860da132e206cd9d4d895e0cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MjY2Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438292662", "bodyText": "This actually is inherited from the existing UFSContractTest#run. @LuQQiu Do you think I should keep these properties for the test?", "author": "jiacheliu3", "createdAt": "2020-06-10T17:29:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4MTkxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MjgyNQ==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r439082825", "bodyText": "Those properties are inherited from original UfsContrctTests and are added to for testing purposes. Like listing less files , using small blocks and speed up tests. I think it will be better to keep these properties", "author": "LuQQiu", "createdAt": "2020-06-11T21:34:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4MTkxOQ=="}], "type": "inlineReview"}, {"oid": "4738033507dee7df99436a0921b27e321116c937", "url": "https://github.com/Alluxio/alluxio/commit/4738033507dee7df99436a0921b27e321116c937", "message": "add cmdline", "committedDate": "2020-06-10T17:15:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4NTE2OA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438285168", "bodyText": "is this better suited part of the interface definition?", "author": "madanadit", "createdAt": "2020-06-10T17:16:36Z", "path": "shell/src/main/java/alluxio/cli/validation/AbstractValidationTask.java", "diffHunk": "@@ -20,6 +20,13 @@\n  * Abstract class for validation environment.\n  */\n public abstract class AbstractValidationTask implements ValidationTask {\n+  /**\n+   * Gets the name of the task.\n+   *\n+   * @return the task name\n+   * */\n+  public abstract String getName();", "originalCommit": "09347fc6566bc4e860da132e206cd9d4d895e0cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4NzA3MA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438287070", "bodyText": "we agreed to validate local conf only w/o ssh?", "author": "madanadit", "createdAt": "2020-06-10T17:19:53Z", "path": "shell/src/main/java/alluxio/cli/validation/ClusterConfConsistencyValidationTask.java", "diffHunk": "@@ -122,37 +147,34 @@ public TaskResult validate(Map<String, String> optionMap) throws InterruptedExce\n         }\n         String remoteValue = allProperties.get(remoteNode).getProperty(propertyName);\n         if (!StringUtils.equals(remoteValue, baseValue)) {\n-          System.err.format(\"%s: Property \\\"%s\\\" is inconsistent between node %s and %s.%n\",\n-              errLabel, propertyName, baseNode, remoteNode);\n-          System.err.format(\" %s: %s%n %s: %s%n\", baseNode, Objects.toString(baseValue, \"not set\"),\n-              remoteNode,  Objects.toString(remoteValue, \"not set\"));\n+          msg.append(String.format(\"%s: Property \\\"%s\\\" is inconsistent between node %s and %s.%n\",\n+              errLabel, propertyName, baseNode, remoteNode));\n+          msg.append(String.format(\" %s: %s%n %s: %s%n\", baseNode,\n+                  Objects.toString(baseValue, \"not set\"),\n+              remoteNode,  Objects.toString(remoteValue, \"not set\")));\n+          advice.append(String.format(\"Please check your settings for property %s on %s and %s.%n\",\n+                  propertyName, baseNode, remoteNode));\n           isConsistent = false;\n         }\n       }\n       if (!isConsistent) {\n-        result = result == TaskResult.FAILED ? TaskResult.FAILED : errLevel;\n+        state = state == ValidateUtils.State.FAILED ? ValidateUtils.State.FAILED : errLevel;\n       }\n     }\n-    return result;\n+    return new ValidateUtils.TaskResult(state, getName(), msg.toString(), advice.toString());\n   }\n \n-  @Nullable\n-  private Properties getNodeConf(String node) {\n-    try {\n-      String homeDir = mConf.get(PropertyKey.HOME);\n-      String remoteCommand = String.format(\n-          \"%s/bin/alluxio getConf\", homeDir);\n-      String localCommand = String.format(\n-          \"ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no -tt %s \\\"bash %s\\\"\",\n-          node, remoteCommand);\n-      String[] command = {\"bash\", \"-c\", localCommand};\n-      Properties properties = new Properties();\n-      Process process = Runtime.getRuntime().exec(command);\n-      properties.load(process.getInputStream());\n-      return properties;\n-    } catch (IOException e) {\n-      System.err.format(\"Unable to retrieve configuration for %s: %s.\", node, e.getMessage());\n-      return null;\n-    }\n+  private Properties getNodeConf(String node) throws IOException {\n+    String homeDir = mConf.get(PropertyKey.HOME);\n+    String remoteCommand = String.format(\n+        \"%s/bin/alluxio getConf\", homeDir);\n+    String localCommand = String.format(", "originalCommit": "09347fc6566bc4e860da132e206cd9d4d895e0cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MTY2MA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438291660", "bodyText": "Yes remote has just been removed", "author": "jiacheliu3", "createdAt": "2020-06-10T17:27:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4NzA3MA=="}], "type": "inlineReview"}, {"oid": "f2d5fc1a2c2c06679df5e1da5c7d99971faf58f4", "url": "https://github.com/Alluxio/alluxio/commit/f2d5fc1a2c2c06679df5e1da5c7d99971faf58f4", "message": "group results in the end", "committedDate": "2020-06-10T17:33:48Z", "type": "commit"}, {"oid": "55b44bfc643ceb4b0dbac02bc4bd6d67b7808116", "url": "https://github.com/Alluxio/alluxio/commit/55b44bfc643ceb4b0dbac02bc4bd6d67b7808116", "message": "correct super user check", "committedDate": "2020-06-10T18:01:19Z", "type": "commit"}, {"oid": "94e6c76210f158292c8e7e6d293422fead2fb400", "url": "https://github.com/Alluxio/alluxio/commit/94e6c76210f158292c8e7e6d293422fead2fb400", "message": "move hdfs validation tasks and rewrite impersonation check logic", "committedDate": "2020-06-11T11:42:54Z", "type": "commit"}, {"oid": "6cc3601cdb607fc574c650a6caf4131e72e88ed1", "url": "https://github.com/Alluxio/alluxio/commit/6cc3601cdb607fc574c650a6caf4131e72e88ed1", "message": "merge updated master", "committedDate": "2020-06-11T11:50:51Z", "type": "commit"}, {"oid": "7b4a15412c8dd3ac4f21c801262473d63cf3218f", "url": "https://github.com/Alluxio/alluxio/commit/7b4a15412c8dd3ac4f21c801262473d63cf3218f", "message": "master is too fast i gotta catch up", "committedDate": "2020-06-11T12:15:05Z", "type": "commit"}, {"oid": "d726454116a9919602e40b6bff0f60e36df25aae", "url": "https://github.com/Alluxio/alluxio/commit/d726454116a9919602e40b6bff0f60e36df25aae", "message": "resolve comment", "committedDate": "2020-06-11T12:49:00Z", "type": "commit"}, {"oid": "4ad06f2a3bafa66919b0a18f2ed142c30e1e9337", "url": "https://github.com/Alluxio/alluxio/commit/4ad06f2a3bafa66919b0a18f2ed142c30e1e9337", "message": "resolve TODOs", "committedDate": "2020-06-11T13:17:00Z", "type": "commit"}, {"oid": "379f56fea0eae80186e74a782e7f40cd123dd20a", "url": "https://github.com/Alluxio/alluxio/commit/379f56fea0eae80186e74a782e7f40cd123dd20a", "message": "checkstyle", "committedDate": "2020-06-11T13:24:27Z", "type": "commit"}, {"oid": "508bdc5cd3f003bc56273d954f03bae43b0a0a26", "url": "https://github.com/Alluxio/alluxio/commit/508bdc5cd3f003bc56273d954f03bae43b0a0a26", "message": "resolve comments", "committedDate": "2020-06-11T14:29:05Z", "type": "commit"}, {"oid": "f0ac42fa46e20e8a955e169fbe6b33dc5bfe6933", "url": "https://github.com/Alluxio/alluxio/commit/f0ac42fa46e20e8a955e169fbe6b33dc5bfe6933", "message": "pom update and checkstyle", "committedDate": "2020-06-11T14:38:28Z", "type": "commit"}, {"oid": "4e7aa61de5cc376548823bd786450149c4fc8cd1", "url": "https://github.com/Alluxio/alluxio/commit/4e7aa61de5cc376548823bd786450149c4fc8cd1", "message": "pom update", "committedDate": "2020-06-11T14:40:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg0NTg0OQ==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438845849", "bodyText": "@madanadit PTAL at the impersonation check now, updated per our discussion today. Now the logic goes as follows:\n// Skipped if authType is NOSASL\nvalidateProxyUsers(String alluxioUser) {\n// if neither hadoop.proxyuser.alluxioUser.users and hadoop.proxyuser.alluxioUser.groups are configured -> ERROR\n// If either is *, OK\n// Otherwise  -> WARN and let the user check. \n}\n\nWhat do you think about the final WARN scenario? Maybe hadoop.proxyuser.alluxioUser.users or hadoop.proxyuser.alluxioUser.groups has some config but we don't really know if that's what we want. I left a TODO in case we want to add a little more to this part.", "author": "jiacheliu3", "createdAt": "2020-06-11T14:53:28Z", "path": "shell/src/main/java/alluxio/cli/validation/hdfs/HdfsProxyUserValidationTask.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package alluxio.cli.validation.hdfs;\n+\n+import alluxio.cli.ValidationUtils;\n+import alluxio.cli.validation.ApplicableUfsType;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.status.UnauthenticatedException;\n+import alluxio.security.authentication.AuthType;\n+import alluxio.security.authentication.ImpersonationAuthenticator;\n+import alluxio.security.user.UserState;\n+\n+import java.util.Map;\n+\n+/**\n+ * Validates the proxyuser configurations for alluxio in hdfs.\n+ * */\n+@ApplicableUfsType(ApplicableUfsType.Type.HDFS)\n+public class HdfsProxyUserValidationTask extends HdfsConfValidationTask {\n+  /**\n+   * Creates a new instance of {@link HdfsProxyUserValidationTask}\n+   * for validating proxyuser configuration.\n+   *\n+   * @param path the UFS path\n+   * @param conf the UFS configuration\n+   */\n+  public HdfsProxyUserValidationTask(String path, AlluxioConfiguration conf) {\n+    super(path, conf);\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return \"ValidateProxyUserConf\";\n+  }\n+\n+  private String getCurrentUser() throws UnauthenticatedException {\n+    UserState s = UserState.Factory.create(mConf);\n+    return s.getUser().getName();\n+  }\n+\n+  private ValidationUtils.TaskResult validateProxyUsers(String userName) {\n+    String proxyUserKey = String.format(\"hadoop.proxyuser.%s.users\", userName);\n+    String proxyGroupKey = String.format(\"hadoop.proxyuser.%s.groups\", userName);\n+    String proxyUsers = mCoreConf.getOrDefault(proxyUserKey, \"\");\n+    String proxyGroups = mCoreConf.getOrDefault(proxyGroupKey, \"\");\n+\n+    // Neither proxy users or groups is configured in core-site.xml\n+    if (proxyUsers.equals(\"\") && proxyGroups.equals(\"\")) {\n+      mMsg.append(String.format(\"Alluxio is running as user %s. But neither %s or %s is \"\n+              + \"configured in hadoop configuration. Alluxio is not able to perform \"\n+              + \"impersonation.%n\", userName, proxyUserKey, proxyGroupKey));\n+      mAdvice.append(String.format(\"Please enable Alluxio user %s to impersonate.%n\", userName));\n+\n+      return new ValidationUtils.TaskResult(ValidationUtils.State.FAILED, getName(), mMsg.toString(),\n+              mAdvice.toString());\n+    }\n+\n+    // If proxy users/groups is *, alluxio can impersonate anyone\n+    if (proxyUsers.equals(ImpersonationAuthenticator.WILDCARD)\n+            || proxyGroups.equals(ImpersonationAuthenticator.WILDCARD)) {\n+      mMsg.append(String.format(\"Alluxio user %s can impersonate as any user/group in HDFS.%n\",\n+              userName));\n+      return new ValidationUtils.TaskResult(ValidationUtils.State.OK, getName(),\n+              mMsg.toString(), mAdvice.toString());\n+    }\n+\n+    // There are proxyable users and groups for the Alluxio user in HDFS,\n+    // but we cannot know if that is a full set.\n+    // Leave a warning for the user to double check.\n+    // TODO(jiacheng): can we do better check than this?", "originalCommit": "4e7aa61de5cc376548823bd786450149c4fc8cd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d842b19e37c3fd60cea8504e72ea7958ea1f15b2", "url": "https://github.com/Alluxio/alluxio/commit/d842b19e37c3fd60cea8504e72ea7958ea1f15b2", "message": "checkstyle", "committedDate": "2020-06-11T15:02:26Z", "type": "commit"}, {"oid": "c4b7f78c344d71cb1493617c67c6105f1279229b", "url": "https://github.com/Alluxio/alluxio/commit/c4b7f78c344d71cb1493617c67c6105f1279229b", "message": "spotbugs", "committedDate": "2020-06-11T15:34:54Z", "type": "commit"}, {"oid": "015c5b853daab3900487b6b116fb71ed987d7028", "url": "https://github.com/Alluxio/alluxio/commit/015c5b853daab3900487b6b116fb71ed987d7028", "message": "checkcheckstyle", "committedDate": "2020-06-12T01:05:07Z", "type": "commit"}]}