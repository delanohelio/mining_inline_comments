{"pr_number": 11440, "pr_title": "Implement client IO stress tools", "pr_createdAt": "2020-05-15T19:48:15Z", "pr_url": "https://github.com/Alluxio/alluxio/pull/11440", "timeline": [{"oid": "a01a3deea2d159967e51debe9c448a9d5c90dbda", "url": "https://github.com/Alluxio/alluxio/commit/a01a3deea2d159967e51debe9c448a9d5c90dbda", "message": "Implement client IO stress tools", "committedDate": "2020-05-15T19:45:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzODY5Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426038696", "bodyText": "use private static constant string?", "author": "bradyoo", "createdAt": "2020-05-15T20:46:05Z", "path": "stress/common/src/main/java/alluxio/stress/Parameters.java", "diffHunk": "@@ -54,7 +55,26 @@\n    */\n   public String getDescription(List<String> fields) {\n     final Map<String, Object> map = toMap();\n-    return fields.stream().map(f -> f + \": \" + map.get(f)).collect(Collectors.joining(\", \"));\n+    return fields.stream()\n+        .map(fieldName -> prettyPrintDescriptionField(fieldName, map.get(fieldName)))\n+        .collect(Collectors.joining(\", \"));\n+  }\n+\n+  /**\n+   * @param fieldName the field name\n+   * @param value the value of the field\n+   * @return the string representation of this field/value\n+   */\n+  protected String prettyPrintDescriptionField(String fieldName, Object value) {\n+    if (\"mBasePath\".equals(fieldName)) {", "originalCommit": "a01a3deea2d159967e51debe9c448a9d5c90dbda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc1MzI2Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426753262", "bodyText": "done", "author": "gpang", "createdAt": "2020-05-18T16:31:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzODY5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzOTA2Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426039062", "bodyText": "Is \"BasePath: \" not needed?", "author": "bradyoo", "createdAt": "2020-05-15T20:47:05Z", "path": "stress/common/src/main/java/alluxio/stress/Parameters.java", "diffHunk": "@@ -54,7 +55,26 @@\n    */\n   public String getDescription(List<String> fields) {\n     final Map<String, Object> map = toMap();\n-    return fields.stream().map(f -> f + \": \" + map.get(f)).collect(Collectors.joining(\", \"));\n+    return fields.stream()\n+        .map(fieldName -> prettyPrintDescriptionField(fieldName, map.get(fieldName)))\n+        .collect(Collectors.joining(\", \"));\n+  }\n+\n+  /**\n+   * @param fieldName the field name\n+   * @param value the value of the field\n+   * @return the string representation of this field/value\n+   */\n+  protected String prettyPrintDescriptionField(String fieldName, Object value) {\n+    if (\"mBasePath\".equals(fieldName)) {\n+      AlluxioURI uri = new AlluxioURI(value.toString());\n+      return String.format(\"%s-%s\", uri.getScheme(), uri.getAuthority());", "originalCommit": "a01a3deea2d159967e51debe9c448a9d5c90dbda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc1MzcwOQ==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426753709", "bodyText": "No, I don't think so. The main purpose for this translation, is to shorten a lot of these outputs, or make them easier to read.", "author": "gpang", "createdAt": "2020-05-18T16:32:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzOTA2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzOTY1Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426039653", "bodyText": "Many of these parameters feel very similar to MasterBenchParameters. Any ways to share code?", "author": "bradyoo", "createdAt": "2020-05-15T20:48:33Z", "path": "stress/common/src/main/java/alluxio/stress/client/ClientIOParameters.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.client;\n+\n+import alluxio.stress.Parameters;\n+\n+import com.beust.jcommander.DynamicParameter;\n+import com.beust.jcommander.Parameter;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * This holds all the parameters. All fields are public for easier json ser/de without all the\n+ * getters and setters.\n+ */\n+public final class ClientIOParameters extends Parameters {", "originalCommit": "a01a3deea2d159967e51debe9c448a9d5c90dbda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc1NDI0MA==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426754240", "bodyText": "Yeah, I know. I don't know if the parameter functionality allows inheritance or something, but I just haven't looked into that yet. It feels ok to keep them separate, since there is no logical requirement that the client io tests and the master throughput tests need to have the same set of parameters.", "author": "gpang", "createdAt": "2020-05-18T16:33:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzOTY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0Mjc5OQ==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426042799", "bodyText": "Where is the aggregation?", "author": "bradyoo", "createdAt": "2020-05-15T20:56:21Z", "path": "stress/common/src/main/java/alluxio/stress/client/ClientIOTaskResult.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.client;\n+\n+import alluxio.Constants;\n+import alluxio.collections.Pair;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.Parameters;\n+import alluxio.stress.Summary;\n+import alluxio.stress.TaskResult;\n+import alluxio.stress.graph.Graph;\n+import alluxio.stress.graph.LineGraph;\n+\n+import com.google.common.base.Splitter;\n+\n+import java.io.IOException;\n+import java.text.DateFormat;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The task result for the master stress tests.\n+ */\n+public final class ClientIOTaskResult implements TaskResult, Summary {\n+  private Map<Integer, ThreadCountResult> mThreadCountResults;\n+  private BaseParameters mBaseParameters;\n+  private ClientIOParameters mParameters;\n+\n+  /**\n+   * Creates an instance.\n+   */\n+  public ClientIOTaskResult() {\n+    // Default constructor required for json deserialization\n+    mThreadCountResults = new HashMap<>();\n+  }\n+\n+  /**\n+   * @return the base parameters\n+   */\n+  public BaseParameters getBaseParameters() {\n+    return mBaseParameters;\n+  }\n+\n+  /**\n+   * @param baseParameters the base parameters\n+   */\n+  public void setBaseParameters(BaseParameters baseParameters) {\n+    mBaseParameters = baseParameters;\n+  }\n+\n+  /**\n+   * @return the parameters\n+   */\n+  public ClientIOParameters getParameters() {\n+    return mParameters;\n+  }\n+\n+  /**\n+   * @param parameters the parameters\n+   */\n+  public void setParameters(ClientIOParameters parameters) {\n+    mParameters = parameters;\n+  }\n+\n+  /**\n+   * @return the map of thread counts to results\n+   */\n+  public Map<Integer, ThreadCountResult> getThreadCountResults() {\n+    return mThreadCountResults;\n+  }\n+\n+  /**\n+   * @param threadCountResults the map of thread counts to results\n+   */\n+  public void setThreadCountResults(Map<Integer, ThreadCountResult> threadCountResults) {\n+    mThreadCountResults = threadCountResults;\n+  }\n+\n+  /**\n+   * @param threadCount the thread count of the results\n+   * @param threadCountResult the results to add\n+   */\n+  public void addThreadCountResults(int threadCount, ThreadCountResult threadCountResult) {\n+    mThreadCountResults.put(threadCount, threadCountResult);\n+  }\n+\n+  private long computeLastEndMs() {\n+    long endMs = 0;\n+    for (ThreadCountResult result : mThreadCountResults.values()) {\n+      endMs = Math.max(endMs, result.getEndMs());\n+    }\n+    return endMs;\n+  }\n+\n+  private LineGraph.Data getThroughputData() {\n+    LineGraph.Data data = new LineGraph.Data();\n+    for (Map.Entry<Integer, ThreadCountResult> entry : mThreadCountResults.entrySet()) {\n+      data.addData(entry.getKey(), entry.getValue().mIOMBps);\n+    }\n+    return data;\n+  }\n+\n+  private List<String> collectErrors() {\n+    List<String> errors = new ArrayList<>();\n+    for (Map.Entry<Integer, ThreadCountResult> entry : mThreadCountResults.entrySet()) {\n+      // add all the errors for this thread count, with the thread count appended to prefix\n+      errors.addAll(\n+          entry.getValue().getErrors().stream().map(err -> entry.getKey().toString() + \": \" + err)\n+              .collect(Collectors.toList()));\n+    }\n+    return errors;\n+  }\n+\n+  @Override\n+  public TaskResult.Aggregator aggregator() {\n+    return new Aggregator();\n+  }\n+\n+  private static final class Aggregator implements TaskResult.Aggregator {\n+    @Override\n+    public ClientIOTaskResult aggregate(Iterable<TaskResult> results) throws Exception {\n+      Iterator<TaskResult> it = results.iterator();\n+      if (it.hasNext()) {\n+        TaskResult taskResult = it.next();\n+        if (!(taskResult instanceof ClientIOTaskResult)) {\n+          throw new IOException(\n+              \"TaskResult is not of type ClientIOTaskResult. class: \" + taskResult.getClass()\n+                  .getName());\n+        }\n+        return (ClientIOTaskResult) taskResult;", "originalCommit": "a01a3deea2d159967e51debe9c448a9d5c90dbda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc2MDA5NQ==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426760095", "bodyText": "This is a single node test, so aggregation is not possible.", "author": "gpang", "createdAt": "2020-05-18T16:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0Mjc5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0NDM5NQ==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426044395", "bodyText": "I notice that ClientIOTaskResult is both a TaskResult and a Summary. Is that going to be the case for MasterBenchTaskResult as well?", "author": "bradyoo", "createdAt": "2020-05-15T20:59:15Z", "path": "stress/common/src/main/java/alluxio/stress/client/ClientIOTaskResult.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.client;\n+\n+import alluxio.Constants;\n+import alluxio.collections.Pair;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.Parameters;\n+import alluxio.stress.Summary;\n+import alluxio.stress.TaskResult;\n+import alluxio.stress.graph.Graph;\n+import alluxio.stress.graph.LineGraph;\n+\n+import com.google.common.base.Splitter;\n+\n+import java.io.IOException;\n+import java.text.DateFormat;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The task result for the master stress tests.\n+ */\n+public final class ClientIOTaskResult implements TaskResult, Summary {", "originalCommit": "a01a3deea2d159967e51debe9c448a9d5c90dbda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc1NjMxMg==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426756312", "bodyText": "Yes, it is both, because the client io test is a single node test. Therefore, it doesn't make sense to aggregate multiple task results into a summary, and instead, a single task result just becomes the summary.", "author": "gpang", "createdAt": "2020-05-18T16:37:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0NDM5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0NTY0OQ==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426045649", "bodyText": "I really never understood why these aren't Math.min'd", "author": "bradyoo", "createdAt": "2020-05-15T21:02:19Z", "path": "stress/common/src/main/java/alluxio/stress/client/ClientIOTaskResult.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.client;\n+\n+import alluxio.Constants;\n+import alluxio.collections.Pair;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.Parameters;\n+import alluxio.stress.Summary;\n+import alluxio.stress.TaskResult;\n+import alluxio.stress.graph.Graph;\n+import alluxio.stress.graph.LineGraph;\n+\n+import com.google.common.base.Splitter;\n+\n+import java.io.IOException;\n+import java.text.DateFormat;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The task result for the master stress tests.\n+ */\n+public final class ClientIOTaskResult implements TaskResult, Summary {\n+  private Map<Integer, ThreadCountResult> mThreadCountResults;\n+  private BaseParameters mBaseParameters;\n+  private ClientIOParameters mParameters;\n+\n+  /**\n+   * Creates an instance.\n+   */\n+  public ClientIOTaskResult() {\n+    // Default constructor required for json deserialization\n+    mThreadCountResults = new HashMap<>();\n+  }\n+\n+  /**\n+   * @return the base parameters\n+   */\n+  public BaseParameters getBaseParameters() {\n+    return mBaseParameters;\n+  }\n+\n+  /**\n+   * @param baseParameters the base parameters\n+   */\n+  public void setBaseParameters(BaseParameters baseParameters) {\n+    mBaseParameters = baseParameters;\n+  }\n+\n+  /**\n+   * @return the parameters\n+   */\n+  public ClientIOParameters getParameters() {\n+    return mParameters;\n+  }\n+\n+  /**\n+   * @param parameters the parameters\n+   */\n+  public void setParameters(ClientIOParameters parameters) {\n+    mParameters = parameters;\n+  }\n+\n+  /**\n+   * @return the map of thread counts to results\n+   */\n+  public Map<Integer, ThreadCountResult> getThreadCountResults() {\n+    return mThreadCountResults;\n+  }\n+\n+  /**\n+   * @param threadCountResults the map of thread counts to results\n+   */\n+  public void setThreadCountResults(Map<Integer, ThreadCountResult> threadCountResults) {\n+    mThreadCountResults = threadCountResults;\n+  }\n+\n+  /**\n+   * @param threadCount the thread count of the results\n+   * @param threadCountResult the results to add\n+   */\n+  public void addThreadCountResults(int threadCount, ThreadCountResult threadCountResult) {\n+    mThreadCountResults.put(threadCount, threadCountResult);\n+  }\n+\n+  private long computeLastEndMs() {\n+    long endMs = 0;\n+    for (ThreadCountResult result : mThreadCountResults.values()) {\n+      endMs = Math.max(endMs, result.getEndMs());\n+    }\n+    return endMs;\n+  }\n+\n+  private LineGraph.Data getThroughputData() {\n+    LineGraph.Data data = new LineGraph.Data();\n+    for (Map.Entry<Integer, ThreadCountResult> entry : mThreadCountResults.entrySet()) {\n+      data.addData(entry.getKey(), entry.getValue().mIOMBps);\n+    }\n+    return data;\n+  }\n+\n+  private List<String> collectErrors() {\n+    List<String> errors = new ArrayList<>();\n+    for (Map.Entry<Integer, ThreadCountResult> entry : mThreadCountResults.entrySet()) {\n+      // add all the errors for this thread count, with the thread count appended to prefix\n+      errors.addAll(\n+          entry.getValue().getErrors().stream().map(err -> entry.getKey().toString() + \": \" + err)\n+              .collect(Collectors.toList()));\n+    }\n+    return errors;\n+  }\n+\n+  @Override\n+  public TaskResult.Aggregator aggregator() {\n+    return new Aggregator();\n+  }\n+\n+  private static final class Aggregator implements TaskResult.Aggregator {\n+    @Override\n+    public ClientIOTaskResult aggregate(Iterable<TaskResult> results) throws Exception {\n+      Iterator<TaskResult> it = results.iterator();\n+      if (it.hasNext()) {\n+        TaskResult taskResult = it.next();\n+        if (!(taskResult instanceof ClientIOTaskResult)) {\n+          throw new IOException(\n+              \"TaskResult is not of type ClientIOTaskResult. class: \" + taskResult.getClass()\n+                  .getName());\n+        }\n+        return (ClientIOTaskResult) taskResult;\n+      }\n+      return new ClientIOTaskResult();\n+    }\n+  }\n+\n+  @Override\n+  public alluxio.stress.GraphGenerator graphGenerator() {\n+    return new GraphGenerator();\n+  }\n+\n+  /**\n+   * The graph generator for this summary.\n+   */\n+  public static final class GraphGenerator extends alluxio.stress.GraphGenerator {\n+    @Override\n+    public List<Graph> generate(List<? extends Summary> results) {\n+      List<Graph> graphs = new ArrayList<>();\n+      // only examine ClientIOSummary\n+      List<ClientIOTaskResult> summaries =\n+          results.stream().map(x -> (ClientIOTaskResult) x).collect(Collectors.toList());\n+\n+      // Iterate over all operations\n+      for (Operation operation : Operation.values()) {\n+        List<ClientIOTaskResult> opSummaries =\n+            summaries.stream().filter(x -> x.mParameters.mOperation == operation)\n+                .collect(Collectors.toList());\n+\n+        if (!opSummaries.isEmpty()) {\n+          // first() is the list of common field names, second() is the list of unique field names\n+          Pair<List<String>, List<String>> fieldNames = Parameters.partitionFieldNames(\n+              opSummaries.stream().map(x -> x.mParameters).collect(Collectors.toList()));\n+\n+          // Split up common description into 100 character chunks, for the sub title\n+          List<String> subTitle = new ArrayList<>(Splitter.fixedLength(100).splitToList(\n+              opSummaries.get(0).mParameters.getDescription(fieldNames.getFirst())));\n+\n+          for (ClientIOTaskResult summary : opSummaries) {\n+            String series = summary.mParameters.getDescription(fieldNames.getSecond());\n+            subTitle.add(series + \": \" + DateFormat.getDateTimeInstance()\n+                .format(summary.computeLastEndMs()));\n+          }\n+\n+          LineGraph responseTimeGraph =\n+              new LineGraph(operation + \" - Throughput\", subTitle, \"# Threads\",\n+                  \"Throughput (MB/s)\");\n+\n+          for (ClientIOTaskResult summary : opSummaries) {\n+            String series = summary.mParameters.getDescription(fieldNames.getSecond());\n+            responseTimeGraph.addDataSeries(series, summary.getThroughputData());\n+            responseTimeGraph.setErrors(series, summary.collectErrors());\n+          }\n+\n+          graphs.add(responseTimeGraph);\n+        }\n+      }\n+\n+      return graphs;\n+    }\n+  }\n+\n+  /**\n+   * A result for a single thread count test.\n+   */\n+  public static final class ThreadCountResult {\n+    private long mRecordStartMs;\n+    private long mEndMs;\n+    private long mDurationMs;\n+    private long mIOBytes;\n+    private float mIOMBps;\n+    private List<String> mErrors;\n+\n+    /**\n+     * Creates an instance.\n+     */\n+    public ThreadCountResult() {\n+      // Default constructor required for json deserialization\n+      mErrors = new ArrayList<>();\n+    }\n+\n+    /**\n+     * Merges (updates) a result with this result.\n+     *\n+     * @param result  the result to merge\n+     */\n+    public void merge(ClientIOTaskResult.ThreadCountResult result) {\n+      mRecordStartMs = result.mRecordStartMs;", "originalCommit": "a01a3deea2d159967e51debe9c448a9d5c90dbda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc2MTY3MQ==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426761671", "bodyText": "used min().", "author": "gpang", "createdAt": "2020-05-18T16:46:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0NTY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0NjI0MQ==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426046241", "bodyText": "I would avoid making these two variables instance variables and just have getters for them that do this. Even if this thing is being json serialized, it's not like your json deserialization is going to use these variables correctly if they aren't these values.", "author": "bradyoo", "createdAt": "2020-05-15T21:04:02Z", "path": "stress/common/src/main/java/alluxio/stress/client/ClientIOTaskResult.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.client;\n+\n+import alluxio.Constants;\n+import alluxio.collections.Pair;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.Parameters;\n+import alluxio.stress.Summary;\n+import alluxio.stress.TaskResult;\n+import alluxio.stress.graph.Graph;\n+import alluxio.stress.graph.LineGraph;\n+\n+import com.google.common.base.Splitter;\n+\n+import java.io.IOException;\n+import java.text.DateFormat;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The task result for the master stress tests.\n+ */\n+public final class ClientIOTaskResult implements TaskResult, Summary {\n+  private Map<Integer, ThreadCountResult> mThreadCountResults;\n+  private BaseParameters mBaseParameters;\n+  private ClientIOParameters mParameters;\n+\n+  /**\n+   * Creates an instance.\n+   */\n+  public ClientIOTaskResult() {\n+    // Default constructor required for json deserialization\n+    mThreadCountResults = new HashMap<>();\n+  }\n+\n+  /**\n+   * @return the base parameters\n+   */\n+  public BaseParameters getBaseParameters() {\n+    return mBaseParameters;\n+  }\n+\n+  /**\n+   * @param baseParameters the base parameters\n+   */\n+  public void setBaseParameters(BaseParameters baseParameters) {\n+    mBaseParameters = baseParameters;\n+  }\n+\n+  /**\n+   * @return the parameters\n+   */\n+  public ClientIOParameters getParameters() {\n+    return mParameters;\n+  }\n+\n+  /**\n+   * @param parameters the parameters\n+   */\n+  public void setParameters(ClientIOParameters parameters) {\n+    mParameters = parameters;\n+  }\n+\n+  /**\n+   * @return the map of thread counts to results\n+   */\n+  public Map<Integer, ThreadCountResult> getThreadCountResults() {\n+    return mThreadCountResults;\n+  }\n+\n+  /**\n+   * @param threadCountResults the map of thread counts to results\n+   */\n+  public void setThreadCountResults(Map<Integer, ThreadCountResult> threadCountResults) {\n+    mThreadCountResults = threadCountResults;\n+  }\n+\n+  /**\n+   * @param threadCount the thread count of the results\n+   * @param threadCountResult the results to add\n+   */\n+  public void addThreadCountResults(int threadCount, ThreadCountResult threadCountResult) {\n+    mThreadCountResults.put(threadCount, threadCountResult);\n+  }\n+\n+  private long computeLastEndMs() {\n+    long endMs = 0;\n+    for (ThreadCountResult result : mThreadCountResults.values()) {\n+      endMs = Math.max(endMs, result.getEndMs());\n+    }\n+    return endMs;\n+  }\n+\n+  private LineGraph.Data getThroughputData() {\n+    LineGraph.Data data = new LineGraph.Data();\n+    for (Map.Entry<Integer, ThreadCountResult> entry : mThreadCountResults.entrySet()) {\n+      data.addData(entry.getKey(), entry.getValue().mIOMBps);\n+    }\n+    return data;\n+  }\n+\n+  private List<String> collectErrors() {\n+    List<String> errors = new ArrayList<>();\n+    for (Map.Entry<Integer, ThreadCountResult> entry : mThreadCountResults.entrySet()) {\n+      // add all the errors for this thread count, with the thread count appended to prefix\n+      errors.addAll(\n+          entry.getValue().getErrors().stream().map(err -> entry.getKey().toString() + \": \" + err)\n+              .collect(Collectors.toList()));\n+    }\n+    return errors;\n+  }\n+\n+  @Override\n+  public TaskResult.Aggregator aggregator() {\n+    return new Aggregator();\n+  }\n+\n+  private static final class Aggregator implements TaskResult.Aggregator {\n+    @Override\n+    public ClientIOTaskResult aggregate(Iterable<TaskResult> results) throws Exception {\n+      Iterator<TaskResult> it = results.iterator();\n+      if (it.hasNext()) {\n+        TaskResult taskResult = it.next();\n+        if (!(taskResult instanceof ClientIOTaskResult)) {\n+          throw new IOException(\n+              \"TaskResult is not of type ClientIOTaskResult. class: \" + taskResult.getClass()\n+                  .getName());\n+        }\n+        return (ClientIOTaskResult) taskResult;\n+      }\n+      return new ClientIOTaskResult();\n+    }\n+  }\n+\n+  @Override\n+  public alluxio.stress.GraphGenerator graphGenerator() {\n+    return new GraphGenerator();\n+  }\n+\n+  /**\n+   * The graph generator for this summary.\n+   */\n+  public static final class GraphGenerator extends alluxio.stress.GraphGenerator {\n+    @Override\n+    public List<Graph> generate(List<? extends Summary> results) {\n+      List<Graph> graphs = new ArrayList<>();\n+      // only examine ClientIOSummary\n+      List<ClientIOTaskResult> summaries =\n+          results.stream().map(x -> (ClientIOTaskResult) x).collect(Collectors.toList());\n+\n+      // Iterate over all operations\n+      for (Operation operation : Operation.values()) {\n+        List<ClientIOTaskResult> opSummaries =\n+            summaries.stream().filter(x -> x.mParameters.mOperation == operation)\n+                .collect(Collectors.toList());\n+\n+        if (!opSummaries.isEmpty()) {\n+          // first() is the list of common field names, second() is the list of unique field names\n+          Pair<List<String>, List<String>> fieldNames = Parameters.partitionFieldNames(\n+              opSummaries.stream().map(x -> x.mParameters).collect(Collectors.toList()));\n+\n+          // Split up common description into 100 character chunks, for the sub title\n+          List<String> subTitle = new ArrayList<>(Splitter.fixedLength(100).splitToList(\n+              opSummaries.get(0).mParameters.getDescription(fieldNames.getFirst())));\n+\n+          for (ClientIOTaskResult summary : opSummaries) {\n+            String series = summary.mParameters.getDescription(fieldNames.getSecond());\n+            subTitle.add(series + \": \" + DateFormat.getDateTimeInstance()\n+                .format(summary.computeLastEndMs()));\n+          }\n+\n+          LineGraph responseTimeGraph =\n+              new LineGraph(operation + \" - Throughput\", subTitle, \"# Threads\",\n+                  \"Throughput (MB/s)\");\n+\n+          for (ClientIOTaskResult summary : opSummaries) {\n+            String series = summary.mParameters.getDescription(fieldNames.getSecond());\n+            responseTimeGraph.addDataSeries(series, summary.getThroughputData());\n+            responseTimeGraph.setErrors(series, summary.collectErrors());\n+          }\n+\n+          graphs.add(responseTimeGraph);\n+        }\n+      }\n+\n+      return graphs;\n+    }\n+  }\n+\n+  /**\n+   * A result for a single thread count test.\n+   */\n+  public static final class ThreadCountResult {\n+    private long mRecordStartMs;\n+    private long mEndMs;\n+    private long mDurationMs;\n+    private long mIOBytes;\n+    private float mIOMBps;\n+    private List<String> mErrors;\n+\n+    /**\n+     * Creates an instance.\n+     */\n+    public ThreadCountResult() {\n+      // Default constructor required for json deserialization\n+      mErrors = new ArrayList<>();\n+    }\n+\n+    /**\n+     * Merges (updates) a result with this result.\n+     *\n+     * @param result  the result to merge\n+     */\n+    public void merge(ClientIOTaskResult.ThreadCountResult result) {\n+      mRecordStartMs = result.mRecordStartMs;\n+      mEndMs = Math.max(mEndMs, result.mEndMs);\n+      mIOBytes += result.mIOBytes;\n+      mErrors.addAll(result.mErrors);\n+      update();\n+    }\n+\n+    /**\n+     * Update various measurements given the existing measurements.\n+     */\n+    public void update() {\n+      mDurationMs = mEndMs - mRecordStartMs;\n+      mIOMBps = ((float) mIOBytes / mDurationMs) * 1000.0f / Constants.MB;", "originalCommit": "a01a3deea2d159967e51debe9c448a9d5c90dbda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgwNzIyOA==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426807228", "bodyText": "Done.", "author": "gpang", "createdAt": "2020-05-18T18:10:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0NjI0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0NzMzNg==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426047336", "bodyText": "would like this to be ClientOperation (and maybe MasterOperation on the other operation as well)", "author": "bradyoo", "createdAt": "2020-05-15T21:06:55Z", "path": "stress/common/src/main/java/alluxio/stress/client/Operation.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.client;\n+\n+/**\n+ * The operations for the master stress tests.\n+ */\n+public enum Operation {", "originalCommit": "a01a3deea2d159967e51debe9c448a9d5c90dbda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgwOTk3MA==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426809970", "bodyText": "renamed this one.", "author": "gpang", "createdAt": "2020-05-18T18:15:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0NzMzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA1MDg4Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426050883", "bodyText": "StressClientIOBench?", "author": "bradyoo", "createdAt": "2020-05-15T21:16:04Z", "path": "stress/shell/src/main/java/alluxio/stress/cli/client/StressClientIO.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.cli.client;\n+\n+import alluxio.conf.PropertyKey;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.cli.Benchmark;\n+import alluxio.stress.client.ClientIOParameters;\n+import alluxio.stress.client.ClientIOTaskResult;\n+import alluxio.stress.client.Operation;\n+import alluxio.util.CommonUtils;\n+import alluxio.util.FormatUtils;\n+import alluxio.util.executor.ExecutorServiceFactories;\n+\n+import com.beust.jcommander.ParametersDelegate;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Single node client IO stress test.\n+ */\n+public class StressClientIO extends Benchmark<ClientIOTaskResult> {", "originalCommit": "a01a3deea2d159967e51debe9c448a9d5c90dbda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgwOTIyMg==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426809222", "bodyText": "done", "author": "gpang", "createdAt": "2020-05-18T18:14:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA1MDg4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA1MTUxMQ==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426051511", "bodyText": "Would really like these \"warning messages\" to be displayed to the user.", "author": "bradyoo", "createdAt": "2020-05-15T21:17:45Z", "path": "stress/shell/src/main/java/alluxio/stress/cli/client/StressClientIO.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.cli.client;\n+\n+import alluxio.conf.PropertyKey;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.cli.Benchmark;\n+import alluxio.stress.client.ClientIOParameters;\n+import alluxio.stress.client.ClientIOTaskResult;\n+import alluxio.stress.client.Operation;\n+import alluxio.util.CommonUtils;\n+import alluxio.util.FormatUtils;\n+import alluxio.util.executor.ExecutorServiceFactories;\n+\n+import com.beust.jcommander.ParametersDelegate;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Single node client IO stress test.\n+ */\n+public class StressClientIO extends Benchmark<ClientIOTaskResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(StressClientIO.class);\n+\n+  @ParametersDelegate\n+  private ClientIOParameters mParameters = new ClientIOParameters();\n+\n+  private FileSystem[] mCachedFs;\n+\n+  /**\n+   * Creates instance.\n+   */\n+  public StressClientIO() {\n+  }\n+\n+  /**\n+   * @param args command-line arguments\n+   */\n+  public static void main(String[] args) {\n+    mainInternal(args, new StressClientIO());\n+  }\n+\n+  @Override\n+  public void prepare() throws Exception {\n+    if (mBaseParameters.mCluster) {\n+      throw new IllegalArgumentException(this.getClass().getName()\n+          + \" is a single-node client IO stress test, so it cannot be run in cluster mode.\");\n+    }\n+    if (FormatUtils.parseSpaceSize(mParameters.mFileSize) < FormatUtils\n+        .parseSpaceSize(mParameters.mBufferSize)) {\n+      throw new IllegalArgumentException(String\n+          .format(\"File size (%s) must be larger than buffer size (%s)\", mParameters.mFileSize,\n+              mParameters.mBufferSize));\n+    }\n+    if (mParameters.mOperation == Operation.Write) {\n+      // Cannot write repeatedly, so warmup is not possible", "originalCommit": "a01a3deea2d159967e51debe9c448a9d5c90dbda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgwODg1MA==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426808850", "bodyText": "I cannot print it to the output, but I added a log message for it.", "author": "gpang", "createdAt": "2020-05-18T18:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA1MTUxMQ=="}], "type": "inlineReview"}, {"oid": "b7a0bfdb2fd4692cba5ba5814506bedaa0412d5e", "url": "https://github.com/Alluxio/alluxio/commit/b7a0bfdb2fd4692cba5ba5814506bedaa0412d5e", "message": "Cleanup", "committedDate": "2020-05-18T18:42:23Z", "type": "commit"}, {"oid": "1cfbd711b79ea5ec4ae7a0799670bc6c69ab9bac", "url": "https://github.com/Alluxio/alluxio/commit/1cfbd711b79ea5ec4ae7a0799670bc6c69ab9bac", "message": "Improve line graph readability", "committedDate": "2020-05-18T22:15:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzMTI5OQ==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426931299", "bodyText": "The comments on these don't seem very clear to me. What does random reads must call seek() have to do with ReadArray etc... Could use javadoc format on each one as well?", "author": "ZacBlanco", "createdAt": "2020-05-18T22:43:02Z", "path": "stress/common/src/main/java/alluxio/stress/client/ClientIOOperation.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.client;\n+\n+/**\n+ * The operations for the client io stress tests.\n+ */\n+public enum ClientIOOperation {\n+  Write,  // write the files for the read operations\n+\n+  ReadArray,       // random reads must call seek()\n+  ReadByteBuffer,  // random reads must call seek()\n+  ReadFully,       // random reads must call seek()\n+  PosRead,         // random reads uses random offsets to api\n+  PosReadFully,    // random reads uses random offsets to api", "originalCommit": "1cfbd711b79ea5ec4ae7a0799670bc6c69ab9bac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwMDA2Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r427500066", "bodyText": "I added a enum level comment explaining the random reads, and added javadocs for each.", "author": "gpang", "createdAt": "2020-05-19T18:07:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzMTI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzNDAyNw==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426934027", "bodyText": "I'm wondering if rather than having to hard-code the variable name you could write a custom annotation class that you can simply put above the parameters and then use reflection to determine what the string value from the annotation?", "author": "ZacBlanco", "createdAt": "2020-05-18T22:51:05Z", "path": "stress/common/src/main/java/alluxio/stress/client/ClientIOParameters.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.client;\n+\n+import alluxio.stress.Parameters;\n+\n+import com.beust.jcommander.DynamicParameter;\n+import com.beust.jcommander.Parameter;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * This holds all the parameters. All fields are public for easier json ser/de without all the\n+ * getters and setters.\n+ */\n+public final class ClientIOParameters extends Parameters {\n+  private static final String FIELD_READ_RANDOM = \"mReadRandom\";\n+  private static final String FIELD_READ_SAME_FILE = \"mReadSameFile\";\n+\n+  @Parameter(names = {\"--operation\"},\n+      description = \"the operation to perform. Options are [ReadArray, ReadByteBuffer, ReadFully,\"\n+          + \" PosRead, PosReadFully]\",\n+      required = true)\n+  public ClientIOOperation mOperation;\n+\n+  @Parameter(names = {\"--clients\"}, description = \"the number of fs clients to use\")\n+  public int mClients = 1;\n+\n+  @Parameter(names = {\"--threads\"},\n+      description = \"the comma-separated list of thread counts to test. The throughput for each \"\n+          + \"thread tested is benchmarked.\")\n+  public List<Integer> mThreads = Collections.singletonList(1);\n+\n+  @Parameter(names = {\"--base\"},\n+      description = \"The base directory path URI to perform operations in\")\n+  public String mBasePath = \"alluxio://localhost:19998/stress-client-io-base\";\n+\n+  @Parameter(names = {\"--file-size\"},\n+      description = \"The files size for IO operations. (1g, 4g, etc.)\")\n+  public String mFileSize = \"1g\";\n+\n+  @Parameter(names = {\"--buffer-size\"},\n+      description = \"The buffer size for IO operations. (1k, 16k, etc.)\")\n+  public String mBufferSize = \"64k\";\n+\n+  @Parameter(names = {\"--block-size\"},\n+      description = \"The size of the file block. (16k, 64m, etc.)\")\n+  public String mBlockSize = \"64m\";\n+\n+  @Parameter(names = {\"--duration\"},\n+      description = \"The length of time to run the benchmark. (1m, 10m, 60s, 10000ms, etc.)\")\n+  public String mDuration = \"30s\";\n+\n+  @Parameter(names = {\"--warmup\"},\n+      description = \"The length of time to warmup before recording measurements. (1m, 10m, 60s, \"\n+          + \"10000ms, etc.)\")\n+  public String mWarmup = \"30s\";\n+\n+  @Parameter(names = {\"--read-same-file\"},\n+      description = \"If true, read the same file.\")\n+  public boolean mReadSameFile = false;\n+\n+  @Parameter(names = {\"--read-random\"},\n+      description = \"If true, read the file from random offsets. For stream operations, seek() is\"\n+          + \" called to read random offsets.\")\n+  public boolean mReadRandom = false;\n+\n+  @Parameter(names = {\"--write-num-workers\"},\n+      description = \"The number of workers to distribute the files to. The blocks of a written \"\n+          + \"file will be round-robin across these number of workers.\")\n+  public int mWriteNumWorkers = 1;\n+\n+  @DynamicParameter(names = \"--conf\", description = \"HDFS client configuration. Can be repeated.\")\n+  public Map<String, String> mConf = new HashMap<>();\n+\n+  @Override\n+  public String prettyPrintDescriptionField(String fieldName, Object value) {\n+    if (FIELD_READ_RANDOM.equals(fieldName)) {\n+      if ((Boolean) value) {\n+        return \"Random\";\n+      }\n+      return \"Sequential\";\n+    }\n+    if (FIELD_READ_SAME_FILE.equals(fieldName)) {\n+      if ((Boolean) value) {\n+        return \"SameFile\";\n+      }\n+      return \"OwnFile\";\n+    }", "originalCommit": "1cfbd711b79ea5ec4ae7a0799670bc6c69ab9bac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzNTY3MA==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426935670", "bodyText": "i.e.\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.Type)\npublic @interface BooleanDescription {\n  public String trueString();\n  public String falseString();\n}\n\n\n...\n\nClass<?> clazz = object.getClass();\n    Map<String, String> fields = new HashMap<>();\n    for (Field field : clazz.getDeclaredFields()) {\n        field.setAccessible(true);\n        if (field.isAnnotationPresent(BooleanDescription.class)) {\n            return ...\n        }\n    }", "author": "ZacBlanco", "createdAt": "2020-05-18T22:55:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzNDAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwMDM4NQ==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r427500385", "bodyText": "great idea! I implemented this with annotations now. Thanks!", "author": "gpang", "createdAt": "2020-05-19T18:08:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzNDAyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzNjg0Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426936846", "bodyText": "I assume this shouldn't be called on anything but a list of ClientIOTaskResults, but casting like this does not seem very sound", "author": "ZacBlanco", "createdAt": "2020-05-18T22:58:52Z", "path": "stress/common/src/main/java/alluxio/stress/client/ClientIOTaskResult.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.client;\n+\n+import alluxio.Constants;\n+import alluxio.collections.Pair;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.Parameters;\n+import alluxio.stress.Summary;\n+import alluxio.stress.TaskResult;\n+import alluxio.stress.graph.Graph;\n+import alluxio.stress.graph.LineGraph;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.google.common.base.Splitter;\n+\n+import java.io.IOException;\n+import java.text.DateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The task result for the master stress tests.\n+ */\n+public final class ClientIOTaskResult implements TaskResult, Summary {\n+  private Map<Integer, ThreadCountResult> mThreadCountResults;\n+  private BaseParameters mBaseParameters;\n+  private ClientIOParameters mParameters;\n+\n+  /**\n+   * Creates an instance.\n+   */\n+  public ClientIOTaskResult() {\n+    // Default constructor required for json deserialization\n+    mThreadCountResults = new HashMap<>();\n+  }\n+\n+  /**\n+   * @return the base parameters\n+   */\n+  public BaseParameters getBaseParameters() {\n+    return mBaseParameters;\n+  }\n+\n+  /**\n+   * @param baseParameters the base parameters\n+   */\n+  public void setBaseParameters(BaseParameters baseParameters) {\n+    mBaseParameters = baseParameters;\n+  }\n+\n+  /**\n+   * @return the parameters\n+   */\n+  public ClientIOParameters getParameters() {\n+    return mParameters;\n+  }\n+\n+  /**\n+   * @param parameters the parameters\n+   */\n+  public void setParameters(ClientIOParameters parameters) {\n+    mParameters = parameters;\n+  }\n+\n+  /**\n+   * @return the map of thread counts to results\n+   */\n+  public Map<Integer, ThreadCountResult> getThreadCountResults() {\n+    return mThreadCountResults;\n+  }\n+\n+  /**\n+   * @param threadCountResults the map of thread counts to results\n+   */\n+  public void setThreadCountResults(Map<Integer, ThreadCountResult> threadCountResults) {\n+    mThreadCountResults = threadCountResults;\n+  }\n+\n+  /**\n+   * @param threadCount the thread count of the results\n+   * @param threadCountResult the results to add\n+   */\n+  public void addThreadCountResults(int threadCount, ThreadCountResult threadCountResult) {\n+    mThreadCountResults.put(threadCount, threadCountResult);\n+  }\n+\n+  private long computeLastEndMs() {\n+    long endMs = 0;\n+    for (ThreadCountResult result : mThreadCountResults.values()) {\n+      endMs = Math.max(endMs, result.getEndMs());\n+    }\n+    return endMs;\n+  }\n+\n+  private LineGraph.Data getThroughputData() {\n+    LineGraph.Data data = new LineGraph.Data();\n+    for (Map.Entry<Integer, ThreadCountResult> entry : mThreadCountResults.entrySet()) {\n+      data.addData(entry.getKey(), entry.getValue().getIOMBps());\n+    }\n+    return data;\n+  }\n+\n+  private List<String> collectErrors() {\n+    List<String> errors = new ArrayList<>();\n+    for (Map.Entry<Integer, ThreadCountResult> entry : mThreadCountResults.entrySet()) {\n+      // add all the errors for this thread count, with the thread count appended to prefix\n+      errors.addAll(\n+          entry.getValue().getErrors().stream().map(err -> entry.getKey().toString() + \": \" + err)\n+              .collect(Collectors.toList()));\n+    }\n+    return errors;\n+  }\n+\n+  @Override\n+  public TaskResult.Aggregator aggregator() {\n+    return new Aggregator();\n+  }\n+\n+  private static final class Aggregator implements TaskResult.Aggregator {\n+    @Override\n+    public ClientIOTaskResult aggregate(Iterable<TaskResult> results) throws Exception {\n+      Iterator<TaskResult> it = results.iterator();\n+      if (it.hasNext()) {\n+        TaskResult taskResult = it.next();\n+        if (it.hasNext()) {\n+          throw new IOException(\n+              \"ClientIO is a single node test, so multiple task results cannot be aggregated.\");\n+        }\n+        if (!(taskResult instanceof ClientIOTaskResult)) {\n+          throw new IOException(\n+              \"TaskResult is not of type ClientIOTaskResult. class: \" + taskResult.getClass()\n+                  .getName());\n+        }\n+        return (ClientIOTaskResult) taskResult;\n+      }\n+      return new ClientIOTaskResult();\n+    }\n+  }\n+\n+  @Override\n+  public alluxio.stress.GraphGenerator graphGenerator() {\n+    return new GraphGenerator();\n+  }\n+\n+  /**\n+   * The graph generator for this summary.\n+   */\n+  public static final class GraphGenerator extends alluxio.stress.GraphGenerator {\n+    @Override\n+    public List<Graph> generate(List<? extends Summary> results) {\n+      List<Graph> graphs = new ArrayList<>();\n+      // only examine ClientIOSummary\n+      List<ClientIOTaskResult> summaries =\n+          results.stream().map(x -> (ClientIOTaskResult) x).collect(Collectors.toList());", "originalCommit": "1cfbd711b79ea5ec4ae7a0799670bc6c69ab9bac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwNTY4Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r427505686", "bodyText": "Yes. This is expecting to throw a ClassCastException if type is not ClientIOTaskResult.", "author": "gpang", "createdAt": "2020-05-19T18:16:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzNjg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzODg3Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426938872", "bodyText": "hmmmm this Random/Sequential thing again. It sounds like we need to come up with some kind of class/primitive that can take a parameter name and provide some interface to give better human-readable values.", "author": "ZacBlanco", "createdAt": "2020-05-18T23:04:28Z", "path": "stress/common/src/main/java/alluxio/stress/client/ClientIOTaskResult.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.client;\n+\n+import alluxio.Constants;\n+import alluxio.collections.Pair;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.Parameters;\n+import alluxio.stress.Summary;\n+import alluxio.stress.TaskResult;\n+import alluxio.stress.graph.Graph;\n+import alluxio.stress.graph.LineGraph;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.google.common.base.Splitter;\n+\n+import java.io.IOException;\n+import java.text.DateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The task result for the master stress tests.\n+ */\n+public final class ClientIOTaskResult implements TaskResult, Summary {\n+  private Map<Integer, ThreadCountResult> mThreadCountResults;\n+  private BaseParameters mBaseParameters;\n+  private ClientIOParameters mParameters;\n+\n+  /**\n+   * Creates an instance.\n+   */\n+  public ClientIOTaskResult() {\n+    // Default constructor required for json deserialization\n+    mThreadCountResults = new HashMap<>();\n+  }\n+\n+  /**\n+   * @return the base parameters\n+   */\n+  public BaseParameters getBaseParameters() {\n+    return mBaseParameters;\n+  }\n+\n+  /**\n+   * @param baseParameters the base parameters\n+   */\n+  public void setBaseParameters(BaseParameters baseParameters) {\n+    mBaseParameters = baseParameters;\n+  }\n+\n+  /**\n+   * @return the parameters\n+   */\n+  public ClientIOParameters getParameters() {\n+    return mParameters;\n+  }\n+\n+  /**\n+   * @param parameters the parameters\n+   */\n+  public void setParameters(ClientIOParameters parameters) {\n+    mParameters = parameters;\n+  }\n+\n+  /**\n+   * @return the map of thread counts to results\n+   */\n+  public Map<Integer, ThreadCountResult> getThreadCountResults() {\n+    return mThreadCountResults;\n+  }\n+\n+  /**\n+   * @param threadCountResults the map of thread counts to results\n+   */\n+  public void setThreadCountResults(Map<Integer, ThreadCountResult> threadCountResults) {\n+    mThreadCountResults = threadCountResults;\n+  }\n+\n+  /**\n+   * @param threadCount the thread count of the results\n+   * @param threadCountResult the results to add\n+   */\n+  public void addThreadCountResults(int threadCount, ThreadCountResult threadCountResult) {\n+    mThreadCountResults.put(threadCount, threadCountResult);\n+  }\n+\n+  private long computeLastEndMs() {\n+    long endMs = 0;\n+    for (ThreadCountResult result : mThreadCountResults.values()) {\n+      endMs = Math.max(endMs, result.getEndMs());\n+    }\n+    return endMs;\n+  }\n+\n+  private LineGraph.Data getThroughputData() {\n+    LineGraph.Data data = new LineGraph.Data();\n+    for (Map.Entry<Integer, ThreadCountResult> entry : mThreadCountResults.entrySet()) {\n+      data.addData(entry.getKey(), entry.getValue().getIOMBps());\n+    }\n+    return data;\n+  }\n+\n+  private List<String> collectErrors() {\n+    List<String> errors = new ArrayList<>();\n+    for (Map.Entry<Integer, ThreadCountResult> entry : mThreadCountResults.entrySet()) {\n+      // add all the errors for this thread count, with the thread count appended to prefix\n+      errors.addAll(\n+          entry.getValue().getErrors().stream().map(err -> entry.getKey().toString() + \": \" + err)\n+              .collect(Collectors.toList()));\n+    }\n+    return errors;\n+  }\n+\n+  @Override\n+  public TaskResult.Aggregator aggregator() {\n+    return new Aggregator();\n+  }\n+\n+  private static final class Aggregator implements TaskResult.Aggregator {\n+    @Override\n+    public ClientIOTaskResult aggregate(Iterable<TaskResult> results) throws Exception {\n+      Iterator<TaskResult> it = results.iterator();\n+      if (it.hasNext()) {\n+        TaskResult taskResult = it.next();\n+        if (it.hasNext()) {\n+          throw new IOException(\n+              \"ClientIO is a single node test, so multiple task results cannot be aggregated.\");\n+        }\n+        if (!(taskResult instanceof ClientIOTaskResult)) {\n+          throw new IOException(\n+              \"TaskResult is not of type ClientIOTaskResult. class: \" + taskResult.getClass()\n+                  .getName());\n+        }\n+        return (ClientIOTaskResult) taskResult;\n+      }\n+      return new ClientIOTaskResult();\n+    }\n+  }\n+\n+  @Override\n+  public alluxio.stress.GraphGenerator graphGenerator() {\n+    return new GraphGenerator();\n+  }\n+\n+  /**\n+   * The graph generator for this summary.\n+   */\n+  public static final class GraphGenerator extends alluxio.stress.GraphGenerator {\n+    @Override\n+    public List<Graph> generate(List<? extends Summary> results) {\n+      List<Graph> graphs = new ArrayList<>();\n+      // only examine ClientIOSummary\n+      List<ClientIOTaskResult> summaries =\n+          results.stream().map(x -> (ClientIOTaskResult) x).collect(Collectors.toList());\n+\n+      // Iterate over all operations\n+      for (ClientIOOperation operation : ClientIOOperation.values()) {\n+        for (Boolean readRandom : Arrays.asList(false, true)) {\n+          List<ClientIOTaskResult> opSummaries =\n+              summaries.stream().filter(x -> x.mParameters.mOperation == operation)\n+                  .filter(x -> x.mParameters.mReadRandom == readRandom)\n+                  .collect(Collectors.toList());\n+\n+          if (!opSummaries.isEmpty()) {\n+            // first() is the list of common field names, second() is the list of unique field names\n+            Pair<List<String>, List<String>> fieldNames = Parameters.partitionFieldNames(\n+                opSummaries.stream().map(x -> x.mParameters).collect(Collectors.toList()));\n+\n+            // Split up common description into 100 character chunks, for the sub title\n+            List<String> subTitle = new ArrayList<>(Splitter.fixedLength(100).splitToList(\n+                opSummaries.get(0).mParameters.getDescription(fieldNames.getFirst())));\n+\n+            for (ClientIOTaskResult summary : opSummaries) {\n+              String series = summary.mParameters.getDescription(fieldNames.getSecond());\n+              subTitle.add(series + \": \" + DateFormat.getDateTimeInstance()\n+                  .format(summary.computeLastEndMs()));\n+            }\n+\n+            LineGraph responseTimeGraph = new LineGraph(\n+                operation + (readRandom ? \" - Random\" : \" - Sequential\") + \" - Throughput\",", "originalCommit": "1cfbd711b79ea5ec4ae7a0799670bc6c69ab9bac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwMDU5OA==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r427500598", "bodyText": "I updated this", "author": "gpang", "createdAt": "2020-05-19T18:08:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzODg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzOTY1Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426939653", "bodyText": "was this a copy from another class? Because this class is simply the ThreadCountResult type and not bound by any inherited classes or interfaces can this just be removed? Same for the other methods in this class that are empty.", "author": "ZacBlanco", "createdAt": "2020-05-18T23:06:58Z", "path": "stress/common/src/main/java/alluxio/stress/client/ClientIOTaskResult.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.client;\n+\n+import alluxio.Constants;\n+import alluxio.collections.Pair;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.Parameters;\n+import alluxio.stress.Summary;\n+import alluxio.stress.TaskResult;\n+import alluxio.stress.graph.Graph;\n+import alluxio.stress.graph.LineGraph;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.google.common.base.Splitter;\n+\n+import java.io.IOException;\n+import java.text.DateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The task result for the master stress tests.\n+ */\n+public final class ClientIOTaskResult implements TaskResult, Summary {\n+  private Map<Integer, ThreadCountResult> mThreadCountResults;\n+  private BaseParameters mBaseParameters;\n+  private ClientIOParameters mParameters;\n+\n+  /**\n+   * Creates an instance.\n+   */\n+  public ClientIOTaskResult() {\n+    // Default constructor required for json deserialization\n+    mThreadCountResults = new HashMap<>();\n+  }\n+\n+  /**\n+   * @return the base parameters\n+   */\n+  public BaseParameters getBaseParameters() {\n+    return mBaseParameters;\n+  }\n+\n+  /**\n+   * @param baseParameters the base parameters\n+   */\n+  public void setBaseParameters(BaseParameters baseParameters) {\n+    mBaseParameters = baseParameters;\n+  }\n+\n+  /**\n+   * @return the parameters\n+   */\n+  public ClientIOParameters getParameters() {\n+    return mParameters;\n+  }\n+\n+  /**\n+   * @param parameters the parameters\n+   */\n+  public void setParameters(ClientIOParameters parameters) {\n+    mParameters = parameters;\n+  }\n+\n+  /**\n+   * @return the map of thread counts to results\n+   */\n+  public Map<Integer, ThreadCountResult> getThreadCountResults() {\n+    return mThreadCountResults;\n+  }\n+\n+  /**\n+   * @param threadCountResults the map of thread counts to results\n+   */\n+  public void setThreadCountResults(Map<Integer, ThreadCountResult> threadCountResults) {\n+    mThreadCountResults = threadCountResults;\n+  }\n+\n+  /**\n+   * @param threadCount the thread count of the results\n+   * @param threadCountResult the results to add\n+   */\n+  public void addThreadCountResults(int threadCount, ThreadCountResult threadCountResult) {\n+    mThreadCountResults.put(threadCount, threadCountResult);\n+  }\n+\n+  private long computeLastEndMs() {\n+    long endMs = 0;\n+    for (ThreadCountResult result : mThreadCountResults.values()) {\n+      endMs = Math.max(endMs, result.getEndMs());\n+    }\n+    return endMs;\n+  }\n+\n+  private LineGraph.Data getThroughputData() {\n+    LineGraph.Data data = new LineGraph.Data();\n+    for (Map.Entry<Integer, ThreadCountResult> entry : mThreadCountResults.entrySet()) {\n+      data.addData(entry.getKey(), entry.getValue().getIOMBps());\n+    }\n+    return data;\n+  }\n+\n+  private List<String> collectErrors() {\n+    List<String> errors = new ArrayList<>();\n+    for (Map.Entry<Integer, ThreadCountResult> entry : mThreadCountResults.entrySet()) {\n+      // add all the errors for this thread count, with the thread count appended to prefix\n+      errors.addAll(\n+          entry.getValue().getErrors().stream().map(err -> entry.getKey().toString() + \": \" + err)\n+              .collect(Collectors.toList()));\n+    }\n+    return errors;\n+  }\n+\n+  @Override\n+  public TaskResult.Aggregator aggregator() {\n+    return new Aggregator();\n+  }\n+\n+  private static final class Aggregator implements TaskResult.Aggregator {\n+    @Override\n+    public ClientIOTaskResult aggregate(Iterable<TaskResult> results) throws Exception {\n+      Iterator<TaskResult> it = results.iterator();\n+      if (it.hasNext()) {\n+        TaskResult taskResult = it.next();\n+        if (it.hasNext()) {\n+          throw new IOException(\n+              \"ClientIO is a single node test, so multiple task results cannot be aggregated.\");\n+        }\n+        if (!(taskResult instanceof ClientIOTaskResult)) {\n+          throw new IOException(\n+              \"TaskResult is not of type ClientIOTaskResult. class: \" + taskResult.getClass()\n+                  .getName());\n+        }\n+        return (ClientIOTaskResult) taskResult;\n+      }\n+      return new ClientIOTaskResult();\n+    }\n+  }\n+\n+  @Override\n+  public alluxio.stress.GraphGenerator graphGenerator() {\n+    return new GraphGenerator();\n+  }\n+\n+  /**\n+   * The graph generator for this summary.\n+   */\n+  public static final class GraphGenerator extends alluxio.stress.GraphGenerator {\n+    @Override\n+    public List<Graph> generate(List<? extends Summary> results) {\n+      List<Graph> graphs = new ArrayList<>();\n+      // only examine ClientIOSummary\n+      List<ClientIOTaskResult> summaries =\n+          results.stream().map(x -> (ClientIOTaskResult) x).collect(Collectors.toList());\n+\n+      // Iterate over all operations\n+      for (ClientIOOperation operation : ClientIOOperation.values()) {\n+        for (Boolean readRandom : Arrays.asList(false, true)) {\n+          List<ClientIOTaskResult> opSummaries =\n+              summaries.stream().filter(x -> x.mParameters.mOperation == operation)\n+                  .filter(x -> x.mParameters.mReadRandom == readRandom)\n+                  .collect(Collectors.toList());\n+\n+          if (!opSummaries.isEmpty()) {\n+            // first() is the list of common field names, second() is the list of unique field names\n+            Pair<List<String>, List<String>> fieldNames = Parameters.partitionFieldNames(\n+                opSummaries.stream().map(x -> x.mParameters).collect(Collectors.toList()));\n+\n+            // Split up common description into 100 character chunks, for the sub title\n+            List<String> subTitle = new ArrayList<>(Splitter.fixedLength(100).splitToList(\n+                opSummaries.get(0).mParameters.getDescription(fieldNames.getFirst())));\n+\n+            for (ClientIOTaskResult summary : opSummaries) {\n+              String series = summary.mParameters.getDescription(fieldNames.getSecond());\n+              subTitle.add(series + \": \" + DateFormat.getDateTimeInstance()\n+                  .format(summary.computeLastEndMs()));\n+            }\n+\n+            LineGraph responseTimeGraph = new LineGraph(\n+                operation + (readRandom ? \" - Random\" : \" - Sequential\") + \" - Throughput\",\n+                subTitle, \"# Threads\", \"Throughput (MB/s)\");\n+\n+            for (ClientIOTaskResult summary : opSummaries) {\n+              String series = summary.mParameters.getDescription(fieldNames.getSecond());\n+              responseTimeGraph.addDataSeries(series, summary.getThroughputData());\n+              responseTimeGraph.setErrors(series, summary.collectErrors());\n+            }\n+\n+            graphs.add(responseTimeGraph);\n+          }\n+        }\n+      }\n+\n+      return graphs;\n+    }\n+  }\n+\n+  /**\n+   * A result for a single thread count test.\n+   */\n+  public static final class ThreadCountResult {\n+    private long mRecordStartMs;\n+    private long mEndMs;\n+    private long mIOBytes;\n+    private List<String> mErrors;\n+\n+    /**\n+     * Creates an instance.\n+     */\n+    public ThreadCountResult() {\n+      // Default constructor required for json deserialization\n+      mErrors = new ArrayList<>();\n+    }\n+\n+    /**\n+     * Merges (updates) a result with this result.\n+     *\n+     * @param result  the result to merge\n+     */\n+    public void merge(ClientIOTaskResult.ThreadCountResult result) {\n+      mRecordStartMs = Math.min(mRecordStartMs, result.mRecordStartMs);\n+      mEndMs = Math.max(mEndMs, result.mEndMs);\n+      mIOBytes += result.mIOBytes;\n+      mErrors.addAll(result.mErrors);\n+      update();\n+    }\n+\n+    /**\n+     * Update various measurements given the existing measurements.\n+     */\n+    public void update() {\n+    }", "originalCommit": "1cfbd711b79ea5ec4ae7a0799670bc6c69ab9bac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwMDY2NQ==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r427500665", "bodyText": "oops, removed. I think the other ones which are setters need to be there for jackson json processing.", "author": "gpang", "createdAt": "2020-05-19T18:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzOTY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk0MDk3MQ==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r426940971", "bodyText": "Maybe add that this should only be used to performing benchmarking?", "author": "ZacBlanco", "createdAt": "2020-05-18T23:11:26Z", "path": "stress/shell/src/main/java/alluxio/stress/cli/client/ClientIOWritePolicy.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.cli.client;\n+\n+import alluxio.client.block.BlockWorkerInfo;\n+import alluxio.client.block.policy.BlockLocationPolicy;\n+import alluxio.client.block.policy.options.GetWorkerOptions;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Objects;\n+import com.google.common.collect.Lists;\n+\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A write type for restricting the writes to a set number of workers.\n+ */", "originalCommit": "1cfbd711b79ea5ec4ae7a0799670bc6c69ab9bac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwMTc2NQ==", "url": "https://github.com/Alluxio/alluxio/pull/11440#discussion_r427501765", "bodyText": "added", "author": "gpang", "createdAt": "2020-05-19T18:10:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk0MDk3MQ=="}], "type": "inlineReview"}, {"oid": "24022398a7382341acd569749e6cc4cb3ce65594", "url": "https://github.com/Alluxio/alluxio/commit/24022398a7382341acd569749e6cc4cb3ce65594", "message": "Cleanup", "committedDate": "2020-05-19T18:21:36Z", "type": "commit"}]}