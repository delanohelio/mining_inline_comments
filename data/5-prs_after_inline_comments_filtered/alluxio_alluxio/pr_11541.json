{"pr_number": 11541, "pr_title": "Simplify lock list downgrades", "pr_createdAt": "2020-06-10T07:19:46Z", "pr_url": "https://github.com/Alluxio/alluxio/pull/11541", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4NzM1Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11541#discussion_r438387352", "bodyText": "Should there be a precondition that makes sure the mLock is the writeLock() of mRwLock? But, basically, the invariant for RWLockResource is that mLock == mRwLock.readLock() or mLock == mRwLock.writeLock() at all times.", "author": "gpang", "createdAt": "2020-06-10T20:24:39Z", "path": "core/common/src/main/java/alluxio/resource/RWLockResource.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.resource;\n+\n+import alluxio.concurrent.LockMode;\n+\n+import com.google.common.base.Preconditions;\n+\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * The {@link RWLockResource} is an extension of the {@link LockResource} which allows for\n+ * downgrading of locks.\n+ */\n+public class RWLockResource extends LockResource {\n+\n+  private final ReentrantReadWriteLock mRwLock;\n+\n+  /**\n+   * Creates a new instance of RW lock that will lock with the given mode.\n+   *\n+   * @param rwLock the read-write lock backing the resource\n+   * @param mode the initial lock mode if acquiring the lock\n+   * @param acquireLock whether or not to acquire the lock\n+   * @param useTryLock whether or not to use {@link java.util.concurrent.locks.Lock#tryLock} when\n+   *                  acquiring the resource\n+   */\n+  public RWLockResource(ReentrantReadWriteLock rwLock, LockMode mode, boolean acquireLock,\n+      boolean useTryLock) {\n+    super(mode == LockMode.READ ? rwLock.readLock() : rwLock.writeLock(), acquireLock, useTryLock);\n+    mRwLock = rwLock;\n+  }\n+\n+  /**\n+   * Downgrade from a write to a read lock.\n+   *\n+   * @return if a successful downgrade was performed. Returns false if it was read locked\n+   */\n+  public boolean downgrade() {\n+    if (!mRwLock.isWriteLocked()) {\n+      return false;\n+    }\n+    Preconditions.checkState(mRwLock.isWriteLockedByCurrentThread(),", "originalCommit": "a7f108da8946c771c47f0ac96b5744cbe2198de7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQwODg5MA==", "url": "https://github.com/Alluxio/alluxio/pull/11541#discussion_r438408890", "bodyText": "We can check this as an extra precaution, but I don't think it is necessary. That case is already handled by checking mRwLock.isWriteLocked and the subsequent isWriteLockedByCurrentThread\nmLock will only be set to the mRwLock.readLock() if you specify a LockPattern of READ OR if you've already downgraded the lock\n\nin the case when downgrade was previously called the isWriteLocked will return false always.\nin the case where we started with the read, isWriteLocked will always return false.\nIf the arguments specified in the constructor don't lock the lock, then isWriteLocked will return false in both read and write cases.\n\nI see this check as being useful for somewhere down the line when someone decides they want to also change the value of mLock and for some reason change it to something other than mRwLock.readLock() or mRwLock.writeLock(), but I don't think it's necessary for the current code", "author": "ZacBlanco", "createdAt": "2020-06-10T21:07:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4NzM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0NjU5Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11541#discussion_r438446596", "bodyText": "o ok", "author": "gpang", "createdAt": "2020-06-10T22:41:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4NzM1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4ODAzMg==", "url": "https://github.com/Alluxio/alluxio/pull/11541#discussion_r438388032", "bodyText": "How about edges?", "author": "gpang", "createdAt": "2020-06-10T20:26:00Z", "path": "core/server/master/src/main/java/alluxio/master/file/meta/InodeLockList.java", "diffHunk": "@@ -104,17 +104,9 @@\n   void unlockLastEdge();\n \n   /**\n-   * Downgrades the last inode from a write lock to a read lock. The read lock is acquired before\n-   * releasing the write lock.\n-   *\n-   * Example\n-   * Starting from [a, a->b, b*]\n-   *\n-   * downgradeLastInode() results in [a, a->b, b]\n-   *\n-   * If the last inode is not the only write-locked inode, no downgrade occurs.\n+   * Downgrades all inodes in the current lock list to read locks.", "originalCommit": "a7f108da8946c771c47f0ac96b5744cbe2198de7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM5NDI4NQ==", "url": "https://github.com/Alluxio/alluxio/pull/11541#discussion_r438394285", "bodyText": "This should probably just say \"all locks\"", "author": "ZacBlanco", "createdAt": "2020-06-10T20:38:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4ODAzMg=="}], "type": "inlineReview"}, {"oid": "da53e3279c3708be3ddb7189c4ad1619eb95fbf2", "url": "https://github.com/Alluxio/alluxio/commit/da53e3279c3708be3ddb7189c4ad1619eb95fbf2", "message": "Simplify lock list downgrades\n\nBefore this change lock downgrades did NOT work if the end\nof the lock list had more than one write locked inode. This\nhasn't burned us until now because the new syncing changes\nassumed all inodes in the locklist would be downgraded when\ncalling LockedInodePath#downgradeToPattern(LockPattern).\nThis was not the case, which ended up causing a deadlock\nwhen the lock list contained many inodes.\n\nOne common case where this can occur is when a user is\nloading a deeply nested file or directory via some getStatus or\nlistStatus call which syncs metadata and in-turn, will create\nthe paths as it discovers them. In doing so, the lock list is\ninitially populated with write locks. We require them to all\nbe downgraded to read locks for the metadata sync to be\nperformed properly.\n\nThe new syncing design also now only requires downgrades\nto read locks which simplifies a lot of logic which existed\nto support downgrades from WRITE_EDGE to\nWRITE_INODE. These changes removes a good chunk of\nthat complicated code in favor of a simpler approach\nwhich simply performs the lock downgrade for all inodes\nin the list.\n\nA new integration test case was added for this regression.", "committedDate": "2020-06-12T00:03:38Z", "type": "commit"}, {"oid": "96b7a76f8d28cc30e72cc8b1c3de7e7b4a7115b6", "url": "https://github.com/Alluxio/alluxio/commit/96b7a76f8d28cc30e72cc8b1c3de7e7b4a7115b6", "message": "Only downgrade sub-list for composite\n\nThis follows the pattern outlined in the javadoc to never modify the\noriginal list.", "committedDate": "2020-06-12T00:03:43Z", "type": "commit"}, {"oid": "2c2d8a01dde18ddbe6d3606fbbf8fd1cf8dd16a4", "url": "https://github.com/Alluxio/alluxio/commit/2c2d8a01dde18ddbe6d3606fbbf8fd1cf8dd16a4", "message": "Address comments", "committedDate": "2020-06-12T00:03:43Z", "type": "commit"}, {"oid": "2c2d8a01dde18ddbe6d3606fbbf8fd1cf8dd16a4", "url": "https://github.com/Alluxio/alluxio/commit/2c2d8a01dde18ddbe6d3606fbbf8fd1cf8dd16a4", "message": "Address comments", "committedDate": "2020-06-12T00:03:43Z", "type": "forcePushed"}]}