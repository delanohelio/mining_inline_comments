{"pr_number": 12053, "pr_title": "Implement snapshot replication for embedded journal", "pr_createdAt": "2020-08-31T04:34:24Z", "pr_url": "https://github.com/Alluxio/alluxio/pull/12053", "timeline": [{"oid": "4e1bb04276d80bada57ab52ce2fee8ffd7f93c17", "url": "https://github.com/Alluxio/alluxio/commit/4e1bb04276d80bada57ab52ce2fee8ffd7f93c17", "message": "Implement snapshot replication among masters", "committedDate": "2020-08-31T04:23:13Z", "type": "commit"}, {"oid": "db37a181a14bc39554f213a679fa924c5cd06e7d", "url": "https://github.com/Alluxio/alluxio/commit/db37a181a14bc39554f213a679fa924c5cd06e7d", "message": "Close raft client properly", "committedDate": "2020-08-31T18:45:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4MzEyNw==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r480383127", "bodyText": "I'm curious, is this feature snapshot replication, or snapshot transfer?\nAlso, what are the implications of a smaller and larger chunk size?", "author": "gpang", "createdAt": "2020-08-31T20:33:22Z", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1534,6 +1534,13 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.MASTER)\n           .build();\n+  public static final PropertyKey MASTER_EMBEDDED_JOURNAL_SNAPSHOT_REPLICATION_CHUNK_SIZE =\n+      new Builder(Name.MASTER_EMBEDDED_JOURNAL_SNAPSHOT_REPLICATION_CHUNK_SIZE)\n+          .setDefaultValue(\"4MB\")\n+          .setDescription(\"The stream chunk size used by masters to replicate snapshots.\")", "originalCommit": "db37a181a14bc39554f213a679fa924c5cd06e7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5MDEwMA==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r481490100", "bodyText": "This feature replicates snapshots among masters. Is there any confusion on the naming?\nFor chunk size, smaller value has less memory foot print; bigger value takes more memory but have smaller grpc overhead.", "author": "bf8086", "createdAt": "2020-09-01T23:37:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4MzEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4Mzc4MQ==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r480383781", "bodyText": "Can we not use the meta master? Meta master already does master operations, like backup, so snapshot operations may fit?", "author": "gpang", "createdAt": "2020-08-31T20:34:43Z", "path": "core/common/src/main/java/alluxio/grpc/ServiceVersionClientServiceHandler.java", "diffHunk": "@@ -94,6 +94,9 @@ public void getServiceVersion(GetServiceVersionPRequest request,\n       case TABLE_MASTER_CLIENT_SERVICE:\n         serviceVersion = Constants.TABLE_MASTER_CLIENT_SERVICE_VERSION;\n         break;\n+      case RAFT_JOURNAL_SERVICE:", "originalCommit": "db37a181a14bc39554f213a679fa924c5cd06e7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5MDU2OA==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r481490568", "bodyText": "The APIs in this service are for raft journals only. This service is only registered when embedded journal is enabled.", "author": "bf8086", "createdAt": "2020-09-01T23:39:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4Mzc4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3MzU0OQ==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r480473549", "bodyText": "NIT: maybe we name this SnapshotDownloader or something? DownloadObserver seems too generic, and when it shows up in the log, DownloadObserver is not obvious that it is the snapshot related downloader.", "author": "gpang", "createdAt": "2020-08-31T23:35:19Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/DownloadObserver.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.journal.raft;\n+\n+import alluxio.grpc.DownloadSnapshotPRequest;\n+import alluxio.grpc.DownloadSnapshotPResponse;\n+import alluxio.grpc.SnapshotData;\n+import alluxio.grpc.UploadSnapshotPRequest;\n+import alluxio.grpc.UploadSnapshotPResponse;\n+\n+import io.grpc.stub.ClientCallStreamObserver;\n+import io.grpc.stub.ClientResponseObserver;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.ratis.io.MD5Hash;\n+import org.apache.ratis.server.protocol.TermIndex;\n+import org.apache.ratis.server.storage.FileInfo;\n+import org.apache.ratis.statemachine.SnapshotInfo;\n+import org.apache.ratis.statemachine.impl.SimpleStateMachineStorage;\n+import org.apache.ratis.statemachine.impl.SingleFileSnapshotInfo;\n+import org.apache.ratis.util.MD5FileUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+\n+/**\n+ * A stream observer for downloading a snapshot.\n+ *\n+ * @param <S> type of the message to send\n+ * @param <R> type of the message to receive\n+ */\n+public class DownloadObserver<S, R> implements ClientResponseObserver<S, R> {", "originalCommit": "db37a181a14bc39554f213a679fa924c5cd06e7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU0ODYxNQ==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r481548615", "bodyText": "Updated.", "author": "bf8086", "createdAt": "2020-09-02T02:01:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3MzU0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3NDkxNg==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r480474916", "bodyText": "i think there is supposed to be only 2 stars? (elsewhere too)", "author": "gpang", "createdAt": "2020-08-31T23:39:59Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/DownloadObserver.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.journal.raft;\n+\n+import alluxio.grpc.DownloadSnapshotPRequest;\n+import alluxio.grpc.DownloadSnapshotPResponse;\n+import alluxio.grpc.SnapshotData;\n+import alluxio.grpc.UploadSnapshotPRequest;\n+import alluxio.grpc.UploadSnapshotPResponse;\n+\n+import io.grpc.stub.ClientCallStreamObserver;\n+import io.grpc.stub.ClientResponseObserver;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.ratis.io.MD5Hash;\n+import org.apache.ratis.server.protocol.TermIndex;\n+import org.apache.ratis.server.storage.FileInfo;\n+import org.apache.ratis.statemachine.SnapshotInfo;\n+import org.apache.ratis.statemachine.impl.SimpleStateMachineStorage;\n+import org.apache.ratis.statemachine.impl.SingleFileSnapshotInfo;\n+import org.apache.ratis.util.MD5FileUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+\n+/**\n+ * A stream observer for downloading a snapshot.\n+ *\n+ * @param <S> type of the message to send\n+ * @param <R> type of the message to receive\n+ */\n+public class DownloadObserver<S, R> implements ClientResponseObserver<S, R> {\n+  private static final Logger LOG = LoggerFactory.getLogger(DownloadObserver.class);\n+\n+  private final SimpleStateMachineStorage mStorage;\n+  private final CompletableFuture<TermIndex> mFuture = new CompletableFuture<>();\n+  private final Function<Long, S> mMessageBuilder;\n+  private final Function<R, SnapshotData> mDataGetter;\n+  private TermIndex mTermIndex;\n+  private File mTempFile;\n+  private FileOutputStream mOutputStream;\n+  private long mBytesWritten = 0;\n+  private StreamObserver<S> mStream;\n+  private SnapshotInfo mSnapshotToInstall;\n+\n+  /***", "originalCommit": "db37a181a14bc39554f213a679fa924c5cd06e7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU0ODc1Mw==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r481548753", "bodyText": "Fixed.", "author": "bf8086", "createdAt": "2020-09-02T02:01:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3NDkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3NTM3OA==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r480475378", "bodyText": "What are the implications/differences between the downloader for the leader and follower?", "author": "gpang", "createdAt": "2020-08-31T23:41:37Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/DownloadObserver.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.journal.raft;\n+\n+import alluxio.grpc.DownloadSnapshotPRequest;\n+import alluxio.grpc.DownloadSnapshotPResponse;\n+import alluxio.grpc.SnapshotData;\n+import alluxio.grpc.UploadSnapshotPRequest;\n+import alluxio.grpc.UploadSnapshotPResponse;\n+\n+import io.grpc.stub.ClientCallStreamObserver;\n+import io.grpc.stub.ClientResponseObserver;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.ratis.io.MD5Hash;\n+import org.apache.ratis.server.protocol.TermIndex;\n+import org.apache.ratis.server.storage.FileInfo;\n+import org.apache.ratis.statemachine.SnapshotInfo;\n+import org.apache.ratis.statemachine.impl.SimpleStateMachineStorage;\n+import org.apache.ratis.statemachine.impl.SingleFileSnapshotInfo;\n+import org.apache.ratis.util.MD5FileUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+\n+/**\n+ * A stream observer for downloading a snapshot.\n+ *\n+ * @param <S> type of the message to send\n+ * @param <R> type of the message to receive\n+ */\n+public class DownloadObserver<S, R> implements ClientResponseObserver<S, R> {\n+  private static final Logger LOG = LoggerFactory.getLogger(DownloadObserver.class);\n+\n+  private final SimpleStateMachineStorage mStorage;\n+  private final CompletableFuture<TermIndex> mFuture = new CompletableFuture<>();\n+  private final Function<Long, S> mMessageBuilder;\n+  private final Function<R, SnapshotData> mDataGetter;\n+  private TermIndex mTermIndex;\n+  private File mTempFile;\n+  private FileOutputStream mOutputStream;\n+  private long mBytesWritten = 0;\n+  private StreamObserver<S> mStream;\n+  private SnapshotInfo mSnapshotToInstall;\n+\n+  /***\n+   * Builds a stream for leader to download a snapshot.", "originalCommit": "db37a181a14bc39554f213a679fa924c5cd06e7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5NTgwNA==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r481495804", "bodyText": "Because the RPC service is only up on the leader/primary master, we provide two different RPC calls for handling snapshot download from leader and download from follower.\nThe leader version uses the message types defined for the RPC call uploadSnapshot. This is used for leader to download a snapshot from follower.\nThe follower version uses the message types defined for the RPC call downloadSnapshot. This is used for follower to download a snapshot from leader.", "author": "bf8086", "createdAt": "2020-09-01T23:57:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3NTM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3NjAzNA==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r480476034", "bodyText": "add file name to message?", "author": "gpang", "createdAt": "2020-08-31T23:43:57Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/DownloadObserver.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.journal.raft;\n+\n+import alluxio.grpc.DownloadSnapshotPRequest;\n+import alluxio.grpc.DownloadSnapshotPResponse;\n+import alluxio.grpc.SnapshotData;\n+import alluxio.grpc.UploadSnapshotPRequest;\n+import alluxio.grpc.UploadSnapshotPResponse;\n+\n+import io.grpc.stub.ClientCallStreamObserver;\n+import io.grpc.stub.ClientResponseObserver;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.ratis.io.MD5Hash;\n+import org.apache.ratis.server.protocol.TermIndex;\n+import org.apache.ratis.server.storage.FileInfo;\n+import org.apache.ratis.statemachine.SnapshotInfo;\n+import org.apache.ratis.statemachine.impl.SimpleStateMachineStorage;\n+import org.apache.ratis.statemachine.impl.SingleFileSnapshotInfo;\n+import org.apache.ratis.util.MD5FileUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+\n+/**\n+ * A stream observer for downloading a snapshot.\n+ *\n+ * @param <S> type of the message to send\n+ * @param <R> type of the message to receive\n+ */\n+public class DownloadObserver<S, R> implements ClientResponseObserver<S, R> {\n+  private static final Logger LOG = LoggerFactory.getLogger(DownloadObserver.class);\n+\n+  private final SimpleStateMachineStorage mStorage;\n+  private final CompletableFuture<TermIndex> mFuture = new CompletableFuture<>();\n+  private final Function<Long, S> mMessageBuilder;\n+  private final Function<R, SnapshotData> mDataGetter;\n+  private TermIndex mTermIndex;\n+  private File mTempFile;\n+  private FileOutputStream mOutputStream;\n+  private long mBytesWritten = 0;\n+  private StreamObserver<S> mStream;\n+  private SnapshotInfo mSnapshotToInstall;\n+\n+  /***\n+   * Builds a stream for leader to download a snapshot.\n+   *\n+   * @param storage the snapshot storage\n+   * @param stream the response stream\n+   * @return the download stream for leader\n+   */\n+  public static DownloadObserver<UploadSnapshotPResponse, UploadSnapshotPRequest> forLeader(\n+      SimpleStateMachineStorage storage, StreamObserver<UploadSnapshotPResponse> stream) {\n+    return new DownloadObserver<>(storage,\n+        offset -> UploadSnapshotPResponse.newBuilder().setOffsetReceived(offset).build(),\n+        UploadSnapshotPRequest::getData, stream);\n+  }\n+\n+  /***\n+   * Builds a stream for follower to download a snapshot.\n+   *\n+   * @param storage the snapshot storage\n+   * @return the download stream for follower\n+   */\n+  public static DownloadObserver<DownloadSnapshotPRequest, DownloadSnapshotPResponse>\n+      forFollower(SimpleStateMachineStorage storage) {\n+    return new DownloadObserver<>(storage,\n+        offset -> DownloadSnapshotPRequest.newBuilder().setOffsetReceived(offset).build(),\n+        DownloadSnapshotPResponse::getData, null);\n+  }\n+\n+  private DownloadObserver(SimpleStateMachineStorage storage, Function<Long, S> messageBuilder,\n+      Function<R, SnapshotData> dataGetter, StreamObserver<S> stream) {\n+    mStorage = storage;\n+    mMessageBuilder = messageBuilder;\n+    mDataGetter = dataGetter;\n+    mStream = stream;\n+  }\n+\n+  @Override\n+  public void onNext(R response) {\n+    try {\n+      onNextInternal(response);\n+    } catch (Exception e) {\n+      mStream.onError(e);\n+      mFuture.completeExceptionally(e);\n+      cleanup();\n+    }\n+  }\n+\n+  private void cleanup() {\n+    if (mOutputStream != null) {\n+      try {\n+        mOutputStream.close();\n+      } catch (IOException ioException) {\n+        LOG.error(\"Error closing snapshot file\", ioException);", "originalCommit": "db37a181a14bc39554f213a679fa924c5cd06e7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU0OTAzMg==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r481549032", "bodyText": "Done.", "author": "bf8086", "createdAt": "2020-09-02T02:02:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3NjAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3NzAxOA==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r480477018", "bodyText": "can you add a comment on what a term index is?", "author": "gpang", "createdAt": "2020-08-31T23:47:12Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/DownloadObserver.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.journal.raft;\n+\n+import alluxio.grpc.DownloadSnapshotPRequest;\n+import alluxio.grpc.DownloadSnapshotPResponse;\n+import alluxio.grpc.SnapshotData;\n+import alluxio.grpc.UploadSnapshotPRequest;\n+import alluxio.grpc.UploadSnapshotPResponse;\n+\n+import io.grpc.stub.ClientCallStreamObserver;\n+import io.grpc.stub.ClientResponseObserver;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.ratis.io.MD5Hash;\n+import org.apache.ratis.server.protocol.TermIndex;\n+import org.apache.ratis.server.storage.FileInfo;\n+import org.apache.ratis.statemachine.SnapshotInfo;\n+import org.apache.ratis.statemachine.impl.SimpleStateMachineStorage;\n+import org.apache.ratis.statemachine.impl.SingleFileSnapshotInfo;\n+import org.apache.ratis.util.MD5FileUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+\n+/**\n+ * A stream observer for downloading a snapshot.\n+ *\n+ * @param <S> type of the message to send\n+ * @param <R> type of the message to receive\n+ */\n+public class DownloadObserver<S, R> implements ClientResponseObserver<S, R> {\n+  private static final Logger LOG = LoggerFactory.getLogger(DownloadObserver.class);\n+\n+  private final SimpleStateMachineStorage mStorage;\n+  private final CompletableFuture<TermIndex> mFuture = new CompletableFuture<>();\n+  private final Function<Long, S> mMessageBuilder;\n+  private final Function<R, SnapshotData> mDataGetter;\n+  private TermIndex mTermIndex;", "originalCommit": "db37a181a14bc39554f213a679fa924c5cd06e7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU0OTE5Ng==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r481549196", "bodyText": "Done.", "author": "bf8086", "createdAt": "2020-09-02T02:02:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3NzAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ4MzIyMQ==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r480483221", "bodyText": "Is there a way to include where it is downloading from?", "author": "gpang", "createdAt": "2020-09-01T00:07:47Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/DownloadObserver.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.journal.raft;\n+\n+import alluxio.grpc.DownloadSnapshotPRequest;\n+import alluxio.grpc.DownloadSnapshotPResponse;\n+import alluxio.grpc.SnapshotData;\n+import alluxio.grpc.UploadSnapshotPRequest;\n+import alluxio.grpc.UploadSnapshotPResponse;\n+\n+import io.grpc.stub.ClientCallStreamObserver;\n+import io.grpc.stub.ClientResponseObserver;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.ratis.io.MD5Hash;\n+import org.apache.ratis.server.protocol.TermIndex;\n+import org.apache.ratis.server.storage.FileInfo;\n+import org.apache.ratis.statemachine.SnapshotInfo;\n+import org.apache.ratis.statemachine.impl.SimpleStateMachineStorage;\n+import org.apache.ratis.statemachine.impl.SingleFileSnapshotInfo;\n+import org.apache.ratis.util.MD5FileUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+\n+/**\n+ * A stream observer for downloading a snapshot.\n+ *\n+ * @param <S> type of the message to send\n+ * @param <R> type of the message to receive\n+ */\n+public class DownloadObserver<S, R> implements ClientResponseObserver<S, R> {\n+  private static final Logger LOG = LoggerFactory.getLogger(DownloadObserver.class);\n+\n+  private final SimpleStateMachineStorage mStorage;\n+  private final CompletableFuture<TermIndex> mFuture = new CompletableFuture<>();\n+  private final Function<Long, S> mMessageBuilder;\n+  private final Function<R, SnapshotData> mDataGetter;\n+  private TermIndex mTermIndex;\n+  private File mTempFile;\n+  private FileOutputStream mOutputStream;\n+  private long mBytesWritten = 0;\n+  private StreamObserver<S> mStream;\n+  private SnapshotInfo mSnapshotToInstall;\n+\n+  /***\n+   * Builds a stream for leader to download a snapshot.\n+   *\n+   * @param storage the snapshot storage\n+   * @param stream the response stream\n+   * @return the download stream for leader\n+   */\n+  public static DownloadObserver<UploadSnapshotPResponse, UploadSnapshotPRequest> forLeader(\n+      SimpleStateMachineStorage storage, StreamObserver<UploadSnapshotPResponse> stream) {\n+    return new DownloadObserver<>(storage,\n+        offset -> UploadSnapshotPResponse.newBuilder().setOffsetReceived(offset).build(),\n+        UploadSnapshotPRequest::getData, stream);\n+  }\n+\n+  /***\n+   * Builds a stream for follower to download a snapshot.\n+   *\n+   * @param storage the snapshot storage\n+   * @return the download stream for follower\n+   */\n+  public static DownloadObserver<DownloadSnapshotPRequest, DownloadSnapshotPResponse>\n+      forFollower(SimpleStateMachineStorage storage) {\n+    return new DownloadObserver<>(storage,\n+        offset -> DownloadSnapshotPRequest.newBuilder().setOffsetReceived(offset).build(),\n+        DownloadSnapshotPResponse::getData, null);\n+  }\n+\n+  private DownloadObserver(SimpleStateMachineStorage storage, Function<Long, S> messageBuilder,\n+      Function<R, SnapshotData> dataGetter, StreamObserver<S> stream) {\n+    mStorage = storage;\n+    mMessageBuilder = messageBuilder;\n+    mDataGetter = dataGetter;\n+    mStream = stream;\n+  }\n+\n+  @Override\n+  public void onNext(R response) {\n+    try {\n+      onNextInternal(response);\n+    } catch (Exception e) {\n+      mStream.onError(e);\n+      mFuture.completeExceptionally(e);\n+      cleanup();\n+    }\n+  }\n+\n+  private void cleanup() {\n+    if (mOutputStream != null) {\n+      try {\n+        mOutputStream.close();\n+      } catch (IOException ioException) {\n+        LOG.error(\"Error closing snapshot file\", ioException);\n+      }\n+    }\n+    if (mTempFile != null && !mTempFile.delete()) {\n+      LOG.error(\"Error deleting snapshot file {}\", mTempFile.getPath());\n+    }\n+  }\n+\n+  private void onNextInternal(R response) throws IOException {\n+    TermIndex termIndex = TermIndex.newTermIndex(\n+        mDataGetter.apply(response).getSnapshotTerm(),\n+        mDataGetter.apply(response).getSnapshotIndex());\n+    if (mTermIndex == null) {\n+      // new start, check if there is already a download\n+      LOG.info(\"Downloading new snapshot {}\", termIndex);", "originalCommit": "db37a181a14bc39554f213a679fa924c5cd06e7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU0OTMyOQ==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r481549329", "bodyText": "Done.", "author": "bf8086", "createdAt": "2020-09-02T02:02:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ4MzIyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ4ODc5NA==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r480488794", "bodyText": "include the snapshot id/file?", "author": "gpang", "createdAt": "2020-09-01T00:16:28Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/DownloadObserver.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.journal.raft;\n+\n+import alluxio.grpc.DownloadSnapshotPRequest;\n+import alluxio.grpc.DownloadSnapshotPResponse;\n+import alluxio.grpc.SnapshotData;\n+import alluxio.grpc.UploadSnapshotPRequest;\n+import alluxio.grpc.UploadSnapshotPResponse;\n+\n+import io.grpc.stub.ClientCallStreamObserver;\n+import io.grpc.stub.ClientResponseObserver;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.ratis.io.MD5Hash;\n+import org.apache.ratis.server.protocol.TermIndex;\n+import org.apache.ratis.server.storage.FileInfo;\n+import org.apache.ratis.statemachine.SnapshotInfo;\n+import org.apache.ratis.statemachine.impl.SimpleStateMachineStorage;\n+import org.apache.ratis.statemachine.impl.SingleFileSnapshotInfo;\n+import org.apache.ratis.util.MD5FileUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+\n+/**\n+ * A stream observer for downloading a snapshot.\n+ *\n+ * @param <S> type of the message to send\n+ * @param <R> type of the message to receive\n+ */\n+public class DownloadObserver<S, R> implements ClientResponseObserver<S, R> {\n+  private static final Logger LOG = LoggerFactory.getLogger(DownloadObserver.class);\n+\n+  private final SimpleStateMachineStorage mStorage;\n+  private final CompletableFuture<TermIndex> mFuture = new CompletableFuture<>();\n+  private final Function<Long, S> mMessageBuilder;\n+  private final Function<R, SnapshotData> mDataGetter;\n+  private TermIndex mTermIndex;\n+  private File mTempFile;\n+  private FileOutputStream mOutputStream;\n+  private long mBytesWritten = 0;\n+  private StreamObserver<S> mStream;\n+  private SnapshotInfo mSnapshotToInstall;\n+\n+  /***\n+   * Builds a stream for leader to download a snapshot.\n+   *\n+   * @param storage the snapshot storage\n+   * @param stream the response stream\n+   * @return the download stream for leader\n+   */\n+  public static DownloadObserver<UploadSnapshotPResponse, UploadSnapshotPRequest> forLeader(\n+      SimpleStateMachineStorage storage, StreamObserver<UploadSnapshotPResponse> stream) {\n+    return new DownloadObserver<>(storage,\n+        offset -> UploadSnapshotPResponse.newBuilder().setOffsetReceived(offset).build(),\n+        UploadSnapshotPRequest::getData, stream);\n+  }\n+\n+  /***\n+   * Builds a stream for follower to download a snapshot.\n+   *\n+   * @param storage the snapshot storage\n+   * @return the download stream for follower\n+   */\n+  public static DownloadObserver<DownloadSnapshotPRequest, DownloadSnapshotPResponse>\n+      forFollower(SimpleStateMachineStorage storage) {\n+    return new DownloadObserver<>(storage,\n+        offset -> DownloadSnapshotPRequest.newBuilder().setOffsetReceived(offset).build(),\n+        DownloadSnapshotPResponse::getData, null);\n+  }\n+\n+  private DownloadObserver(SimpleStateMachineStorage storage, Function<Long, S> messageBuilder,\n+      Function<R, SnapshotData> dataGetter, StreamObserver<S> stream) {\n+    mStorage = storage;\n+    mMessageBuilder = messageBuilder;\n+    mDataGetter = dataGetter;\n+    mStream = stream;\n+  }\n+\n+  @Override\n+  public void onNext(R response) {\n+    try {\n+      onNextInternal(response);\n+    } catch (Exception e) {\n+      mStream.onError(e);\n+      mFuture.completeExceptionally(e);\n+      cleanup();\n+    }\n+  }\n+\n+  private void cleanup() {\n+    if (mOutputStream != null) {\n+      try {\n+        mOutputStream.close();\n+      } catch (IOException ioException) {\n+        LOG.error(\"Error closing snapshot file\", ioException);\n+      }\n+    }\n+    if (mTempFile != null && !mTempFile.delete()) {\n+      LOG.error(\"Error deleting snapshot file {}\", mTempFile.getPath());\n+    }\n+  }\n+\n+  private void onNextInternal(R response) throws IOException {\n+    TermIndex termIndex = TermIndex.newTermIndex(\n+        mDataGetter.apply(response).getSnapshotTerm(),\n+        mDataGetter.apply(response).getSnapshotIndex());\n+    if (mTermIndex == null) {\n+      // new start, check if there is already a download\n+      LOG.info(\"Downloading new snapshot {}\", termIndex);\n+      mTermIndex = termIndex;\n+      // start a new file\n+      mTempFile = RaftJournalUtils.createTempSnapshotFile(mStorage);\n+\n+      mTempFile.deleteOnExit();\n+      mStream.onNext(mMessageBuilder.apply(0L));\n+    } else {\n+      if (!termIndex.equals(mTermIndex)) {\n+        throw new IOException(String.format(\n+            \"Mismatched term index when downloading the snapshot. expected: %s actual: %s\",\n+            mTermIndex, termIndex));\n+      }\n+      if (!mDataGetter.apply(response).hasChunk()) {\n+        throw new IOException(String.format(\"A chunk is missing from the response %s\", response));", "originalCommit": "db37a181a14bc39554f213a679fa924c5cd06e7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU0OTg4Mw==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r481549883", "bodyText": "Added local file path. Snapshot id is included in the response.", "author": "bf8086", "createdAt": "2020-09-02T02:03:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ4ODc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ5MzQzNA==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r480493434", "bodyText": "I'm not sure what this message means. Could you explain it or add more details in the message?", "author": "gpang", "createdAt": "2020-09-01T00:23:32Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -203,6 +215,16 @@ public void notifyNotLeader(Collection<TransactionContext> pendingEntries) {\n     mJournalSystem.notifyLeadershipStateChanged(false);\n   }\n \n+  @Override\n+  public CompletableFuture<TermIndex> notifyInstallSnapshotFromLeader(\n+      RaftProtos.RoleInfoProto roleInfoProto, TermIndex firstTermIndexInLog) {\n+    if (roleInfoProto.getRole() != RaftProtos.RaftPeerRole.FOLLOWER) {\n+      return RaftJournalUtils.completeExceptionally(\n+          new IllegalStateException(\"Received snapshot as a non-follower\"));", "originalCommit": "db37a181a14bc39554f213a679fa924c5cd06e7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU1MDAwMg==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r481550002", "bodyText": "Updated.", "author": "bf8086", "createdAt": "2020-09-02T02:03:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ5MzQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ5ODMxOQ==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r480498319", "bodyText": "Maybe we should rename this to SnapshotUploader, since UploadObserver seems too generic.", "author": "gpang", "createdAt": "2020-09-01T00:30:58Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/UploadObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.journal.raft;\n+\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.status.InvalidArgumentException;\n+import alluxio.grpc.DownloadSnapshotPRequest;\n+import alluxio.grpc.DownloadSnapshotPResponse;\n+import alluxio.grpc.SnapshotData;\n+import alluxio.grpc.UploadSnapshotPRequest;\n+import alluxio.grpc.UploadSnapshotPResponse;\n+\n+import com.google.protobuf.UnsafeByteOperations;\n+import io.grpc.stub.ClientCallStreamObserver;\n+import io.grpc.stub.ClientResponseObserver;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.ratis.statemachine.SnapshotInfo;\n+import org.apache.ratis.statemachine.impl.SimpleStateMachineStorage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.function.Function;\n+\n+/**\n+ * A stream observer for uploading a snapshot.\n+ *\n+ * @param <S> the message type to send\n+ * @param <R> the message type to receive\n+ */\n+public class UploadObserver<S, R>", "originalCommit": "db37a181a14bc39554f213a679fa924c5cd06e7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU1MDA0OQ==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r481550049", "bodyText": "Renamed.", "author": "bf8086", "createdAt": "2020-09-02T02:03:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ5ODMxOQ=="}], "type": "inlineReview"}, {"oid": "e76369e3378283fb5353c39c3147651900defd3a", "url": "https://github.com/Alluxio/alluxio/commit/e76369e3378283fb5353c39c3147651900defd3a", "message": "Address comments", "committedDate": "2020-09-02T02:00:17Z", "type": "commit"}, {"oid": "2c8ee7bc2e1d7fbc9c33fbcf9d827889c5a8928e", "url": "https://github.com/Alluxio/alluxio/commit/2c8ee7bc2e1d7fbc9c33fbcf9d827889c5a8928e", "message": "Fix typo", "committedDate": "2020-09-02T02:03:55Z", "type": "commit"}, {"oid": "93ef609e883d295168cf2dc69e167f86c2cddebf", "url": "https://github.com/Alluxio/alluxio/commit/93ef609e883d295168cf2dc69e167f86c2cddebf", "message": "Fix checkstyles", "committedDate": "2020-09-02T18:30:22Z", "type": "commit"}, {"oid": "1e13bc8f7f126312a6aae6d23dfdc3e1e5b93d1e", "url": "https://github.com/Alluxio/alluxio/commit/1e13bc8f7f126312a6aae6d23dfdc3e1e5b93d1e", "message": "Fix tests", "committedDate": "2020-09-04T06:00:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA3Njk0Nw==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r485076947", "bodyText": "I am still a little bit confused about the differences between the leader and the follower.\nOnly the leader has the RPC service, right? There are 2 types of transfers:\n\n\nleader receives snapshot from follower: What is the RPC data flow here? Since the leader only has the RPC service, how does the follower know when to upload to leader? Does the follower just proactively try to transfer to leader whenever it creates a new snapshot?\n\n\nfollower receives snapshot from leader: What is the RPC data flow here? When would the follower want to download a snapshot from the leader?", "author": "gpang", "createdAt": "2020-09-08T17:16:46Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/SnapshotDownloader.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.journal.raft;\n+\n+import alluxio.grpc.DownloadSnapshotPRequest;\n+import alluxio.grpc.DownloadSnapshotPResponse;\n+import alluxio.grpc.SnapshotData;\n+import alluxio.grpc.UploadSnapshotPRequest;\n+import alluxio.grpc.UploadSnapshotPResponse;\n+\n+import io.grpc.stub.ClientCallStreamObserver;\n+import io.grpc.stub.ClientResponseObserver;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.ratis.io.MD5Hash;\n+import org.apache.ratis.server.protocol.TermIndex;\n+import org.apache.ratis.server.storage.FileInfo;\n+import org.apache.ratis.statemachine.SnapshotInfo;\n+import org.apache.ratis.statemachine.impl.SimpleStateMachineStorage;\n+import org.apache.ratis.statemachine.impl.SingleFileSnapshotInfo;\n+import org.apache.ratis.util.MD5FileUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+\n+/**\n+ * A stream observer for downloading a snapshot.", "originalCommit": "1e13bc8f7f126312a6aae6d23dfdc3e1e5b93d1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIzNDI1MA==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r485234250", "bodyText": "Only the leader has the RPC service, right? There are 2 types of transfers:\n\nYes\n\nleader receives snapshot from follower: What is the RPC data flow here?  Since the leader only has the RPC service, how does the follower know when to upload to leader? Does the follower just proactively try to transfer to leader whenever it creates a new snapshot?\n\nHere is the workflow:\n\nratis calls leader state machine to take a snapshot\nleader get snapshot metadata from follower\nleader pick one of the the follower and send a request for copying the snapshot\nfollower receives the request and calls the leader raft journal service to upload the snapshot\nafter the upload completes, leader remembers the temporary snapshot location and index.\nratis calls the leader state machine again to take a snapshot\nleader moves the temporary snapshot to the journal snapshot folder and gives ratis the snapshot index.\n\n\nfollower receives snapshot from leader: What is the RPC data flow here? When would the follower want to download a snapshot from the leader?\n\n\nratis leader found one of the follower needs a snapshot because it missed journal entries from a long time ago.\nratis leader notifies ratis follower to install snapshot from leader, the follower calls the alluxio state machine to fulfill this request\nthe follower state machine calls the snapshot manager which calls the raft journal service from leader to download a snapshot.\nafter the downloads completes, follower moves the file to snapshot directory and gives ratis the snapshot index.", "author": "bf8086", "createdAt": "2020-09-08T22:41:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA3Njk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4MTc3MQ==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r485081771", "bodyText": "Do both leaders and followers run this manager?", "author": "gpang", "createdAt": "2020-09-08T17:25:13Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/SnapshotReplicationManager.java", "diffHunk": "@@ -0,0 +1,503 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.journal.raft;\n+\n+import alluxio.ClientContext;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.status.AbortedException;\n+import alluxio.exception.status.AlluxioStatusException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.exception.status.UnavailableException;\n+import alluxio.grpc.DownloadSnapshotPRequest;\n+import alluxio.grpc.DownloadSnapshotPResponse;\n+import alluxio.grpc.GetSnapshotInfoRequest;\n+import alluxio.grpc.GetSnapshotInfoResponse;\n+import alluxio.grpc.GetSnapshotRequest;\n+import alluxio.grpc.JournalQueryRequest;\n+import alluxio.grpc.JournalQueryResponse;\n+import alluxio.grpc.QuorumServerState;\n+import alluxio.grpc.SnapshotData;\n+import alluxio.grpc.SnapshotMetadata;\n+import alluxio.grpc.UploadSnapshotPRequest;\n+import alluxio.grpc.UploadSnapshotPResponse;\n+import alluxio.master.MasterClientContext;\n+import alluxio.security.authentication.ClientIpAddressInjector;\n+import alluxio.util.CommonUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageLite;\n+import io.grpc.Status;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.ratis.protocol.Message;\n+import org.apache.ratis.protocol.RaftClientReply;\n+import org.apache.ratis.protocol.RaftPeerId;\n+import org.apache.ratis.server.protocol.TermIndex;\n+import org.apache.ratis.server.raftlog.RaftLog;\n+import org.apache.ratis.server.storage.FileInfo;\n+import org.apache.ratis.statemachine.SnapshotInfo;\n+import org.apache.ratis.statemachine.impl.SimpleStateMachineStorage;\n+import org.apache.ratis.statemachine.impl.SingleFileSnapshotInfo;\n+import org.apache.ratis.thirdparty.com.google.protobuf.UnsafeByteOperations;\n+import org.apache.ratis.util.MD5FileUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class for managing snapshot replication among masters.", "originalCommit": "1e13bc8f7f126312a6aae6d23dfdc3e1e5b93d1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5ODA2MA==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r485198060", "bodyText": "yes.", "author": "bf8086", "createdAt": "2020-09-08T21:10:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4MTc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4NDc0OQ==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r485084749", "bodyText": "What is this DOWNLOADED state for? What happens in that state? The description sounds like a very short/temporary state?", "author": "gpang", "createdAt": "2020-09-08T17:30:27Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/SnapshotReplicationManager.java", "diffHunk": "@@ -0,0 +1,503 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.journal.raft;\n+\n+import alluxio.ClientContext;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.status.AbortedException;\n+import alluxio.exception.status.AlluxioStatusException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.exception.status.UnavailableException;\n+import alluxio.grpc.DownloadSnapshotPRequest;\n+import alluxio.grpc.DownloadSnapshotPResponse;\n+import alluxio.grpc.GetSnapshotInfoRequest;\n+import alluxio.grpc.GetSnapshotInfoResponse;\n+import alluxio.grpc.GetSnapshotRequest;\n+import alluxio.grpc.JournalQueryRequest;\n+import alluxio.grpc.JournalQueryResponse;\n+import alluxio.grpc.QuorumServerState;\n+import alluxio.grpc.SnapshotData;\n+import alluxio.grpc.SnapshotMetadata;\n+import alluxio.grpc.UploadSnapshotPRequest;\n+import alluxio.grpc.UploadSnapshotPResponse;\n+import alluxio.master.MasterClientContext;\n+import alluxio.security.authentication.ClientIpAddressInjector;\n+import alluxio.util.CommonUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageLite;\n+import io.grpc.Status;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.ratis.protocol.Message;\n+import org.apache.ratis.protocol.RaftClientReply;\n+import org.apache.ratis.protocol.RaftPeerId;\n+import org.apache.ratis.server.protocol.TermIndex;\n+import org.apache.ratis.server.raftlog.RaftLog;\n+import org.apache.ratis.server.storage.FileInfo;\n+import org.apache.ratis.statemachine.SnapshotInfo;\n+import org.apache.ratis.statemachine.impl.SimpleStateMachineStorage;\n+import org.apache.ratis.statemachine.impl.SingleFileSnapshotInfo;\n+import org.apache.ratis.thirdparty.com.google.protobuf.UnsafeByteOperations;\n+import org.apache.ratis.util.MD5FileUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class for managing snapshot replication among masters.\n+ */\n+public class SnapshotReplicationManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(SnapshotReplicationManager.class);\n+  private static final long SNAPSHOT_REQUEST_TIMEOUT_MS =\n+      ServerConfiguration.getMs(PropertyKey.MASTER_EMBEDDED_JOURNAL_TRANSPORT_REQUEST_TIMEOUT_MS);\n+\n+  private final SimpleStateMachineStorage mStorage;\n+  private final RaftJournalSystem mJournalSystem;\n+  private volatile long mSnapshotRequestTime = 0L;\n+  private volatile RaftJournalServiceClient mJournalServiceClient;\n+  private volatile SnapshotInfo mDownloadedSnapshot;\n+\n+  private enum DownloadState {\n+    /** No snapshot download is in progress. */\n+    IDLE,\n+\n+    /** Snapshot information is requested from available followers. */\n+    REQUEST_INFO,\n+\n+    /** The latest snapshot data is requested from one of the followers. */\n+    REQUEST_DATA,\n+\n+    /** The latest snapshot is being downloaded from one of the followers. */\n+    STREAM_DATA,\n+\n+    /** A snapshot is downloaded. */\n+    DOWNLOADED,", "originalCommit": "1e13bc8f7f126312a6aae6d23dfdc3e1e5b93d1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIwMjA1Mg==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r485202052", "bodyText": "It means it is finished downloading but not installed. The install can happen later on a leader when Ratis makes another call to take the snapshot.", "author": "bf8086", "createdAt": "2020-09-08T21:19:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4NDc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4Njg5Mw==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r485086893", "bodyText": "What if this was not successful?", "author": "gpang", "createdAt": "2020-09-08T17:34:34Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/SnapshotReplicationManager.java", "diffHunk": "@@ -0,0 +1,503 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.journal.raft;\n+\n+import alluxio.ClientContext;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.status.AbortedException;\n+import alluxio.exception.status.AlluxioStatusException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.exception.status.UnavailableException;\n+import alluxio.grpc.DownloadSnapshotPRequest;\n+import alluxio.grpc.DownloadSnapshotPResponse;\n+import alluxio.grpc.GetSnapshotInfoRequest;\n+import alluxio.grpc.GetSnapshotInfoResponse;\n+import alluxio.grpc.GetSnapshotRequest;\n+import alluxio.grpc.JournalQueryRequest;\n+import alluxio.grpc.JournalQueryResponse;\n+import alluxio.grpc.QuorumServerState;\n+import alluxio.grpc.SnapshotData;\n+import alluxio.grpc.SnapshotMetadata;\n+import alluxio.grpc.UploadSnapshotPRequest;\n+import alluxio.grpc.UploadSnapshotPResponse;\n+import alluxio.master.MasterClientContext;\n+import alluxio.security.authentication.ClientIpAddressInjector;\n+import alluxio.util.CommonUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageLite;\n+import io.grpc.Status;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.ratis.protocol.Message;\n+import org.apache.ratis.protocol.RaftClientReply;\n+import org.apache.ratis.protocol.RaftPeerId;\n+import org.apache.ratis.server.protocol.TermIndex;\n+import org.apache.ratis.server.raftlog.RaftLog;\n+import org.apache.ratis.server.storage.FileInfo;\n+import org.apache.ratis.statemachine.SnapshotInfo;\n+import org.apache.ratis.statemachine.impl.SimpleStateMachineStorage;\n+import org.apache.ratis.statemachine.impl.SingleFileSnapshotInfo;\n+import org.apache.ratis.thirdparty.com.google.protobuf.UnsafeByteOperations;\n+import org.apache.ratis.util.MD5FileUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class for managing snapshot replication among masters.\n+ */\n+public class SnapshotReplicationManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(SnapshotReplicationManager.class);\n+  private static final long SNAPSHOT_REQUEST_TIMEOUT_MS =\n+      ServerConfiguration.getMs(PropertyKey.MASTER_EMBEDDED_JOURNAL_TRANSPORT_REQUEST_TIMEOUT_MS);\n+\n+  private final SimpleStateMachineStorage mStorage;\n+  private final RaftJournalSystem mJournalSystem;\n+  private volatile long mSnapshotRequestTime = 0L;\n+  private volatile RaftJournalServiceClient mJournalServiceClient;\n+  private volatile SnapshotInfo mDownloadedSnapshot;\n+\n+  private enum DownloadState {\n+    /** No snapshot download is in progress. */\n+    IDLE,\n+\n+    /** Snapshot information is requested from available followers. */\n+    REQUEST_INFO,\n+\n+    /** The latest snapshot data is requested from one of the followers. */\n+    REQUEST_DATA,\n+\n+    /** The latest snapshot is being downloaded from one of the followers. */\n+    STREAM_DATA,\n+\n+    /** A snapshot is downloaded. */\n+    DOWNLOADED,\n+\n+    /** A snapshot is being installed to the journal storage. */\n+    INSTALLING,\n+  }\n+\n+  private final AtomicReference<DownloadState> mDownloadState =\n+      new AtomicReference<>(DownloadState.IDLE);\n+\n+  /**\n+   * @param journalSystem the raft journal system\n+   * @param storage the snapshot storage\n+   */\n+  public SnapshotReplicationManager(RaftJournalSystem journalSystem,\n+      SimpleStateMachineStorage storage) {\n+    mStorage = storage;\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  /**\n+   * @param journalSystem the raft journal system\n+   * @param storage the snapshot storage\n+   */\n+  @VisibleForTesting\n+  SnapshotReplicationManager(RaftJournalSystem journalSystem,\n+      SimpleStateMachineStorage storage, RaftJournalServiceClient client) {\n+    this(journalSystem, storage);\n+    mJournalServiceClient = client;\n+  }\n+\n+  /**\n+   * Downloads and installs a snapshot from the leader.\n+   *\n+   * @return a future with the term index of the installed snapshot\n+   */\n+  public CompletableFuture<TermIndex> installSnapshotFromLeader() {\n+    if (mJournalSystem.isLeader()) {\n+      return RaftJournalUtils.completeExceptionally(\n+          new IllegalStateException(\"Abort snapshot installation after becoming a leader\"));\n+    }\n+    if (!transitionState(DownloadState.IDLE, DownloadState.STREAM_DATA)) {\n+      return RaftJournalUtils.completeExceptionally(\n+          new IllegalStateException(\"Illegal state while installing a snapshot\"));\n+    }\n+    try {\n+      RaftJournalServiceClient client = getJournalServiceClient();\n+      SnapshotDownloader<DownloadSnapshotPRequest, DownloadSnapshotPResponse> observer =\n+          SnapshotDownloader.forFollower(mStorage, String.valueOf(client.getAddress()));\n+      client.downloadSnapshot(observer);\n+      return observer.getFuture().thenApplyAsync((termIndex) -> {\n+        mDownloadedSnapshot = observer.getSnapshotToInstall();\n+        transitionState(DownloadState.STREAM_DATA, DownloadState.DOWNLOADED);", "originalCommit": "1e13bc8f7f126312a6aae6d23dfdc3e1e5b93d1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIwNjQ1OQ==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r485206459", "bodyText": "If you are referring to the state transition itself not being successful, it is not possible because the previous transition  transitionState(DownloadState.IDLE, DownloadState.STREAM_DATA) ensured the state is STREAM_DATA before this method is called. If we break this in the future, the transition will log a warning of the broken assumption.\nIf you are referring to the download being not successful. We have a whenComplete handler below to check the error thrown during download, log the error and reset the state.", "author": "bf8086", "createdAt": "2020-09-08T21:29:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4Njg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4NzU3NA==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r485087574", "bodyText": "Can we add useful information to this message? What happens to this exception message? Is it ever exposed to the end user?", "author": "gpang", "createdAt": "2020-09-08T17:35:42Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/SnapshotReplicationManager.java", "diffHunk": "@@ -0,0 +1,503 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.journal.raft;\n+\n+import alluxio.ClientContext;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.status.AbortedException;\n+import alluxio.exception.status.AlluxioStatusException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.exception.status.UnavailableException;\n+import alluxio.grpc.DownloadSnapshotPRequest;\n+import alluxio.grpc.DownloadSnapshotPResponse;\n+import alluxio.grpc.GetSnapshotInfoRequest;\n+import alluxio.grpc.GetSnapshotInfoResponse;\n+import alluxio.grpc.GetSnapshotRequest;\n+import alluxio.grpc.JournalQueryRequest;\n+import alluxio.grpc.JournalQueryResponse;\n+import alluxio.grpc.QuorumServerState;\n+import alluxio.grpc.SnapshotData;\n+import alluxio.grpc.SnapshotMetadata;\n+import alluxio.grpc.UploadSnapshotPRequest;\n+import alluxio.grpc.UploadSnapshotPResponse;\n+import alluxio.master.MasterClientContext;\n+import alluxio.security.authentication.ClientIpAddressInjector;\n+import alluxio.util.CommonUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageLite;\n+import io.grpc.Status;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.ratis.protocol.Message;\n+import org.apache.ratis.protocol.RaftClientReply;\n+import org.apache.ratis.protocol.RaftPeerId;\n+import org.apache.ratis.server.protocol.TermIndex;\n+import org.apache.ratis.server.raftlog.RaftLog;\n+import org.apache.ratis.server.storage.FileInfo;\n+import org.apache.ratis.statemachine.SnapshotInfo;\n+import org.apache.ratis.statemachine.impl.SimpleStateMachineStorage;\n+import org.apache.ratis.statemachine.impl.SingleFileSnapshotInfo;\n+import org.apache.ratis.thirdparty.com.google.protobuf.UnsafeByteOperations;\n+import org.apache.ratis.util.MD5FileUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class for managing snapshot replication among masters.\n+ */\n+public class SnapshotReplicationManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(SnapshotReplicationManager.class);\n+  private static final long SNAPSHOT_REQUEST_TIMEOUT_MS =\n+      ServerConfiguration.getMs(PropertyKey.MASTER_EMBEDDED_JOURNAL_TRANSPORT_REQUEST_TIMEOUT_MS);\n+\n+  private final SimpleStateMachineStorage mStorage;\n+  private final RaftJournalSystem mJournalSystem;\n+  private volatile long mSnapshotRequestTime = 0L;\n+  private volatile RaftJournalServiceClient mJournalServiceClient;\n+  private volatile SnapshotInfo mDownloadedSnapshot;\n+\n+  private enum DownloadState {\n+    /** No snapshot download is in progress. */\n+    IDLE,\n+\n+    /** Snapshot information is requested from available followers. */\n+    REQUEST_INFO,\n+\n+    /** The latest snapshot data is requested from one of the followers. */\n+    REQUEST_DATA,\n+\n+    /** The latest snapshot is being downloaded from one of the followers. */\n+    STREAM_DATA,\n+\n+    /** A snapshot is downloaded. */\n+    DOWNLOADED,\n+\n+    /** A snapshot is being installed to the journal storage. */\n+    INSTALLING,\n+  }\n+\n+  private final AtomicReference<DownloadState> mDownloadState =\n+      new AtomicReference<>(DownloadState.IDLE);\n+\n+  /**\n+   * @param journalSystem the raft journal system\n+   * @param storage the snapshot storage\n+   */\n+  public SnapshotReplicationManager(RaftJournalSystem journalSystem,\n+      SimpleStateMachineStorage storage) {\n+    mStorage = storage;\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  /**\n+   * @param journalSystem the raft journal system\n+   * @param storage the snapshot storage\n+   */\n+  @VisibleForTesting\n+  SnapshotReplicationManager(RaftJournalSystem journalSystem,\n+      SimpleStateMachineStorage storage, RaftJournalServiceClient client) {\n+    this(journalSystem, storage);\n+    mJournalServiceClient = client;\n+  }\n+\n+  /**\n+   * Downloads and installs a snapshot from the leader.\n+   *\n+   * @return a future with the term index of the installed snapshot\n+   */\n+  public CompletableFuture<TermIndex> installSnapshotFromLeader() {\n+    if (mJournalSystem.isLeader()) {\n+      return RaftJournalUtils.completeExceptionally(\n+          new IllegalStateException(\"Abort snapshot installation after becoming a leader\"));\n+    }\n+    if (!transitionState(DownloadState.IDLE, DownloadState.STREAM_DATA)) {\n+      return RaftJournalUtils.completeExceptionally(\n+          new IllegalStateException(\"Illegal state while installing a snapshot\"));", "originalCommit": "1e13bc8f7f126312a6aae6d23dfdc3e1e5b93d1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI0MjE1MQ==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r485242151", "bodyText": "This exception message will be logged by Ratis. It will only show up in master logs. transitionState() will log the expected state and actual state when the expectation is not met.", "author": "bf8086", "createdAt": "2020-09-08T23:03:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4NzU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1MTIyNw==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r485251227", "bodyText": "Updated the message to be more descriptive.", "author": "bf8086", "createdAt": "2020-09-08T23:33:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4NzU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4ODA5Ng==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r485088096", "bodyText": "Can we add the snapshot file or some info/identifier?", "author": "gpang", "createdAt": "2020-09-08T17:36:43Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/SnapshotReplicationManager.java", "diffHunk": "@@ -0,0 +1,503 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.journal.raft;\n+\n+import alluxio.ClientContext;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.status.AbortedException;\n+import alluxio.exception.status.AlluxioStatusException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.exception.status.UnavailableException;\n+import alluxio.grpc.DownloadSnapshotPRequest;\n+import alluxio.grpc.DownloadSnapshotPResponse;\n+import alluxio.grpc.GetSnapshotInfoRequest;\n+import alluxio.grpc.GetSnapshotInfoResponse;\n+import alluxio.grpc.GetSnapshotRequest;\n+import alluxio.grpc.JournalQueryRequest;\n+import alluxio.grpc.JournalQueryResponse;\n+import alluxio.grpc.QuorumServerState;\n+import alluxio.grpc.SnapshotData;\n+import alluxio.grpc.SnapshotMetadata;\n+import alluxio.grpc.UploadSnapshotPRequest;\n+import alluxio.grpc.UploadSnapshotPResponse;\n+import alluxio.master.MasterClientContext;\n+import alluxio.security.authentication.ClientIpAddressInjector;\n+import alluxio.util.CommonUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageLite;\n+import io.grpc.Status;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.ratis.protocol.Message;\n+import org.apache.ratis.protocol.RaftClientReply;\n+import org.apache.ratis.protocol.RaftPeerId;\n+import org.apache.ratis.server.protocol.TermIndex;\n+import org.apache.ratis.server.raftlog.RaftLog;\n+import org.apache.ratis.server.storage.FileInfo;\n+import org.apache.ratis.statemachine.SnapshotInfo;\n+import org.apache.ratis.statemachine.impl.SimpleStateMachineStorage;\n+import org.apache.ratis.statemachine.impl.SingleFileSnapshotInfo;\n+import org.apache.ratis.thirdparty.com.google.protobuf.UnsafeByteOperations;\n+import org.apache.ratis.util.MD5FileUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class for managing snapshot replication among masters.\n+ */\n+public class SnapshotReplicationManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(SnapshotReplicationManager.class);\n+  private static final long SNAPSHOT_REQUEST_TIMEOUT_MS =\n+      ServerConfiguration.getMs(PropertyKey.MASTER_EMBEDDED_JOURNAL_TRANSPORT_REQUEST_TIMEOUT_MS);\n+\n+  private final SimpleStateMachineStorage mStorage;\n+  private final RaftJournalSystem mJournalSystem;\n+  private volatile long mSnapshotRequestTime = 0L;\n+  private volatile RaftJournalServiceClient mJournalServiceClient;\n+  private volatile SnapshotInfo mDownloadedSnapshot;\n+\n+  private enum DownloadState {\n+    /** No snapshot download is in progress. */\n+    IDLE,\n+\n+    /** Snapshot information is requested from available followers. */\n+    REQUEST_INFO,\n+\n+    /** The latest snapshot data is requested from one of the followers. */\n+    REQUEST_DATA,\n+\n+    /** The latest snapshot is being downloaded from one of the followers. */\n+    STREAM_DATA,\n+\n+    /** A snapshot is downloaded. */\n+    DOWNLOADED,\n+\n+    /** A snapshot is being installed to the journal storage. */\n+    INSTALLING,\n+  }\n+\n+  private final AtomicReference<DownloadState> mDownloadState =\n+      new AtomicReference<>(DownloadState.IDLE);\n+\n+  /**\n+   * @param journalSystem the raft journal system\n+   * @param storage the snapshot storage\n+   */\n+  public SnapshotReplicationManager(RaftJournalSystem journalSystem,\n+      SimpleStateMachineStorage storage) {\n+    mStorage = storage;\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  /**\n+   * @param journalSystem the raft journal system\n+   * @param storage the snapshot storage\n+   */\n+  @VisibleForTesting\n+  SnapshotReplicationManager(RaftJournalSystem journalSystem,\n+      SimpleStateMachineStorage storage, RaftJournalServiceClient client) {\n+    this(journalSystem, storage);\n+    mJournalServiceClient = client;\n+  }\n+\n+  /**\n+   * Downloads and installs a snapshot from the leader.\n+   *\n+   * @return a future with the term index of the installed snapshot\n+   */\n+  public CompletableFuture<TermIndex> installSnapshotFromLeader() {\n+    if (mJournalSystem.isLeader()) {\n+      return RaftJournalUtils.completeExceptionally(\n+          new IllegalStateException(\"Abort snapshot installation after becoming a leader\"));\n+    }\n+    if (!transitionState(DownloadState.IDLE, DownloadState.STREAM_DATA)) {\n+      return RaftJournalUtils.completeExceptionally(\n+          new IllegalStateException(\"Illegal state while installing a snapshot\"));\n+    }\n+    try {\n+      RaftJournalServiceClient client = getJournalServiceClient();\n+      SnapshotDownloader<DownloadSnapshotPRequest, DownloadSnapshotPResponse> observer =\n+          SnapshotDownloader.forFollower(mStorage, String.valueOf(client.getAddress()));\n+      client.downloadSnapshot(observer);\n+      return observer.getFuture().thenApplyAsync((termIndex) -> {\n+        mDownloadedSnapshot = observer.getSnapshotToInstall();\n+        transitionState(DownloadState.STREAM_DATA, DownloadState.DOWNLOADED);\n+        long index = installDownloadedSnapshot();\n+        if (index == RaftLog.INVALID_LOG_INDEX) {\n+          throw new CompletionException(\n+              new RuntimeException(\"Failed to install downloaded snapshot\"));", "originalCommit": "1e13bc8f7f126312a6aae6d23dfdc3e1e5b93d1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1MTA2MA==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r485251060", "bodyText": "Done.", "author": "bf8086", "createdAt": "2020-09-08T23:32:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4ODA5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4ODQzMQ==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r485088431", "bodyText": "Can we add who the leader is?", "author": "gpang", "createdAt": "2020-09-08T17:37:21Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/SnapshotReplicationManager.java", "diffHunk": "@@ -0,0 +1,503 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.journal.raft;\n+\n+import alluxio.ClientContext;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.status.AbortedException;\n+import alluxio.exception.status.AlluxioStatusException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.exception.status.UnavailableException;\n+import alluxio.grpc.DownloadSnapshotPRequest;\n+import alluxio.grpc.DownloadSnapshotPResponse;\n+import alluxio.grpc.GetSnapshotInfoRequest;\n+import alluxio.grpc.GetSnapshotInfoResponse;\n+import alluxio.grpc.GetSnapshotRequest;\n+import alluxio.grpc.JournalQueryRequest;\n+import alluxio.grpc.JournalQueryResponse;\n+import alluxio.grpc.QuorumServerState;\n+import alluxio.grpc.SnapshotData;\n+import alluxio.grpc.SnapshotMetadata;\n+import alluxio.grpc.UploadSnapshotPRequest;\n+import alluxio.grpc.UploadSnapshotPResponse;\n+import alluxio.master.MasterClientContext;\n+import alluxio.security.authentication.ClientIpAddressInjector;\n+import alluxio.util.CommonUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageLite;\n+import io.grpc.Status;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.ratis.protocol.Message;\n+import org.apache.ratis.protocol.RaftClientReply;\n+import org.apache.ratis.protocol.RaftPeerId;\n+import org.apache.ratis.server.protocol.TermIndex;\n+import org.apache.ratis.server.raftlog.RaftLog;\n+import org.apache.ratis.server.storage.FileInfo;\n+import org.apache.ratis.statemachine.SnapshotInfo;\n+import org.apache.ratis.statemachine.impl.SimpleStateMachineStorage;\n+import org.apache.ratis.statemachine.impl.SingleFileSnapshotInfo;\n+import org.apache.ratis.thirdparty.com.google.protobuf.UnsafeByteOperations;\n+import org.apache.ratis.util.MD5FileUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class for managing snapshot replication among masters.\n+ */\n+public class SnapshotReplicationManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(SnapshotReplicationManager.class);\n+  private static final long SNAPSHOT_REQUEST_TIMEOUT_MS =\n+      ServerConfiguration.getMs(PropertyKey.MASTER_EMBEDDED_JOURNAL_TRANSPORT_REQUEST_TIMEOUT_MS);\n+\n+  private final SimpleStateMachineStorage mStorage;\n+  private final RaftJournalSystem mJournalSystem;\n+  private volatile long mSnapshotRequestTime = 0L;\n+  private volatile RaftJournalServiceClient mJournalServiceClient;\n+  private volatile SnapshotInfo mDownloadedSnapshot;\n+\n+  private enum DownloadState {\n+    /** No snapshot download is in progress. */\n+    IDLE,\n+\n+    /** Snapshot information is requested from available followers. */\n+    REQUEST_INFO,\n+\n+    /** The latest snapshot data is requested from one of the followers. */\n+    REQUEST_DATA,\n+\n+    /** The latest snapshot is being downloaded from one of the followers. */\n+    STREAM_DATA,\n+\n+    /** A snapshot is downloaded. */\n+    DOWNLOADED,\n+\n+    /** A snapshot is being installed to the journal storage. */\n+    INSTALLING,\n+  }\n+\n+  private final AtomicReference<DownloadState> mDownloadState =\n+      new AtomicReference<>(DownloadState.IDLE);\n+\n+  /**\n+   * @param journalSystem the raft journal system\n+   * @param storage the snapshot storage\n+   */\n+  public SnapshotReplicationManager(RaftJournalSystem journalSystem,\n+      SimpleStateMachineStorage storage) {\n+    mStorage = storage;\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  /**\n+   * @param journalSystem the raft journal system\n+   * @param storage the snapshot storage\n+   */\n+  @VisibleForTesting\n+  SnapshotReplicationManager(RaftJournalSystem journalSystem,\n+      SimpleStateMachineStorage storage, RaftJournalServiceClient client) {\n+    this(journalSystem, storage);\n+    mJournalServiceClient = client;\n+  }\n+\n+  /**\n+   * Downloads and installs a snapshot from the leader.\n+   *\n+   * @return a future with the term index of the installed snapshot\n+   */\n+  public CompletableFuture<TermIndex> installSnapshotFromLeader() {\n+    if (mJournalSystem.isLeader()) {\n+      return RaftJournalUtils.completeExceptionally(\n+          new IllegalStateException(\"Abort snapshot installation after becoming a leader\"));\n+    }\n+    if (!transitionState(DownloadState.IDLE, DownloadState.STREAM_DATA)) {\n+      return RaftJournalUtils.completeExceptionally(\n+          new IllegalStateException(\"Illegal state while installing a snapshot\"));\n+    }\n+    try {\n+      RaftJournalServiceClient client = getJournalServiceClient();\n+      SnapshotDownloader<DownloadSnapshotPRequest, DownloadSnapshotPResponse> observer =\n+          SnapshotDownloader.forFollower(mStorage, String.valueOf(client.getAddress()));\n+      client.downloadSnapshot(observer);\n+      return observer.getFuture().thenApplyAsync((termIndex) -> {\n+        mDownloadedSnapshot = observer.getSnapshotToInstall();\n+        transitionState(DownloadState.STREAM_DATA, DownloadState.DOWNLOADED);\n+        long index = installDownloadedSnapshot();\n+        if (index == RaftLog.INVALID_LOG_INDEX) {\n+          throw new CompletionException(\n+              new RuntimeException(\"Failed to install downloaded snapshot\"));\n+        }\n+        if (index != termIndex.getIndex()) {\n+          throw new CompletionException(new IllegalStateException(\n+              String.format(\"Mismatched snapshot installed - downloaded %d, installed %d\",\n+                  termIndex.getIndex(), index)));\n+        }\n+        return termIndex;\n+      }).whenComplete((termIndex, throwable) -> {\n+        if (throwable != null) {\n+          LOG.error(\"Unexpected exception downloading snapshot from leader.\", throwable);", "originalCommit": "1e13bc8f7f126312a6aae6d23dfdc3e1e5b93d1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1MTEwNA==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r485251104", "bodyText": "Added.", "author": "bf8086", "createdAt": "2020-09-08T23:32:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4ODQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5MTI5Mw==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r485091293", "bodyText": "When an error happens, I'm assuming the state has to get out of INSTALLING. What will do that transition?", "author": "gpang", "createdAt": "2020-09-08T17:42:31Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/SnapshotReplicationManager.java", "diffHunk": "@@ -0,0 +1,503 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.journal.raft;\n+\n+import alluxio.ClientContext;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.status.AbortedException;\n+import alluxio.exception.status.AlluxioStatusException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.exception.status.UnavailableException;\n+import alluxio.grpc.DownloadSnapshotPRequest;\n+import alluxio.grpc.DownloadSnapshotPResponse;\n+import alluxio.grpc.GetSnapshotInfoRequest;\n+import alluxio.grpc.GetSnapshotInfoResponse;\n+import alluxio.grpc.GetSnapshotRequest;\n+import alluxio.grpc.JournalQueryRequest;\n+import alluxio.grpc.JournalQueryResponse;\n+import alluxio.grpc.QuorumServerState;\n+import alluxio.grpc.SnapshotData;\n+import alluxio.grpc.SnapshotMetadata;\n+import alluxio.grpc.UploadSnapshotPRequest;\n+import alluxio.grpc.UploadSnapshotPResponse;\n+import alluxio.master.MasterClientContext;\n+import alluxio.security.authentication.ClientIpAddressInjector;\n+import alluxio.util.CommonUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageLite;\n+import io.grpc.Status;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.ratis.protocol.Message;\n+import org.apache.ratis.protocol.RaftClientReply;\n+import org.apache.ratis.protocol.RaftPeerId;\n+import org.apache.ratis.server.protocol.TermIndex;\n+import org.apache.ratis.server.raftlog.RaftLog;\n+import org.apache.ratis.server.storage.FileInfo;\n+import org.apache.ratis.statemachine.SnapshotInfo;\n+import org.apache.ratis.statemachine.impl.SimpleStateMachineStorage;\n+import org.apache.ratis.statemachine.impl.SingleFileSnapshotInfo;\n+import org.apache.ratis.thirdparty.com.google.protobuf.UnsafeByteOperations;\n+import org.apache.ratis.util.MD5FileUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class for managing snapshot replication among masters.\n+ */\n+public class SnapshotReplicationManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(SnapshotReplicationManager.class);\n+  private static final long SNAPSHOT_REQUEST_TIMEOUT_MS =\n+      ServerConfiguration.getMs(PropertyKey.MASTER_EMBEDDED_JOURNAL_TRANSPORT_REQUEST_TIMEOUT_MS);\n+\n+  private final SimpleStateMachineStorage mStorage;\n+  private final RaftJournalSystem mJournalSystem;\n+  private volatile long mSnapshotRequestTime = 0L;\n+  private volatile RaftJournalServiceClient mJournalServiceClient;\n+  private volatile SnapshotInfo mDownloadedSnapshot;\n+\n+  private enum DownloadState {\n+    /** No snapshot download is in progress. */\n+    IDLE,\n+\n+    /** Snapshot information is requested from available followers. */\n+    REQUEST_INFO,\n+\n+    /** The latest snapshot data is requested from one of the followers. */\n+    REQUEST_DATA,\n+\n+    /** The latest snapshot is being downloaded from one of the followers. */\n+    STREAM_DATA,\n+\n+    /** A snapshot is downloaded. */\n+    DOWNLOADED,\n+\n+    /** A snapshot is being installed to the journal storage. */\n+    INSTALLING,\n+  }\n+\n+  private final AtomicReference<DownloadState> mDownloadState =\n+      new AtomicReference<>(DownloadState.IDLE);\n+\n+  /**\n+   * @param journalSystem the raft journal system\n+   * @param storage the snapshot storage\n+   */\n+  public SnapshotReplicationManager(RaftJournalSystem journalSystem,\n+      SimpleStateMachineStorage storage) {\n+    mStorage = storage;\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  /**\n+   * @param journalSystem the raft journal system\n+   * @param storage the snapshot storage\n+   */\n+  @VisibleForTesting\n+  SnapshotReplicationManager(RaftJournalSystem journalSystem,\n+      SimpleStateMachineStorage storage, RaftJournalServiceClient client) {\n+    this(journalSystem, storage);\n+    mJournalServiceClient = client;\n+  }\n+\n+  /**\n+   * Downloads and installs a snapshot from the leader.\n+   *\n+   * @return a future with the term index of the installed snapshot\n+   */\n+  public CompletableFuture<TermIndex> installSnapshotFromLeader() {\n+    if (mJournalSystem.isLeader()) {\n+      return RaftJournalUtils.completeExceptionally(\n+          new IllegalStateException(\"Abort snapshot installation after becoming a leader\"));\n+    }\n+    if (!transitionState(DownloadState.IDLE, DownloadState.STREAM_DATA)) {\n+      return RaftJournalUtils.completeExceptionally(\n+          new IllegalStateException(\"Illegal state while installing a snapshot\"));\n+    }\n+    try {\n+      RaftJournalServiceClient client = getJournalServiceClient();\n+      SnapshotDownloader<DownloadSnapshotPRequest, DownloadSnapshotPResponse> observer =\n+          SnapshotDownloader.forFollower(mStorage, String.valueOf(client.getAddress()));\n+      client.downloadSnapshot(observer);\n+      return observer.getFuture().thenApplyAsync((termIndex) -> {\n+        mDownloadedSnapshot = observer.getSnapshotToInstall();\n+        transitionState(DownloadState.STREAM_DATA, DownloadState.DOWNLOADED);\n+        long index = installDownloadedSnapshot();\n+        if (index == RaftLog.INVALID_LOG_INDEX) {\n+          throw new CompletionException(\n+              new RuntimeException(\"Failed to install downloaded snapshot\"));\n+        }\n+        if (index != termIndex.getIndex()) {\n+          throw new CompletionException(new IllegalStateException(\n+              String.format(\"Mismatched snapshot installed - downloaded %d, installed %d\",\n+                  termIndex.getIndex(), index)));\n+        }\n+        return termIndex;\n+      }).whenComplete((termIndex, throwable) -> {\n+        if (throwable != null) {\n+          LOG.error(\"Unexpected exception downloading snapshot from leader.\", throwable);\n+          transitionState(DownloadState.STREAM_DATA, DownloadState.IDLE);\n+        }\n+      });\n+    } catch (Exception e) {\n+      transitionState(DownloadState.STREAM_DATA, DownloadState.IDLE);\n+      return RaftJournalUtils.completeExceptionally(e);\n+    }\n+  }\n+\n+  /**\n+   * Sends a snapshot to the leader.\n+   *\n+   * @throws IOException if error occurs while initializing the data stream\n+   */\n+  public void sendSnapshotToLeader() throws IOException {\n+    if (mJournalSystem.isLeader()) {\n+      throw new IllegalStateException(\"Server is no longer a follower\");\n+    }\n+    LOG.debug(\"Checking latest snapshot to send\");\n+    SnapshotInfo snapshot = mStorage.getLatestSnapshot();\n+    if (snapshot == null) {\n+      throw new NotFoundException(\"No snapshot available\");\n+    }\n+    StreamObserver<UploadSnapshotPResponse> responseObserver =\n+        SnapshotUploader.forFollower(mStorage, snapshot);\n+    RaftJournalServiceClient client = getJournalServiceClient();\n+    LOG.info(\"Sending stream request to {} for snapshot {}\", client.getAddress(),\n+        snapshot.getTermIndex());\n+    StreamObserver<UploadSnapshotPRequest> requestObserver = getJournalServiceClient()\n+        .uploadSnapshot(responseObserver);\n+    requestObserver.onNext(UploadSnapshotPRequest.newBuilder()\n+        .setData(SnapshotData.newBuilder()\n+                .setSnapshotTerm(snapshot.getTerm())\n+                .setSnapshotIndex(snapshot.getIndex())\n+                .setOffset(0))\n+        .build());\n+  }\n+\n+  /**\n+   * Attempts to copy a snapshot from one of the followers.\n+   *\n+   * The leader state machine calls this method regularly when it needs a new snapshot.\n+   * To avoid blocking normal journal operations, This method always returns a value immediately\n+   * without waiting for download to finish:\n+   *\n+   * - If no download is in progress, it schedules a new download asynchronously and returns\n+   * {@link RaftLog#INVALID_LOG_INDEX}.\n+   * - If a download is in progress, it returns {@link RaftLog#INVALID_LOG_INDEX} immediately.\n+   * - If a download is completed, it moves the downloaded file to the snapshot directory and\n+   * returns the snapshot index.\n+   *\n+   * @return the index of the downloaded snapshot, or {@link RaftLog#INVALID_LOG_INDEX}\n+   * if no snapshot is installed.\n+   */\n+  public long maybeCopySnapshotFromFollower() {\n+    if (mDownloadState.get() == DownloadState.DOWNLOADED) {\n+      return installDownloadedSnapshot();\n+    }\n+    if (mDownloadState.get() == DownloadState.REQUEST_DATA) {\n+      checkRequestTimeout();\n+    }\n+    if (mDownloadState.get() == DownloadState.IDLE) {\n+      CompletableFuture.runAsync(this::requestSnapshotFromFollowers);\n+    }\n+    return RaftLog.INVALID_LOG_INDEX;\n+  }\n+\n+  /**\n+   * Receives a snapshot from follower.\n+   *\n+   * @param responseStreamObserver the response stream observer\n+   * @return the request stream observer\n+   */\n+  public StreamObserver<UploadSnapshotPRequest> receiveSnapshotFromFollower(\n+      StreamObserver<UploadSnapshotPResponse> responseStreamObserver) {\n+    String followerIp = ClientIpAddressInjector.getIpAddress();\n+    LOG.info(\"Received upload snapshot request from follower {}\", followerIp);\n+    SnapshotDownloader<UploadSnapshotPResponse, UploadSnapshotPRequest> observer =\n+        SnapshotDownloader.forLeader(mStorage, responseStreamObserver,\n+            followerIp);\n+    if (!transitionState(DownloadState.REQUEST_DATA, DownloadState.STREAM_DATA)) {\n+      responseStreamObserver.onCompleted();\n+      return observer;\n+    }\n+    observer.getFuture()\n+        .thenApply(termIndex -> {\n+          mDownloadedSnapshot = observer.getSnapshotToInstall();\n+          transitionState(DownloadState.STREAM_DATA, DownloadState.DOWNLOADED);\n+          return termIndex;\n+        }).exceptionally(e -> {\n+          LOG.error(\"Unexpected exception downloading snapshot from follower {}.\", followerIp, e);\n+          transitionState(DownloadState.STREAM_DATA, DownloadState.IDLE);\n+          return null;\n+        });\n+    return observer;\n+  }\n+\n+  /**\n+   * Handles snapshot requests.\n+   *\n+   * @param queryRequest the query request\n+   * @return the response message, or null if the request is not handled\n+   * @throws IOException if any error occurred while handling the request\n+   */\n+  public Message handleRequest(JournalQueryRequest queryRequest) throws IOException {\n+    if (queryRequest.hasSnapshotInfoRequest()) {\n+      SnapshotInfo latestSnapshot = mStorage.getLatestSnapshot();\n+      if (latestSnapshot == null) {\n+        LOG.debug(\"No snapshot to send\");\n+        return toMessage(GetSnapshotInfoResponse.getDefaultInstance());\n+      }\n+      JournalQueryResponse response = JournalQueryResponse.newBuilder()\n+          .setSnapshotInfoResponse(GetSnapshotInfoResponse.newBuilder().setLatest(\n+              toSnapshotMetadata(latestSnapshot.getTermIndex())))\n+          .build();\n+      LOG.debug(\"Sent snapshot info response {}\", response);\n+      return toMessage(response);\n+    }\n+    if (queryRequest.hasSnapshotRequest()) {\n+      LOG.debug(\"Start sending snapshot to leader\");\n+      sendSnapshotToLeader();\n+      return Message.EMPTY;\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Sends a snapshot to a follower.\n+   *\n+   * @param responseObserver the response stream observer\n+   * @return the request stream observer\n+   */\n+  public StreamObserver<DownloadSnapshotPRequest> sendSnapshotToFollower(\n+      StreamObserver<DownloadSnapshotPResponse> responseObserver) {\n+    SnapshotInfo snapshot = mStorage.getLatestSnapshot();\n+    LOG.debug(\"Received snapshot download request from {}\", ClientIpAddressInjector.getIpAddress());\n+    SnapshotUploader<DownloadSnapshotPResponse, DownloadSnapshotPRequest> requestStreamObserver =\n+        SnapshotUploader.forLeader(mStorage, snapshot, responseObserver);\n+    if (snapshot == null) {\n+      responseObserver.onError(Status.NOT_FOUND\n+          .withDescription(\"Cannot find a valid snapshot to download.\")\n+          .asException());\n+      return requestStreamObserver;\n+    }\n+    responseObserver.onNext(DownloadSnapshotPResponse.newBuilder()\n+        .setData(SnapshotData.newBuilder()\n+            .setSnapshotTerm(snapshot.getTerm())\n+            .setSnapshotIndex(snapshot.getIndex())\n+            .setOffset(0))\n+        .build());\n+    return requestStreamObserver;\n+  }\n+\n+  private static Message toMessage(MessageLite value) {\n+    return Message.valueOf(\n+        UnsafeByteOperations.unsafeWrap(value.toByteString().asReadOnlyByteBuffer()));\n+  }\n+\n+  private SnapshotMetadata toSnapshotMetadata(TermIndex value) {\n+    return value == null ? null :\n+        SnapshotMetadata.newBuilder()\n+            .setSnapshotTerm(value.getTerm())\n+            .setSnapshotIndex(value.getIndex())\n+            .build();\n+  }\n+\n+  private boolean transitionState(DownloadState expected, DownloadState update) {\n+    if (!mDownloadState.compareAndSet(expected, update)) {\n+      LOG.warn(\"Failed to transition from {} to {}: current state is {}\",\n+          expected, update, mDownloadState.get());\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Installs a downloaded snapshot in the journal snapshot directory.\n+   *\n+   * @return the index of the installed snapshot\n+   */\n+  private long installDownloadedSnapshot() {\n+    if (!transitionState(DownloadState.DOWNLOADED, DownloadState.INSTALLING)) {\n+      return RaftLog.INVALID_LOG_INDEX;\n+    }\n+    File tempFile = null;\n+    try {\n+      SnapshotInfo snapshot = mDownloadedSnapshot;\n+      if (snapshot == null) {\n+        throw new IllegalStateException(\"Snapshot is not completed\");\n+      }\n+      FileInfo fileInfo = snapshot.getFiles().get(0);\n+      tempFile = fileInfo.getPath().toFile();\n+      if (!tempFile.exists()) {\n+        throw new FileNotFoundException(String.format(\"Snapshot file %s is not found\", tempFile));\n+      }\n+      SnapshotInfo latestSnapshot = mStorage.getLatestSnapshot();\n+      TermIndex lastInstalled = latestSnapshot == null ? null : latestSnapshot.getTermIndex();\n+      TermIndex downloaded = snapshot.getTermIndex();\n+      if (lastInstalled != null && downloaded.compareTo(lastInstalled) < 0) {\n+        throw new AbortedException(", "originalCommit": "1e13bc8f7f126312a6aae6d23dfdc3e1e5b93d1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIwMDg5MQ==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r485200891", "bodyText": "It is done in the corresponding finally block.", "author": "bf8086", "createdAt": "2020-09-08T21:16:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5MTI5Mw=="}], "type": "inlineReview"}, {"oid": "00def78abf3872f4f2b989ec82567bc622378db5", "url": "https://github.com/Alluxio/alluxio/commit/00def78abf3872f4f2b989ec82567bc622378db5", "message": "Address comments", "committedDate": "2020-09-08T23:31:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk2MjM3OA==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r485962378", "bodyText": "Is there any chance the current state is NOT STREAM_DATA? Then, we would not be able to reset the state, right?", "author": "gpang", "createdAt": "2020-09-09T22:45:22Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/SnapshotReplicationManager.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.journal.raft;\n+\n+import alluxio.ClientContext;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.status.AbortedException;\n+import alluxio.exception.status.AlluxioStatusException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.exception.status.UnavailableException;\n+import alluxio.grpc.DownloadSnapshotPRequest;\n+import alluxio.grpc.DownloadSnapshotPResponse;\n+import alluxio.grpc.GetSnapshotInfoRequest;\n+import alluxio.grpc.GetSnapshotInfoResponse;\n+import alluxio.grpc.GetSnapshotRequest;\n+import alluxio.grpc.JournalQueryRequest;\n+import alluxio.grpc.JournalQueryResponse;\n+import alluxio.grpc.QuorumServerState;\n+import alluxio.grpc.SnapshotData;\n+import alluxio.grpc.SnapshotMetadata;\n+import alluxio.grpc.UploadSnapshotPRequest;\n+import alluxio.grpc.UploadSnapshotPResponse;\n+import alluxio.master.MasterClientContext;\n+import alluxio.security.authentication.ClientIpAddressInjector;\n+import alluxio.util.CommonUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageLite;\n+import io.grpc.Status;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.ratis.protocol.Message;\n+import org.apache.ratis.protocol.RaftClientReply;\n+import org.apache.ratis.protocol.RaftPeerId;\n+import org.apache.ratis.server.protocol.TermIndex;\n+import org.apache.ratis.server.raftlog.RaftLog;\n+import org.apache.ratis.server.storage.FileInfo;\n+import org.apache.ratis.statemachine.SnapshotInfo;\n+import org.apache.ratis.statemachine.impl.SimpleStateMachineStorage;\n+import org.apache.ratis.statemachine.impl.SingleFileSnapshotInfo;\n+import org.apache.ratis.thirdparty.com.google.protobuf.UnsafeByteOperations;\n+import org.apache.ratis.util.MD5FileUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class for managing snapshot replication among masters.\n+ * It manages two snapshot replication workflows - worker to master and master to worker.\n+ *\n+ * 1. Worker to Master\n+ * When a raft leader needs a snapshot, instead of taking snapshot locally it copies a recent\n+ * snapshot from one of the followers.\n+ *\n+ * Workflow:\n+ *\n+ * - Ratis calls leader state machine to take a snapshot\n+ * - leader gets snapshot metadata from follower\n+ * - leader pick one of the the follower and send a request for copying the snapshot\n+ * - follower receives the request and calls the leader raft journal service to upload the snapshot\n+ * - after the upload completes, leader remembers the temporary snapshot location and index\n+ * - Ratis calls the leader state machine again to take a snapshot\n+ * - leader moves the temporary snapshot to the journal snapshot folder and returns snapshot index\n+ *\n+ * 2. Master to Worker\n+ * When a raft follower receives a notification to download a snapshot, it downloads the latest\n+ * snapshot from the leader.\n+ *\n+ * Workflow:\n+ *\n+ * - Ratis leader determines one of the follower needs a snapshot because it misses journal entries\n+ *   from a long time ago\n+ * - Ratis leader notifies Ratis follower to install a snapshot from leader, the follower calls the\n+ *   Alluxio state machine to fulfill this request\n+ * - the follower state machine calls the snapshot manager which calls the raft journal service from\n+ *   leader to download a snapshot\n+ * - after the downloads completes, follower moves the file to snapshot directory and gives Ratis\n+ *   the snapshot index\n+ */\n+public class SnapshotReplicationManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(SnapshotReplicationManager.class);\n+  private static final long SNAPSHOT_REQUEST_TIMEOUT_MS =\n+      ServerConfiguration.getMs(PropertyKey.MASTER_EMBEDDED_JOURNAL_TRANSPORT_REQUEST_TIMEOUT_MS);\n+\n+  private final SimpleStateMachineStorage mStorage;\n+  private final RaftJournalSystem mJournalSystem;\n+  private volatile long mSnapshotRequestTime = 0L;\n+  private volatile RaftJournalServiceClient mJournalServiceClient;\n+  private volatile SnapshotInfo mDownloadedSnapshot;\n+\n+  private enum DownloadState {\n+    /** No snapshot download is in progress. */\n+    IDLE,\n+\n+    /** Snapshot information is requested from available followers. */\n+    REQUEST_INFO,\n+\n+    /** The latest snapshot data is requested from one of the followers. */\n+    REQUEST_DATA,\n+\n+    /** The latest snapshot is being downloaded from one of the followers. */\n+    STREAM_DATA,\n+\n+    /** A snapshot is downloaded and ready for installation. */\n+    DOWNLOADED,\n+\n+    /** A snapshot is being installed to the journal storage. */\n+    INSTALLING,\n+  }\n+\n+  private final AtomicReference<DownloadState> mDownloadState =\n+      new AtomicReference<>(DownloadState.IDLE);\n+\n+  /**\n+   * @param journalSystem the raft journal system\n+   * @param storage the snapshot storage\n+   */\n+  public SnapshotReplicationManager(RaftJournalSystem journalSystem,\n+      SimpleStateMachineStorage storage) {\n+    mStorage = storage;\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  /**\n+   * @param journalSystem the raft journal system\n+   * @param storage the snapshot storage\n+   */\n+  @VisibleForTesting\n+  SnapshotReplicationManager(RaftJournalSystem journalSystem,\n+      SimpleStateMachineStorage storage, RaftJournalServiceClient client) {\n+    this(journalSystem, storage);\n+    mJournalServiceClient = client;\n+  }\n+\n+  /**\n+   * Downloads and installs a snapshot from the leader.\n+   *\n+   * @return a future with the term index of the installed snapshot\n+   */\n+  public CompletableFuture<TermIndex> installSnapshotFromLeader() {\n+    if (mJournalSystem.isLeader()) {\n+      return RaftJournalUtils.completeExceptionally(\n+          new IllegalStateException(\"Abort snapshot installation after becoming a leader\"));\n+    }\n+    if (!transitionState(DownloadState.IDLE, DownloadState.STREAM_DATA)) {\n+      return RaftJournalUtils.completeExceptionally(\n+          new IllegalStateException(\"State is not IDLE when starting a snapshot installation\"));\n+    }\n+    try {\n+      RaftJournalServiceClient client = getJournalServiceClient();\n+      String address = String.valueOf(client.getAddress());\n+      SnapshotDownloader<DownloadSnapshotPRequest, DownloadSnapshotPResponse> observer =\n+          SnapshotDownloader.forFollower(mStorage, address);\n+      client.downloadSnapshot(observer);\n+      return observer.getFuture().thenApplyAsync((termIndex) -> {\n+        mDownloadedSnapshot = observer.getSnapshotToInstall();\n+        transitionState(DownloadState.STREAM_DATA, DownloadState.DOWNLOADED);\n+        long index = installDownloadedSnapshot();\n+        if (index == RaftLog.INVALID_LOG_INDEX) {\n+          throw new CompletionException(new RuntimeException(\n+              String.format(\"Failed to install the downloaded snapshot %s\", termIndex)));\n+        }\n+        if (index != termIndex.getIndex()) {\n+          throw new CompletionException(new IllegalStateException(\n+              String.format(\"Mismatched snapshot installed - downloaded %d, installed %d\",\n+                  termIndex.getIndex(), index)));\n+        }\n+        return termIndex;\n+      }).whenComplete((termIndex, throwable) -> {\n+        if (throwable != null) {\n+          LOG.error(\"Unexpected exception downloading snapshot from leader {}.\", address,\n+              throwable);\n+          transitionState(DownloadState.STREAM_DATA, DownloadState.IDLE);", "originalCommit": "00def78abf3872f4f2b989ec82567bc622378db5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjEzMjk2Mg==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r486132962", "bodyText": "Here is the workflow:\nOn line 164 in this function the state is transitioned to STREAM_DATA.\nAfter that there are 3 places that can transition to a different state:\n\nOn line 176, it will transition to DOWNLOADED. Immediately after that it calls installDownloadedSnapshot, which guarantees transition to IDLE at the end of the function.\nOn line 192(this line), it will transition to IDLE if the download fails to finish.\nOn line 196, it will transition to IDLE if the download fails to start.\n\nOutside this function, there is no place that transition out of STREAM_DATA without first atomically transition into STREAM_DATA, which guarantees an exclusive lock of the state within this function.", "author": "bf8086", "createdAt": "2020-09-10T07:44:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk2MjM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk2MjQwMA==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r485962400", "bodyText": "Is there any chance the current state is NOT STREAM_DATA? Then, we would not be able to reset the state, right?", "author": "gpang", "createdAt": "2020-09-09T22:45:26Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/SnapshotReplicationManager.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.journal.raft;\n+\n+import alluxio.ClientContext;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.status.AbortedException;\n+import alluxio.exception.status.AlluxioStatusException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.exception.status.UnavailableException;\n+import alluxio.grpc.DownloadSnapshotPRequest;\n+import alluxio.grpc.DownloadSnapshotPResponse;\n+import alluxio.grpc.GetSnapshotInfoRequest;\n+import alluxio.grpc.GetSnapshotInfoResponse;\n+import alluxio.grpc.GetSnapshotRequest;\n+import alluxio.grpc.JournalQueryRequest;\n+import alluxio.grpc.JournalQueryResponse;\n+import alluxio.grpc.QuorumServerState;\n+import alluxio.grpc.SnapshotData;\n+import alluxio.grpc.SnapshotMetadata;\n+import alluxio.grpc.UploadSnapshotPRequest;\n+import alluxio.grpc.UploadSnapshotPResponse;\n+import alluxio.master.MasterClientContext;\n+import alluxio.security.authentication.ClientIpAddressInjector;\n+import alluxio.util.CommonUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageLite;\n+import io.grpc.Status;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.ratis.protocol.Message;\n+import org.apache.ratis.protocol.RaftClientReply;\n+import org.apache.ratis.protocol.RaftPeerId;\n+import org.apache.ratis.server.protocol.TermIndex;\n+import org.apache.ratis.server.raftlog.RaftLog;\n+import org.apache.ratis.server.storage.FileInfo;\n+import org.apache.ratis.statemachine.SnapshotInfo;\n+import org.apache.ratis.statemachine.impl.SimpleStateMachineStorage;\n+import org.apache.ratis.statemachine.impl.SingleFileSnapshotInfo;\n+import org.apache.ratis.thirdparty.com.google.protobuf.UnsafeByteOperations;\n+import org.apache.ratis.util.MD5FileUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class for managing snapshot replication among masters.\n+ * It manages two snapshot replication workflows - worker to master and master to worker.\n+ *\n+ * 1. Worker to Master\n+ * When a raft leader needs a snapshot, instead of taking snapshot locally it copies a recent\n+ * snapshot from one of the followers.\n+ *\n+ * Workflow:\n+ *\n+ * - Ratis calls leader state machine to take a snapshot\n+ * - leader gets snapshot metadata from follower\n+ * - leader pick one of the the follower and send a request for copying the snapshot\n+ * - follower receives the request and calls the leader raft journal service to upload the snapshot\n+ * - after the upload completes, leader remembers the temporary snapshot location and index\n+ * - Ratis calls the leader state machine again to take a snapshot\n+ * - leader moves the temporary snapshot to the journal snapshot folder and returns snapshot index\n+ *\n+ * 2. Master to Worker\n+ * When a raft follower receives a notification to download a snapshot, it downloads the latest\n+ * snapshot from the leader.\n+ *\n+ * Workflow:\n+ *\n+ * - Ratis leader determines one of the follower needs a snapshot because it misses journal entries\n+ *   from a long time ago\n+ * - Ratis leader notifies Ratis follower to install a snapshot from leader, the follower calls the\n+ *   Alluxio state machine to fulfill this request\n+ * - the follower state machine calls the snapshot manager which calls the raft journal service from\n+ *   leader to download a snapshot\n+ * - after the downloads completes, follower moves the file to snapshot directory and gives Ratis\n+ *   the snapshot index\n+ */\n+public class SnapshotReplicationManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(SnapshotReplicationManager.class);\n+  private static final long SNAPSHOT_REQUEST_TIMEOUT_MS =\n+      ServerConfiguration.getMs(PropertyKey.MASTER_EMBEDDED_JOURNAL_TRANSPORT_REQUEST_TIMEOUT_MS);\n+\n+  private final SimpleStateMachineStorage mStorage;\n+  private final RaftJournalSystem mJournalSystem;\n+  private volatile long mSnapshotRequestTime = 0L;\n+  private volatile RaftJournalServiceClient mJournalServiceClient;\n+  private volatile SnapshotInfo mDownloadedSnapshot;\n+\n+  private enum DownloadState {\n+    /** No snapshot download is in progress. */\n+    IDLE,\n+\n+    /** Snapshot information is requested from available followers. */\n+    REQUEST_INFO,\n+\n+    /** The latest snapshot data is requested from one of the followers. */\n+    REQUEST_DATA,\n+\n+    /** The latest snapshot is being downloaded from one of the followers. */\n+    STREAM_DATA,\n+\n+    /** A snapshot is downloaded and ready for installation. */\n+    DOWNLOADED,\n+\n+    /** A snapshot is being installed to the journal storage. */\n+    INSTALLING,\n+  }\n+\n+  private final AtomicReference<DownloadState> mDownloadState =\n+      new AtomicReference<>(DownloadState.IDLE);\n+\n+  /**\n+   * @param journalSystem the raft journal system\n+   * @param storage the snapshot storage\n+   */\n+  public SnapshotReplicationManager(RaftJournalSystem journalSystem,\n+      SimpleStateMachineStorage storage) {\n+    mStorage = storage;\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  /**\n+   * @param journalSystem the raft journal system\n+   * @param storage the snapshot storage\n+   */\n+  @VisibleForTesting\n+  SnapshotReplicationManager(RaftJournalSystem journalSystem,\n+      SimpleStateMachineStorage storage, RaftJournalServiceClient client) {\n+    this(journalSystem, storage);\n+    mJournalServiceClient = client;\n+  }\n+\n+  /**\n+   * Downloads and installs a snapshot from the leader.\n+   *\n+   * @return a future with the term index of the installed snapshot\n+   */\n+  public CompletableFuture<TermIndex> installSnapshotFromLeader() {\n+    if (mJournalSystem.isLeader()) {\n+      return RaftJournalUtils.completeExceptionally(\n+          new IllegalStateException(\"Abort snapshot installation after becoming a leader\"));\n+    }\n+    if (!transitionState(DownloadState.IDLE, DownloadState.STREAM_DATA)) {\n+      return RaftJournalUtils.completeExceptionally(\n+          new IllegalStateException(\"State is not IDLE when starting a snapshot installation\"));\n+    }\n+    try {\n+      RaftJournalServiceClient client = getJournalServiceClient();\n+      String address = String.valueOf(client.getAddress());\n+      SnapshotDownloader<DownloadSnapshotPRequest, DownloadSnapshotPResponse> observer =\n+          SnapshotDownloader.forFollower(mStorage, address);\n+      client.downloadSnapshot(observer);\n+      return observer.getFuture().thenApplyAsync((termIndex) -> {\n+        mDownloadedSnapshot = observer.getSnapshotToInstall();\n+        transitionState(DownloadState.STREAM_DATA, DownloadState.DOWNLOADED);\n+        long index = installDownloadedSnapshot();\n+        if (index == RaftLog.INVALID_LOG_INDEX) {\n+          throw new CompletionException(new RuntimeException(\n+              String.format(\"Failed to install the downloaded snapshot %s\", termIndex)));\n+        }\n+        if (index != termIndex.getIndex()) {\n+          throw new CompletionException(new IllegalStateException(\n+              String.format(\"Mismatched snapshot installed - downloaded %d, installed %d\",\n+                  termIndex.getIndex(), index)));\n+        }\n+        return termIndex;\n+      }).whenComplete((termIndex, throwable) -> {\n+        if (throwable != null) {\n+          LOG.error(\"Unexpected exception downloading snapshot from leader {}.\", address,\n+              throwable);\n+          transitionState(DownloadState.STREAM_DATA, DownloadState.IDLE);\n+        }\n+      });\n+    } catch (Exception e) {\n+      transitionState(DownloadState.STREAM_DATA, DownloadState.IDLE);", "originalCommit": "00def78abf3872f4f2b989ec82567bc622378db5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjEzMzE4OA==", "url": "https://github.com/Alluxio/alluxio/pull/12053#discussion_r486133188", "bodyText": "Please see the comment above.", "author": "bf8086", "createdAt": "2020-09-10T07:45:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk2MjQwMA=="}], "type": "inlineReview"}]}