{"pr_number": 11579, "pr_title": "Fix deadlock issue on metadata sync", "pr_createdAt": "2020-06-17T18:15:17Z", "pr_url": "https://github.com/Alluxio/alluxio/pull/11579", "timeline": [{"oid": "f56ab2808ffa9e09e0a8b5aae2cb7ccfa82c917b", "url": "https://github.com/Alluxio/alluxio/commit/f56ab2808ffa9e09e0a8b5aae2cb7ccfa82c917b", "message": "Fix deadlock issue on metadata sync\n\nThis deadlock occurs when concurrent clients submit requests to\npaths where one is the parent of another. It is most likely to\noccur one path is a direct parent of another. There needs to be\nless threads in the executor than there are paths to sync.\nWhen the deadlock occurs it is because the child path holds a read\nlock on a path the parent may be attempting to sync. This prevents\nthe parent path from continuing to sync. The child path though may\nkeep queuing sync jobs which can prevent the child from completing\nits sync and thus causing deadlock because the parent can never\nfinish.\n\nIn order to fix this there were two major issues to be solved:\n\n1. Unlock the root path so the ancestry of one sync does not block\nanother. After internal discussion, we decided that because we\ndon't hold the lock for any children for the duration of the sync\nthat it is unnecessary to hold the parent lock for the entire\nduration as well.\n\n2. Because the inode sync stream has to lock and unlock the root\npath while syncing, the function loadMetadataIfNotExists needed\nto be modified so that the path is unlocked before loading the\nmetadata. The major issue is that checking whether we need to\nload metadata on a path is expensive because it requires a lock.\nIn order to maintain high RPC throughput for GetFileInfo and\nListStatus (the users of loadMetadataIfNotExist) this PR\nintroduces a two-phase scheme for locking on those RPCs. The\ngeneral approach is to lock and then check if metadata needs to\nbe loaded, in which case we unlock and go back to the beginning\nof the RPCs main logic with an extra flag set to load metdata.\nIn the case where the path already exists and does not need to be\nloaded, then the RPC continues as normal.\n\nThere will be a slight overhead in occasions where we are loading\nmetadata for paths that don't yet exist, but that is not the\ncommon case, so I am slightly less concerned about the performance\nthere. There will be no more locks taken there than there would be\nin a normal metadata sync, so the runtimes should be comparable\nanyway.", "committedDate": "2020-06-17T18:17:08Z", "type": "forcePushed"}, {"oid": "9038955b3b75240f339788bb31540d9cf93127d1", "url": "https://github.com/Alluxio/alluxio/commit/9038955b3b75240f339788bb31540d9cf93127d1", "message": "Fix deadlock issue on metadata sync\n\nThis deadlock occurs when concurrent clients submit requests to\npaths where one is the parent of another. It is most likely to\noccur one path is a direct parent of another. There needs to be\nless threads in the executor than there are paths to sync.\nWhen the deadlock occurs it is because the child path holds a read\nlock on a path the parent may be attempting to sync. This prevents\nthe parent path from continuing to sync. The child path though may\nkeep queuing sync jobs which can prevent the child from completing\nits sync and thus causing deadlock because the parent can never\nfinish.\n\nIn order to fix this there were two major issues to be solved:\n\n1. Unlock the root path so the ancestry of one sync does not block\nanother. After internal discussion, we decided that because we\ndon't hold the lock for any children for the duration of the sync\nthat it is unnecessary to hold the parent lock for the entire\nduration as well.\n\n2. Because the inode sync stream has to lock and unlock the root\npath while syncing, the function loadMetadataIfNotExists needed\nto be modified so that the path is unlocked before loading the\nmetadata. The major issue is that checking whether we need to\nload metadata on a path is expensive because it requires a lock.\nIn order to maintain high RPC throughput for GetFileInfo and\nListStatus (the users of loadMetadataIfNotExist) this PR\nintroduces a two-phase scheme for locking on those RPCs. The\ngeneral approach is to lock and then check if metadata needs to\nbe loaded, in which case we unlock and go back to the beginning\nof the RPCs main logic with an extra flag set to load metdata.\nIn the case where the path already exists and does not need to be\nloaded, then the RPC continues as normal.\n\nThere will be a slight overhead in occasions where we are loading\nmetadata for paths that don't yet exist, but that is not the\ncommon case, so I am slightly less concerned about the performance\nthere. There will be no more locks taken there than there would be\nin a normal metadata sync, so the runtimes should be comparable\nanyway.", "committedDate": "2020-06-17T19:55:03Z", "type": "commit"}, {"oid": "9038955b3b75240f339788bb31540d9cf93127d1", "url": "https://github.com/Alluxio/alluxio/commit/9038955b3b75240f339788bb31540d9cf93127d1", "message": "Fix deadlock issue on metadata sync\n\nThis deadlock occurs when concurrent clients submit requests to\npaths where one is the parent of another. It is most likely to\noccur one path is a direct parent of another. There needs to be\nless threads in the executor than there are paths to sync.\nWhen the deadlock occurs it is because the child path holds a read\nlock on a path the parent may be attempting to sync. This prevents\nthe parent path from continuing to sync. The child path though may\nkeep queuing sync jobs which can prevent the child from completing\nits sync and thus causing deadlock because the parent can never\nfinish.\n\nIn order to fix this there were two major issues to be solved:\n\n1. Unlock the root path so the ancestry of one sync does not block\nanother. After internal discussion, we decided that because we\ndon't hold the lock for any children for the duration of the sync\nthat it is unnecessary to hold the parent lock for the entire\nduration as well.\n\n2. Because the inode sync stream has to lock and unlock the root\npath while syncing, the function loadMetadataIfNotExists needed\nto be modified so that the path is unlocked before loading the\nmetadata. The major issue is that checking whether we need to\nload metadata on a path is expensive because it requires a lock.\nIn order to maintain high RPC throughput for GetFileInfo and\nListStatus (the users of loadMetadataIfNotExist) this PR\nintroduces a two-phase scheme for locking on those RPCs. The\ngeneral approach is to lock and then check if metadata needs to\nbe loaded, in which case we unlock and go back to the beginning\nof the RPCs main logic with an extra flag set to load metdata.\nIn the case where the path already exists and does not need to be\nloaded, then the RPC continues as normal.\n\nThere will be a slight overhead in occasions where we are loading\nmetadata for paths that don't yet exist, but that is not the\ncommon case, so I am slightly less concerned about the performance\nthere. There will be no more locks taken there than there would be\nin a normal metadata sync, so the runtimes should be comparable\nanyway.", "committedDate": "2020-06-17T19:55:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNjU0Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442416543", "bodyText": "Why is this renamed? mount info sounds like it is the info for a single mount, but mount table sounds like the entire mapping?", "author": "gpang", "createdAt": "2020-06-18T18:19:06Z", "path": "core/server/master/src/main/java/alluxio/master/file/FileSystemMaster.java", "diffHunk": "@@ -234,7 +234,7 @@ long getNewBlockIdForFile(AlluxioURI path) throws FileDoesNotExistException, Inv\n   /**\n    * @return a copy of the current mount table\n    */\n-  Map<String, MountPointInfo>  getMountTable();\n+  Map<String, MountPointInfo>  getMountInfo();", "originalCommit": "9038955b3b75240f339788bb31540d9cf93127d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQzMzY3Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442433672", "bodyText": "I renamed it because I added another method which actually returns the MountTable object. I felt it was more apt to call that getMountTable. This was used by a few other places and I couldn't think of a good name. Since it wasn't the actual MountTable object I just settled on getMountInfo. I'm open to other ideas", "author": "ZacBlanco", "createdAt": "2020-06-18T18:51:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNjU0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwOTE1MA==", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442509150", "bodyText": "Ah, I see it now. maybe getMountTableMap? or getMountInfoMap? Yeah, since it is not the actual mount table, this should not simply be getMountTable.", "author": "gpang", "createdAt": "2020-06-18T21:20:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNjU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNjk2OA==", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442416968", "bodyText": "What about this test?", "author": "gpang", "createdAt": "2020-06-18T18:19:56Z", "path": "core/server/master/src/test/java/alluxio/master/file/FileSystemMasterTest.java", "diffHunk": "@@ -2672,6 +2673,46 @@ public void propagatePersisted() throws Exception {\n             GetStatusContext.defaults()).getPersistenceState());\n   }\n \n+//  @Test", "originalCommit": "9038955b3b75240f339788bb31540d9cf93127d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0MDA4Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442440082", "bodyText": "I was trying to write a test which reproduced the issue consistently, but this one only reproduced it every 1/25 times or so...I can try adding more to make sure that it does reproduce the issue and that this change fixes it, but it might take me a bit longer - or we can just go without this test.\nWhat do you think?", "author": "ZacBlanco", "createdAt": "2020-06-18T19:02:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNjk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwNzYyOQ==", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442507629", "bodyText": "Even with a much longer path? How long could the test take if it \"passes\"?", "author": "gpang", "createdAt": "2020-06-18T21:17:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNjk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzNjY2MQ==", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442536661", "bodyText": "even with a longer path it failed to reproduce. To writing the actual test that fails (deadlocks) in the earlier code and not in the current code might take me a while to write.", "author": "ZacBlanco", "createdAt": "2020-06-18T22:31:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNjk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyODM0NA==", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442428344", "bodyText": "is this no longer necessary because everything is unlocked?", "author": "gpang", "createdAt": "2020-06-18T18:41:07Z", "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -257,21 +293,18 @@ public boolean sync() {\n \n       // process the sync result for the original path\n       try {\n-        mRootPath.traverse();\n+        path.traverse();\n       } catch (InvalidPathException e) {\n         throw new RuntimeException(e);\n       }\n-    } catch (AccessControlException | BlockInfoException | FileAlreadyCompletedException\n+    } catch (BlockInfoException | FileAlreadyCompletedException\n         | FileDoesNotExistException | InterruptedException | InvalidFileSizeException\n-        | InvalidPathException | IOException e) {\n+        | IOException e) {\n       LogUtils.warnWithException(LOG, \"Failed to sync metadata on root path {}\",\n           toString(), e);\n     } finally {\n       // regardless of the outcome, remove the UfsStatus for this path from the cache\n-      mStatusCache.remove(mRootPath.getUri());\n-      // downgrade so that if operations are parallelized, the lock on the root doesn't restrict\n-      // concurrent operations\n-      mRootPath.downgradeToRead();", "originalCommit": "9038955b3b75240f339788bb31540d9cf93127d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQzMzcyNw==", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442433727", "bodyText": "yes", "author": "ZacBlanco", "createdAt": "2020-06-18T18:51:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyODM0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyODYxMg==", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442428612", "bodyText": "This will relock and recheck permissions? Can we add that to the comments of this method or class?", "author": "gpang", "createdAt": "2020-06-18T18:41:37Z", "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -245,9 +269,21 @@ public boolean sync() {\n     if (LOG.isDebugEnabled()) {\n       start = System.currentTimeMillis();\n     }\n-\n-    try {\n-      syncInodeMetadata(mRootPath);\n+    try (LockedInodePath path = mInodeTree.lockInodePath(mRootScheme)) {", "originalCommit": "9038955b3b75240f339788bb31540d9cf93127d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQzNjcwOA==", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442436708", "bodyText": "This will relock and recheck permissions\n\nThe permission check and locking were all moved into this block. The syncMetadata function in DFSM no longer does the lock and permission check", "author": "ZacBlanco", "createdAt": "2020-06-18T18:56:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyODYxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxMDY5NQ==", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442510695", "bodyText": "NIT: I would avoid calling this a two-phase locking scheme, since \"two-phase locking\" is already a well-defined term. Maybe this can be a two-step locking scheme?", "author": "gpang", "createdAt": "2020-06-18T21:23:55Z", "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -737,18 +737,48 @@ public long getFileId(AlluxioURI path) throws AccessControlException, Unavailabl\n \n   private long getFileIdInternal(AlluxioURI path, boolean checkPermission)\n       throws AccessControlException, UnavailableException {\n-    try (RpcContext rpcContext = createRpcContext();\n-         LockedInodePath inodePath = mInodeTree.lockInodePath(path, LockPattern.READ)) {\n-      if (checkPermission) {\n-        mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n+    try (RpcContext rpcContext = createRpcContext()) {\n+      /*\n+      In order to prevent locking twice on RPCs where metadata does _not_ need to be loaded, we use\n+      a two-phase scheme as an optimization to prevent the extra lock. loadMetadataIfNotExists", "originalCommit": "9038955b3b75240f339788bb31540d9cf93127d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxMTY5NA==", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442511694", "bodyText": "This is the same comment as in getFileIdInternal right? Can we just have a simple comment here to point to that method for more details about load metadata? (same comment for list status)", "author": "gpang", "createdAt": "2020-06-18T21:26:08Z", "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -769,49 +799,72 @@ public FileInfo getFileInfo(AlluxioURI path, GetStatusContext context)\n         FileSystemMasterAuditContext auditContext =\n             createAuditContext(\"getFileInfo\", path, null, null)) {\n \n-      if (syncMetadata(rpcContext,\n-          path,\n-          context.getOptions().getCommonOptions(),\n-          DescendantType.ONE,\n-          auditContext,\n-          LockedInodePath::getInodeOrNull,\n+      if (syncMetadata(rpcContext, path, context.getOptions().getCommonOptions(),\n+          DescendantType.ONE, auditContext, LockedInodePath::getInodeOrNull,\n           (inodePath, permChecker) -> permChecker.checkPermission(Mode.Bits.READ, inodePath),\n           true)) {\n         // If synced, do not load metadata.\n         context.getOptions().setLoadMetadataType(LoadMetadataPType.NEVER);\n       }\n-\n-      LockingScheme lockingScheme = new LockingScheme(path, LockPattern.READ, false);\n-      try (LockedInodePath inodePath = mInodeTree.lockInodePath(lockingScheme)) {\n-        auditContext.setSrcInode(inodePath.getInodeOrNull());\n-        try {\n-          mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n-        } catch (AccessControlException e) {\n-          auditContext.setAllowed(false);\n-          throw e;\n+      LoadMetadataContext lmCtx = LoadMetadataContext.mergeFrom(\n+          LoadMetadataPOptions.newBuilder().setCreateAncestors(true).setCommonOptions(\n+              FileSystemMasterCommonPOptions.newBuilder()\n+                  .setTtl(context.getOptions().getCommonOptions().getTtl())\n+                  .setTtlAction(context.getOptions().getCommonOptions().getTtlAction())));\n+      /*\n+      In order to prevent locking twice on RPCs where metadata does _not_ need to be loaded, we use", "originalCommit": "9038955b3b75240f339788bb31540d9cf93127d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzNzE0OQ==", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442537149", "bodyText": "Yeah, I can make it so there's only one comment. I just wanted to be extra clear in where I was using it.", "author": "ZacBlanco", "createdAt": "2020-06-18T22:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxMTY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyNjgwMA==", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442526800", "bodyText": "Is there any chance this could run for more than 2 iterations?", "author": "gpang", "createdAt": "2020-06-18T22:02:56Z", "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -737,18 +737,48 @@ public long getFileId(AlluxioURI path) throws AccessControlException, Unavailabl\n \n   private long getFileIdInternal(AlluxioURI path, boolean checkPermission)\n       throws AccessControlException, UnavailableException {\n-    try (RpcContext rpcContext = createRpcContext();\n-         LockedInodePath inodePath = mInodeTree.lockInodePath(path, LockPattern.READ)) {\n-      if (checkPermission) {\n-        mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n+    try (RpcContext rpcContext = createRpcContext()) {\n+      /*\n+      In order to prevent locking twice on RPCs where metadata does _not_ need to be loaded, we use\n+      a two-phase scheme as an optimization to prevent the extra lock. loadMetadataIfNotExists\n+      requires a lock on the tree to determine if the path should be loaded before executing. To\n+      prevent the extra lock, we execute the RPC as normal and use a conditional check in the\n+      main body of the function to determine whether control flow should be shifted out of the\n+      RPC logic and back to the loadMetadataIfNotExists function.\n+\n+      If loadMetadataIfNotExists runs, then the next pass into the main logic body should\n+      continue as normal. This may present a slight decrease in performance for newly-loaded\n+      metadata, but it is better than affecting the most common case where metadata is not being\n+      loaded.\n+       */\n+      LoadMetadataContext lmCtx = LoadMetadataContext.mergeFrom(\n+          LoadMetadataPOptions.newBuilder().setCreateAncestors(true));\n+      boolean run = true;\n+      boolean loadMetadata = false;\n+      while (run) {", "originalCommit": "9038955b3b75240f339788bb31540d9cf93127d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyMjMzNA==", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442722334", "bodyText": "Do you see a case where it could?\nI stepped through the logic myself to iron out as many errors as possible when writing it and when doing the tests.\nFor each of the implementations there are two flags\n\nrun\nloadMetadata\n\nIn the main body of the loop run is always immediately set false after entering the loop and is only set again within a conditional that contains if (!loadMetadata)\nWithin the conditional of if (!loadMetadata) we set run to true, but also set the loadMetadata flag to true, which means that we shouldn't enter the same conditional the 2nd time around to be able to set run to true again - preventing more than 2 iterations.", "author": "ZacBlanco", "createdAt": "2020-06-19T09:07:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyNjgwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczOTgxNg==", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442739816", "bodyText": "If you have a better idea of how you would implement this logic I'm all ears. I'm sure there are ways it can be improved. This was the simplest thing I came up with.", "author": "ZacBlanco", "createdAt": "2020-06-19T09:42:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyNjgwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkzNjg1MQ==", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442936851", "bodyText": "Yeah, after looking at it, it should be fine. The important part is that we have to make sure run is set to false in the beginning, and setting run=true can only happen when loadMetadata == false.", "author": "gpang", "createdAt": "2020-06-19T16:27:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyNjgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyNzMwMg==", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442527302", "bodyText": "the rpcs use shouldLoadMetadataIfNotExists to check to load metadata, but this method also calls shouldLoadMetadataIfNotExists again. Is that intentional, and why do we need to check again?", "author": "gpang", "createdAt": "2020-06-18T22:04:09Z", "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -2518,12 +2592,32 @@ public UfsInfo getUfsInfo(long mountId) {\n    * Loads metadata for the path if it is (non-existing || load direct children is set).\n    *\n    * @param rpcContext the rpc context\n-   * @param inodePath the {@link LockedInodePath} to load the metadata for\n    * @param context the load metadata context\n    */\n-  private void loadMetadataIfNotExist(RpcContext rpcContext, LockedInodePath inodePath,\n-      LoadMetadataContext context, boolean isGetFileInfo) {\n-    Preconditions.checkState(inodePath.getLockPattern() == LockPattern.READ);\n+  private void loadMetadataIfNotExist(RpcContext rpcContext, AlluxioURI path,\n+      LoadMetadataContext context, boolean isGetFileInfo)\n+      throws InvalidPathException, AccessControlException {\n+    LockingScheme scheme = new LockingScheme(path, LockPattern.READ, false);\n+    boolean lm;\n+    try (LockedInodePath inodePath = mInodeTree.lockInodePath(scheme)) {\n+      lm = shouldLoadMetadataIfNotExists(inodePath, context);", "originalCommit": "9038955b3b75240f339788bb31540d9cf93127d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyOTU1MQ==", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442729551", "bodyText": "It was originally intentional because I was trying to preserve the old behavior, and it's possible that in between the original check and running this function the tree changed, so this can prevent us from loading the metadata unnecessarily\nBut I am thinking more about it now; the cost of the lock to perform this check vs the probability of the path being loaded since the last check outside this function is likely low, and so the cost of performing this lock vs the amount of CPU time it could save is likely going to do more harm than good. I'll remove it.", "author": "ZacBlanco", "createdAt": "2020-06-19T09:22:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyNzMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyODU2NA==", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442528564", "bodyText": "Is there a better message we can use, to help us debug or fix?", "author": "gpang", "createdAt": "2020-06-18T22:07:36Z", "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -769,49 +799,72 @@ public FileInfo getFileInfo(AlluxioURI path, GetStatusContext context)\n         FileSystemMasterAuditContext auditContext =\n             createAuditContext(\"getFileInfo\", path, null, null)) {\n \n-      if (syncMetadata(rpcContext,\n-          path,\n-          context.getOptions().getCommonOptions(),\n-          DescendantType.ONE,\n-          auditContext,\n-          LockedInodePath::getInodeOrNull,\n+      if (syncMetadata(rpcContext, path, context.getOptions().getCommonOptions(),\n+          DescendantType.ONE, auditContext, LockedInodePath::getInodeOrNull,\n           (inodePath, permChecker) -> permChecker.checkPermission(Mode.Bits.READ, inodePath),\n           true)) {\n         // If synced, do not load metadata.\n         context.getOptions().setLoadMetadataType(LoadMetadataPType.NEVER);\n       }\n-\n-      LockingScheme lockingScheme = new LockingScheme(path, LockPattern.READ, false);\n-      try (LockedInodePath inodePath = mInodeTree.lockInodePath(lockingScheme)) {\n-        auditContext.setSrcInode(inodePath.getInodeOrNull());\n-        try {\n-          mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n-        } catch (AccessControlException e) {\n-          auditContext.setAllowed(false);\n-          throw e;\n+      LoadMetadataContext lmCtx = LoadMetadataContext.mergeFrom(\n+          LoadMetadataPOptions.newBuilder().setCreateAncestors(true).setCommonOptions(\n+              FileSystemMasterCommonPOptions.newBuilder()\n+                  .setTtl(context.getOptions().getCommonOptions().getTtl())\n+                  .setTtlAction(context.getOptions().getCommonOptions().getTtlAction())));\n+      /*\n+      In order to prevent locking twice on RPCs where metadata does _not_ need to be loaded, we use\n+      a two-phase scheme as an optimization to prevent the extra lock. loadMetadataIfNotExists\n+      requires a lock on the tree to determine if the path should be loaded before executing. To\n+      prevent the extra lock, we execute the RPC as normal and use a conditional check in the\n+      main body of the function to determine whether control flow should be shifted out of the\n+      RPC logic and back to the loadMetadataIfNotExists function.\n+\n+      If loadMetadataIfNotExists runs, then the next pass into the main logic body should\n+      continue as normal. This may present a slight decrease in performance for newly-loaded\n+      metadata, but it is better than affecting the most common case where metadata is not being\n+      loaded.\n+       */\n+      boolean run = true;\n+      boolean loadMetadata = false;\n+      FileInfo ret = null;\n+      while (run) {\n+        run = false;\n+        if (loadMetadata) {\n+          checkLoadMetadataOptions(context.getOptions().getLoadMetadataType(), path);\n+          loadMetadataIfNotExist(rpcContext, path, lmCtx, true);\n         }\n-        // If the file already exists, then metadata does not need to be loaded,\n-        // otherwise load metadata.\n-        if (!inodePath.fullPathExists()) {\n-          checkLoadMetadataOptions(context.getOptions().getLoadMetadataType(), inodePath.getUri());\n-          loadMetadataIfNotExist(rpcContext, inodePath, LoadMetadataContext.mergeFrom(\n-              LoadMetadataPOptions.newBuilder().setCreateAncestors(true).setCommonOptions(\n-                  FileSystemMasterCommonPOptions.newBuilder()\n-                      .setTtl(context.getOptions().getCommonOptions().getTtl())\n-                      .setTtlAction(context.getOptions().getCommonOptions().getTtlAction()))),\n-              true);\n+\n+        LockingScheme lockingScheme = new LockingScheme(path, LockPattern.READ, false);\n+        try (LockedInodePath inodePath = mInodeTree.lockInodePath(lockingScheme)) {\n+          auditContext.setSrcInode(inodePath.getInodeOrNull());\n+          try {\n+            mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n+          } catch (AccessControlException e) {\n+            auditContext.setAllowed(false);\n+            throw e;\n+          }\n+\n+          if (!loadMetadata && shouldLoadMetadataIfNotExists(inodePath, lmCtx)) {\n+            loadMetadata = true;\n+            run = true;\n+            continue;\n+          }\n+\n           ensureFullPathAndUpdateCache(inodePath);\n+\n+          FileInfo fileInfo = getFileInfoInternal(inodePath);\n+          Mode.Bits accessMode = Mode.Bits.fromProto(context.getOptions().getAccessMode());\n+          if (context.getOptions().getUpdateTimestamps() && context.getOptions().hasAccessMode()\n+              && (accessMode.imply(Mode.Bits.READ) || accessMode.imply(Mode.Bits.WRITE))) {\n+            mAccessTimeUpdater.updateAccessTime(rpcContext.getJournalContext(),\n+                inodePath.getInode(), opTimeMs);\n+          }\n+          auditContext.setSrcInode(inodePath.getInode()).setSucceeded(true);\n+          ret = fileInfo;\n         }\n-        FileInfo fileInfo = getFileInfoInternal(inodePath);\n-        Mode.Bits accessMode = Mode.Bits.fromProto(context.getOptions().getAccessMode());\n-        if (context.getOptions().getUpdateTimestamps() && context.getOptions().hasAccessMode() && (\n-            accessMode.imply(Mode.Bits.READ) || accessMode.imply(Mode.Bits.WRITE))) {\n-          mAccessTimeUpdater\n-              .updateAccessTime(rpcContext.getJournalContext(), inodePath.getInode(), opTimeMs);\n-        }\n-        auditContext.setSrcInode(inodePath.getInode()).setSucceeded(true);\n-        return fileInfo;\n       }\n+      return Preconditions.checkNotNull(ret,\n+          \"fileInfo returned should not be null. This is a bug.\");", "originalCommit": "9038955b3b75240f339788bb31540d9cf93127d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczODA2Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442738066", "bodyText": "Oh so, I guess IntelliJ became smart again - after looking at this code the IDE is reporting to me that \"ret is always non-null\" at this point (it didn't before). I guess I can remove this Precondition check.", "author": "ZacBlanco", "createdAt": "2020-06-19T09:39:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyODU2NA=="}], "type": "inlineReview"}, {"oid": "f4ee1438491c934838cbe13be8ceafc9b35f4895", "url": "https://github.com/Alluxio/alluxio/commit/f4ee1438491c934838cbe13be8ceafc9b35f4895", "message": "Address comments", "committedDate": "2020-06-19T09:43:17Z", "type": "commit"}, {"oid": "79a530ac560c5f23b840e535726a3249a1e760ee", "url": "https://github.com/Alluxio/alluxio/commit/79a530ac560c5f23b840e535726a3249a1e760ee", "message": "Remove commented test", "committedDate": "2020-06-22T21:59:58Z", "type": "commit"}]}