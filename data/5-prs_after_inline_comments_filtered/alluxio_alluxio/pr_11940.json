{"pr_number": 11940, "pr_title": "Migrate state machine to ratis", "pr_createdAt": "2020-08-08T02:55:43Z", "pr_url": "https://github.com/Alluxio/alluxio/pull/11940", "timeline": [{"oid": "5b8a80fdf23fb713dd710c0463810c3e5c22b9b8", "url": "https://github.com/Alluxio/alluxio/commit/5b8a80fdf23fb713dd710c0463810c3e5c22b9b8", "message": "migrate state machine to ratis", "committedDate": "2020-08-08T02:17:40Z", "type": "commit"}, {"oid": "93b957447387511b7619456098f30b1866cae103", "url": "https://github.com/Alluxio/alluxio/commit/93b957447387511b7619456098f30b1866cae103", "message": "Fix spotbug issues", "committedDate": "2020-08-13T18:43:45Z", "type": "commit"}, {"oid": "0f13afcb308e7e142ab95f07337bb634f9b33645", "url": "https://github.com/Alluxio/alluxio/commit/0f13afcb308e7e142ab95f07337bb634f9b33645", "message": "Fix unit test", "committedDate": "2020-08-14T06:23:55Z", "type": "commit"}, {"oid": "9250d5b4373f086ec5da357acc86d3167c3cfbcb", "url": "https://github.com/Alluxio/alluxio/commit/9250d5b4373f086ec5da357acc86d3167c3cfbcb", "message": "Clean up comments", "committedDate": "2020-08-14T07:15:49Z", "type": "commit"}, {"oid": "78e1bfffd8435db5525423ebf415d3785f61ba61", "url": "https://github.com/Alluxio/alluxio/commit/78e1bfffd8435db5525423ebf415d3785f61ba61", "message": "Update journal dumper and fix tests", "committedDate": "2020-08-15T01:24:49Z", "type": "commit"}, {"oid": "04df2168f24846426848cced3a7462ae2b8571b3", "url": "https://github.com/Alluxio/alluxio/commit/04df2168f24846426848cced3a7462ae2b8571b3", "message": "Fix more tests", "committedDate": "2020-08-17T17:54:33Z", "type": "commit"}, {"oid": "54853c807e70564964849901be803ffb949a5435", "url": "https://github.com/Alluxio/alluxio/commit/54853c807e70564964849901be803ffb949a5435", "message": "Clean up code", "committedDate": "2020-08-18T09:29:00Z", "type": "commit"}, {"oid": "96131f5114210d2a09e1d955f53ee3296b97fb98", "url": "https://github.com/Alluxio/alluxio/commit/96131f5114210d2a09e1d955f53ee3296b97fb98", "message": "Fix snapshot bug", "committedDate": "2020-08-18T16:26:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE0NDY3Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474144676", "bodyText": "why does it take so long to register nodes?", "author": "gpang", "createdAt": "2020-08-20T17:09:59Z", "path": "tests/src/test/java/alluxio/server/ft/journal/TriggeredCheckpointTest.java", "diffHunk": "@@ -121,7 +121,7 @@ private void validateCheckpointInClusterRestart(MultiProcessCluster cluster)\n       throws Exception {\n     cluster.stopMasters();\n     cluster.startMasters();\n-    cluster.waitForAllNodesRegistered(20 * Constants.SECOND_MS);\n+    cluster.waitForAllNodesRegistered(30 * Constants.SECOND_MS);", "originalCommit": "96131f5114210d2a09e1d955f53ee3296b97fb98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3NTc0Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474175743", "bodyText": "I am not exactly sure. There might be some parameters that we can tune to make it faster.", "author": "bf8086", "createdAt": "2020-08-20T18:06:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE0NDY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE0NjQ2NA==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474146464", "bodyText": "old calculation was wrong?", "author": "gpang", "createdAt": "2020-08-20T17:13:15Z", "path": "core/server/common/src/test/java/alluxio/master/journal/raft/RaftJournalTest.java", "diffHunk": "@@ -242,9 +242,10 @@ public void gainPrimacyAfterSuspend() throws Exception {\n     Assert.assertEquals(0, countingMaster.getApplyCount());\n     // Gain primacy in follower journal and validate it catches up.\n     mFollowerJournalSystem.gainPrimacy();\n-    CommonUtils.waitFor(\"full state acquired after resume\",\n-        () -> countingMaster.getApplyCount() == entryCount, mWaitOptions);\n-\n+    CommonUtils.waitFor(\n+        \"full state acquired after resume\", () -> mFollowerJournalSystem.getCurrentSequenceNumbers()\n+            .values().stream().distinct().collect(Collectors.toList()).get(0) == entryCount - 1,", "originalCommit": "96131f5114210d2a09e1d955f53ee3296b97fb98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI4MDU5Nw==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474280597", "bodyText": "Gaining primacy in this test does not ensure all journal entries are applied. Sometimes a few entries are processed after the journal system is promoted and thus get ignored. The sequence number reflects entries that are processed which will include the entries processed before and after the follower becomes primary.", "author": "bf8086", "createdAt": "2020-08-20T21:23:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE0NjQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MTczOA==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474161738", "bodyText": "Is there any identifier we can add to this message?", "author": "gpang", "createdAt": "2020-08-20T17:40:49Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -70,35 +88,164 @@\n   private volatile long mLastPrimaryStartSequenceNumber = 0;\n   private volatile long mNextSequenceNumberToRead = 0;\n   private volatile boolean mSnapshotting = false;\n+  private volatile boolean mIsLeader = false;\n+\n   // The start time of the most recent snapshot\n   private volatile long mLastSnapshotStartTime = 0;\n   /** Used to control applying to masters. */\n   private BufferedJournalApplier mJournalApplier;\n+  private final SimpleStateMachineStorage mStorage = new SimpleStateMachineStorage();\n+  private RaftGroupId mRaftGroupId;\n \n   /**\n-   * @param journals master journals; these journals are still owned by the caller, not by the\n-   *        journal state machine\n-   * @param journalSinks a supplier for journal sinks\n+   * @param journals     master journals; these journals are still owned by the caller, not by the\n+   *                     journal state machine\n+   * @param journalSystem the raft journal system\n    */\n-  public JournalStateMachine(Map<String, RaftJournal> journals,\n-      Supplier<Set<JournalSink>> journalSinks) {\n+  public JournalStateMachine(Map<String, RaftJournal> journals, RaftJournalSystem journalSystem) {\n     mJournals = journals;\n-    mJournalApplier = new BufferedJournalApplier(journals, journalSinks);\n+    mJournalApplier = new BufferedJournalApplier(journals,\n+        () -> journalSystem.getJournalSinks(null));\n     resetState();\n     LOG.info(\"Initialized new journal state machine\");\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  private static <T> CompletableFuture<T> completeExceptionally(Exception e) {\n+    final CompletableFuture<T> future = new CompletableFuture<>();\n+    future.completeExceptionally(e);\n+    return future;\n+  }\n+\n+  @Override\n+  public void initialize(RaftServer server, RaftGroupId groupId,\n+      RaftStorage raftStorage) throws IOException {\n+    getLifeCycle().startAndTransition(() -> {\n+      super.initialize(server, groupId, raftStorage);\n+      mRaftGroupId = groupId;\n+      mStorage.init(raftStorage);\n+      loadSnapshot(mStorage.getLatestSnapshot());\n+    });\n+  }\n+\n+  @Override\n+  public void reinitialize() throws IOException {\n+    LOG.info(\"Reinitializing state machine.\");", "originalCommit": "96131f5114210d2a09e1d955f53ee3296b97fb98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI5MTExNw==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474291117", "bodyText": "AFAIK there is only one state machine per master. Is there a specific identifier you are looking for?", "author": "bf8086", "createdAt": "2020-08-20T21:47:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MTczOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTczNjg0OQ==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r475736849", "bodyText": "Ok. Is there a local path where the files will be initialized?", "author": "gpang", "createdAt": "2020-08-24T16:24:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MTczOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc5NDYyNw==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r475794627", "bodyText": "The local path where the journal logs and snapshots are stored is the journal directory set through the raft server configuration.", "author": "bf8086", "createdAt": "2020-08-24T17:56:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MTczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MjEzOA==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474162138", "bodyText": "I'm curious. Why does reinitialize() and initialize() look completely different? I would have imagined that reinitialize would be quite similar to initialize, or would share some code?", "author": "gpang", "createdAt": "2020-08-20T17:41:32Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -70,35 +88,164 @@\n   private volatile long mLastPrimaryStartSequenceNumber = 0;\n   private volatile long mNextSequenceNumberToRead = 0;\n   private volatile boolean mSnapshotting = false;\n+  private volatile boolean mIsLeader = false;\n+\n   // The start time of the most recent snapshot\n   private volatile long mLastSnapshotStartTime = 0;\n   /** Used to control applying to masters. */\n   private BufferedJournalApplier mJournalApplier;\n+  private final SimpleStateMachineStorage mStorage = new SimpleStateMachineStorage();\n+  private RaftGroupId mRaftGroupId;\n \n   /**\n-   * @param journals master journals; these journals are still owned by the caller, not by the\n-   *        journal state machine\n-   * @param journalSinks a supplier for journal sinks\n+   * @param journals     master journals; these journals are still owned by the caller, not by the\n+   *                     journal state machine\n+   * @param journalSystem the raft journal system\n    */\n-  public JournalStateMachine(Map<String, RaftJournal> journals,\n-      Supplier<Set<JournalSink>> journalSinks) {\n+  public JournalStateMachine(Map<String, RaftJournal> journals, RaftJournalSystem journalSystem) {\n     mJournals = journals;\n-    mJournalApplier = new BufferedJournalApplier(journals, journalSinks);\n+    mJournalApplier = new BufferedJournalApplier(journals,\n+        () -> journalSystem.getJournalSinks(null));\n     resetState();\n     LOG.info(\"Initialized new journal state machine\");\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  private static <T> CompletableFuture<T> completeExceptionally(Exception e) {\n+    final CompletableFuture<T> future = new CompletableFuture<>();\n+    future.completeExceptionally(e);\n+    return future;\n+  }\n+\n+  @Override\n+  public void initialize(RaftServer server, RaftGroupId groupId,\n+      RaftStorage raftStorage) throws IOException {\n+    getLifeCycle().startAndTransition(() -> {\n+      super.initialize(server, groupId, raftStorage);\n+      mRaftGroupId = groupId;\n+      mStorage.init(raftStorage);\n+      loadSnapshot(mStorage.getLatestSnapshot());\n+    });\n+  }\n+\n+  @Override\n+  public void reinitialize() throws IOException {", "originalCommit": "96131f5114210d2a09e1d955f53ee3296b97fb98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI4ODM0OQ==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474288349", "bodyText": "initialize() is invoked when the server is first started. reinitialize() is invoked when a follower got a new snapshot from leader and need to reload.\nThere isn't much difference except maybe two things:\n\nthe initialize() does a little more to initialize the group id and raft storage.\nmStorage.loadLatestSnapshot() was implicitly called in initialize() as part of mStorage.init(raftStorage);", "author": "bf8086", "createdAt": "2020-08-20T21:40:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MjEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MjY5Nw==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474162697", "bodyText": "Should be ERROR. Also, when does this happen? I don't know what this message is supposed to tell the user.\nWhy is this not throwing an exception instead?", "author": "gpang", "createdAt": "2020-08-20T17:42:36Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -70,35 +88,164 @@\n   private volatile long mLastPrimaryStartSequenceNumber = 0;\n   private volatile long mNextSequenceNumberToRead = 0;\n   private volatile boolean mSnapshotting = false;\n+  private volatile boolean mIsLeader = false;\n+\n   // The start time of the most recent snapshot\n   private volatile long mLastSnapshotStartTime = 0;\n   /** Used to control applying to masters. */\n   private BufferedJournalApplier mJournalApplier;\n+  private final SimpleStateMachineStorage mStorage = new SimpleStateMachineStorage();\n+  private RaftGroupId mRaftGroupId;\n \n   /**\n-   * @param journals master journals; these journals are still owned by the caller, not by the\n-   *        journal state machine\n-   * @param journalSinks a supplier for journal sinks\n+   * @param journals     master journals; these journals are still owned by the caller, not by the\n+   *                     journal state machine\n+   * @param journalSystem the raft journal system\n    */\n-  public JournalStateMachine(Map<String, RaftJournal> journals,\n-      Supplier<Set<JournalSink>> journalSinks) {\n+  public JournalStateMachine(Map<String, RaftJournal> journals, RaftJournalSystem journalSystem) {\n     mJournals = journals;\n-    mJournalApplier = new BufferedJournalApplier(journals, journalSinks);\n+    mJournalApplier = new BufferedJournalApplier(journals,\n+        () -> journalSystem.getJournalSinks(null));\n     resetState();\n     LOG.info(\"Initialized new journal state machine\");\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  private static <T> CompletableFuture<T> completeExceptionally(Exception e) {\n+    final CompletableFuture<T> future = new CompletableFuture<>();\n+    future.completeExceptionally(e);\n+    return future;\n+  }\n+\n+  @Override\n+  public void initialize(RaftServer server, RaftGroupId groupId,\n+      RaftStorage raftStorage) throws IOException {\n+    getLifeCycle().startAndTransition(() -> {\n+      super.initialize(server, groupId, raftStorage);\n+      mRaftGroupId = groupId;\n+      mStorage.init(raftStorage);\n+      loadSnapshot(mStorage.getLatestSnapshot());\n+    });\n+  }\n+\n+  @Override\n+  public void reinitialize() throws IOException {\n+    LOG.info(\"Reinitializing state machine.\");\n+    mStorage.loadLatestSnapshot();\n+    loadSnapshot(mStorage.getLatestSnapshot());\n+    unpause();\n+  }\n+\n+  private void loadSnapshot(SingleFileSnapshotInfo snapshot) throws IOException {\n+    if (snapshot == null) {\n+      LOG.info(\"No snapshot to load\");", "originalCommit": "96131f5114210d2a09e1d955f53ee3296b97fb98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI4OTA3OA==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474289078", "bodyText": "A null snapshot is given if there isn't a snapshot in the journal folder. This can happen when the master is started for the first time or before a snapshot is taken. It is an expected case therefore is not logged as an error.", "author": "bf8086", "createdAt": "2020-08-20T21:42:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MjY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MzAyMQ==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474163021", "bodyText": "Do we need to log and throw the same exception?", "author": "gpang", "createdAt": "2020-08-20T17:43:12Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -70,35 +88,164 @@\n   private volatile long mLastPrimaryStartSequenceNumber = 0;\n   private volatile long mNextSequenceNumberToRead = 0;\n   private volatile boolean mSnapshotting = false;\n+  private volatile boolean mIsLeader = false;\n+\n   // The start time of the most recent snapshot\n   private volatile long mLastSnapshotStartTime = 0;\n   /** Used to control applying to masters. */\n   private BufferedJournalApplier mJournalApplier;\n+  private final SimpleStateMachineStorage mStorage = new SimpleStateMachineStorage();\n+  private RaftGroupId mRaftGroupId;\n \n   /**\n-   * @param journals master journals; these journals are still owned by the caller, not by the\n-   *        journal state machine\n-   * @param journalSinks a supplier for journal sinks\n+   * @param journals     master journals; these journals are still owned by the caller, not by the\n+   *                     journal state machine\n+   * @param journalSystem the raft journal system\n    */\n-  public JournalStateMachine(Map<String, RaftJournal> journals,\n-      Supplier<Set<JournalSink>> journalSinks) {\n+  public JournalStateMachine(Map<String, RaftJournal> journals, RaftJournalSystem journalSystem) {\n     mJournals = journals;\n-    mJournalApplier = new BufferedJournalApplier(journals, journalSinks);\n+    mJournalApplier = new BufferedJournalApplier(journals,\n+        () -> journalSystem.getJournalSinks(null));\n     resetState();\n     LOG.info(\"Initialized new journal state machine\");\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  private static <T> CompletableFuture<T> completeExceptionally(Exception e) {\n+    final CompletableFuture<T> future = new CompletableFuture<>();\n+    future.completeExceptionally(e);\n+    return future;\n+  }\n+\n+  @Override\n+  public void initialize(RaftServer server, RaftGroupId groupId,\n+      RaftStorage raftStorage) throws IOException {\n+    getLifeCycle().startAndTransition(() -> {\n+      super.initialize(server, groupId, raftStorage);\n+      mRaftGroupId = groupId;\n+      mStorage.init(raftStorage);\n+      loadSnapshot(mStorage.getLatestSnapshot());\n+    });\n+  }\n+\n+  @Override\n+  public void reinitialize() throws IOException {\n+    LOG.info(\"Reinitializing state machine.\");\n+    mStorage.loadLatestSnapshot();\n+    loadSnapshot(mStorage.getLatestSnapshot());\n+    unpause();\n+  }\n+\n+  private void loadSnapshot(SingleFileSnapshotInfo snapshot) throws IOException {\n+    if (snapshot == null) {\n+      LOG.info(\"No snapshot to load\");\n+      return;\n+    }\n+    LOG.info(\"Loading Snapshot {}\", snapshot);\n+    final File snapshotFile = snapshot.getFile().getPath().toFile();\n+    if (!snapshotFile.exists()) {\n+      LOG.error(\"The snapshot {} does not exist\", snapshot);", "originalCommit": "96131f5114210d2a09e1d955f53ee3296b97fb98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMwODk2Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474308963", "bodyText": "I initially added the log for debugging. Removed.", "author": "bf8086", "createdAt": "2020-08-20T22:35:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MzAyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MzcxMQ==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474163711", "bodyText": "I think if you use the logging with {}, you cannot use the last argument as the exception. You have to use String.format() to pass in a single string, and then the exception.", "author": "gpang", "createdAt": "2020-08-20T17:44:34Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -70,35 +88,164 @@\n   private volatile long mLastPrimaryStartSequenceNumber = 0;\n   private volatile long mNextSequenceNumberToRead = 0;\n   private volatile boolean mSnapshotting = false;\n+  private volatile boolean mIsLeader = false;\n+\n   // The start time of the most recent snapshot\n   private volatile long mLastSnapshotStartTime = 0;\n   /** Used to control applying to masters. */\n   private BufferedJournalApplier mJournalApplier;\n+  private final SimpleStateMachineStorage mStorage = new SimpleStateMachineStorage();\n+  private RaftGroupId mRaftGroupId;\n \n   /**\n-   * @param journals master journals; these journals are still owned by the caller, not by the\n-   *        journal state machine\n-   * @param journalSinks a supplier for journal sinks\n+   * @param journals     master journals; these journals are still owned by the caller, not by the\n+   *                     journal state machine\n+   * @param journalSystem the raft journal system\n    */\n-  public JournalStateMachine(Map<String, RaftJournal> journals,\n-      Supplier<Set<JournalSink>> journalSinks) {\n+  public JournalStateMachine(Map<String, RaftJournal> journals, RaftJournalSystem journalSystem) {\n     mJournals = journals;\n-    mJournalApplier = new BufferedJournalApplier(journals, journalSinks);\n+    mJournalApplier = new BufferedJournalApplier(journals,\n+        () -> journalSystem.getJournalSinks(null));\n     resetState();\n     LOG.info(\"Initialized new journal state machine\");\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  private static <T> CompletableFuture<T> completeExceptionally(Exception e) {\n+    final CompletableFuture<T> future = new CompletableFuture<>();\n+    future.completeExceptionally(e);\n+    return future;\n+  }\n+\n+  @Override\n+  public void initialize(RaftServer server, RaftGroupId groupId,\n+      RaftStorage raftStorage) throws IOException {\n+    getLifeCycle().startAndTransition(() -> {\n+      super.initialize(server, groupId, raftStorage);\n+      mRaftGroupId = groupId;\n+      mStorage.init(raftStorage);\n+      loadSnapshot(mStorage.getLatestSnapshot());\n+    });\n+  }\n+\n+  @Override\n+  public void reinitialize() throws IOException {\n+    LOG.info(\"Reinitializing state machine.\");\n+    mStorage.loadLatestSnapshot();\n+    loadSnapshot(mStorage.getLatestSnapshot());\n+    unpause();\n+  }\n+\n+  private void loadSnapshot(SingleFileSnapshotInfo snapshot) throws IOException {\n+    if (snapshot == null) {\n+      LOG.info(\"No snapshot to load\");\n+      return;\n+    }\n+    LOG.info(\"Loading Snapshot {}\", snapshot);\n+    final File snapshotFile = snapshot.getFile().getPath().toFile();\n+    if (!snapshotFile.exists()) {\n+      LOG.error(\"The snapshot {} does not exist\", snapshot);\n+      throw new FileNotFoundException(\n+          String.format(\"The snapshot file %s does not exist\", snapshotFile.getPath()));\n+    }\n+    try {\n+      resetState();\n+      setLastAppliedTermIndex(snapshot.getTermIndex());\n+      install(snapshotFile);\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to load snapshot {}\", snapshot, e);", "originalCommit": "96131f5114210d2a09e1d955f53ee3296b97fb98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI5MjIzNA==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474292234", "bodyText": "For slf4j we can pass an exception in addition to all string parameters to include the call stack in the log.", "author": "bf8086", "createdAt": "2020-08-20T21:50:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MzcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2Mzk3Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474163972", "bodyText": "Should we throw a new exception with the message like above? Also, do we need to log and throw an exception?", "author": "gpang", "createdAt": "2020-08-20T17:45:00Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -70,35 +88,164 @@\n   private volatile long mLastPrimaryStartSequenceNumber = 0;\n   private volatile long mNextSequenceNumberToRead = 0;\n   private volatile boolean mSnapshotting = false;\n+  private volatile boolean mIsLeader = false;\n+\n   // The start time of the most recent snapshot\n   private volatile long mLastSnapshotStartTime = 0;\n   /** Used to control applying to masters. */\n   private BufferedJournalApplier mJournalApplier;\n+  private final SimpleStateMachineStorage mStorage = new SimpleStateMachineStorage();\n+  private RaftGroupId mRaftGroupId;\n \n   /**\n-   * @param journals master journals; these journals are still owned by the caller, not by the\n-   *        journal state machine\n-   * @param journalSinks a supplier for journal sinks\n+   * @param journals     master journals; these journals are still owned by the caller, not by the\n+   *                     journal state machine\n+   * @param journalSystem the raft journal system\n    */\n-  public JournalStateMachine(Map<String, RaftJournal> journals,\n-      Supplier<Set<JournalSink>> journalSinks) {\n+  public JournalStateMachine(Map<String, RaftJournal> journals, RaftJournalSystem journalSystem) {\n     mJournals = journals;\n-    mJournalApplier = new BufferedJournalApplier(journals, journalSinks);\n+    mJournalApplier = new BufferedJournalApplier(journals,\n+        () -> journalSystem.getJournalSinks(null));\n     resetState();\n     LOG.info(\"Initialized new journal state machine\");\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  private static <T> CompletableFuture<T> completeExceptionally(Exception e) {\n+    final CompletableFuture<T> future = new CompletableFuture<>();\n+    future.completeExceptionally(e);\n+    return future;\n+  }\n+\n+  @Override\n+  public void initialize(RaftServer server, RaftGroupId groupId,\n+      RaftStorage raftStorage) throws IOException {\n+    getLifeCycle().startAndTransition(() -> {\n+      super.initialize(server, groupId, raftStorage);\n+      mRaftGroupId = groupId;\n+      mStorage.init(raftStorage);\n+      loadSnapshot(mStorage.getLatestSnapshot());\n+    });\n+  }\n+\n+  @Override\n+  public void reinitialize() throws IOException {\n+    LOG.info(\"Reinitializing state machine.\");\n+    mStorage.loadLatestSnapshot();\n+    loadSnapshot(mStorage.getLatestSnapshot());\n+    unpause();\n+  }\n+\n+  private void loadSnapshot(SingleFileSnapshotInfo snapshot) throws IOException {\n+    if (snapshot == null) {\n+      LOG.info(\"No snapshot to load\");\n+      return;\n+    }\n+    LOG.info(\"Loading Snapshot {}\", snapshot);\n+    final File snapshotFile = snapshot.getFile().getPath().toFile();\n+    if (!snapshotFile.exists()) {\n+      LOG.error(\"The snapshot {} does not exist\", snapshot);\n+      throw new FileNotFoundException(\n+          String.format(\"The snapshot file %s does not exist\", snapshotFile.getPath()));\n+    }\n+    try {\n+      resetState();\n+      setLastAppliedTermIndex(snapshot.getTermIndex());\n+      install(snapshotFile);\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to load snapshot {}\", snapshot, e);\n+      throw e;", "originalCommit": "96131f5114210d2a09e1d955f53ee3296b97fb98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMwOTIyNw==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474309227", "bodyText": "Removed the logging message and included it in a new exception.", "author": "bf8086", "createdAt": "2020-08-20T22:36:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2Mzk3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2NDg0Nw==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474164847", "bodyText": "Do we need to throw and log? Can we have this message include the message above?", "author": "gpang", "createdAt": "2020-08-20T17:46:39Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -70,35 +88,164 @@\n   private volatile long mLastPrimaryStartSequenceNumber = 0;\n   private volatile long mNextSequenceNumberToRead = 0;\n   private volatile boolean mSnapshotting = false;\n+  private volatile boolean mIsLeader = false;\n+\n   // The start time of the most recent snapshot\n   private volatile long mLastSnapshotStartTime = 0;\n   /** Used to control applying to masters. */\n   private BufferedJournalApplier mJournalApplier;\n+  private final SimpleStateMachineStorage mStorage = new SimpleStateMachineStorage();\n+  private RaftGroupId mRaftGroupId;\n \n   /**\n-   * @param journals master journals; these journals are still owned by the caller, not by the\n-   *        journal state machine\n-   * @param journalSinks a supplier for journal sinks\n+   * @param journals     master journals; these journals are still owned by the caller, not by the\n+   *                     journal state machine\n+   * @param journalSystem the raft journal system\n    */\n-  public JournalStateMachine(Map<String, RaftJournal> journals,\n-      Supplier<Set<JournalSink>> journalSinks) {\n+  public JournalStateMachine(Map<String, RaftJournal> journals, RaftJournalSystem journalSystem) {\n     mJournals = journals;\n-    mJournalApplier = new BufferedJournalApplier(journals, journalSinks);\n+    mJournalApplier = new BufferedJournalApplier(journals,\n+        () -> journalSystem.getJournalSinks(null));\n     resetState();\n     LOG.info(\"Initialized new journal state machine\");\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  private static <T> CompletableFuture<T> completeExceptionally(Exception e) {\n+    final CompletableFuture<T> future = new CompletableFuture<>();\n+    future.completeExceptionally(e);\n+    return future;\n+  }\n+\n+  @Override\n+  public void initialize(RaftServer server, RaftGroupId groupId,\n+      RaftStorage raftStorage) throws IOException {\n+    getLifeCycle().startAndTransition(() -> {\n+      super.initialize(server, groupId, raftStorage);\n+      mRaftGroupId = groupId;\n+      mStorage.init(raftStorage);\n+      loadSnapshot(mStorage.getLatestSnapshot());\n+    });\n+  }\n+\n+  @Override\n+  public void reinitialize() throws IOException {\n+    LOG.info(\"Reinitializing state machine.\");\n+    mStorage.loadLatestSnapshot();\n+    loadSnapshot(mStorage.getLatestSnapshot());\n+    unpause();\n+  }\n+\n+  private void loadSnapshot(SingleFileSnapshotInfo snapshot) throws IOException {\n+    if (snapshot == null) {\n+      LOG.info(\"No snapshot to load\");\n+      return;\n+    }\n+    LOG.info(\"Loading Snapshot {}\", snapshot);\n+    final File snapshotFile = snapshot.getFile().getPath().toFile();\n+    if (!snapshotFile.exists()) {\n+      LOG.error(\"The snapshot {} does not exist\", snapshot);\n+      throw new FileNotFoundException(\n+          String.format(\"The snapshot file %s does not exist\", snapshotFile.getPath()));\n+    }\n+    try {\n+      resetState();\n+      setLastAppliedTermIndex(snapshot.getTermIndex());\n+      install(snapshotFile);\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to load snapshot {}\", snapshot, e);\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public long takeSnapshot() {\n+    if (mIsLeader) {\n+      // TODO(feng): if secondary master has a more recent snapshot, install it\n+      return RaftLog.INVALID_LOG_INDEX;\n+    } else {\n+      return takeLocalSnapshot();\n+    }\n+  }\n+\n+  @Override\n+  public SnapshotInfo getLatestSnapshot() {\n+    return mStorage.getLatestSnapshot();\n+  }\n+\n+  @Override\n+  public StateMachineStorage getStateMachineStorage() {\n+    return mStorage;\n+  }\n+\n+  @Override\n+  public CompletableFuture<Message> query(Message request) {\n+    LOG.info(\"Received query: {}\", request);\n+    return super.query(request);\n+  }\n+\n+  @Override\n+  public void close() {\n+    mClosed = true;\n+  }\n+\n+  @Override\n+  public CompletableFuture<Message> applyTransaction(TransactionContext trx) {\n+    try {\n+      applyJournalEntryCommand(trx);\n+      return super.applyTransaction(trx);\n+    } catch (Exception e) {\n+      return completeExceptionally(e);\n+    }\n+  }\n+\n+  @Override\n+  public void notifyNotLeader(Collection<TransactionContext> pendingEntries) {\n+    mIsLeader = false;\n+    mJournalSystem.notifyLeadershipStateChanged(false);\n+  }\n+\n+  @Override\n+  public void pause() {\n+    getLifeCycle().transition(LifeCycle.State.PAUSING);\n+    try {\n+      if (!mJournalApplier.isSuspended()) {\n+        suspend();\n+      }\n+    } catch (IOException e) {\n+      LOG.error(\"State machine pause failed\", e);\n+      throw new IllegalStateException(e);", "originalCommit": "96131f5114210d2a09e1d955f53ee3296b97fb98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMwODU4MA==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474308580", "bodyText": "Removed the logging message.", "author": "bf8086", "createdAt": "2020-08-20T22:34:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2NDg0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2NTcyMA==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474165720", "bodyText": "Can you include the file name?", "author": "gpang", "createdAt": "2020-08-20T17:48:13Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -171,31 +317,77 @@ private void applySingleEntry(JournalEntry entry) {\n     }\n   }\n \n-  @Override\n-  public void snapshot(SnapshotWriter writer) {\n+  private File createTempSnapshotFile() throws IOException {\n+    File tempDir = new File(mStorage.getSmDir().getParentFile(), \"tmp\");\n+    if (!tempDir.isDirectory() && !tempDir.mkdir()) {\n+      throw new IOException(\n+          \"Cannot create temporary snapshot directory at \" + tempDir.getAbsolutePath());\n+    }\n+    return File.createTempFile(\"raft_snapshot_\" + System.currentTimeMillis() + \"_\",\n+        \".dat\", tempDir);\n+  }\n+\n+  /**\n+   * Takes a snapshot of local state machine.\n+   * @return the index of last included entry, or {@link RaftLog#INVALID_LOG_INDEX} if it fails\n+   */\n+  public long takeLocalSnapshot() {\n     // Snapshot format is [snapshotId, name1, bytes1, name2, bytes2, ...].\n     if (mClosed) {\n-      return;\n+      return RaftLog.INVALID_LOG_INDEX;\n     }\n     LOG.debug(\"Calling snapshot\");\n     Preconditions.checkState(!mSnapshotting, \"Cannot call snapshot multiple times concurrently\");\n     mSnapshotting = true;\n     mLastSnapshotStartTime = System.currentTimeMillis();\n     long snapshotId = mNextSequenceNumberToRead - 1;\n-    try (SnapshotWriterStream sws = new SnapshotWriterStream(writer)) {\n-      writer.writeLong(snapshotId);\n-      JournalUtils.writeToCheckpoint(sws, getStateMachines());\n+    TermIndex last = getLastAppliedTermIndex();\n+    File tempFile;\n+    try {\n+      tempFile = createTempSnapshotFile();\n+    } catch (IOException e) {\n+      LogUtils.warnWithException(LOG, \"Failed to create temp snapshot file\", e);\n+      return RaftLog.INVALID_LOG_INDEX;\n+    }\n+    LOG.info(\"Taking a snapshot to file {}\", tempFile);\n+    final File snapshotFile = mStorage.getSnapshotFile(last.getTerm(), last.getIndex());\n+    try (DataOutputStream outputStream = new DataOutputStream(new FileOutputStream(tempFile))) {\n+      outputStream.writeLong(snapshotId);\n+      JournalUtils.writeToCheckpoint(outputStream, getStateMachines());\n+    } catch (Exception e) {\n+      tempFile.delete();\n+      LogUtils.warnWithException(LOG, \"Failed to take snapshot: {}\", snapshotId, e);", "originalCommit": "96131f5114210d2a09e1d955f53ee3296b97fb98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMwODQ4MA==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474308480", "bodyText": "Added.", "author": "bf8086", "createdAt": "2020-08-20T22:33:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2NTcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2NjQ5Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474166493", "bodyText": "Include filename? Also, this message is identical to the previous section. Can we distinguish them?", "author": "gpang", "createdAt": "2020-08-20T17:49:39Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -171,31 +317,77 @@ private void applySingleEntry(JournalEntry entry) {\n     }\n   }\n \n-  @Override\n-  public void snapshot(SnapshotWriter writer) {\n+  private File createTempSnapshotFile() throws IOException {\n+    File tempDir = new File(mStorage.getSmDir().getParentFile(), \"tmp\");\n+    if (!tempDir.isDirectory() && !tempDir.mkdir()) {\n+      throw new IOException(\n+          \"Cannot create temporary snapshot directory at \" + tempDir.getAbsolutePath());\n+    }\n+    return File.createTempFile(\"raft_snapshot_\" + System.currentTimeMillis() + \"_\",\n+        \".dat\", tempDir);\n+  }\n+\n+  /**\n+   * Takes a snapshot of local state machine.\n+   * @return the index of last included entry, or {@link RaftLog#INVALID_LOG_INDEX} if it fails\n+   */\n+  public long takeLocalSnapshot() {\n     // Snapshot format is [snapshotId, name1, bytes1, name2, bytes2, ...].\n     if (mClosed) {\n-      return;\n+      return RaftLog.INVALID_LOG_INDEX;\n     }\n     LOG.debug(\"Calling snapshot\");\n     Preconditions.checkState(!mSnapshotting, \"Cannot call snapshot multiple times concurrently\");\n     mSnapshotting = true;\n     mLastSnapshotStartTime = System.currentTimeMillis();\n     long snapshotId = mNextSequenceNumberToRead - 1;\n-    try (SnapshotWriterStream sws = new SnapshotWriterStream(writer)) {\n-      writer.writeLong(snapshotId);\n-      JournalUtils.writeToCheckpoint(sws, getStateMachines());\n+    TermIndex last = getLastAppliedTermIndex();\n+    File tempFile;\n+    try {\n+      tempFile = createTempSnapshotFile();\n+    } catch (IOException e) {\n+      LogUtils.warnWithException(LOG, \"Failed to create temp snapshot file\", e);\n+      return RaftLog.INVALID_LOG_INDEX;\n+    }\n+    LOG.info(\"Taking a snapshot to file {}\", tempFile);\n+    final File snapshotFile = mStorage.getSnapshotFile(last.getTerm(), last.getIndex());\n+    try (DataOutputStream outputStream = new DataOutputStream(new FileOutputStream(tempFile))) {\n+      outputStream.writeLong(snapshotId);\n+      JournalUtils.writeToCheckpoint(outputStream, getStateMachines());\n+    } catch (Exception e) {\n+      tempFile.delete();\n+      LogUtils.warnWithException(LOG, \"Failed to take snapshot: {}\", snapshotId, e);\n+      return RaftLog.INVALID_LOG_INDEX;\n+    }\n+    try {\n+      final MD5Hash digest = MD5FileUtil.computeMd5ForFile(tempFile);\n+      LOG.info(\"Saving digest for snapshot file {}\", snapshotFile);\n+      MD5FileUtil.saveMD5File(snapshotFile, digest);\n+      LOG.info(\"Renaming a snapshot file {} to {}\", tempFile, snapshotFile);\n+      if (!tempFile.renameTo(snapshotFile)) {\n+        tempFile.delete();\n+        LOG.warn(\"Failed to rename snapshot from {} to {}\", tempFile, snapshotFile);\n+        return RaftLog.INVALID_LOG_INDEX;\n+      }\n+      LOG.info(\"Completed snapshot up to SN {} in {}ms\", snapshotId,\n+          System.currentTimeMillis() - mLastSnapshotStartTime);\n     } catch (Exception e) {\n-      ProcessUtils.fatalError(LOG, e, \"Failed to take snapshot: %s\", snapshotId);\n-      throw new RuntimeException(e);\n+      tempFile.delete();\n+      LogUtils.warnWithException(LOG, \"Failed to take snapshot: {}\", snapshotId, e);", "originalCommit": "96131f5114210d2a09e1d955f53ee3296b97fb98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMwODQzOQ==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474308439", "bodyText": "Updated.", "author": "bf8086", "createdAt": "2020-08-20T22:33:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2NjQ5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2Njk3NA==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474166974", "bodyText": "What about if this is not true? What would that happen, and do we want to log some sort of warning when that happens?", "author": "gpang", "createdAt": "2020-08-20T17:50:31Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -314,10 +506,11 @@ public boolean isSnapshotting() {\n     return mSnapshotting;\n   }\n \n-  /**\n-   * Closes the journal state machine, causing all further modification requests to be ignored.\n-   */\n-  public void close() {\n-    mClosed = true;\n+  @Override\n+  public void notifyLeaderChanged(RaftGroupMemberId groupMemberId, RaftPeerId raftPeerId) {\n+    if (mRaftGroupId == groupMemberId.getGroupId()) {", "originalCommit": "96131f5114210d2a09e1d955f53ee3296b97fb98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMwODM4OQ==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474308389", "bodyText": "Yeah this should always be true given we only have one raft group. I will add a warning.", "author": "bf8086", "createdAt": "2020-08-20T22:33:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2Njk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2ODQzOQ==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474168439", "bodyText": "Can you update some of the comments in this file that still say copycat?", "author": "gpang", "createdAt": "2020-08-20T17:53:08Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/RaftPrimarySelector.java", "diffHunk": "@@ -29,33 +23,13 @@\n  */\n @ThreadSafe\n public class RaftPrimarySelector extends AbstractPrimarySelector {", "originalCommit": "96131f5114210d2a09e1d955f53ee3296b97fb98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMwODA4Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474308082", "bodyText": "Updated.", "author": "bf8086", "createdAt": "2020-08-20T22:32:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2ODQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3MDI0MA==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474170240", "bodyText": "If you want to use the exception as the last argument, you will have to use String.format() to print parameters.", "author": "gpang", "createdAt": "2020-08-20T17:56:14Z", "path": "core/server/master/src/main/java/alluxio/master/journal/tool/RaftJournalDumper.java", "diffHunk": "@@ -81,74 +75,69 @@ void dumpJournal() throws Throwable {\n    * way may be stale, but it can still be useful for debugging while the cluster is offline.\n    */\n   private void readFromDir() throws Throwable {\n-    Serializer serializer = RaftJournalSystem.createSerializer();\n-    serializer.resolve(new ClientRequestTypeResolver());\n-    serializer.resolve(new ClientResponseTypeResolver());\n-    serializer.resolve(new ProtocolSerialization());\n-    serializer.resolve(new ServerSerialization());\n-    serializer.resolve(new StorageSerialization());\n-\n-    SingleThreadContext context = new SingleThreadContext(\"readJournal\", serializer);\n-\n-    try {\n-      // Read through the whole journal content, starting from snapshot.\n-      context.execute(this::readCopycatSnapshotFromDir).get();\n-      context.execute(this::readCopycatLogFromDir).get();\n-    } catch (InterruptedException e) {\n-      Thread.currentThread().interrupt();\n-      throw e;\n-    } catch (ExecutionException e) {\n-      throw e.getCause();\n-    } finally {\n-      context.close();\n-    }\n+    // Read through the whole journal content, starting from snapshot.\n+    readRatisSnapshotFromDir();\n+    readRatisLogFromDir();\n   }\n \n-  private void readCopycatLogFromDir() {\n+  private void readRatisLogFromDir() {\n     try (\n         PrintStream out =\n             new PrintStream(new BufferedOutputStream(new FileOutputStream(mJournalEntryFile)));\n-        Log log = Storage.builder().withDirectory(mInputDir).build().openLog(\"copycat\")) {\n-      for (long i = log.firstIndex(); i < log.lastIndex(); i++) {\n-        io.atomix.copycat.server.storage.entry.Entry entry = log.get(i);\n-        if (entry instanceof CommandEntry) {\n-          Command command = ((CommandEntry) entry).getCommand();\n-          if (command instanceof JournalEntryCommand) {\n-            byte[] entryBytes = ((JournalEntryCommand) command).getSerializedJournalEntry();\n-            try {\n-              writeSelected(out, Journal.JournalEntry.parseFrom(entryBytes));\n-            } catch (Exception e) {\n-              throw new RuntimeException(e);\n-            }\n-          }\n-        }\n+        RaftStorage storage = new RaftStorage(getJournalDir(),\n+            RaftServerConstants.StartupOption.REGULAR)) {\n+      List<RaftStorageDirectory.LogPathAndIndex> paths =\n+          storage.getStorageDir().getLogSegmentFiles();\n+      for (RaftStorageDirectory.LogPathAndIndex path : paths) {\n+        final int entryCount = LogSegment.readSegmentFile(path.getPath().toFile(),\n+            path.getStartIndex(), path.getEndIndex(), path.isOpen(),\n+            RaftServerConfigKeys.Log.CorruptionPolicy.EXCEPTION, null, (proto) -> {\n+              if (proto.hasStateMachineLogEntry()) {\n+                try {\n+                  Journal.JournalEntry entry = Journal.JournalEntry.parseFrom(\n+                      proto.getStateMachineLogEntry().getLogData().asReadOnlyByteBuffer());\n+                  writeSelected(out, entry);\n+                } catch (Exception e) {\n+                  throw new RuntimeException(e);\n+                }\n+              }\n+            });\n+        LOG.info(\"Read {} entries from log {}.\", entryCount, path.getPath());\n       }\n     } catch (Exception e) {\n       LOG.error(\"Failed to read logs from journal.\", e);\n     }\n   }\n \n-  private void readCopycatSnapshotFromDir() {\n-    Storage journalStorage = Storage.builder().withDirectory(mInputDir).build();\n-    Snapshot currentSnapshot;\n-    try (final SnapshotStore copycat = journalStorage.openSnapshotStore(\"copycat\")) {\n-      if (copycat.snapshots().isEmpty()) {\n-        LOG.debug(\"No snapshot found.\");\n+  private File getJournalDir() {\n+    return new File(mInputDir, RaftJournalSystem.RAFT_GROUP_ID.toString());\n+  }\n+\n+  private void readRatisSnapshotFromDir() throws IOException {\n+    try (RaftStorage storage = new RaftStorage(getJournalDir(),\n+        RaftServerConstants.StartupOption.REGULAR)) {\n+      SimpleStateMachineStorage stateMachineStorage = new SimpleStateMachineStorage();\n+      stateMachineStorage.init(storage);\n+      SingleFileSnapshotInfo currentSnapshot = stateMachineStorage.getLatestSnapshot();\n+      if (currentSnapshot == null) {\n+        LOG.debug(\"No snapshot found\");\n         return;\n       }\n-      currentSnapshot = copycat.currentSnapshot();\n-    }\n-\n-    SnapshotReader snapshotReader = currentSnapshot.reader();\n-    String checkpointPath = String.format(\"%s-%s-%s\", mCheckpointsDir, currentSnapshot.index(),\n-        currentSnapshot.timestamp());\n-\n-    LOG.debug(\"Reading snapshot-Id: {}\", snapshotReader.readLong());\n-    try (CheckpointInputStream checkpointStream =\n-        new CheckpointInputStream(new SnapshotReaderStream(snapshotReader))) {\n-      readCheckpoint(checkpointStream, Paths.get(checkpointPath));\n-    } catch (Exception e) {\n-      LOG.error(\"Failed to read snapshot from journal.\", e);\n+      final File snapshotFile = currentSnapshot.getFile().getPath().toFile();\n+      String checkpointPath = String.format(\"%s-%s-%s\", mCheckpointsDir, currentSnapshot.getIndex(),\n+          snapshotFile.lastModified());\n+\n+      try (DataInputStream inputStream = new DataInputStream(new FileInputStream(snapshotFile))) {\n+        LOG.debug(\"Reading snapshot-Id: {}\", inputStream.readLong());\n+        try (CheckpointInputStream checkpointStream = new CheckpointInputStream(inputStream)) {\n+          readCheckpoint(checkpointStream, Paths.get(checkpointPath));\n+        } catch (Exception e) {\n+          LOG.error(\"Failed to read snapshot from journal.\", e);\n+        }\n+      } catch (Exception e) {\n+        LOG.error(\"Failed to load snapshot {}\", snapshotFile, e);", "originalCommit": "96131f5114210d2a09e1d955f53ee3296b97fb98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE5NzQ4MQ==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474197481", "bodyText": "IIRC in slf4j we can add one throwable in addition to the string parameters to print full exception stack: http://www.slf4j.org/faq.html#paramException", "author": "bf8086", "createdAt": "2020-08-20T18:46:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3MDI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc0MjI3NQ==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r475742275", "bodyText": "hrmmm, that is strange. I remember our logging messages would ignore the throwable, if we were using the string parameters...", "author": "gpang", "createdAt": "2020-08-24T16:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3MDI0MA=="}], "type": "inlineReview"}, {"oid": "a465214cd1df8477f60f84be4bf45caabe4571c5", "url": "https://github.com/Alluxio/alluxio/commit/a465214cd1df8477f60f84be4bf45caabe4571c5", "message": "Address comments", "committedDate": "2020-08-20T22:32:11Z", "type": "commit"}, {"oid": "170c1eb177f2275b3273521408ba9cef33f75e2a", "url": "https://github.com/Alluxio/alluxio/commit/170c1eb177f2275b3273521408ba9cef33f75e2a", "message": "Improve snapshot error handling", "committedDate": "2020-08-21T18:43:28Z", "type": "commit"}, {"oid": "597403e77e3b6c17806b32645079a5839a7147b2", "url": "https://github.com/Alluxio/alluxio/commit/597403e77e3b6c17806b32645079a5839a7147b2", "message": "improve leader election timing", "committedDate": "2020-08-22T05:42:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc0ODU5NA==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r475748594", "bodyText": "replace copycat in the comment", "author": "gpang", "createdAt": "2020-08-24T16:39:29Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/RaftJournalSystem.java", "diffHunk": "@@ -333,7 +375,7 @@ public synchronized void gainPrimacy() {\n \n   @Override\n   public synchronized void losePrimacy() {\n-    if (!mServer.isRunning()) {\n+    if (mServer.getLifeCycleState() != LifeCycle.State.RUNNING) {\n       // Avoid duplicate shut down copycat server", "originalCommit": "597403e77e3b6c17806b32645079a5839a7147b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgwMDg4Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r475800883", "bodyText": "Updated.", "author": "bf8086", "createdAt": "2020-08-24T18:08:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc0ODU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDcwMQ==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r475134701", "bodyText": "Why using a fixed group id?", "author": "LuQQiu", "createdAt": "2020-08-22T20:18:51Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/RaftJournalSystem.java", "diffHunk": "@@ -124,19 +139,18 @@\n  */\n @ThreadSafe\n public final class RaftJournalSystem extends AbstractJournalSystem {\n+  public static final UUID RAFT_GROUP_ID = UUID.fromString(\"02511d47-d67c-49a3-9011-abb3109a44c1\");", "originalCommit": "597403e77e3b6c17806b32645079a5839a7147b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc5NzMxMA==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r475797310", "bodyText": "The raft group id associate the single state machine we have for master. We need it to be a constant for masters to join the right cluster when they start.", "author": "bf8086", "createdAt": "2020-08-24T18:01:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDcwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDc2Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r475134763", "bodyText": "Change the comment as well?", "author": "LuQQiu", "createdAt": "2020-08-22T20:19:32Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/RaftJournalSystem.java", "diffHunk": "@@ -159,7 +173,7 @@\n   /**\n    * Copycat server.", "originalCommit": "597403e77e3b6c17806b32645079a5839a7147b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgwMDQwMg==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r475800402", "bodyText": "Updated.", "author": "bf8086", "createdAt": "2020-08-24T18:07:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDc2Mw=="}], "type": "inlineReview"}, {"oid": "e4edb2773978627aaea14f54d22d47395e534aba", "url": "https://github.com/Alluxio/alluxio/commit/e4edb2773978627aaea14f54d22d47395e534aba", "message": "Update comments", "committedDate": "2020-08-24T18:06:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgyMjAzOA==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r475822038", "bodyText": "I saw the examples of loading snapshots in initialize and reinitialize, but not sure why.\nAre there guaranteed that all journal entries are included in the latest snapshot? will some journal entries after latest snapshot lost?", "author": "LuQQiu", "createdAt": "2020-08-24T18:45:38Z", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -70,35 +88,158 @@\n   private volatile long mLastPrimaryStartSequenceNumber = 0;\n   private volatile long mNextSequenceNumberToRead = 0;\n   private volatile boolean mSnapshotting = false;\n+  private volatile boolean mIsLeader = false;\n+\n   // The start time of the most recent snapshot\n   private volatile long mLastSnapshotStartTime = 0;\n   /** Used to control applying to masters. */\n   private BufferedJournalApplier mJournalApplier;\n+  private final SimpleStateMachineStorage mStorage = new SimpleStateMachineStorage();\n+  private RaftGroupId mRaftGroupId;\n \n   /**\n-   * @param journals master journals; these journals are still owned by the caller, not by the\n-   *        journal state machine\n-   * @param journalSinks a supplier for journal sinks\n+   * @param journals     master journals; these journals are still owned by the caller, not by the\n+   *                     journal state machine\n+   * @param journalSystem the raft journal system\n    */\n-  public JournalStateMachine(Map<String, RaftJournal> journals,\n-      Supplier<Set<JournalSink>> journalSinks) {\n+  public JournalStateMachine(Map<String, RaftJournal> journals, RaftJournalSystem journalSystem) {\n     mJournals = journals;\n-    mJournalApplier = new BufferedJournalApplier(journals, journalSinks);\n+    mJournalApplier = new BufferedJournalApplier(journals,\n+        () -> journalSystem.getJournalSinks(null));\n     resetState();\n     LOG.info(\"Initialized new journal state machine\");\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  private static <T> CompletableFuture<T> completeExceptionally(Exception e) {\n+    final CompletableFuture<T> future = new CompletableFuture<>();\n+    future.completeExceptionally(e);\n+    return future;\n+  }\n+\n+  @Override\n+  public void initialize(RaftServer server, RaftGroupId groupId,\n+      RaftStorage raftStorage) throws IOException {\n+    getLifeCycle().startAndTransition(() -> {\n+      super.initialize(server, groupId, raftStorage);\n+      mRaftGroupId = groupId;\n+      mStorage.init(raftStorage);\n+      loadSnapshot(mStorage.getLatestSnapshot());", "originalCommit": "e4edb2773978627aaea14f54d22d47395e534aba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkzNjI1MA==", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r475936250", "bodyText": "The snapshot does not have to include all entries. Ratis will catch up on entries after the snapshot before the server starts serving.", "author": "bf8086", "createdAt": "2020-08-24T22:48:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgyMjAzOA=="}], "type": "inlineReview"}]}