{"pr_number": 11535, "pr_title": "Implement interrupt based locking protocol over state-lock", "pr_createdAt": "2020-06-09T22:41:59Z", "pr_url": "https://github.com/Alluxio/alluxio/pull/11535", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NDM1NQ==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r437764355", "bodyText": "@gpang if you pass the last argument of StateLockOptions as 0 (which disables the interrupt-waiters cycle), then the repro will fail as before.", "author": "ggezer", "createdAt": "2020-06-09T22:49:23Z", "path": "tests/src/test/java/alluxio/client/cli/fsadmin/BackupCommandIntegrationTest.java", "diffHunk": "@@ -87,4 +101,54 @@ public void timeout() throws Exception {\n       assertNotEquals(0, errCode);\n     }\n   }\n+\n+  @Test\n+  public void workersLostRepro() throws Exception {\n+    // Grab the master state-change lock via reflection.\n+    MasterProcess masterProcess =\n+        Whitebox.getInternalState(mLocalAlluxioCluster.getLocalAlluxioMaster(), \"mMasterProcess\");\n+    MasterContext masterCtx = Whitebox.getInternalState(masterProcess, \"mContext\");\n+    StateLockManager stateLockManager = masterCtx.getStateLockManager();\n+\n+    BlockMaster blockMaster = masterProcess.getMaster(BlockMaster.class);\n+    Whitebox.setInternalState(blockMaster, \"mMasterContext\", masterCtx);\n+\n+    FileSystemMaster fsMaster = masterProcess.getMaster(FileSystemMaster.class);\n+    Whitebox.setInternalState(fsMaster, \"mMasterContext\", masterCtx);\n+\n+    FileSystem fs = mLocalAlluxioCluster.getClient();\n+    FileOutStream fsOutStr = fs.createFile(new AlluxioURI(\"/test\"));\n+    fsOutStr.write(\"bogus\".getBytes());\n+    // Lock the state-change lock on the master.\n+    LockResource lr =\n+        stateLockManager.lockExclusive(new StateLockOptions(false, false, true, 0, 0, 0, 100));", "originalCommit": "d5b75bfc788ecfaa6d8cbf059542924b0738821c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc4ODY3MQ==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r437788671", "bodyText": "Mark the runnable as @Nullable", "author": "gpang", "createdAt": "2020-06-10T00:07:00Z", "path": "core/common/src/main/java/alluxio/resource/LockResource.java", "diffHunk": "@@ -59,7 +56,25 @@ public LockResource(Lock lock) {\n    * @param useTryLock whether or not use to {@link Lock#tryLock()}\n    */\n   public LockResource(Lock lock, boolean acquireLock, boolean useTryLock) {\n+    this(lock, acquireLock, useTryLock, null);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link LockResource} using the given lock.\n+   *\n+   * This method may use the {@link Lock#tryLock()} method to gain ownership of the locks. The\n+   * reason one might want to use this is to avoid the fairness heuristics within the\n+   * {@link java.util.concurrent.locks.ReentrantReadWriteLock}'s NonFairSync which may block reader\n+   * threads if a writer if the first in the queue.\n+   *\n+   * @param lock the lock to acquire\n+   * @param acquireLock whether to lock the lock\n+   * @param useTryLock whether or not use to {@link Lock#tryLock()}\n+   * @param closeAction the closeable that will be closed along with this lock\n+   */\n+  public LockResource(Lock lock, boolean acquireLock, boolean useTryLock, Runnable closeAction) {", "originalCommit": "69ff6f65f4e88e80951149f0a3d3899da5d8cfff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0NjA0MA==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438246040", "bodyText": "Does this mean backup is in progress? Should we say more in the message?", "author": "gpang", "createdAt": "2020-06-10T16:12:33Z", "path": "core/server/common/src/main/java/alluxio/master/AbstractMaster.java", "diffHunk": "@@ -135,8 +136,14 @@ protected ExecutorService getExecutorService() {\n   public JournalContext createJournalContext() throws UnavailableException {\n     // Use the state change lock for the journal context, since all modifications to journaled\n     // state must happen inside of a journal context.\n-    return new StateChangeJournalContext(mJournal.createJournalContext(),\n-        mMasterContext.stateChangeLock());\n+    LockResource sharedLockResource;\n+    try {\n+      sharedLockResource = mMasterContext.getStateLockManager().lockShared();\n+    } catch (InterruptedException e) {\n+      throw new UnavailableException(\"Failed to acquire state-lock in shared mode.\");", "originalCommit": "5e248a260c674452ccdc7bfad1c202df47033c27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxNzA5MQ==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438417091", "bodyText": "Changed as \"Failed to acquire state-lock due to ongoing backup activity.", "author": "ggezer", "createdAt": "2020-06-10T21:25:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0NjA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0OTIyMQ==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438249221", "bodyText": "why are these all set to IGNORE?", "author": "gpang", "createdAt": "2020-06-10T16:17:27Z", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1296,6 +1296,13 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n           .setScope(Scope.MASTER)\n           .build();\n+  public static final PropertyKey MASTER_BACKUP_STATE_LOCK_SAFE_MODE =\n+      new Builder(Name.MASTER_BACKUP_STATE_LOCK_SAFE_MODE)\n+          .setDefaultValue(false)\n+          .setDescription(\"Ignores client state-lock requests for backup to always take the lock.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)", "originalCommit": "5e248a260c674452ccdc7bfad1c202df47033c27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0OTk4OQ==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438249989", "bodyText": "Can you add what this implies? Like, all new rpcs could block for this long?", "author": "gpang", "createdAt": "2020-06-10T16:18:33Z", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1323,11 +1330,24 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.ENFORCE)\n           .setScope(Scope.MASTER)\n           .build();\n-  public static final PropertyKey MASTER_BACKUP_STATE_LOCK_TIMEOUT =\n-      new Builder(Name.MASTER_BACKUP_STATE_LOCK_TIMEOUT)\n+  public static final PropertyKey MASTER_SHELL_BACKUP_STATE_LOCK_TIMEOUT =\n+      new Builder(Name.MASTER_SHELL_BACKUP_STATE_LOCK_TIMEOUT)\n           .setDefaultValue(\"1m\")\n-          .setDescription(\n-              \"The max duration to try acquiring the state lock for taking backups via shell.\")\n+          .setDescription(\"The max duration to try acquiring the state lock for taking backups .\")", "originalCommit": "5e248a260c674452ccdc7bfad1c202df47033c27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1MDUzNA==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438250534", "bodyText": "I don't think grace period is defined anywhere, so this description is not obvious what it means.", "author": "gpang", "createdAt": "2020-06-10T16:19:17Z", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1323,11 +1330,24 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.ENFORCE)\n           .setScope(Scope.MASTER)\n           .build();\n-  public static final PropertyKey MASTER_BACKUP_STATE_LOCK_TIMEOUT =\n-      new Builder(Name.MASTER_BACKUP_STATE_LOCK_TIMEOUT)\n+  public static final PropertyKey MASTER_SHELL_BACKUP_STATE_LOCK_TIMEOUT =\n+      new Builder(Name.MASTER_SHELL_BACKUP_STATE_LOCK_TIMEOUT)\n           .setDefaultValue(\"1m\")\n-          .setDescription(\n-              \"The max duration to try acquiring the state lock for taking backups via shell.\")\n+          .setDescription(\"The max duration to try acquiring the state lock for taking backups .\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n+          .setScope(Scope.MASTER)\n+          .build();\n+  public static final PropertyKey MASTER_SHELL_BACKUP_STATE_LOCK_INTERRUPT_HOLDERS_AFTER_GRACE =\n+      new Builder(Name.MASTER_SHELL_BACKUP_STATE_LOCK_INTERRUPT_HOLDERS_AFTER_GRACE)\n+          .setDefaultValue(false)\n+          .setDescription(\"Whether to interrupt state-lock holders after grace period.\")", "originalCommit": "5e248a260c674452ccdc7bfad1c202df47033c27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1MDg5OA==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438250898", "bodyText": "I don't think grace period is defined anywhere, so this description is not obvious what it means. Also, it is not clear how it is different from MASTER_SHELL_BACKUP_STATE_LOCK_INTERRUPT_HOLDERS_AFTER_GRACE. Interrupting sounds forceful, so would this parameter be different?", "author": "gpang", "createdAt": "2020-06-10T16:19:58Z", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1323,11 +1330,24 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.ENFORCE)\n           .setScope(Scope.MASTER)\n           .build();\n-  public static final PropertyKey MASTER_BACKUP_STATE_LOCK_TIMEOUT =\n-      new Builder(Name.MASTER_BACKUP_STATE_LOCK_TIMEOUT)\n+  public static final PropertyKey MASTER_SHELL_BACKUP_STATE_LOCK_TIMEOUT =\n+      new Builder(Name.MASTER_SHELL_BACKUP_STATE_LOCK_TIMEOUT)\n           .setDefaultValue(\"1m\")\n-          .setDescription(\n-              \"The max duration to try acquiring the state lock for taking backups via shell.\")\n+          .setDescription(\"The max duration to try acquiring the state lock for taking backups .\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n+          .setScope(Scope.MASTER)\n+          .build();\n+  public static final PropertyKey MASTER_SHELL_BACKUP_STATE_LOCK_INTERRUPT_HOLDERS_AFTER_GRACE =\n+      new Builder(Name.MASTER_SHELL_BACKUP_STATE_LOCK_INTERRUPT_HOLDERS_AFTER_GRACE)\n+          .setDefaultValue(false)\n+          .setDescription(\"Whether to interrupt state-lock holders after grace period.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n+          .setScope(Scope.MASTER)\n+          .build();\n+  public static final PropertyKey MASTER_SHELL_BACKUP_STATE_LOCK_TAKE_AFTER_GRACE =\n+      new Builder(Name.MASTER_SHELL_BACKUP_STATE_LOCK_TAKE_AFTER_GRACE)\n+          .setDefaultValue(false)\n+          .setDescription(\"Whether to take the lock forcefully after grace period.\")", "originalCommit": "5e248a260c674452ccdc7bfad1c202df47033c27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1MTM1NA==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438251354", "bodyText": "I have the same questions as the shell ones.", "author": "gpang", "createdAt": "2020-06-10T16:20:39Z", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1352,6 +1372,20 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n           .setScope(Scope.MASTER)\n           .build();\n+  public static final PropertyKey MASTER_DAILY_BACKUP_STATE_LOCK_INTERRUPT_HOLDERS_AFTER_GRACE =\n+      new Builder(Name.MASTER_DAILY_BACKUP_STATE_LOCK_INTERRUPT_HOLDERS_AFTER_GRACE)\n+          .setDefaultValue(true)\n+          .setDescription(\"Whether to interrupt state-lock holders after grace period.\")", "originalCommit": "5e248a260c674452ccdc7bfad1c202df47033c27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4Njg1MA==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439586850", "bodyText": "@gpang Please re-check all props as I did a major reorg.", "author": "ggezer", "createdAt": "2020-06-12T18:45:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1MTM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1MzU1NQ==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438253555", "bodyText": "what does safe mode mean? I think it would be helpful if there was more documentation on this class as to what various terms mean, and workflow or state transitions.", "author": "gpang", "createdAt": "2020-06-10T16:23:59Z", "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */", "originalCommit": "5e248a260c674452ccdc7bfad1c202df47033c27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMzNTk4Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438335983", "bodyText": "This is when the master is restarted with a special flag for always allowing backups.", "author": "ggezer", "createdAt": "2020-06-10T18:44:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1MzU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1NTAxOQ==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438255019", "bodyText": "Will this message be propagated to clients? If so, can this be more actionable, and/or informative?", "author": "gpang", "createdAt": "2020-06-10T16:26:17Z", "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaiters = new ConcurrentHashSet<>();\n+    mSharedHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      throw new IllegalStateException(\"Cannot acquire lock shared during safe-mode.\");", "originalCommit": "5e248a260c674452ccdc7bfad1c202df47033c27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1NzEzMw==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438257133", "bodyText": "What is the contract for all the threads this set? Clearly we cannot track this perfectly, so will that be a problem? Some threads in the set will not be waiting for the lock yet.", "author": "gpang", "createdAt": "2020-06-10T16:29:41Z", "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaiters = new ConcurrentHashSet<>();\n+    mSharedHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      throw new IllegalStateException(\"Cannot acquire lock shared during safe-mode.\");\n+    }\n+    try {\n+      // Register as waiter.\n+      mSharedWaiters.add(Thread.currentThread());", "originalCommit": "5e248a260c674452ccdc7bfad1c202df47033c27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1NzYyMQ==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438257621", "bodyText": "What is the contract for all the threads this set? Clearly we cannot track this perfectly, so will that be a problem? Some actual lock holders will not be in the holder set yet.\nAlso, there is a point in time that a thread is not in either set. What are the implications of that?\nBasically, since we cannot track the lock holders and waiters in a perfectly consistent way, which inconsistencies are we able to handle?", "author": "gpang", "createdAt": "2020-06-10T16:30:29Z", "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaiters = new ConcurrentHashSet<>();\n+    mSharedHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      throw new IllegalStateException(\"Cannot acquire lock shared during safe-mode.\");\n+    }\n+    try {\n+      // Register as waiter.\n+      mSharedWaiters.add(Thread.currentThread());\n+      // Grab the lock interruptibly.\n+      mStateLock.readLock().lockInterruptibly();\n+    } finally {\n+      // Remove itself from waiters.\n+      mSharedWaiters.remove(Thread.currentThread());\n+    }\n+    // Register as holder.\n+    mSharedHolders.add(Thread.currentThread());", "originalCommit": "5e248a260c674452ccdc7bfad1c202df47033c27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQwODg4OQ==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438408889", "bodyText": "Races around sets are:\n1-Thread interrupted before calling lockInterruptibly()\n* not an issue since lockInterruptbly() API will throw for an already interrupted thread.\n2- Thread interrupted after the lock is acquired (until it's removed from the set):\n* we can reset the interrupt flag after taking the lock.\n3- Thread misses an interrupt for holders before it's added to shared-holders set.\n* not an issue unless this missed thread was going to run a long rpc like ls -R.\n* this can be hardened by accessing each set under a lock, and holding the same lock during interrupt loops.\n4- Thread gets interrupted before returning.\n* after removing from the holders set. we can reset thread's interrupt state.", "author": "ggezer", "createdAt": "2020-06-10T21:07:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1NzYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxMDY2MQ==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438410661", "bodyText": "Overall I think below will suffice in terms of restraining the inconsistencies that can arise:\na- locking set add/remove/iterate operations\nb- resetting caller thread's interrupted state as provided in 2-4.\nFor b; to avoid interfering with the system shutdown,  we can keep track of threads we ourselves interrupted and run the reset logic only for those.", "author": "ggezer", "createdAt": "2020-06-10T21:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1NzYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MzE3NQ==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438463175", "bodyText": "hrmmm, this seems tricky and hard to guarantee correct behavior...", "author": "gpang", "createdAt": "2020-06-10T23:34:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1NzYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2Mzg3NA==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438463874", "bodyText": "what is \"correct behavior\" ?", "author": "ggezer", "createdAt": "2020-06-10T23:37:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1NzYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3MjgwOQ==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438472809", "bodyText": "Any inconsistency could lead to two faulty actions:\n1- interrupt a thread when not intended\n2- don't interrupt a thread when required\n2 is covered by the interrupt-cycle.\n1 can be hardened by proposed locking over sets. Then it can only happen at the end of write-lock and that's acceptable.", "author": "ggezer", "createdAt": "2020-06-11T00:08:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1NzYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUyODEyNw==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438528127", "bodyText": "@gpang I merged waiters and holders sets as we can reliably keep them at sync without heavy locking over the sets.\nIn the current state, I don't see any unacceptable inconsistency.\n\nthe interrupt could be missed for a thread: this will be handled by the next tick.\nthe interrupted thread might already have released the lock: this will be ignored as a victim of backup. (This can be fixed by keeping track of which threads the manager has interrupted and reset the flags based on that. I don't think that's necessary for the overall scenario though.)\n\nWDYT?", "author": "ggezer", "createdAt": "2020-06-11T03:53:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1NzYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI2MDI4Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438260282", "bodyText": "Is this supposed to be shell?", "author": "gpang", "createdAt": "2020-06-10T16:34:43Z", "path": "core/server/master/src/main/java/alluxio/master/backup/BackupLeaderRole.java", "diffHunk": "@@ -98,10 +100,10 @@\n   public BackupLeaderRole(CoreMasterContext masterContext) {\n     super(masterContext);\n     LOG.info(\"Creating backup-leader role.\");\n-    // Store state lock for pausing state change when necessary.\n-    mStatePauseLock = masterContext.pauseStateLock();\n+    // Store state lock manager pausing state change when necessary.\n+    mStateLockManager = masterContext.getStateLockManager();\n     // Read properties.\n-    mStateLockTimeout = ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_TIMEOUT);\n+    mStateLockTimeout = ServerConfiguration.getMs(PropertyKey.MASTER_SHELL_BACKUP_STATE_LOCK_TIMEOUT);", "originalCommit": "5e248a260c674452ccdc7bfad1c202df47033c27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM5NTg1Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438395853", "bodyText": "Removed this all together.", "author": "ggezer", "createdAt": "2020-06-10T20:41:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI2MDI4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI2MTA5NA==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438261094", "bodyText": "Can we have more information in this message?", "author": "gpang", "createdAt": "2020-06-10T16:35:58Z", "path": "core/server/master/src/main/java/alluxio/master/meta/DefaultMetaMaster.java", "diffHunk": "@@ -382,11 +370,14 @@ public BackupStatus getBackupStatus(BackupStatusPRequest statusPRequest) throws\n \n   @Override\n   public String checkpoint() throws IOException {\n-    try (LockResource lr = new LockResource(mMasterContext.pauseStateLock())) {\n+    try (LockResource lr =\n+        mMasterContext.getStateLockManager().lockExclusive(StateLockOptions.defaults())) {\n       mJournalSystem.checkpoint();\n+      return NetworkAddressUtils.getConnectHost(NetworkAddressUtils.ServiceType.MASTER_RPC,\n+          ServerConfiguration.global());\n+    } catch (Exception e) {\n+      throw new IOException(\"Failed to take a checkpoint\", e);", "originalCommit": "5e248a260c674452ccdc7bfad1c202df47033c27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQyMDIzOQ==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438420239", "bodyText": "This is unexpected with defaults() options. So I can't know why it failed.", "author": "ggezer", "createdAt": "2020-06-10T21:32:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI2MTA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDIzNw==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438460237", "bodyText": "does safemode never get reset? That means the master can ONLY take a backup and never service clients, even when it is primary?", "author": "gpang", "createdAt": "2020-06-10T23:24:40Z", "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaiters = new ConcurrentHashSet<>();\n+    mSharedHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);", "originalCommit": "f1448e8416bad07da0b959a416f08a31f6fe2fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4MTE2Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438481162", "bodyText": "We can make it something that resets but need to coordinate this between masters.\nRight now it's just a crude failsafe.", "author": "ggezer", "createdAt": "2020-06-11T00:40:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDIzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMjQwMQ==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439112401", "bodyText": "This could block for a long time, and thus block other RPCs (including heartbeats) for a long time?", "author": "gpang", "createdAt": "2020-06-11T22:48:57Z", "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for or holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedWaitersAndHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaitersAndHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * Calling thread might be interrupted by this manager,\n+   * if it found to be waiting for the shared lock under when:\n+   *  - backup is exiting grace-cycle and entering the lock permanently\n+   *  - backup is in progress\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      String safeModeMsg = String.format(\n+          \"Cannot acquire lock shared during backup safe-mode. \"\n+              + \"Please configure %s as 'false' in order to disable the backup safe-mode.\",\n+          PropertyKey.Name.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+      throw new IllegalStateException(safeModeMsg);\n+    }\n+    // Register thread for interrupt cycle.\n+    mSharedWaitersAndHolders.add(Thread.currentThread());\n+    // Grab the lock interruptibly.\n+    mStateLock.readLock().lockInterruptibly();\n+    // Return the resource.\n+    // Register an action to remove the thread from holders registry before releasing the lock.\n+    return new LockResource(mStateLock.readLock(), false, false, () -> {\n+      mSharedWaitersAndHolders.remove(Thread.currentThread());\n+    });\n+  }\n+\n+  /**\n+   * Locks the state exclusively.\n+   *\n+   * @param lockOptions exclusive lock options\n+   * @return the lock resource\n+   * @throws TimeoutException if locking times out\n+   * @throws InterruptedException if interrupting during locking\n+   */\n+  public LockResource lockExclusive(StateLockOptions lockOptions)\n+      throws TimeoutException, InterruptedException {\n+    // Run the grace cycle.\n+    boolean lockAcquired = false;\n+    if (lockOptions.waitGraceCycle()) {\n+      long deadlineMs = System.currentTimeMillis() + lockOptions.getGraceCycleTimeoutMs();\n+      while (System.currentTimeMillis() < deadlineMs) {\n+        if (mStateLock.writeLock().tryLock(lockOptions.getGraceCycleTryMs(), TimeUnit.MILLISECONDS)) {\n+          lockAcquired = true;\n+          break;\n+        } else {\n+          long remainingWaitMs = deadlineMs - System.currentTimeMillis();\n+          if (remainingWaitMs > 0) {\n+            Thread.sleep(Math.min(lockOptions.getGraceCycleSleepMs(), remainingWaitMs));\n+          }\n+        }\n+      }\n+    }\n+    if (lockAcquired) { // Lock was acquired within grace-cycle.\n+      scheduleInterruptCycle(lockOptions.getInterruptWaitersInternalMs());\n+    } else { // Lock couldn't be acquired by grace-cycle.\n+      if (!lockOptions.lockAfterGraceCycle()) {\n+        throw new TimeoutException(\n+                ExceptionMessage.STATE_LOCK_TIMED_OUT.getMessage(lockOptions.getGraceCycleTimeoutMs()));\n+      }\n+      if (lockOptions.interruptCycleAfterGraceCycle()) {\n+        // Schedule interrupt cycle before entering the lock because it might wait in the queue.\n+        scheduleInterruptCycle(lockOptions.getInterruptWaitersInternalMs());\n+      }\n+      // Own the lock.\n+      mStateLock.writeLock().lock();", "originalCommit": "b0550f44dfad36238ad1210eee202232e1c02396", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExNDk2OA==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439114968", "bodyText": "Yes but interrupt cycle is activated before this point.", "author": "ggezer", "createdAt": "2020-06-11T22:56:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMjQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMjk4OQ==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439112989", "bodyText": "Is there any danger that this mInterrupterFuture points to a different future than the one that was started?", "author": "gpang", "createdAt": "2020-06-11T22:50:45Z", "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for or holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedWaitersAndHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaitersAndHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * Calling thread might be interrupted by this manager,\n+   * if it found to be waiting for the shared lock under when:\n+   *  - backup is exiting grace-cycle and entering the lock permanently\n+   *  - backup is in progress\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      String safeModeMsg = String.format(\n+          \"Cannot acquire lock shared during backup safe-mode. \"\n+              + \"Please configure %s as 'false' in order to disable the backup safe-mode.\",\n+          PropertyKey.Name.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+      throw new IllegalStateException(safeModeMsg);\n+    }\n+    // Register thread for interrupt cycle.\n+    mSharedWaitersAndHolders.add(Thread.currentThread());\n+    // Grab the lock interruptibly.\n+    mStateLock.readLock().lockInterruptibly();\n+    // Return the resource.\n+    // Register an action to remove the thread from holders registry before releasing the lock.\n+    return new LockResource(mStateLock.readLock(), false, false, () -> {\n+      mSharedWaitersAndHolders.remove(Thread.currentThread());\n+    });\n+  }\n+\n+  /**\n+   * Locks the state exclusively.\n+   *\n+   * @param lockOptions exclusive lock options\n+   * @return the lock resource\n+   * @throws TimeoutException if locking times out\n+   * @throws InterruptedException if interrupting during locking\n+   */\n+  public LockResource lockExclusive(StateLockOptions lockOptions)\n+      throws TimeoutException, InterruptedException {\n+    // Run the grace cycle.\n+    boolean lockAcquired = false;\n+    if (lockOptions.waitGraceCycle()) {\n+      long deadlineMs = System.currentTimeMillis() + lockOptions.getGraceCycleTimeoutMs();\n+      while (System.currentTimeMillis() < deadlineMs) {\n+        if (mStateLock.writeLock().tryLock(lockOptions.getGraceCycleTryMs(), TimeUnit.MILLISECONDS)) {\n+          lockAcquired = true;\n+          break;\n+        } else {\n+          long remainingWaitMs = deadlineMs - System.currentTimeMillis();\n+          if (remainingWaitMs > 0) {\n+            Thread.sleep(Math.min(lockOptions.getGraceCycleSleepMs(), remainingWaitMs));\n+          }\n+        }\n+      }\n+    }\n+    if (lockAcquired) { // Lock was acquired within grace-cycle.\n+      scheduleInterruptCycle(lockOptions.getInterruptWaitersInternalMs());\n+    } else { // Lock couldn't be acquired by grace-cycle.\n+      if (!lockOptions.lockAfterGraceCycle()) {\n+        throw new TimeoutException(\n+                ExceptionMessage.STATE_LOCK_TIMED_OUT.getMessage(lockOptions.getGraceCycleTimeoutMs()));\n+      }\n+      if (lockOptions.interruptCycleAfterGraceCycle()) {\n+        // Schedule interrupt cycle before entering the lock because it might wait in the queue.\n+        scheduleInterruptCycle(lockOptions.getInterruptWaitersInternalMs());\n+      }\n+      // Own the lock.\n+      mStateLock.writeLock().lock();\n+    }\n+\n+    // We have the lock, wrap it and return.\n+    // Register an action for cancelling the interrupt cycle before releasing the lock.\n+    return new LockResource(mStateLock.writeLock(), false, false, () -> {\n+      // Before releasing the write-lock, deactivate interrupter if active.\n+      if (mInterrupterFuture != null && !mInterrupterFuture.isDone()) {", "originalCommit": "b0550f44dfad36238ad1210eee202232e1c02396", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExNTE2OQ==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439115169", "bodyText": "It's not possible due to exclusive locking.", "author": "ggezer", "createdAt": "2020-06-11T22:57:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMjk4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEyNjQ2Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439126462", "bodyText": "Need to support multiple exclusive lockers though. This PR should cover that. To do that properly, the interrupt cycle should be owned by the state-lock-manager.", "author": "ggezer", "createdAt": "2020-06-11T23:35:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMjk4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NjM1OQ==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439586359", "bodyText": "This is fixed now.", "author": "ggezer", "createdAt": "2020-06-12T18:44:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMjk4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMzI0Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439113246", "bodyText": "I don't know how this should be used by users.", "author": "gpang", "createdAt": "2020-06-11T22:51:36Z", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1296,6 +1296,13 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n           .setScope(Scope.MASTER)\n           .build();\n+  public static final PropertyKey MASTER_BACKUP_STATE_LOCK_SAFE_MODE =\n+      new Builder(Name.MASTER_BACKUP_STATE_LOCK_SAFE_MODE)\n+          .setDefaultValue(false)\n+          .setDescription(\"Ignores client state-lock requests for backup to always take the lock.\")", "originalCommit": "b0550f44dfad36238ad1210eee202232e1c02396", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExNTU4NA==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439115584", "bodyText": "The typical scenario is when you can't take backups (shell/daily) due to a never-ending RPC. Restarting Alluxio master with this will guarantee that backup can take the lock and continue.", "author": "ggezer", "createdAt": "2020-06-11T22:59:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMzI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUxNjMyMQ==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439516321", "bodyText": "@ggezer\nYes, but it will never service RPCs. That will make this master unusable, right? Why would a user want an unusable master?", "author": "gpang", "createdAt": "2020-06-12T16:16:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMzI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU3OTQ2MA==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439579460", "bodyText": "The point is not \"wanting an unusable master\", It's \"wanting a backup\".\n@calvinjia @ns1123 WDYT about this mode?", "author": "ggezer", "createdAt": "2020-06-12T18:28:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMzI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU5MDg5MQ==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439590891", "bodyText": "I'd rather instead of being a server side property, that this is an option on the fsadmin backup command. That way a backup can be forced by an admin in a dire situation.", "author": "ns1123", "createdAt": "2020-06-12T18:54:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMzI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2MDEwNQ==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439660105", "bodyText": "@ns1123 This PR already makes the changes for doing the best we can in taking the backup. This particular property is introducing a new maintenance mode under which backup will be \"guaranteed\".", "author": "ggezer", "createdAt": "2020-06-12T22:03:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMzI0Ng=="}], "type": "inlineReview"}, {"oid": "f7bb22b60722c34eddc983adb69c52dbef8ced8c", "url": "https://github.com/Alluxio/alluxio/commit/f7bb22b60722c34eddc983adb69c52dbef8ced8c", "message": "Implement interrupt based locking protocol over state-lock", "committedDate": "2020-06-12T18:43:29Z", "type": "forcePushed"}, {"oid": "6c5f9387aa07165072123451c226a506636b3701", "url": "https://github.com/Alluxio/alluxio/commit/6c5f9387aa07165072123451c226a506636b3701", "message": "Implement interrupt based locking protocol over state-lock", "committedDate": "2020-06-12T22:00:17Z", "type": "forcePushed"}, {"oid": "02b7f612ff46a4e250127a9ebf1efeb334ec6465", "url": "https://github.com/Alluxio/alluxio/commit/02b7f612ff46a4e250127a9ebf1efeb334ec6465", "message": "Implement interrupt based locking protocol over state-lock", "committedDate": "2020-06-12T22:06:41Z", "type": "forcePushed"}, {"oid": "942701b545fbda91810654b814e7436b40172ff3", "url": "https://github.com/Alluxio/alluxio/commit/942701b545fbda91810654b814e7436b40172ff3", "message": "Implement interrupt based locking protocol over state-lock", "committedDate": "2020-06-12T22:52:56Z", "type": "commit"}, {"oid": "942701b545fbda91810654b814e7436b40172ff3", "url": "https://github.com/Alluxio/alluxio/commit/942701b545fbda91810654b814e7436b40172ff3", "message": "Implement interrupt based locking protocol over state-lock", "committedDate": "2020-06-12T22:52:56Z", "type": "forcePushed"}, {"oid": "9a6517d86e54ddb6d3aea12e86429dc26cab3e2b", "url": "https://github.com/Alluxio/alluxio/commit/9a6517d86e54ddb6d3aea12e86429dc26cab3e2b", "message": "Reduce grace modes to TIMEOUT/FORCED", "committedDate": "2020-06-15T20:22:00Z", "type": "commit"}, {"oid": "2f1276491e39a7fdd110881a8d3f8407355b921d", "url": "https://github.com/Alluxio/alluxio/commit/2f1276491e39a7fdd110881a8d3f8407355b921d", "message": "Make guaranteed mode bound to life-cycle of master", "committedDate": "2020-06-15T20:27:45Z", "type": "commit"}, {"oid": "9203ceab6a25f945fbfccf87a107784003aba9eb", "url": "https://github.com/Alluxio/alluxio/commit/9203ceab6a25f945fbfccf87a107784003aba9eb", "message": "Test fixes", "committedDate": "2020-06-15T20:31:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ2MTkyMQ==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r440461921", "bodyText": "Will it be easy to search for log message, where will this be logged?", "author": "calvinjia", "createdAt": "2020-06-15T21:38:49Z", "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock. */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for or holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedWaitersAndHolders;\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+\n+  /** Whether exclusive locking will trigger interrupt-cycle. */\n+  private boolean mInterruptCycleEnabled;\n+  /** Interval at which threads around shared-lock will be interrupted during interrupt-cycle. */\n+  private long mInterruptCycleInterval;\n+  /** Used to synchronize execution/termination of interrupt-cycle. */\n+  private Lock mInterruptCycleLock = new ReentrantLock(true);\n+  /** How many active exclusive locking attempts. */\n+  private volatile long mInterruptCycleRefCount = 0;\n+  /** The future for the active interrupt cycle. */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** This is the deadline for forcing the lock. */\n+  private long mForcedDurationMs;\n+\n+  // TODO(ggezer): Make it bound to a process start/stop cycle.\n+  /** Shared locking requests will fail until this time. */\n+  private long mExclusiveOnlyDeadlineMs = -1;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaitersAndHolders = new ConcurrentHashSet<>();\n+    // Init members.\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+    // Read properties.\n+    mInterruptCycleEnabled = ServerConfiguration\n+        .getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_INTERRUPT_CYCLE_ENABLED);\n+    mInterruptCycleInterval =\n+        ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_INTERRUPT_CYCLE_INTERVAL);\n+    mForcedDurationMs =\n+        ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_FORCED_DURATION);\n+    // Validate properties.\n+    Preconditions.checkArgument(mInterruptCycleInterval > 0,\n+        \"Interrupt-cycle interval should be greater than 0.\");\n+  }\n+\n+  /**\n+   * This is called by owning process in order to signal that\n+   * the state is read completely and masters are started.\n+   *\n+   * This triggers the beginning of exclusive-only maintenance mode for the state-lock.\n+   * Note: Calling it multiple times does not reset the maintenance window.\n+   */\n+  public void mastersStartedCallback() {\n+    if (mExclusiveOnlyDeadlineMs == -1) {\n+      mExclusiveOnlyDeadlineMs = System.currentTimeMillis()\n+          + ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_EXCLUSIVE_DURATION);\n+    }\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * Calling thread might be interrupted by this manager,\n+   * if it found to be waiting for the shared lock under when:\n+   *  - backup is exiting grace-cycle and entering the lock permanently\n+   *  - backup is in progress\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (System.currentTimeMillis() < mExclusiveOnlyDeadlineMs) {\n+      String safeModeMsg = String.format(\n+          \"Master still in exclusive-only phase for the state-lock.\"\n+              + \"Please see documentation for %s.\",\n+          PropertyKey.Name.MASTER_BACKUP_STATE_LOCK_EXCLUSIVE_DURATION);\n+      throw new IllegalStateException(safeModeMsg);\n+    }\n+    // Register thread for interrupt cycle.\n+    mSharedWaitersAndHolders.add(Thread.currentThread());\n+    // Grab the lock interruptibly.\n+    mStateLock.readLock().lockInterruptibly();\n+    // Return the resource.\n+    // Register an action to remove the thread from holders registry before releasing the lock.\n+    return new LockResource(mStateLock.readLock(), false, false, () -> {\n+      mSharedWaitersAndHolders.remove(Thread.currentThread());\n+    });\n+  }\n+\n+  /**\n+   * Locks the state exclusively.\n+   *\n+   * @param lockOptions exclusive lock options\n+   * @return the lock resource\n+   * @throws TimeoutException if locking times out\n+   * @throws InterruptedException if interrupting during locking\n+   */\n+  public LockResource lockExclusive(StateLockOptions lockOptions)\n+      throws TimeoutException, InterruptedException {\n+    // Run the grace cycle.\n+    StateLockOptions.GraceMode graceMode = lockOptions.getGraceMode();\n+    boolean lockAcquired = false;\n+    long deadlineMs = System.currentTimeMillis() + lockOptions.getGraceCycleTimeoutMs();\n+    while (System.currentTimeMillis() < deadlineMs) {\n+      if (mStateLock.writeLock().tryLock(lockOptions.getGraceCycleTryMs(), TimeUnit.MILLISECONDS)) {\n+        lockAcquired = true;\n+        break;\n+      } else {\n+        long remainingWaitMs = deadlineMs - System.currentTimeMillis();\n+        if (remainingWaitMs > 0) {\n+          Thread.sleep(Math.min(lockOptions.getGraceCycleSleepMs(), remainingWaitMs));\n+        }\n+      }\n+    }\n+    if (lockAcquired) { // Lock was acquired within grace-cycle.\n+      activateInterruptCycle();\n+    } else { // Lock couldn't be acquired by grace-cycle.\n+      if (graceMode == StateLockOptions.GraceMode.TIMEOUT) {\n+        throw new TimeoutException(\n+            ExceptionMessage.STATE_LOCK_TIMED_OUT.getMessage(lockOptions.getGraceCycleTimeoutMs()));", "originalCommit": "9203ceab6a25f945fbfccf87a107784003aba9eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAzNDE1NA==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r441034154", "bodyText": "This will end up being caught at RpcUtils.callAndReturn, which prints an error-log for runtime exceptions.", "author": "ggezer", "createdAt": "2020-06-16T17:50:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ2MTkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ2Mjc4OQ==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r440462789", "bodyText": "Would be helpful to state how much longer the deadline is", "author": "calvinjia", "createdAt": "2020-06-15T21:40:49Z", "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock. */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for or holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedWaitersAndHolders;\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+\n+  /** Whether exclusive locking will trigger interrupt-cycle. */\n+  private boolean mInterruptCycleEnabled;\n+  /** Interval at which threads around shared-lock will be interrupted during interrupt-cycle. */\n+  private long mInterruptCycleInterval;\n+  /** Used to synchronize execution/termination of interrupt-cycle. */\n+  private Lock mInterruptCycleLock = new ReentrantLock(true);\n+  /** How many active exclusive locking attempts. */\n+  private volatile long mInterruptCycleRefCount = 0;\n+  /** The future for the active interrupt cycle. */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** This is the deadline for forcing the lock. */\n+  private long mForcedDurationMs;\n+\n+  // TODO(ggezer): Make it bound to a process start/stop cycle.\n+  /** Shared locking requests will fail until this time. */\n+  private long mExclusiveOnlyDeadlineMs = -1;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaitersAndHolders = new ConcurrentHashSet<>();\n+    // Init members.\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+    // Read properties.\n+    mInterruptCycleEnabled = ServerConfiguration\n+        .getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_INTERRUPT_CYCLE_ENABLED);\n+    mInterruptCycleInterval =\n+        ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_INTERRUPT_CYCLE_INTERVAL);\n+    mForcedDurationMs =\n+        ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_FORCED_DURATION);\n+    // Validate properties.\n+    Preconditions.checkArgument(mInterruptCycleInterval > 0,\n+        \"Interrupt-cycle interval should be greater than 0.\");\n+  }\n+\n+  /**\n+   * This is called by owning process in order to signal that\n+   * the state is read completely and masters are started.\n+   *\n+   * This triggers the beginning of exclusive-only maintenance mode for the state-lock.\n+   * Note: Calling it multiple times does not reset the maintenance window.\n+   */\n+  public void mastersStartedCallback() {\n+    if (mExclusiveOnlyDeadlineMs == -1) {\n+      mExclusiveOnlyDeadlineMs = System.currentTimeMillis()\n+          + ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_EXCLUSIVE_DURATION);\n+    }\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * Calling thread might be interrupted by this manager,\n+   * if it found to be waiting for the shared lock under when:\n+   *  - backup is exiting grace-cycle and entering the lock permanently\n+   *  - backup is in progress\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (System.currentTimeMillis() < mExclusiveOnlyDeadlineMs) {\n+      String safeModeMsg = String.format(\n+          \"Master still in exclusive-only phase for the state-lock.\"\n+              + \"Please see documentation for %s.\",", "originalCommit": "9203ceab6a25f945fbfccf87a107784003aba9eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAzOTQ4Nw==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r441039487", "bodyText": "Added more traces b872473", "author": "ggezer", "createdAt": "2020-06-16T17:59:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ2Mjc4OQ=="}], "type": "inlineReview"}, {"oid": "b8724736bbe4463dadc8920db951ab867fb3cd4f", "url": "https://github.com/Alluxio/alluxio/commit/b8724736bbe4463dadc8920db951ab867fb3cd4f", "message": "Add more traces for exclusive-only mode", "committedDate": "2020-06-16T17:58:29Z", "type": "commit"}, {"oid": "ffcb98861454fb7435673273bbf3b109dc8917d2", "url": "https://github.com/Alluxio/alluxio/commit/ffcb98861454fb7435673273bbf3b109dc8917d2", "message": "Add UT for exclusive-only phase", "committedDate": "2020-06-16T18:25:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3NjQ2MQ==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r441076461", "bodyText": "I think this is stale, since we are still using tryLock.", "author": "gpang", "createdAt": "2020-06-16T19:00:43Z", "path": "core/server/common/src/main/java/alluxio/master/StateLockOptions.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+\n+import java.util.concurrent.locks.Lock;\n+\n+/**\n+ * Used to define state-lock options for taking it exclusively.\n+ * A typical framework for obtaining the state-lock exclusively is:\n+ *  1- Run a grace-cycle:\n+ *      cycle of {@link Lock#tryLock()} - {@link Thread#sleep(long)} calls.\n+ *  2- Interrupt state-lock holders if grace-cycle fails.\n+ *  3- Take the lock using {@link Lock#lock()}", "originalCommit": "ffcb98861454fb7435673273bbf3b109dc8917d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3NjczNA==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r441076734", "bodyText": "This is actually something like \"continually interrupt state-lock holders and waiters\", right?", "author": "gpang", "createdAt": "2020-06-16T19:01:13Z", "path": "core/server/common/src/main/java/alluxio/master/StateLockOptions.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+\n+import java.util.concurrent.locks.Lock;\n+\n+/**\n+ * Used to define state-lock options for taking it exclusively.\n+ * A typical framework for obtaining the state-lock exclusively is:\n+ *  1- Run a grace-cycle:\n+ *      cycle of {@link Lock#tryLock()} - {@link Thread#sleep(long)} calls.\n+ *  2- Interrupt state-lock holders if grace-cycle fails.", "originalCommit": "ffcb98861454fb7435673273bbf3b109dc8917d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA5MTg2NA==", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r441091864", "bodyText": "I think we should be more explicit here. This will reject all RPCs which need to take the state-lock, which is most client RPCs.\nShould we also mention that this can be useful to guarantee a window on restart to initiate a backup?", "author": "gpang", "createdAt": "2020-06-16T19:29:24Z", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1301,6 +1301,39 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n           .setScope(Scope.MASTER)\n           .build();\n+  public static final PropertyKey MASTER_BACKUP_STATE_LOCK_EXCLUSIVE_DURATION =\n+      new Builder(Name.MASTER_BACKUP_STATE_LOCK_EXCLUSIVE_DURATION)\n+          .setDefaultValue(\"0ms\")\n+          .setDescription(\"Alluxio master will allow only exclusive locking of \"\n+              + \"the state-lock for this duration. This duration starts after masters \"", "originalCommit": "ffcb98861454fb7435673273bbf3b109dc8917d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "713cd794fbfe4bce27de455ff8d1b2bed062f8ea", "url": "https://github.com/Alluxio/alluxio/commit/713cd794fbfe4bce27de455ff8d1b2bed062f8ea", "message": "PR feedback", "committedDate": "2020-06-16T20:11:43Z", "type": "commit"}, {"oid": "b5329c0ccd3f30344719fe1316c391be9a576650", "url": "https://github.com/Alluxio/alluxio/commit/b5329c0ccd3f30344719fe1316c391be9a576650", "message": "Add integration test for exclusive-only phase", "committedDate": "2020-06-16T20:12:02Z", "type": "commit"}]}