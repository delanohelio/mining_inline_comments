{"pr_number": 11310, "pr_title": "Release resources properly within Worker ReadHandler", "pr_createdAt": "2020-04-17T10:36:11Z", "pr_url": "https://github.com/Alluxio/alluxio/pull/11310", "timeline": [{"oid": "22b0e21a4b905f5d671fb2a53feced9e5045468f", "url": "https://github.com/Alluxio/alluxio/commit/22b0e21a4b905f5d671fb2a53feced9e5045468f", "message": "Clean resources properly within ReadHandler\n\nBy cleaning up the resources in the correct way, we avoid one major\nissue, which is forgetting to unlock a block when the call fails.\n\nFixes #11258", "committedDate": "2020-04-17T10:34:29Z", "type": "commit"}, {"oid": "557484bf6cf6923dc55ca7bfe63297dab02300c7", "url": "https://github.com/Alluxio/alluxio/commit/557484bf6cf6923dc55ca7bfe63297dab02300c7", "message": "Add licenses, fix checkstyle", "committedDate": "2020-04-17T17:22:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NTg2MA==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r410395860", "bodyText": "This isn't necessarily due to rejected execution since we catch exception on line 157?", "author": "calvinjia", "createdAt": "2020-04-17T18:23:44Z", "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -126,14 +152,36 @@ public void onNext(alluxio.grpc.ReadRequest request) {\n       mContext.setPosReceived(mContext.getRequest().getStart());\n       mDataReaderExecutor.submit(createDataReader(mContext, mResponseObserver));\n       mContext.setDataReaderActive(true);\n+    } catch (RejectedExecutionException e) {\n+      handleStreamEndingException(e, Status.RESOURCE_EXHAUSTED);\n     } catch (Exception e) {\n-      LogUtils.warnWithException(LOG, \"Exception occurred while processing read request {}.\",\n-          request, e);\n-      mSerializingExecutor.execute(() -> mResponseObserver\n-          .onError(AlluxioStatusException.fromCheckedException(e).toGrpcStatusException()));\n+      handleStreamEndingException(\n+          AlluxioStatusException.fromThrowable(e).toGrpcStatusException());\n     }\n   }\n \n+  private void handleStreamEndingException(StatusException e) {\n+    handleStreamEndingException(e, e.getStatus());\n+  }\n+\n+  // In this case, we hit an exception that does not allow us to proceed further\n+  private void handleStreamEndingException(Exception e, Status status) {\n+    // The executor is too busy to handle our requests. The stream should error.", "originalCommit": "557484bf6cf6923dc55ca7bfe63297dab02300c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3MTIwMw==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r410471203", "bodyText": "you are right. In a previous version of the code I had called this method handleRejectedExecutionException :)", "author": "ZacBlanco", "createdAt": "2020-04-17T21:09:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NTg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxNTMxMw==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r410515313", "bodyText": "fixed", "author": "ZacBlanco", "createdAt": "2020-04-17T23:36:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NTg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NjkzOQ==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r410396939", "bodyText": "One line", "author": "calvinjia", "createdAt": "2020-04-17T18:25:51Z", "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -126,14 +152,36 @@ public void onNext(alluxio.grpc.ReadRequest request) {\n       mContext.setPosReceived(mContext.getRequest().getStart());\n       mDataReaderExecutor.submit(createDataReader(mContext, mResponseObserver));\n       mContext.setDataReaderActive(true);\n+    } catch (RejectedExecutionException e) {\n+      handleStreamEndingException(e, Status.RESOURCE_EXHAUSTED);\n     } catch (Exception e) {\n-      LogUtils.warnWithException(LOG, \"Exception occurred while processing read request {}.\",\n-          request, e);\n-      mSerializingExecutor.execute(() -> mResponseObserver\n-          .onError(AlluxioStatusException.fromCheckedException(e).toGrpcStatusException()));\n+      handleStreamEndingException(\n+          AlluxioStatusException.fromThrowable(e).toGrpcStatusException());\n     }\n   }\n \n+  private void handleStreamEndingException(StatusException e) {\n+    handleStreamEndingException(e, e.getStatus());\n+  }\n+\n+  // In this case, we hit an exception that does not allow us to proceed further\n+  private void handleStreamEndingException(Exception e, Status status) {\n+    // The executor is too busy to handle our requests. The stream should error.\n+    Long sessionId = mContext.getRequest() == null ? null : mContext.getRequest().getSessionId();\n+    LogUtils.warnWithException(LOG, \"handling RejectedExecutionException: sessionId: {}\",\n+        sessionId, e);\n+    AlluxioStatusException statusExc =", "originalCommit": "557484bf6cf6923dc55ca7bfe63297dab02300c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxNTMyOQ==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r410515329", "bodyText": "fixed", "author": "ZacBlanco", "createdAt": "2020-04-17T23:36:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NjkzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NjA0OQ==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r410466049", "bodyText": "Previously we do all the work in a separate thread ensuring abstract read handler methods execute fairly quickly. Will executing the data reader on this thread cause significant slowdowns?", "author": "calvinjia", "createdAt": "2020-04-17T20:57:23Z", "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -126,14 +152,36 @@ public void onNext(alluxio.grpc.ReadRequest request) {\n       mContext.setPosReceived(mContext.getRequest().getStart());\n       mDataReaderExecutor.submit(createDataReader(mContext, mResponseObserver));\n       mContext.setDataReaderActive(true);\n+    } catch (RejectedExecutionException e) {\n+      handleStreamEndingException(e, Status.RESOURCE_EXHAUSTED);\n     } catch (Exception e) {\n-      LogUtils.warnWithException(LOG, \"Exception occurred while processing read request {}.\",\n-          request, e);\n-      mSerializingExecutor.execute(() -> mResponseObserver\n-          .onError(AlluxioStatusException.fromCheckedException(e).toGrpcStatusException()));\n+      handleStreamEndingException(\n+          AlluxioStatusException.fromThrowable(e).toGrpcStatusException());\n     }\n   }\n \n+  private void handleStreamEndingException(StatusException e) {\n+    handleStreamEndingException(e, e.getStatus());\n+  }\n+\n+  // In this case, we hit an exception that does not allow us to proceed further\n+  private void handleStreamEndingException(Exception e, Status status) {\n+    // The executor is too busy to handle our requests. The stream should error.\n+    Long sessionId = mContext.getRequest() == null ? null : mContext.getRequest().getSessionId();\n+    LogUtils.warnWithException(LOG, \"handling RejectedExecutionException: sessionId: {}\",\n+        sessionId, e);\n+    AlluxioStatusException statusExc =\n+        new AlluxioStatusException(status);\n+    if (mContext == null) {\n+      mContext = createRequestContext(alluxio.grpc.ReadRequest.newBuilder().build());\n+    }\n+    setError(new Error(statusExc, true));\n+    // After calling setError, this will run the data reader to complete the request and close\n+    // any possibly opened blocks, then replies to the client with onError, and should eventually\n+    // shut down the serializing executor.\n+    createDataReader(mContext, mResponseObserver).run();", "originalCommit": "557484bf6cf6923dc55ca7bfe63297dab02300c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3OTYyNg==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r410479626", "bodyText": "After calling setError, the context status will have the mError flag as true. Once the error flag is set calling createDataReader(...).run() should be relatively fast.\nThere are a few places where we could see a slowdown.\n\nEntering the loop where we wait for mLock\n\n\n  \n    \n      alluxio/core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java\n    \n    \n        Lines 358 to 375\n      in\n      557484b\n    \n    \n    \n    \n\n        \n          \n           while (true) { \n        \n\n        \n          \n             final long start; \n        \n\n        \n          \n             final int chunkSize; \n        \n\n        \n          \n             try (LockResource lr = new LockResource(mLock)) { \n        \n\n        \n          \n               start = mContext.getPosToQueue(); \n        \n\n        \n          \n               eof = mContext.isEof(); \n        \n\n        \n          \n               cancel = mContext.isCancel(); \n        \n\n        \n          \n               error = mContext.getError(); \n        \n\n        \n          \n            \n        \n\n        \n          \n               if (eof || cancel || error != null || (!mResponse.isReady() && tooManyPendingChunks())) { \n        \n\n        \n          \n                 mContext.setDataReaderActive(false); \n        \n\n        \n          \n                 break; \n        \n\n        \n          \n               } \n        \n\n        \n          \n               chunkSize = (int) Math.min(mRequest.getEnd() - mContext.getPosToQueue(), mChunkSize); \n        \n\n        \n          \n            \n        \n\n        \n          \n               // chunkSize should always be > 0 here when reaches here. \n        \n\n        \n          \n               Preconditions.checkState(chunkSize > 0); \n        \n\n        \n          \n             } \n        \n    \n  \n\n\nBecause we call setError before running the DataReader, we immediately break from the while loop, as lock as we can access mLock.\n\n\nAfterwards we need to then perform any unlockBlock operations via the completeRequest. This should complete quickly.\n\n\n  \n    \n      alluxio/core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java\n    \n    \n        Lines 431 to 456\n      in\n      557484b\n    \n    \n    \n    \n\n        \n          \n             if (error != null) { \n        \n\n        \n          \n               try { \n        \n\n        \n          \n                 // mRequest is null if an exception is thrown when initializing mRequest. \n        \n\n        \n          \n                 if (mRequest != null) { \n        \n\n        \n          \n                   completeRequest(mContext); \n        \n\n        \n          \n                 } \n        \n\n        \n          \n               } catch (Exception e) { \n        \n\n        \n          \n                 LOG.error(\"Failed to close the request.\", e); \n        \n\n        \n          \n               } \n        \n\n        \n          \n               replyError(error); \n        \n\n        \n          \n             } else if (eof || cancel) { \n        \n\n        \n          \n               try { \n        \n\n        \n          \n                 completeRequest(mContext); \n        \n\n        \n          \n               } catch (Exception e) { \n        \n\n        \n          \n                 LogUtils.warnWithException(LOG, \"Exception occurred while completing read request, \" \n        \n\n        \n          \n                         + \"EOF/CANCEL sessionId: {}. {}\", mContext.getRequest().getSessionId(), \n        \n\n        \n          \n                     mContext.getRequest(), e); \n        \n\n        \n          \n                 setError(new Error(AlluxioStatusException.fromThrowable(e), true)); \n        \n\n        \n          \n               } \n        \n\n        \n          \n               if (eof) { \n        \n\n        \n          \n                 replyEof(); \n        \n\n        \n          \n               } else { \n        \n\n        \n          \n                 replyCancel(); \n        \n\n        \n          \n               } \n        \n\n        \n          \n             } \n        \n\n        \n          \n           } \n        \n    \n  \n\n\n\n\nThen finally will call replyError, which prevents any more operations from occurring. It will shutdown the serializing executor as well.\n\n\n  \n    \n      alluxio/core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java\n    \n    \n        Lines 480 to 491\n      in\n      557484b\n    \n    \n    \n    \n\n        \n          \n           mSerializingExecutor.addTask(() -> { \n        \n\n        \n          \n             try { \n        \n\n        \n          \n               mResponse.onError(error.getCause().toGrpcStatusException()); \n        \n\n        \n          \n             } catch (StatusRuntimeException e) { \n        \n\n        \n          \n               // Ignores the error when client already closed the stream. \n        \n\n        \n          \n               if (e.getStatus().getCode() != Status.Code.CANCELLED) { \n        \n\n        \n          \n                 throw e; \n        \n\n        \n          \n               } \n        \n\n        \n          \n             } \n        \n\n        \n          \n           }); \n        \n\n        \n          \n           mFinished.set(true); \n        \n\n        \n          \n           mSerializingExecutor.shutdown(5, TimeUnit.SECONDS); \n        \n    \n  \n\n\n\n\n\nSo yes, I think this does have some potential to slow down the handler threads.\nI haven't tested yet, but I don't think calling setError is enough to guarantee that we call replyError. The problem arises if there aren't enough executor threads to actually create the new data reader to send the final mResponseObserve.onError request. Running it here is a proactive measure against another possible RejectedExecutionException", "author": "ZacBlanco", "createdAt": "2020-04-17T21:30:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NjA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4MjQ0MA==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r410482440", "bodyText": "Maybe instead we can make a comprise. As long as we submit the data reader to the executor successfully, we don't really care when it executes. Just that it does get run at some point after setError.\nSo in the handler here, we can do\ntry {\n  mDataReaderExecutor.submit(createDataReader(...));\n} catch (RejectedExecutionException e) {\n  createDataReader(...).run();\n}\nWhat do you think?", "author": "ZacBlanco", "createdAt": "2020-04-17T21:38:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NjA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDg1NjMzNw==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r410856337", "bodyText": "How about a separate threadpool with infinite size queue?", "author": "calvinjia", "createdAt": "2020-04-19T09:00:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NjA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5Mzk1Nw==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411093957", "bodyText": "Right now we limit the number of clients that can read from a single worker by the max size of threadpool that we submit data readers to. By making that queue size unlimited, it makes it possible for the queue to grow excessively large under high load and the latency between submitting a data reader and actually beginning to process could end up being larger than client timeouts. Right now, when we submit a data reader, it's guaranteed to run immediately unless the thread pool is at max capacity.\nI think it's better to fail fast when reaching a specified load on the worker, rather than letting  too many clients connect. With the new retries it will force the clients to try a new worker quicker than if we use an infinite-size queue.", "author": "ZacBlanco", "createdAt": "2020-04-20T05:00:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NjA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM5MzcyMw==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412393723", "bodyText": "This code has been removed", "author": "ZacBlanco", "createdAt": "2020-04-21T18:29:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NjA0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2Njc3NQ==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r410466775", "bodyText": "Is there a functional change here, it seems like we lose the error message of failing to close the block reader?", "author": "calvinjia", "createdAt": "2020-04-17T20:59:00Z", "path": "core/server/worker/src/main/java/alluxio/worker/grpc/BlockReadHandler.java", "diffHunk": "@@ -82,27 +82,28 @@\n \n     @Override\n     protected void completeRequest(BlockReadRequestContext context) throws Exception {\n-      BlockReader reader = context.getBlockReader();\n-      if (reader != null) {\n-        try {\n+      BlockReader reader = null;\n+      try {\n+        reader = context.getBlockReader();\n+        if (reader != null) {\n           reader.close();\n-        } catch (Exception e) {\n-          LOG.warn(\"Failed to close block reader for block {} with error {}.\",\n-              context.getRequest().getId(), e.getMessage());\n         }\n-      }\n-      if (!mWorker.unlockBlock(context.getRequest().getSessionId(), context.getRequest().getId())) {\n-        if (reader != null) {\n-          mWorker.closeUfsBlock(context.getRequest().getSessionId(), context.getRequest().getId());\n-          context.setBlockReader(null);\n+      } finally {\n+        if (!mWorker.unlockBlock(context.getRequest().getSessionId(),\n+            context.getRequest().getId())) {\n+          if (reader != null) {\n+            mWorker.closeUfsBlock(context.getRequest().getSessionId(),\n+                context.getRequest().getId());\n+            context.setBlockReader(null);\n+          }", "originalCommit": "557484bf6cf6923dc55ca7bfe63297dab02300c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3OTk4OA==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r410479988", "bodyText": "good catch", "author": "ZacBlanco", "createdAt": "2020-04-17T21:32:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2Njc3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxNTM1OA==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r410515358", "bodyText": "updated", "author": "ZacBlanco", "createdAt": "2020-04-17T23:36:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2Njc3NQ=="}], "type": "inlineReview"}, {"oid": "619592a5ec5676d691ceae2bffee28b0503cee41", "url": "https://github.com/Alluxio/alluxio/commit/619592a5ec5676d691ceae2bffee28b0503cee41", "message": "Address comments\n\n- Add back missed exception on BlockReadHandler\n- When handling stream ending exception, attempt to run the data reader in a\nseparate thread first.", "committedDate": "2020-04-17T23:35:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyODY3NA==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r410528674", "bodyText": "Throwable", "author": "witgo", "createdAt": "2020-04-18T00:58:16Z", "path": "core/common/src/main/java/alluxio/util/executor/SerializedTaskRunner.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.util.executor;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * This class can execute a series of tasks on a separate thread in the order they are submitted.\n+ * No guarantees can be made about the timing of how the tasks complete, or what the result of\n+ * the tasks are.\n+ *\n+ * All tasks in the queue are guaranteed to complete before {@link #shutdown(long, TimeUnit)} is\n+ * called so long as they complete within the provided timeout. At which time the task runner will\n+ * stop accepting new tasks (all calls to {@link #addTask(Runnable)} will return false).\n+ *\n+ */\n+public class SerializedTaskRunner implements Runnable {\n+  private static final Logger LOG = LoggerFactory.getLogger(SerializedTaskRunner.class);\n+\n+  private volatile boolean mRunning;\n+  private volatile boolean mIsShutdown;\n+  private final LinkedBlockingQueue<Runnable> mTasks;\n+  private volatile Thread mRunningThread;\n+\n+  /**\n+   * Create a new instance of {@link SerializedTaskRunner}.\n+   */\n+  public SerializedTaskRunner() {\n+    mTasks = new LinkedBlockingQueue<>();\n+    mRunning = true;\n+    mIsShutdown = false;\n+  }\n+\n+  /**\n+   * Add a new task to execute into the queue.\n+   *\n+   * @param r task to run\n+   *\n+   * @return true if the task was added to the queue successfully\n+   */\n+  public boolean addTask(Runnable r) {\n+    if (mIsShutdown) {\n+      return false;\n+    }\n+    return mTasks.add(r);\n+  }\n+\n+  @Override\n+  public void run() {\n+    mRunningThread = Thread.currentThread();\n+    while (mRunning) {\n+      try {\n+        Runnable task = mTasks.take();\n+        try {\n+          task.run();\n+        } catch (RuntimeException e) {", "originalCommit": "619592a5ec5676d691ceae2bffee28b0503cee41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5NzMwNA==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411097304", "bodyText": "Updated.\nAlso, I apologize if this conflicts with your other PR. Correct me if I'm wrong, I don't think we're solving the same problems. We recently found the issue which I'm trying to solve in this PR. I guess the timing is just unfortunate.", "author": "ZacBlanco", "createdAt": "2020-04-20T05:12:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyODY3NA=="}], "type": "inlineReview"}, {"oid": "c0e8727224089821327a838559e58240f9698cab", "url": "https://github.com/Alluxio/alluxio/commit/c0e8727224089821327a838559e58240f9698cab", "message": "Catch throwable instead of RuntimeException", "committedDate": "2020-04-20T04:46:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUzNjM0OA==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411536348", "bodyText": "Why not all exceptions?", "author": "ggezer", "createdAt": "2020-04-20T16:53:52Z", "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -237,9 +301,13 @@ protected abstract DataReader createDataReader(T context,\n \n   public void onReady() {\n     try (LockResource lr = new LockResource(mLock)) {\n-      if (shouldRestartDataReader()) {\n-        mDataReaderExecutor.submit(createDataReader(mContext, mResponseObserver));\n-        mContext.setDataReaderActive(true);\n+      if (shouldRestartDataReader() && !mFinished.get()) {\n+        try {\n+          mDataReaderExecutor.submit(createDataReader(mContext, mResponseObserver));\n+          mContext.setDataReaderActive(true);\n+        } catch (RejectedExecutionException e) {", "originalCommit": "619592a5ec5676d691ceae2bffee28b0503cee41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2MTM2Nw==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411561367", "bodyText": "There aren't any other that can be thrown from this code path.\nAdditionally, it's not good practice to catch Exception.", "author": "ZacBlanco", "createdAt": "2020-04-20T17:31:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUzNjM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0MTU4Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411541583", "bodyText": "Why do we need this?", "author": "ggezer", "createdAt": "2020-04-20T17:01:40Z", "path": "core/common/src/main/java/alluxio/util/executor/SerializedTaskRunner.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.util.executor;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * This class can execute a series of tasks on a separate thread in the order they are submitted.\n+ * No guarantees can be made about the timing of how the tasks complete, or what the result of\n+ * the tasks are.\n+ *\n+ * All tasks in the queue are guaranteed to complete before {@link #shutdown(long, TimeUnit)} is\n+ * called so long as they complete within the provided timeout. At which time the task runner will\n+ * stop accepting new tasks (all calls to {@link #addTask(Runnable)} will return false).\n+ *\n+ */\n+public class SerializedTaskRunner implements Runnable {", "originalCommit": "619592a5ec5676d691ceae2bffee28b0503cee41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2NzMxNQ==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411567315", "bodyText": "Each data read handler needs to submit responses using onNext, onError, and onCompleted. In order for the client to understand the protocol properly, we can't have onNext messages intermingled with onError or onCompleted. That's why we used the SerializingExecutor before, in order to ensure tasks that were completed one after another.\nFor one, the previous approach was bad, because it used SerializingExecutor an internal gRPC class which was not designed to be exposed to users of the library.\nTwo, because it previously used the same underlying executor as the data reader. In order to send messages back to the client in the proper order, we relied on always being able to submit a task to the serializing executor. If submitting one task failed, the client could time out get a failure because it never actually received the data (failed to submit task which replied with the data), or it could timeout even after the worker attempted to send onError or onCompeted because it coudl fail to submit the task that calls those methods. Basically when the thread pool filled up before, we would simply stop sending messages back to clients - even ones that had already connected.\nThis new class is designed so that each new creation of AbstractReadHandler corresponds with a lease of a SerializedTaskRunner. During the lifetime of the task runner it's guaranteed to be able to run the tasks that are submitted because it uses a dedicated thread. This ensures any client which begins to be handled by the worker can complete or terminate properly because we guarantee that at least one of StreamObserver#onError or StreamObserver#onCompleted are called.", "author": "ZacBlanco", "createdAt": "2020-04-20T17:40:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0MTU4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM5MTY0OA==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412391648", "bodyText": "This has been removed", "author": "ZacBlanco", "createdAt": "2020-04-21T18:26:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0MTU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0NDMwMA==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411544300", "bodyText": "We shouldn't care.\nThread here is allocated from gRPC's internal no-limit pool, just to serve onNext() and terminate afterward.", "author": "ggezer", "createdAt": "2020-04-20T17:05:49Z", "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -126,11 +153,46 @@ public void onNext(alluxio.grpc.ReadRequest request) {\n       mContext.setPosReceived(mContext.getRequest().getStart());\n       mDataReaderExecutor.submit(createDataReader(mContext, mResponseObserver));\n       mContext.setDataReaderActive(true);\n+    } catch (RejectedExecutionException e) {\n+      handleStreamEndingException(e, Status.RESOURCE_EXHAUSTED);\n     } catch (Exception e) {\n-      LogUtils.warnWithException(LOG, \"Exception occurred while processing read request {}.\",\n-          request, e);\n-      mSerializingExecutor.execute(() -> mResponseObserver\n-          .onError(AlluxioStatusException.fromCheckedException(e).toGrpcStatusException()));\n+      handleStreamEndingException(\n+          AlluxioStatusException.fromThrowable(e).toGrpcStatusException());\n+    }\n+  }\n+\n+  private void handleStreamEndingException(StatusException e) {\n+    handleStreamEndingException(e, e.getStatus());\n+  }\n+\n+  /**\n+   * Handle any exception which should abort the client's read request.\n+   *\n+   * @param exception the exception thrown\n+   * @param status the type of {@link Status} exception which should be returned to the user\n+   */\n+  private void handleStreamEndingException(Exception exception, Status status) {\n+    Long sessionId = mContext.getRequest() == null ? null : mContext.getRequest().getSessionId();\n+    LogUtils.warnWithException(LOG, \"fatal error occurred while handling read. sessionId: {}\",\n+        sessionId, exception);\n+    AlluxioStatusException statusExc = new AlluxioStatusException(status);\n+    try (LockResource lr = new LockResource(mLock)) {\n+      if (mContext == null) {\n+        mContext = createRequestContext(alluxio.grpc.ReadRequest.newBuilder().build());\n+      }\n+      setError(new Error(statusExc, true));\n+    }\n+    // After calling setError, this will run the data reader to complete the request and close\n+    // any possibly opened blocks, then replies to the client with onError, and should eventually\n+    // shut down the serializing executor.\n+    // If possible, we should free up this thread immediately by running the data reader in a\n+    // separate thread because we want to avoid the possibility of blocking the `onNext` method", "originalCommit": "619592a5ec5676d691ceae2bffee28b0503cee41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU3MDA2NQ==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411570065", "bodyText": "I was told previously that the \"no limit\" pool was merely for simple RPCs.\nFor the stream handling aspect, the number of threads designated to serve the stream observers are coming from the workers netty threadpool, which is finite.", "author": "ZacBlanco", "createdAt": "2020-04-20T17:44:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0NDMwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU3Nzc1NQ==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411577755", "bodyText": "I'd expect that only under directExecutor() mode which is not the case here.\nNetty is supposed to do proto parsing and allocate a thread from the gRPC server's ExecutorService for calling StreamObserver<> callbacks with deserialized proto objects.", "author": "ggezer", "createdAt": "2020-04-20T17:56:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0NDMwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4NzQ2Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411587463", "bodyText": "@bf8086 and @calvinjia I think have said something otherwise, or maybe I misunderstood them. Maybe we should all have a short discussion?", "author": "ZacBlanco", "createdAt": "2020-04-20T18:11:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0NDMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0NjI3Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411546273", "bodyText": "Why not send it in-line?", "author": "ggezer", "createdAt": "2020-04-20T17:08:49Z", "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -337,7 +408,7 @@ private void runInternal() {\n \n           if (chunk != null) {\n             DataBuffer finalChunk = chunk;\n-            mSerializingExecutor.execute(() -> {\n+            mSerializingExecutor.addTask(() -> {", "originalCommit": "619592a5ec5676d691ceae2bffee28b0503cee41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2NzU1MQ==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411567551", "bodyText": "Sorry, I don't quite understand", "author": "ZacBlanco", "createdAt": "2020-04-20T17:41:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0NjI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU3ODIwNg==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411578206", "bodyText": "Again, why do we need to spawn a new thread?", "author": "ggezer", "createdAt": "2020-04-20T17:57:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0NjI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4NjI3NA==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411586274", "bodyText": "This doesn't spawn a new thread, only sends a task to the thread responsible for sending messages back to the client", "author": "ZacBlanco", "createdAt": "2020-04-20T18:10:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0NjI3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0NjcwMw==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411546703", "bodyText": "Why not send it in-line?", "author": "ggezer", "createdAt": "2020-04-20T17:09:27Z", "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -409,18 +482,16 @@ private void runInternal() {\n      * configurable transfer type.\n      *\n      * @param context context of the request to complete\n-     * @param response the gRPC response observer\n      * @param len The length, in bytes, of the data to read from the block\n      * @return a {@link DataBuffer} representing the data\n      */\n-    protected abstract DataBuffer getDataBuffer(T context, StreamObserver<ReadResponse> response,\n-        long offset, int len) throws Exception;\n+    protected abstract DataBuffer getDataBuffer(T context, long offset, int len) throws Exception;\n \n     /**\n      * Writes an error read response to the channel and closes the channel after that.\n      */\n     private void replyError(Error error) {\n-      mSerializingExecutor.execute(() -> {\n+      mSerializingExecutor.addTask(() -> {", "originalCommit": "619592a5ec5676d691ceae2bffee28b0503cee41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0ODQ4Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411548482", "bodyText": "What does WORKER_NETWORK_BLOCK_READER_THREADS_MAX limit when used with this pool?", "author": "ggezer", "createdAt": "2020-04-20T17:12:05Z", "path": "core/server/worker/src/main/java/alluxio/worker/grpc/GrpcExecutors.java", "diffHunk": "@@ -48,6 +48,12 @@\n           THREAD_STOP_MS, TimeUnit.MILLISECONDS, new SynchronousQueue<>(),\n           ThreadFactoryUtils.build(\"BlockDataReaderExecutor-%d\", true)));\n \n+  public static final ExecutorService BLOCK_READER_SERIALIZED_RUNNER_EXECUTOR =\n+      new ImpersonateThreadPoolExecutor(new ThreadPoolExecutor(THREADS_MIN,\n+          ServerConfiguration.getInt(PropertyKey.WORKER_NETWORK_BLOCK_READER_THREADS_MAX),", "originalCommit": "619592a5ec5676d691ceae2bffee28b0503cee41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2ODU5Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411568593", "bodyText": "I used that value because it's the same one that corresponds to the BlockDataReaderExecutor. We should never have more task executors than we have threads from the BlockDataReaderExecutor", "author": "ZacBlanco", "createdAt": "2020-04-20T17:42:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0ODQ4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU3OTIxNg==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411579216", "bodyText": "We will have more streams than we have reader-threads.\nNot all streams are in a state to a read block, so total count should be allowable to be more than that. Otherwise, we're stalling completions/cancellations until readers are finished.", "author": "ggezer", "createdAt": "2020-04-20T17:58:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0ODQ4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAzMjgwOA==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412032808", "bodyText": "updated", "author": "ZacBlanco", "createdAt": "2020-04-21T09:38:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0ODQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0ODk1Nw==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411548957", "bodyText": "Does this mean every new SerializedTaskRunner will hold a thread off this pool?", "author": "ggezer", "createdAt": "2020-04-20T17:12:52Z", "path": "core/common/src/main/java/alluxio/util/executor/SerializedTaskRunner.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.util.executor;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * This class can execute a series of tasks on a separate thread in the order they are submitted.\n+ * No guarantees can be made about the timing of how the tasks complete, or what the result of\n+ * the tasks are.\n+ *\n+ * All tasks in the queue are guaranteed to complete before {@link #shutdown(long, TimeUnit)} is\n+ * called so long as they complete within the provided timeout. At which time the task runner will\n+ * stop accepting new tasks (all calls to {@link #addTask(Runnable)} will return false).\n+ *\n+ */\n+public class SerializedTaskRunner implements Runnable {\n+  private static final Logger LOG = LoggerFactory.getLogger(SerializedTaskRunner.class);\n+\n+  private volatile boolean mRunning;\n+  private volatile boolean mIsShutdown;\n+  private final LinkedBlockingQueue<Runnable> mTasks;\n+  private volatile Thread mRunningThread;\n+\n+  /**\n+   * Create a new instance of {@link SerializedTaskRunner}.\n+   */\n+  public SerializedTaskRunner() {\n+    mTasks = new LinkedBlockingQueue<>();\n+    mRunning = true;\n+    mIsShutdown = false;\n+  }\n+\n+  /**\n+   * Add a new task to execute into the queue.\n+   *\n+   * @param r task to run\n+   *\n+   * @return true if the task was added to the queue successfully\n+   */\n+  public boolean addTask(Runnable r) {\n+    if (mIsShutdown) {\n+      return false;\n+    }\n+    return mTasks.add(r);\n+  }\n+\n+  @Override\n+  public void run() {\n+    mRunningThread = Thread.currentThread();\n+    while (mRunning) {\n+      try {\n+        Runnable task = mTasks.take();\n+        try {\n+          task.run();\n+        } catch (RuntimeException e) {\n+          LOG.warn(\"Exception in serialized task runner: \", e);\n+        }\n+      } catch (InterruptedException e) {\n+        LOG.debug(\"Interrupted while waiting for task\");\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Shuts down the task runner.\n+   *\n+   * No new tasks are accepted after this method is called. Remaining tasks are attempted to all\n+   * be executed within the shutdown timeout. Otherwise, after the timeout the running thread\n+   * will exit, any remaining tasks will fail to ever be executed.\n+   *\n+   * @param time the time to spend before aborting any outstanding tasks\n+   * @param unit the {@link TimeUnit} corresponding to the time argument\n+   */\n+  public synchronized void shutdown(long time, TimeUnit unit) {\n+    Preconditions.checkNotNull(unit, \"time unit\");\n+    if (mIsShutdown) {\n+      return;\n+    }\n+    mIsShutdown = true;\n+    long totalTime = unit.toMillis(time);\n+    long curr;\n+    long start = curr = System.currentTimeMillis();\n+    while (mTasks.size() > 0 || curr - start > totalTime) {\n+      curr = System.currentTimeMillis();\n+      Thread.yield();\n+    }\n+    mRunning = false;\n+    mRunningThread.interrupt();\n+    mRunningThread = null;\n+  }\n+\n+  /**\n+   * A Factory which can spawn new {@link SerializedTaskRunner}s on separate threads using an\n+   * available {@link ExecutorService}.\n+   */\n+  public static class Factory {\n+    private final ExecutorService mService;\n+\n+    /**\n+     * Create a new instance of  {@link Factory}.\n+     *\n+     * @param svc the executor service backing this factory\n+     */\n+    public Factory(ExecutorService svc) {\n+      mService = svc;\n+    }\n+\n+    /**\n+     * Spawn a new task executor which can begin queueing new tasks.\n+     *\n+     * It is not guaranteed to immediately begin running tasks. It will depend on the underlying\n+     * executor's ability to allocate a thread to this task runner.\n+     *\n+     * @return a new {@link SerializedTaskRunner}\n+     */\n+    public SerializedTaskRunner create() {\n+      SerializedTaskRunner runner = new SerializedTaskRunner();\n+      mService.execute(runner);", "originalCommit": "619592a5ec5676d691ceae2bffee28b0503cee41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2NzkyNQ==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411567925", "bodyText": "Yes, until the task runner is shut down", "author": "ZacBlanco", "createdAt": "2020-04-20T17:41:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0ODk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU3OTQ3MA==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411579470", "bodyText": "Is this the same with gRPC's SerializingExecutor ?", "author": "ggezer", "createdAt": "2020-04-20T17:59:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0ODk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4NjAyMQ==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411586021", "bodyText": "As far as I'm aware, no", "author": "ZacBlanco", "createdAt": "2020-04-20T18:09:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0ODk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYxODc5Nw==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411618797", "bodyText": "Then maybe we should switch back to it for now?", "author": "ggezer", "createdAt": "2020-04-20T19:02:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0ODk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc4NDEyOA==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411784128", "bodyText": "It will not be very efficient to hold a thread for the entire life of a request. The client might not be actively processing data so a number of the threads in pool will be taken by idle runners, lower workers ability to process concurrent requests.", "author": "bf8086", "createdAt": "2020-04-21T00:34:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0ODk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAzMjYzMQ==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412032631", "bodyText": "updates", "author": "ZacBlanco", "createdAt": "2020-04-21T09:38:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0ODk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc4ODY1Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411788656", "bodyText": "Shall we just bail out and respond error directly if the context is not even created?", "author": "bf8086", "createdAt": "2020-04-21T00:48:21Z", "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -126,11 +153,46 @@ public void onNext(alluxio.grpc.ReadRequest request) {\n       mContext.setPosReceived(mContext.getRequest().getStart());\n       mDataReaderExecutor.submit(createDataReader(mContext, mResponseObserver));\n       mContext.setDataReaderActive(true);\n+    } catch (RejectedExecutionException e) {\n+      handleStreamEndingException(e, Status.RESOURCE_EXHAUSTED);\n     } catch (Exception e) {\n-      LogUtils.warnWithException(LOG, \"Exception occurred while processing read request {}.\",\n-          request, e);\n-      mSerializingExecutor.execute(() -> mResponseObserver\n-          .onError(AlluxioStatusException.fromCheckedException(e).toGrpcStatusException()));\n+      handleStreamEndingException(\n+          AlluxioStatusException.fromThrowable(e).toGrpcStatusException());\n+    }\n+  }\n+\n+  private void handleStreamEndingException(StatusException e) {\n+    handleStreamEndingException(e, e.getStatus());\n+  }\n+\n+  /**\n+   * Handle any exception which should abort the client's read request.\n+   *\n+   * @param exception the exception thrown\n+   * @param status the type of {@link Status} exception which should be returned to the user\n+   */\n+  private void handleStreamEndingException(Exception exception, Status status) {\n+    Long sessionId = mContext.getRequest() == null ? null : mContext.getRequest().getSessionId();\n+    LogUtils.warnWithException(LOG, \"fatal error occurred while handling read. sessionId: {}\",\n+        sessionId, exception);\n+    AlluxioStatusException statusExc = new AlluxioStatusException(status);\n+    try (LockResource lr = new LockResource(mLock)) {\n+      if (mContext == null) {", "originalCommit": "c0e8727224089821327a838559e58240f9698cab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAyMTAzNg==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412021036", "bodyText": "We can, but we should still create one, because in the case that we want to respond with an error, and there are packets in flight that could trigger the handler's onNext, then it might still try to run the data reader even though we've already sent the error response.", "author": "ZacBlanco", "createdAt": "2020-04-21T09:22:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc4ODY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3NTY0Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412575646", "bodyText": "I see. That will never happen in current logic unless the client is hacked. I am fine with being extra cautious though.", "author": "bf8086", "createdAt": "2020-04-22T00:09:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc4ODY1Ng=="}], "type": "inlineReview"}, {"oid": "93b4598116c7d96b4b6a25b42b26dc40845ef74b", "url": "https://github.com/Alluxio/alluxio/commit/93b4598116c7d96b4b6a25b42b26dc40845ef74b", "message": "Use an unbounded SerializedExecutor", "committedDate": "2020-04-21T04:03:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAwMTM3OQ==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412001379", "bodyText": "Why do we need two thread pools?", "author": "witgo", "createdAt": "2020-04-21T08:54:59Z", "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -100,9 +103,10 @@\n   AbstractReadHandler(ExecutorService executorService,\n       StreamObserver<ReadResponse> responseObserver, AuthenticatedUserInfo userInfo) {\n     mDataReaderExecutor = executorService;\n-    mSerializingExecutor = new SerializingExecutor(executorService);\n     mResponseObserver = responseObserver;\n     mUserInfo = userInfo;\n+    mSerializingExecutor =", "originalCommit": "93b4598116c7d96b4b6a25b42b26dc40845ef74b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAwNDgwNA==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412004804", "bodyText": "Removed  mDataReaderExecutor  in #10540, it looks fine.", "author": "witgo", "createdAt": "2020-04-21T08:59:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAwMTM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAyNTUzNA==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412025534", "bodyText": "The data reader thread shouldn't be blocked by sending responses back to the client. mSerializingExecutor could block the data reader from doing I/O. Ideally we minimize latency by using a dedicated threadpool for the data readers performing I/O.\nThe serializing executor should guarantee that everything submitted to it can be run (no RejectedExecutionExceptions). In order to guarantee this, we use a cached threadpool with a max capacity of Integer.MAX_VALUE. The pool in my testing does not grow above 10 threads or so, even under high load of a few thousand clients. If we use the same executor as the data reader, then we could fail to send responses to the client after erroring, reading data, or even completing the read entirely because submitting the tasks in the reply* methods could fail due to the read handler executor being capped by a configuration value.", "author": "ZacBlanco", "createdAt": "2020-04-21T09:28:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAwMTM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAyODQ2OQ==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412028469", "bodyText": "For context, I'm trying to snuff out issues when we hit the capacity of the GrpcExecutors#BLOCK_READER_EXECUTOR.\nIn my testing I set this to some artificially low value (32, 64, 128), and then generate a few thousand clients worth of load on a single worker. I want to make sure the system behaves well when we scale those up to 2048 threads with anywhere from 10k-20k clients, or at least fail gracefully in such situations.", "author": "ZacBlanco", "createdAt": "2020-04-21T09:32:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAwMTM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjExMjY4Nw==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412112687", "bodyText": "Cross-thread operations on large data blocks will cause CPU cache invalidation and decrease the throughput of worker processes.", "author": "witgo", "createdAt": "2020-04-21T11:45:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAwMTM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc1MDg5Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412750896", "bodyText": "We can test that change in your PR. I am trying to limit the scope of this so that it is suitable for a 2.2.X release\nThanks for your for help!", "author": "ZacBlanco", "createdAt": "2020-04-22T07:47:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAwMTM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIwMDA1Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412200052", "bodyText": "If it is changed to new LinkedBlockingQueue<>(),  the mDataReaderExecutor#submit will not throw a RejectedExecutionException exception .", "author": "witgo", "createdAt": "2020-04-21T13:48:11Z", "path": "core/server/worker/src/main/java/alluxio/worker/grpc/GrpcExecutors.java", "diffHunk": "@@ -48,6 +48,11 @@\n           THREAD_STOP_MS, TimeUnit.MILLISECONDS, new SynchronousQueue<>(),", "originalCommit": "93b4598116c7d96b4b6a25b42b26dc40845ef74b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMyNTM1OA==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412325358", "bodyText": "I see, thanks for clarifying", "author": "ZacBlanco", "createdAt": "2020-04-21T16:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIwMDA1Mg=="}], "type": "inlineReview"}, {"oid": "4a6a0f35bd710f7270e5e92b6666951f2337c163", "url": "https://github.com/Alluxio/alluxio/commit/4a6a0f35bd710f7270e5e92b6666951f2337c163", "message": "Client should check for error after data timeout\n\n- We should check the error before throwing deadline exceeded\nto avoid masking any potential error messages already sent from\nthe worker.", "committedDate": "2020-04-21T17:31:25Z", "type": "commit"}, {"oid": "21afee753064f4c5d571c131475678e4b4ffe638", "url": "https://github.com/Alluxio/alluxio/commit/21afee753064f4c5d571c131475678e4b4ffe638", "message": "Use CallerRunsPolicy for overloaded SerializedExec", "committedDate": "2020-04-21T21:25:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3MzIyMw==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412573223", "bodyText": "When will this happen? Will it be too chatty on the log?", "author": "bf8086", "createdAt": "2020-04-22T00:01:49Z", "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -439,8 +485,12 @@ private void replyEof() {\n       mSerializingExecutor.execute(() -> {\n         try {\n           Preconditions.checkState(!mContext.isDoneUnsafe());\n-          mContext.setDoneUnsafe(true);\n-          mResponse.onCompleted();\n+          if (!mContext.isDoneUnsafe()) {\n+            mContext.setDoneUnsafe(true);\n+            mResponse.onCompleted();\n+          } else {\n+            LOG.warn(\"Tried to replyEof when stream was already finished. context: {}\", mContext);", "originalCommit": "21afee753064f4c5d571c131475678e4b4ffe638", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3NTcyNg==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412575726", "bodyText": "I can move this to debug logging? or remove it all together. In the 500M of logs I have, I only seen the replyError one", "author": "ZacBlanco", "createdAt": "2020-04-22T00:09:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3MzIyMw=="}], "type": "inlineReview"}, {"oid": "479b34328c2469d2e9bf9e946e36d30ca844db8c", "url": "https://github.com/Alluxio/alluxio/commit/479b34328c2469d2e9bf9e946e36d30ca844db8c", "message": "Move log for replies to debug", "committedDate": "2020-04-22T00:20:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3OTc2Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412579762", "bodyText": "remove this line?", "author": "bf8086", "createdAt": "2020-04-22T00:20:50Z", "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -439,8 +485,12 @@ private void replyEof() {\n       mSerializingExecutor.execute(() -> {\n         try {\n           Preconditions.checkState(!mContext.isDoneUnsafe());", "originalCommit": "21afee753064f4c5d571c131475678e4b4ffe638", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f0251df0a7a2b0c63c63999e8a9a6f1e811e9e81", "url": "https://github.com/Alluxio/alluxio/commit/f0251df0a7a2b0c63c63999e8a9a6f1e811e9e81", "message": "Remove precondition check", "committedDate": "2020-04-22T01:20:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYwNzk4NQ==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412607985", "bodyText": "Why is this the case now?", "author": "ggezer", "createdAt": "2020-04-22T01:45:14Z", "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -484,7 +484,6 @@ private void replyError(Error error) {\n     private void replyEof() {\n       mSerializingExecutor.execute(() -> {\n         try {\n-          Preconditions.checkState(!mContext.isDoneUnsafe());", "originalCommit": "f0251df0a7a2b0c63c63999e8a9a6f1e811e9e81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxMzA1MA==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412613050", "bodyText": "we shouldn't need to throw an error if the context is already done (sent a stream-ending response back to the client). Rather than throw the exception, we just log it now in case that we do hit this and want to debug further. It is uncommon, but does happen from time to time.", "author": "ZacBlanco", "createdAt": "2020-04-22T01:59:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYwNzk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTYwMjc2OA==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r429602768", "bodyText": "@ZacBlanco Is there a reason for moving this continue out?\nIs it possible for this to cause a tight-loop here? or a premature exit without sending a reply?", "author": "ggezer", "createdAt": "2020-05-24T06:09:12Z", "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -355,19 +397,18 @@ private void runInternal() {\n                     mContext.getRequest(), e);\n                 setError(new Error(AlluxioStatusException.fromThrowable(e), true));\n               } finally {\n-                if (finalChunk != null) {\n-                  finalChunk.release();\n-                }\n+                finalChunk.release();\n               }\n             });\n           }\n         } catch (Exception e) {\n           LogUtils.warnWithException(LOG,\n-              \"Exception occurred while reading data for read request {}.\", mContext.getRequest(),\n+              \"Exception occurred while reading data for read request {}. session {}\",\n+              mContext.getRequest(), mContext.getRequest().getSessionId(),\n               e);\n           setError(new Error(AlluxioStatusException.fromThrowable(e), true));\n-          continue;\n         }\n+        continue;", "originalCommit": "f0251df0a7a2b0c63c63999e8a9a6f1e811e9e81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3NDU2Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r430574562", "bodyText": "While this looks like a typo I made during the PR. Looking at the logic I don't think it should have any effect.\nThe bracket } below the continue matches to the outer-loop while (true) {. The bracket above matches to the exception handler\nPreviously, the continue statement was within the exception handler which would have sent the program back to the beginning of the loop.\nHowever, now that continue is the last statement in the loop which is essentially a no-op since it would have returned to the beginning anyway. I think even before it would have been a no-op because after exiting the exception handler the program flow would have sent it to the beginning of the loop anyway.", "author": "ZacBlanco", "createdAt": "2020-05-26T17:11:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTYwMjc2OA=="}], "type": "inlineReview"}]}