{"pr_number": 10783, "pr_title": "Refactor gRPC authentication", "pr_createdAt": "2020-01-22T23:40:07Z", "pr_url": "https://github.com/Alluxio/alluxio/pull/10783", "timeline": [{"oid": "661e6775469d74d8e3bbd84dfd358d4423184c43", "url": "https://github.com/Alluxio/alluxio/commit/661e6775469d74d8e3bbd84dfd358d4423184c43", "message": "Refactor gRPC authentication", "committedDate": "2020-01-23T00:46:50Z", "type": "commit"}, {"oid": "661e6775469d74d8e3bbd84dfd358d4423184c43", "url": "https://github.com/Alluxio/alluxio/commit/661e6775469d74d8e3bbd84dfd358d4423184c43", "message": "Refactor gRPC authentication", "committedDate": "2020-01-23T00:46:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgyOTg1NQ==", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r370829855", "bodyText": "why was this removed?", "author": "gpang", "createdAt": "2020-01-24T20:32:45Z", "path": "core/common/src/test/java/alluxio/security/authentication/SaslHandlersTest.java", "diffHunk": "@@ -69,12 +65,4 @@ public void testCreateClientSimpleNullPasword() throws UnauthenticatedException\n     mThrown.expectMessage(\"PLAIN: authorization ID and password must be specified\");\n     SaslClientHandler client = new SaslClientHandlerPlain(\"test\", null, null);\n   }\n-\n-  @Test\n-  public void testCreateServerSimple() throws UnauthenticatedException, SaslException {", "originalCommit": "661e6775469d74d8e3bbd84dfd358d4423184c43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg4MTc1OA==", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r370881758", "bodyText": "Can't test it anymore. And honestly was a pretty obvious case to bother testing.", "author": "ggezer", "createdAt": "2020-01-24T23:11:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgyOTg1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3NzczOQ==", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r370877739", "bodyText": "should this be a constant?", "author": "gpang", "createdAt": "2020-01-24T22:55:38Z", "path": "core/common/src/main/java/alluxio/grpc/GrpcChannelKey.java", "diffHunk": "@@ -57,8 +60,18 @@\n   private Optional<String> mClientType = Optional.empty();\n   /** Unique channel identifier. */\n   private UUID mChannelId = UUID.randomUUID();\n-\n-  private GrpcChannelKey() {}\n+  /** Hostname to send to server for identification. */\n+  private String mLocalHostName;\n+\n+  private GrpcChannelKey(AlluxioConfiguration conf) {\n+    // Try to get local host name.\n+    try {\n+      mLocalHostName = NetworkAddressUtils\n+          .getLocalHostName((int) conf.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS));\n+    } catch (Exception e) {\n+      mLocalHostName = \"<UNKNOWN>\";", "originalCommit": "661e6775469d74d8e3bbd84dfd358d4423184c43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3Nzg3MQ==", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r370877871", "bodyText": "can this be final?", "author": "gpang", "createdAt": "2020-01-24T22:56:06Z", "path": "core/common/src/main/java/alluxio/grpc/GrpcChannelKey.java", "diffHunk": "@@ -57,8 +60,18 @@\n   private Optional<String> mClientType = Optional.empty();\n   /** Unique channel identifier. */\n   private UUID mChannelId = UUID.randomUUID();\n-\n-  private GrpcChannelKey() {}\n+  /** Hostname to send to server for identification. */\n+  private String mLocalHostName;", "originalCommit": "661e6775469d74d8e3bbd84dfd358d4423184c43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3ODAyOA==", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r370878028", "bodyText": "why is client hostname not part of this?", "author": "gpang", "createdAt": "2020-01-24T22:56:49Z", "path": "core/common/src/main/java/alluxio/grpc/GrpcChannelKey.java", "diffHunk": "@@ -288,14 +301,25 @@ public String toString() {\n    * @return short representation of this channel key\n    */\n   public String toStringShort() {\n-    return MoreObjects.toStringHelper(this)\n+    return MoreObjects.toStringHelper(\"Channel\")\n         .add(\"ClientType\", getStringFromOptional(mClientType))\n         .add(\"ServerAddress\", mServerAddress)", "originalCommit": "661e6775469d74d8e3bbd84dfd358d4423184c43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg4MjY0MQ==", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r370882641", "bodyText": "This one shows up on client-side traces only. Dumping the hostname doesn't add any value.", "author": "ggezer", "createdAt": "2020-01-24T23:15:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3ODAyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg4NjM2NQ==", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r370886365", "bodyText": "f9e3d45", "author": "ggezer", "createdAt": "2020-01-24T23:33:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3ODAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3ODE2NA==", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r370878164", "bodyText": "I'm not sure what the differences are between these 2 toString methods.", "author": "gpang", "createdAt": "2020-01-24T22:57:19Z", "path": "core/common/src/main/java/alluxio/grpc/GrpcChannelKey.java", "diffHunk": "@@ -288,14 +301,25 @@ public String toString() {\n    * @return short representation of this channel key\n    */\n   public String toStringShort() {\n-    return MoreObjects.toStringHelper(this)\n+    return MoreObjects.toStringHelper(\"Channel\")\n         .add(\"ClientType\", getStringFromOptional(mClientType))\n         .add(\"ServerAddress\", mServerAddress)\n         .add(\"ChannelId\", mChannelId)\n         .omitNullValues()\n         .toString();\n   }\n \n+  /**\n+   * @return server-side representation of this channel key", "originalCommit": "661e6775469d74d8e3bbd84dfd358d4423184c43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg4Mjg1OA==", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r370882858", "bodyText": "This one will be sent to server side as identifier. It makes sense to know at the server side what hostname the channel belongs to.", "author": "ggezer", "createdAt": "2020-01-24T23:16:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3ODE2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg4NTgxOQ==", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r370885819", "bodyText": "After consideration, I think It's better to merge these two.", "author": "ggezer", "createdAt": "2020-01-24T23:30:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3ODE2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg4NjM0OA==", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r370886348", "bodyText": "f9e3d45", "author": "ggezer", "createdAt": "2020-01-24T23:33:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3ODE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3ODQwMA==", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r370878400", "bodyText": "is this allowed to be final?", "author": "gpang", "createdAt": "2020-01-24T22:58:15Z", "path": "core/common/src/main/java/alluxio/security/authentication/AbstractSaslClientHandler.java", "diffHunk": "@@ -23,12 +29,59 @@\n public abstract class AbstractSaslClientHandler implements SaslClientHandler {\n   private static final Logger LOG = LoggerFactory.getLogger(AbstractSaslClientHandler.class);\n \n+  /** Initial challenge for client to start Sasl session. */\n+  private static final byte[] S_INITIATE_CHALLENGE = new byte[0];\n+\n+  private ChannelAuthenticationScheme mAuthScheme;", "originalCommit": "661e6775469d74d8e3bbd84dfd358d4423184c43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3OTcwMQ==", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r370879701", "bodyText": "why does this not use unregisterChannel?", "author": "gpang", "createdAt": "2020-01-24T23:03:32Z", "path": "core/common/src/main/java/alluxio/security/authentication/DefaultAuthenticationServer.java", "diffHunk": "@@ -178,7 +163,7 @@ private void cleanupStaleClients() {\n     // Unregister stale clients.\n     LOG.debug(\"Found {} stale channels for cleanup.\", staleChannels.size());\n     for (UUID clientId : staleChannels) {\n-      unregisterChannel(clientId);\n+      mChannels.remove(clientId).getSaslServerDriver().close();", "originalCommit": "661e6775469d74d8e3bbd84dfd358d4423184c43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg4NDQzNw==", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r370884437", "bodyText": "because the AuthenticatedChannelServerDriver owns calling unregisterChannel. We assume, correctly, that there is no channel registered here that doesn't have an associated driver. This switch made handling of closing much simpler.", "author": "ggezer", "createdAt": "2020-01-24T23:23:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3OTcwMQ=="}], "type": "inlineReview"}, {"oid": "447ee1d30bf6850da1df49ef95c17fa246a8f281", "url": "https://github.com/Alluxio/alluxio/commit/447ee1d30bf6850da1df49ef95c17fa246a8f281", "message": "PR feedback", "committedDate": "2020-01-24T23:24:18Z", "type": "commit"}, {"oid": "f9e3d4597f27c40f1663d7916c993ae602c9ca52", "url": "https://github.com/Alluxio/alluxio/commit/f9e3d4597f27c40f1663d7916c993ae602c9ca52", "message": "Merge toString variations of GrpcChannelKey", "committedDate": "2020-01-24T23:32:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzNDgxNA==", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r371434814", "bodyText": "This will invoke toStringShort even if it is not debug level, right? Instead, should we have a if (debug()) gating this? (same with other LOG.debug statements here)", "author": "gpang", "createdAt": "2020-01-27T19:25:03Z", "path": "core/common/src/main/java/alluxio/security/authentication/AuthenticatedChannelClientDriver.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.security.authentication;\n+\n+import alluxio.exception.status.AlluxioStatusException;\n+import alluxio.exception.status.DeadlineExceededException;\n+import alluxio.exception.status.UnauthenticatedException;\n+import alluxio.grpc.GrpcChannelKey;\n+import alluxio.grpc.SaslMessage;\n+import alluxio.util.LogUtils;\n+\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.Status;\n+import io.grpc.stub.StreamObserver;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * Responsible for driving authentication traffic from client-side.\n+ *\n+ * An authentication between client and server is managed by\n+ * {@link AuthenticatedChannelClientDriver} and {@link AuthenticatedChannelServerDriver}\n+ * respectively.\n+ *\n+ * These drivers are wrappers over gRPC {@link StreamObserver}s that manages the stream\n+ * traffic destined for the other participant. They make sure messages are exchanged between client\n+ * and server synchronously.\n+ *\n+ * Authentication is initiated by the client. Following the initiate call, depending on the scheme,\n+ * one or more messages are exchanged to establish authenticated session between client and server.\n+ *\n+ * After the authentication is established, client and server streams are not closed in order to use\n+ * them as long polling on authentication state changes.\n+ *  -> Client closing the stream means that it doesn't want to be authenticated anymore.\n+ *  -> Server closing the stream means the client is not authenticated at the server anymore.\n+ *\n+ */\n+public class AuthenticatedChannelClientDriver implements StreamObserver<SaslMessage> {\n+  private static final Logger LOG = LoggerFactory.getLogger(AuthenticatedChannelClientDriver.class);\n+  /** Channel key. */\n+  private GrpcChannelKey mChannelKey;\n+  /** Server's sasl stream. */\n+  private StreamObserver<SaslMessage> mRequestObserver;\n+  /** Handshake handler for client. */\n+  private SaslClientHandler mSaslClientHandler;\n+  /** Whether channel is authenticated. */\n+  private volatile boolean mChannelAuthenticated;\n+  /** Used to wait during authentication handshake. */\n+  private SettableFuture<Void> mChannelAuthenticatedFuture;\n+\n+  /**\n+   * Creates client driver with given handshake handler.\n+   *\n+   * @param saslClientHandler sasl client handler\n+   * @param channelKey channel key\n+   */\n+  public AuthenticatedChannelClientDriver(SaslClientHandler saslClientHandler,\n+      GrpcChannelKey channelKey) {\n+    mSaslClientHandler = saslClientHandler;\n+    mChannelKey = channelKey;\n+    mChannelAuthenticated = false;\n+    mChannelAuthenticatedFuture = SettableFuture.create();\n+  }\n+\n+  /**\n+   * Sets the server's Sasl stream.\n+   *\n+   * @param requestObserver server Sasl stream\n+   */\n+  public void setServerObserver(StreamObserver<SaslMessage> requestObserver) {\n+    mRequestObserver = requestObserver;\n+  }\n+\n+  @Override\n+  public void onNext(SaslMessage saslMessage) {\n+    try {\n+      LOG.debug(\"Received message for {}. Message: {}\", mChannelKey.toStringShort(), saslMessage);", "originalCommit": "f9e3d4597f27c40f1663d7916c993ae602c9ca52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyODUwMQ==", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r372028501", "bodyText": "We don't expect many calls to this. I'm in favor of keeping it simple.", "author": "ggezer", "createdAt": "2020-01-28T20:06:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzNDgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzNTc0MQ==", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r371435741", "bodyText": "should we include the channel info in the message?", "author": "gpang", "createdAt": "2020-01-27T19:26:47Z", "path": "core/common/src/main/java/alluxio/security/authentication/AuthenticatedChannelClientDriver.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.security.authentication;\n+\n+import alluxio.exception.status.AlluxioStatusException;\n+import alluxio.exception.status.DeadlineExceededException;\n+import alluxio.exception.status.UnauthenticatedException;\n+import alluxio.grpc.GrpcChannelKey;\n+import alluxio.grpc.SaslMessage;\n+import alluxio.util.LogUtils;\n+\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.Status;\n+import io.grpc.stub.StreamObserver;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * Responsible for driving authentication traffic from client-side.\n+ *\n+ * An authentication between client and server is managed by\n+ * {@link AuthenticatedChannelClientDriver} and {@link AuthenticatedChannelServerDriver}\n+ * respectively.\n+ *\n+ * These drivers are wrappers over gRPC {@link StreamObserver}s that manages the stream\n+ * traffic destined for the other participant. They make sure messages are exchanged between client\n+ * and server synchronously.\n+ *\n+ * Authentication is initiated by the client. Following the initiate call, depending on the scheme,\n+ * one or more messages are exchanged to establish authenticated session between client and server.\n+ *\n+ * After the authentication is established, client and server streams are not closed in order to use\n+ * them as long polling on authentication state changes.\n+ *  -> Client closing the stream means that it doesn't want to be authenticated anymore.\n+ *  -> Server closing the stream means the client is not authenticated at the server anymore.\n+ *\n+ */\n+public class AuthenticatedChannelClientDriver implements StreamObserver<SaslMessage> {\n+  private static final Logger LOG = LoggerFactory.getLogger(AuthenticatedChannelClientDriver.class);\n+  /** Channel key. */\n+  private GrpcChannelKey mChannelKey;\n+  /** Server's sasl stream. */\n+  private StreamObserver<SaslMessage> mRequestObserver;\n+  /** Handshake handler for client. */\n+  private SaslClientHandler mSaslClientHandler;\n+  /** Whether channel is authenticated. */\n+  private volatile boolean mChannelAuthenticated;\n+  /** Used to wait during authentication handshake. */\n+  private SettableFuture<Void> mChannelAuthenticatedFuture;\n+\n+  /**\n+   * Creates client driver with given handshake handler.\n+   *\n+   * @param saslClientHandler sasl client handler\n+   * @param channelKey channel key\n+   */\n+  public AuthenticatedChannelClientDriver(SaslClientHandler saslClientHandler,\n+      GrpcChannelKey channelKey) {\n+    mSaslClientHandler = saslClientHandler;\n+    mChannelKey = channelKey;\n+    mChannelAuthenticated = false;\n+    mChannelAuthenticatedFuture = SettableFuture.create();\n+  }\n+\n+  /**\n+   * Sets the server's Sasl stream.\n+   *\n+   * @param requestObserver server Sasl stream\n+   */\n+  public void setServerObserver(StreamObserver<SaslMessage> requestObserver) {\n+    mRequestObserver = requestObserver;\n+  }\n+\n+  @Override\n+  public void onNext(SaslMessage saslMessage) {\n+    try {\n+      LOG.debug(\"Received message for {}. Message: {}\", mChannelKey.toStringShort(), saslMessage);\n+      SaslMessage response = mSaslClientHandler.handleMessage(saslMessage);\n+      if (response != null) {\n+        mRequestObserver.onNext(response);\n+      } else {\n+        // {@code null} response means server message was a success.\n+        // Release blocked waiters.\n+        LOG.debug(\"Authentication established for {}\", mChannelKey.toStringShort());\n+        mChannelAuthenticatedFuture.set(null);\n+      }\n+    } catch (Throwable t) {\n+      LOG.debug(\"Exception while handling message for {}. Message: {}. Error: {}\",\n+          mChannelKey.toStringShort(), saslMessage, t);\n+      // Fail blocked waiters.\n+      mChannelAuthenticatedFuture.setException(t);\n+      mRequestObserver.onError(AlluxioStatusException.fromThrowable(t).toGrpcStatusException());\n+    }\n+  }\n+\n+  @Override\n+  public void onError(Throwable throwable) {\n+    LOG.debug(\"Received error for {}. Error: {}\", mChannelKey.toStringShort(), throwable);\n+    closeAuthenticatedChannel(false);\n+\n+    // Fail blocked waiters.\n+    mChannelAuthenticatedFuture.setException(throwable);\n+  }\n+\n+  @Override\n+  public void onCompleted() {\n+    LOG.debug(\"Authenticated channel revoked by server for {}\", mChannelKey.toStringShort());\n+    closeAuthenticatedChannel(false);\n+  }\n+\n+  /**\n+   * Stops authenticated session with the server by releasing the long poll.\n+   */\n+  public void close() {\n+    LOG.debug(\"Closing authentication for {}\", mChannelKey.toStringShort());\n+    closeAuthenticatedChannel(true);\n+  }\n+\n+  /**\n+   * @return {@code true} if the channel is still authenticated\n+   */\n+  public boolean isAuthenticated() {\n+    return mChannelAuthenticated;\n+  }\n+\n+  /**\n+   * Starts authentication with the server and wait until completion.\n+   *\n+   * @param timeoutMs time to wait for authentication\n+   * @throws UnauthenticatedException\n+   */\n+  public void startAuthenticatedChannel(long timeoutMs) throws AlluxioStatusException {\n+    try {\n+      LOG.debug(\"Initiating authentication for {}\", mChannelKey.toStringShort());\n+      // Send the server initial message.\n+      SaslMessage.Builder initialMsg = mSaslClientHandler.handleMessage(null).toBuilder();\n+      initialMsg.setClientId(mChannelKey.getChannelId().toString());\n+      initialMsg.setChannelRef(mChannelKey.toStringShort());\n+      mRequestObserver.onNext(initialMsg.build());\n+\n+      // Utility to return from start when channel is secured.\n+      waitUntilChannelAuthenticated(timeoutMs);\n+    } catch (Throwable t) {\n+      closeAuthenticatedChannel(true);\n+      throw AlluxioStatusException.fromThrowable(t);\n+    }\n+  }\n+\n+  private void waitUntilChannelAuthenticated(long timeoutMs) throws AlluxioStatusException {\n+    try {\n+      // Wait until authentication status changes.\n+      mChannelAuthenticatedFuture.get(timeoutMs, TimeUnit.MILLISECONDS);\n+      mChannelAuthenticated = true;\n+    } catch (InterruptedException ie) {\n+      Thread.currentThread().interrupt();\n+      throw AlluxioStatusException.fromThrowable(ie);\n+    } catch (ExecutionException e) {\n+      AlluxioStatusException statExc = AlluxioStatusException.fromThrowable(e.getCause());\n+      // Unimplemented is returned if server doesn't provide authentication service.\n+      if (statExc.getStatusCode() == Status.Code.UNIMPLEMENTED) {\n+        throw new UnauthenticatedException(\"Authentication is disabled on target server.\");", "originalCommit": "f9e3d4597f27c40f1663d7916c993ae602c9ca52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyOTQwMg==", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r372029402", "bodyText": "This exception will be wrapped by caller with channel info. Including here will double the info.", "author": "ggezer", "createdAt": "2020-01-28T20:08:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzNTc0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzNTg3Mw==", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r371435873", "bodyText": "should we include the channel info in the message?", "author": "gpang", "createdAt": "2020-01-27T19:27:04Z", "path": "core/common/src/main/java/alluxio/security/authentication/AuthenticatedChannelClientDriver.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.security.authentication;\n+\n+import alluxio.exception.status.AlluxioStatusException;\n+import alluxio.exception.status.DeadlineExceededException;\n+import alluxio.exception.status.UnauthenticatedException;\n+import alluxio.grpc.GrpcChannelKey;\n+import alluxio.grpc.SaslMessage;\n+import alluxio.util.LogUtils;\n+\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.Status;\n+import io.grpc.stub.StreamObserver;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * Responsible for driving authentication traffic from client-side.\n+ *\n+ * An authentication between client and server is managed by\n+ * {@link AuthenticatedChannelClientDriver} and {@link AuthenticatedChannelServerDriver}\n+ * respectively.\n+ *\n+ * These drivers are wrappers over gRPC {@link StreamObserver}s that manages the stream\n+ * traffic destined for the other participant. They make sure messages are exchanged between client\n+ * and server synchronously.\n+ *\n+ * Authentication is initiated by the client. Following the initiate call, depending on the scheme,\n+ * one or more messages are exchanged to establish authenticated session between client and server.\n+ *\n+ * After the authentication is established, client and server streams are not closed in order to use\n+ * them as long polling on authentication state changes.\n+ *  -> Client closing the stream means that it doesn't want to be authenticated anymore.\n+ *  -> Server closing the stream means the client is not authenticated at the server anymore.\n+ *\n+ */\n+public class AuthenticatedChannelClientDriver implements StreamObserver<SaslMessage> {\n+  private static final Logger LOG = LoggerFactory.getLogger(AuthenticatedChannelClientDriver.class);\n+  /** Channel key. */\n+  private GrpcChannelKey mChannelKey;\n+  /** Server's sasl stream. */\n+  private StreamObserver<SaslMessage> mRequestObserver;\n+  /** Handshake handler for client. */\n+  private SaslClientHandler mSaslClientHandler;\n+  /** Whether channel is authenticated. */\n+  private volatile boolean mChannelAuthenticated;\n+  /** Used to wait during authentication handshake. */\n+  private SettableFuture<Void> mChannelAuthenticatedFuture;\n+\n+  /**\n+   * Creates client driver with given handshake handler.\n+   *\n+   * @param saslClientHandler sasl client handler\n+   * @param channelKey channel key\n+   */\n+  public AuthenticatedChannelClientDriver(SaslClientHandler saslClientHandler,\n+      GrpcChannelKey channelKey) {\n+    mSaslClientHandler = saslClientHandler;\n+    mChannelKey = channelKey;\n+    mChannelAuthenticated = false;\n+    mChannelAuthenticatedFuture = SettableFuture.create();\n+  }\n+\n+  /**\n+   * Sets the server's Sasl stream.\n+   *\n+   * @param requestObserver server Sasl stream\n+   */\n+  public void setServerObserver(StreamObserver<SaslMessage> requestObserver) {\n+    mRequestObserver = requestObserver;\n+  }\n+\n+  @Override\n+  public void onNext(SaslMessage saslMessage) {\n+    try {\n+      LOG.debug(\"Received message for {}. Message: {}\", mChannelKey.toStringShort(), saslMessage);\n+      SaslMessage response = mSaslClientHandler.handleMessage(saslMessage);\n+      if (response != null) {\n+        mRequestObserver.onNext(response);\n+      } else {\n+        // {@code null} response means server message was a success.\n+        // Release blocked waiters.\n+        LOG.debug(\"Authentication established for {}\", mChannelKey.toStringShort());\n+        mChannelAuthenticatedFuture.set(null);\n+      }\n+    } catch (Throwable t) {\n+      LOG.debug(\"Exception while handling message for {}. Message: {}. Error: {}\",\n+          mChannelKey.toStringShort(), saslMessage, t);\n+      // Fail blocked waiters.\n+      mChannelAuthenticatedFuture.setException(t);\n+      mRequestObserver.onError(AlluxioStatusException.fromThrowable(t).toGrpcStatusException());\n+    }\n+  }\n+\n+  @Override\n+  public void onError(Throwable throwable) {\n+    LOG.debug(\"Received error for {}. Error: {}\", mChannelKey.toStringShort(), throwable);\n+    closeAuthenticatedChannel(false);\n+\n+    // Fail blocked waiters.\n+    mChannelAuthenticatedFuture.setException(throwable);\n+  }\n+\n+  @Override\n+  public void onCompleted() {\n+    LOG.debug(\"Authenticated channel revoked by server for {}\", mChannelKey.toStringShort());\n+    closeAuthenticatedChannel(false);\n+  }\n+\n+  /**\n+   * Stops authenticated session with the server by releasing the long poll.\n+   */\n+  public void close() {\n+    LOG.debug(\"Closing authentication for {}\", mChannelKey.toStringShort());\n+    closeAuthenticatedChannel(true);\n+  }\n+\n+  /**\n+   * @return {@code true} if the channel is still authenticated\n+   */\n+  public boolean isAuthenticated() {\n+    return mChannelAuthenticated;\n+  }\n+\n+  /**\n+   * Starts authentication with the server and wait until completion.\n+   *\n+   * @param timeoutMs time to wait for authentication\n+   * @throws UnauthenticatedException\n+   */\n+  public void startAuthenticatedChannel(long timeoutMs) throws AlluxioStatusException {\n+    try {\n+      LOG.debug(\"Initiating authentication for {}\", mChannelKey.toStringShort());\n+      // Send the server initial message.\n+      SaslMessage.Builder initialMsg = mSaslClientHandler.handleMessage(null).toBuilder();\n+      initialMsg.setClientId(mChannelKey.getChannelId().toString());\n+      initialMsg.setChannelRef(mChannelKey.toStringShort());\n+      mRequestObserver.onNext(initialMsg.build());\n+\n+      // Utility to return from start when channel is secured.\n+      waitUntilChannelAuthenticated(timeoutMs);\n+    } catch (Throwable t) {\n+      closeAuthenticatedChannel(true);\n+      throw AlluxioStatusException.fromThrowable(t);\n+    }\n+  }\n+\n+  private void waitUntilChannelAuthenticated(long timeoutMs) throws AlluxioStatusException {\n+    try {\n+      // Wait until authentication status changes.\n+      mChannelAuthenticatedFuture.get(timeoutMs, TimeUnit.MILLISECONDS);\n+      mChannelAuthenticated = true;\n+    } catch (InterruptedException ie) {\n+      Thread.currentThread().interrupt();\n+      throw AlluxioStatusException.fromThrowable(ie);\n+    } catch (ExecutionException e) {\n+      AlluxioStatusException statExc = AlluxioStatusException.fromThrowable(e.getCause());\n+      // Unimplemented is returned if server doesn't provide authentication service.\n+      if (statExc.getStatusCode() == Status.Code.UNIMPLEMENTED) {\n+        throw new UnauthenticatedException(\"Authentication is disabled on target server.\");\n+      }\n+      throw statExc;\n+    } catch (TimeoutException e) {\n+      throw new DeadlineExceededException(e);\n+    }\n+  }\n+\n+  private void closeAuthenticatedChannel(boolean signalServer) {\n+    mSaslClientHandler.close();\n+    // Authentication failed either during or after handshake.\n+    mChannelAuthenticated = false;\n+\n+    if (signalServer) {\n+      try {\n+        mRequestObserver.onCompleted();\n+      } catch (Exception e) {\n+        LogUtils.warnWithException(LOG, \"Failed signaling server for stream completion.\", e);", "originalCommit": "f9e3d4597f27c40f1663d7916c993ae602c9ca52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ac4f9e327a958f625a3615400a9fc183a7558e5e", "url": "https://github.com/Alluxio/alluxio/commit/ac4f9e327a958f625a3615400a9fc183a7558e5e", "message": "Trace fix", "committedDate": "2020-01-28T20:09:34Z", "type": "commit"}]}