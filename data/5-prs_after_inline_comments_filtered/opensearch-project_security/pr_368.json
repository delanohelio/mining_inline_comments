{"pr_number": 368, "pr_title": "Refactor compliance config", "pr_createdAt": "2020-04-09T21:48:56Z", "pr_url": "https://github.com/opensearch-project/security/pull/368", "timeline": [{"oid": "ceae7a90dc9a9e816e0eca841141cd476eb2d20c", "url": "https://github.com/opensearch-project/security/commit/ceae7a90dc9a9e816e0eca841141cd476eb2d20c", "message": "Refactor compliance config", "committedDate": "2020-04-12T08:21:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2MDgxOA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r407660818", "bodyText": "I see you have changed values with the class member variables. Why opposite here?", "author": "palashhedau", "createdAt": "2020-04-13T19:11:33Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -41,209 +56,302 @@\n import java.util.Set;\n import java.util.concurrent.ExecutionException;\n \n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.elasticsearch.ElasticsearchException;\n-import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n-import org.joda.time.DateTime;\n-import org.joda.time.DateTimeZone;\n-import org.joda.time.format.DateTimeFormat;\n-import org.joda.time.format.DateTimeFormatter;\n-\n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n-import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n-import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n-import com.google.common.cache.CacheBuilder;\n-import com.google.common.cache.CacheLoader;\n-import com.google.common.cache.LoadingCache;\n-\n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndices;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n-    private volatile boolean enabled = true;\n-    private volatile boolean externalConfigLogged = false;\n-\n-    public ComplianceConfig(final Environment environment, final IndexResolverReplacer irr, final AuditLog auditLog) {\n-        super();\n-        this.settings = environment.settings();\n-        this.environment = environment;\n-        this.irr = irr;\n-        this.auditLog = auditLog;\n-        final List<String> watchedReadFields = this.settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n-                Collections.emptyList(), false);\n \n-        watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n-        logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n-        logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n-        logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n-        logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n-        logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n-        immutableIndicesPatterns = new HashSet<String>(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n-        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n-        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+    private final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n+    private final LoadingCache<String, Set<String>> cache;\n+    private final byte[] salt16;\n+    private final DateTimeFormatter auditLogPattern;\n+    private final String auditLogIndex;\n+\n+    private ComplianceConfig(\n+            final boolean logExternalConfig,\n+            final boolean logInternalConfig,\n+            final boolean logReadMetadataOnly,\n+            final boolean logWriteMetadataOnly,\n+            final boolean logDiffsForWrite,\n+            final List<String> watchedReadFields,\n+            final List<String> watchedWriteIndices,\n+            final Set<String> immutableIndicesPatterns,\n+            final String saltAsString,\n+            final String opendistrosecurityIndex,\n+            final String destinationType,\n+            final String destinationIndex) {\n+        this.logExternalConfig = logExternalConfig;\n+        this.logInternalConfig = logInternalConfig;\n+        this.logReadMetadataOnly = logReadMetadataOnly;\n+        this.logWriteMetadataOnly = logWriteMetadataOnly;\n+        this.logDiffsForWrite = logDiffsForWrite;\n+        this.watchedWriteIndices = watchedWriteIndices;\n+        this.immutableIndicesPatterns = immutableIndicesPatterns;\n+        this.opendistrosecurityIndex = opendistrosecurityIndex;\n \n-        if(saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n-            log.warn(\"If you plan to use field masking pls configure \"+ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" to be a random string of 16 chars length identical on all nodes\");\n+        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+        if (saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n+            log.warn(\"If you plan to use field masking pls configure compliance salt {} to be a random string of 16 chars length identical on all nodes\", saltAsString);\n         }\n-        \n-        if(saltAsBytes.length < 16) {\n-            throw new ElasticsearchException(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" must at least contain 16 bytes\");\n+        if (saltAsBytes.length < SALT_SIZE) {\n+            throw new ElasticsearchException(\"Provided compliance salt \" + saltAsString + \" must at least contain 16 bytes\");\n         }\n-        \n-        if(saltAsBytes.length > 16) {\n-            log.warn(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" is greater than 16 bytes. Only the first 16 bytes are used for salting\");\n+        if (saltAsBytes.length > SALT_SIZE) {\n+            log.warn(\"Provided compliance salt {} is greater than 16 bytes. Only the first 16 bytes are used for salting\", saltAsString);\n         }\n-        \n-        salt16 = Arrays.copyOf(saltAsBytes, 16);\n-        this.opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n-        \n+        this.salt16 = Arrays.copyOf(saltAsBytes, SALT_SIZE);\n+\n         //opendistro_security.compliance.pii_fields:\n         //  - indexpattern,fieldpattern,fieldpattern,....\n-        for(String watchedReadField: watchedReadFields) {\n+        for (String watchedReadField : watchedReadFields) {\n             final List<String> split = new ArrayList<>(Arrays.asList(watchedReadField.split(\",\")));\n-            if(split.isEmpty()) {\n+            if (split.isEmpty()) {\n                 continue;\n-            } else if(split.size() == 1) {\n-                readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n+            } else if (split.size() == 1) {\n+                this.readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n             } else {\n                 Set<String> _fields = new HashSet<String>(split.subList(1, split.size()));\n-                readEnabledFields.put(split.get(0), _fields);\n+                this.readEnabledFields.put(split.get(0), _fields);\n             }\n         }\n \n-        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n-        if(\"internal_elasticsearch\".equalsIgnoreCase(type)) {\n-            final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX,\"'security-auditlog-'YYYY.MM.dd\");\n+        DateTimeFormatter auditLogPattern = null;\n+        String auditLogIndex = null;\n+        if (INTERNAL_ELASTICSEARCH.equalsIgnoreCase(destinationType)) {\n             try {\n-                auditLogPattern = DateTimeFormat.forPattern(index); //throws IllegalArgumentException if no pattern\n+                auditLogPattern = DateTimeFormat.forPattern(destinationIndex); //throws IllegalArgumentException if no pattern\n             } catch (IllegalArgumentException e) {\n                 //no pattern\n-                auditLogIndex = index;\n+                auditLogIndex = destinationIndex;\n             } catch (Exception e) {\n-                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", index, e);\n+                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", destinationIndex, e);\n             }\n         }\n+        this.auditLogPattern = auditLogPattern;\n+        this.auditLogIndex = auditLogIndex;\n \n-        log.info(\"PII configuration [auditLogPattern={},  auditLogIndex={}]: {}\", auditLogPattern, auditLogIndex, readEnabledFields);\n-\n-\n-        cache = CacheBuilder.newBuilder()\n-                .maximumSize(1000)\n+        this.cache = CacheBuilder.newBuilder()\n+                .maximumSize(CACHE_SIZE)\n                 .build(new CacheLoader<String, Set<String>>() {\n                     @Override\n                     public Set<String> load(String index) throws Exception {\n-                        return getFieldsForIndex0(index);\n+                        return getFieldsForIndex(index);\n                     }\n                 });\n     }\n \n-    public boolean isLogExternalConfig() {\n-\t\treturn logExternalConfig;\n-\t}\n+    public void log(Logger logger) {\n+        logger.info(\"Auditing of external configuration is {}.\", logExternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing of internal configuration is {}.\", logInternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing only metadata information for read request is {}.\", logReadMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for read requests.\", readEnabledFields);\n+        logger.info(\"Auditing only metadata information for write request is {}.\", logWriteMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing diffs for write requests is {}.\", logDiffsForWrite ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for write requests.\", watchedWriteIndices);\n+        logger.info(\"{} indices are made immutable.\", immutableIndicesPatterns);\n+        logger.info(\"{} is used as internal security index.\", opendistrosecurityIndex);\n+        logger.info(\"Internal index used for posting audit logs is {}\", auditLogIndex);\n+    }\n \n-\tpublic boolean isExternalConfigLogged() {\n-\t\treturn externalConfigLogged;\n-\t}\n+    /**\n+     * Create compliance configuration from Settings defined in elasticsearch.yml\n+     * @param settings settings\n+     * @return compliance configuration\n+     */\n+    public static ComplianceConfig from(Settings settings) {\n+        final boolean logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n+        final boolean logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n+        final boolean logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n+        final boolean logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n+        final boolean logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n+        final List<String> watchedReadFields = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n+                Collections.emptyList(), false);\n+        final List<String> watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n+        final Set<String> immutableIndicesPatterns = ImmutableSet.copyOf(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n+        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n+        final String opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n+        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n+        final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX, \"'security-auditlog-'YYYY.MM.dd\");\n+\n+        return new ComplianceConfig(\n+                logExternalConfig,\n+                logInternalConfig,\n+                logReadMetadataOnly,\n+                logWriteMetadataOnly,\n+                logDiffsForWrite,\n+                watchedReadFields,\n+                watchedWriteIndices,\n+                immutableIndicesPatterns,\n+                saltAsString,\n+                opendistrosecurityIndex,\n+                type,\n+                index);\n+    }\n \n-\tpublic void setExternalConfigLogged(boolean externalConfigLogged) {\n-\t\tthis.externalConfigLogged = externalConfigLogged;\n-\t}\n+    /**\n+     * Checks if config defined in elasticsearch config directory must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogExternalConfig() {\n+        return logExternalConfig;\n+    }\n+\n+    /**\n+     * Checks if internal config must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogInternalConfig() {\n+        return logInternalConfig;\n+    }\n \n-\tpublic boolean isEnabled() {\n-        return this.enabled;\n+    /**\n+     * Checks if compliance is enabled\n+     * @return true/false\n+     */\n+    public boolean isEnabled() {\n+        return true;", "originalCommit": "ceae7a90dc9a9e816e0eca841141cd476eb2d20c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3ODExNQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r407678115", "bodyText": "I will revert this back to class member variable.\nI actually wanted to remove this isEnabled() itself because its always set to true. I believe this is something we inherited from search-guard where compliance was offered as a separate feature that could be disabled.\nOther places check for this explicitly hence I retained for some future use-cases.", "author": "sujithvm", "createdAt": "2020-04-13T19:44:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2MDgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3Nzk1OQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r407677959", "bodyText": "Please avoid reordering of imports.", "author": "vrozov", "createdAt": "2020-04-13T19:44:21Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -30,6 +30,21 @@\n \n package com.amazon.opendistroforelasticsearch.security.compliance;\n \n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;", "originalCommit": "ceae7a90dc9a9e816e0eca841141cd476eb2d20c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2NDAyMg==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r407764022", "bodyText": "Done!", "author": "sujithvm", "createdAt": "2020-04-13T22:49:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3Nzk1OQ=="}], "type": "inlineReview"}, {"oid": "386c749bda35c01b02003b827c6cd9b105598784", "url": "https://github.com/opensearch-project/security/commit/386c749bda35c01b02003b827c6cd9b105598784", "message": "Use class member variable", "committedDate": "2020-04-13T19:45:47Z", "type": "commit"}, {"oid": "754b209fe115330a13a900a3769ba03a262886ab", "url": "https://github.com/opensearch-project/security/commit/754b209fe115330a13a900a3769ba03a262886ab", "message": "revert back re-ordering of imports", "committedDate": "2020-04-13T22:48:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg2NDU3NA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r407864574", "bodyText": "move check complianceConfig != null  to isIndexImmutable().", "author": "vrozov", "createdAt": "2020-04-14T04:46:54Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java", "diffHunk": "@@ -330,12 +335,27 @@ private boolean checkImmutableIndices(Object request, ActionListener listener) {\n         }\n         \n         if(request instanceof IndexRequest) {\n-            if(complianceConfig != null && complianceConfig.isIndexImmutable(request)) {\n+            if(complianceConfig != null && isIndexImmutable(request)) {", "originalCommit": "754b209fe115330a13a900a3769ba03a262886ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkwMDQ1MA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r407900450", "bodyText": "Done!", "author": "sujithvm", "createdAt": "2020-04-14T06:42:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg2NDU3NA=="}], "type": "inlineReview"}, {"oid": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633", "url": "https://github.com/opensearch-project/security/commit/ecdf7e66dd1e129ab35018a02ff58eb1e3adf633", "message": "Move compliance config null check into isIndexImmutable func", "committedDate": "2020-04-14T06:41:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE1ODc0Mw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408158743", "bodyText": "Possible race condition, two threads may race for externalConfigLogged.", "author": "vrozov", "createdAt": "2020-04-14T13:59:43Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/OpenDistroSecurityPlugin.java", "diffHunk": "@@ -1010,10 +1015,10 @@ public void onNodeStarted() {\n         }\n         final Set<ModuleInfo> securityModules = ReflectionHelper.getModulesLoaded();\n         log.info(\"{} Open Distro Security modules loaded so far: {}\", securityModules.size(), securityModules);\n-        if(complianceConfig != null && complianceConfig.isEnabled() && complianceConfig.isLogExternalConfig() && !complianceConfig.isExternalConfigLogged()) {\n-        \tlog.info(\"logging external config\");\n-        \tauditLog.logExternalConfig(complianceConfig.getSettings(), complianceConfig.getEnvironment());\n-            complianceConfig.setExternalConfigLogged(true);\n+        if(complianceConfig != null && complianceConfig.isEnabled() && complianceConfig.shouldLogExternalConfig() && !externalConfigLogged) {\n+            log.info(\"logging external config\");\n+            auditLog.logExternalConfig(settings, environment);\n+            externalConfigLogged = true;", "originalCommit": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIxODQyNw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408218427", "bodyText": "externalConfigLogged is set t volatile. This is existing behavior as well. It is just pulled out of compliance config", "author": "sujithvm", "createdAt": "2020-04-14T15:15:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE1ODc0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIzMjUwNg==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408232506", "bodyText": "volatile does not prevent race condition, it only provides memory barrier. It will be OK to file that as an issue and address in a separate PR.", "author": "vrozov", "createdAt": "2020-04-14T15:33:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE1ODc0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI1MzA0NQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408253045", "bodyText": "Yes it would be great to address it separately.\nAre you saying onNodeStarted will be called by multiple threads ? Need to investigate the race condition", "author": "sujithvm", "createdAt": "2020-04-14T16:01:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE1ODc0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM1MzIwMw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408353203", "bodyText": "It is a possible race condition. As plugin has no control when and how onNodeStarted() is called, it will be safer to avoid the race condition, especially that it will not cost anything. Just replace volatile with AtomicBoolean and use getAndSet().", "author": "vrozov", "createdAt": "2020-04-14T18:38:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE1ODc0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3MzY1OQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408173659", "bodyText": "nit: move to enclosing if", "author": "vrozov", "createdAt": "2020-04-14T14:19:14Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java", "diffHunk": "@@ -311,7 +316,7 @@ private boolean checkImmutableIndices(Object request, ActionListener listener) {\n                 || request instanceof IndicesAliasesRequest //TODO only remove index\n                 ) {\n             \n-            if(complianceConfig != null && complianceConfig.isIndexImmutable(request)) {\n+            if (isIndexImmutable(request)) {", "originalCommit": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIyNDQ4MQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408224481", "bodyText": "Retained existing code.", "author": "sujithvm", "createdAt": "2020-04-14T15:23:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3MzY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3NDgwMw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408174803", "bodyText": "nit: move to enclosing if", "author": "vrozov", "createdAt": "2020-04-14T14:20:46Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java", "diffHunk": "@@ -330,12 +335,27 @@ private boolean checkImmutableIndices(Object request, ActionListener listener) {\n         }\n         \n         if(request instanceof IndexRequest) {\n-            if(complianceConfig != null && complianceConfig.isIndexImmutable(request)) {\n+            if (isIndexImmutable(request)) {", "originalCommit": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE5MzU0Nw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408193547", "bodyText": "nit: consider isRequestIndexImmutable", "author": "vrozov", "createdAt": "2020-04-14T14:44:32Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java", "diffHunk": "@@ -330,12 +335,27 @@ private boolean checkImmutableIndices(Object request, ActionListener listener) {\n         }\n         \n         if(request instanceof IndexRequest) {\n-            if(complianceConfig != null && complianceConfig.isIndexImmutable(request)) {\n+            if (isIndexImmutable(request)) {\n                 ((IndexRequest) request).opType(OpType.CREATE);\n             }\n         }\n         \n         return false;\n     }\n \n-}\n\\ No newline at end of file\n+    private boolean isIndexImmutable(Object request) {", "originalCommit": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIxODkwNw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408218907", "bodyText": "Retained the existing function name. Wanted to reduce diffs", "author": "sujithvm", "createdAt": "2020-04-14T15:15:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE5MzU0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIyMzU4NA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408223584", "bodyText": "This is a new function, the diff is already there.", "author": "vrozov", "createdAt": "2020-04-14T15:21:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE5MzU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE5NTExMw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408195113", "bodyText": "Actually this check is redundant. There is the same condition on line 198 before checkImmutableIndices() call.", "author": "vrozov", "createdAt": "2020-04-14T14:46:30Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java", "diffHunk": "@@ -330,12 +335,27 @@ private boolean checkImmutableIndices(Object request, ActionListener listener) {\n         }\n         \n         if(request instanceof IndexRequest) {\n-            if(complianceConfig != null && complianceConfig.isIndexImmutable(request)) {\n+            if (isIndexImmutable(request)) {\n                 ((IndexRequest) request).opType(OpType.CREATE);\n             }\n         }\n         \n         return false;\n     }\n \n-}\n\\ No newline at end of file\n+    private boolean isIndexImmutable(Object request) {\n+        if (complianceConfig == null || !complianceConfig.isEnabled()) {", "originalCommit": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIyNDA2OA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408224068", "bodyText": "Well, I think this should be retained here while calling this function", "author": "sujithvm", "createdAt": "2020-04-14T15:22:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE5NTExMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIzNDY0MQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408234641", "bodyText": "Why? It is a private method and there is no need to duplicate the check.", "author": "vrozov", "createdAt": "2020-04-14T15:36:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE5NTExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIwMjY3Mw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408202673", "bodyText": "Should this be part of the check on line 198? You can check that immutableIndicesPatterns is not empty once for BulkShardRequest and assume that it is not empty here or pass it to checkImmutableIndices().", "author": "vrozov", "createdAt": "2020-04-14T14:55:33Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java", "diffHunk": "@@ -330,12 +335,27 @@ private boolean checkImmutableIndices(Object request, ActionListener listener) {\n         }\n         \n         if(request instanceof IndexRequest) {\n-            if(complianceConfig != null && complianceConfig.isIndexImmutable(request)) {\n+            if (isIndexImmutable(request)) {\n                 ((IndexRequest) request).opType(OpType.CREATE);\n             }\n         }\n         \n         return false;\n     }\n \n-}\n\\ No newline at end of file\n+    private boolean isIndexImmutable(Object request) {\n+        if (complianceConfig == null || !complianceConfig.isEnabled()) {\n+            return false;\n+        }\n+\n+        final Set<String> immutableIndicesPatterns = complianceConfig.getImmutableIndicesPatterns();\n+        if (immutableIndicesPatterns.isEmpty()) {", "originalCommit": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1e9b7bbb4990e9daf957ab1c304662f94cf4f13d", "url": "https://github.com/opensearch-project/security/commit/1e9b7bbb4990e9daf957ab1c304662f94cf4f13d", "message": "Address code reviews", "committedDate": "2020-04-15T02:58:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwMDI0Mw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410400243", "bodyText": "Consider:\n        if (saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n            log.warn(\"If you plan to use field masking pls configure compliance salt {} to be a random string of 16 chars length identical on all nodes\", saltAsString);\n        }\n        try {\n            ByteBuffer byteBuffer = StandardCharsets.UTF_8.encode(saltAsString);\n            byteBuffer.get(salt16);\n            if (byteBuffer.remaining() > 0) {\n                log.warn(\"Provided compliance salt {} is greater than 16 bytes. Only the first 16 bytes are used for salting\", saltAsString);\n            }\n        } catch (BufferUnderflowException e) {\n            throw new ElasticsearchException(\"Provided compliance salt \" + saltAsString + \" must at least contain 16 bytes\", e);\n        }\n\nPlease add test cases for salt.", "author": "vrozov", "createdAt": "2020-04-17T18:32:16Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -45,205 +45,315 @@\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndices;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n+\n+    private final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n+    private final LoadingCache<String, Set<String>> cache;\n+    private final byte[] salt16;\n+    private final DateTimeFormatter auditLogPattern;\n+    private final String auditLogIndex;\n     private volatile boolean enabled = true;\n-    private volatile boolean externalConfigLogged = false;\n-\n-    public ComplianceConfig(final Environment environment, final IndexResolverReplacer irr, final AuditLog auditLog) {\n-        super();\n-        this.settings = environment.settings();\n-        this.environment = environment;\n-        this.irr = irr;\n-        this.auditLog = auditLog;\n-        final List<String> watchedReadFields = this.settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n-                Collections.emptyList(), false);\n \n-        watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n-        logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n-        logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n-        logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n-        logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n-        logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n-        immutableIndicesPatterns = new HashSet<String>(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n-        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n-        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+    private ComplianceConfig(\n+            final boolean logExternalConfig,\n+            final boolean logInternalConfig,\n+            final boolean logReadMetadataOnly,\n+            final boolean logWriteMetadataOnly,\n+            final boolean logDiffsForWrite,\n+            final List<String> watchedReadFields,\n+            final List<String> watchedWriteIndices,\n+            final Set<String> immutableIndicesPatterns,\n+            final String saltAsString,\n+            final String opendistrosecurityIndex,\n+            final String destinationType,\n+            final String destinationIndex) {\n+        this.logExternalConfig = logExternalConfig;\n+        this.logInternalConfig = logInternalConfig;\n+        this.logReadMetadataOnly = logReadMetadataOnly;\n+        this.logWriteMetadataOnly = logWriteMetadataOnly;\n+        this.logDiffsForWrite = logDiffsForWrite;\n+        this.watchedWriteIndices = watchedWriteIndices;\n+        this.immutableIndicesPatterns = immutableIndicesPatterns;\n+        this.opendistrosecurityIndex = opendistrosecurityIndex;\n \n-        if(saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n-            log.warn(\"If you plan to use field masking pls configure \"+ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" to be a random string of 16 chars length identical on all nodes\");\n+        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);", "originalCommit": "1e9b7bbb4990e9daf957ab1c304662f94cf4f13d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNDEyMQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410434121", "bodyText": "Consider:\n        this.readEnabledFields = watchedReadFields.stream()\n                .map(watchedReadField -> watchedReadField.split(\",\"))\n                .filter(split -> split.length != 0)\n                .collect(Collectors.toMap(\n                        split -> split[0],\n                        split -> split.length == 1 ?\n                                Collections.singleton(\"*\") : Arrays.stream(split).skip(1).collect(Collectors.toSet())\n                ));", "author": "vrozov", "createdAt": "2020-04-17T19:44:17Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -45,205 +45,315 @@\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndices;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n+\n+    private final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n+    private final LoadingCache<String, Set<String>> cache;\n+    private final byte[] salt16;\n+    private final DateTimeFormatter auditLogPattern;\n+    private final String auditLogIndex;\n     private volatile boolean enabled = true;\n-    private volatile boolean externalConfigLogged = false;\n-\n-    public ComplianceConfig(final Environment environment, final IndexResolverReplacer irr, final AuditLog auditLog) {\n-        super();\n-        this.settings = environment.settings();\n-        this.environment = environment;\n-        this.irr = irr;\n-        this.auditLog = auditLog;\n-        final List<String> watchedReadFields = this.settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n-                Collections.emptyList(), false);\n \n-        watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n-        logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n-        logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n-        logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n-        logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n-        logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n-        immutableIndicesPatterns = new HashSet<String>(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n-        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n-        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+    private ComplianceConfig(\n+            final boolean logExternalConfig,\n+            final boolean logInternalConfig,\n+            final boolean logReadMetadataOnly,\n+            final boolean logWriteMetadataOnly,\n+            final boolean logDiffsForWrite,\n+            final List<String> watchedReadFields,\n+            final List<String> watchedWriteIndices,\n+            final Set<String> immutableIndicesPatterns,\n+            final String saltAsString,\n+            final String opendistrosecurityIndex,\n+            final String destinationType,\n+            final String destinationIndex) {\n+        this.logExternalConfig = logExternalConfig;\n+        this.logInternalConfig = logInternalConfig;\n+        this.logReadMetadataOnly = logReadMetadataOnly;\n+        this.logWriteMetadataOnly = logWriteMetadataOnly;\n+        this.logDiffsForWrite = logDiffsForWrite;\n+        this.watchedWriteIndices = watchedWriteIndices;\n+        this.immutableIndicesPatterns = immutableIndicesPatterns;\n+        this.opendistrosecurityIndex = opendistrosecurityIndex;\n \n-        if(saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n-            log.warn(\"If you plan to use field masking pls configure \"+ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" to be a random string of 16 chars length identical on all nodes\");\n+        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+        if (saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n+            log.warn(\"If you plan to use field masking pls configure compliance salt {} to be a random string of 16 chars length identical on all nodes\", saltAsString);\n         }\n-        \n-        if(saltAsBytes.length < 16) {\n-            throw new ElasticsearchException(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" must at least contain 16 bytes\");\n+        if (saltAsBytes.length < SALT_SIZE) {\n+            throw new ElasticsearchException(\"Provided compliance salt \" + saltAsString + \" must at least contain 16 bytes\");\n         }\n-        \n-        if(saltAsBytes.length > 16) {\n-            log.warn(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" is greater than 16 bytes. Only the first 16 bytes are used for salting\");\n+        if (saltAsBytes.length > SALT_SIZE) {\n+            log.warn(\"Provided compliance salt {} is greater than 16 bytes. Only the first 16 bytes are used for salting\", saltAsString);\n         }\n-        \n-        salt16 = Arrays.copyOf(saltAsBytes, 16);\n-        this.opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n-        \n+        this.salt16 = Arrays.copyOf(saltAsBytes, SALT_SIZE);\n+\n         //opendistro_security.compliance.pii_fields:\n         //  - indexpattern,fieldpattern,fieldpattern,....\n-        for(String watchedReadField: watchedReadFields) {\n+        for (String watchedReadField : watchedReadFields) {", "originalCommit": "1e9b7bbb4990e9daf957ab1c304662f94cf4f13d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9cac07bcbd203f2ee90acbfae5e75592080ac27e", "url": "https://github.com/opensearch-project/security/commit/9cac07bcbd203f2ee90acbfae5e75592080ac27e", "message": "Fetch current compliance config from auditlog", "committedDate": "2020-04-17T19:48:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3MTQzNg==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410471436", "bodyText": "Should it be Set<String> watchedWriteIndicesPatterns to be consistent with Set<String> immutableIndicesPatterns?", "author": "vrozov", "createdAt": "2020-04-17T21:09:46Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -45,205 +45,315 @@\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndices;", "originalCommit": "9cac07bcbd203f2ee90acbfae5e75592080ac27e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3NjAwNQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410476005", "bodyText": "nit: please change cache to a more descriptive name.", "author": "vrozov", "createdAt": "2020-04-17T21:21:27Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -45,205 +45,315 @@\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndices;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n+\n+    private final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n+    private final LoadingCache<String, Set<String>> cache;", "originalCommit": "9cac07bcbd203f2ee90acbfae5e75592080ac27e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "27d15469e0c14fd342441f62200adfd654e5323a", "url": "https://github.com/opensearch-project/security/commit/27d15469e0c14fd342441f62200adfd654e5323a", "message": "address code reviews\n\nFix non null", "committedDate": "2020-04-17T21:43:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ5NjQ5NQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410496495", "bodyText": "I don't think that copy/clone is necessary, but if it is, I would rather use Arrays.copyOf().", "author": "vrozov", "createdAt": "2020-04-17T22:18:39Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -45,205 +45,315 @@\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndices;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n+\n+    private final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n+    private final LoadingCache<String, Set<String>> cache;\n+    private final byte[] salt16;\n+    private final DateTimeFormatter auditLogPattern;\n+    private final String auditLogIndex;\n     private volatile boolean enabled = true;\n-    private volatile boolean externalConfigLogged = false;\n-\n-    public ComplianceConfig(final Environment environment, final IndexResolverReplacer irr, final AuditLog auditLog) {\n-        super();\n-        this.settings = environment.settings();\n-        this.environment = environment;\n-        this.irr = irr;\n-        this.auditLog = auditLog;\n-        final List<String> watchedReadFields = this.settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n-                Collections.emptyList(), false);\n \n-        watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n-        logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n-        logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n-        logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n-        logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n-        logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n-        immutableIndicesPatterns = new HashSet<String>(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n-        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n-        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+    private ComplianceConfig(\n+            final boolean logExternalConfig,\n+            final boolean logInternalConfig,\n+            final boolean logReadMetadataOnly,\n+            final boolean logWriteMetadataOnly,\n+            final boolean logDiffsForWrite,\n+            final List<String> watchedReadFields,\n+            final List<String> watchedWriteIndices,\n+            final Set<String> immutableIndicesPatterns,\n+            final String saltAsString,\n+            final String opendistrosecurityIndex,\n+            final String destinationType,\n+            final String destinationIndex) {\n+        this.logExternalConfig = logExternalConfig;\n+        this.logInternalConfig = logInternalConfig;\n+        this.logReadMetadataOnly = logReadMetadataOnly;\n+        this.logWriteMetadataOnly = logWriteMetadataOnly;\n+        this.logDiffsForWrite = logDiffsForWrite;\n+        this.watchedWriteIndices = watchedWriteIndices;\n+        this.immutableIndicesPatterns = immutableIndicesPatterns;\n+        this.opendistrosecurityIndex = opendistrosecurityIndex;\n \n-        if(saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n-            log.warn(\"If you plan to use field masking pls configure \"+ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" to be a random string of 16 chars length identical on all nodes\");\n+        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+        if (saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n+            log.warn(\"If you plan to use field masking pls configure compliance salt {} to be a random string of 16 chars length identical on all nodes\", saltAsString);\n         }\n-        \n-        if(saltAsBytes.length < 16) {\n-            throw new ElasticsearchException(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" must at least contain 16 bytes\");\n+        if (saltAsBytes.length < SALT_SIZE) {\n+            throw new ElasticsearchException(\"Provided compliance salt \" + saltAsString + \" must at least contain 16 bytes\");\n         }\n-        \n-        if(saltAsBytes.length > 16) {\n-            log.warn(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" is greater than 16 bytes. Only the first 16 bytes are used for salting\");\n+        if (saltAsBytes.length > SALT_SIZE) {\n+            log.warn(\"Provided compliance salt {} is greater than 16 bytes. Only the first 16 bytes are used for salting\", saltAsString);\n         }\n-        \n-        salt16 = Arrays.copyOf(saltAsBytes, 16);\n-        this.opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n-        \n+        this.salt16 = Arrays.copyOf(saltAsBytes, SALT_SIZE);\n+\n         //opendistro_security.compliance.pii_fields:\n         //  - indexpattern,fieldpattern,fieldpattern,....\n-        for(String watchedReadField: watchedReadFields) {\n+        for (String watchedReadField : watchedReadFields) {\n             final List<String> split = new ArrayList<>(Arrays.asList(watchedReadField.split(\",\")));\n-            if(split.isEmpty()) {\n+            if (split.isEmpty()) {\n                 continue;\n-            } else if(split.size() == 1) {\n-                readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n+            } else if (split.size() == 1) {\n+                this.readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n             } else {\n                 Set<String> _fields = new HashSet<String>(split.subList(1, split.size()));\n-                readEnabledFields.put(split.get(0), _fields);\n+                this.readEnabledFields.put(split.get(0), _fields);\n             }\n         }\n \n-        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n-        if(\"internal_elasticsearch\".equalsIgnoreCase(type)) {\n-            final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX,\"'security-auditlog-'YYYY.MM.dd\");\n+        DateTimeFormatter auditLogPattern = null;\n+        String auditLogIndex = null;\n+        if (INTERNAL_ELASTICSEARCH.equalsIgnoreCase(destinationType)) {\n             try {\n-                auditLogPattern = DateTimeFormat.forPattern(index); //throws IllegalArgumentException if no pattern\n+                auditLogPattern = DateTimeFormat.forPattern(destinationIndex); //throws IllegalArgumentException if no pattern\n             } catch (IllegalArgumentException e) {\n                 //no pattern\n-                auditLogIndex = index;\n+                auditLogIndex = destinationIndex;\n             } catch (Exception e) {\n-                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", index, e);\n+                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", destinationIndex, e);\n             }\n         }\n+        this.auditLogPattern = auditLogPattern;\n+        this.auditLogIndex = auditLogIndex;\n \n-        log.info(\"PII configuration [auditLogPattern={},  auditLogIndex={}]: {}\", auditLogPattern, auditLogIndex, readEnabledFields);\n-\n-\n-        cache = CacheBuilder.newBuilder()\n-                .maximumSize(1000)\n+        this.cache = CacheBuilder.newBuilder()\n+                .maximumSize(CACHE_SIZE)\n                 .build(new CacheLoader<String, Set<String>>() {\n                     @Override\n                     public Set<String> load(String index) throws Exception {\n-                        return getFieldsForIndex0(index);\n+                        return getFieldsForIndex(index);\n                     }\n                 });\n     }\n \n-    public boolean isLogExternalConfig() {\n-\t\treturn logExternalConfig;\n-\t}\n+    public void log(Logger logger) {\n+        logger.info(\"Auditing of external configuration is {}.\", logExternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing of internal configuration is {}.\", logInternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing only metadata information for read request is {}.\", logReadMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for read requests.\", readEnabledFields);\n+        logger.info(\"Auditing only metadata information for write request is {}.\", logWriteMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing diffs for write requests is {}.\", logDiffsForWrite ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for write requests.\", watchedWriteIndices);\n+        logger.info(\"{} indices are made immutable.\", immutableIndicesPatterns);\n+        logger.info(\"{} is used as internal security index.\", opendistrosecurityIndex);\n+        logger.info(\"Internal index used for posting audit logs is {}\", auditLogIndex);\n+    }\n+\n+    /**\n+     * Create compliance configuration from Settings defined in elasticsearch.yml\n+     * @param settings settings\n+     * @return compliance configuration\n+     */\n+    public static ComplianceConfig from(Settings settings) {\n+        final boolean logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n+        final boolean logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n+        final boolean logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n+        final boolean logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n+        final boolean logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n+        final List<String> watchedReadFields = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n+                Collections.emptyList(), false);\n+        final List<String> watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n+        final Set<String> immutableIndicesPatterns = ImmutableSet.copyOf(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n+        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n+        final String opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n+        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n+        final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX, \"'security-auditlog-'YYYY.MM.dd\");\n+\n+        return new ComplianceConfig(\n+                logExternalConfig,\n+                logInternalConfig,\n+                logReadMetadataOnly,\n+                logWriteMetadataOnly,\n+                logDiffsForWrite,\n+                watchedReadFields,\n+                watchedWriteIndices,\n+                immutableIndicesPatterns,\n+                saltAsString,\n+                opendistrosecurityIndex,\n+                type,\n+                index);\n+    }\n \n-\tpublic boolean isExternalConfigLogged() {\n-\t\treturn externalConfigLogged;\n-\t}\n+    /**\n+     * Checks if config defined in elasticsearch config directory must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogExternalConfig() {\n+        return logExternalConfig;\n+    }\n \n-\tpublic void setExternalConfigLogged(boolean externalConfigLogged) {\n-\t\tthis.externalConfigLogged = externalConfigLogged;\n-\t}\n+    /**\n+     * Checks if internal config must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogInternalConfig() {\n+        return logInternalConfig;\n+    }\n \n-\tpublic boolean isEnabled() {\n+    /**\n+     * Checks if compliance is enabled\n+     * @return true/false\n+     */\n+    public boolean isEnabled() {\n         return this.enabled;\n     }\n \n-    //cached\n-    @SuppressWarnings(\"unchecked\")\n-    private Set<String> getFieldsForIndex0(String index) {\n+    /**\n+     * Checks if logs diffs must be recorded for write requests\n+     * Log metadata only for write requests must be disabled\n+     * @return true/false\n+     */\n+    public boolean shouldLogDiffsForWrite() {\n+        return !shouldLogWriteMetadataOnly() && logDiffsForWrite;\n+    }\n+\n+    /**\n+     * Checks if only metadata for write requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogWriteMetadataOnly() {\n+        return logWriteMetadataOnly;\n+    }\n \n-        if(index == null) {\n-            return Collections.EMPTY_SET;\n+    /**\n+     * Checks if only metadata for read requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogReadMetadataOnly() {\n+        return logReadMetadataOnly;\n+    }\n+\n+    /**\n+     * Get set of immutable index pattern\n+     * @return set of index patterns\n+     */\n+    public Set<String> getImmutableIndicesPatterns() {\n+        return immutableIndicesPatterns;\n+    }\n+\n+    /**\n+     * Get the salt in bytes for filed anonymization\n+     * @return salt in bytes\n+     */\n+    public byte[] getSalt16() {\n+        return salt16.clone();", "originalCommit": "9cac07bcbd203f2ee90acbfae5e75592080ac27e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwMzcwNg==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410503706", "bodyText": "The array can be modified by some other classes right? Requesting salt will give the modified array.", "author": "sujithvm", "createdAt": "2020-04-17T22:45:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ5NjQ5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcyNDczMw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410724733", "bodyText": "There are no other classes that modify the array. In this particular case, if you track how salt is used, it will be copied twice.", "author": "vrozov", "createdAt": "2020-04-18T17:15:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ5NjQ5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDczNDYyNg==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410734626", "bodyText": "If you look at MaskedField where you are passing salt16, you are passing the salt to 3rd lib function like this https://github.com/opendistro-for-elasticsearch/security/blob/master/src/main/java/com/amazon/opendistroforelasticsearch/security/configuration/MaskedField.java#L176\nYou never know if other libs modify the array or not. Is it safer to return a copy and I would prefer doing the same.\nMoreover copying salt is current functionality and can changes around this if needed be done separately?", "author": "sujithvm", "createdAt": "2020-04-18T18:40:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ5NjQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ5NzA3Nw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410497077", "bodyText": "Consider:\n        return readEnabledFields.entrySet().stream()\n                .filter(entry -> WildcardMatcher.match(entry.getKey(), index))\n                .flatMap(entry -> entry.getValue().stream())\n                .collect(Collectors.toSet());\n\nThere is no point of adding null or empty indexPattern to readEnabledFields, add it as a filter to the constructor.", "author": "vrozov", "createdAt": "2020-04-17T22:20:39Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -45,205 +45,315 @@\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndices;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n+\n+    private final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n+    private final LoadingCache<String, Set<String>> cache;\n+    private final byte[] salt16;\n+    private final DateTimeFormatter auditLogPattern;\n+    private final String auditLogIndex;\n     private volatile boolean enabled = true;\n-    private volatile boolean externalConfigLogged = false;\n-\n-    public ComplianceConfig(final Environment environment, final IndexResolverReplacer irr, final AuditLog auditLog) {\n-        super();\n-        this.settings = environment.settings();\n-        this.environment = environment;\n-        this.irr = irr;\n-        this.auditLog = auditLog;\n-        final List<String> watchedReadFields = this.settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n-                Collections.emptyList(), false);\n \n-        watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n-        logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n-        logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n-        logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n-        logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n-        logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n-        immutableIndicesPatterns = new HashSet<String>(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n-        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n-        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+    private ComplianceConfig(\n+            final boolean logExternalConfig,\n+            final boolean logInternalConfig,\n+            final boolean logReadMetadataOnly,\n+            final boolean logWriteMetadataOnly,\n+            final boolean logDiffsForWrite,\n+            final List<String> watchedReadFields,\n+            final List<String> watchedWriteIndices,\n+            final Set<String> immutableIndicesPatterns,\n+            final String saltAsString,\n+            final String opendistrosecurityIndex,\n+            final String destinationType,\n+            final String destinationIndex) {\n+        this.logExternalConfig = logExternalConfig;\n+        this.logInternalConfig = logInternalConfig;\n+        this.logReadMetadataOnly = logReadMetadataOnly;\n+        this.logWriteMetadataOnly = logWriteMetadataOnly;\n+        this.logDiffsForWrite = logDiffsForWrite;\n+        this.watchedWriteIndices = watchedWriteIndices;\n+        this.immutableIndicesPatterns = immutableIndicesPatterns;\n+        this.opendistrosecurityIndex = opendistrosecurityIndex;\n \n-        if(saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n-            log.warn(\"If you plan to use field masking pls configure \"+ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" to be a random string of 16 chars length identical on all nodes\");\n+        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+        if (saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n+            log.warn(\"If you plan to use field masking pls configure compliance salt {} to be a random string of 16 chars length identical on all nodes\", saltAsString);\n         }\n-        \n-        if(saltAsBytes.length < 16) {\n-            throw new ElasticsearchException(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" must at least contain 16 bytes\");\n+        if (saltAsBytes.length < SALT_SIZE) {\n+            throw new ElasticsearchException(\"Provided compliance salt \" + saltAsString + \" must at least contain 16 bytes\");\n         }\n-        \n-        if(saltAsBytes.length > 16) {\n-            log.warn(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" is greater than 16 bytes. Only the first 16 bytes are used for salting\");\n+        if (saltAsBytes.length > SALT_SIZE) {\n+            log.warn(\"Provided compliance salt {} is greater than 16 bytes. Only the first 16 bytes are used for salting\", saltAsString);\n         }\n-        \n-        salt16 = Arrays.copyOf(saltAsBytes, 16);\n-        this.opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n-        \n+        this.salt16 = Arrays.copyOf(saltAsBytes, SALT_SIZE);\n+\n         //opendistro_security.compliance.pii_fields:\n         //  - indexpattern,fieldpattern,fieldpattern,....\n-        for(String watchedReadField: watchedReadFields) {\n+        for (String watchedReadField : watchedReadFields) {\n             final List<String> split = new ArrayList<>(Arrays.asList(watchedReadField.split(\",\")));\n-            if(split.isEmpty()) {\n+            if (split.isEmpty()) {\n                 continue;\n-            } else if(split.size() == 1) {\n-                readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n+            } else if (split.size() == 1) {\n+                this.readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n             } else {\n                 Set<String> _fields = new HashSet<String>(split.subList(1, split.size()));\n-                readEnabledFields.put(split.get(0), _fields);\n+                this.readEnabledFields.put(split.get(0), _fields);\n             }\n         }\n \n-        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n-        if(\"internal_elasticsearch\".equalsIgnoreCase(type)) {\n-            final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX,\"'security-auditlog-'YYYY.MM.dd\");\n+        DateTimeFormatter auditLogPattern = null;\n+        String auditLogIndex = null;\n+        if (INTERNAL_ELASTICSEARCH.equalsIgnoreCase(destinationType)) {\n             try {\n-                auditLogPattern = DateTimeFormat.forPattern(index); //throws IllegalArgumentException if no pattern\n+                auditLogPattern = DateTimeFormat.forPattern(destinationIndex); //throws IllegalArgumentException if no pattern\n             } catch (IllegalArgumentException e) {\n                 //no pattern\n-                auditLogIndex = index;\n+                auditLogIndex = destinationIndex;\n             } catch (Exception e) {\n-                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", index, e);\n+                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", destinationIndex, e);\n             }\n         }\n+        this.auditLogPattern = auditLogPattern;\n+        this.auditLogIndex = auditLogIndex;\n \n-        log.info(\"PII configuration [auditLogPattern={},  auditLogIndex={}]: {}\", auditLogPattern, auditLogIndex, readEnabledFields);\n-\n-\n-        cache = CacheBuilder.newBuilder()\n-                .maximumSize(1000)\n+        this.cache = CacheBuilder.newBuilder()\n+                .maximumSize(CACHE_SIZE)\n                 .build(new CacheLoader<String, Set<String>>() {\n                     @Override\n                     public Set<String> load(String index) throws Exception {\n-                        return getFieldsForIndex0(index);\n+                        return getFieldsForIndex(index);\n                     }\n                 });\n     }\n \n-    public boolean isLogExternalConfig() {\n-\t\treturn logExternalConfig;\n-\t}\n+    public void log(Logger logger) {\n+        logger.info(\"Auditing of external configuration is {}.\", logExternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing of internal configuration is {}.\", logInternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing only metadata information for read request is {}.\", logReadMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for read requests.\", readEnabledFields);\n+        logger.info(\"Auditing only metadata information for write request is {}.\", logWriteMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing diffs for write requests is {}.\", logDiffsForWrite ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for write requests.\", watchedWriteIndices);\n+        logger.info(\"{} indices are made immutable.\", immutableIndicesPatterns);\n+        logger.info(\"{} is used as internal security index.\", opendistrosecurityIndex);\n+        logger.info(\"Internal index used for posting audit logs is {}\", auditLogIndex);\n+    }\n+\n+    /**\n+     * Create compliance configuration from Settings defined in elasticsearch.yml\n+     * @param settings settings\n+     * @return compliance configuration\n+     */\n+    public static ComplianceConfig from(Settings settings) {\n+        final boolean logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n+        final boolean logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n+        final boolean logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n+        final boolean logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n+        final boolean logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n+        final List<String> watchedReadFields = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n+                Collections.emptyList(), false);\n+        final List<String> watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n+        final Set<String> immutableIndicesPatterns = ImmutableSet.copyOf(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n+        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n+        final String opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n+        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n+        final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX, \"'security-auditlog-'YYYY.MM.dd\");\n+\n+        return new ComplianceConfig(\n+                logExternalConfig,\n+                logInternalConfig,\n+                logReadMetadataOnly,\n+                logWriteMetadataOnly,\n+                logDiffsForWrite,\n+                watchedReadFields,\n+                watchedWriteIndices,\n+                immutableIndicesPatterns,\n+                saltAsString,\n+                opendistrosecurityIndex,\n+                type,\n+                index);\n+    }\n \n-\tpublic boolean isExternalConfigLogged() {\n-\t\treturn externalConfigLogged;\n-\t}\n+    /**\n+     * Checks if config defined in elasticsearch config directory must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogExternalConfig() {\n+        return logExternalConfig;\n+    }\n \n-\tpublic void setExternalConfigLogged(boolean externalConfigLogged) {\n-\t\tthis.externalConfigLogged = externalConfigLogged;\n-\t}\n+    /**\n+     * Checks if internal config must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogInternalConfig() {\n+        return logInternalConfig;\n+    }\n \n-\tpublic boolean isEnabled() {\n+    /**\n+     * Checks if compliance is enabled\n+     * @return true/false\n+     */\n+    public boolean isEnabled() {\n         return this.enabled;\n     }\n \n-    //cached\n-    @SuppressWarnings(\"unchecked\")\n-    private Set<String> getFieldsForIndex0(String index) {\n+    /**\n+     * Checks if logs diffs must be recorded for write requests\n+     * Log metadata only for write requests must be disabled\n+     * @return true/false\n+     */\n+    public boolean shouldLogDiffsForWrite() {\n+        return !shouldLogWriteMetadataOnly() && logDiffsForWrite;\n+    }\n+\n+    /**\n+     * Checks if only metadata for write requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogWriteMetadataOnly() {\n+        return logWriteMetadataOnly;\n+    }\n \n-        if(index == null) {\n-            return Collections.EMPTY_SET;\n+    /**\n+     * Checks if only metadata for read requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogReadMetadataOnly() {\n+        return logReadMetadataOnly;\n+    }\n+\n+    /**\n+     * Get set of immutable index pattern\n+     * @return set of index patterns\n+     */\n+    public Set<String> getImmutableIndicesPatterns() {\n+        return immutableIndicesPatterns;\n+    }\n+\n+    /**\n+     * Get the salt in bytes for filed anonymization\n+     * @return salt in bytes\n+     */\n+    public byte[] getSalt16() {\n+        return salt16.clone();\n+    }\n+\n+    /**\n+     * This function is used for caching the fields\n+     * @param index index to check for fields\n+     * @return set of fields which is used by cache\n+     */\n+    private Set<String> getFieldsForIndex(String index) {\n+        if (index == null) {\n+            return Collections.emptySet();\n         }\n \n-        if(auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n-            return Collections.EMPTY_SET;\n+        if (auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n+            return Collections.emptySet();\n         }\n \n-        if(auditLogPattern != null) {\n-            if(index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n-                return Collections.EMPTY_SET;\n+        if (auditLogPattern != null) {\n+            if (index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n+                return Collections.emptySet();\n             }\n         }\n \n         final Set<String> tmp = new HashSet<String>(100);\n-        for(String indexPattern: readEnabledFields.keySet()) {\n-            if(indexPattern != null && !indexPattern.isEmpty() && WildcardMatcher.match(indexPattern, index)) {\n+        for (String indexPattern : readEnabledFields.keySet()) {", "originalCommit": "9cac07bcbd203f2ee90acbfae5e75592080ac27e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8aa0b0a7808adf463c7811313142895ccbeaa0b9", "url": "https://github.com/opensearch-project/security/commit/8aa0b0a7808adf463c7811313142895ccbeaa0b9", "message": "address code reviews", "committedDate": "2020-04-17T22:50:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNTc3Ng==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410505776", "bodyText": "private volatile or private final AtomicReference", "author": "vrozov", "createdAt": "2020-04-17T22:53:48Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/impl/AbstractAuditLog.java", "diffHunk": "@@ -87,6 +87,7 @@\n     private final Settings settings;\n     private final AuditConfig.Filter auditConfigFilter;\n     private final String opendistrosecurityIndex;\n+    protected ComplianceConfig complianceConfig;", "originalCommit": "27d15469e0c14fd342441f62200adfd654e5323a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNjc0OA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410506748", "bodyText": "I thought of doing the volatile change when subscribe is added.\nBut I ll add it here itself", "author": "sujithvm", "createdAt": "2020-04-17T22:58:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNTc3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMDQ3Ng==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410520476", "bodyText": "If you remove setter (setComplienceConfig()), it can wait till subscribe is added.", "author": "vrozov", "createdAt": "2020-04-18T00:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNTc3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjE5OQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410522199", "bodyText": "Alright. I will remove setter setComplienceConfig  and re-add when needed", "author": "sujithvm", "createdAt": "2020-04-18T00:14:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNTc3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNjU4NQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410506585", "bodyText": "getCurrentComplianceConfig -> getComplianceConfig", "author": "vrozov", "createdAt": "2020-04-17T22:57:25Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/AuditLog.java", "diffHunk": "@@ -69,13 +69,15 @@\n     void logSSLException(TransportRequest request, Throwable t, String action, Task task);\n     void logSSLException(RestRequest request, Throwable t);\n \n-    void logDocumentRead(String index, String id, ShardId shardId, Map<String, String> fieldNameValues, ComplianceConfig complianceConfig);\n-    void logDocumentWritten(ShardId shardId, GetResult originalIndex, Index currentIndex, IndexResult result, ComplianceConfig complianceConfig);\n+    void logDocumentRead(String index, String id, ShardId shardId, Map<String, String> fieldNameValues);\n+    void logDocumentWritten(ShardId shardId, GetResult originalIndex, Index currentIndex, IndexResult result);\n     void logDocumentDeleted(ShardId shardId, Delete delete, DeleteResult result);\n     void logExternalConfig(Settings settings, Environment environment);\n     \n     // compliance config\n     void setComplianceConfig(ComplianceConfig complianceConfig);\n+\n+    ComplianceConfig getCurrentComplianceConfig();", "originalCommit": "8aa0b0a7808adf463c7811313142895ccbeaa0b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNjkyNw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410506927", "bodyText": "I thought the name getCurrentComplianceConfig will be more descriptive that config fetched is the latest/current config", "author": "sujithvm", "createdAt": "2020-04-17T22:58:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNjU4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxNjg0Nw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410516847", "bodyText": "Let me know if you would like to use getComplianceConfig itself or some other name.", "author": "sujithvm", "createdAt": "2020-04-17T23:44:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNjU4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMDE0OA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410520148", "bodyText": "getCurrentComplienceConfig() is confusing, IMO. It is just a getter method, it can only get the current value, there is no any other values to get.", "author": "vrozov", "createdAt": "2020-04-18T00:02:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNjU4NQ=="}], "type": "inlineReview"}, {"oid": "f118d8ca5ec55ee20cda0fb93080283cb170f872", "url": "https://github.com/opensearch-project/security/commit/f118d8ca5ec55ee20cda0fb93080283cb170f872", "message": "address code review - use volatile for compliance config", "committedDate": "2020-04-17T23:44:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxNjk3NA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410516974", "bodyText": "Is it necessary to have setComplianceConfig() method? Can it be instantiated inside AbstractAuditLog constructor?", "author": "vrozov", "createdAt": "2020-04-17T23:44:49Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/AuditLog.java", "diffHunk": "@@ -69,13 +69,15 @@\n     void logSSLException(TransportRequest request, Throwable t, String action, Task task);\n     void logSSLException(RestRequest request, Throwable t);\n \n-    void logDocumentRead(String index, String id, ShardId shardId, Map<String, String> fieldNameValues, ComplianceConfig complianceConfig);\n-    void logDocumentWritten(ShardId shardId, GetResult originalIndex, Index currentIndex, IndexResult result, ComplianceConfig complianceConfig);\n+    void logDocumentRead(String index, String id, ShardId shardId, Map<String, String> fieldNameValues);\n+    void logDocumentWritten(ShardId shardId, GetResult originalIndex, Index currentIndex, IndexResult result);\n     void logDocumentDeleted(ShardId shardId, Delete delete, DeleteResult result);\n     void logExternalConfig(Settings settings, Environment environment);\n     \n     // compliance config\n     void setComplianceConfig(ComplianceConfig complianceConfig);", "originalCommit": "8aa0b0a7808adf463c7811313142895ccbeaa0b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxNzUzNQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410517535", "bodyText": "I want to retain this method as subscribing for changes should be as simple as adding @Subscribe to the function.", "author": "sujithvm", "createdAt": "2020-04-17T23:47:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxNjk3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxOTg4OA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410519888", "bodyText": "@Subscribe should not be on the interface method. NullAuditLog should not subscribe to the event bus.", "author": "vrozov", "createdAt": "2020-04-18T00:01:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxNjk3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMDgyNw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410520827", "bodyText": "Sorry I meant the function in AuditLogImpl and not this interface method", "author": "sujithvm", "createdAt": "2020-04-18T00:06:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxNjk3NA=="}], "type": "inlineReview"}, {"oid": "039cbb512fed692151bfebe74121e0466d9b4426", "url": "https://github.com/opensearch-project/security/commit/039cbb512fed692151bfebe74121e0466d9b4426", "message": "Address code reviews - use auditLog getComplianceConfig()", "committedDate": "2020-04-18T00:09:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjkzNw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410522937", "bodyText": "It should be private. If necessary, there is public getter.", "author": "vrozov", "createdAt": "2020-04-18T00:19:52Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/impl/AbstractAuditLog.java", "diffHunk": "@@ -87,6 +87,7 @@\n     private final Settings settings;\n     private final AuditConfig.Filter auditConfigFilter;\n     private final String opendistrosecurityIndex;\n+    protected volatile ComplianceConfig complianceConfig;", "originalCommit": "039cbb512fed692151bfebe74121e0466d9b4426", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3b3f743f226d46372e95f363db243080b0406694", "url": "https://github.com/opensearch-project/security/commit/3b3f743f226d46372e95f363db243080b0406694", "message": "remove setComplianceConfig", "committedDate": "2020-04-18T01:13:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU3NDU5Nw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410574597", "bodyText": "Consider:\n            log.warn(\"Failed to get index {} fields enabled for read from cache. Bypassing cache.\", index, e);\n            return getFieldsForIndex(index).isEmpty();", "author": "vrozov", "createdAt": "2020-04-18T02:53:15Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -31,292 +31,354 @@\n package com.amazon.opendistroforelasticsearch.security.compliance;\n \n import java.nio.charset.StandardCharsets;\n-import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndicesPatterns;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n+\n+    private final Map<String, Set<String>> readEnabledFields;\n+    private final LoadingCache<String, Set<String>> readEnabledFieldsCache;\n+    private final byte[] salt16;\n+    private final DateTimeFormatter auditLogPattern;\n+    private final String auditLogIndex;\n     private volatile boolean enabled = true;\n-    private volatile boolean externalConfigLogged = false;\n-\n-    public ComplianceConfig(final Environment environment, final IndexResolverReplacer irr, final AuditLog auditLog) {\n-        super();\n-        this.settings = environment.settings();\n-        this.environment = environment;\n-        this.irr = irr;\n-        this.auditLog = auditLog;\n-        final List<String> watchedReadFields = this.settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n-                Collections.emptyList(), false);\n \n-        watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n-        logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n-        logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n-        logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n-        logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n-        logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n-        immutableIndicesPatterns = new HashSet<String>(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n-        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n-        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+    private ComplianceConfig(\n+            final boolean logExternalConfig,\n+            final boolean logInternalConfig,\n+            final boolean logReadMetadataOnly,\n+            final boolean logWriteMetadataOnly,\n+            final boolean logDiffsForWrite,\n+            final List<String> watchedReadFields,\n+            final List<String> watchedWriteIndicesPatterns,\n+            final Set<String> immutableIndicesPatterns,\n+            final String saltAsString,\n+            final String opendistrosecurityIndex,\n+            final String destinationType,\n+            final String destinationIndex) {\n+        this.logExternalConfig = logExternalConfig;\n+        this.logInternalConfig = logInternalConfig;\n+        this.logReadMetadataOnly = logReadMetadataOnly;\n+        this.logWriteMetadataOnly = logWriteMetadataOnly;\n+        this.logDiffsForWrite = logDiffsForWrite;\n+        this.watchedWriteIndicesPatterns = watchedWriteIndicesPatterns;\n+        this.immutableIndicesPatterns = immutableIndicesPatterns;\n+        this.opendistrosecurityIndex = opendistrosecurityIndex;\n \n-        if(saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n-            log.warn(\"If you plan to use field masking pls configure \"+ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" to be a random string of 16 chars length identical on all nodes\");\n+        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+        if (saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n+            log.warn(\"If you plan to use field masking pls configure compliance salt {} to be a random string of 16 chars length identical on all nodes\", saltAsString);\n         }\n-        \n-        if(saltAsBytes.length < 16) {\n-            throw new ElasticsearchException(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" must at least contain 16 bytes\");\n+        if (saltAsBytes.length < SALT_SIZE) {\n+            throw new ElasticsearchException(\"Provided compliance salt \" + saltAsString + \" must at least contain 16 bytes\");\n         }\n-        \n-        if(saltAsBytes.length > 16) {\n-            log.warn(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" is greater than 16 bytes. Only the first 16 bytes are used for salting\");\n+        if (saltAsBytes.length > SALT_SIZE) {\n+            log.warn(\"Provided compliance salt {} is greater than 16 bytes. Only the first 16 bytes are used for salting\", saltAsString);\n         }\n-        \n-        salt16 = Arrays.copyOf(saltAsBytes, 16);\n-        this.opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n-        \n+        this.salt16 = Arrays.copyOf(saltAsBytes, SALT_SIZE);\n+\n         //opendistro_security.compliance.pii_fields:\n         //  - indexpattern,fieldpattern,fieldpattern,....\n-        for(String watchedReadField: watchedReadFields) {\n-            final List<String> split = new ArrayList<>(Arrays.asList(watchedReadField.split(\",\")));\n-            if(split.isEmpty()) {\n-                continue;\n-            } else if(split.size() == 1) {\n-                readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n-            } else {\n-                Set<String> _fields = new HashSet<String>(split.subList(1, split.size()));\n-                readEnabledFields.put(split.get(0), _fields);\n-            }\n-        }\n-\n-        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n-        if(\"internal_elasticsearch\".equalsIgnoreCase(type)) {\n-            final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX,\"'security-auditlog-'YYYY.MM.dd\");\n+        this.readEnabledFields = watchedReadFields.stream()\n+                .map(watchedReadField -> watchedReadField.split(\",\"))\n+                .filter(split -> split.length != 0 && !Strings.isNullOrEmpty(split[0]))\n+                .collect(Collectors.toMap(\n+                        split -> split[0],\n+                        split -> split.length == 1 ?\n+                                Collections.singleton(\"*\") : Arrays.stream(split).skip(1).collect(Collectors.toSet())\n+                ));\n+\n+        DateTimeFormatter auditLogPattern = null;\n+        String auditLogIndex = null;\n+        if (INTERNAL_ELASTICSEARCH.equalsIgnoreCase(destinationType)) {\n             try {\n-                auditLogPattern = DateTimeFormat.forPattern(index); //throws IllegalArgumentException if no pattern\n+                auditLogPattern = DateTimeFormat.forPattern(destinationIndex); //throws IllegalArgumentException if no pattern\n             } catch (IllegalArgumentException e) {\n                 //no pattern\n-                auditLogIndex = index;\n+                auditLogIndex = destinationIndex;\n             } catch (Exception e) {\n-                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", index, e);\n+                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", destinationIndex, e);\n             }\n         }\n+        this.auditLogPattern = auditLogPattern;\n+        this.auditLogIndex = auditLogIndex;\n \n-        log.info(\"PII configuration [auditLogPattern={},  auditLogIndex={}]: {}\", auditLogPattern, auditLogIndex, readEnabledFields);\n-\n-\n-        cache = CacheBuilder.newBuilder()\n-                .maximumSize(1000)\n+        this.readEnabledFieldsCache = CacheBuilder.newBuilder()\n+                .maximumSize(CACHE_SIZE)\n                 .build(new CacheLoader<String, Set<String>>() {\n                     @Override\n                     public Set<String> load(String index) throws Exception {\n-                        return getFieldsForIndex0(index);\n+                        return getFieldsForIndex(index);\n                     }\n                 });\n     }\n \n-    public boolean isLogExternalConfig() {\n-\t\treturn logExternalConfig;\n-\t}\n+    public void log(Logger logger) {\n+        logger.info(\"Auditing of external configuration is {}.\", logExternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing of internal configuration is {}.\", logInternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing only metadata information for read request is {}.\", logReadMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for read requests.\", readEnabledFields);\n+        logger.info(\"Auditing only metadata information for write request is {}.\", logWriteMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing diffs for write requests is {}.\", logDiffsForWrite ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for write requests.\", watchedWriteIndicesPatterns);\n+        logger.info(\"{} indices are made immutable.\", immutableIndicesPatterns);\n+        logger.info(\"{} is used as internal security index.\", opendistrosecurityIndex);\n+        logger.info(\"Internal index used for posting audit logs is {}\", auditLogIndex);\n+    }\n \n-\tpublic boolean isExternalConfigLogged() {\n-\t\treturn externalConfigLogged;\n-\t}\n+    /**\n+     * Create compliance configuration from Settings defined in elasticsearch.yml\n+     * @param settings settings\n+     * @return compliance configuration\n+     */\n+    public static ComplianceConfig from(Settings settings) {\n+        final boolean logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n+        final boolean logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n+        final boolean logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n+        final boolean logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n+        final boolean logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n+        final List<String> watchedReadFields = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n+                Collections.emptyList(), false);\n+        final List<String> watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n+        final Set<String> immutableIndicesPatterns = ImmutableSet.copyOf(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n+        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n+        final String opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n+        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n+        final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX, \"'security-auditlog-'YYYY.MM.dd\");\n+\n+        return new ComplianceConfig(\n+                logExternalConfig,\n+                logInternalConfig,\n+                logReadMetadataOnly,\n+                logWriteMetadataOnly,\n+                logDiffsForWrite,\n+                watchedReadFields,\n+                watchedWriteIndices,\n+                immutableIndicesPatterns,\n+                saltAsString,\n+                opendistrosecurityIndex,\n+                type,\n+                index);\n+    }\n+\n+    /**\n+     * Checks if config defined in elasticsearch config directory must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogExternalConfig() {\n+        return logExternalConfig;\n+    }\n \n-\tpublic void setExternalConfigLogged(boolean externalConfigLogged) {\n-\t\tthis.externalConfigLogged = externalConfigLogged;\n-\t}\n+    /**\n+     * Checks if internal config must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogInternalConfig() {\n+        return logInternalConfig;\n+    }\n \n-\tpublic boolean isEnabled() {\n+    /**\n+     * Checks if compliance is enabled\n+     * @return true/false\n+     */\n+    public boolean isEnabled() {\n         return this.enabled;\n     }\n \n-    //cached\n-    @SuppressWarnings(\"unchecked\")\n-    private Set<String> getFieldsForIndex0(String index) {\n+    /**\n+     * Checks if logs diffs must be recorded for write requests\n+     * Log metadata only for write requests must be disabled\n+     * @return true/false\n+     */\n+    public boolean shouldLogDiffsForWrite() {\n+        return !shouldLogWriteMetadataOnly() && logDiffsForWrite;\n+    }\n \n-        if(index == null) {\n-            return Collections.EMPTY_SET;\n-        }\n+    /**\n+     * Checks if only metadata for write requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogWriteMetadataOnly() {\n+        return logWriteMetadataOnly;\n+    }\n \n-        if(auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n-            return Collections.EMPTY_SET;\n+    /**\n+     * Checks if only metadata for read requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogReadMetadataOnly() {\n+        return logReadMetadataOnly;\n+    }\n+\n+    /**\n+     * Get set of immutable index pattern\n+     * @return set of index patterns\n+     */\n+    public Set<String> getImmutableIndicesPatterns() {\n+        return immutableIndicesPatterns;\n+    }\n+\n+    /**\n+     * Get the salt in bytes for filed anonymization\n+     * @return salt in bytes\n+     */\n+    public byte[] getSalt16() {\n+        return Arrays.copyOf(salt16, salt16.length);\n+    }\n+\n+    /**\n+     * This function is used for caching the fields\n+     * @param index index to check for fields\n+     * @return set of fields which is used by cache\n+     */\n+    private Set<String> getFieldsForIndex(String index) {\n+        if (index == null) {\n+            return Collections.emptySet();\n         }\n \n-        if(auditLogPattern != null) {\n-            if(index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n-                return Collections.EMPTY_SET;\n-            }\n+        if (auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n+            return Collections.emptySet();\n         }\n \n-        final Set<String> tmp = new HashSet<String>(100);\n-        for(String indexPattern: readEnabledFields.keySet()) {\n-            if(indexPattern != null && !indexPattern.isEmpty() && WildcardMatcher.match(indexPattern, index)) {\n-                tmp.addAll(readEnabledFields.get(indexPattern));\n+        if (auditLogPattern != null) {\n+            if (index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n+                return Collections.emptySet();\n             }\n         }\n-        return tmp;\n+\n+        return readEnabledFields.entrySet().stream()\n+                .filter(entry -> WildcardMatcher.match(entry.getKey(), index))\n+                .flatMap(entry -> entry.getValue().stream())\n+                .collect(Collectors.toSet());\n     }\n \n+    /**\n+     * Get the index name with date pattern for rolling indexes\n+     * @param indexPattern index pattern\n+     * @param index index\n+     * @return index name\n+     */\n     private String getExpandedIndexName(DateTimeFormatter indexPattern, String index) {\n-        if(indexPattern == null) {\n+        if (indexPattern == null) {\n             return index;\n         }\n         return indexPattern.print(DateTime.now(DateTimeZone.UTC));\n     }\n \n-    //do not check for isEnabled\n+    /**\n+     * Check if write history is enabled for the index.\n+     * Does not check for compliance here.\n+     * @param index index\n+     * @return true/false\n+     */\n     public boolean writeHistoryEnabledForIndex(String index) {\n-\n-        if(index == null) {\n+        if (index == null) {\n             return false;\n         }\n-        \n-        if(opendistrosecurityIndex.equals(index)) {\n+        // if open distro index (internal index) check if internal config logging is enabled\n+        if (opendistrosecurityIndex.equals(index)) {\n             return logInternalConfig;\n         }\n-\n-        if(auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n+        // if the index is used for audit logging, return false\n+        if (auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n             return false;\n         }\n-\n-        if(auditLogPattern != null) {\n-            if(index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n+        // if the index is used for audit logging (rolling index name), return false\n+        if (auditLogPattern != null) {\n+            if (index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n                 return false;\n             }\n         }\n-\n-        return WildcardMatcher.matchAny(watchedWriteIndices, index);\n+        return WildcardMatcher.matchAny(watchedWriteIndicesPatterns, index);\n     }\n \n-    //no patterns here as parameters\n-    //check for isEnabled\n+    /**\n+     * Check if read compliance history is enabled for given index\n+     * Checks if compliance is enabled\n+     * @param index index\n+     * @return true/false\n+     */\n     public boolean readHistoryEnabledForIndex(String index) {\n-        \n-        if(!this.enabled) {\n+        if (!this.isEnabled()) {\n             return false;\n         }\n-        \n-        if(opendistrosecurityIndex.equals(index)) {\n+        // if open distro index (internal index) check if internal config logging is enabled\n+        if (opendistrosecurityIndex.equals(index)) {\n             return logInternalConfig;\n         }\n-        \n         try {\n-            return !cache.get(index).isEmpty();\n+            return !readEnabledFieldsCache.get(index).isEmpty();\n         } catch (ExecutionException e) {\n             log.error(e);", "originalCommit": "3b3f743f226d46372e95f363db243080b0406694", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU3NTE4NA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410575184", "bodyText": "Consider:\n            log.warn(\"Failed to get index {} fields enabled for read from cache. Bypassing cache.\", index, e);\n            fields = getFieldsForIndex(index);", "author": "vrozov", "createdAt": "2020-04-18T02:54:40Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -31,292 +31,354 @@\n package com.amazon.opendistroforelasticsearch.security.compliance;\n \n import java.nio.charset.StandardCharsets;\n-import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndicesPatterns;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n+\n+    private final Map<String, Set<String>> readEnabledFields;\n+    private final LoadingCache<String, Set<String>> readEnabledFieldsCache;\n+    private final byte[] salt16;\n+    private final DateTimeFormatter auditLogPattern;\n+    private final String auditLogIndex;\n     private volatile boolean enabled = true;\n-    private volatile boolean externalConfigLogged = false;\n-\n-    public ComplianceConfig(final Environment environment, final IndexResolverReplacer irr, final AuditLog auditLog) {\n-        super();\n-        this.settings = environment.settings();\n-        this.environment = environment;\n-        this.irr = irr;\n-        this.auditLog = auditLog;\n-        final List<String> watchedReadFields = this.settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n-                Collections.emptyList(), false);\n \n-        watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n-        logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n-        logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n-        logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n-        logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n-        logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n-        immutableIndicesPatterns = new HashSet<String>(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n-        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n-        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+    private ComplianceConfig(\n+            final boolean logExternalConfig,\n+            final boolean logInternalConfig,\n+            final boolean logReadMetadataOnly,\n+            final boolean logWriteMetadataOnly,\n+            final boolean logDiffsForWrite,\n+            final List<String> watchedReadFields,\n+            final List<String> watchedWriteIndicesPatterns,\n+            final Set<String> immutableIndicesPatterns,\n+            final String saltAsString,\n+            final String opendistrosecurityIndex,\n+            final String destinationType,\n+            final String destinationIndex) {\n+        this.logExternalConfig = logExternalConfig;\n+        this.logInternalConfig = logInternalConfig;\n+        this.logReadMetadataOnly = logReadMetadataOnly;\n+        this.logWriteMetadataOnly = logWriteMetadataOnly;\n+        this.logDiffsForWrite = logDiffsForWrite;\n+        this.watchedWriteIndicesPatterns = watchedWriteIndicesPatterns;\n+        this.immutableIndicesPatterns = immutableIndicesPatterns;\n+        this.opendistrosecurityIndex = opendistrosecurityIndex;\n \n-        if(saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n-            log.warn(\"If you plan to use field masking pls configure \"+ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" to be a random string of 16 chars length identical on all nodes\");\n+        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+        if (saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n+            log.warn(\"If you plan to use field masking pls configure compliance salt {} to be a random string of 16 chars length identical on all nodes\", saltAsString);\n         }\n-        \n-        if(saltAsBytes.length < 16) {\n-            throw new ElasticsearchException(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" must at least contain 16 bytes\");\n+        if (saltAsBytes.length < SALT_SIZE) {\n+            throw new ElasticsearchException(\"Provided compliance salt \" + saltAsString + \" must at least contain 16 bytes\");\n         }\n-        \n-        if(saltAsBytes.length > 16) {\n-            log.warn(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" is greater than 16 bytes. Only the first 16 bytes are used for salting\");\n+        if (saltAsBytes.length > SALT_SIZE) {\n+            log.warn(\"Provided compliance salt {} is greater than 16 bytes. Only the first 16 bytes are used for salting\", saltAsString);\n         }\n-        \n-        salt16 = Arrays.copyOf(saltAsBytes, 16);\n-        this.opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n-        \n+        this.salt16 = Arrays.copyOf(saltAsBytes, SALT_SIZE);\n+\n         //opendistro_security.compliance.pii_fields:\n         //  - indexpattern,fieldpattern,fieldpattern,....\n-        for(String watchedReadField: watchedReadFields) {\n-            final List<String> split = new ArrayList<>(Arrays.asList(watchedReadField.split(\",\")));\n-            if(split.isEmpty()) {\n-                continue;\n-            } else if(split.size() == 1) {\n-                readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n-            } else {\n-                Set<String> _fields = new HashSet<String>(split.subList(1, split.size()));\n-                readEnabledFields.put(split.get(0), _fields);\n-            }\n-        }\n-\n-        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n-        if(\"internal_elasticsearch\".equalsIgnoreCase(type)) {\n-            final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX,\"'security-auditlog-'YYYY.MM.dd\");\n+        this.readEnabledFields = watchedReadFields.stream()\n+                .map(watchedReadField -> watchedReadField.split(\",\"))\n+                .filter(split -> split.length != 0 && !Strings.isNullOrEmpty(split[0]))\n+                .collect(Collectors.toMap(\n+                        split -> split[0],\n+                        split -> split.length == 1 ?\n+                                Collections.singleton(\"*\") : Arrays.stream(split).skip(1).collect(Collectors.toSet())\n+                ));\n+\n+        DateTimeFormatter auditLogPattern = null;\n+        String auditLogIndex = null;\n+        if (INTERNAL_ELASTICSEARCH.equalsIgnoreCase(destinationType)) {\n             try {\n-                auditLogPattern = DateTimeFormat.forPattern(index); //throws IllegalArgumentException if no pattern\n+                auditLogPattern = DateTimeFormat.forPattern(destinationIndex); //throws IllegalArgumentException if no pattern\n             } catch (IllegalArgumentException e) {\n                 //no pattern\n-                auditLogIndex = index;\n+                auditLogIndex = destinationIndex;\n             } catch (Exception e) {\n-                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", index, e);\n+                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", destinationIndex, e);\n             }\n         }\n+        this.auditLogPattern = auditLogPattern;\n+        this.auditLogIndex = auditLogIndex;\n \n-        log.info(\"PII configuration [auditLogPattern={},  auditLogIndex={}]: {}\", auditLogPattern, auditLogIndex, readEnabledFields);\n-\n-\n-        cache = CacheBuilder.newBuilder()\n-                .maximumSize(1000)\n+        this.readEnabledFieldsCache = CacheBuilder.newBuilder()\n+                .maximumSize(CACHE_SIZE)\n                 .build(new CacheLoader<String, Set<String>>() {\n                     @Override\n                     public Set<String> load(String index) throws Exception {\n-                        return getFieldsForIndex0(index);\n+                        return getFieldsForIndex(index);\n                     }\n                 });\n     }\n \n-    public boolean isLogExternalConfig() {\n-\t\treturn logExternalConfig;\n-\t}\n+    public void log(Logger logger) {\n+        logger.info(\"Auditing of external configuration is {}.\", logExternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing of internal configuration is {}.\", logInternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing only metadata information for read request is {}.\", logReadMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for read requests.\", readEnabledFields);\n+        logger.info(\"Auditing only metadata information for write request is {}.\", logWriteMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing diffs for write requests is {}.\", logDiffsForWrite ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for write requests.\", watchedWriteIndicesPatterns);\n+        logger.info(\"{} indices are made immutable.\", immutableIndicesPatterns);\n+        logger.info(\"{} is used as internal security index.\", opendistrosecurityIndex);\n+        logger.info(\"Internal index used for posting audit logs is {}\", auditLogIndex);\n+    }\n \n-\tpublic boolean isExternalConfigLogged() {\n-\t\treturn externalConfigLogged;\n-\t}\n+    /**\n+     * Create compliance configuration from Settings defined in elasticsearch.yml\n+     * @param settings settings\n+     * @return compliance configuration\n+     */\n+    public static ComplianceConfig from(Settings settings) {\n+        final boolean logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n+        final boolean logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n+        final boolean logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n+        final boolean logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n+        final boolean logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n+        final List<String> watchedReadFields = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n+                Collections.emptyList(), false);\n+        final List<String> watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n+        final Set<String> immutableIndicesPatterns = ImmutableSet.copyOf(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n+        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n+        final String opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n+        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n+        final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX, \"'security-auditlog-'YYYY.MM.dd\");\n+\n+        return new ComplianceConfig(\n+                logExternalConfig,\n+                logInternalConfig,\n+                logReadMetadataOnly,\n+                logWriteMetadataOnly,\n+                logDiffsForWrite,\n+                watchedReadFields,\n+                watchedWriteIndices,\n+                immutableIndicesPatterns,\n+                saltAsString,\n+                opendistrosecurityIndex,\n+                type,\n+                index);\n+    }\n+\n+    /**\n+     * Checks if config defined in elasticsearch config directory must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogExternalConfig() {\n+        return logExternalConfig;\n+    }\n \n-\tpublic void setExternalConfigLogged(boolean externalConfigLogged) {\n-\t\tthis.externalConfigLogged = externalConfigLogged;\n-\t}\n+    /**\n+     * Checks if internal config must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogInternalConfig() {\n+        return logInternalConfig;\n+    }\n \n-\tpublic boolean isEnabled() {\n+    /**\n+     * Checks if compliance is enabled\n+     * @return true/false\n+     */\n+    public boolean isEnabled() {\n         return this.enabled;\n     }\n \n-    //cached\n-    @SuppressWarnings(\"unchecked\")\n-    private Set<String> getFieldsForIndex0(String index) {\n+    /**\n+     * Checks if logs diffs must be recorded for write requests\n+     * Log metadata only for write requests must be disabled\n+     * @return true/false\n+     */\n+    public boolean shouldLogDiffsForWrite() {\n+        return !shouldLogWriteMetadataOnly() && logDiffsForWrite;\n+    }\n \n-        if(index == null) {\n-            return Collections.EMPTY_SET;\n-        }\n+    /**\n+     * Checks if only metadata for write requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogWriteMetadataOnly() {\n+        return logWriteMetadataOnly;\n+    }\n \n-        if(auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n-            return Collections.EMPTY_SET;\n+    /**\n+     * Checks if only metadata for read requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogReadMetadataOnly() {\n+        return logReadMetadataOnly;\n+    }\n+\n+    /**\n+     * Get set of immutable index pattern\n+     * @return set of index patterns\n+     */\n+    public Set<String> getImmutableIndicesPatterns() {\n+        return immutableIndicesPatterns;\n+    }\n+\n+    /**\n+     * Get the salt in bytes for filed anonymization\n+     * @return salt in bytes\n+     */\n+    public byte[] getSalt16() {\n+        return Arrays.copyOf(salt16, salt16.length);\n+    }\n+\n+    /**\n+     * This function is used for caching the fields\n+     * @param index index to check for fields\n+     * @return set of fields which is used by cache\n+     */\n+    private Set<String> getFieldsForIndex(String index) {\n+        if (index == null) {\n+            return Collections.emptySet();\n         }\n \n-        if(auditLogPattern != null) {\n-            if(index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n-                return Collections.EMPTY_SET;\n-            }\n+        if (auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n+            return Collections.emptySet();\n         }\n \n-        final Set<String> tmp = new HashSet<String>(100);\n-        for(String indexPattern: readEnabledFields.keySet()) {\n-            if(indexPattern != null && !indexPattern.isEmpty() && WildcardMatcher.match(indexPattern, index)) {\n-                tmp.addAll(readEnabledFields.get(indexPattern));\n+        if (auditLogPattern != null) {\n+            if (index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n+                return Collections.emptySet();\n             }\n         }\n-        return tmp;\n+\n+        return readEnabledFields.entrySet().stream()\n+                .filter(entry -> WildcardMatcher.match(entry.getKey(), index))\n+                .flatMap(entry -> entry.getValue().stream())\n+                .collect(Collectors.toSet());\n     }\n \n+    /**\n+     * Get the index name with date pattern for rolling indexes\n+     * @param indexPattern index pattern\n+     * @param index index\n+     * @return index name\n+     */\n     private String getExpandedIndexName(DateTimeFormatter indexPattern, String index) {\n-        if(indexPattern == null) {\n+        if (indexPattern == null) {\n             return index;\n         }\n         return indexPattern.print(DateTime.now(DateTimeZone.UTC));\n     }\n \n-    //do not check for isEnabled\n+    /**\n+     * Check if write history is enabled for the index.\n+     * Does not check for compliance here.\n+     * @param index index\n+     * @return true/false\n+     */\n     public boolean writeHistoryEnabledForIndex(String index) {\n-\n-        if(index == null) {\n+        if (index == null) {\n             return false;\n         }\n-        \n-        if(opendistrosecurityIndex.equals(index)) {\n+        // if open distro index (internal index) check if internal config logging is enabled\n+        if (opendistrosecurityIndex.equals(index)) {\n             return logInternalConfig;\n         }\n-\n-        if(auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n+        // if the index is used for audit logging, return false\n+        if (auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n             return false;\n         }\n-\n-        if(auditLogPattern != null) {\n-            if(index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n+        // if the index is used for audit logging (rolling index name), return false\n+        if (auditLogPattern != null) {\n+            if (index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n                 return false;\n             }\n         }\n-\n-        return WildcardMatcher.matchAny(watchedWriteIndices, index);\n+        return WildcardMatcher.matchAny(watchedWriteIndicesPatterns, index);\n     }\n \n-    //no patterns here as parameters\n-    //check for isEnabled\n+    /**\n+     * Check if read compliance history is enabled for given index\n+     * Checks if compliance is enabled\n+     * @param index index\n+     * @return true/false\n+     */\n     public boolean readHistoryEnabledForIndex(String index) {\n-        \n-        if(!this.enabled) {\n+        if (!this.isEnabled()) {\n             return false;\n         }\n-        \n-        if(opendistrosecurityIndex.equals(index)) {\n+        // if open distro index (internal index) check if internal config logging is enabled\n+        if (opendistrosecurityIndex.equals(index)) {\n             return logInternalConfig;\n         }\n-        \n         try {\n-            return !cache.get(index).isEmpty();\n+            return !readEnabledFieldsCache.get(index).isEmpty();\n         } catch (ExecutionException e) {\n             log.error(e);\n             return true;\n         }\n     }\n \n-    //no patterns here as parameters\n-    //check for isEnabled\n+    /**\n+     * Check if read compliance history is enabled for given index\n+     * Checks if compliance is enabled\n+     * @param index index\n+     * @return true/false\n+     */\n     public boolean readHistoryEnabledForField(String index, String field) {\n-        \n-        if(!this.enabled) {\n+        if (!this.isEnabled()) {\n             return false;\n         }\n-        \n-        if(opendistrosecurityIndex.equals(index)) {\n+        // if open distro index (internal index) check if internal config logging is enabled\n+        if (opendistrosecurityIndex.equals(index)) {\n             return logInternalConfig;\n         }\n-        \n         try {\n-            final Set<String> fields = cache.get(index);\n-            if(fields.isEmpty()) {\n+            final Set<String> fields = readEnabledFieldsCache.get(index);\n+            if (fields.isEmpty()) {\n                 return false;\n             }\n-\n             return WildcardMatcher.matchAny(fields, field);\n         } catch (ExecutionException e) {\n             log.error(e);", "originalCommit": "3b3f743f226d46372e95f363db243080b0406694", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "85291e8e7cb67e13808080725cb078b3e28a69ec", "url": "https://github.com/opensearch-project/security/commit/85291e8e7cb67e13808080725cb078b3e28a69ec", "message": "address code review", "committedDate": "2020-04-18T03:09:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwNzUyMQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410607521", "bodyText": "complianceDisabled -> isComplienceConfigEnabled (true -> enabled)", "author": "vrozov", "createdAt": "2020-04-18T04:14:53Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/routing/AuditMessageRouter.java", "diffHunk": "@@ -65,22 +63,18 @@ public AuditMessageRouter(final Settings settings, final Client clientProvider,\n \t\t}\n \t}\n \n-\tpublic void setComplianceConfig(ComplianceConfig complianceConfig) {\n-\t\tthis.complianceConfig = complianceConfig;\n-\t}\n-\n \tpublic boolean isEnabled() {\n \t\treturn this.enabled;\n \t}\n \n-\tpublic final void route(final AuditMessage msg) {\n+\tpublic final void route(final AuditMessage msg, final boolean complianceDisabled) {", "originalCommit": "3b3f743f226d46372e95f363db243080b0406694", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410609283", "bodyText": "keep public final void route(final AuditMessage msg) and use the most common default to call route(msg, ...)", "author": "vrozov", "createdAt": "2020-04-18T04:18:58Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/routing/AuditMessageRouter.java", "diffHunk": "@@ -65,22 +63,18 @@ public AuditMessageRouter(final Settings settings, final Client clientProvider,\n \t\t}\n \t}\n \n-\tpublic void setComplianceConfig(ComplianceConfig complianceConfig) {\n-\t\tthis.complianceConfig = complianceConfig;\n-\t}\n-\n \tpublic boolean isEnabled() {\n \t\treturn this.enabled;\n \t}\n \n-\tpublic final void route(final AuditMessage msg) {", "originalCommit": "85291e8e7cb67e13808080725cb078b3e28a69ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYxNDA4MQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410614081", "bodyText": "What do you mean by most common default ?", "author": "sujithvm", "createdAt": "2020-04-18T04:30:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYxOTAzNA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410619034", "bodyText": "route(msg, true)", "author": "vrozov", "createdAt": "2020-04-18T04:42:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYyMjkzNg==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410622936", "bodyText": "Are you saying to have two functions\n\nroute(msg, true)\nroute(msg) calling the above ?\n\nroute(msg) would probably be useful only for tests (which I have updated already). Dont want to add more code to main just for tests.", "author": "sujithvm", "createdAt": "2020-04-18T04:52:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYzMzM4OQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410633389", "bodyText": "It is OK to provide a default so that test don't need to be changed.", "author": "vrozov", "createdAt": "2020-04-18T05:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYzNjU3Nw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410636577", "bodyText": "The tests are already updated", "author": "sujithvm", "createdAt": "2020-04-18T05:26:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY2MDI3MA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410660270", "bodyText": "Please consider the following approach:\n\nrevert changes to the route() method (it should only take AuditMessage msg as an argument)\nintroduce a boolean instance variable areRoutesEnabled (false by default).\nin route() instead of  isComplianceConfigEnabled use areRoutesEnabled.\nrename setupRoutes() to enableRoutes() and make it public\ndo not call enableRoutes() from AuditMessageRouter constructor, instead, call it from AuditLogImpl if it is enabled and complianceConfig is also enabled", "author": "vrozov", "createdAt": "2020-04-18T07:06:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDczMTU4MQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410731581", "bodyText": "Could you explain the value in doing this and insisting on removing the current change ?\nIMO, I see no issue in route(msg, isComplianceConfigEnabled) as it determines what route to take from the audit log based on current compliance configuration for hot reload.\nAlso would appreciate if you could send the changes in a PR against this branch so that we can quickly move forward :)", "author": "sujithvm", "createdAt": "2020-04-18T18:15:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDczNDA4MA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410734080", "bodyText": "The value of the proposal is that\n\nareRoutesEnabled is the state of AuditMessageRouter instance that is simply a delegate of AuditLogImpl, not a parameter for the route() method (that should only take message to route). Such state will be shared by many calls to the route() until there is a state transition.\nIt is not necessary to initialize routes if routes are not enabled.", "author": "vrozov", "createdAt": "2020-04-18T18:36:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDczNjUyMw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410736523", "bodyText": "Please see https://github.com/sujithvm/security/pull/57", "author": "vrozov", "createdAt": "2020-04-18T18:56:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDczNzEyNw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410737127", "bodyText": "I would prefer AuditMessageRouter improvements to be done separately.\nWould appreciate if you could share your changes :) Dont want to trigger another set of changes around this.", "author": "sujithvm", "createdAt": "2020-04-18T19:00:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDczOTE0Mg==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410739142", "bodyText": "The improvements to AuditMessageRouter are minimal, but it is necessary to keep original route() to take message as the only parameter.", "author": "vrozov", "createdAt": "2020-04-18T19:17:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw=="}], "type": "inlineReview"}, {"oid": "07c85006481dabe045a39c569035c2ba5a7d2245", "url": "https://github.com/opensearch-project/security/commit/07c85006481dabe045a39c569035c2ba5a7d2245", "message": "Use is compliance enabled", "committedDate": "2020-04-18T04:36:50Z", "type": "commit"}, {"oid": "391cb4ad5179046f530d5507a19547bf817c592e", "url": "https://github.com/opensearch-project/security/commit/391cb4ad5179046f530d5507a19547bf817c592e", "message": "Update byte buffer", "committedDate": "2020-04-18T20:04:00Z", "type": "commit"}, {"oid": "f032e0ed642e3559c6782675356e0b6ff3e5953b", "url": "https://github.com/opensearch-project/security/commit/f032e0ed642e3559c6782675356e0b6ff3e5953b", "message": "code review", "committedDate": "2020-04-18T20:06:23Z", "type": "commit"}, {"oid": "36a20c42570969b77de30b3ba268471636b419f6", "url": "https://github.com/opensearch-project/security/commit/36a20c42570969b77de30b3ba268471636b419f6", "message": "fix tests", "committedDate": "2020-04-18T20:23:42Z", "type": "commit"}, {"oid": "6507fa9f0f85db02286be5825c7c21cef618fb15", "url": "https://github.com/opensearch-project/security/commit/6507fa9f0f85db02286be5825c7c21cef618fb15", "message": "fix test", "committedDate": "2020-04-18T20:59:12Z", "type": "commit"}, {"oid": "2116cd01e9c25688419ce16d3b58943b486f1713", "url": "https://github.com/opensearch-project/security/commit/2116cd01e9c25688419ce16d3b58943b486f1713", "message": "fixing test", "committedDate": "2020-04-18T22:54:16Z", "type": "commit"}, {"oid": "3a217b0d8ec560ef98314fb15afabe24338fa684", "url": "https://github.com/opensearch-project/security/commit/3a217b0d8ec560ef98314fb15afabe24338fa684", "message": "fixing test", "committedDate": "2020-04-18T22:58:01Z", "type": "commit"}, {"oid": "07a7b8cfe8dc01684755cf3e228d72b021ea9915", "url": "https://github.com/opensearch-project/security/commit/07a7b8cfe8dc01684755cf3e228d72b021ea9915", "message": "code review (#57)", "committedDate": "2020-04-19T03:06:52Z", "type": "commit"}]}