{"pr_number": 409, "pr_title": "Hot reloading audit configuration", "pr_createdAt": "2020-04-23T22:55:19Z", "pr_url": "https://github.com/opensearch-project/security/pull/409", "timeline": [{"oid": "7b946897590572e73022766daca7b802ffa119e5", "url": "https://github.com/opensearch-project/security/commit/7b946897590572e73022766daca7b802ffa119e5", "message": "Code changes for Audit config hot reload", "committedDate": "2020-05-23T00:57:12Z", "type": "commit"}, {"oid": "590ac469fe5a66fa2c4118debe5c23a7523b3e7a", "url": "https://github.com/opensearch-project/security/commit/590ac469fe5a66fa2c4118debe5c23a7523b3e7a", "message": "Test changes for Audit config hot reload", "committedDate": "2020-05-23T00:57:12Z", "type": "commit"}, {"oid": "8749ca8b16430f731785d2dd0384c37f8d2891e3", "url": "https://github.com/opensearch-project/security/commit/8749ca8b16430f731785d2dd0384c37f8d2891e3", "message": "code review (#173)\n\n* code review", "committedDate": "2020-05-23T00:57:12Z", "type": "commit"}, {"oid": "0ef6b5fa8117a66796dde9bc69417abc6dfb5b69", "url": "https://github.com/opensearch-project/security/commit/0ef6b5fa8117a66796dde9bc69417abc6dfb5b69", "message": "code review", "committedDate": "2020-05-23T00:57:12Z", "type": "commit"}, {"oid": "690720596ae3c23d165dcf508e501d19d55a0bcc", "url": "https://github.com/opensearch-project/security/commit/690720596ae3c23d165dcf508e501d19d55a0bcc", "message": "Remove immutable indices and salt from config", "committedDate": "2020-05-23T00:57:12Z", "type": "commit"}, {"oid": "0d21542a1c7a760389de37717b802c6aed89b340", "url": "https://github.com/opensearch-project/security/commit/0d21542a1c7a760389de37717b802c6aed89b340", "message": "Separate out audit and compliance and use AuditConfig", "committedDate": "2020-05-23T00:57:12Z", "type": "commit"}, {"oid": "723878aa8c62e1b4fe03e1933adac3ccbcc59eb8", "url": "https://github.com/opensearch-project/security/commit/723878aa8c62e1b4fe03e1933adac3ccbcc59eb8", "message": "remove redundant read from settings", "committedDate": "2020-05-23T00:57:12Z", "type": "commit"}, {"oid": "81e73b48bb7c02cc70401cc7b96fa015c709b428", "url": "https://github.com/opensearch-project/security/commit/81e73b48bb7c02cc70401cc7b96fa015c709b428", "message": "Revert back the config loading", "committedDate": "2020-05-23T00:57:12Z", "type": "commit"}, {"oid": "383a2fdce6efc46a8de571b28ba8b1bb4201cfe1", "url": "https://github.com/opensearch-project/security/commit/383a2fdce6efc46a8de571b28ba8b1bb4201cfe1", "message": "Put audit config if absent", "committedDate": "2020-05-23T00:57:12Z", "type": "commit"}, {"oid": "5fa082bb4893c13a4c9b4175829d0c65b2a8cede", "url": "https://github.com/opensearch-project/security/commit/5fa082bb4893c13a4c9b4175829d0c65b2a8cede", "message": "add more tests", "committedDate": "2020-05-23T00:57:12Z", "type": "commit"}, {"oid": "3173edfc105488638ecfc668a5f7ffc7e786e281", "url": "https://github.com/opensearch-project/security/commit/3173edfc105488638ecfc668a5f7ffc7e786e281", "message": "add support for audit log enabled and compliance enabled", "committedDate": "2020-05-23T00:57:12Z", "type": "commit"}, {"oid": "d97f203b261e2e3e2d41012f486fc2a818c0159e", "url": "https://github.com/opensearch-project/security/commit/d97f203b261e2e3e2d41012f486fc2a818c0159e", "message": "Convert read watch fields to mpa", "committedDate": "2020-05-23T00:57:12Z", "type": "commit"}, {"oid": "0030d4a004daa508d50e294801eb5b22c4b9648a", "url": "https://github.com/opensearch-project/security/commit/0030d4a004daa508d50e294801eb5b22c4b9648a", "message": "migration", "committedDate": "2020-05-23T00:57:12Z", "type": "commit"}, {"oid": "23b978a7a04cade1afba557f38d2b6336d2cb779", "url": "https://github.com/opensearch-project/security/commit/23b978a7a04cade1afba557f38d2b6336d2cb779", "message": "Log deprecation warning", "committedDate": "2020-05-23T00:57:12Z", "type": "commit"}, {"oid": "5a81a60cc05d37d92a965e8cb03a5214c10e03c1", "url": "https://github.com/opensearch-project/security/commit/5a81a60cc05d37d92a965e8cb03a5214c10e03c1", "message": "remove unwanted diffs", "committedDate": "2020-05-23T00:57:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwMTAzNQ==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r441901035", "bodyText": "Covered in #491", "author": "sujithvm", "createdAt": "2020-06-18T00:17:48Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/OpenDistroSecurityPlugin.java", "diffHunk": "@@ -514,14 +511,8 @@ public void onIndexModule(IndexModule indexModule) {\n \n                 final ComplianceIndexingOperationListener ciol;\n \n-                assert complianceConfig!=null:\"compliance config must not be null here\";\n-                \n-                if(complianceConfig.writeHistoryEnabledForIndex(indexModule.getIndex().getName())) {\n-                    ciol = ReflectionHelper.instantiateComplianceListener(Objects.requireNonNull(auditLog));\n-                    indexModule.addIndexOperationListener(ciol);\n-                } else {\n-                    ciol = new ComplianceIndexingOperationListener();\n-                }", "originalCommit": "5a81a60cc05d37d92a965e8cb03a5214c10e03c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwMTE0Mg==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r441901142", "bodyText": "Register on the event bus to listen on any audit config changes", "author": "sujithvm", "createdAt": "2020-06-18T00:18:11Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/OpenDistroSecurityPlugin.java", "diffHunk": "@@ -787,6 +777,10 @@ public AsyncSender interceptSender(AsyncSender sender) {\n         dcf.registerDCFListener(irr);\n         dcf.registerDCFListener(xffResolver);\n         dcf.registerDCFListener(evaluator);\n+        if (!(auditLog instanceof NullAuditLog)) {\n+            // Don't register if advanced modules is disabled in which case auditlog is instance of NullAuditLog\n+            dcf.registerDCFListener(auditLog);\n+        }", "originalCommit": "5a81a60cc05d37d92a965e8cb03a5214c10e03c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwMTgzNA==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r441901834", "bodyText": "Removed external config loading because when node starts, compliance config is not available YET (because it needs to fetch from index). Check in AuditLogImpl\nprotected void onComplianceConfigChanged(ComplianceConfig complianceConfig) {\n        this.complianceConfig = complianceConfig;\n        enableRoutes();\n        this.complianceConfig.log(log);\n        logExternalConfig();\n    }", "author": "sujithvm", "createdAt": "2020-06-18T00:21:11Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/OpenDistroSecurityPlugin.java", "diffHunk": "@@ -1014,13 +1008,6 @@ public void onNodeStarted() {\n         }\n         final Set<ModuleInfo> securityModules = ReflectionHelper.getModulesLoaded();\n         log.info(\"{} Open Distro Security modules loaded so far: {}\", securityModules.size(), securityModules);\n-        if (auditLog != null) {\n-            final ComplianceConfig complianceConfig = auditLog.getComplianceConfig();\n-            if(complianceConfig != null && complianceConfig.isEnabled() && complianceConfig.shouldLogExternalConfig() && !externalConfigLogged.getAndSet(true)) {\n-                log.info(\"logging external config\");\n-                auditLog.logExternalConfig(settings, environment);", "originalCommit": "5a81a60cc05d37d92a965e8cb03a5214c10e03c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwODE0OA==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r441908148", "bodyText": "Hot-reloading for audit logging configuration in tests", "author": "sujithvm", "createdAt": "2020-06-18T00:47:06Z", "path": "src/test/java/com/amazon/opendistroforelasticsearch/security/auditlog/AbstractAuditlogiUnitTest.java", "diffHunk": "@@ -40,9 +41,19 @@ protected String getResourceFolder() {\n     }\n \n     protected final void setup(Settings additionalSettings) throws Exception {\n-        final Settings nodeSettings = defaultNodeSettings(additionalSettings);\n+        final Settings.Builder auditSettingsBuilder = Settings.builder();\n+        final Settings.Builder additionalSettingsBuilder = Settings.builder().put(additionalSettings);\n+        AuditConfig.DEPRECATED_KEYS.forEach(key -> {\n+            if (additionalSettingsBuilder.get(key) != null) {\n+                auditSettingsBuilder.put(key, additionalSettings.get(key));\n+                additionalSettingsBuilder.remove(key);\n+            }\n+        });\n+\n+        final Settings nodeSettings = defaultNodeSettings(additionalSettingsBuilder.build());\n         setup(Settings.EMPTY, new DynamicSecurityConfig(), nodeSettings, init);\n         rh = restHelper();\n+        updateAuditConfig(auditSettingsBuilder.build());", "originalCommit": "5a81a60cc05d37d92a965e8cb03a5214c10e03c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8fff72d074682f64d30ed3b30f5368c12b86e90d", "url": "https://github.com/opensearch-project/security/commit/8fff72d074682f64d30ed3b30f5368c12b86e90d", "message": "Merge remote-tracking branch 'upstream/master' into auditlog", "committedDate": "2020-06-25T09:26:58Z", "type": "commit"}, {"oid": "4f73103e842c3fc94bc00dfb07a7042f78ade09f", "url": "https://github.com/opensearch-project/security/commit/4f73103e842c3fc94bc00dfb07a7042f78ade09f", "message": "Fixes", "committedDate": "2020-06-25T17:07:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyMTE4Mg==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r445921182", "bodyText": "Add new line", "author": "vrozov", "createdAt": "2020-06-26T01:24:28Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/routing/AuditMessageRouter.java", "diffHunk": "@@ -41,138 +45,148 @@\n \n public class AuditMessageRouter {\n \n-\tprotected final Logger log = LogManager.getLogger(this.getClass());\n-\tfinal AuditLogSink defaultSink;\n-\tfinal Map<AuditCategory, List<AuditLogSink>> categorySinks = new EnumMap<>(AuditCategory.class);\n-\tfinal SinkProvider sinkProvider;\n-\tfinal AsyncStoragePool storagePool;\n-\tprivate boolean hasMultipleEndpoints;\n-\tprivate boolean areRoutesEnabled;\n-\n-\tpublic AuditMessageRouter(final Settings settings, final Client clientProvider, ThreadPool threadPool, final Path configPath) {\n-\t\tthis.sinkProvider = new SinkProvider(settings, clientProvider, threadPool, configPath);\n-\t\tthis.storagePool = new AsyncStoragePool(ThreadPoolConfig.getConfig(settings));\n-\n-\t\t// get the default sink\n-\t\tthis.defaultSink = sinkProvider.getDefaultSink();\n-\t\tif (defaultSink == null) {\n-\t\t\tlog.warn(\"No default storage available, audit log may not work properly. Please check configuration.\");\n-\t\t}\n-\t}\n-\n-\tpublic boolean isEnabled() {\n-\t\treturn defaultSink != null;\n-\t}\n-\n-\tpublic final void route(final AuditMessage msg) {\n-\t\tif (!isEnabled()) {\n-\t\t\t// should not happen since we check in AuditLogImpl, so this is just a safeguard\n-\t\t\tlog.error(\"#route(AuditMessage) called but message router is disabled\");\n-\t\t\treturn;\n-\t\t}\n-\t\t// if we do not run the compliance features or no extended configuration is present, only log to default.\n-\t\tif (!areRoutesEnabled || !hasMultipleEndpoints) {\n-\t\t\tstore(defaultSink, msg);\n-\t\t} else {\n-\t\t\tfor (AuditLogSink sink : categorySinks.get(msg.getCategory())) {\n-\t\t\t\tstore(sink, msg);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic final void close() {\n-\t\t// shutdown storage pool\n-\t\tstoragePool.close();\n-\t\t// close default\n-\t\tsinkProvider.close();\n-\t}\n-\n-\tprotected final void close(List<AuditLogSink> sinks) {\n-\t\tfor (AuditLogSink sink : sinks) {\n-\t\t\ttry {\n-\t\t\t\tlog.info(\"Closing {}\", sink.getClass().getSimpleName());\n-\t\t\t\tsink.close();\n-\t\t\t} catch (Exception ex) {\n-\t\t\t\tlog.info(\"Could not close delegate '{}' due to '{}'\", sink.getClass().getSimpleName(), ex.getMessage());\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic final boolean enableRoutes(Settings settings) {\n-\t\tcheckState(isEnabled(), \"AuditMessageRouter is disabled\");\n-\t\tareRoutesEnabled = true;\n-\t\tMap<String, Object> routesConfiguration = Utils.convertJsonToxToStructuredMap(settings.getAsSettings(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_ROUTES));\n-\t\tif (!routesConfiguration.isEmpty()) {\n-\t\t\thasMultipleEndpoints = true;\n-\t\t\t// first set up all configured routes. We do it this way so category names are case insensitive\n-\t\t\t// and we can warn if a non-existing category has been detected.\n-\t\t\tfor (Entry<String, Object> routesEntry : routesConfiguration.entrySet()) {\n-\t\t\t\tlog.trace(\"Setting up routes for endpoint {}, configuraton is {}\", routesEntry.getKey(), routesEntry.getValue());\n-\t\t\t\tString categoryName = routesEntry.getKey();\n-\t\t\t\ttry {\n-\t\t\t\t\tAuditCategory category = AuditCategory.valueOf(categoryName.toUpperCase());\n-\t\t\t\t\t// warn for duplicate definitions\n-\t\t\t\t\tif (categorySinks.get(category) != null) {\n-\t\t\t\t\t\tlog.warn(\"Duplicate routing configuration detected for category {}, skipping.\", category);\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t\tList<AuditLogSink> sinksForCategory = createSinksForCategory(category, settings.getAsSettings(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_ROUTES + \".\" + categoryName));\n-\t\t\t\t\tif (!sinksForCategory.isEmpty()) {\n-\t\t\t\t\t\tcategorySinks.put(category, sinksForCategory);\n-\t\t\t\t\t\tif(log.isTraceEnabled()) {\n-\t\t\t\t\t\t\tlog.debug(\"Created {} endpoints for category {}\", sinksForCategory.size(), category );\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tlog.debug(\"No valid endpoints found for category {} adding only default.\", category );\n-\n-\t\t\t\t\t}\n-\t\t\t\t} catch (Exception e ) {\n-\t\t\t\t\tlog.error(\"Invalid category '{}' found in routing configuration. Must be one of: {}\", categoryName, AuditCategory.values());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t// for all non-configured categories we automatically set up the default endpoint\n-\t\t\tfor(AuditCategory category : AuditCategory.values()) {\n-\t\t\t\tif (!categorySinks.containsKey(category)) {\n-\t\t\t\t\tif (log.isDebugEnabled()) {\n-\t\t\t\t\t\tlog.debug(\"No endpoint configured for category {}, adding default endpoint\", category);\n-\t\t\t\t\t}\n-\t\t\t\t\tcategorySinks.put(category, Collections.singletonList(defaultSink));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn hasMultipleEndpoints;\n-\t}\n-\n-\tprivate final List<AuditLogSink> createSinksForCategory(AuditCategory category, Settings configuration) {\n-\t\tList<AuditLogSink> sinksForCategory = new LinkedList<>();\n-\t\tList<String> sinks = configuration.getAsList(\"endpoints\");\n-\t\tif (sinks == null || sinks.isEmpty()) {\n-\t\t\tlog.error(\"No endpoints configured for category {}\", category);\n-\t\t\treturn sinksForCategory;\n-\t\t}\n-\t\tfor (String sinkName : sinks) {\n-\t\t\tAuditLogSink sink = sinkProvider.getSink(sinkName);\n-\t\t\tif (sink != null && !sinksForCategory.contains(sink)) {\n-\t\t\t\tsinksForCategory.add(sink);\n-\t\t\t} else {\n-\t\t\t\tlog.error(\"Configured endpoint '{}' not available\", sinkName);\n-\t\t\t}\n-\t\t}\n-\t\treturn sinksForCategory;\n-\t}\n-\n-\tprivate final void store(AuditLogSink sink, AuditMessage msg) {\n-\t\tif (sink.isHandlingBackpressure()) {\n-\t\t\tsink.store(msg);\n-\t\t\tif (log.isTraceEnabled()) {\n-\t\t\t\tlog.trace(\"stored on sink {} synchronously\", sink.getClass().getSimpleName());\n-\t\t\t}\n-\t\t} else {\n-\t\t\tstoragePool.submit(msg, sink);\n-\t\t\tif (log.isTraceEnabled()) {\n-\t\t\t\tlog.trace(\"will store on sink {} asynchronously\", sink.getClass().getSimpleName());\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-}\n+    protected final Logger log = LogManager.getLogger(this.getClass());\n+    final AuditLogSink defaultSink;\n+    volatile Map<AuditCategory, List<AuditLogSink>> categorySinks;\n+    final SinkProvider sinkProvider;\n+    final AsyncStoragePool storagePool;\n+\n+    public AuditMessageRouter(final Settings settings, final Client clientProvider, ThreadPool threadPool, final Path configPath) {\n+        this(\n+            new SinkProvider(settings, clientProvider, threadPool, configPath),\n+            new AsyncStoragePool(ThreadPoolConfig.getConfig(settings))\n+        );\n+    }\n+\n+    @VisibleForTesting\n+    public AuditMessageRouter(SinkProvider sinkProvider, AsyncStoragePool storagePool) {\n+        this.sinkProvider = sinkProvider;\n+        this.storagePool = storagePool;\n+\n+        // get the default sink\n+        this.defaultSink = sinkProvider.getDefaultSink();\n+        if (defaultSink == null) {\n+            log.warn(\"No default storage available, audit log may not work properly. Please check configuration.\");\n+        }\n+    }\n+\n+    public boolean isEnabled() {\n+        return defaultSink != null;\n+    }\n+\n+    public final void route(final AuditMessage msg) {\n+        if (!isEnabled()) {\n+            // should not happen since we check in AuditLogImpl, so this is just a safeguard\n+            log.error(\"#route(AuditMessage) called but message router is disabled\");\n+            return;\n+        }\n+        checkState(categorySinks != null, \"categorySinks is null, prior to route() call enableRoutes().\");\n+        // if we do not run the compliance features or no extended configuration is present, only log to default.\n+        List<AuditLogSink> auditLogSinks = categorySinks.get(msg.getCategory());\n+        if (auditLogSinks == null) {\n+            store(defaultSink, msg);\n+        } else {\n+            auditLogSinks.stream().forEach(sink -> store(sink, msg));\n+        }\n+    }\n+\n+    public final void close() {\n+        // shutdown storage pool\n+        storagePool.close();\n+        // close default\n+        sinkProvider.close();\n+    }\n+\n+    protected final void close(List<AuditLogSink> sinks) {\n+        for (AuditLogSink sink : sinks) {\n+            try {\n+                log.info(\"Closing {}\", sink.getClass().getSimpleName());\n+                sink.close();\n+            } catch (Exception ex) {\n+                log.info(\"Could not close delegate '{}' due to '{}'\", sink.getClass().getSimpleName(), ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    public final void enableRoutes(Settings settings) {\n+        checkState(isEnabled(), \"AuditMessageRouter is disabled\");\n+        if (categorySinks != null) {\n+            return;\n+        }\n+        Map<String, Object> routesConfiguration = Utils.convertJsonToxToStructuredMap(settings.getAsSettings(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_ROUTES));\n+        EnumSet<AuditCategory> presentAuditCategory = EnumSet.noneOf(AuditCategory.class);\n+        categorySinks = routesConfiguration.entrySet().stream()\n+            .peek(entry -> log.trace(\"Setting up routes for endpoint {}, configuration is {}\", entry.getKey(), entry.getValue()))\n+            .map(entry -> {\n+                String categoryName = entry.getKey();\n+                try {\n+                    // first set up all configured routes. We do it this way so category names are case insensitive\n+                    // and we can warn if a non-existing category has been detected.\n+                    AuditCategory auditCategory = AuditCategory.valueOf(categoryName.toUpperCase());\n+                    return Maps.immutableEntry(auditCategory, createSinksForCategory(auditCategory, (Map<String, List<String>>)entry.getValue()));\n+                } catch (IllegalArgumentException e) {\n+                    log.error(\"Invalid category '{}' found in routing configuration. Must be one of: {}\", categoryName, AuditCategory.values());\n+                    return null;\n+                }\n+            })\n+            .filter(entry -> {\n+                if (entry != null) {\n+                    AuditCategory category = entry.getKey();\n+                    List<AuditLogSink> auditLogSinks = entry.getValue();\n+                    if (auditLogSinks.isEmpty()) {\n+                        log.debug(\"No valid endpoints found for category {}.\", category);\n+                        return false;\n+                    }\n+                    if (presentAuditCategory.add(category)) {\n+                        log.debug(\"Created {} endpoints for category {}\", auditLogSinks.size(), category);\n+                        return true;\n+                    }\n+                    log.warn(\"Duplicate routing configuration {} detected for category {}, skipping.\", auditLogSinks, category);\n+                }\n+                return false;\n+            })\n+            .collect(\n+                Maps.toImmutableEnumMap(\n+                    Map.Entry::getKey,\n+                    Map.Entry::getValue\n+                )\n+            );\n+\n+        // for all non-configured categories we automatically set up the default endpoint\n+        log.warn(\"No endpoint configured for categories {}, using default endpoint\", EnumSet.complementOf(presentAuditCategory));\n+    }\n+\n+    private final List<AuditLogSink> createSinksForCategory(AuditCategory category, Map<String, List<String>> configuration) {\n+        List<AuditLogSink> sinksForCategory = new LinkedList<>();\n+        List<String> sinks = configuration.get(\"endpoints\");\n+        if (sinks != null && !sinks.isEmpty()) {\n+            for (String sinkName : sinks) {\n+                AuditLogSink sink = sinkProvider.getSink(sinkName);\n+                if (sink != null && !sinksForCategory.contains(sink)) {\n+                    sinksForCategory.add(sink);\n+                } else {\n+                    log.error(\"Configured endpoint '{}' not available\", sinkName);\n+                }\n+            }\n+        }\n+        if (sinksForCategory.isEmpty()) {\n+            log.error(\"No endpoints configured for category {}\", category);\n+        }\n+        return sinksForCategory;\n+    }\n+\n+    private final void store(AuditLogSink sink, AuditMessage msg) {\n+        if (sink.isHandlingBackpressure()) {\n+            sink.store(msg);\n+            if (log.isTraceEnabled()) {\n+                log.trace(\"stored on sink {} synchronously\", sink.getClass().getSimpleName());\n+            }\n+        } else {\n+            storagePool.submit(msg, sink);\n+            if (log.isTraceEnabled()) {\n+                log.trace(\"will store on sink {} asynchronously\", sink.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+}", "originalCommit": "4f73103e842c3fc94bc00dfb07a7042f78ade09f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk0NDM4OQ==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r445944389", "bodyText": "undo the change", "author": "vrozov", "createdAt": "2020-06-26T03:06:04Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -388,4 +381,4 @@ public boolean readHistoryEnabledForField(String index, String field) {\n         }\n         return matcher.test(field);\n     }\n-}\n+}", "originalCommit": "4f73103e842c3fc94bc00dfb07a7042f78ade09f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "497b5c6678b47aad8f633ebc1e07b215c9dc1626", "url": "https://github.com/opensearch-project/security/commit/497b5c6678b47aad8f633ebc1e07b215c9dc1626", "message": "Code review", "committedDate": "2020-06-29T16:34:37Z", "type": "commit"}, {"oid": "0428f4e7cccd5a45593d185f723a226d0e575683", "url": "https://github.com/opensearch-project/security/commit/0428f4e7cccd5a45593d185f723a226d0e575683", "message": "Merge remote-tracking branch 'upstream/master' into auditlog", "committedDate": "2020-06-29T21:39:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMwNDE5OA==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447304198", "bodyText": "Is this change necessary?", "author": "vrozov", "createdAt": "2020-06-29T22:52:49Z", "path": "src/test/java/com/amazon/opendistroforelasticsearch/security/auditlog/impl/TracingTests.java", "diffHunk": "@@ -49,15 +50,21 @@ public void testHTTPTrace() throws Exception {\n \n         final Settings settings = Settings.builder()\n                 .put(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, \"debug\")\n-                .put(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS, \"*\")\n-                .put(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, \"*\")\n-                .put(\"opendistro_security.audit.resolve_bulk_requests\", true)\n                 .put(\"opendistro_security.audit.config.log4j.logger_name\", \"opendistro_security_action_trace\")\n                 .put(\"opendistro_security.audit.config.log4j.level\", \"TRACE\")\n                 .build();\n \n         setup(Settings.EMPTY, new DynamicSecurityConfig(), settings, true, ClusterConfiguration.DEFAULT);\n \n+        Settings auditSettings = Settings.builder()", "originalCommit": "0428f4e7cccd5a45593d185f723a226d0e575683", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxOTMzNQ==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447319335", "bodyText": "nit: static", "author": "vrozov", "createdAt": "2020-06-29T23:38:15Z", "path": "src/test/java/com/amazon/opendistroforelasticsearch/security/test/DynamicSecurityConfig.java", "diffHunk": "@@ -50,6 +50,7 @@\n     private String securityInternalUsers = \"internal_users.yml\";\n     private String securityActionGroups = \"action_groups.yml\";\n     private String securityNodesDn = \"nodes_dn.yml\";\n+    private String securityAudit = \"audit.yml\";", "originalCommit": "0428f4e7cccd5a45593d185f723a226d0e575683", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMzOTIxMA==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447339210", "bodyText": "Class usage is nit static and this member is modified by setSecurityAudit() function defined below", "author": "sujithvm", "createdAt": "2020-06-30T00:38:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxOTMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyNzYxMg==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447327612", "bodyText": "Why is it OK to use this file?", "author": "vrozov", "createdAt": "2020-06-30T00:03:14Z", "path": "src/test/java/com/amazon/opendistroforelasticsearch/security/auditlog/AbstractAuditlogiUnitTest.java", "diffHunk": "@@ -105,9 +116,22 @@ protected boolean validateJson(final String json) {\n \n     protected AuditMessageRouter createMessageRouterComplianceEnabled(Settings settings) {\n         AuditMessageRouter router = new AuditMessageRouter(settings, null, null, null);\n-        if (router.isEnabled()) {\n-            router.enableRoutes(settings);\n-        }\n+        router.enableRoutes(settings);\n         return router;\n     }\n+\n+    protected void updateAuditConfig(final Settings settings) throws Exception {\n+        updateAuditConfig(AuditTestUtils.createAuditPayload(settings));\n+    }\n+\n+    protected void updateAuditConfig(final String payload) throws Exception {\n+        final boolean sendAdminCertificate = rh.sendAdminCertificate;\n+        final String keystore = rh.keystore;\n+        rh.sendAdminCertificate = true;\n+        rh.keystore = \"auditlog/kirk-keystore.jks\";", "originalCommit": "0428f4e7cccd5a45593d185f723a226d0e575683", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMzNzc0MA==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447337740", "bodyText": "This is an admin cert used only in the tests to update the configuration.", "author": "sujithvm", "createdAt": "2020-06-30T00:33:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyNzYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM1OTkyNg==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447359926", "bodyText": "It comes from \"auditlog\", what if another cert is used in a different unit test? If it is always the same, why it comes from \"auditlog\"?", "author": "vrozov", "createdAt": "2020-06-30T01:49:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyNzYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk5NDUyOQ==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447994529", "bodyText": "Current usage of tests & associated test resources seem to be done this way. Tests in auditlog package are referencing the test resources (certs & config) present in the associated resources/auditlog directory.", "author": "sujithvm", "createdAt": "2020-06-30T21:38:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyNzYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA2NDE5NA==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r448064194", "bodyText": "OK, but similar issue applies to AuditTestUtils.updateAuditConfig() that is used by AbstractRestApiUnitTest.", "author": "vrozov", "createdAt": "2020-07-01T01:20:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyNzYxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMzNDAxNQ==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447334015", "bodyText": "nit: add new line", "author": "vrozov", "createdAt": "2020-06-30T00:22:37Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/config/AuditConfig.java", "diffHunk": "@@ -214,31 +397,368 @@ public void log(Logger logger) {\n             logger.info(\"Bulk requests resolution is {} during request auditing.\", resolveBulkRequests ? \"enabled\" : \"disabled\");\n             logger.info(\"Index resolution is {} during request auditing.\", resolveIndices ? \"enabled\" : \"disabled\");\n             logger.info(\"Sensitive headers auditing is {}.\", excludeSensitiveHeaders ? \"enabled\" : \"disabled\");\n-            logger.info(\"Auditing requests from {} users is disabled.\", ignoredAuditUsersMatcher);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"Filter{\" +\n-                    \"isRestApiAuditEnabled=\" + isRestApiAuditEnabled +\n-                    \", disabledRestCategories=\" + disabledRestCategories +\n-                    \", isTransportApiAuditEnabled=\" + isTransportApiAuditEnabled +\n-                    \", disabledTransportCategories=\" + disabledTransportCategories +\n-                    \", resolveBulkRequests=\" + resolveBulkRequests +\n-                    \", logRequestBody=\" + logRequestBody +\n-                    \", resolveIndices=\" + resolveIndices +\n-                    \", excludeSensitiveHeaders=\" + excludeSensitiveHeaders +\n-                    \", ignoredAuditUsers=\" + ignoredAuditUsersMatcher +\n-                    \", ignoreAuditRequests=\" + ignoredAuditRequestsMatcher +\n-                    '}';\n+            logger.info(\"Auditing requests from {} users is disabled.\", ignoredAuditUsers);\n+        }\n+    }\n+\n+    public static class Compliance {\n+        @JsonProperty(value = Key.ENABLED)\n+        private boolean complianceEnabled = true;\n+        @JsonProperty(value = Key.INTERNAL_CONFIG_ENABLED)\n+        private boolean internalConfigEnabled = true;\n+        @JsonProperty(value = Key.EXTERNAL_CONFIG_ENABLED)\n+        private boolean externalConfigEnabled = false;\n+        @JsonProperty(value = Key.READ_METADATA_ONLY)\n+        private boolean readMetadataOnly = true;\n+        @JsonProperty(value = Key.READ_WATCHED_FIELDS)\n+        private Map<String, Set<String>> readWatchedFields = Collections.emptyMap();\n+        @JsonProperty(value = Key.READ_IGNORE_USERS)\n+        private Set<String> readIgnoreUsers = Collections.emptySet();\n+        @JsonProperty(value = Key.WRITE_METADATA_ONLY)\n+        private boolean writeMetadataOnly = true;\n+        @JsonProperty(value = Key.WRITE_LOG_DIFFS)\n+        private boolean writeLogDiffs = false;\n+        @JsonProperty(value = Key.WRITE_WATCHED_INDICES)\n+        private List<String> writeWatchedIndices = Collections.emptyList();\n+        @JsonProperty(value = Key.WRITE_IGNORE_USERS)\n+        private Set<String> writeIgnoreUsers = Collections.emptySet();\n+\n+        /**\n+         * Checks if compliance auditing is enabled\n+         * @return true/false\n+         */\n+        @JsonIgnore\n+        public boolean isComplianceEnabled() {\n+            return complianceEnabled;\n+        }\n+\n+        /**\n+         * Set whether to audit compliance events\n+         * @param complianceEnabled true/false\n+         */\n+        @JsonIgnore\n+        public void setComplianceEnabled(boolean complianceEnabled) {\n+            this.complianceEnabled = complianceEnabled;\n+        }\n+\n+        /**\n+         * Check if auditing of internal opendistro security index is enabled\n+         * @return true/false\n+         */\n+        @JsonIgnore\n+        public boolean isInternalConfigEnabled() {\n+            return internalConfigEnabled;\n+        }\n+\n+        /**\n+         * Set whether to audit internal opendistro security index\n+         * @param internalConfigEnabled true/false\n+         */\n+        @JsonIgnore\n+        public void setInternalConfigEnabled(boolean internalConfigEnabled) {\n+            this.internalConfigEnabled = internalConfigEnabled;\n+        }\n+\n+        /**\n+         * Checks if auditing of external configuration files is enabled\n+         * @return true/false\n+         */\n+        @JsonIgnore\n+        public boolean isExternalConfigEnabled() {\n+            return externalConfigEnabled;\n+        }\n+\n+        /**\n+         * Set whether to audit external configuration files\n+         * @param externalConfigEnabled true/false\n+         */\n+        @JsonIgnore\n+        public void setExternalConfigEnabled(boolean externalConfigEnabled) {\n+            this.externalConfigEnabled = externalConfigEnabled;\n+        }\n+\n+        /**\n+         * Checks if only metadata or field names are to be logged for doc read requests\n+         * @return true/false\n+         */\n+        @JsonIgnore\n+        public boolean isReadMetadataOnly() {\n+            return readMetadataOnly;\n+        }\n+\n+        /**\n+         * Set if only metadata or field names are to be logged for doc read requests\n+         * @param readMetadataOnly true/false\n+         */\n+        @JsonIgnore\n+        public void setReadMetadataOnly(boolean readMetadataOnly) {\n+            this.readMetadataOnly = readMetadataOnly;\n+        }\n+\n+        /**\n+         * Get list of fields to watch for, in a document in an index\n+         * @return index name mapped to a set of fields\n+         */\n+        @JsonIgnore\n+        public Map<String, Set<String>> getReadWatchedFields() {\n+            return readWatchedFields;\n+        }\n+\n+        /**\n+         * Set list of fields to watch for, in a document in an index\n+         * @param readWatchedFields index name mapped to a set of fields\n+         */\n+        @JsonSetter(value = Key.READ_WATCHED_FIELDS, nulls = Nulls.AS_EMPTY)\n+        public void setReadWatchedFields(Map<String, Set<String>> readWatchedFields) {\n+            if (readWatchedFields != null) {\n+                this.readWatchedFields = readWatchedFields;\n+            } else {\n+                this.readWatchedFields = Collections.emptyMap();\n+            }\n+        }\n+\n+        /**\n+         * Get users ignored for auditing doc read requests\n+         * @return set of ignored users\n+         */\n+        @JsonIgnore\n+        public Set<String> getReadIgnoreUsers() {\n+            return readIgnoreUsers;\n+        }\n+\n+        /**\n+         * Set users to be ignored for auditing doc read requests\n+         * @param readIgnoreUsers users\n+         */\n+        @JsonSetter(value = Key.READ_IGNORE_USERS, nulls = Nulls.AS_EMPTY)\n+        public void setReadIgnoreUsers(Set<String> readIgnoreUsers) {\n+            if (readIgnoreUsers != null) {\n+                this.readIgnoreUsers = readIgnoreUsers;\n+            } else {\n+                this.readIgnoreUsers = Collections.emptySet();\n+            }\n         }\n+\n+        /**\n+         * Checks if only metadata or field names are to be logged for doc write requests\n+         * @return true/false\n+         */\n+        @JsonIgnore\n+        public boolean isWriteMetadataOnly() {\n+            return writeMetadataOnly;\n+        }\n+\n+        /**\n+         * Set whether to log only metadata for doc write requests\n+         * @param writeMetadataOnly true/false\n+         */\n+        @JsonIgnore\n+        public void setWriteMetadataOnly(boolean writeMetadataOnly) {\n+            this.writeMetadataOnly = writeMetadataOnly;\n+        }\n+\n+        /**\n+         * Checks if only diffs are to be logged for doc write requests\n+         * @return true/false\n+         */\n+        @JsonIgnore\n+        public boolean isWriteLogDiffs() {\n+            return writeLogDiffs;\n+        }\n+\n+        /**\n+         * Set whether to log only diffs for doc write requests\n+         * @param writeLogDiffs true/false\n+         */\n+        @JsonIgnore\n+        public void setWriteLogDiffs(boolean writeLogDiffs) {\n+            this.writeLogDiffs = writeLogDiffs;\n+        }\n+\n+        /**\n+         * Get list of indices to watch for doc write requests\n+         * @return indices\n+         */\n+        @JsonIgnore\n+        public List<String> getWriteWatchedIndices() {\n+            return writeWatchedIndices;\n+        }\n+\n+        /**\n+         * Set indices to watch for doc write requests\n+         * @param writeWatchedIndices indices\n+         */\n+        @JsonSetter(value = Key.WRITE_WATCHED_INDICES, nulls = Nulls.AS_EMPTY)\n+        public void setWriteWatchedIndices(List<String> writeWatchedIndices) {\n+            if (writeWatchedIndices != null) {\n+                this.writeWatchedIndices = writeWatchedIndices;\n+            } else {\n+                this.writeWatchedIndices = Collections.emptyList();\n+            }\n+        }\n+\n+        /**\n+         * Get users ignored for auditing doc write requests\n+         * @return set of ignored users\n+         */\n+        @JsonIgnore\n+        public Set<String> getWriteIgnoreUsers() {\n+            return writeIgnoreUsers;\n+        }\n+\n+        /**\n+         * Set users to be ignored for auditing doc write requests\n+         * @param writeIgnoreUsers users\n+         */\n+        @JsonSetter(value = Key.WRITE_IGNORE_USERS, nulls = Nulls.AS_EMPTY)\n+        public void setWriteIgnoreUsers(Set<String> writeIgnoreUsers) {\n+            if (writeIgnoreUsers != null) {\n+                this.writeIgnoreUsers = writeIgnoreUsers;\n+            } else {\n+                this.readIgnoreUsers = Collections.emptySet();\n+            }\n+        }\n+    }\n+\n+    public static class Key {\n+        public static final String ENABLED = \"enabled\";\n+        public static final String AUDIT = \"audit\";\n+        public static final String COMPLIANCE = \"compliance\";\n+        public static final String ENABLE_REST = \"enable_rest\";\n+        public static final String DISABLED_REST_CATEGORIES = \"disabled_rest_categories\";\n+        public static final String ENABLE_TRANSPORT = \"enable_transport\";\n+        public static final String DISABLED_TRANSPORT_CATEGORIES = \"disabled_transport_categories\";\n+        public static final String INTERNAL_CONFIG_ENABLED = \"internal_config\";\n+        public static final String EXTERNAL_CONFIG_ENABLED = \"external_config\";\n+        public static final String RESOLVE_BULK_REQUESTS = \"resolve_bulk_requests\";\n+        public static final String LOG_REQUEST_BODY = \"log_request_body\";\n+        public static final String RESOLVE_INDICES = \"resolve_indices\";\n+        public static final String EXCLUDE_SENSITIVE_HEADERS = \"exclude_sensitive_headers\";\n+        public static final String IGNORE_USERS = \"ignore_users\";\n+        public static final String IGNORE_REQUESTS = \"ignore_requests\";\n+        public static final String READ_METADATA_ONLY = \"read_metadata_only\";\n+        public static final String READ_WATCHED_FIELDS = \"read_watched_fields\";\n+        public static final String READ_IGNORE_USERS = \"read_ignore_users\";\n+        public static final String WRITE_METADATA_ONLY = \"write_metadata_only\";\n+        public static final String WRITE_LOG_DIFFS = \"write_log_diffs\";\n+        public static final String WRITE_WATCHED_INDICES = \"write_watched_indices\";\n+        public static final String WRITE_IGNORE_USERS = \"write_ignore_users\";\n+    }\n+\n+    private static final List<String> DEFAULT_IGNORED_USERS_LIST = ImmutableList.copyOf(DEFAULT_IGNORED_USERS);\n+    private static final List<String> DEFAULT_DISABLED_CATEGORIES_LIST = DEFAULT_DISABLED_CATEGORIES.stream().map(Enum::name).collect(Collectors.toList());\n+\n+    /**\n+     * Generate audit logging configuration from settings defined in elasticsearch.yml\n+     * @param settings settings\n+     * @return audit configuration filter\n+     */\n+    public static AuditConfig from(Settings settings) {\n+        final AuditConfig auditConfig = new AuditConfig();\n+        final Filter audit = new Filter();\n+        final Compliance compliance = new Compliance();\n+        audit.setRestApiAuditEnabled(settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ENABLE_REST, true));\n+        audit.setTransportApiAuditEnabled(settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ENABLE_TRANSPORT, true));\n+        audit.setResolveBulkRequests(settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_RESOLVE_BULK_REQUESTS, false));\n+        audit.setLogRequestBody(settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_LOG_REQUEST_BODY, true));\n+        audit.setResolveIndices(settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_RESOLVE_INDICES, true));\n+        audit.setExcludeSensitiveHeaders(settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_EXCLUDE_SENSITIVE_HEADERS, true));\n+\n+        audit.setDisabledRestCategories(AuditCategory.parse(getSettingAsSet(\n+                settings,\n+                ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DISABLED_REST_CATEGORIES,\n+                DEFAULT_DISABLED_CATEGORIES_LIST,\n+                true)));\n+\n+        audit.setDisabledTransportCategories(AuditCategory.parse(getSettingAsSet(\n+                settings,\n+                ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DISABLED_TRANSPORT_CATEGORIES,\n+                DEFAULT_DISABLED_CATEGORIES_LIST,\n+                true)));\n+\n+        audit.setIgnoreUsers(getSettingAsSet(\n+                settings,\n+                ConfigConstants.OPENDISTRO_SECURITY_AUDIT_IGNORE_USERS,\n+                DEFAULT_IGNORED_USERS_LIST,\n+                false));\n+\n+        audit.setIgnoreRequests(ImmutableSet.copyOf(settings.getAsList(\n+                ConfigConstants.OPENDISTRO_SECURITY_AUDIT_IGNORE_REQUESTS,\n+                Collections.emptyList())));\n+\n+        compliance.setExternalConfigEnabled(settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false));\n+        compliance.setInternalConfigEnabled(settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false));\n+        compliance.setReadMetadataOnly(settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false));\n+        compliance.setWriteMetadataOnly(settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false));\n+        compliance.setWriteLogDiffs(settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false));\n+\n+        final List<String> setReadWatchedFieldsList = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n+                Collections.emptyList(), false);\n+        //opendistro_security.compliance.pii_fields:\n+        //  - indexpattern,fieldpattern,fieldpattern,....\n+        Map<String, Set<String>> readEnabledFields = setReadWatchedFieldsList.stream()\n+                .map(watchedReadField -> watchedReadField.split(\",\"))\n+                .filter(split -> split.length != 0 && !Strings.isNullOrEmpty(split[0]))\n+                .collect(Collectors.toMap(\n+                        split -> split[0],\n+                        split -> split.length == 1 ?\n+                                Collections.singleton(\"*\") : Arrays.stream(split).skip(1).collect(Collectors.toSet())\n+                ));\n+        compliance.setReadWatchedFields(readEnabledFields);\n+\n+        compliance.setWriteWatchedIndices(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList()));\n+        compliance.setReadIgnoreUsers(getSettingAsSet(\n+                settings,\n+                ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_IGNORE_USERS,\n+                DEFAULT_IGNORED_USERS_LIST,\n+                false));\n+        compliance.setWriteIgnoreUsers(getSettingAsSet(\n+                settings,\n+                ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_IGNORE_USERS,\n+                DEFAULT_IGNORED_USERS_LIST,\n+                false));\n+        auditConfig.setFilter(audit);\n+        auditConfig.setCompliance(compliance);\n+        return auditConfig;\n     }\n \n-    public static Set<String> getSettingAsSet(final Settings settings, final String key, final List<String> defaultList, final boolean ignoreCaseForNone) {\n+    private static Set<String> getSettingAsSet(final Settings settings, final String key, final List<String> defaultList, final boolean ignoreCaseForNone) {\n         final List<String> list = settings.getAsList(key, defaultList);\n         if (list.size() == 1 && \"NONE\".equals(ignoreCaseForNone? list.get(0).toUpperCase() : list.get(0))) {\n             return Collections.emptySet();\n         }\n         return ImmutableSet.copyOf(list);\n     }\n-}\n+\n+    /**\n+     * List of keys that are deprecated\n+     */\n+    public static final List<String> DEPRECATED_KEYS = ImmutableList.of(\n+            ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ENABLE_REST,\n+            ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DISABLED_REST_CATEGORIES,\n+            ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ENABLE_TRANSPORT,\n+            ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DISABLED_TRANSPORT_CATEGORIES,\n+            ConfigConstants.OPENDISTRO_SECURITY_AUDIT_LOG_REQUEST_BODY,\n+            ConfigConstants.OPENDISTRO_SECURITY_AUDIT_RESOLVE_INDICES,\n+            ConfigConstants.OPENDISTRO_SECURITY_AUDIT_EXCLUDE_SENSITIVE_HEADERS,\n+            ConfigConstants.OPENDISTRO_SECURITY_AUDIT_RESOLVE_BULK_REQUESTS,\n+            ConfigConstants.OPENDISTRO_SECURITY_AUDIT_IGNORE_USERS,\n+            ConfigConstants.OPENDISTRO_SECURITY_AUDIT_IGNORE_REQUESTS,\n+            ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED,\n+            ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED,\n+            ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY,\n+            ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_IGNORE_USERS,\n+            ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n+            ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY,\n+            ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS,\n+            ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_IGNORE_USERS,\n+            ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES\n+    );\n+\n+    public static Set<String> getDeprecatedKeys(final Settings settings) {\n+        return AuditConfig.DEPRECATED_KEYS\n+                .stream()\n+                .filter(settings::hasValue)\n+                .collect(Collectors.toSet());\n+    }\n+}", "originalCommit": "0428f4e7cccd5a45593d185f723a226d0e575683", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM0MTIxNw==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447341217", "bodyText": "This constructor should take configCompliance and store it as a member variable instead of copying each individual value.", "author": "vrozov", "createdAt": "2020-06-30T00:45:39Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -162,38 +158,35 @@ public void log(Logger logger) {\n      * @return compliance configuration\n      */\n     public static ComplianceConfig from(Settings settings) {\n-        final boolean logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n-        final boolean logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n-        final boolean logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n-        final boolean logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n-        final boolean logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n-        final List<String> watchedReadFields = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n-                Collections.emptyList(), false);\n-        final List<String> watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n+        final AuditConfig.Compliance compliance = AuditConfig.from(settings).getCompliance();\n+        return from(compliance, settings);\n+    }\n+\n+    /**\n+     * Create compliance configuration from audit\n+     * opendistrosecurityIndex - used to determine if internal index is written to or read from.\n+     * type - checks if log destination used is internal elasticsearch.\n+     * index - the index used for storing audit logs to avoid monitoring it.\n+     * @param configCompliance configCompliance\n+     * @param settings settings\n+     * @return ComplianceConfig\n+     */\n+    public static ComplianceConfig from(AuditConfig.Compliance configCompliance, Settings settings) {\n         final String opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n         final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n         final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX, \"'security-auditlog-'YYYY.MM.dd\");\n-        final Set<String> ignoredComplianceUsersForRead = AuditConfig.getSettingAsSet(\n-                settings,\n-                ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_IGNORE_USERS,\n-                AuditConfig.DEFAULT_IGNORED_USERS,\n-                false);\n-        final Set<String> ignoredComplianceUsersForWrite = AuditConfig.getSettingAsSet(\n-                settings,\n-                ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_IGNORE_USERS,\n-                AuditConfig.DEFAULT_IGNORED_USERS,\n-                false);\n \n         return new ComplianceConfig(\n-                logExternalConfig,\n-                logInternalConfig,\n-                logReadMetadataOnly,\n-                watchedReadFields,\n-                ignoredComplianceUsersForRead,\n-                logWriteMetadataOnly,\n-                logDiffsForWrite,\n-                watchedWriteIndices,\n-                ignoredComplianceUsersForWrite,\n+                configCompliance.isComplianceEnabled(),", "originalCommit": "0428f4e7cccd5a45593d185f723a226d0e575683", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM0Mjk0OQ==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447342949", "bodyText": "IMO, it will be better to move those strings to Filter or Compliance classes instead of sharing them in a single class. It is OK to do this in a follow up PR.", "author": "vrozov", "createdAt": "2020-06-30T00:51:44Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/config/AuditConfig.java", "diffHunk": "@@ -214,31 +397,368 @@ public void log(Logger logger) {\n             logger.info(\"Bulk requests resolution is {} during request auditing.\", resolveBulkRequests ? \"enabled\" : \"disabled\");\n             logger.info(\"Index resolution is {} during request auditing.\", resolveIndices ? \"enabled\" : \"disabled\");\n             logger.info(\"Sensitive headers auditing is {}.\", excludeSensitiveHeaders ? \"enabled\" : \"disabled\");\n-            logger.info(\"Auditing requests from {} users is disabled.\", ignoredAuditUsersMatcher);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"Filter{\" +\n-                    \"isRestApiAuditEnabled=\" + isRestApiAuditEnabled +\n-                    \", disabledRestCategories=\" + disabledRestCategories +\n-                    \", isTransportApiAuditEnabled=\" + isTransportApiAuditEnabled +\n-                    \", disabledTransportCategories=\" + disabledTransportCategories +\n-                    \", resolveBulkRequests=\" + resolveBulkRequests +\n-                    \", logRequestBody=\" + logRequestBody +\n-                    \", resolveIndices=\" + resolveIndices +\n-                    \", excludeSensitiveHeaders=\" + excludeSensitiveHeaders +\n-                    \", ignoredAuditUsers=\" + ignoredAuditUsersMatcher +\n-                    \", ignoreAuditRequests=\" + ignoredAuditRequestsMatcher +\n-                    '}';\n+            logger.info(\"Auditing requests from {} users is disabled.\", ignoredAuditUsers);\n+        }\n+    }\n+\n+    public static class Compliance {\n+        @JsonProperty(value = Key.ENABLED)\n+        private boolean complianceEnabled = true;\n+        @JsonProperty(value = Key.INTERNAL_CONFIG_ENABLED)\n+        private boolean internalConfigEnabled = true;\n+        @JsonProperty(value = Key.EXTERNAL_CONFIG_ENABLED)\n+        private boolean externalConfigEnabled = false;\n+        @JsonProperty(value = Key.READ_METADATA_ONLY)\n+        private boolean readMetadataOnly = true;\n+        @JsonProperty(value = Key.READ_WATCHED_FIELDS)\n+        private Map<String, Set<String>> readWatchedFields = Collections.emptyMap();\n+        @JsonProperty(value = Key.READ_IGNORE_USERS)\n+        private Set<String> readIgnoreUsers = Collections.emptySet();\n+        @JsonProperty(value = Key.WRITE_METADATA_ONLY)\n+        private boolean writeMetadataOnly = true;\n+        @JsonProperty(value = Key.WRITE_LOG_DIFFS)\n+        private boolean writeLogDiffs = false;\n+        @JsonProperty(value = Key.WRITE_WATCHED_INDICES)\n+        private List<String> writeWatchedIndices = Collections.emptyList();\n+        @JsonProperty(value = Key.WRITE_IGNORE_USERS)\n+        private Set<String> writeIgnoreUsers = Collections.emptySet();\n+\n+        /**\n+         * Checks if compliance auditing is enabled\n+         * @return true/false\n+         */\n+        @JsonIgnore\n+        public boolean isComplianceEnabled() {\n+            return complianceEnabled;\n+        }\n+\n+        /**\n+         * Set whether to audit compliance events\n+         * @param complianceEnabled true/false\n+         */\n+        @JsonIgnore\n+        public void setComplianceEnabled(boolean complianceEnabled) {\n+            this.complianceEnabled = complianceEnabled;\n+        }\n+\n+        /**\n+         * Check if auditing of internal opendistro security index is enabled\n+         * @return true/false\n+         */\n+        @JsonIgnore\n+        public boolean isInternalConfigEnabled() {\n+            return internalConfigEnabled;\n+        }\n+\n+        /**\n+         * Set whether to audit internal opendistro security index\n+         * @param internalConfigEnabled true/false\n+         */\n+        @JsonIgnore\n+        public void setInternalConfigEnabled(boolean internalConfigEnabled) {\n+            this.internalConfigEnabled = internalConfigEnabled;\n+        }\n+\n+        /**\n+         * Checks if auditing of external configuration files is enabled\n+         * @return true/false\n+         */\n+        @JsonIgnore\n+        public boolean isExternalConfigEnabled() {\n+            return externalConfigEnabled;\n+        }\n+\n+        /**\n+         * Set whether to audit external configuration files\n+         * @param externalConfigEnabled true/false\n+         */\n+        @JsonIgnore\n+        public void setExternalConfigEnabled(boolean externalConfigEnabled) {\n+            this.externalConfigEnabled = externalConfigEnabled;\n+        }\n+\n+        /**\n+         * Checks if only metadata or field names are to be logged for doc read requests\n+         * @return true/false\n+         */\n+        @JsonIgnore\n+        public boolean isReadMetadataOnly() {\n+            return readMetadataOnly;\n+        }\n+\n+        /**\n+         * Set if only metadata or field names are to be logged for doc read requests\n+         * @param readMetadataOnly true/false\n+         */\n+        @JsonIgnore\n+        public void setReadMetadataOnly(boolean readMetadataOnly) {\n+            this.readMetadataOnly = readMetadataOnly;\n+        }\n+\n+        /**\n+         * Get list of fields to watch for, in a document in an index\n+         * @return index name mapped to a set of fields\n+         */\n+        @JsonIgnore\n+        public Map<String, Set<String>> getReadWatchedFields() {\n+            return readWatchedFields;\n+        }\n+\n+        /**\n+         * Set list of fields to watch for, in a document in an index\n+         * @param readWatchedFields index name mapped to a set of fields\n+         */\n+        @JsonSetter(value = Key.READ_WATCHED_FIELDS, nulls = Nulls.AS_EMPTY)\n+        public void setReadWatchedFields(Map<String, Set<String>> readWatchedFields) {\n+            if (readWatchedFields != null) {\n+                this.readWatchedFields = readWatchedFields;\n+            } else {\n+                this.readWatchedFields = Collections.emptyMap();\n+            }\n+        }\n+\n+        /**\n+         * Get users ignored for auditing doc read requests\n+         * @return set of ignored users\n+         */\n+        @JsonIgnore\n+        public Set<String> getReadIgnoreUsers() {\n+            return readIgnoreUsers;\n+        }\n+\n+        /**\n+         * Set users to be ignored for auditing doc read requests\n+         * @param readIgnoreUsers users\n+         */\n+        @JsonSetter(value = Key.READ_IGNORE_USERS, nulls = Nulls.AS_EMPTY)\n+        public void setReadIgnoreUsers(Set<String> readIgnoreUsers) {\n+            if (readIgnoreUsers != null) {\n+                this.readIgnoreUsers = readIgnoreUsers;\n+            } else {\n+                this.readIgnoreUsers = Collections.emptySet();\n+            }\n         }\n+\n+        /**\n+         * Checks if only metadata or field names are to be logged for doc write requests\n+         * @return true/false\n+         */\n+        @JsonIgnore\n+        public boolean isWriteMetadataOnly() {\n+            return writeMetadataOnly;\n+        }\n+\n+        /**\n+         * Set whether to log only metadata for doc write requests\n+         * @param writeMetadataOnly true/false\n+         */\n+        @JsonIgnore\n+        public void setWriteMetadataOnly(boolean writeMetadataOnly) {\n+            this.writeMetadataOnly = writeMetadataOnly;\n+        }\n+\n+        /**\n+         * Checks if only diffs are to be logged for doc write requests\n+         * @return true/false\n+         */\n+        @JsonIgnore\n+        public boolean isWriteLogDiffs() {\n+            return writeLogDiffs;\n+        }\n+\n+        /**\n+         * Set whether to log only diffs for doc write requests\n+         * @param writeLogDiffs true/false\n+         */\n+        @JsonIgnore\n+        public void setWriteLogDiffs(boolean writeLogDiffs) {\n+            this.writeLogDiffs = writeLogDiffs;\n+        }\n+\n+        /**\n+         * Get list of indices to watch for doc write requests\n+         * @return indices\n+         */\n+        @JsonIgnore\n+        public List<String> getWriteWatchedIndices() {\n+            return writeWatchedIndices;\n+        }\n+\n+        /**\n+         * Set indices to watch for doc write requests\n+         * @param writeWatchedIndices indices\n+         */\n+        @JsonSetter(value = Key.WRITE_WATCHED_INDICES, nulls = Nulls.AS_EMPTY)\n+        public void setWriteWatchedIndices(List<String> writeWatchedIndices) {\n+            if (writeWatchedIndices != null) {\n+                this.writeWatchedIndices = writeWatchedIndices;\n+            } else {\n+                this.writeWatchedIndices = Collections.emptyList();\n+            }\n+        }\n+\n+        /**\n+         * Get users ignored for auditing doc write requests\n+         * @return set of ignored users\n+         */\n+        @JsonIgnore\n+        public Set<String> getWriteIgnoreUsers() {\n+            return writeIgnoreUsers;\n+        }\n+\n+        /**\n+         * Set users to be ignored for auditing doc write requests\n+         * @param writeIgnoreUsers users\n+         */\n+        @JsonSetter(value = Key.WRITE_IGNORE_USERS, nulls = Nulls.AS_EMPTY)\n+        public void setWriteIgnoreUsers(Set<String> writeIgnoreUsers) {\n+            if (writeIgnoreUsers != null) {\n+                this.writeIgnoreUsers = writeIgnoreUsers;\n+            } else {\n+                this.readIgnoreUsers = Collections.emptySet();\n+            }\n+        }\n+    }\n+\n+    public static class Key {", "originalCommit": "0428f4e7cccd5a45593d185f723a226d0e575683", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc3NTgyNQ==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447775825", "bodyText": "Done!", "author": "sujithvm", "createdAt": "2020-06-30T15:30:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM0Mjk0OQ=="}], "type": "inlineReview"}, {"oid": "7bd495a1919dc2216a66f408b3f10af40a1c717c", "url": "https://github.com/opensearch-project/security/commit/7bd495a1919dc2216a66f408b3f10af40a1c717c", "message": "code review", "committedDate": "2020-06-30T01:03:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM1NTQyNw==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447355427", "bodyText": "How is it enforced that isAuditConfigDocPresentInIndex is initialized before isAuditConfigDocPresentInIndex() is called?", "author": "vrozov", "createdAt": "2020-06-30T01:34:35Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/configuration/ConfigurationLoaderSecurity7.java", "diffHunk": "@@ -84,6 +87,14 @@\n         log.debug(\"Index is: {}\", securityIndex);\n     }\n \n+    /**\n+     * Checks if audit config doc is present in security index\n+     * @return true/false\n+     */\n+    boolean isAuditConfigDocPresentInIndex() {\n+        return isAuditConfigDocPresentInIndex.get();", "originalCommit": "0428f4e7cccd5a45593d185f723a226d0e575683", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2NTQ2OA==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447365468", "bodyText": "As part of bootstrapping the configs are reloaded https://github.com/sujithvm/security/blob/auditlog/src/main/java/com/amazon/opendistroforelasticsearch/security/configuration/ConfigurationRepository.java#L192\nThis would ensure whether doc is present in the index or not.", "author": "sujithvm", "createdAt": "2020-06-30T02:09:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM1NTQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM1NjYzOA==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447356638", "bodyText": "What is the final agreement on the case where audit entries are present both in the index and elasticsearch.yml?", "author": "vrozov", "createdAt": "2020-06-30T01:38:35Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/configuration/ConfigurationRepository.java", "diffHunk": "@@ -195,6 +204,21 @@ public void run() {\n                         }\n                     }\n \n+                    final Set<String> deprecatedAuditKeysInSettings = AuditConfig.getDeprecatedKeys(settings);\n+                    if (!deprecatedAuditKeysInSettings.isEmpty()) {\n+                        LOGGER.warn(\"Following keys {} are deprecated in elasticsearch settings. They will be removed in plugin v2.0.0.0\", deprecatedAuditKeysInSettings);\n+                    }\n+                    final boolean isAuditConfigDocPresentInIndex = cl.isAuditConfigDocPresentInIndex();\n+                    if (isAuditConfigDocPresentInIndex) {\n+                        if (!deprecatedAuditKeysInSettings.isEmpty()) {", "originalCommit": "0428f4e7cccd5a45593d185f723a226d0e575683", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2NTg2MA==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447365860", "bodyText": "Warn the user that settings are present at both places but continue using from index. Do not fail startup.\nIndex takes priority over elasticsearch.yml.", "author": "sujithvm", "createdAt": "2020-06-30T02:10:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM1NjYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM3MzU3Ng==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447373576", "bodyText": "OK, just want to be sure that it is the final agreement and it is documented", "author": "vrozov", "createdAt": "2020-06-30T02:39:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM1NjYzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM1Njc1Ng==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447356756", "bodyText": "nit: add new line", "author": "vrozov", "createdAt": "2020-06-30T01:39:00Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/configuration/ConfigurationRepository.java", "diffHunk": "@@ -377,4 +405,4 @@ private static String formatDate(long date) {\n     public static int getDefaultConfigVersion() {\n         return ConfigurationRepository.DEFAULT_CONFIG_VERSION;\n     }\n-}\n+}", "originalCommit": "0428f4e7cccd5a45593d185f723a226d0e575683", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2MTY2MQ==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447361661", "bodyText": "Use RESOURCE_NAME", "author": "vrozov", "createdAt": "2020-06-30T01:56:05Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/dlic/rest/api/AuditApiAction.java", "diffHunk": "@@ -0,0 +1,185 @@\n+package com.amazon.opendistroforelasticsearch.security.dlic.rest.api;\n+\n+import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.configuration.ConfigurationRepository;\n+import com.amazon.opendistroforelasticsearch.security.dlic.rest.validation.AbstractConfigurationValidator;\n+import com.amazon.opendistroforelasticsearch.security.dlic.rest.validation.AuditValidator;\n+import com.amazon.opendistroforelasticsearch.security.privileges.PrivilegesEvaluator;\n+import com.amazon.opendistroforelasticsearch.security.securityconf.impl.CType;\n+import com.amazon.opendistroforelasticsearch.security.ssl.transport.PrincipalExtractor;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.ImmutableList;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+/**\n+ * Rest handler for fetching and updating audit configuration.\n+ * Supported REST endpoints\n+ * GET _opendistro/_security/api/audit/\n+ * {\n+ *   \"config\" : {\n+ *     \"audit\" : {\n+ *       \"enable_rest\" : true,\n+ *       \"disabled_rest_categories\" : [\n+ *         \"GRANTED_PRIVILEGES\",\n+ *         \"SSL_EXCEPTION\"\n+ *       ],\n+ *       \"enable_transport\" : true,\n+ *       \"disabled_transport_categories\" : [\n+ *         \"GRANTED_PRIVILEGES\",\n+ *         \"AUTHENTICATED\"\n+ *       ],\n+ *       \"resolve_bulk_requests\" : false,\n+ *       \"log_request_body\" : true,\n+ *       \"resolve_indices\" : true,\n+ *       \"exclude_sensitive_headers\" : true,\n+ *       \"ignore_users\" : [\n+ *         \"kibanaserver\"\n+ *       ],\n+ *       \"ignore_requests\" : [ ]\n+ *     },\n+ *     \"compliance\" : {\n+ *       \"internal_config\" : true,\n+ *       \"external_config\" : true,\n+ *       \"read_metadata_only\" : true,\n+ *       \"read_watched_fields\" : { },\n+ *       \"read_ignore_users\" : [ ],\n+ *       \"write_metadata_only\" : true,\n+ *       \"write_log_diffs\" : false,\n+ *       \"write_watched_indices\" : [ ],\n+ *       \"write_ignore_users\" : [ ]\n+ *     }\n+ *   }\n+ * }\n+ *\n+ * PUT _opendistro/_security/api/audit/config\n+ * {\n+ *   \"audit\":{\n+ *     \"enable_rest\":true,\n+ *     \"disabled_rest_categories\":[\n+ *       \"GRANTED_PRIVILEGES\",\n+ *       \"SSL_EXCEPTION\"\n+ *     ],\n+ *     \"enable_transport\":true,\n+ *     \"disabled_transport_categories\":[\n+ *       \"GRANTED_PRIVILEGES\",\n+ *       \"AUTHENTICATED\"\n+ *     ],\n+ *     \"resolve_bulk_requests\":false,\n+ *     \"log_request_body\":true,\n+ *     \"resolve_indices\":true,\n+ *     \"exclude_sensitive_headers\":true,\n+ *     \"ignore_users\":[ ],\n+ *     \"ignore_requests\":[ ]\n+ *   },\n+ *   \"compliance\":{\n+ *     \"internal_config\":true,\n+ *     \"external_config\":true,\n+ *     \"read_metadata_only\":true,\n+ *     \"read_watched_fields\":{ },\n+ *     \"read_ignore_users\":[ ],\n+ *     \"write_metadata_only\":true,\n+ *     \"write_log_diffs\":false,\n+ *     \"write_watched_indices\":[ ],\n+ *     \"write_ignore_users\":[ ]\n+ *   }\n+ * }\n+ *\n+ * PATCH _opendistro/_security/api/audit\n+ * [{\"op\": \"replace\", \"path\": \"/config/audit/enable_rest\", \"value\": \"true\"}]\n+ * [{\"op\": \"replace\", \"path\": \"/config/compliance/internal_config\", \"value\": \"true\"}]\n+ */\n+public class AuditApiAction extends PatchableResourceApiAction {\n+    private static final List<Route> routes = ImmutableList.of(\n+            new Route(RestRequest.Method.GET, \"/_opendistro/_security/api/audit/\"),\n+            new Route(RestRequest.Method.PUT, \"/_opendistro/_security/api/audit/{name}\"),\n+            new Route(RestRequest.Method.PATCH, \"/_opendistro/_security/api/audit/\")\n+    );\n+\n+    private static final String RESOURCE_NAME = \"config\";\n+    private final PrivilegesEvaluator privilegesEvaluator;\n+    private final ThreadContext threadContext;\n+\n+    public AuditApiAction(final Settings settings,\n+                          final Path configPath,\n+                          final RestController controller,\n+                          final Client client,\n+                          final AdminDNs adminDNs,\n+                          final ConfigurationRepository cl,\n+                          final ClusterService cs,\n+                          final PrincipalExtractor principalExtractor,\n+                          final PrivilegesEvaluator privilegesEvaluator,\n+                          final ThreadPool threadPool,\n+                          final AuditLog auditLog) {\n+        super(settings, configPath, controller, client, adminDNs, cl, cs, principalExtractor, privilegesEvaluator, threadPool, auditLog);\n+        this.privilegesEvaluator = privilegesEvaluator;\n+        this.threadContext = threadPool.getThreadContext();\n+    }\n+\n+    @Override\n+    public List<Route> routes() {\n+        return routes;\n+    }\n+\n+    @Override\n+    protected void handleApiRequest(final RestChannel channel, final RestRequest request, final Client client) throws IOException {\n+        // if audit config doc is not available in security index,\n+        // disable audit APIs\n+        if (!cl.isAuditHotReloadingEnabled()) {\n+            notImplemented(channel, request.method());\n+            return;\n+        }\n+        super.handleApiRequest(channel, request, client);\n+    }\n+\n+    @Override\n+    protected void handlePut(final RestChannel channel, final RestRequest request, final Client client, final JsonNode content) throws IOException {\n+        if (!\"config\".equals(request.param(\"name\"))) {", "originalCommit": "7bd495a1919dc2216a66f408b3f10af40a1c717c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2MjYxNw==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447362617", "bodyText": "Can you move this to a separate PR, I am not sure why NodesDn was not included before.", "author": "vrozov", "createdAt": "2020-06-30T01:59:36Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/dlic/rest/api/ValidateApiAction.java", "diffHunk": "@@ -96,13 +98,17 @@ protected void handleGet(RestChannel channel, RestRequest request, Client client\n             final SecurityDynamicConfiguration<InternalUserV6> internalUsersV6 = (SecurityDynamicConfiguration<InternalUserV6>) load(CType.INTERNALUSERS, true, acceptInvalid);\n             final SecurityDynamicConfiguration<RoleV6> rolesV6 = (SecurityDynamicConfiguration<RoleV6>) load(CType.ROLES, true, acceptInvalid);\n             final SecurityDynamicConfiguration<RoleMappingsV6> rolesmappingV6 = (SecurityDynamicConfiguration<RoleMappingsV6>) load(CType.ROLESMAPPING, true, acceptInvalid);\n+            final SecurityDynamicConfiguration<NodesDn> nodesDnV6 = (SecurityDynamicConfiguration<NodesDn>) load(CType.NODESDN, true);", "originalCommit": "7bd495a1919dc2216a66f408b3f10af40a1c717c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2NTQ1Ng==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447365456", "bodyText": "Order in which tests are executed by JUnit is not defined, this may be the first one to be executed and it will set sendAdminCertificate to true.", "author": "vrozov", "createdAt": "2020-06-30T02:09:32Z", "path": "src/test/java/com/amazon/opendistroforelasticsearch/security/auditlog/compliance/ComplianceAuditlogTest.java", "diffHunk": "@@ -86,6 +93,36 @@ public void testSourceFilter() throws Exception {\n         Assert.assertTrue(validateMsgs(TestAuditlogImpl.messages));\n     }\n \n+    @Test\n+    public void testComplianceEnable() throws Exception {\n+        Settings additionalSettings = Settings.builder()\n+                .put(\"opendistro_security.audit.type\", TestAuditlogImpl.class.getName())\n+                .build();\n+\n+        setup(additionalSettings);\n+        rh.sendAdminCertificate = true;", "originalCommit": "7bd495a1919dc2216a66f408b3f10af40a1c717c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2Nzc0MQ==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447367741", "bodyText": "Is the change necessary? Can't it rely on settings to configure audit in the test not directly related to it?", "author": "vrozov", "createdAt": "2020-06-30T02:17:16Z", "path": "src/test/java/com/amazon/opendistroforelasticsearch/security/auditlog/impl/TracingTests.java", "diffHunk": "@@ -332,11 +333,17 @@ public void uncaughtException(Thread t, Throwable e) {\n     @Test\n     public void testAdvancedMapping() throws Exception {\n         Settings settings = Settings.builder()\n-                .put(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS, \"*\")", "originalCommit": "7bd495a1919dc2216a66f408b3f10af40a1c717c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2OTE2MA==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447369160", "bodyText": "Why java block ({ ... }) is necessary?", "author": "vrozov", "createdAt": "2020-06-30T02:22:44Z", "path": "src/test/java/com/amazon/opendistroforelasticsearch/security/dlic/rest/api/AuditApiActionTest.java", "diffHunk": "@@ -0,0 +1,285 @@\n+package com.amazon.opendistroforelasticsearch.security.dlic.rest.api;\n+\n+import com.amazon.opendistroforelasticsearch.security.DefaultObjectMapper;\n+import com.amazon.opendistroforelasticsearch.security.auditlog.AuditTestUtils;\n+import com.amazon.opendistroforelasticsearch.security.test.helper.rest.RestHelper;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.http.Header;\n+import org.apache.http.HttpStatus;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Test;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.amazon.opendistroforelasticsearch.security.DefaultObjectMapper.readTree;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+\n+public class AuditApiActionTest extends AbstractRestApiUnitTest {\n+\n+    private static final String ENDPOINT = \"/_opendistro/_security/api/audit\";\n+    private static final String CONFIG_ENDPOINT = \"/_opendistro/_security/api/audit/config\";\n+\n+    @Test\n+    public void testInvalidPath() throws Exception {\n+        setup();\n+\n+        rh.keystore = \"restapi/kirk-keystore.jks\";\n+        rh.sendAdminCertificate = true;\n+        RestHelper.HttpResponse response;\n+\n+        // should have /config for put request\n+        response = rh.executePutRequest(ENDPOINT, \"{\\\"xxx\\\": 1}\");\n+        assertEquals(HttpStatus.SC_METHOD_NOT_ALLOWED, response.getStatusCode());\n+\n+        // no post supported\n+        response = rh.executePostRequest(ENDPOINT, \"{\\\"xxx\\\": 1}\");\n+        assertEquals(HttpStatus.SC_METHOD_NOT_ALLOWED, response.getStatusCode());\n+\n+        // should have /config for patch request\n+        response = rh.executePatchRequest(ENDPOINT, \"{\\\"xxx\\\": 1}\");\n+        assertEquals(HttpStatus.SC_BAD_REQUEST, response.getStatusCode());\n+\n+        // no delete supported\n+        response = rh.executeDeleteRequest(ENDPOINT);\n+        assertEquals(HttpStatus.SC_METHOD_NOT_ALLOWED, response.getStatusCode());\n+    }\n+\n+    @Test\n+    public void testBadRequest() throws Exception {\n+        setupWithRestRoles();\n+        rh.keystore = \"restapi/kirk-keystore.jks\";\n+        rh.sendAdminCertificate = true;\n+\n+        // test bad patch request\n+        testBoolean(\"/test\", HttpStatus.SC_BAD_REQUEST);\n+        testBoolean(\"/config/test\", HttpStatus.SC_BAD_REQUEST);\n+        testBoolean(\"/config/audit/test\", HttpStatus.SC_BAD_REQUEST);\n+        testBoolean(\"/config/compliance/test\", HttpStatus.SC_BAD_REQUEST);\n+        testBoolean(\"/config/compliance/disabled_rest_categories\", HttpStatus.SC_BAD_REQUEST);\n+\n+        testPutAction(\"{}\", HttpStatus.SC_BAD_REQUEST);\n+        testPutAction(\"{\\\"test\\\": \\\"val\\\"}\", HttpStatus.SC_BAD_REQUEST);\n+\n+        // incorrect category\n+        final String jsonValue = DefaultObjectMapper.writeValueAsString(ImmutableList.of(\"RANDOM\", \"Test\"), true);\n+        RestHelper.HttpResponse response;\n+        response = rh.executePatchRequest(ENDPOINT, \"[{\\\"op\\\": \\\"add\\\",\\\"path\\\": \\\"\" + \"/config/audit/disabled_rest_categories\" + \"\\\",\\\"value\\\": \" + jsonValue + \"}]\");\n+        assertEquals(HttpStatus.SC_BAD_REQUEST, response.getStatusCode());\n+        response = rh.executePatchRequest(ENDPOINT, \"[{\\\"op\\\": \\\"add\\\",\\\"path\\\": \\\"\" + \"/config/audit/disabled_transport_categories\" + \"\\\",\\\"value\\\": \" + jsonValue + \"}]\");\n+        assertEquals(HttpStatus.SC_BAD_REQUEST, response.getStatusCode());\n+    }\n+\n+    @Test\n+    public void testApi() throws Exception {\n+        setupWithRestRoles();\n+        rh.keystore = \"restapi/kirk-keystore.jks\";\n+\n+        // admin cred with roles in test yml files\n+        final Header adminCredsHeader = encodeBasicHeader(\"sarek\", \"sarek\");\n+        // non-admin\n+        final Header nonAdminCredsHeader = encodeBasicHeader(\"random\", \"random\");\n+\n+        {", "originalCommit": "7bd495a1919dc2216a66f408b3f10af40a1c717c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM3MDAyMg==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447370022", "bodyText": "nit: take desired sendAdminCertificate as a parameter for testActions.", "author": "vrozov", "createdAt": "2020-06-30T02:25:55Z", "path": "src/test/java/com/amazon/opendistroforelasticsearch/security/dlic/rest/api/AuditApiActionTest.java", "diffHunk": "@@ -0,0 +1,285 @@\n+package com.amazon.opendistroforelasticsearch.security.dlic.rest.api;\n+\n+import com.amazon.opendistroforelasticsearch.security.DefaultObjectMapper;\n+import com.amazon.opendistroforelasticsearch.security.auditlog.AuditTestUtils;\n+import com.amazon.opendistroforelasticsearch.security.test.helper.rest.RestHelper;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.http.Header;\n+import org.apache.http.HttpStatus;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Test;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.amazon.opendistroforelasticsearch.security.DefaultObjectMapper.readTree;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+\n+public class AuditApiActionTest extends AbstractRestApiUnitTest {\n+\n+    private static final String ENDPOINT = \"/_opendistro/_security/api/audit\";\n+    private static final String CONFIG_ENDPOINT = \"/_opendistro/_security/api/audit/config\";\n+\n+    @Test\n+    public void testInvalidPath() throws Exception {\n+        setup();\n+\n+        rh.keystore = \"restapi/kirk-keystore.jks\";\n+        rh.sendAdminCertificate = true;\n+        RestHelper.HttpResponse response;\n+\n+        // should have /config for put request\n+        response = rh.executePutRequest(ENDPOINT, \"{\\\"xxx\\\": 1}\");\n+        assertEquals(HttpStatus.SC_METHOD_NOT_ALLOWED, response.getStatusCode());\n+\n+        // no post supported\n+        response = rh.executePostRequest(ENDPOINT, \"{\\\"xxx\\\": 1}\");\n+        assertEquals(HttpStatus.SC_METHOD_NOT_ALLOWED, response.getStatusCode());\n+\n+        // should have /config for patch request\n+        response = rh.executePatchRequest(ENDPOINT, \"{\\\"xxx\\\": 1}\");\n+        assertEquals(HttpStatus.SC_BAD_REQUEST, response.getStatusCode());\n+\n+        // no delete supported\n+        response = rh.executeDeleteRequest(ENDPOINT);\n+        assertEquals(HttpStatus.SC_METHOD_NOT_ALLOWED, response.getStatusCode());\n+    }\n+\n+    @Test\n+    public void testBadRequest() throws Exception {\n+        setupWithRestRoles();\n+        rh.keystore = \"restapi/kirk-keystore.jks\";\n+        rh.sendAdminCertificate = true;\n+\n+        // test bad patch request\n+        testBoolean(\"/test\", HttpStatus.SC_BAD_REQUEST);\n+        testBoolean(\"/config/test\", HttpStatus.SC_BAD_REQUEST);\n+        testBoolean(\"/config/audit/test\", HttpStatus.SC_BAD_REQUEST);\n+        testBoolean(\"/config/compliance/test\", HttpStatus.SC_BAD_REQUEST);\n+        testBoolean(\"/config/compliance/disabled_rest_categories\", HttpStatus.SC_BAD_REQUEST);\n+\n+        testPutAction(\"{}\", HttpStatus.SC_BAD_REQUEST);\n+        testPutAction(\"{\\\"test\\\": \\\"val\\\"}\", HttpStatus.SC_BAD_REQUEST);\n+\n+        // incorrect category\n+        final String jsonValue = DefaultObjectMapper.writeValueAsString(ImmutableList.of(\"RANDOM\", \"Test\"), true);\n+        RestHelper.HttpResponse response;\n+        response = rh.executePatchRequest(ENDPOINT, \"[{\\\"op\\\": \\\"add\\\",\\\"path\\\": \\\"\" + \"/config/audit/disabled_rest_categories\" + \"\\\",\\\"value\\\": \" + jsonValue + \"}]\");\n+        assertEquals(HttpStatus.SC_BAD_REQUEST, response.getStatusCode());\n+        response = rh.executePatchRequest(ENDPOINT, \"[{\\\"op\\\": \\\"add\\\",\\\"path\\\": \\\"\" + \"/config/audit/disabled_transport_categories\" + \"\\\",\\\"value\\\": \" + jsonValue + \"}]\");\n+        assertEquals(HttpStatus.SC_BAD_REQUEST, response.getStatusCode());\n+    }\n+\n+    @Test\n+    public void testApi() throws Exception {\n+        setupWithRestRoles();\n+        rh.keystore = \"restapi/kirk-keystore.jks\";\n+\n+        // admin cred with roles in test yml files\n+        final Header adminCredsHeader = encodeBasicHeader(\"sarek\", \"sarek\");\n+        // non-admin\n+        final Header nonAdminCredsHeader = encodeBasicHeader(\"random\", \"random\");\n+\n+        {\n+            // No creds, no admin certificate - UNAUTHORIZED\n+            rh.sendAdminCertificate = false;\n+            testActions(HttpStatus.SC_UNAUTHORIZED);", "originalCommit": "7bd495a1919dc2216a66f408b3f10af40a1c717c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9d73716524cfb98d830220d60908cf05f4da8cb1", "url": "https://github.com/opensearch-project/security/commit/9d73716524cfb98d830220d60908cf05f4da8cb1", "message": "code review", "committedDate": "2020-06-30T02:34:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM3NjA2Mg==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447376062", "bodyText": "isAuditConfigDocPresentInIndex must be set before latch is updated to avoid possibility of the waiting thread using not updated state.", "author": "vrozov", "createdAt": "2020-06-30T02:48:35Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/configuration/ConfigurationLoaderSecurity7.java", "diffHunk": "@@ -101,6 +112,11 @@ public void success(SecurityDynamicConfiguration<?> dConf) {\n                 if(log.isDebugEnabled()) {\n                     log.debug(\"Received config for {} (of {}) with current latch value={}\", dConf.getCType().toLCString(), Arrays.toString(events), latch.getCount());\n                 }\n+                // Audit configuration doc is available in the index.\n+                // Configuration can be hot-reloaded.\n+                if (dConf.getCType() == CType.AUDIT) {\n+                    isAuditConfigDocPresentInIndex.set(true);", "originalCommit": "9d73716524cfb98d830220d60908cf05f4da8cb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a40d25bd4a74bf93dbcaeea21a787182bf7e3015", "url": "https://github.com/opensearch-project/security/commit/a40d25bd4a74bf93dbcaeea21a787182bf7e3015", "message": "code review", "committedDate": "2020-06-30T08:27:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMzOTYyMg==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447339622", "bodyText": "will this loose audit-logging for  changes in external config (.yml changes) during node boot up?\nhow did we test to make sure its current functionality?", "author": "hardik-k-shah", "createdAt": "2020-06-30T00:40:02Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/AuditLog.java", "diffHunk": "@@ -72,10 +73,12 @@\n     void logDocumentRead(String index, String id, ShardId shardId, Map<String, String> fieldNameValues);\n     void logDocumentWritten(ShardId shardId, GetResult originalIndex, Index currentIndex, IndexResult result);\n     void logDocumentDeleted(ShardId shardId, Delete delete, DeleteResult result);\n-    void logExternalConfig(Settings settings, Environment environment);", "originalCommit": "0428f4e7cccd5a45593d185f723a226d0e575683", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0NzMxMg==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r448047312", "bodyText": "https://github.com/opendistro-for-elasticsearch/security/pull/409/files#diff-5f0cc3e225606da6800e9edc758caf36R125 posts the external config. This is done within the implementation and hence removed it from the interface.", "author": "sujithvm", "createdAt": "2020-07-01T00:14:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMzOTYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5MTQ3OQ==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447891479", "bodyText": "private boolean logRequestBody = true;  --> should we log request body by default?", "author": "hardik-k-shah", "createdAt": "2020-06-30T18:24:08Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/config/AuditConfig.java", "diffHunk": "@@ -1,167 +1,363 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *  You may not use this file except in compliance with the License.\n+ *  A copy of the License is located at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed\n+ *  on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n package com.amazon.opendistroforelasticsearch.security.auditlog.config;\n \n import com.amazon.opendistroforelasticsearch.security.auditlog.impl.AuditCategory;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n-\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.settings.Settings;\n \n import java.util.Arrays;\n import java.util.Collections;\n import java.util.EnumSet;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n+import java.util.stream.Collectors;\n \n /**\n  * Class represents configuration for audit logging.\n+ * Expected class structure\n+ * {\n+ *   \"enabled\": true,\n+ *   \"audit\" : {\n+ *     \"enable_rest\" : true,\n+ *     \"disabled_rest_categories\" : [\n+ *       \"GRANTED_PRIVILEGES\",\n+ *       \"SSL_EXCEPTION\"\n+ *     ],\n+ *     \"enable_transport\" : true,\n+ *     \"disabled_transport_categories\" : [\n+ *       \"GRANTED_PRIVILEGES\",\n+ *       \"AUTHENTICATED\"\n+ *     ],\n+ *     \"resolve_bulk_requests\" : false,\n+ *     \"log_request_body\" : true,\n+ *     \"resolve_indices\" : true,\n+ *     \"exclude_sensitive_headers\" : true,\n+ *     \"ignore_users\" : [\n+ *       \"kibanaserver\"\n+ *     ],\n+ *     \"ignore_requests\" : [ ]\n+ *   },\n+ *   \"compliance\" : {\n+ *     \"enabled\": true,\n+ *     \"internal_config\" : true,\n+ *     \"external_config\" : true,\n+ *     \"read_metadata_only\" : true,\n+ *     \"read_watched_fields\" : { },\n+ *     \"read_ignore_users\" : [ ],\n+ *     \"write_metadata_only\" : true,\n+ *     \"write_log_diffs\" : false,\n+ *     \"write_watched_indices\" : [ ],\n+ *     \"write_ignore_users\" : [ ]\n+ *   }\n+ * }\n  */\n public class AuditConfig {\n \n-    public static final List<String> DEFAULT_IGNORED_USERS = Collections.singletonList(\"kibanaserver\");\n+    private static final Set<String> DEFAULT_IGNORED_USERS = Collections.singleton(\"kibanaserver\");\n+    private static final EnumSet<AuditCategory> DEFAULT_DISABLED_CATEGORIES = EnumSet.of(\n+            AuditCategory.AUTHENTICATED, AuditCategory.GRANTED_PRIVILEGES);\n+\n+    @JsonProperty(value = Key.ENABLED)\n+    private boolean auditLogEnabled = true;\n+    @JsonProperty(value = Key.AUDIT)\n+    private Filter filter = new Filter();\n+    @JsonProperty(value = Key.COMPLIANCE)\n+    private Compliance compliance = new Compliance();\n+\n+    @JsonIgnore\n+    public boolean isEnabled() {\n+        return auditLogEnabled;\n+    }\n+\n+    @JsonIgnore\n+    public void setEnabled(boolean auditLogEnabled) {\n+        this.auditLogEnabled = auditLogEnabled;\n+    }\n+\n+    @JsonIgnore\n+    public Filter getFilter() {\n+        return filter;\n+    }\n \n-    private AuditConfig() { }\n+    @JsonProperty(value = Key.AUDIT)\n+    public void setFilter(Filter filter) {\n+        this.filter = filter;\n+    }\n+\n+    @JsonIgnore\n+    public Compliance getCompliance() {\n+        return compliance;\n+    }\n+\n+    @JsonProperty(value = Key.COMPLIANCE)\n+    public void setCompliance(Compliance compliance) {\n+        this.compliance = compliance;\n+    }\n \n     /**\n      * Filter represents set of filtering configuration settings for audit logging.\n      * Audit logger will use these settings to determine what audit logs are to be generated.\n      */\n     public static class Filter {\n-        private static final List<String> DEFAULT_DISABLED_CATEGORIES =\n-                Arrays.asList(AuditCategory.AUTHENTICATED.toString(),\n-                        AuditCategory.GRANTED_PRIVILEGES.toString());\n-\n-        private final boolean isRestApiAuditEnabled;\n-        private final boolean isTransportApiAuditEnabled;\n-        private final boolean resolveBulkRequests;\n-        private final boolean logRequestBody;\n-        private final boolean resolveIndices;\n-        private final boolean excludeSensitiveHeaders;\n-        private final WildcardMatcher ignoredAuditUsersMatcher;\n-        private final WildcardMatcher ignoredAuditRequestsMatcher;\n-        private final EnumSet<AuditCategory> disabledRestCategories;\n-        private final EnumSet<AuditCategory> disabledTransportCategories;\n-\n-        private Filter(final boolean isRestApiAuditEnabled,\n-                       final boolean isTransportApiAuditEnabled,\n-                       final boolean resolveBulkRequests,\n-                       final boolean logRequestBody,\n-                       final boolean resolveIndices,\n-                       final boolean excludeSensitiveHeaders,\n-                       final Set<String> ignoredAuditUsers,\n-                       final Set<String> ignoredAuditRequests,\n-                       final EnumSet<AuditCategory> disabledRestCategories,\n-                       final EnumSet<AuditCategory> disabledTransportCategories) {\n-            this.isRestApiAuditEnabled = isRestApiAuditEnabled;\n-            this.isTransportApiAuditEnabled = isTransportApiAuditEnabled;\n-            this.resolveBulkRequests = resolveBulkRequests;\n-            this.logRequestBody = logRequestBody;\n-            this.resolveIndices = resolveIndices;\n-            this.excludeSensitiveHeaders = excludeSensitiveHeaders;\n-            this.ignoredAuditUsersMatcher = WildcardMatcher.from(ignoredAuditUsers);\n-            this.ignoredAuditRequestsMatcher = WildcardMatcher.from(ignoredAuditRequests);\n-            this.disabledRestCategories = disabledRestCategories;\n-            this.disabledTransportCategories = disabledTransportCategories;\n-        }\n-\n-        /**\n-         * Generate audit logging configuration from settings defined in elasticsearch.yml\n-         * @param settings settings\n-         * @return audit configuration filter\n-         */\n-        public static Filter from(Settings settings) {\n-            final boolean isRestApiAuditEnabled = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ENABLE_REST, true);\n-            final boolean isTransportAuditEnabled = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ENABLE_TRANSPORT, true);\n-            final boolean resolveBulkRequests = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_RESOLVE_BULK_REQUESTS, false);\n-            final boolean logRequestBody = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_LOG_REQUEST_BODY, true);\n-            final boolean resolveIndices = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_RESOLVE_INDICES, true);\n-            final boolean excludeSensitiveHeaders = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_EXCLUDE_SENSITIVE_HEADERS, true);\n-\n-            final EnumSet<AuditCategory> disabledRestCategories = AuditCategory.parse(getSettingAsSet(\n-                    settings,\n-                    ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DISABLED_REST_CATEGORIES,\n-                    DEFAULT_DISABLED_CATEGORIES,\n-                    true));\n-\n-            final EnumSet<AuditCategory> disabledTransportCategories = AuditCategory.parse(getSettingAsSet(\n-                    settings,\n-                    ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DISABLED_TRANSPORT_CATEGORIES,\n-                    DEFAULT_DISABLED_CATEGORIES,\n-                    true));\n-\n-            final Set<String> ignoredAuditUsers = getSettingAsSet(\n-                    settings,\n-                    ConfigConstants.OPENDISTRO_SECURITY_AUDIT_IGNORE_USERS,\n-                    DEFAULT_IGNORED_USERS,\n-                    false);\n-\n-            final Set<String> ignoreAuditRequests = ImmutableSet.copyOf(settings.getAsList(\n-                    ConfigConstants.OPENDISTRO_SECURITY_AUDIT_IGNORE_REQUESTS,\n-                    Collections.emptyList()));\n-\n-            return new Filter(isRestApiAuditEnabled,\n-                    isTransportAuditEnabled,\n-                    resolveBulkRequests,\n-                    logRequestBody,\n-                    resolveIndices,\n-                    excludeSensitiveHeaders,\n-                    ignoredAuditUsers,\n-                    ignoreAuditRequests,\n-                    disabledRestCategories,\n-                    disabledTransportCategories);\n-        }\n+        @JsonProperty(value = Key.ENABLE_REST)\n+        private boolean isRestApiAuditEnabled = true;\n+        @JsonProperty(value = Key.DISABLED_REST_CATEGORIES)\n+        private EnumSet<AuditCategory> disabledRestCategories = DEFAULT_DISABLED_CATEGORIES;\n+        @JsonProperty(value = Key.ENABLE_TRANSPORT)\n+        private boolean isTransportApiAuditEnabled = true;\n+        @JsonProperty(value = Key.DISABLED_TRANSPORT_CATEGORIES)\n+        private EnumSet<AuditCategory> disabledTransportCategories = DEFAULT_DISABLED_CATEGORIES;\n+        @JsonProperty(value = Key.RESOLVE_BULK_REQUESTS)\n+        private boolean resolveBulkRequests = false;\n+        @JsonProperty(value = Key.LOG_REQUEST_BODY)\n+        private boolean logRequestBody = true;", "originalCommit": "0428f4e7cccd5a45593d185f723a226d0e575683", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0Nzc2MA==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r448047760", "bodyText": "Current setting was true incase it was missing in elasticsearch.yml . Can change this if needed.", "author": "sujithvm", "createdAt": "2020-07-01T00:16:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5MTQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1NDgxMg==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447954812", "bodyText": "Can you please add sample about wildcard support in YML file?", "author": "hardik-k-shah", "createdAt": "2020-06-30T20:19:51Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/config/AuditConfig.java", "diffHunk": "@@ -1,167 +1,363 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *  You may not use this file except in compliance with the License.\n+ *  A copy of the License is located at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed\n+ *  on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n package com.amazon.opendistroforelasticsearch.security.auditlog.config;\n \n import com.amazon.opendistroforelasticsearch.security.auditlog.impl.AuditCategory;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n-\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.settings.Settings;\n \n import java.util.Arrays;\n import java.util.Collections;\n import java.util.EnumSet;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n+import java.util.stream.Collectors;\n \n /**\n  * Class represents configuration for audit logging.\n+ * Expected class structure\n+ * {\n+ *   \"enabled\": true,\n+ *   \"audit\" : {\n+ *     \"enable_rest\" : true,\n+ *     \"disabled_rest_categories\" : [\n+ *       \"GRANTED_PRIVILEGES\",\n+ *       \"SSL_EXCEPTION\"\n+ *     ],\n+ *     \"enable_transport\" : true,\n+ *     \"disabled_transport_categories\" : [\n+ *       \"GRANTED_PRIVILEGES\",\n+ *       \"AUTHENTICATED\"\n+ *     ],\n+ *     \"resolve_bulk_requests\" : false,\n+ *     \"log_request_body\" : true,\n+ *     \"resolve_indices\" : true,\n+ *     \"exclude_sensitive_headers\" : true,\n+ *     \"ignore_users\" : [\n+ *       \"kibanaserver\"\n+ *     ],\n+ *     \"ignore_requests\" : [ ]\n+ *   },\n+ *   \"compliance\" : {\n+ *     \"enabled\": true,\n+ *     \"internal_config\" : true,\n+ *     \"external_config\" : true,\n+ *     \"read_metadata_only\" : true,\n+ *     \"read_watched_fields\" : { },\n+ *     \"read_ignore_users\" : [ ],\n+ *     \"write_metadata_only\" : true,\n+ *     \"write_log_diffs\" : false,\n+ *     \"write_watched_indices\" : [ ],\n+ *     \"write_ignore_users\" : [ ]\n+ *   }\n+ * }\n  */\n public class AuditConfig {\n \n-    public static final List<String> DEFAULT_IGNORED_USERS = Collections.singletonList(\"kibanaserver\");\n+    private static final Set<String> DEFAULT_IGNORED_USERS = Collections.singleton(\"kibanaserver\");\n+    private static final EnumSet<AuditCategory> DEFAULT_DISABLED_CATEGORIES = EnumSet.of(\n+            AuditCategory.AUTHENTICATED, AuditCategory.GRANTED_PRIVILEGES);\n+\n+    @JsonProperty(value = Key.ENABLED)\n+    private boolean auditLogEnabled = true;\n+    @JsonProperty(value = Key.AUDIT)\n+    private Filter filter = new Filter();\n+    @JsonProperty(value = Key.COMPLIANCE)\n+    private Compliance compliance = new Compliance();\n+\n+    @JsonIgnore\n+    public boolean isEnabled() {\n+        return auditLogEnabled;\n+    }\n+\n+    @JsonIgnore\n+    public void setEnabled(boolean auditLogEnabled) {\n+        this.auditLogEnabled = auditLogEnabled;\n+    }\n+\n+    @JsonIgnore\n+    public Filter getFilter() {\n+        return filter;\n+    }\n \n-    private AuditConfig() { }\n+    @JsonProperty(value = Key.AUDIT)\n+    public void setFilter(Filter filter) {\n+        this.filter = filter;\n+    }\n+\n+    @JsonIgnore\n+    public Compliance getCompliance() {\n+        return compliance;\n+    }\n+\n+    @JsonProperty(value = Key.COMPLIANCE)\n+    public void setCompliance(Compliance compliance) {\n+        this.compliance = compliance;\n+    }\n \n     /**\n      * Filter represents set of filtering configuration settings for audit logging.\n      * Audit logger will use these settings to determine what audit logs are to be generated.\n      */\n     public static class Filter {\n-        private static final List<String> DEFAULT_DISABLED_CATEGORIES =\n-                Arrays.asList(AuditCategory.AUTHENTICATED.toString(),\n-                        AuditCategory.GRANTED_PRIVILEGES.toString());\n-\n-        private final boolean isRestApiAuditEnabled;\n-        private final boolean isTransportApiAuditEnabled;\n-        private final boolean resolveBulkRequests;\n-        private final boolean logRequestBody;\n-        private final boolean resolveIndices;\n-        private final boolean excludeSensitiveHeaders;\n-        private final WildcardMatcher ignoredAuditUsersMatcher;\n-        private final WildcardMatcher ignoredAuditRequestsMatcher;\n-        private final EnumSet<AuditCategory> disabledRestCategories;\n-        private final EnumSet<AuditCategory> disabledTransportCategories;\n-\n-        private Filter(final boolean isRestApiAuditEnabled,\n-                       final boolean isTransportApiAuditEnabled,\n-                       final boolean resolveBulkRequests,\n-                       final boolean logRequestBody,\n-                       final boolean resolveIndices,\n-                       final boolean excludeSensitiveHeaders,\n-                       final Set<String> ignoredAuditUsers,\n-                       final Set<String> ignoredAuditRequests,\n-                       final EnumSet<AuditCategory> disabledRestCategories,\n-                       final EnumSet<AuditCategory> disabledTransportCategories) {\n-            this.isRestApiAuditEnabled = isRestApiAuditEnabled;\n-            this.isTransportApiAuditEnabled = isTransportApiAuditEnabled;\n-            this.resolveBulkRequests = resolveBulkRequests;\n-            this.logRequestBody = logRequestBody;\n-            this.resolveIndices = resolveIndices;\n-            this.excludeSensitiveHeaders = excludeSensitiveHeaders;\n-            this.ignoredAuditUsersMatcher = WildcardMatcher.from(ignoredAuditUsers);\n-            this.ignoredAuditRequestsMatcher = WildcardMatcher.from(ignoredAuditRequests);\n-            this.disabledRestCategories = disabledRestCategories;\n-            this.disabledTransportCategories = disabledTransportCategories;\n-        }\n-\n-        /**\n-         * Generate audit logging configuration from settings defined in elasticsearch.yml\n-         * @param settings settings\n-         * @return audit configuration filter\n-         */\n-        public static Filter from(Settings settings) {\n-            final boolean isRestApiAuditEnabled = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ENABLE_REST, true);\n-            final boolean isTransportAuditEnabled = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ENABLE_TRANSPORT, true);\n-            final boolean resolveBulkRequests = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_RESOLVE_BULK_REQUESTS, false);\n-            final boolean logRequestBody = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_LOG_REQUEST_BODY, true);\n-            final boolean resolveIndices = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_RESOLVE_INDICES, true);\n-            final boolean excludeSensitiveHeaders = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_EXCLUDE_SENSITIVE_HEADERS, true);\n-\n-            final EnumSet<AuditCategory> disabledRestCategories = AuditCategory.parse(getSettingAsSet(\n-                    settings,\n-                    ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DISABLED_REST_CATEGORIES,\n-                    DEFAULT_DISABLED_CATEGORIES,\n-                    true));\n-\n-            final EnumSet<AuditCategory> disabledTransportCategories = AuditCategory.parse(getSettingAsSet(\n-                    settings,\n-                    ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DISABLED_TRANSPORT_CATEGORIES,\n-                    DEFAULT_DISABLED_CATEGORIES,\n-                    true));\n-\n-            final Set<String> ignoredAuditUsers = getSettingAsSet(\n-                    settings,\n-                    ConfigConstants.OPENDISTRO_SECURITY_AUDIT_IGNORE_USERS,\n-                    DEFAULT_IGNORED_USERS,\n-                    false);\n-\n-            final Set<String> ignoreAuditRequests = ImmutableSet.copyOf(settings.getAsList(\n-                    ConfigConstants.OPENDISTRO_SECURITY_AUDIT_IGNORE_REQUESTS,\n-                    Collections.emptyList()));\n-\n-            return new Filter(isRestApiAuditEnabled,\n-                    isTransportAuditEnabled,\n-                    resolveBulkRequests,\n-                    logRequestBody,\n-                    resolveIndices,\n-                    excludeSensitiveHeaders,\n-                    ignoredAuditUsers,\n-                    ignoreAuditRequests,\n-                    disabledRestCategories,\n-                    disabledTransportCategories);\n-        }\n+        @JsonProperty(value = Key.ENABLE_REST)\n+        private boolean isRestApiAuditEnabled = true;\n+        @JsonProperty(value = Key.DISABLED_REST_CATEGORIES)\n+        private EnumSet<AuditCategory> disabledRestCategories = DEFAULT_DISABLED_CATEGORIES;\n+        @JsonProperty(value = Key.ENABLE_TRANSPORT)\n+        private boolean isTransportApiAuditEnabled = true;\n+        @JsonProperty(value = Key.DISABLED_TRANSPORT_CATEGORIES)\n+        private EnumSet<AuditCategory> disabledTransportCategories = DEFAULT_DISABLED_CATEGORIES;\n+        @JsonProperty(value = Key.RESOLVE_BULK_REQUESTS)\n+        private boolean resolveBulkRequests = false;\n+        @JsonProperty(value = Key.LOG_REQUEST_BODY)\n+        private boolean logRequestBody = true;\n+        @JsonProperty(value = Key.RESOLVE_INDICES)\n+        private boolean resolveIndices = true;\n+        @JsonProperty(value = Key.EXCLUDE_SENSITIVE_HEADERS)\n+        private boolean excludeSensitiveHeaders = true;\n+        @JsonProperty(value = Key.IGNORE_USERS)\n+        private Set<String> ignoredAuditUsers = DEFAULT_IGNORED_USERS;\n+        @JsonProperty(value = Key.IGNORE_REQUESTS)\n+        private Set<String> ignoreAuditRequests = Collections.emptySet();\n+\n+        @JsonIgnore\n+        private WildcardMatcher ignoredAuditUsersMatcher;\n+        @JsonIgnore\n+        private WildcardMatcher ignoredAuditRequestsMatcher;\n \n         /**\n          * Checks if auditing for REST API is enabled or disabled\n          * @return true/false\n          */\n+        @JsonIgnore\n         public boolean isRestApiAuditEnabled() {\n             return isRestApiAuditEnabled;\n         }\n \n+        /**\n+         * Enable or disable REST API auditing\n+         * @param enableRest true/false\n+         */\n+        @JsonIgnore\n+        public void setRestApiAuditEnabled(boolean enableRest) {\n+            this.isRestApiAuditEnabled = enableRest;\n+        }\n+\n+        /**\n+         * Disabled categories for REST API auditing\n+         * @return set of categories\n+         */\n+        @JsonIgnore\n+        public EnumSet<AuditCategory> getDisabledRestCategories() {\n+            return disabledRestCategories;\n+        }\n+\n+        /**\n+         * Set categories to ignore REST API auditing\n+         * @param disabledRestCategories categories\n+         */\n+        @JsonSetter(value = Key.DISABLED_REST_CATEGORIES, nulls = Nulls.AS_EMPTY)\n+        public void setDisabledRestCategories(Set<AuditCategory> disabledRestCategories) {\n+            if (disabledRestCategories != null && !disabledRestCategories.isEmpty()) {\n+                if (disabledRestCategories instanceof EnumSet) {\n+                    this.disabledRestCategories = (EnumSet) disabledRestCategories;\n+                } else {\n+                    this.disabledRestCategories = EnumSet.copyOf(disabledRestCategories);\n+                }\n+            } else {\n+                this.disabledRestCategories = EnumSet.noneOf(AuditCategory.class);\n+            }\n+        }\n+\n         /**\n          * Checks if auditing for Transport API is enabled or disabled\n          * @return true/false\n          */\n+        @JsonIgnore\n         public boolean isTransportApiAuditEnabled() {\n             return isTransportApiAuditEnabled;\n         }\n \n         /**\n-         * Checks if bulk requests must be resolved during auditing\n+         * Enable or disable Transport API auditing\n+         * @param enableTransport true/false\n+         */\n+        @JsonIgnore\n+        public void setTransportApiAuditEnabled(boolean enableTransport) {\n+            this.isTransportApiAuditEnabled = enableTransport;\n+        }\n+\n+        /**\n+         * Disabled categories for Transport API auditing\n+         * @return set of categories\n+         */\n+        @JsonIgnore\n+        public EnumSet<AuditCategory> getDisabledTransportCategories() {\n+            return disabledTransportCategories;\n+        }\n+\n+        /**\n+         *  Set categories to ignore Transport API auditing\n+         * @param disabledTransportCategories categories\n+         */\n+        @JsonSetter(value = Key.DISABLED_TRANSPORT_CATEGORIES, nulls = Nulls.AS_EMPTY)\n+        public void setDisabledTransportCategories(Set<AuditCategory> disabledTransportCategories) {\n+            if (disabledTransportCategories != null && !disabledTransportCategories.isEmpty()) {\n+                if (disabledTransportCategories instanceof EnumSet) {\n+                    this.disabledTransportCategories = (EnumSet) disabledTransportCategories;\n+                } else {\n+                    this.disabledTransportCategories = EnumSet.copyOf(disabledTransportCategories);\n+                }\n+            } else {\n+                this.disabledTransportCategories = EnumSet.noneOf(AuditCategory.class);\n+            }\n+        }\n+\n+        /**\n+         * Check if bulk requests must be resolved during auditing\n          * @return true/false\n          */\n+        @JsonIgnore\n         public boolean shouldResolveBulkRequests() {\n             return resolveBulkRequests;\n         }\n \n+        /**\n+         * Set if bulk requests must be resolved during auditing\n+         * @param resolveBulkRequests true/false\n+         */\n+        @JsonIgnore\n+        public void setResolveBulkRequests(boolean resolveBulkRequests) {\n+            this.resolveBulkRequests = resolveBulkRequests;\n+        }\n+\n         /**\n          * Checks if request body must be logged\n          * @return true/false\n          */\n+        @JsonIgnore\n         public boolean shouldLogRequestBody() {\n             return logRequestBody;\n         }\n \n+        /**\n+         * Set if request body must be logged\n+         * @param logRequestBody true/false\n+         */\n+        @JsonIgnore\n+        public void setLogRequestBody(boolean logRequestBody) {\n+            this.logRequestBody = logRequestBody;\n+        }\n+\n         /**\n          * Check if indices must be resolved during auditing\n          * @return true/false\n          */\n+        @JsonIgnore\n         public boolean shouldResolveIndices() {\n             return resolveIndices;\n         }\n \n         /**\n-         * Checks if sensitive headers eg: Authorization must be excluded in log messages\n+         * Set if indices must be resolved during auditing\n+         * @param resolveIndices true/false\n+         */\n+        @JsonIgnore\n+        public void setResolveIndices(boolean resolveIndices) {\n+            this.resolveIndices = resolveIndices;\n+        }\n+\n+        /**\n+         * Checks if sensitive headers eg: Authorization must be excluded in audit log messages\n          * @return true/false\n          */\n+        @JsonIgnore\n         public boolean shouldExcludeSensitiveHeaders() {\n             return excludeSensitiveHeaders;\n         }\n \n+        /**\n+         * Set  if sensitive headers must be excluded from audit log messages\n+         * @param excludeSensitiveHeaders true/false\n+         */\n+        @JsonIgnore\n+        public void setExcludeSensitiveHeaders(boolean excludeSensitiveHeaders) {\n+            this.excludeSensitiveHeaders = excludeSensitiveHeaders;\n+        }\n+\n+        /**\n+         * Get users for whom auditing must be ignored.\n+         * @return set of users\n+         */\n+        @JsonIgnore\n+        public Set<String> getIgnoredAuditUsers() {\n+            return ignoredAuditUsers;\n+        }\n+\n+        /**\n+         * Set of users for whom auditing must be ignored.\n+         * @param ignoreUsers users\n+         */\n+        @JsonSetter(value = Key.IGNORE_USERS, nulls = Nulls.AS_EMPTY)\n+        public void setIgnoreUsers(Set<String> ignoreUsers) {\n+            if (ignoreUsers != null) {\n+                this.ignoredAuditUsers = ignoreUsers;\n+            } else {\n+                this.ignoredAuditUsers = Collections.emptySet();\n+            }\n+            ignoredAuditUsersMatcher = WildcardMatcher.from(this.ignoredAuditUsers);", "originalCommit": "0428f4e7cccd5a45593d185f723a226d0e575683", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1NjU5NQ==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447956595", "bodyText": "please add sample in YML", "author": "hardik-k-shah", "createdAt": "2020-06-30T20:23:14Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/config/AuditConfig.java", "diffHunk": "@@ -1,167 +1,363 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *  You may not use this file except in compliance with the License.\n+ *  A copy of the License is located at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed\n+ *  on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n package com.amazon.opendistroforelasticsearch.security.auditlog.config;\n \n import com.amazon.opendistroforelasticsearch.security.auditlog.impl.AuditCategory;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n-\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSetter;\n+import com.fasterxml.jackson.annotation.Nulls;\n import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.settings.Settings;\n \n import java.util.Arrays;\n import java.util.Collections;\n import java.util.EnumSet;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n+import java.util.stream.Collectors;\n \n /**\n  * Class represents configuration for audit logging.\n+ * Expected class structure\n+ * {\n+ *   \"enabled\": true,\n+ *   \"audit\" : {\n+ *     \"enable_rest\" : true,\n+ *     \"disabled_rest_categories\" : [\n+ *       \"GRANTED_PRIVILEGES\",\n+ *       \"SSL_EXCEPTION\"\n+ *     ],\n+ *     \"enable_transport\" : true,\n+ *     \"disabled_transport_categories\" : [\n+ *       \"GRANTED_PRIVILEGES\",\n+ *       \"AUTHENTICATED\"\n+ *     ],\n+ *     \"resolve_bulk_requests\" : false,\n+ *     \"log_request_body\" : true,\n+ *     \"resolve_indices\" : true,\n+ *     \"exclude_sensitive_headers\" : true,\n+ *     \"ignore_users\" : [\n+ *       \"kibanaserver\"\n+ *     ],\n+ *     \"ignore_requests\" : [ ]\n+ *   },\n+ *   \"compliance\" : {\n+ *     \"enabled\": true,\n+ *     \"internal_config\" : true,\n+ *     \"external_config\" : true,\n+ *     \"read_metadata_only\" : true,\n+ *     \"read_watched_fields\" : { },\n+ *     \"read_ignore_users\" : [ ],\n+ *     \"write_metadata_only\" : true,\n+ *     \"write_log_diffs\" : false,\n+ *     \"write_watched_indices\" : [ ],\n+ *     \"write_ignore_users\" : [ ]\n+ *   }\n+ * }\n  */\n public class AuditConfig {\n \n-    public static final List<String> DEFAULT_IGNORED_USERS = Collections.singletonList(\"kibanaserver\");\n+    private static final Set<String> DEFAULT_IGNORED_USERS = Collections.singleton(\"kibanaserver\");\n+    private static final EnumSet<AuditCategory> DEFAULT_DISABLED_CATEGORIES = EnumSet.of(\n+            AuditCategory.AUTHENTICATED, AuditCategory.GRANTED_PRIVILEGES);\n+\n+    @JsonProperty(value = Key.ENABLED)\n+    private boolean auditLogEnabled = true;\n+    @JsonProperty(value = Key.AUDIT)\n+    private Filter filter = new Filter();\n+    @JsonProperty(value = Key.COMPLIANCE)\n+    private Compliance compliance = new Compliance();\n+\n+    @JsonIgnore\n+    public boolean isEnabled() {\n+        return auditLogEnabled;\n+    }\n+\n+    @JsonIgnore\n+    public void setEnabled(boolean auditLogEnabled) {\n+        this.auditLogEnabled = auditLogEnabled;\n+    }\n+\n+    @JsonIgnore\n+    public Filter getFilter() {\n+        return filter;\n+    }\n \n-    private AuditConfig() { }\n+    @JsonProperty(value = Key.AUDIT)\n+    public void setFilter(Filter filter) {\n+        this.filter = filter;\n+    }\n+\n+    @JsonIgnore\n+    public Compliance getCompliance() {\n+        return compliance;\n+    }\n+\n+    @JsonProperty(value = Key.COMPLIANCE)\n+    public void setCompliance(Compliance compliance) {\n+        this.compliance = compliance;\n+    }\n \n     /**\n      * Filter represents set of filtering configuration settings for audit logging.\n      * Audit logger will use these settings to determine what audit logs are to be generated.\n      */\n     public static class Filter {\n-        private static final List<String> DEFAULT_DISABLED_CATEGORIES =\n-                Arrays.asList(AuditCategory.AUTHENTICATED.toString(),\n-                        AuditCategory.GRANTED_PRIVILEGES.toString());\n-\n-        private final boolean isRestApiAuditEnabled;\n-        private final boolean isTransportApiAuditEnabled;\n-        private final boolean resolveBulkRequests;\n-        private final boolean logRequestBody;\n-        private final boolean resolveIndices;\n-        private final boolean excludeSensitiveHeaders;\n-        private final WildcardMatcher ignoredAuditUsersMatcher;\n-        private final WildcardMatcher ignoredAuditRequestsMatcher;\n-        private final EnumSet<AuditCategory> disabledRestCategories;\n-        private final EnumSet<AuditCategory> disabledTransportCategories;\n-\n-        private Filter(final boolean isRestApiAuditEnabled,\n-                       final boolean isTransportApiAuditEnabled,\n-                       final boolean resolveBulkRequests,\n-                       final boolean logRequestBody,\n-                       final boolean resolveIndices,\n-                       final boolean excludeSensitiveHeaders,\n-                       final Set<String> ignoredAuditUsers,\n-                       final Set<String> ignoredAuditRequests,\n-                       final EnumSet<AuditCategory> disabledRestCategories,\n-                       final EnumSet<AuditCategory> disabledTransportCategories) {\n-            this.isRestApiAuditEnabled = isRestApiAuditEnabled;\n-            this.isTransportApiAuditEnabled = isTransportApiAuditEnabled;\n-            this.resolveBulkRequests = resolveBulkRequests;\n-            this.logRequestBody = logRequestBody;\n-            this.resolveIndices = resolveIndices;\n-            this.excludeSensitiveHeaders = excludeSensitiveHeaders;\n-            this.ignoredAuditUsersMatcher = WildcardMatcher.from(ignoredAuditUsers);\n-            this.ignoredAuditRequestsMatcher = WildcardMatcher.from(ignoredAuditRequests);\n-            this.disabledRestCategories = disabledRestCategories;\n-            this.disabledTransportCategories = disabledTransportCategories;\n-        }\n-\n-        /**\n-         * Generate audit logging configuration from settings defined in elasticsearch.yml\n-         * @param settings settings\n-         * @return audit configuration filter\n-         */\n-        public static Filter from(Settings settings) {\n-            final boolean isRestApiAuditEnabled = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ENABLE_REST, true);\n-            final boolean isTransportAuditEnabled = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ENABLE_TRANSPORT, true);\n-            final boolean resolveBulkRequests = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_RESOLVE_BULK_REQUESTS, false);\n-            final boolean logRequestBody = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_LOG_REQUEST_BODY, true);\n-            final boolean resolveIndices = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_RESOLVE_INDICES, true);\n-            final boolean excludeSensitiveHeaders = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_EXCLUDE_SENSITIVE_HEADERS, true);\n-\n-            final EnumSet<AuditCategory> disabledRestCategories = AuditCategory.parse(getSettingAsSet(\n-                    settings,\n-                    ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DISABLED_REST_CATEGORIES,\n-                    DEFAULT_DISABLED_CATEGORIES,\n-                    true));\n-\n-            final EnumSet<AuditCategory> disabledTransportCategories = AuditCategory.parse(getSettingAsSet(\n-                    settings,\n-                    ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DISABLED_TRANSPORT_CATEGORIES,\n-                    DEFAULT_DISABLED_CATEGORIES,\n-                    true));\n-\n-            final Set<String> ignoredAuditUsers = getSettingAsSet(\n-                    settings,\n-                    ConfigConstants.OPENDISTRO_SECURITY_AUDIT_IGNORE_USERS,\n-                    DEFAULT_IGNORED_USERS,\n-                    false);\n-\n-            final Set<String> ignoreAuditRequests = ImmutableSet.copyOf(settings.getAsList(\n-                    ConfigConstants.OPENDISTRO_SECURITY_AUDIT_IGNORE_REQUESTS,\n-                    Collections.emptyList()));\n-\n-            return new Filter(isRestApiAuditEnabled,\n-                    isTransportAuditEnabled,\n-                    resolveBulkRequests,\n-                    logRequestBody,\n-                    resolveIndices,\n-                    excludeSensitiveHeaders,\n-                    ignoredAuditUsers,\n-                    ignoreAuditRequests,\n-                    disabledRestCategories,\n-                    disabledTransportCategories);\n-        }\n+        @JsonProperty(value = Key.ENABLE_REST)\n+        private boolean isRestApiAuditEnabled = true;\n+        @JsonProperty(value = Key.DISABLED_REST_CATEGORIES)\n+        private EnumSet<AuditCategory> disabledRestCategories = DEFAULT_DISABLED_CATEGORIES;\n+        @JsonProperty(value = Key.ENABLE_TRANSPORT)\n+        private boolean isTransportApiAuditEnabled = true;\n+        @JsonProperty(value = Key.DISABLED_TRANSPORT_CATEGORIES)\n+        private EnumSet<AuditCategory> disabledTransportCategories = DEFAULT_DISABLED_CATEGORIES;\n+        @JsonProperty(value = Key.RESOLVE_BULK_REQUESTS)\n+        private boolean resolveBulkRequests = false;\n+        @JsonProperty(value = Key.LOG_REQUEST_BODY)\n+        private boolean logRequestBody = true;\n+        @JsonProperty(value = Key.RESOLVE_INDICES)\n+        private boolean resolveIndices = true;\n+        @JsonProperty(value = Key.EXCLUDE_SENSITIVE_HEADERS)\n+        private boolean excludeSensitiveHeaders = true;\n+        @JsonProperty(value = Key.IGNORE_USERS)\n+        private Set<String> ignoredAuditUsers = DEFAULT_IGNORED_USERS;\n+        @JsonProperty(value = Key.IGNORE_REQUESTS)\n+        private Set<String> ignoreAuditRequests = Collections.emptySet();\n+\n+        @JsonIgnore\n+        private WildcardMatcher ignoredAuditUsersMatcher;\n+        @JsonIgnore\n+        private WildcardMatcher ignoredAuditRequestsMatcher;\n \n         /**\n          * Checks if auditing for REST API is enabled or disabled\n          * @return true/false\n          */\n+        @JsonIgnore\n         public boolean isRestApiAuditEnabled() {\n             return isRestApiAuditEnabled;\n         }\n \n+        /**\n+         * Enable or disable REST API auditing\n+         * @param enableRest true/false\n+         */\n+        @JsonIgnore\n+        public void setRestApiAuditEnabled(boolean enableRest) {\n+            this.isRestApiAuditEnabled = enableRest;\n+        }\n+\n+        /**\n+         * Disabled categories for REST API auditing\n+         * @return set of categories\n+         */\n+        @JsonIgnore\n+        public EnumSet<AuditCategory> getDisabledRestCategories() {\n+            return disabledRestCategories;\n+        }\n+\n+        /**\n+         * Set categories to ignore REST API auditing\n+         * @param disabledRestCategories categories\n+         */\n+        @JsonSetter(value = Key.DISABLED_REST_CATEGORIES, nulls = Nulls.AS_EMPTY)\n+        public void setDisabledRestCategories(Set<AuditCategory> disabledRestCategories) {\n+            if (disabledRestCategories != null && !disabledRestCategories.isEmpty()) {\n+                if (disabledRestCategories instanceof EnumSet) {\n+                    this.disabledRestCategories = (EnumSet) disabledRestCategories;\n+                } else {\n+                    this.disabledRestCategories = EnumSet.copyOf(disabledRestCategories);\n+                }\n+            } else {\n+                this.disabledRestCategories = EnumSet.noneOf(AuditCategory.class);\n+            }\n+        }\n+\n         /**\n          * Checks if auditing for Transport API is enabled or disabled\n          * @return true/false\n          */\n+        @JsonIgnore\n         public boolean isTransportApiAuditEnabled() {\n             return isTransportApiAuditEnabled;\n         }\n \n         /**\n-         * Checks if bulk requests must be resolved during auditing\n+         * Enable or disable Transport API auditing\n+         * @param enableTransport true/false\n+         */\n+        @JsonIgnore\n+        public void setTransportApiAuditEnabled(boolean enableTransport) {\n+            this.isTransportApiAuditEnabled = enableTransport;\n+        }\n+\n+        /**\n+         * Disabled categories for Transport API auditing\n+         * @return set of categories\n+         */\n+        @JsonIgnore\n+        public EnumSet<AuditCategory> getDisabledTransportCategories() {\n+            return disabledTransportCategories;\n+        }\n+\n+        /**\n+         *  Set categories to ignore Transport API auditing\n+         * @param disabledTransportCategories categories\n+         */\n+        @JsonSetter(value = Key.DISABLED_TRANSPORT_CATEGORIES, nulls = Nulls.AS_EMPTY)\n+        public void setDisabledTransportCategories(Set<AuditCategory> disabledTransportCategories) {\n+            if (disabledTransportCategories != null && !disabledTransportCategories.isEmpty()) {\n+                if (disabledTransportCategories instanceof EnumSet) {\n+                    this.disabledTransportCategories = (EnumSet) disabledTransportCategories;\n+                } else {\n+                    this.disabledTransportCategories = EnumSet.copyOf(disabledTransportCategories);\n+                }\n+            } else {\n+                this.disabledTransportCategories = EnumSet.noneOf(AuditCategory.class);\n+            }\n+        }\n+\n+        /**\n+         * Check if bulk requests must be resolved during auditing\n          * @return true/false\n          */\n+        @JsonIgnore\n         public boolean shouldResolveBulkRequests() {\n             return resolveBulkRequests;\n         }\n \n+        /**\n+         * Set if bulk requests must be resolved during auditing\n+         * @param resolveBulkRequests true/false\n+         */\n+        @JsonIgnore\n+        public void setResolveBulkRequests(boolean resolveBulkRequests) {\n+            this.resolveBulkRequests = resolveBulkRequests;\n+        }\n+\n         /**\n          * Checks if request body must be logged\n          * @return true/false\n          */\n+        @JsonIgnore\n         public boolean shouldLogRequestBody() {\n             return logRequestBody;\n         }\n \n+        /**\n+         * Set if request body must be logged\n+         * @param logRequestBody true/false\n+         */\n+        @JsonIgnore\n+        public void setLogRequestBody(boolean logRequestBody) {\n+            this.logRequestBody = logRequestBody;\n+        }\n+\n         /**\n          * Check if indices must be resolved during auditing\n          * @return true/false\n          */\n+        @JsonIgnore\n         public boolean shouldResolveIndices() {\n             return resolveIndices;\n         }\n \n         /**\n-         * Checks if sensitive headers eg: Authorization must be excluded in log messages\n+         * Set if indices must be resolved during auditing\n+         * @param resolveIndices true/false\n+         */\n+        @JsonIgnore\n+        public void setResolveIndices(boolean resolveIndices) {\n+            this.resolveIndices = resolveIndices;\n+        }\n+\n+        /**\n+         * Checks if sensitive headers eg: Authorization must be excluded in audit log messages\n          * @return true/false\n          */\n+        @JsonIgnore\n         public boolean shouldExcludeSensitiveHeaders() {\n             return excludeSensitiveHeaders;\n         }\n \n+        /**\n+         * Set  if sensitive headers must be excluded from audit log messages\n+         * @param excludeSensitiveHeaders true/false\n+         */\n+        @JsonIgnore\n+        public void setExcludeSensitiveHeaders(boolean excludeSensitiveHeaders) {\n+            this.excludeSensitiveHeaders = excludeSensitiveHeaders;\n+        }\n+\n+        /**\n+         * Get users for whom auditing must be ignored.\n+         * @return set of users\n+         */\n+        @JsonIgnore\n+        public Set<String> getIgnoredAuditUsers() {\n+            return ignoredAuditUsers;\n+        }\n+\n+        /**\n+         * Set of users for whom auditing must be ignored.\n+         * @param ignoreUsers users\n+         */\n+        @JsonSetter(value = Key.IGNORE_USERS, nulls = Nulls.AS_EMPTY)\n+        public void setIgnoreUsers(Set<String> ignoreUsers) {\n+            if (ignoreUsers != null) {\n+                this.ignoredAuditUsers = ignoreUsers;\n+            } else {\n+                this.ignoredAuditUsers = Collections.emptySet();\n+            }\n+            ignoredAuditUsersMatcher = WildcardMatcher.from(this.ignoredAuditUsers);\n+        }\n+\n+        /**\n+         * Request patterns that must be ignored.\n+         * @return set of request patterns\n+         */\n+        @JsonIgnore\n+        public Set<String> getIgnoredAuditRequests() {\n+            return ignoreAuditRequests;\n+        }\n+\n+        /**\n+         * Set requests to be ignored using api auditing\n+         * @param ignoreRequests request patterns\n+         */\n+        @JsonSetter(value = Key.IGNORE_REQUESTS, nulls = Nulls.AS_EMPTY)\n+        public void setIgnoreRequests(Set<String> ignoreRequests) {\n+            if (ignoreRequests != null) {\n+                this.ignoreAuditRequests = ignoreRequests;\n+            } else {\n+                this.ignoreAuditRequests = Collections.emptySet();\n+            }\n+            ignoredAuditRequestsMatcher = WildcardMatcher.from(this.ignoreAuditRequests);", "originalCommit": "0428f4e7cccd5a45593d185f723a226d0e575683", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1NzU2Nw==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447957567", "bodyText": "Are we setting default to true?", "author": "hardik-k-shah", "createdAt": "2020-06-30T20:25:05Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/config/AuditConfig.java", "diffHunk": "@@ -214,31 +397,368 @@ public void log(Logger logger) {\n             logger.info(\"Bulk requests resolution is {} during request auditing.\", resolveBulkRequests ? \"enabled\" : \"disabled\");\n             logger.info(\"Index resolution is {} during request auditing.\", resolveIndices ? \"enabled\" : \"disabled\");\n             logger.info(\"Sensitive headers auditing is {}.\", excludeSensitiveHeaders ? \"enabled\" : \"disabled\");\n-            logger.info(\"Auditing requests from {} users is disabled.\", ignoredAuditUsersMatcher);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"Filter{\" +\n-                    \"isRestApiAuditEnabled=\" + isRestApiAuditEnabled +\n-                    \", disabledRestCategories=\" + disabledRestCategories +\n-                    \", isTransportApiAuditEnabled=\" + isTransportApiAuditEnabled +\n-                    \", disabledTransportCategories=\" + disabledTransportCategories +\n-                    \", resolveBulkRequests=\" + resolveBulkRequests +\n-                    \", logRequestBody=\" + logRequestBody +\n-                    \", resolveIndices=\" + resolveIndices +\n-                    \", excludeSensitiveHeaders=\" + excludeSensitiveHeaders +\n-                    \", ignoredAuditUsers=\" + ignoredAuditUsersMatcher +\n-                    \", ignoreAuditRequests=\" + ignoredAuditRequestsMatcher +\n-                    '}';\n+            logger.info(\"Auditing requests from {} users is disabled.\", ignoredAuditUsers);\n+        }\n+    }\n+\n+    public static class Compliance {\n+        @JsonProperty(value = Key.ENABLED)\n+        private boolean complianceEnabled = true;", "originalCommit": "0428f4e7cccd5a45593d185f723a226d0e575683", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0ODMxOA==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r448048318", "bodyText": "Current behavior is setting it to true always https://github.com/opendistro-for-elasticsearch/security/blob/master/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java#L84 . Will review the defaults once more", "author": "sujithvm", "createdAt": "2020-07-01T00:18:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1NzU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1NzkzNw==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r447957937", "bodyText": "Does internalConfig is for logging changes to security index?\nIncluding audit logging config / cert Dn hot-reloading changes along with user/action/roles/role-mapping ?", "author": "hardik-k-shah", "createdAt": "2020-06-30T20:25:52Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/config/AuditConfig.java", "diffHunk": "@@ -214,31 +397,368 @@ public void log(Logger logger) {\n             logger.info(\"Bulk requests resolution is {} during request auditing.\", resolveBulkRequests ? \"enabled\" : \"disabled\");\n             logger.info(\"Index resolution is {} during request auditing.\", resolveIndices ? \"enabled\" : \"disabled\");\n             logger.info(\"Sensitive headers auditing is {}.\", excludeSensitiveHeaders ? \"enabled\" : \"disabled\");\n-            logger.info(\"Auditing requests from {} users is disabled.\", ignoredAuditUsersMatcher);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"Filter{\" +\n-                    \"isRestApiAuditEnabled=\" + isRestApiAuditEnabled +\n-                    \", disabledRestCategories=\" + disabledRestCategories +\n-                    \", isTransportApiAuditEnabled=\" + isTransportApiAuditEnabled +\n-                    \", disabledTransportCategories=\" + disabledTransportCategories +\n-                    \", resolveBulkRequests=\" + resolveBulkRequests +\n-                    \", logRequestBody=\" + logRequestBody +\n-                    \", resolveIndices=\" + resolveIndices +\n-                    \", excludeSensitiveHeaders=\" + excludeSensitiveHeaders +\n-                    \", ignoredAuditUsers=\" + ignoredAuditUsersMatcher +\n-                    \", ignoreAuditRequests=\" + ignoredAuditRequestsMatcher +\n-                    '}';\n+            logger.info(\"Auditing requests from {} users is disabled.\", ignoredAuditUsers);\n+        }\n+    }\n+\n+    public static class Compliance {\n+        @JsonProperty(value = Key.ENABLED)\n+        private boolean complianceEnabled = true;\n+        @JsonProperty(value = Key.INTERNAL_CONFIG_ENABLED)\n+        private boolean internalConfigEnabled = true;", "originalCommit": "0428f4e7cccd5a45593d185f723a226d0e575683", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0ODgyMg==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r448048822", "bodyText": "Yes internal_config_enalbed logs changes to security index. Since audit logging is also stored in the index, changes will be logged. However if disabled then config changes are not recorded. Will whitelist to record audit config changes always.", "author": "sujithvm", "createdAt": "2020-07-01T00:20:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1NzkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQxOTYyMA==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r450419620", "bodyText": "Will whitelist to record audit config changes always. --> why do we need to do whitelist? We should not treat auditlogging config specially. It should be same as other user/action/roles/role-mapping, cert-Dn etc..\nIt should be enabled (Default: True) and customer should be able to disable if they want.", "author": "hardik-k-shah", "createdAt": "2020-07-06T18:57:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1NzkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAwMjQ1OA==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r448002458", "bodyText": "Should we support pattern for read and write ignore user as well?", "author": "hardik-k-shah", "createdAt": "2020-06-30T21:56:56Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/config/AuditConfig.java", "diffHunk": "@@ -214,31 +397,368 @@ public void log(Logger logger) {\n             logger.info(\"Bulk requests resolution is {} during request auditing.\", resolveBulkRequests ? \"enabled\" : \"disabled\");\n             logger.info(\"Index resolution is {} during request auditing.\", resolveIndices ? \"enabled\" : \"disabled\");\n             logger.info(\"Sensitive headers auditing is {}.\", excludeSensitiveHeaders ? \"enabled\" : \"disabled\");\n-            logger.info(\"Auditing requests from {} users is disabled.\", ignoredAuditUsersMatcher);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"Filter{\" +\n-                    \"isRestApiAuditEnabled=\" + isRestApiAuditEnabled +\n-                    \", disabledRestCategories=\" + disabledRestCategories +\n-                    \", isTransportApiAuditEnabled=\" + isTransportApiAuditEnabled +\n-                    \", disabledTransportCategories=\" + disabledTransportCategories +\n-                    \", resolveBulkRequests=\" + resolveBulkRequests +\n-                    \", logRequestBody=\" + logRequestBody +\n-                    \", resolveIndices=\" + resolveIndices +\n-                    \", excludeSensitiveHeaders=\" + excludeSensitiveHeaders +\n-                    \", ignoredAuditUsers=\" + ignoredAuditUsersMatcher +\n-                    \", ignoreAuditRequests=\" + ignoredAuditRequestsMatcher +\n-                    '}';\n+            logger.info(\"Auditing requests from {} users is disabled.\", ignoredAuditUsers);\n+        }\n+    }\n+\n+    public static class Compliance {\n+        @JsonProperty(value = Key.ENABLED)\n+        private boolean complianceEnabled = true;\n+        @JsonProperty(value = Key.INTERNAL_CONFIG_ENABLED)\n+        private boolean internalConfigEnabled = true;\n+        @JsonProperty(value = Key.EXTERNAL_CONFIG_ENABLED)\n+        private boolean externalConfigEnabled = false;\n+        @JsonProperty(value = Key.READ_METADATA_ONLY)\n+        private boolean readMetadataOnly = true;\n+        @JsonProperty(value = Key.READ_WATCHED_FIELDS)\n+        private Map<String, Set<String>> readWatchedFields = Collections.emptyMap();\n+        @JsonProperty(value = Key.READ_IGNORE_USERS)\n+        private Set<String> readIgnoreUsers = Collections.emptySet();\n+        @JsonProperty(value = Key.WRITE_METADATA_ONLY)\n+        private boolean writeMetadataOnly = true;\n+        @JsonProperty(value = Key.WRITE_LOG_DIFFS)\n+        private boolean writeLogDiffs = false;\n+        @JsonProperty(value = Key.WRITE_WATCHED_INDICES)\n+        private List<String> writeWatchedIndices = Collections.emptyList();\n+        @JsonProperty(value = Key.WRITE_IGNORE_USERS)\n+        private Set<String> writeIgnoreUsers = Collections.emptySet();\n+\n+        /**\n+         * Checks if compliance auditing is enabled\n+         * @return true/false\n+         */\n+        @JsonIgnore\n+        public boolean isComplianceEnabled() {\n+            return complianceEnabled;\n+        }\n+\n+        /**\n+         * Set whether to audit compliance events\n+         * @param complianceEnabled true/false\n+         */\n+        @JsonIgnore\n+        public void setComplianceEnabled(boolean complianceEnabled) {\n+            this.complianceEnabled = complianceEnabled;\n+        }\n+\n+        /**\n+         * Check if auditing of internal opendistro security index is enabled\n+         * @return true/false\n+         */\n+        @JsonIgnore\n+        public boolean isInternalConfigEnabled() {\n+            return internalConfigEnabled;\n+        }\n+\n+        /**\n+         * Set whether to audit internal opendistro security index\n+         * @param internalConfigEnabled true/false\n+         */\n+        @JsonIgnore\n+        public void setInternalConfigEnabled(boolean internalConfigEnabled) {\n+            this.internalConfigEnabled = internalConfigEnabled;\n+        }\n+\n+        /**\n+         * Checks if auditing of external configuration files is enabled\n+         * @return true/false\n+         */\n+        @JsonIgnore\n+        public boolean isExternalConfigEnabled() {\n+            return externalConfigEnabled;\n+        }\n+\n+        /**\n+         * Set whether to audit external configuration files\n+         * @param externalConfigEnabled true/false\n+         */\n+        @JsonIgnore\n+        public void setExternalConfigEnabled(boolean externalConfigEnabled) {\n+            this.externalConfigEnabled = externalConfigEnabled;\n+        }\n+\n+        /**\n+         * Checks if only metadata or field names are to be logged for doc read requests\n+         * @return true/false\n+         */\n+        @JsonIgnore\n+        public boolean isReadMetadataOnly() {\n+            return readMetadataOnly;\n+        }\n+\n+        /**\n+         * Set if only metadata or field names are to be logged for doc read requests\n+         * @param readMetadataOnly true/false\n+         */\n+        @JsonIgnore\n+        public void setReadMetadataOnly(boolean readMetadataOnly) {\n+            this.readMetadataOnly = readMetadataOnly;\n+        }\n+\n+        /**\n+         * Get list of fields to watch for, in a document in an index\n+         * @return index name mapped to a set of fields\n+         */\n+        @JsonIgnore\n+        public Map<String, Set<String>> getReadWatchedFields() {\n+            return readWatchedFields;\n+        }\n+\n+        /**\n+         * Set list of fields to watch for, in a document in an index\n+         * @param readWatchedFields index name mapped to a set of fields\n+         */\n+        @JsonSetter(value = Key.READ_WATCHED_FIELDS, nulls = Nulls.AS_EMPTY)\n+        public void setReadWatchedFields(Map<String, Set<String>> readWatchedFields) {\n+            if (readWatchedFields != null) {\n+                this.readWatchedFields = readWatchedFields;\n+            } else {\n+                this.readWatchedFields = Collections.emptyMap();\n+            }\n+        }\n+\n+        /**\n+         * Get users ignored for auditing doc read requests\n+         * @return set of ignored users\n+         */\n+        @JsonIgnore\n+        public Set<String> getReadIgnoreUsers() {\n+            return readIgnoreUsers;\n+        }\n+\n+        /**\n+         * Set users to be ignored for auditing doc read requests\n+         * @param readIgnoreUsers users\n+         */\n+        @JsonSetter(value = Key.READ_IGNORE_USERS, nulls = Nulls.AS_EMPTY)\n+        public void setReadIgnoreUsers(Set<String> readIgnoreUsers) {\n+            if (readIgnoreUsers != null) {\n+                this.readIgnoreUsers = readIgnoreUsers;", "originalCommit": "0428f4e7cccd5a45593d185f723a226d0e575683", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0ODk5NA==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r448048994", "bodyText": "Patterns are supported. May need rename the variable", "author": "sujithvm", "createdAt": "2020-07-01T00:20:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAwMjQ1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQyMDEyNg==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r450420126", "bodyText": "renaming is good. But I would also add comments/ sample in audit_logging sample YML file.", "author": "hardik-k-shah", "createdAt": "2020-07-06T18:58:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAwMjQ1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAwMjkwOA==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r448002908", "bodyText": "what about index pattern?", "author": "hardik-k-shah", "createdAt": "2020-06-30T21:58:04Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/config/AuditConfig.java", "diffHunk": "@@ -214,31 +397,368 @@ public void log(Logger logger) {\n             logger.info(\"Bulk requests resolution is {} during request auditing.\", resolveBulkRequests ? \"enabled\" : \"disabled\");\n             logger.info(\"Index resolution is {} during request auditing.\", resolveIndices ? \"enabled\" : \"disabled\");\n             logger.info(\"Sensitive headers auditing is {}.\", excludeSensitiveHeaders ? \"enabled\" : \"disabled\");\n-            logger.info(\"Auditing requests from {} users is disabled.\", ignoredAuditUsersMatcher);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"Filter{\" +\n-                    \"isRestApiAuditEnabled=\" + isRestApiAuditEnabled +\n-                    \", disabledRestCategories=\" + disabledRestCategories +\n-                    \", isTransportApiAuditEnabled=\" + isTransportApiAuditEnabled +\n-                    \", disabledTransportCategories=\" + disabledTransportCategories +\n-                    \", resolveBulkRequests=\" + resolveBulkRequests +\n-                    \", logRequestBody=\" + logRequestBody +\n-                    \", resolveIndices=\" + resolveIndices +\n-                    \", excludeSensitiveHeaders=\" + excludeSensitiveHeaders +\n-                    \", ignoredAuditUsers=\" + ignoredAuditUsersMatcher +\n-                    \", ignoreAuditRequests=\" + ignoredAuditRequestsMatcher +\n-                    '}';\n+            logger.info(\"Auditing requests from {} users is disabled.\", ignoredAuditUsers);\n+        }\n+    }\n+\n+    public static class Compliance {\n+        @JsonProperty(value = Key.ENABLED)\n+        private boolean complianceEnabled = true;\n+        @JsonProperty(value = Key.INTERNAL_CONFIG_ENABLED)\n+        private boolean internalConfigEnabled = true;\n+        @JsonProperty(value = Key.EXTERNAL_CONFIG_ENABLED)\n+        private boolean externalConfigEnabled = false;\n+        @JsonProperty(value = Key.READ_METADATA_ONLY)\n+        private boolean readMetadataOnly = true;\n+        @JsonProperty(value = Key.READ_WATCHED_FIELDS)\n+        private Map<String, Set<String>> readWatchedFields = Collections.emptyMap();\n+        @JsonProperty(value = Key.READ_IGNORE_USERS)\n+        private Set<String> readIgnoreUsers = Collections.emptySet();\n+        @JsonProperty(value = Key.WRITE_METADATA_ONLY)\n+        private boolean writeMetadataOnly = true;\n+        @JsonProperty(value = Key.WRITE_LOG_DIFFS)\n+        private boolean writeLogDiffs = false;\n+        @JsonProperty(value = Key.WRITE_WATCHED_INDICES)\n+        private List<String> writeWatchedIndices = Collections.emptyList();\n+        @JsonProperty(value = Key.WRITE_IGNORE_USERS)\n+        private Set<String> writeIgnoreUsers = Collections.emptySet();\n+\n+        /**\n+         * Checks if compliance auditing is enabled\n+         * @return true/false\n+         */\n+        @JsonIgnore\n+        public boolean isComplianceEnabled() {\n+            return complianceEnabled;\n+        }\n+\n+        /**\n+         * Set whether to audit compliance events\n+         * @param complianceEnabled true/false\n+         */\n+        @JsonIgnore\n+        public void setComplianceEnabled(boolean complianceEnabled) {\n+            this.complianceEnabled = complianceEnabled;\n+        }\n+\n+        /**\n+         * Check if auditing of internal opendistro security index is enabled\n+         * @return true/false\n+         */\n+        @JsonIgnore\n+        public boolean isInternalConfigEnabled() {\n+            return internalConfigEnabled;\n+        }\n+\n+        /**\n+         * Set whether to audit internal opendistro security index\n+         * @param internalConfigEnabled true/false\n+         */\n+        @JsonIgnore\n+        public void setInternalConfigEnabled(boolean internalConfigEnabled) {\n+            this.internalConfigEnabled = internalConfigEnabled;\n+        }\n+\n+        /**\n+         * Checks if auditing of external configuration files is enabled\n+         * @return true/false\n+         */\n+        @JsonIgnore\n+        public boolean isExternalConfigEnabled() {\n+            return externalConfigEnabled;\n+        }\n+\n+        /**\n+         * Set whether to audit external configuration files\n+         * @param externalConfigEnabled true/false\n+         */\n+        @JsonIgnore\n+        public void setExternalConfigEnabled(boolean externalConfigEnabled) {\n+            this.externalConfigEnabled = externalConfigEnabled;\n+        }\n+\n+        /**\n+         * Checks if only metadata or field names are to be logged for doc read requests\n+         * @return true/false\n+         */\n+        @JsonIgnore\n+        public boolean isReadMetadataOnly() {\n+            return readMetadataOnly;\n+        }\n+\n+        /**\n+         * Set if only metadata or field names are to be logged for doc read requests\n+         * @param readMetadataOnly true/false\n+         */\n+        @JsonIgnore\n+        public void setReadMetadataOnly(boolean readMetadataOnly) {\n+            this.readMetadataOnly = readMetadataOnly;\n+        }\n+\n+        /**\n+         * Get list of fields to watch for, in a document in an index\n+         * @return index name mapped to a set of fields\n+         */\n+        @JsonIgnore\n+        public Map<String, Set<String>> getReadWatchedFields() {\n+            return readWatchedFields;\n+        }\n+\n+        /**\n+         * Set list of fields to watch for, in a document in an index\n+         * @param readWatchedFields index name mapped to a set of fields\n+         */\n+        @JsonSetter(value = Key.READ_WATCHED_FIELDS, nulls = Nulls.AS_EMPTY)\n+        public void setReadWatchedFields(Map<String, Set<String>> readWatchedFields) {\n+            if (readWatchedFields != null) {\n+                this.readWatchedFields = readWatchedFields;\n+            } else {\n+                this.readWatchedFields = Collections.emptyMap();\n+            }\n+        }\n+\n+        /**\n+         * Get users ignored for auditing doc read requests\n+         * @return set of ignored users\n+         */\n+        @JsonIgnore\n+        public Set<String> getReadIgnoreUsers() {\n+            return readIgnoreUsers;\n+        }\n+\n+        /**\n+         * Set users to be ignored for auditing doc read requests\n+         * @param readIgnoreUsers users\n+         */\n+        @JsonSetter(value = Key.READ_IGNORE_USERS, nulls = Nulls.AS_EMPTY)\n+        public void setReadIgnoreUsers(Set<String> readIgnoreUsers) {\n+            if (readIgnoreUsers != null) {\n+                this.readIgnoreUsers = readIgnoreUsers;\n+            } else {\n+                this.readIgnoreUsers = Collections.emptySet();\n+            }\n         }\n+\n+        /**\n+         * Checks if only metadata or field names are to be logged for doc write requests\n+         * @return true/false\n+         */\n+        @JsonIgnore\n+        public boolean isWriteMetadataOnly() {\n+            return writeMetadataOnly;\n+        }\n+\n+        /**\n+         * Set whether to log only metadata for doc write requests\n+         * @param writeMetadataOnly true/false\n+         */\n+        @JsonIgnore\n+        public void setWriteMetadataOnly(boolean writeMetadataOnly) {\n+            this.writeMetadataOnly = writeMetadataOnly;\n+        }\n+\n+        /**\n+         * Checks if only diffs are to be logged for doc write requests\n+         * @return true/false\n+         */\n+        @JsonIgnore\n+        public boolean isWriteLogDiffs() {\n+            return writeLogDiffs;\n+        }\n+\n+        /**\n+         * Set whether to log only diffs for doc write requests\n+         * @param writeLogDiffs true/false\n+         */\n+        @JsonIgnore\n+        public void setWriteLogDiffs(boolean writeLogDiffs) {\n+            this.writeLogDiffs = writeLogDiffs;\n+        }\n+\n+        /**\n+         * Get list of indices to watch for doc write requests\n+         * @return indices\n+         */\n+        @JsonIgnore\n+        public List<String> getWriteWatchedIndices() {\n+            return writeWatchedIndices;\n+        }\n+\n+        /**\n+         * Set indices to watch for doc write requests\n+         * @param writeWatchedIndices indices\n+         */\n+        @JsonSetter(value = Key.WRITE_WATCHED_INDICES, nulls = Nulls.AS_EMPTY)\n+        public void setWriteWatchedIndices(List<String> writeWatchedIndices) {\n+            if (writeWatchedIndices != null) {\n+                this.writeWatchedIndices = writeWatchedIndices;", "originalCommit": "0428f4e7cccd5a45593d185f723a226d0e575683", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0OTI5NA==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r448049294", "bodyText": "Index patterns are supported. May need to rename the variable", "author": "sujithvm", "createdAt": "2020-07-01T00:22:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAwMjkwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU1ODgzOQ==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r450558839", "bodyText": "Resolved with #542", "author": "sujithvm", "createdAt": "2020-07-07T01:17:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAwMjkwOA=="}], "type": "inlineReview"}, {"oid": "10a0364651675214231d1a9da7f803a8fa091be1", "url": "https://github.com/opensearch-project/security/commit/10a0364651675214231d1a9da7f803a8fa091be1", "message": "Update REST permission info", "committedDate": "2020-07-06T08:05:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQzOTAzMg==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r450439032", "bodyText": "Why we need this?\nShould we also log internalConfig ?\nwhat about logging external/internal config changes for \"onAuditConfigFilterChanged\" ?", "author": "hardik-k-shah", "createdAt": "2020-07-06T19:37:41Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/impl/AbstractAuditLog.java", "diffHunk": "@@ -98,22 +103,26 @@\n         writeClasses.add(DeleteRequest.class.getSimpleName());\n     }\n \n-    protected AbstractAuditLog(Settings settings, final ThreadPool threadPool, final IndexNameExpressionResolver resolver, final ClusterService clusterService, final boolean dlsFlsAvailable) {\n+    protected AbstractAuditLog(Settings settings, final ThreadPool threadPool, final IndexNameExpressionResolver resolver, final ClusterService clusterService, final Environment environment) {\n         super();\n         this.threadPool = threadPool;\n         this.settings = settings;\n         this.resolver = resolver;\n         this.clusterService = clusterService;\n-        this.auditConfigFilter = AuditConfig.Filter.from(settings);\n-        this.auditConfigFilter.log(log);\n         this.opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n-        if (dlsFlsAvailable) {\n-            this.complianceConfig = ComplianceConfig.from(settings);\n-            this.complianceConfig.log(log);\n-        } else {\n-            this.complianceConfig = null;\n-            log.debug(\"Compliance config is null because DLS-FLS is not available.\");\n-        }\n+        this.environment = environment;\n+    }\n+\n+    protected void onAuditConfigFilterChanged(AuditConfig.Filter auditConfigFilter) {\n+        this.auditConfigFilter = auditConfigFilter;\n+        this.auditConfigFilter.log(log);\n+    }\n+\n+    protected void onComplianceConfigChanged(ComplianceConfig complianceConfig) {\n+        this.complianceConfig = complianceConfig;\n+        enableRoutes();\n+        this.complianceConfig.log(log);\n+        logExternalConfig();", "originalCommit": "10a0364651675214231d1a9da7f803a8fa091be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwNzQxMQ==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r450507411", "bodyText": "Lets add comments why this is the right place for logExternalConfig?", "author": "hardik-k-shah", "createdAt": "2020-07-06T22:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQzOTAzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ0MjI1Mg==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r450442252", "bodyText": "Why do we depend on dlsFls?", "author": "hardik-k-shah", "createdAt": "2020-07-06T19:44:40Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/impl/AuditLogImpl.java", "diffHunk": "@@ -40,31 +41,43 @@\n import org.elasticsearch.transport.TransportRequest;\n \n import com.amazon.opendistroforelasticsearch.security.auditlog.routing.AuditMessageRouter;\n+import org.greenrobot.eventbus.Subscribe;\n \n public final class AuditLogImpl extends AbstractAuditLog {\n \n \tprivate final AuditMessageRouter messageRouter;\n-\tprivate final boolean enabled;\n-\n-\tAuditLogImpl(final Settings settings, final Path configPath, Client clientProvider, ThreadPool threadPool,\n-\t\t\t\t final IndexNameExpressionResolver resolver, final ClusterService clusterService) {\n-\t\tthis(settings, configPath, clientProvider, threadPool, resolver, clusterService, false);\n-\t}\n-\n-\tpublic AuditLogImpl(final Settings settings, final Path configPath, Client clientProvider, ThreadPool threadPool,\n-\t\t\t\t\t\tfinal IndexNameExpressionResolver resolver, final ClusterService clusterService, final boolean dlsFlsAvailable) {\n-\t\tsuper(settings, threadPool, resolver, clusterService, dlsFlsAvailable);\n-\n-\t\tthis.messageRouter = new AuditMessageRouter(settings, clientProvider, threadPool, configPath);\n-\t\tthis.enabled = messageRouter.isEnabled();\n-\t\tif (enabled) {\n-\t\t\tComplianceConfig complianceConfig = getComplianceConfig();\n-\t\t\tif (complianceConfig != null && complianceConfig.isEnabled()) {\n-\t\t\t\tmessageRouter.enableRoutes(settings);\n-\t\t\t}\n+\tprivate final Settings settings;\n+\tprivate final boolean dlsFlsAvailable;\n+\tprivate final boolean messageRouterEnabled;\n+\tprivate volatile boolean enabled;\n+\n+\tpublic AuditLogImpl(final Settings settings,\n+\t\t\tfinal Path configPath,\n+\t\t\tfinal Client clientProvider,\n+\t\t\tfinal ThreadPool threadPool,\n+\t\t\tfinal IndexNameExpressionResolver resolver,\n+\t\t\tfinal ClusterService clusterService) {\n+\t\tthis(settings, configPath, clientProvider, threadPool, resolver, clusterService, null, true);\n+\t}\n+\n+\tpublic AuditLogImpl(final Settings settings,\n+\t\t\t\t\t\tfinal Path configPath,\n+\t\t\t\t\t\tfinal Client clientProvider,\n+\t\t\t\t\t\tfinal ThreadPool threadPool,\n+\t\t\t\t\t\tfinal IndexNameExpressionResolver resolver,\n+\t\t\t\t\t\tfinal ClusterService clusterService,\n+\t\t\t\t\t\tfinal Environment environment,\n+\t\t\t\t\t\tfinal boolean dlsFlsAvailable) {\n+\t\tsuper(settings, threadPool, resolver, clusterService, environment);\n+\t\tthis.settings = settings;\n+\t\tthis.dlsFlsAvailable = dlsFlsAvailable;\n+\t\tif (!dlsFlsAvailable) {", "originalCommit": "10a0364651675214231d1a9da7f803a8fa091be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwOTI3Nw==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r450509277", "bodyText": "enable/disable or SSLOnlyMode\nso lets raise separate PR to remove this flag", "author": "hardik-k-shah", "createdAt": "2020-07-06T22:20:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ0MjI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU1ODc1NQ==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r450558755", "bodyText": "https://github.com/opendistro-for-elasticsearch/security/issues/547", "author": "sujithvm", "createdAt": "2020-07-07T01:17:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ0MjI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU0ODM5NA==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r450548394", "bodyText": "Are we blocking all APIs including get?\nI thought get we are allowing and returning value of elasticsearch.yml", "author": "hardik-k-shah", "createdAt": "2020-07-07T00:35:02Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/dlic/rest/api/AuditApiAction.java", "diffHunk": "@@ -0,0 +1,185 @@\n+package com.amazon.opendistroforelasticsearch.security.dlic.rest.api;\n+\n+import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.configuration.ConfigurationRepository;\n+import com.amazon.opendistroforelasticsearch.security.dlic.rest.validation.AbstractConfigurationValidator;\n+import com.amazon.opendistroforelasticsearch.security.dlic.rest.validation.AuditValidator;\n+import com.amazon.opendistroforelasticsearch.security.privileges.PrivilegesEvaluator;\n+import com.amazon.opendistroforelasticsearch.security.securityconf.impl.CType;\n+import com.amazon.opendistroforelasticsearch.security.ssl.transport.PrincipalExtractor;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.ImmutableList;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+/**\n+ * Rest handler for fetching and updating audit configuration.\n+ * Supported REST endpoints\n+ * GET _opendistro/_security/api/audit/\n+ * {\n+ *   \"config\" : {\n+ *     \"audit\" : {\n+ *       \"enable_rest\" : true,\n+ *       \"disabled_rest_categories\" : [\n+ *         \"GRANTED_PRIVILEGES\",\n+ *         \"SSL_EXCEPTION\"\n+ *       ],\n+ *       \"enable_transport\" : true,\n+ *       \"disabled_transport_categories\" : [\n+ *         \"GRANTED_PRIVILEGES\",\n+ *         \"AUTHENTICATED\"\n+ *       ],\n+ *       \"resolve_bulk_requests\" : false,\n+ *       \"log_request_body\" : true,\n+ *       \"resolve_indices\" : true,\n+ *       \"exclude_sensitive_headers\" : true,\n+ *       \"ignore_users\" : [\n+ *         \"kibanaserver\"\n+ *       ],\n+ *       \"ignore_requests\" : [ ]\n+ *     },\n+ *     \"compliance\" : {\n+ *       \"internal_config\" : true,\n+ *       \"external_config\" : true,\n+ *       \"read_metadata_only\" : true,\n+ *       \"read_watched_fields\" : { },\n+ *       \"read_ignore_users\" : [ ],\n+ *       \"write_metadata_only\" : true,\n+ *       \"write_log_diffs\" : false,\n+ *       \"write_watched_indices\" : [ ],\n+ *       \"write_ignore_users\" : [ ]\n+ *     }\n+ *   }\n+ * }\n+ *\n+ * PUT _opendistro/_security/api/audit/config\n+ * {\n+ *   \"audit\":{\n+ *     \"enable_rest\":true,\n+ *     \"disabled_rest_categories\":[\n+ *       \"GRANTED_PRIVILEGES\",\n+ *       \"SSL_EXCEPTION\"\n+ *     ],\n+ *     \"enable_transport\":true,\n+ *     \"disabled_transport_categories\":[\n+ *       \"GRANTED_PRIVILEGES\",\n+ *       \"AUTHENTICATED\"\n+ *     ],\n+ *     \"resolve_bulk_requests\":false,\n+ *     \"log_request_body\":true,\n+ *     \"resolve_indices\":true,\n+ *     \"exclude_sensitive_headers\":true,\n+ *     \"ignore_users\":[ ],\n+ *     \"ignore_requests\":[ ]\n+ *   },\n+ *   \"compliance\":{\n+ *     \"internal_config\":true,\n+ *     \"external_config\":true,\n+ *     \"read_metadata_only\":true,\n+ *     \"read_watched_fields\":{ },\n+ *     \"read_ignore_users\":[ ],\n+ *     \"write_metadata_only\":true,\n+ *     \"write_log_diffs\":false,\n+ *     \"write_watched_indices\":[ ],\n+ *     \"write_ignore_users\":[ ]\n+ *   }\n+ * }\n+ *\n+ * PATCH _opendistro/_security/api/audit\n+ * [{\"op\": \"replace\", \"path\": \"/config/audit/enable_rest\", \"value\": \"true\"}]\n+ * [{\"op\": \"replace\", \"path\": \"/config/compliance/internal_config\", \"value\": \"true\"}]\n+ */\n+public class AuditApiAction extends PatchableResourceApiAction {\n+    private static final List<Route> routes = ImmutableList.of(\n+            new Route(RestRequest.Method.GET, \"/_opendistro/_security/api/audit/\"),\n+            new Route(RestRequest.Method.PUT, \"/_opendistro/_security/api/audit/{name}\"),\n+            new Route(RestRequest.Method.PATCH, \"/_opendistro/_security/api/audit/\")\n+    );\n+\n+    private static final String RESOURCE_NAME = \"config\";\n+    private final PrivilegesEvaluator privilegesEvaluator;\n+    private final ThreadContext threadContext;\n+\n+    public AuditApiAction(final Settings settings,\n+                          final Path configPath,\n+                          final RestController controller,\n+                          final Client client,\n+                          final AdminDNs adminDNs,\n+                          final ConfigurationRepository cl,\n+                          final ClusterService cs,\n+                          final PrincipalExtractor principalExtractor,\n+                          final PrivilegesEvaluator privilegesEvaluator,\n+                          final ThreadPool threadPool,\n+                          final AuditLog auditLog) {\n+        super(settings, configPath, controller, client, adminDNs, cl, cs, principalExtractor, privilegesEvaluator, threadPool, auditLog);\n+        this.privilegesEvaluator = privilegesEvaluator;\n+        this.threadContext = threadPool.getThreadContext();\n+    }\n+\n+    @Override\n+    public List<Route> routes() {\n+        return routes;\n+    }\n+\n+    @Override\n+    protected void handleApiRequest(final RestChannel channel, final RestRequest request, final Client client) throws IOException {\n+        // if audit config doc is not available in security index,\n+        // disable audit APIs\n+        if (!cl.isAuditHotReloadingEnabled()) {", "originalCommit": "10a0364651675214231d1a9da7f803a8fa091be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU1ODM1MQ==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r450558351", "bodyText": "Yes. We blocking all APIs including GET. Thought that there is no usage for GET as well if the hot-reloading is disabled. However this can be changed. Do you want to return the elasticsearch.yml settings ?", "author": "sujithvm", "createdAt": "2020-07-07T01:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU0ODM5NA=="}], "type": "inlineReview"}, {"oid": "3f82e54f60cf1d736c4fff932fb590d1e369c4d6", "url": "https://github.com/opensearch-project/security/commit/3f82e54f60cf1d736c4fff932fb590d1e369c4d6", "message": "code review", "committedDate": "2020-07-07T02:28:50Z", "type": "commit"}, {"oid": "ac02a9d956be93961b849527306e9a19af4a3538", "url": "https://github.com/opensearch-project/security/commit/ac02a9d956be93961b849527306e9a19af4a3538", "message": "Merge remote-tracking branch 'upstream/master' into auditlog", "committedDate": "2020-07-07T02:37:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4Mjk1MA==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r450582950", "bodyText": "And externalConfig parameter can be hot-reloadable which will impact functionality of \"logExternalConfig()\"", "author": "hardik-k-shah", "createdAt": "2020-07-07T02:51:55Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/impl/AbstractAuditLog.java", "diffHunk": "@@ -122,6 +122,8 @@ protected void onComplianceConfigChanged(ComplianceConfig complianceConfig) {\n         this.complianceConfig = complianceConfig;\n         enableRoutes();\n         this.complianceConfig.log(log);\n+        // External config is audit logged only once per node start and config from index is not available at that time.\n+        // The audit event will be created only if enabled and not already logged.", "originalCommit": "3f82e54f60cf1d736c4fff932fb590d1e369c4d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5bf5be4b35184edf13331b7d9aec5611ad1bfd67", "url": "https://github.com/opensearch-project/security/commit/5bf5be4b35184edf13331b7d9aec5611ad1bfd67", "message": "Serialize", "committedDate": "2020-07-07T04:52:48Z", "type": "commit"}, {"oid": "cdfc2819e3a280d44d43164fa395c4a7985655d3", "url": "https://github.com/opensearch-project/security/commit/cdfc2819e3a280d44d43164fa395c4a7985655d3", "message": "Merge remote-tracking branch 'upstream/master' into auditlog", "committedDate": "2020-07-07T05:11:55Z", "type": "commit"}, {"oid": "c0a9f1f3df69f06ed8f8cf4df0da14114b146b03", "url": "https://github.com/opensearch-project/security/commit/c0a9f1f3df69f06ed8f8cf4df0da14114b146b03", "message": "code review", "committedDate": "2020-07-07T05:18:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYxOTA4Mg==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r450619082", "bodyText": "Duplicate import. Please check merge.", "author": "vrozov", "createdAt": "2020-07-07T05:28:40Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/config/AuditConfig.java", "diffHunk": "@@ -17,6 +18,9 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static com.amazon.opendistroforelasticsearch.security.DefaultObjectMapper.getOrDefault;", "originalCommit": "c0a9f1f3df69f06ed8f8cf4df0da14114b146b03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY0MjUzNA==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r450642534", "bodyText": "Duplicate import removed", "author": "sujithvm", "createdAt": "2020-07-07T06:41:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYxOTA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYxOTM0MA==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r450619340", "bodyText": "nit: add new line.", "author": "vrozov", "createdAt": "2020-07-07T05:29:28Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/config/AuditConfig.java", "diffHunk": "@@ -340,4 +344,36 @@ public String toString() {\n                     '}';\n         }\n     }\n-}\n+\n+    /**\n+     * List of keys that are deprecated\n+     */\n+    public static final List<String> DEPRECATED_KEYS = ImmutableList.of(\n+            ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ENABLE_REST,\n+            ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DISABLED_REST_CATEGORIES,\n+            ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ENABLE_TRANSPORT,\n+            ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DISABLED_TRANSPORT_CATEGORIES,\n+            ConfigConstants.OPENDISTRO_SECURITY_AUDIT_LOG_REQUEST_BODY,\n+            ConfigConstants.OPENDISTRO_SECURITY_AUDIT_RESOLVE_INDICES,\n+            ConfigConstants.OPENDISTRO_SECURITY_AUDIT_EXCLUDE_SENSITIVE_HEADERS,\n+            ConfigConstants.OPENDISTRO_SECURITY_AUDIT_RESOLVE_BULK_REQUESTS,\n+            ConfigConstants.OPENDISTRO_SECURITY_AUDIT_IGNORE_USERS,\n+            ConfigConstants.OPENDISTRO_SECURITY_AUDIT_IGNORE_REQUESTS,\n+            ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED,\n+            ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED,\n+            ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY,\n+            ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_IGNORE_USERS,\n+            ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n+            ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY,\n+            ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS,\n+            ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_IGNORE_USERS,\n+            ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES\n+    );\n+\n+    public static Set<String> getDeprecatedKeys(final Settings settings) {\n+        return AuditConfig.DEPRECATED_KEYS\n+                .stream()\n+                .filter(settings::hasValue)\n+                .collect(Collectors.toSet());\n+    }\n+}", "originalCommit": "c0a9f1f3df69f06ed8f8cf4df0da14114b146b03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "39ad3d24eccac5e5221a3058d561bcf3afa46f25", "url": "https://github.com/opensearch-project/security/commit/39ad3d24eccac5e5221a3058d561bcf3afa46f25", "message": "add newlines", "committedDate": "2020-07-07T05:30:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyMjE1Mg==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r450622152", "bodyText": "it can be kept private", "author": "vrozov", "createdAt": "2020-07-07T05:40:03Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/config/AuditConfig.java", "diffHunk": "@@ -105,7 +109,7 @@ public static AuditConfig from(final Settings settings) {\n      * Audit logger will use these settings to determine what audit logs are to be generated.\n      */\n     public static class Filter {\n-        private static final Filter DEFAULT = Filter.from(Settings.EMPTY);\n+        public static final Filter DEFAULT = Filter.from(Settings.EMPTY);", "originalCommit": "c0a9f1f3df69f06ed8f8cf4df0da14114b146b03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY0MzA4Ng==", "url": "https://github.com/opensearch-project/security/pull/409#discussion_r450643086", "bodyText": "Made it visible for testing as one of the tests is using it", "author": "sujithvm", "createdAt": "2020-07-07T06:42:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyMjE1Mg=="}], "type": "inlineReview"}, {"oid": "73f9611f251332e0d51e06b036722ffe9a90bc59", "url": "https://github.com/opensearch-project/security/commit/73f9611f251332e0d51e06b036722ffe9a90bc59", "message": "Fix tests", "committedDate": "2020-07-07T07:28:22Z", "type": "commit"}]}