{"pr_number": 2125, "pr_title": "Provides tests suite to expose onDiscard leaks and fixes", "pr_createdAt": "2020-04-20T15:59:14Z", "pr_url": "https://github.com/reactor/reactor-core/pull/2125", "timeline": [{"oid": "6660f9916877fe6eb2970a1682a5bf3ac58cb2ca", "url": "https://github.com/reactor/reactor-core/commit/6660f9916877fe6eb2970a1682a5bf3ac58cb2ca", "message": "provides tests suite to expose onDiscard leaks and fixes\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>", "committedDate": "2020-04-20T16:19:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU1MTIwOA==", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r411551208", "bodyText": "if possible (depends on whether or not future test cases will absolutely need the whole array of publishers in a single array variable), I would suggest the following signature:\nprotected abstract Publisher<Tracked<?>> transform(TestPublisher<Tracked<?>> firstUpstream, TestPublisher<Tracked<?>>... otherUpstreams);", "author": "simonbasle", "createdAt": "2020-04-20T17:16:07Z", "path": "reactor-core/src/test/java/reactor/core/publisher/AbstractOnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -40,7 +42,7 @@ public AbstractOnDiscardShouldNotLeakTest(boolean conditional, boolean fused) {\n         this.fused = fused;\n     }\n \n-    abstract Flux<Tracked<?>> transform(Flux<Tracked<?>> upstream);\n+    protected abstract Publisher<Tracked<?>> transform(TestPublisher<Tracked<?>>... upstreams);", "originalCommit": "2f486cbf4dd08af2af6082292bd0e0fbd1defe38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9e5fc611146ba3103fa21467b050fdf9a42a4c46", "url": "https://github.com/reactor/reactor-core/commit/9e5fc611146ba3103fa21467b050fdf9a42a4c46", "message": "migrates to TestPublisher\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>", "committedDate": "2020-04-20T17:17:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA3OTE4MQ==", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412079181", "bodyText": "should be in try {} finally {} to avoid a leak", "author": "bsideup", "createdAt": "2020-04-21T10:50:04Z", "path": "reactor-core/src/test/java/reactor/core/publisher/AbstractOnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -0,0 +1,443 @@\n+package reactor.core.publisher;\n+\n+import org.assertj.core.api.Assertions;\n+import org.assertj.core.api.Assumptions;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.reactivestreams.Publisher;\n+import reactor.core.Fuseable;\n+import reactor.core.Scannable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.test.publisher.TestPublisher;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.test.util.RaceTestUtils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+@RunWith(Parameterized.class)\n+public abstract class AbstractOnDiscardShouldNotLeakTest {\n+\n+    @Parameterized.Parameters\n+    public static Collection<Boolean[]> data() {\n+        return Arrays.asList(new Boolean[][] {\n+            { false, false },\n+            { true, false },\n+            { false, true },\n+            { true, true }\n+        });\n+    }\n+\n+    private final boolean conditional;\n+    private final boolean fused;\n+\n+    public AbstractOnDiscardShouldNotLeakTest(boolean conditional, boolean fused) {\n+        this.conditional = conditional;\n+        this.fused = fused;\n+    }\n+\n+    protected abstract Publisher<Tracked<?>> transform(TestPublisher<Tracked<?>> main, TestPublisher<Tracked<?>>... additional);\n+\n+    int subscriptionsNumber() {\n+        return 1;\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        Hooks.resetOnNextDropped();\n+        Hooks.resetOnErrorDropped();\n+        Hooks.resetOnNextError();\n+        Hooks.resetOnOperatorError();\n+    }\n+\n+    @Test\n+    public void ensureMultipleSubscribersSupportWithNoLeaksWhenRacingCancelAndOnNextAndRequest() {\n+        Hooks.onNextDropped(Tracked::safeRelease);\n+        Hooks.onErrorDropped(e -> {});\n+        Hooks.onOperatorError((e,v) -> null);\n+        int subscriptionsNumber = subscriptionsNumber();\n+        Scheduler scheduler = Schedulers.newParallel(\"testScheduler\", subscriptionsNumber + 1);\n+        scheduler.start();\n+        for (int i = 0; i < 10000; i++) {\n+            int[] index = new int[] {subscriptionsNumber};\n+            TestPublisher<Tracked<?>>[] testPublishers = new TestPublisher[subscriptionsNumber];\n+\n+            for (int i1 = 0; i1 < subscriptionsNumber; i1++) {\n+                testPublishers[i1] = TestPublisher.createNoncompliant(TestPublisher.Violation.DEFER_CANCELLATION, TestPublisher.Violation.REQUEST_OVERFLOW);\n+            }\n+\n+            Publisher<Tracked<?>> source = transform(testPublishers[0], Arrays.copyOfRange(testPublishers, 1, testPublishers.length));\n+\n+            if (conditional) {\n+                if (source instanceof Flux) {\n+                    source = ((Flux<Tracked<?>>)source).filter(t -> true);\n+                } else {\n+                    source = ((Mono<Tracked<?>>)source).filter(t -> true);\n+                }\n+            }\n+\n+            AssertSubscriber<Tracked<?>> assertSubscriber = new AssertSubscriber<>(Operators.enableOnDiscard(null, Tracked::safeRelease), 0);\n+            if (fused) {\n+                assertSubscriber.requestedFusionMode(Fuseable.ANY);\n+            }\n+            source.subscribe(assertSubscriber);\n+\n+            if (subscriptionsNumber == 1) {\n+                Tracked<Integer> value = new Tracked<>(1);\n+                RaceTestUtils.race(() -> RaceTestUtils.race(assertSubscriber::cancel, () -> assertSubscriber.request(Long.MAX_VALUE), scheduler), () -> testPublishers[0].next(value), scheduler);\n+            } else {\n+                int startIndex = --index[0];\n+                Tracked<Integer> value1 = new Tracked<>(startIndex);\n+                int secondIndex = --index[0];\n+                Tracked<Integer> value2 = new Tracked<>(secondIndex);\n+                Runnable action = () -> RaceTestUtils.race(() -> testPublishers[startIndex].next(value1), () -> testPublishers[secondIndex].next(value2), scheduler);\n+\n+                while (index[0] > 0) {\n+                    int nextIndex = --index[0];\n+                    Tracked<Integer> nextValue = new Tracked<>(nextIndex);\n+                    Runnable nextAction = action;\n+                    action = () -> RaceTestUtils.race(nextAction, () -> testPublishers[nextIndex].next(nextValue), scheduler);\n+                }\n+                RaceTestUtils.race(() -> RaceTestUtils.race(assertSubscriber::cancel, () -> assertSubscriber.request(Long.MAX_VALUE), scheduler), action, scheduler);\n+            }\n+\n+            List<Tracked<?>> values = assertSubscriber.values();\n+            values.forEach(Tracked::release);\n+\n+            Tracked.assertNoLeaks();\n+        }\n+        scheduler.dispose();", "originalCommit": "e71d24ed008b177d3da03600fad3fa3e1a698e4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4NDY2MA==", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412084660", "bodyText": "Moved to a common field which setups @before each test and dispose in the @after method", "author": "OlegDokuka", "createdAt": "2020-04-21T10:58:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA3OTE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA3OTU1Mg==", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412079552", "bodyText": "this block seems to be repeated in tests, perhaps it can be reused", "author": "bsideup", "createdAt": "2020-04-21T10:50:43Z", "path": "reactor-core/src/test/java/reactor/core/publisher/AbstractOnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -0,0 +1,443 @@\n+package reactor.core.publisher;\n+\n+import org.assertj.core.api.Assertions;\n+import org.assertj.core.api.Assumptions;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.reactivestreams.Publisher;\n+import reactor.core.Fuseable;\n+import reactor.core.Scannable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.test.publisher.TestPublisher;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.test.util.RaceTestUtils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+@RunWith(Parameterized.class)\n+public abstract class AbstractOnDiscardShouldNotLeakTest {\n+\n+    @Parameterized.Parameters\n+    public static Collection<Boolean[]> data() {\n+        return Arrays.asList(new Boolean[][] {\n+            { false, false },\n+            { true, false },\n+            { false, true },\n+            { true, true }\n+        });\n+    }\n+\n+    private final boolean conditional;\n+    private final boolean fused;\n+\n+    public AbstractOnDiscardShouldNotLeakTest(boolean conditional, boolean fused) {\n+        this.conditional = conditional;\n+        this.fused = fused;\n+    }\n+\n+    protected abstract Publisher<Tracked<?>> transform(TestPublisher<Tracked<?>> main, TestPublisher<Tracked<?>>... additional);\n+\n+    int subscriptionsNumber() {\n+        return 1;\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        Hooks.resetOnNextDropped();\n+        Hooks.resetOnErrorDropped();\n+        Hooks.resetOnNextError();\n+        Hooks.resetOnOperatorError();\n+    }\n+\n+    @Test\n+    public void ensureMultipleSubscribersSupportWithNoLeaksWhenRacingCancelAndOnNextAndRequest() {\n+        Hooks.onNextDropped(Tracked::safeRelease);\n+        Hooks.onErrorDropped(e -> {});\n+        Hooks.onOperatorError((e,v) -> null);\n+        int subscriptionsNumber = subscriptionsNumber();\n+        Scheduler scheduler = Schedulers.newParallel(\"testScheduler\", subscriptionsNumber + 1);\n+        scheduler.start();\n+        for (int i = 0; i < 10000; i++) {\n+            int[] index = new int[] {subscriptionsNumber};\n+            TestPublisher<Tracked<?>>[] testPublishers = new TestPublisher[subscriptionsNumber];\n+\n+            for (int i1 = 0; i1 < subscriptionsNumber; i1++) {\n+                testPublishers[i1] = TestPublisher.createNoncompliant(TestPublisher.Violation.DEFER_CANCELLATION, TestPublisher.Violation.REQUEST_OVERFLOW);\n+            }\n+\n+            Publisher<Tracked<?>> source = transform(testPublishers[0], Arrays.copyOfRange(testPublishers, 1, testPublishers.length));\n+\n+            if (conditional) {\n+                if (source instanceof Flux) {\n+                    source = ((Flux<Tracked<?>>)source).filter(t -> true);\n+                } else {\n+                    source = ((Mono<Tracked<?>>)source).filter(t -> true);\n+                }\n+            }\n+\n+            AssertSubscriber<Tracked<?>> assertSubscriber = new AssertSubscriber<>(Operators.enableOnDiscard(null, Tracked::safeRelease), 0);\n+            if (fused) {\n+                assertSubscriber.requestedFusionMode(Fuseable.ANY);\n+            }\n+            source.subscribe(assertSubscriber);\n+\n+            if (subscriptionsNumber == 1) {\n+                Tracked<Integer> value = new Tracked<>(1);\n+                RaceTestUtils.race(() -> RaceTestUtils.race(assertSubscriber::cancel, () -> assertSubscriber.request(Long.MAX_VALUE), scheduler), () -> testPublishers[0].next(value), scheduler);\n+            } else {\n+                int startIndex = --index[0];\n+                Tracked<Integer> value1 = new Tracked<>(startIndex);\n+                int secondIndex = --index[0];\n+                Tracked<Integer> value2 = new Tracked<>(secondIndex);\n+                Runnable action = () -> RaceTestUtils.race(() -> testPublishers[startIndex].next(value1), () -> testPublishers[secondIndex].next(value2), scheduler);\n+\n+                while (index[0] > 0) {\n+                    int nextIndex = --index[0];\n+                    Tracked<Integer> nextValue = new Tracked<>(nextIndex);\n+                    Runnable nextAction = action;\n+                    action = () -> RaceTestUtils.race(nextAction, () -> testPublishers[nextIndex].next(nextValue), scheduler);\n+                }\n+                RaceTestUtils.race(() -> RaceTestUtils.race(assertSubscriber::cancel, () -> assertSubscriber.request(Long.MAX_VALUE), scheduler), action, scheduler);\n+            }\n+\n+            List<Tracked<?>> values = assertSubscriber.values();\n+            values.forEach(Tracked::release);\n+\n+            Tracked.assertNoLeaks();\n+        }\n+        scheduler.dispose();\n+    }\n+\n+    @Test\n+    public void ensureNoLeaksPopulatedQueueAndRacingCancelAndOnNext() {\n+        Assumptions.assumeThat(subscriptionsNumber())\n+                .isOne();\n+        Hooks.onNextDropped(Tracked::safeRelease);\n+        Hooks.onErrorDropped(e -> {});\n+        Hooks.onOperatorError((e,v) -> null);\n+        Scheduler scheduler = Schedulers.newParallel(\"testScheduler\", subscriptionsNumber() + 1);\n+        scheduler.start();", "originalCommit": "e71d24ed008b177d3da03600fad3fa3e1a698e4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4NDQ3OA==", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412084478", "bodyText": "Moved to a common field which setups @Before each test and dispose in the @After method", "author": "OlegDokuka", "createdAt": "2020-04-21T10:58:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA3OTU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4MDQ5MQ==", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412080491", "bodyText": "why not just changing the latch to new CountDownLatch(4) and output the current value if await fails?", "author": "bsideup", "createdAt": "2020-04-21T10:52:13Z", "path": "reactor-core/src/test/java/reactor/core/publisher/SerializedSubscriberTest.java", "diffHunk": "@@ -90,6 +90,9 @@ public void testLeakWithRetryWhenImmediatelyCancelled() throws InterruptedExcept\n \t\tAtomicInteger seen = new AtomicInteger();\n \n \t\tfinal CountDownLatch latch = new CountDownLatch(1);\n+\t\tfinal CountDownLatch latch1 = new CountDownLatch(1);", "originalCommit": "e71d24ed008b177d3da03600fad3fa3e1a698e4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4NDExNQ==", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412084115", "bodyText": "yeah. fixed", "author": "OlegDokuka", "createdAt": "2020-04-21T10:58:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4MDQ5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4MTEzMQ==", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412081131", "bodyText": "nit: looking at other similar tests, we could introduce AbstractFluxOnDiscardShouldNotLeakTest that defines transform(Flux, Flux)", "author": "bsideup", "createdAt": "2020-04-21T10:53:15Z", "path": "reactor-core/src/test/java/reactor/core/publisher/FluxFlatMapIterableOnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Publisher;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.util.Arrays;\n+\n+public class FluxFlatMapIterableOnDiscardShouldNotLeakTest extends AbstractOnDiscardShouldNotLeakTest {\n+\n+    public FluxFlatMapIterableOnDiscardShouldNotLeakTest(boolean conditional, boolean fused) {\n+        super(conditional, fused);\n+    }\n+\n+    @Override\n+    protected Publisher<Tracked<?>> transform(TestPublisher<Tracked<?>> main, TestPublisher<Tracked<?>>... additional) {\n+        return main", "originalCommit": "e71d24ed008b177d3da03600fad3fa3e1a698e4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4NDg0NQ==", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412084845", "bodyText": "Makes sense to do", "author": "OlegDokuka", "createdAt": "2020-04-21T10:59:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4MTEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4ODgxNg==", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412088816", "bodyText": "fixed", "author": "OlegDokuka", "createdAt": "2020-04-21T11:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4MTEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4MjAxNw==", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412082017", "bodyText": "Have you considered adding this to BaseOperatorTest instead?", "author": "bsideup", "createdAt": "2020-04-21T10:54:41Z", "path": "reactor-core/src/test/java/reactor/core/publisher/AbstractOnDiscardShouldNotLeakTest.java", "diffHunk": "@@ -0,0 +1,443 @@\n+package reactor.core.publisher;\n+\n+import org.assertj.core.api.Assertions;\n+import org.assertj.core.api.Assumptions;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.reactivestreams.Publisher;\n+import reactor.core.Fuseable;\n+import reactor.core.Scannable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.test.publisher.TestPublisher;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.test.util.RaceTestUtils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+@RunWith(Parameterized.class)\n+public abstract class AbstractOnDiscardShouldNotLeakTest {", "originalCommit": "e71d24ed008b177d3da03600fad3fa3e1a698e4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4NTQxNQ==", "url": "https://github.com/reactor/reactor-core/pull/2125#discussion_r412085415", "bodyText": "Yeah. I don't know how to use it properly, thus created an abstract class for simplicity at the first stage, but ready to optimize and make it extending BaseOperatorTest", "author": "OlegDokuka", "createdAt": "2020-04-21T11:00:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4MjAxNw=="}], "type": "inlineReview"}, {"oid": "5ec2f86c5e277fb9fe99427d54aa7c8030550b4b", "url": "https://github.com/reactor/reactor-core/commit/5ec2f86c5e277fb9fe99427d54aa7c8030550b4b", "message": "fixes AbstractFluxOnDiscardShouldNotLeakTest\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>", "committedDate": "2020-04-21T12:12:10Z", "type": "forcePushed"}, {"oid": "f6d476c9d1796d54de64c2429e24ec9f8fd7cfad", "url": "https://github.com/reactor/reactor-core/commit/f6d476c9d1796d54de64c2429e24ec9f8fd7cfad", "message": "fixes flakky test\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>", "committedDate": "2020-04-21T19:15:58Z", "type": "forcePushed"}, {"oid": "f7d300f8ed3bbaf97399e090d100cba626d2a97e", "url": "https://github.com/reactor/reactor-core/commit/f7d300f8ed3bbaf97399e090d100cba626d2a97e", "message": "ensures merge has enough sources\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>", "committedDate": "2020-04-22T11:51:40Z", "type": "forcePushed"}, {"oid": "028fc8110b7063bb647fa9121b5ca3229173ff96", "url": "https://github.com/reactor/reactor-core/commit/028fc8110b7063bb647fa9121b5ca3229173ff96", "message": "[test] Extract Tracked to MemoryUtils, add OffHeapDetector\n\nThe Tracked util introduced in #2125 has been moved into MemoryUtils and\nthe concern of tracking and asserting these objects has been split out\ninto the OffHeapDetector class, ensuring that even if a test fails,\nother tests that use Tracked won't be polluted due to an uncleaned\nshared queue.", "committedDate": "2020-04-22T12:38:56Z", "type": "forcePushed"}, {"oid": "6f261c53b99ef88180b08709ab3fe9429f60a814", "url": "https://github.com/reactor/reactor-core/commit/6f261c53b99ef88180b08709ab3fe9429f60a814", "message": "Fix some discard cases, provide cross-cutting discard test (#2125)\n\nThis commit fixes several operators handling of discard hooks in the\ncase of racing onNext and cancel (flatMap, flatMapIterable, publishOn,\nonBackpressureBuffer).\n\nAdditionally, it introduces a reusable test base for testing this\ncategory of discard cases.\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>", "committedDate": "2020-04-22T14:47:26Z", "type": "commit"}, {"oid": "c0c6f3b2df619b31ae48b8b4e033cd1e809123dd", "url": "https://github.com/reactor/reactor-core/commit/c0c6f3b2df619b31ae48b8b4e033cd1e809123dd", "message": "[test] Polish some flakky tests\n\nReviewed-in: #2125\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>", "committedDate": "2020-04-22T14:49:29Z", "type": "commit"}, {"oid": "dcdee8f76a6f95661277ff71cf41d5e97fbd06b5", "url": "https://github.com/reactor/reactor-core/commit/dcdee8f76a6f95661277ff71cf41d5e97fbd06b5", "message": "[Polish] Rework #2125 test cases into a single class\n\nThe abstract test class is replaced by a cross-cutting test class that\ncovers all relevant operators, which are provided as a collection of\nDiscardLeakScenarios. This allows to also test multiple variants of an\noperator without the need for one class per variant.\n\nThe tests have also been improved, with all hooks and schedulers setup\nand teardown done in the test lifecycle methods.", "committedDate": "2020-04-22T14:49:29Z", "type": "commit"}, {"oid": "3f44e262d26c70a33d05330849e406f132cc245e", "url": "https://github.com/reactor/reactor-core/commit/3f44e262d26c70a33d05330849e406f132cc245e", "message": "[test] Extract Tracked to MemoryUtils, add OffHeapDetector\n\nThe Tracked util introduced in #2125 has been moved into MemoryUtils and\nthe concern of tracking and asserting these objects has been split out\ninto the OffHeapDetector class, ensuring that even if a test fails,\nother tests that use Tracked won't be polluted due to an uncleaned\nshared queue.", "committedDate": "2020-04-22T14:49:29Z", "type": "commit"}, {"oid": "3f44e262d26c70a33d05330849e406f132cc245e", "url": "https://github.com/reactor/reactor-core/commit/3f44e262d26c70a33d05330849e406f132cc245e", "message": "[test] Extract Tracked to MemoryUtils, add OffHeapDetector\n\nThe Tracked util introduced in #2125 has been moved into MemoryUtils and\nthe concern of tracking and asserting these objects has been split out\ninto the OffHeapDetector class, ensuring that even if a test fails,\nother tests that use Tracked won't be polluted due to an uncleaned\nshared queue.", "committedDate": "2020-04-22T14:49:29Z", "type": "forcePushed"}]}