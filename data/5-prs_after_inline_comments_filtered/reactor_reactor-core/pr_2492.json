{"pr_number": 2492, "pr_title": "fix #2269 Add test util to capture logs in early-established loggers", "pr_createdAt": "2020-11-17T16:27:04Z", "pr_url": "https://github.com/reactor/reactor-core/pull/2492", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkzODUzNQ==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525938535", "bodyText": "since we don't need classWithLogger I'd remove that parameter here and in resetAppender. The class is public but in the /test sourceset so this shouldn't be an issue. (although the end goal is to make this part of reactor-test prod sourceset)", "author": "simonbasle", "createdAt": "2020-11-18T09:32:21Z", "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "diffHunk": "@@ -1,59 +1,208 @@\n package reactor.test;\n \n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n import ch.qos.logback.classic.Level;\n-import ch.qos.logback.classic.Logger;\n import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n import ch.qos.logback.classic.spi.ILoggingEvent;\n import ch.qos.logback.core.UnsynchronizedAppenderBase;\n-import org.slf4j.LoggerFactory;\n import reactor.test.util.TestLogger;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tstatic final String TEST_APPENDER_NAME = \"TestAppender\";\n+\tprivate static TestLogger testLogger;\n \n \tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tTestAppender appender = new TestAppender(testLogger);\n-\t\t\tappender.start();\n-\t\t\tlogbackLogger.addAppender(appender);\n-\t\t}\n+\t\tLoggerUtils.testLogger = testLogger;", "originalCommit": "065378d00adcd05262bafbdf6ed6ad8cdd5e094c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk2MDExOA==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525960118", "bodyText": "I think there is still value to provide a TestLogger as opposed to letting the method create one internally and return it. see comment about tuning logging levels.", "author": "simonbasle", "createdAt": "2020-11-18T10:03:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkzODUzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk0NjEwNA==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525946104", "bodyText": "rather than using reflexion maybe we should look into making Loggers return the previous factory ? or at least a Function<String, Logger> getCurrentFactory() getter?", "author": "simonbasle", "createdAt": "2020-11-18T09:43:45Z", "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "diffHunk": "@@ -1,59 +1,208 @@\n package reactor.test;\n \n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n import ch.qos.logback.classic.Level;\n-import ch.qos.logback.classic.Logger;\n import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n import ch.qos.logback.classic.spi.ILoggingEvent;\n import ch.qos.logback.core.UnsynchronizedAppenderBase;\n-import org.slf4j.LoggerFactory;\n import reactor.test.util.TestLogger;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tstatic final String TEST_APPENDER_NAME = \"TestAppender\";\n+\tprivate static TestLogger testLogger;\n \n \tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tTestAppender appender = new TestAppender(testLogger);\n-\t\t\tappender.start();\n-\t\t\tlogbackLogger.addAppender(appender);\n-\t\t}\n+\t\tLoggerUtils.testLogger = testLogger;\n \t}\n \n \tpublic static void resetAppender(Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tlogbackLogger.detachAppender(TEST_APPENDER_NAME);\n+\t\tLoggerUtils.testLogger = null;\n+\t}\n+\n+\tpublic static void installQueryableLogger() {\n+\t\tLoggers.resetLoggerFactory();", "originalCommit": "065378d00adcd05262bafbdf6ed6ad8cdd5e094c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1NDUwNg==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525954506", "bodyText": "another interesting feature that this opens up is to \"force\" a logging level via the TestLogger. This can be done in a separate issue, but if TestLogger was to have configurable loglevel, isXxxEnabled here could be an OR combination of the delegate and the root TestLogger. A special TestLogger subclass for the DivertingLogger could even have a Map<String, LogLevel> internally, to selectively filter out logs from some sources.", "author": "simonbasle", "createdAt": "2020-11-18T09:55:48Z", "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "diffHunk": "@@ -1,59 +1,208 @@\n package reactor.test;\n \n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n import ch.qos.logback.classic.Level;\n-import ch.qos.logback.classic.Logger;\n import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n import ch.qos.logback.classic.spi.ILoggingEvent;\n import ch.qos.logback.core.UnsynchronizedAppenderBase;\n-import org.slf4j.LoggerFactory;\n import reactor.test.util.TestLogger;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tstatic final String TEST_APPENDER_NAME = \"TestAppender\";\n+\tprivate static TestLogger testLogger;\n \n \tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tTestAppender appender = new TestAppender(testLogger);\n-\t\t\tappender.start();\n-\t\t\tlogbackLogger.addAppender(appender);\n-\t\t}\n+\t\tLoggerUtils.testLogger = testLogger;\n \t}\n \n \tpublic static void resetAppender(Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tlogbackLogger.detachAppender(TEST_APPENDER_NAME);\n+\t\tLoggerUtils.testLogger = null;\n+\t}\n+\n+\tpublic static void installQueryableLogger() {\n+\t\tLoggers.resetLoggerFactory();\n+\t\ttry {\n+\t\t\tField lfField = Loggers.class.getDeclaredField(\"LOGGER_FACTORY\");\n+\t\t\tlfField.setAccessible(true);\n+\t\t\tObject factoryObject = lfField.get(Loggers.class);\n+\t\t\tMethod factoryMethod = factoryObject.getClass().getMethod(\"getLogger\", String.class);\n+\t\t\tfactoryMethod.setAccessible(true);\n+\n+\t\t\tLoggers.useCustomLoggers(category -> {\n+\t\t\t\ttry {\n+\t\t\t\t\tLogger original = (Logger) factoryMethod.invoke(factoryObject, category);\n+\t\t\t\t\treturn new DivertingLogger(original);\n+\t\t\t\t}\n+\t\t\t\tcatch (IllegalAccessException | InvocationTargetException e) {\n+\t\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\tcatch (NoSuchFieldException | IllegalAccessException | NoSuchMethodException e) {\n+\t\t\tthrow new RuntimeException(\"Could not install custom logger\", e);\n \t\t}\n \t}\n \n-\tstatic class TestAppender extends UnsynchronizedAppenderBase<ILoggingEvent> {\n+\tprivate static class DivertingLogger implements reactor.util.Logger {\n+\n+\t\tprivate final reactor.util.Logger delegate;\n \n-\t\tprivate final TestLogger testLogger;\n-\t\tprivate final ThrowableProxyConverter throwableProxyConverter = new ThrowableProxyConverter();\n+\t\tprivate DivertingLogger(Logger delegate) {\n+\t\t\tthis.delegate = delegate;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getName() {\n+\t\t\treturn delegate.getName();\n+\t\t}\n \n-\t\tTestAppender(TestLogger testLogger) {\n-\t\t\tthis.testLogger = testLogger;\n+\t\t@Override\n+\t\tpublic boolean isTraceEnabled() {\n+\t\t\treturn delegate.isTraceEnabled();", "originalCommit": "065378d00adcd05262bafbdf6ed6ad8cdd5e094c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1NTIzOA==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525955238", "bodyText": "maybe add a global parameter along testLogger to decide whether or not the delegate should also receive log instructions", "author": "simonbasle", "createdAt": "2020-11-18T09:56:52Z", "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "diffHunk": "@@ -1,59 +1,208 @@\n package reactor.test;\n \n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n import ch.qos.logback.classic.Level;\n-import ch.qos.logback.classic.Logger;\n import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n import ch.qos.logback.classic.spi.ILoggingEvent;\n import ch.qos.logback.core.UnsynchronizedAppenderBase;\n-import org.slf4j.LoggerFactory;\n import reactor.test.util.TestLogger;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tstatic final String TEST_APPENDER_NAME = \"TestAppender\";\n+\tprivate static TestLogger testLogger;\n \n \tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tTestAppender appender = new TestAppender(testLogger);\n-\t\t\tappender.start();\n-\t\t\tlogbackLogger.addAppender(appender);\n-\t\t}\n+\t\tLoggerUtils.testLogger = testLogger;\n \t}\n \n \tpublic static void resetAppender(Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tlogbackLogger.detachAppender(TEST_APPENDER_NAME);\n+\t\tLoggerUtils.testLogger = null;\n+\t}\n+\n+\tpublic static void installQueryableLogger() {\n+\t\tLoggers.resetLoggerFactory();\n+\t\ttry {\n+\t\t\tField lfField = Loggers.class.getDeclaredField(\"LOGGER_FACTORY\");\n+\t\t\tlfField.setAccessible(true);\n+\t\t\tObject factoryObject = lfField.get(Loggers.class);\n+\t\t\tMethod factoryMethod = factoryObject.getClass().getMethod(\"getLogger\", String.class);\n+\t\t\tfactoryMethod.setAccessible(true);\n+\n+\t\t\tLoggers.useCustomLoggers(category -> {\n+\t\t\t\ttry {\n+\t\t\t\t\tLogger original = (Logger) factoryMethod.invoke(factoryObject, category);\n+\t\t\t\t\treturn new DivertingLogger(original);\n+\t\t\t\t}\n+\t\t\t\tcatch (IllegalAccessException | InvocationTargetException e) {\n+\t\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\tcatch (NoSuchFieldException | IllegalAccessException | NoSuchMethodException e) {\n+\t\t\tthrow new RuntimeException(\"Could not install custom logger\", e);\n \t\t}\n \t}\n \n-\tstatic class TestAppender extends UnsynchronizedAppenderBase<ILoggingEvent> {\n+\tprivate static class DivertingLogger implements reactor.util.Logger {\n+\n+\t\tprivate final reactor.util.Logger delegate;\n \n-\t\tprivate final TestLogger testLogger;\n-\t\tprivate final ThrowableProxyConverter throwableProxyConverter = new ThrowableProxyConverter();\n+\t\tprivate DivertingLogger(Logger delegate) {\n+\t\t\tthis.delegate = delegate;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getName() {\n+\t\t\treturn delegate.getName();\n+\t\t}\n \n-\t\tTestAppender(TestLogger testLogger) {\n-\t\t\tthis.testLogger = testLogger;\n+\t\t@Override\n+\t\tpublic boolean isTraceEnabled() {\n+\t\t\treturn delegate.isTraceEnabled();\n \t\t}\n \n \t\t@Override\n-\t\tprotected void append(ILoggingEvent eventObject) {\n-\t\t\tif (eventObject.getLevel() == Level.ERROR) {\n-\t\t\t\ttestLogger.error(eventObject.getFormattedMessage()\n-\t\t\t\t                            .concat(\"\\n\")\n-\t\t\t\t                            .concat(throwableProxyConverter.convert(eventObject)));\n+\t\tpublic void trace(String msg) {\n+\t\t\tif (LoggerUtils.testLogger != null) {\n+\t\t\t\tLoggerUtils.testLogger.trace(msg);\n+\t\t\t}\n+\t\t\tdelegate.trace(msg);", "originalCommit": "065378d00adcd05262bafbdf6ed6ad8cdd5e094c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyMjE0Nw==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r527022147", "bodyText": "defering this until somebody actually \"complains\" about the double output", "author": "simonbasle", "createdAt": "2020-11-19T16:26:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1NTIzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1NTU0OQ==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525955549", "bodyText": "yeah this is dead code, but it should be done in a separate PR", "author": "simonbasle", "createdAt": "2020-11-18T09:57:16Z", "path": "reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java", "diffHunk": "@@ -440,40 +440,6 @@ public I next() {\n \t\t}\n \t}\n \n-\tfinal <S extends OperatorScenario<I, PI, O, PO>> void forEachScenario(List<S> scenarios,", "originalCommit": "065378d00adcd05262bafbdf6ed6ad8cdd5e094c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1OTA0MA==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525959040", "bodyText": "why removing the finals in this file ?", "author": "simonbasle", "createdAt": "2020-11-18T10:02:13Z", "path": "reactor-core/src/main/java/reactor/util/Loggers.java", "diffHunk": "@@ -64,7 +64,7 @@\n \t * @see #useConsoleLoggers()\n \t * @see #useVerboseConsoleLoggers()\n \t */\n-\tpublic static final void resetLoggerFactory() {\n+\tpublic static void resetLoggerFactory() {", "originalCommit": "065378d00adcd05262bafbdf6ed6ad8cdd5e094c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1OTM3Nw==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525959377", "bodyText": "(need a TODO to complete this test, no assertion)", "author": "simonbasle", "createdAt": "2020-11-18T10:02:47Z", "path": "reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java", "diffHunk": "@@ -972,4 +972,11 @@ public void reportThrowInSubscribeWithFuseableErrorResumed() {\n \n \t\tassertSubscriber.assertNoError().awaitAndAssertNextValues(123);\n \t}\n+\n+\t@Test\n+\tpublic void onDiscardCallbackErrorsLog() {\n+\t\tContext context = Operators.enableOnDiscard(Context.empty(), t -> {throw new RuntimeException(\"Boom\");});\n+\t\tOperators.onDiscard(\"Foo\", context);\n+", "originalCommit": "065378d00adcd05262bafbdf6ed6ad8cdd5e094c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc1NzQ2OA==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r526757468", "bodyText": "for the condition, capture the testLogger into a local variable (the testLogger could be nulled out between the != null test and the isTraceEnabled() call)", "author": "simonbasle", "createdAt": "2020-11-19T10:36:24Z", "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "diffHunk": "@@ -62,7 +68,7 @@ public String getName() {\n \n \t\t@Override\n \t\tpublic boolean isTraceEnabled() {\n-\t\t\treturn delegate.isTraceEnabled();\n+\t\t\treturn delegate.isTraceEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isTraceEnabled());", "originalCommit": "3786997bbe39d8b08ad707c7669133b5a4c0be16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc2NDM2Mw==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r526764363", "bodyText": "same comment as above about testLogger capture", "author": "simonbasle", "createdAt": "2020-11-19T10:47:09Z", "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "diffHunk": "@@ -1,59 +1,214 @@\n package reactor.test;\n \n-import ch.qos.logback.classic.Level;\n-import ch.qos.logback.classic.Logger;\n-import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n-import ch.qos.logback.classic.spi.ILoggingEvent;\n-import ch.qos.logback.core.UnsynchronizedAppenderBase;\n-import org.slf4j.LoggerFactory;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.function.Function;\n+\n import reactor.test.util.TestLogger;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tstatic final String TEST_APPENDER_NAME = \"TestAppender\";\n+\tprivate static Logger testLogger;\n \n-\tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tTestAppender appender = new TestAppender(testLogger);\n-\t\t\tappender.start();\n-\t\t\tlogbackLogger.addAppender(appender);\n-\t\t}\n+\tpublic static void installAdditionalLogger(Logger testLogger) {\n+\t\tLoggerUtils.testLogger = testLogger;\n \t}\n \n-\tpublic static void resetAppender(Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tlogbackLogger.detachAppender(TEST_APPENDER_NAME);\n+\tpublic static void resetAdditionalLogger() {\n+\t\tLoggerUtils.testLogger = null;\n+\t}\n+\n+\t/**\n+\t * Sets a {@link Loggers#useCustomLoggers(Function) logger factory} that will return loggers that not only use the\n+\t * original logging framework used by reactor, but also use the logger set via {@link #installAdditionalLogger(Logger)}, irrespective\n+\t * of its name or how it was obtained. The expectation here is that tests that want to assess that something is\n+\t * logged by reactor will pass a {@link TestLogger} instance to {@link #installAdditionalLogger(Logger)}, trigger the operation\n+\t * under scrutiny, assert the logger contents and reset state by calling {@link #resetAdditionalLogger()}.\n+\t */\n+\tpublic static void setupDivertingLoggerFactory() {\n+\t\ttry {\n+\t\t\tField lfField = Loggers.class.getDeclaredField(\"LOGGER_FACTORY\");\n+\t\t\tlfField.setAccessible(true);\n+\t\t\tObject factoryObject = lfField.get(Loggers.class);\n+\t\t\tMethod factoryMethod = factoryObject.getClass().getMethod(\"getLogger\", String.class);\n+\t\t\tfactoryMethod.setAccessible(true);\n+\n+\t\t\tLoggers.useCustomLoggers(category -> {\n+\t\t\t\ttry {\n+\t\t\t\t\tLogger original = (Logger) factoryMethod.invoke(factoryObject, category);\n+\t\t\t\t\treturn new DivertingLogger(original);\n+\t\t\t\t}\n+\t\t\t\tcatch (IllegalAccessException | InvocationTargetException e) {\n+\t\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\tcatch (NoSuchFieldException | IllegalAccessException | NoSuchMethodException e) {\n+\t\t\tthrow new RuntimeException(\"Could not install custom logger\", e);\n \t\t}\n \t}\n \n-\tstatic class TestAppender extends UnsynchronizedAppenderBase<ILoggingEvent> {\n+\t/**\n+\t * A Logger that behaves like its {@link #delegate} but also logs to {@link LoggerUtils#testLogger} if it is set.\n+\t */\n+\tprivate static class DivertingLogger implements reactor.util.Logger {\n+\n+\t\tprivate final reactor.util.Logger delegate;\n \n-\t\tprivate final TestLogger testLogger;\n-\t\tprivate final ThrowableProxyConverter throwableProxyConverter = new ThrowableProxyConverter();\n+\t\tprivate DivertingLogger(Logger delegate) {\n+\t\t\tthis.delegate = delegate;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getName() {\n+\t\t\treturn delegate.getName();\n+\t\t}\n \n-\t\tTestAppender(TestLogger testLogger) {\n-\t\t\tthis.testLogger = testLogger;\n+\t\t@Override\n+\t\tpublic boolean isTraceEnabled() {\n+\t\t\treturn delegate.isTraceEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isTraceEnabled());\n \t\t}\n \n \t\t@Override\n-\t\tprotected void append(ILoggingEvent eventObject) {\n-\t\t\tif (eventObject.getLevel() == Level.ERROR) {\n-\t\t\t\ttestLogger.error(eventObject.getFormattedMessage()\n-\t\t\t\t                            .concat(\"\\n\")\n-\t\t\t\t                            .concat(throwableProxyConverter.convert(eventObject)));\n+\t\tpublic void trace(String msg) {\n+\t\t\tif (LoggerUtils.testLogger != null) {", "originalCommit": "3786997bbe39d8b08ad707c7669133b5a4c0be16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc2NTQxNw==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r526765417", "bodyText": "I'm on the fence about the method actually setting up the logger factory, vs returning a \"factory\" (as a Function) to pass to Loggers.useCustomLoggers.", "author": "simonbasle", "createdAt": "2020-11-19T10:48:43Z", "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "diffHunk": "@@ -1,59 +1,214 @@\n package reactor.test;\n \n-import ch.qos.logback.classic.Level;\n-import ch.qos.logback.classic.Logger;\n-import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n-import ch.qos.logback.classic.spi.ILoggingEvent;\n-import ch.qos.logback.core.UnsynchronizedAppenderBase;\n-import org.slf4j.LoggerFactory;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.function.Function;\n+\n import reactor.test.util.TestLogger;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tstatic final String TEST_APPENDER_NAME = \"TestAppender\";\n+\tprivate static Logger testLogger;\n \n-\tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tTestAppender appender = new TestAppender(testLogger);\n-\t\t\tappender.start();\n-\t\t\tlogbackLogger.addAppender(appender);\n-\t\t}\n+\tpublic static void installAdditionalLogger(Logger testLogger) {\n+\t\tLoggerUtils.testLogger = testLogger;\n \t}\n \n-\tpublic static void resetAppender(Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tlogbackLogger.detachAppender(TEST_APPENDER_NAME);\n+\tpublic static void resetAdditionalLogger() {\n+\t\tLoggerUtils.testLogger = null;\n+\t}\n+\n+\t/**\n+\t * Sets a {@link Loggers#useCustomLoggers(Function) logger factory} that will return loggers that not only use the\n+\t * original logging framework used by reactor, but also use the logger set via {@link #installAdditionalLogger(Logger)}, irrespective\n+\t * of its name or how it was obtained. The expectation here is that tests that want to assess that something is\n+\t * logged by reactor will pass a {@link TestLogger} instance to {@link #installAdditionalLogger(Logger)}, trigger the operation\n+\t * under scrutiny, assert the logger contents and reset state by calling {@link #resetAdditionalLogger()}.\n+\t */\n+\tpublic static void setupDivertingLoggerFactory() {", "originalCommit": "3786997bbe39d8b08ad707c7669133b5a4c0be16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "13e5e6cd17c6318fe9c5fc917ef4e923f1f6a635", "url": "https://github.com/reactor/reactor-core/commit/13e5e6cd17c6318fe9c5fc917ef4e923f1f6a635", "message": "fix #2269 Introduce an early override of loggers in tests", "committedDate": "2020-11-19T11:36:03Z", "type": "commit"}, {"oid": "cb1f11c4a980bf472b03baf551a874ba9bed3565", "url": "https://github.com/reactor/reactor-core/commit/cb1f11c4a980bf472b03baf551a874ba9bed3565", "message": "Use better names for LoggerUtils methods.", "committedDate": "2020-11-19T11:37:10Z", "type": "commit"}, {"oid": "b72e68c3e7e1a8ce9b4871f8fd0a21526e017600", "url": "https://github.com/reactor/reactor-core/commit/b72e68c3e7e1a8ce9b4871f8fd0a21526e017600", "message": "Warn on non-balanced calls", "committedDate": "2020-11-19T11:37:10Z", "type": "commit"}, {"oid": "6673eaff689fb0adaa08bf125e6819b09cf87ba5", "url": "https://github.com/reactor/reactor-core/commit/6673eaff689fb0adaa08bf125e6819b09cf87ba5", "message": "Move TestUtils into reactor-test production code", "committedDate": "2020-11-19T11:37:11Z", "type": "commit"}, {"oid": "509283403d1874fef538136638cb40a6d6a990b9", "url": "https://github.com/reactor/reactor-core/commit/509283403d1874fef538136638cb40a6d6a990b9", "message": "Finish test for Operators.onDiscard()", "committedDate": "2020-11-19T11:37:11Z", "type": "commit"}, {"oid": "8da2efa9b2ad130fcaabfae6bee541e01dc9ada9", "url": "https://github.com/reactor/reactor-core/commit/8da2efa9b2ad130fcaabfae6bee541e01dc9ada9", "message": "Capture logger variable to protect against it being nulled in a race", "committedDate": "2020-11-19T11:37:11Z", "type": "commit"}, {"oid": "669d7847c8ebce0632f6ebc52d18e9d0fc3708dd", "url": "https://github.com/reactor/reactor-core/commit/669d7847c8ebce0632f6ebc52d18e9d0fc3708dd", "message": "Rename methods", "committedDate": "2020-11-19T13:45:05Z", "type": "commit"}, {"oid": "a37d55852eef6a2a7f143fba29baf35ec1d68a8d", "url": "https://github.com/reactor/reactor-core/commit/a37d55852eef6a2a7f143fba29baf35ec1d68a8d", "message": "Add tests for LoggerUtils", "committedDate": "2020-11-19T15:12:13Z", "type": "commit"}, {"oid": "a37d55852eef6a2a7f143fba29baf35ec1d68a8d", "url": "https://github.com/reactor/reactor-core/commit/a37d55852eef6a2a7f143fba29baf35ec1d68a8d", "message": "Add tests for LoggerUtils", "committedDate": "2020-11-19T15:12:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAxNTkwMw==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r527015903", "bodyText": "still needs to remove the call to old reset() method in BaseOperatorTest", "author": "simonbasle", "createdAt": "2020-11-19T16:18:09Z", "path": "reactor-core/src/test/java/reactor/ReactorTestExecutionListener.java", "diffHunk": "@@ -24,10 +25,21 @@\n import reactor.core.publisher.Hooks;\n import reactor.core.scheduler.Schedulers;\n import reactor.test.AssertionsUtils;\n+import reactor.test.util.LoggerUtils;\n+import reactor.util.Logger;\n \n+/**\n+ * A custom TestExecutionListener that helps with tests in reactor:<ul>\n+ *     <li>resets {@link Hooks} once a test is finished, making sure no dirty state remains,</li>\n+ *     <li>resets {@link Schedulers} related infrastructure, making sure no dirty state remains,</li>\n+ *     <li>installs custom assertJ {@link Representation} for some of reactor types,</li>\n+ *     <li>installs a custom {@link Logger} factory <strong>very</strong> early in the suite lifecycle, so that loggers\n+ *     in reactor (which are typically static members initialized early) can be diverted and asserted in tests.</li>\n+ * </ul>\n+ */\n public class ReactorTestExecutionListener implements TestExecutionListener {\n \n-\tpublic static void reset() {\n+\tprivate static void resetHooksAndSchedulers() {", "originalCommit": "a37d55852eef6a2a7f143fba29baf35ec1d68a8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyMDA4Mw==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r527020083", "bodyText": "nitpick: I'd put the static methods above both static inner classes, and add basic documentation", "author": "simonbasle", "createdAt": "2020-11-19T16:23:44Z", "path": "reactor-test/src/main/java/reactor/test/util/LoggerUtils.java", "diffHunk": "@@ -0,0 +1,281 @@\n+package reactor.test.util;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.function.Function;\n+\n+import reactor.core.Disposable;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n+\n+/**\n+ * This class eases testing interested in what reactor classes emit using {@link Logger loggers}.\n+ *\n+ * @author Eric Bottard\n+ */\n+public final class LoggerUtils {\n+\tprivate static Logger testLogger;\n+\n+\tprivate LoggerUtils() {\n+\t}\n+\n+\t/**\n+\t * Sets a {@link Loggers#useCustomLoggers(Function) logger factory} that will return loggers that not only use the\n+\t * original logging framework used by reactor, but also use the logger set via {@link #enableCaptureWith(Logger)}, irrespective\n+\t * of its name or how it was obtained. The expectation here is that tests that want to assess that something is\n+\t * logged by reactor will pass a {@link TestLogger} instance to {@link #enableCaptureWith(Logger)}, trigger the operation\n+\t * under scrutiny, assert the logger contents and reset state by calling {@link #disableCapture()}.\n+\t *\n+\t * <p>This method should be called very early in the application/tests lifecycle, before reactor classes have created\n+\t * their loggers.</p>\n+\t *\n+\t * @return a disposable that re-installs the original factory when disposed\n+\t */\n+\tpublic static Disposable useCurrentLoggersWithCapture() {\n+\t\ttry {\n+\t\t\tCapturingFactory capturingFactory = new CapturingFactory();\n+\t\t\tLoggers.useCustomLoggers(capturingFactory);\n+\t\t\treturn capturingFactory;\n+\t\t}\n+\t\tcatch (NoSuchFieldException | IllegalAccessException | NoSuchMethodException e) {\n+\t\t\tthrow new RuntimeException(\"Could not install custom logger\", e);\n+\t\t}\n+\t}\n+\n+\tprivate static class CapturingFactory implements Function<String, Logger>, Disposable {\n+\n+\t\tprivate final Method originalFactoryMethod;\n+\n+\t\tprivate final Object orginalFactory;\n+\n+\t\tprivate CapturingFactory() throws NoSuchFieldException, IllegalAccessException, NoSuchMethodException {\n+\t\t\tField lfField = Loggers.class.getDeclaredField(\"LOGGER_FACTORY\");\n+\t\t\tlfField.setAccessible(true);\n+\t\t\torginalFactory = lfField.get(Loggers.class);\n+\t\t\toriginalFactoryMethod = orginalFactory.getClass().getMethod(\"getLogger\", String.class);\n+\t\t\toriginalFactoryMethod.setAccessible(true);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Logger apply(String category) {\n+\t\t\ttry {\n+\t\t\t\tLogger original = (Logger) originalFactoryMethod.invoke(orginalFactory, category);\n+\t\t\t\treturn new DivertingLogger(original);\n+\t\t\t}\n+\t\t\tcatch (IllegalAccessException | InvocationTargetException e) {\n+\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void dispose() {\n+\t\t\ttry {\n+\t\t\t\tField lfField = Loggers.class.getDeclaredField(\"LOGGER_FACTORY\");\n+\t\t\t\tlfField.setAccessible(true);\n+\t\t\t\tObject o = lfField.get(Loggers.class);\n+\n+\t\t\t\tif (!(Loggers.getLogger(LoggerUtils.class) instanceof DivertingLogger)) {\n+\t\t\t\t\tthrow new IllegalStateException(\"Expected the current factory to be \" + this + \", found \" + o + \" instead\");\n+\t\t\t\t}\n+\t\t\t\tlfField.set(Loggers.class, orginalFactory);\n+\t\t\t}\n+\t\t\tcatch (NoSuchFieldException | IllegalAccessException e) {\n+\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static void enableCaptureWith(Logger testLogger) {", "originalCommit": "a37d55852eef6a2a7f143fba29baf35ec1d68a8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyMTQxNg==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r527021416", "bodyText": "the message should be asserted", "author": "simonbasle", "createdAt": "2020-11-19T16:25:22Z", "path": "reactor-test/src/test/java/reactor/test/util/LoggerUtilsTest.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) 2011-2018 Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.test.util;\n+\n+import org.junit.jupiter.api.Test;\n+import reactor.core.Disposable;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+\n+class LoggerUtilsTest {\n+\n+\t@Test\n+\tvoid installsFactory() {\n+\t\tDisposable disposable = LoggerUtils.useCurrentLoggersWithCapture();\n+\t\tTestLogger testLogger = new TestLogger();\n+\t\ttry {\n+\t\t\tLogger frameworkLogger = Loggers.getLogger(\"category\"); // simulates an early creation of a logger\n+\n+\t\t\tLoggerUtils.enableCaptureWith(testLogger);\n+\t\t\tframeworkLogger.debug(\"Look ma!, I'm debugging!\");\n+\t\t\tassertThat(testLogger.getOutContent()).contains(\"Look ma!, I'm debugging!\");\n+\t\t\tLoggerUtils.disableCapture();\n+\t\t\tframeworkLogger.debug(\"This won't be captured\");\n+\t\t\tassertThat(testLogger.getOutContent()).doesNotContain(\"This won't be captured\");\n+\t\t} finally {\n+\t\t\tdisposable.dispose();\n+\n+\t\t\t// The following tests that once disposed, capturing is no longer in effect\n+\t\t\tLoggerUtils.enableCaptureWith(testLogger);\n+\t\t\tLogger otherLogger = Loggers.getLogger(\"another\");\n+\t\t\totherLogger.debug(\"This won't be captured either\");\n+\t\t\tassertThat(testLogger.getOutContent()).doesNotContain(\"This won't be captured either\");\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tvoid disposeOnlyUninstallsItelf() {\n+\t\tDisposable disposable = LoggerUtils.useCurrentLoggersWithCapture();\n+\t\tassertThatExceptionOfType(IllegalStateException.class).isThrownBy(() -> {\n+\t\t\tLoggers.resetLoggerFactory(); // Overwrites our custom logger\n+\t\t\tdisposable.dispose();\n+\t\t});", "originalCommit": "a37d55852eef6a2a7f143fba29baf35ec1d68a8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f46191d8c10dc93c048ffc12a5cf747d51e02d26", "url": "https://github.com/reactor/reactor-core/commit/f46191d8c10dc93c048ffc12a5cf747d51e02d26", "message": "Address review comments", "committedDate": "2020-11-20T09:20:45Z", "type": "commit"}]}