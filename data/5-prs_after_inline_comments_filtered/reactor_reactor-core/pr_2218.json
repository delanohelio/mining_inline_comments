{"pr_number": 2218, "pr_title": "Suggesting some changes on the Processor API update", "pr_createdAt": "2020-06-23T21:33:51Z", "pr_url": "https://github.com/reactor/reactor-core/pull/2218", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1MTA3Mw==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r444751073", "bodyText": "if sinks are advertised as thread safe objects, doesn't this require external synchronization of the processor's calls ? especially if we later introduce several flavors of MonoProcessor ?", "author": "simonbasle", "createdAt": "2020-06-24T09:03:47Z", "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -203,64 +159,43 @@ public void error(Throwable e) {\n \t\t}\n \n \t\t@Override\n-\t\tpublic StandaloneFluxSink<T> next(T t) {\n+\t\tpublic Sink<T> next(T t) {\n \t\t\tdelegateSink.next(t);\n \t\t\treturn this;\n \t\t}\n \t}\n \n-\t//TODO improve synchronization, prefer CAS ?\n-\tstatic final class MonoProcessorSink<T> implements StandaloneMonoSink<T> {\n+\tstatic final class MonoProcessorSink<T> implements Sink<T> {", "originalCommit": "e152ff38435ecb251deefea7fdfbde45ba9516c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1OTU1OA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445159558", "bodyText": "MonoProcessor are safe, all the onXxx methods are atomic - I'll actually have an extra commit that moves further and remove the need for MonoProcessorSink by making MonoProcessor implementing it directly.", "author": "smaldini", "createdAt": "2020-06-24T20:42:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1MTA3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQxMTA0Mg==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445411042", "bodyText": "ok. the later might be a better solution actually, since then there is no risk of adding a (non-serialized) flavor of MonoProcessor and mistakenly wrapping it with a (non-serialized) sink decorator", "author": "simonbasle", "createdAt": "2020-06-25T08:58:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1MTA3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1MzQ2NQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r444753465", "bodyText": "could you maybe revert the FluxIdentityProcessor removal for now, and offer it in a separate PR ? this distracts from the rest of the PR IMHO, as maybe 90% of these files are only changed due to this removal.", "author": "simonbasle", "createdAt": "2020-06-24T09:07:48Z", "path": "reactor-core/src/main/java/reactor/core/publisher/DirectProcessor.java", "diffHunk": "@@ -81,7 +81,7 @@\n  * @deprecated Prefer clear cut usage of either {@link Processors} or {@link Sinks}, to be removed in 3.5\n  */\n @Deprecated\n-public final class DirectProcessor<T> extends FluxIdentityProcessor<T> {\n+public final class DirectProcessor<T> extends FluxProcessor<T, T> {", "originalCommit": "e152ff38435ecb251deefea7fdfbde45ba9516c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MDg2Mg==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445160862", "bodyText": "The PR is not finished and there will be more impact due to removing Processors and use of Processor directly wherever possible.", "author": "smaldini", "createdAt": "2020-06-24T20:44:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1MzQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1NTA3Mw==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r444755073", "bodyText": "the rationale for adding this was that FluxProcessor<String, String> feels clunky, and was such a pain to migrate when removing deprecation warnings in the test code. Maybe that pain will be a good motivator for people to move to Sink? But maybe on the contrary it will just make them angry \ud83d\ude1d", "author": "simonbasle", "createdAt": "2020-06-24T09:10:33Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxIdentityProcessor.java", "diffHunk": "@@ -1,26 +0,0 @@\n-/*\n- * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *        https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package reactor.core.publisher;\n-\n-/**\n- * A {@link FluxProcessor} that has the same input and output types.\n- * \n- * @author Simon Basl\u00e9\n- */\n-public abstract class FluxIdentityProcessor<T> extends FluxProcessor<T, T> {", "originalCommit": "e152ff38435ecb251deefea7fdfbde45ba9516c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MTI1MQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445161251", "bodyText": "Yeah the rationale is to not use processors api at all in the future so no need to spend any more surface api for them.", "author": "smaldini", "createdAt": "2020-06-24T20:45:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1NTA3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1NTg4NQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r444755885", "bodyText": "honestly, I'm not a huge fan of offering an API and then having it error in half the cases. this feels like a step backward towards the same kind of inconsistencies that we had in processors.", "author": "simonbasle", "createdAt": "2020-06-24T09:11:55Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSink.java", "diffHunk": "@@ -113,6 +113,16 @@\n \t */\n \tFluxSink<T> onDispose(Disposable d);\n \n+\t@Override\n+\tdefault Flux<T> toFlux() {\n+\t\treturn Flux.error(new IllegalStateException(\"A FluxSink does not support back referencing the outer Flux\"));", "originalCommit": "e152ff38435ecb251deefea7fdfbde45ba9516c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2Mjg1MA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445162850", "bodyText": "It's not impossible to support it but its easy to make mistakes if supported. At least its explicit that it doesn't work unlike using Processor directly vs sinks. We can look at the final result once I'm done and see what can go back. Right now i'm aiming for one API entry: Sink/Sinks and will add more from this.", "author": "smaldini", "createdAt": "2020-06-24T20:48:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1NTg4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA3NjE0OA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449076148", "bodyText": "After re-considering it I think I can live with the FluxSink rejecting use of toFlux at runtime, maybe. I have more trouble with FluxSink having a toMono() and MonoSink a toFlux, to be honest", "author": "simonbasle", "createdAt": "2020-07-02T15:17:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1NTg4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUyMTE0Ng==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r464521146", "bodyText": "fixed in 6f60e9f", "author": "simonbasle", "createdAt": "2020-08-03T16:24:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1NTg4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1ODMwMw==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r444758303", "bodyText": "I think this is very problematic. Offering a flux-like API on the MonoSink, even if we introduce a specialized API, is bound to be confusing.\nie this API seemingly allows next(t).next(t).complete() or even more confusing, next(t1).next(t2).success(t3) type of calls.", "author": "simonbasle", "createdAt": "2020-06-24T09:15:58Z", "path": "reactor-core/src/main/java/reactor/core/publisher/MonoSink.java", "diffHunk": "@@ -31,7 +33,45 @@\n  *\n  * @param <T> the value type emitted\n  */\n-public interface MonoSink<T> extends ScalarSink<T> {\n+public interface MonoSink<T> extends Sink<T> {", "originalCommit": "e152ff38435ecb251deefea7fdfbde45ba9516c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2NDQ1OA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445164458", "bodyText": "That is changed in the next commit. Sink has orthogonal methods \"boolean emitXxx\" (complete|error|next). Chaining only brings value to FluxSink if any and it was impossible for processors to be internally sink due to competing error signatures. Plus it provides for a new feature, returning false if emission failed because the sink is terminated.", "author": "smaldini", "createdAt": "2020-06-24T20:51:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1ODMwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQxMjcwNQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445412705", "bodyText": "wouldn't it make implementing the tryNext feature harder ? I'm guessing this overlaps a bit, but it could be interesting to be able to distinguish between a emitNext call that returns false because termination from one that returns false because backpressure. wdyt @dfeist ?", "author": "simonbasle", "createdAt": "2020-06-25T09:01:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1ODMwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyODM3MQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r447328371", "bodyText": "If we go that route we always bring back the enum Emission with various helper isOk, isTerminated, isCancelled, isDisposed, isBackpressured", "author": "smaldini", "createdAt": "2020-06-30T00:05:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1ODMwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA4MTA2Mw==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449081063", "bodyText": "that would be an option, yeah. as I'm not sure I will be able to implement the tryNext feature within the 3.4.0 timeframe, I'd prefer to pave the way for it and thus introduce a subset of the enum. Maybe SinkResult with values EMITTED, REJECTED_TERMINATED and REJECTED_CANCELLED for now ? (or even just EMITTED vs REJECTED_TERMINATED). The important point is that trynext is only one new enum value from being added (and we can later do finer grained distinction between rejections due to termination, cancellation and disposal of the sink)\nIn a word I would make a MVP of this idea part of this PR", "author": "simonbasle", "createdAt": "2020-07-02T15:24:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1ODMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQxNTM1OA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445415358", "bodyText": "while you're here \ud83d\ude01\ncould you help getting rid of the parkNanos ? (I think I remember you said you thought it was possible)", "author": "simonbasle", "createdAt": "2020-06-25T09:06:10Z", "path": "reactor-core/src/main/java/reactor/core/publisher/EmitterProcessor.java", "diffHunk": "@@ -192,6 +192,85 @@ public void subscribe(CoreSubscriber<? super T> actual) {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic boolean emitComplete() {\n+\t\tif (done) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tdone = true;\n+\t\tdrain();\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\tpublic boolean emitError(Throwable t) {\n+\t\tObjects.requireNonNull(t, \"onError\");\n+\t\tif (done) {\n+\t\t\tOperators.onErrorDroppedMulticast(t);\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (Exceptions.addThrowable(ERROR, this, t)) {\n+\t\t\tdone = true;\n+\t\t\tdrain();\n+\t\t\treturn true;\n+\t\t}\n+\t\telse {\n+\t\t\tOperators.onErrorDroppedMulticast(t);\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic boolean emitNext(T t) {\n+\t\tif (done) {\n+\t\t\tOperators.onNextDropped(t, currentContext());\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (sourceMode == Fuseable.ASYNC) {\n+\t\t\tdrain();\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tObjects.requireNonNull(t, \"onNext\");\n+\n+\t\tQueue<T> q = queue;\n+\n+\t\tif (q == null) {\n+\t\t\tif (Operators.setOnce(S, this, Operators.emptySubscription())) {\n+\t\t\t\tq = Queues.<T>get(prefetch).get();\n+\t\t\t\tqueue = q;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tfor (; ; ) {\n+\t\t\t\t\tif (isDisposed()) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\tq = queue;\n+\t\t\t\t\tif (q != null) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\twhile (!q.offer(t)) {\n+\t\t\tLockSupport.parkNanos(10);", "originalCommit": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyMTg5Ng==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r447321896", "bodyText": "I think we should just not support it at all this is a mistake and it feels like a documentable change for 3.4", "author": "smaldini", "createdAt": "2020-06-29T23:46:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQxNTM1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQxNjc1Ng==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445416756", "bodyText": "potential for regression around leaks", "author": "simonbasle", "createdAt": "2020-06-25T09:08:39Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxCreate.java", "diffHunk": "@@ -131,102 +130,102 @@ public Object scanUnsafe(Attr key) {\n \n \t\tvolatile boolean done;\n \n-\t\tSerializedSink(BaseSink<T> sink) {\n+\t\tSerializedSink(SINK sink) {\n \t\t\tthis.sink = sink;\n \t\t\tthis.mpscQueue = Queues.<T>unboundedMultiproducer().get();\n \t\t}\n \n \t\t@Override\n-\t\tpublic Context currentContext() {\n-\t\t\treturn sink.currentContext();\n+\t\tpublic final Flux<T> toFlux() {\n+\t\t\treturn sink.toFlux();\n \t\t}\n \n \t\t@Override\n-\t\tpublic FluxSink<T> next(T t) {\n+\t\tpublic final Mono<T> toMono() {\n+\t\t\treturn sink.toMono();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic final boolean emitComplete() {\n+\t\t\tif (done) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tdone = true;\n+\t\t\tdrain();\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tabstract Context currentContext();\n+\n+\t\t@Override\n+\t\tpublic final boolean emitError(Throwable t) {\n+\t\t\tObjects.requireNonNull(t, \"t is null in sink.error(t)\");\n+\t\t\tif (done) {\n+\t\t\t\tOperators.onOperatorError(t, currentContext());\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (Exceptions.addThrowable(ERROR, this, t)) {\n+\t\t\t\tdone = true;\n+\t\t\t\tdrain();\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\tContext ctx = currentContext();\n+\t\t\tOperators.onDiscardQueueWithClear(mpscQueue, ctx, null);\n+\t\t\tOperators.onOperatorError(t, ctx);\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic final boolean emitNext(T t) {\n \t\t\tObjects.requireNonNull(t, \"t is null in sink.next(t)\");\n-\t\t\tif (sink.isTerminated() || done) {\n-\t\t\t\tOperators.onNextDropped(t, sink.currentContext());\n-\t\t\t\treturn this;\n+\t\t\tif (done) {\n+\t\t\t\tOperators.onNextDropped(t, currentContext());\n+\t\t\t\treturn false;\n \t\t\t}\n \t\t\tif (WIP.get(this) == 0 && WIP.compareAndSet(this, 0, 1)) {\n \t\t\t\ttry {\n-\t\t\t\t\tsink.next(t);\n+\t\t\t\t\tsink.emitNext(t);\n \t\t\t\t}\n \t\t\t\tcatch (Throwable ex) {\n-\t\t\t\t\tOperators.onOperatorError(sink, ex, t, sink.currentContext());\n+\t\t\t\t\tOperators.onOperatorError(null, ex, t, currentContext());\n+\t\t\t\t\temitError(ex);\n+\t\t\t\t\treturn false;\n \t\t\t\t}\n \t\t\t\tif (WIP.decrementAndGet(this) == 0) {\n-\t\t\t\t\treturn this;\n+\t\t\t\t\treturn true;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthis.mpscQueue.offer(t);\n \t\t\t\tif (WIP.getAndIncrement(this) != 0) {\n-\t\t\t\t\treturn this;\n+\t\t\t\t\treturn true;\n \t\t\t\t}\n \t\t\t}\n \t\t\tdrainLoop();\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void error(Throwable t) {\n-\t\t\tObjects.requireNonNull(t, \"t is null in sink.error(t)\");\n-\t\t\tif (sink.isTerminated() || done) {\n-\t\t\t\tOperators.onOperatorError(t, sink.currentContext());\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tif (Exceptions.addThrowable(ERROR, this, t)) {\n-\t\t\t\tdone = true;\n-\t\t\t\tdrain();\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tContext ctx = sink.currentContext();\n-\t\t\t\tOperators.onDiscardQueueWithClear(mpscQueue, ctx, null);\n-\t\t\t\tOperators.onOperatorError(t, ctx);\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void complete() {\n-\t\t\tif (sink.isTerminated() || done) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tdone = true;\n-\t\t\tdrain();\n+\t\t\treturn true;\n \t\t}\n \n \t\t//impl note: don't use sink.isTerminated() in the drain loop,\n \t\t//it needs to separately check its own `done` status before calling the base sink\n \t\t//complete()/error() methods (which do flip the isTerminated), otherwise it could\n \t\t//bypass the terminate handler (in buffer and latest variants notably).\n-\t\tvoid drain() {\n+\t\tfinal void drain() {\n \t\t\tif (WIP.getAndIncrement(this) == 0) {\n \t\t\t\tdrainLoop();\n \t\t\t}\n \t\t}\n \n-\t\tvoid drainLoop() {\n-\t\t\tContext ctx = sink.currentContext();\n-\t\t\tBaseSink<T> e = sink;\n+\t\tfinal void drainLoop() {\n+\t\t\tSink<T> e = sink;\n \t\t\tQueue<T> q = mpscQueue;\n \t\t\tfor (; ; ) {\n \n \t\t\t\tfor (; ; ) {\n-\t\t\t\t\tif (e.isCancelled()) {", "originalCommit": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyNjY3MA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r447326670", "bodyText": "double checked but unfortunately there is no easy other way for now and i don't want to scope creep into changing this here. So reverted", "author": "smaldini", "createdAt": "2020-06-30T00:00:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQxNjc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQxODY3Ng==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445418676", "bodyText": "I think we can directly make Sink implement Scannable", "author": "simonbasle", "createdAt": "2020-06-25T09:12:11Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxGroupJoin.java", "diffHunk": "@@ -207,7 +207,7 @@\n \t\t@Override\n \t\tpublic Stream<? extends Scannable> inners() {\n \t\t\treturn Stream.concat(\n-\t\t\t\t\tlefts.values().stream(),\n+\t\t\t\t\tlefts.values().stream().map(Scannable.class::cast),", "originalCommit": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyNzAyMg==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r447327022", "bodyText": "I'm not too sure, tangent, inners should have its own attribute (and delegate to it on the Scannable contract).\nWill update in another PR if we want", "author": "smaldini", "createdAt": "2020-06-30T00:01:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQxODY3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA3MzI0Nw==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449073247", "bodyText": "this should definitely NOT be Scannable.class::cast then, but from. otherwise we'll be sure to get ClassCastException at some point in the future.", "author": "simonbasle", "createdAt": "2020-07-02T15:12:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQxODY3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNDg0MQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449134841", "bodyText": "good catch", "author": "smaldini", "createdAt": "2020-07-02T16:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQxODY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQyMDU3OQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445420579", "bodyText": "no need for the from if Sink becomes Scannable (this comment is relevant to several other files, I haven't commented on all of them)", "author": "simonbasle", "createdAt": "2020-06-25T09:15:34Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxWindow.java", "diffHunk": "@@ -445,18 +443,18 @@ public Object scanUnsafe(Attr key) {\n \n \t\t@Override\n \t\tpublic Stream<? extends Scannable> inners() {\n-\t\t\treturn Stream.of(window);\n+\t\t\treturn Stream.of(Scannable.from(window));", "originalCommit": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQyNDg2Nw==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445424867", "bodyText": "remove either in both overloads javadocs", "author": "simonbasle", "createdAt": "2020-06-25T09:22:41Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxProcessor.java", "diffHunk": "@@ -203,7 +203,7 @@ public Context currentContext() {\n \t * </ul>\n \t *\n \t * @return a serializing {@link FluxSink}\n-\t * @deprecated Prefer clear cut usage of either {@link Processors} or {@link Sinks}, to be removed in 3.5\n+\t * @deprecated Prefer clear cut usage of either {@link Sinks}, to be removed in 3.5", "originalCommit": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQyNzE4Mw==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445427183", "bodyText": "should we deprecate the next/complete/error methods in favor of the emit ones? contrary to MonoSink, these don't seem to provide more value / guidance to the user. (on MonoSink the methods help you respect the mono contract). cc @reactor/core-team", "author": "simonbasle", "createdAt": "2020-06-25T09:26:44Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSink.java", "diffHunk": "@@ -33,9 +34,29 @@\n  */\n public interface FluxSink<T> extends Sink<T> {\n \n-\t@Override\n+\t/**\n+\t * Emit a non-null element, generating an {@link Subscriber#onNext(Object) onNext} signal.", "originalCommit": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyNzYwMg==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r447327602", "bodyText": "I'd tend to agree, you still have some chaining value out of next but error and complete are just there to align semantically with next. To be reviewed in a subsequent PR imo", "author": "smaldini", "createdAt": "2020-06-30T00:03:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQyNzE4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExMDIxMA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449110210", "bodyText": "tracking in #2243", "author": "simonbasle", "createdAt": "2020-07-02T15:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQyNzE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQyOTAzOQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445429039", "bodyText": "note : will need to document the dropping behavior (in case of return false)", "author": "simonbasle", "createdAt": "2020-06-25T09:29:50Z", "path": "reactor-core/src/main/java/reactor/core/publisher/MonoSink.java", "diffHunk": "@@ -55,11 +55,18 @@\n \tvoid success(@Nullable T value);\n \n \t/**\n-\t * Terminate with the given value without requiring {@link #complete()} to be explicitly called.\n+\t * @see #emitError(Throwable)\n+\t */\n+\tvoid error(Throwable e);\n+\n+\t/**\n+\t * Terminate with the given value without requiring {@link #emitComplete()} to be explicitly called.", "originalCommit": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyODg1MA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r447328850", "bodyText": "Agree - Being consistent here with the hook there and processor/sink. That might be a separate PR to Improve documentation on Dropping behaviors.", "author": "smaldini", "createdAt": "2020-06-30T00:07:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQyOTAzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQzMDAxNA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445430014", "bodyText": "let's use completion rather than emission which is a bit too tied to the notion of emitting an element for the docs IMO.", "author": "simonbasle", "createdAt": "2020-06-25T09:31:30Z", "path": "reactor-core/src/main/java/reactor/core/publisher/Sink.java", "diffHunk": "@@ -36,17 +37,19 @@\n \t * signal.\n \t *\n \t * @see Subscriber#onComplete()\n+\t * @return true if emission succeeded (the sink was not previously terminated)", "originalCommit": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQzMTEwNg==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445431106", "bodyText": "let's use sequence could be failed rather than emission succeeded which is a bit too tied to the notion of emitting an element for the docs IMO. Plus the word succeeded on an error method is a bit confusing.", "author": "simonbasle", "createdAt": "2020-06-25T09:33:18Z", "path": "reactor-core/src/main/java/reactor/core/publisher/Sink.java", "diffHunk": "@@ -36,17 +37,19 @@\n \t * signal.\n \t *\n \t * @see Subscriber#onComplete()\n+\t * @return true if emission succeeded (the sink was not previously terminated)\n \t */\n-\tvoid complete();\n+\tboolean emitComplete();\n \n \t/**\n \t * Fail the sequence, generating an {@link Subscriber#onError(Throwable) onError}\n \t * signal.\n \t *\n \t * @see Subscriber#onError(Throwable)\n \t * @param e the exception to signal, not null\n+\t * @return true if emission succeeded (the sink was not previously terminated)", "originalCommit": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQzNDc5OA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445434798", "bodyText": "I still think this inconsistency in behavior between what happens before the FIRST subscriber and what happens to ADDITIONAL subscribers can be surprising, and so it should be made a little bit more explicit. Maybe re-introduce the <li> but put it first in the list? Like \"What happens before the first subscription\" vs \"What happens when more subscribers subscribe\" rather than \"Without subscriber\"vs\"Replaying\" ?", "author": "simonbasle", "createdAt": "2020-06-25T09:39:36Z", "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -47,25 +53,37 @@ private Sinks() { }\n \t */\n \t@SuppressWarnings(\"deprecation\")\n \tpublic static <T> Sink<T> multicast() {\n-\t\treturn new ProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t\tEmitterProcessor<T> processor = EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE);\n+\t\treturn SinksHelper.toSink(processor, processor);\n \t}\n \n \t/**\n \t * A {@link Sink} with the following characteristics:\n \t * <ul>\n \t *     <li>Multicast</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Backpressure : this sink is not able to honor downstream demand and will emit `onError` if there is a mismatch.</li>\n \t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n-\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n-\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n-\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first", "originalCommit": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQzNzI3Mw==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445437273", "bodyText": "add a private ctor", "author": "simonbasle", "createdAt": "2020-06-25T09:43:52Z", "path": "reactor-core/src/main/java/reactor/core/publisher/SinksHelper.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package reactor.core.publisher;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Disposable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.function.Consumer;\n+\n+final class SinksHelper implements Sinks.UnsafeSinks {\n+\tstatic final SinksHelper INSTANCE = new SinksHelper();\n+", "originalCommit": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ0MjA4OA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445442088", "bodyText": "rename to serialize? (like in Operators.serialize(subscriber))", "author": "simonbasle", "createdAt": "2020-06-25T09:52:16Z", "path": "reactor-core/src/main/java/reactor/core/publisher/SinksHelper.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package reactor.core.publisher;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Disposable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.function.Consumer;\n+\n+final class SinksHelper implements Sinks.UnsafeSinks {\n+\tstatic final SinksHelper INSTANCE = new SinksHelper();\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> unicast() {\n+\t\treturn UnicastProcessor.create();\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> multicast() {\n+\t\treturn EmitterProcessor.create();\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replayAll() {\n+\t\treturn ReplayProcessor.create();\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replay(int historySize) {\n+\t\treturn ReplayProcessor.create(historySize);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic  <T> Sink<T> replayTimeout(Duration maxAge) {\n+\t\treturn ReplayProcessor.createTimeout(maxAge);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replaySizeAndTimeout(int historySize, Duration maxAge) {\n+\t\treturn ReplayProcessor.createSizeAndTimeout(historySize, maxAge);\n+\t}\n+\n+\t// == unicast ==\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> unicast(Queue<T> queue) {\n+\t\treturn UnicastProcessor.create(queue);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> unicast(Queue<T> queue, Disposable endCallback) {\n+\t\treturn UnicastProcessor.create(queue, endCallback);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> unicast(Queue<T> queue, Consumer<? super T> onOverflow, Disposable endCallback) {\n+\t\treturn UnicastProcessor.create(queue, onOverflow, endCallback);\n+\t}\n+\n+\t// == direct (less used) ==\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> multicastNoBackpressure() {\n+\t\treturn DirectProcessor.create();\n+\t}\n+\n+\t// == emitter ==\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> multicast(boolean autoCancel) {\n+\t\treturn EmitterProcessor.create(autoCancel);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> multicast(int bufferSize) {\n+\t\treturn EmitterProcessor.create(bufferSize);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> multicast(int bufferSize, boolean autoCancel) {\n+\t\treturn EmitterProcessor.create(bufferSize, autoCancel);\n+\t}\n+\n+\t// == replay ==\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replayLatest() {\n+\t\treturn ReplayProcessor.cacheLast();\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replayLatestOrDefault(@Nullable T value) {\n+\t\treturn ReplayProcessor.cacheLastOrDefault(value);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replay(int historySize, boolean unbounded) {\n+\t\treturn ReplayProcessor.create(historySize, unbounded);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replayTimeout(Duration maxAge, Scheduler scheduler) {\n+\t\treturn ReplayProcessor.createTimeout(maxAge, scheduler);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replaySizeAndTimeout(int historySize, Duration maxAge, Scheduler scheduler) {\n+\t\treturn ReplayProcessor.createSizeAndTimeout(historySize, maxAge, scheduler);\n+\t}\n+\n+\tstatic <T> Sink<T> toSink(Sink<T> sink, CoreSubscriber<T> contextHolder) {", "originalCommit": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ0MjQ3Ng==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445442476", "bodyText": "rename to SerializedSinkWithContext ?", "author": "simonbasle", "createdAt": "2020-06-25T09:52:55Z", "path": "reactor-core/src/main/java/reactor/core/publisher/SinksHelper.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package reactor.core.publisher;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Disposable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.function.Consumer;\n+\n+final class SinksHelper implements Sinks.UnsafeSinks {\n+\tstatic final SinksHelper INSTANCE = new SinksHelper();\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> unicast() {\n+\t\treturn UnicastProcessor.create();\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> multicast() {\n+\t\treturn EmitterProcessor.create();\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replayAll() {\n+\t\treturn ReplayProcessor.create();\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replay(int historySize) {\n+\t\treturn ReplayProcessor.create(historySize);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic  <T> Sink<T> replayTimeout(Duration maxAge) {\n+\t\treturn ReplayProcessor.createTimeout(maxAge);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replaySizeAndTimeout(int historySize, Duration maxAge) {\n+\t\treturn ReplayProcessor.createSizeAndTimeout(historySize, maxAge);\n+\t}\n+\n+\t// == unicast ==\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> unicast(Queue<T> queue) {\n+\t\treturn UnicastProcessor.create(queue);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> unicast(Queue<T> queue, Disposable endCallback) {\n+\t\treturn UnicastProcessor.create(queue, endCallback);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> unicast(Queue<T> queue, Consumer<? super T> onOverflow, Disposable endCallback) {\n+\t\treturn UnicastProcessor.create(queue, onOverflow, endCallback);\n+\t}\n+\n+\t// == direct (less used) ==\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> multicastNoBackpressure() {\n+\t\treturn DirectProcessor.create();\n+\t}\n+\n+\t// == emitter ==\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> multicast(boolean autoCancel) {\n+\t\treturn EmitterProcessor.create(autoCancel);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> multicast(int bufferSize) {\n+\t\treturn EmitterProcessor.create(bufferSize);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> multicast(int bufferSize, boolean autoCancel) {\n+\t\treturn EmitterProcessor.create(bufferSize, autoCancel);\n+\t}\n+\n+\t// == replay ==\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replayLatest() {\n+\t\treturn ReplayProcessor.cacheLast();\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replayLatestOrDefault(@Nullable T value) {\n+\t\treturn ReplayProcessor.cacheLastOrDefault(value);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replay(int historySize, boolean unbounded) {\n+\t\treturn ReplayProcessor.create(historySize, unbounded);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replayTimeout(Duration maxAge, Scheduler scheduler) {\n+\t\treturn ReplayProcessor.createTimeout(maxAge, scheduler);\n+\t}\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic <T> Sink<T> replaySizeAndTimeout(int historySize, Duration maxAge, Scheduler scheduler) {\n+\t\treturn ReplayProcessor.createSizeAndTimeout(historySize, maxAge, scheduler);\n+\t}\n+\n+\tstatic <T> Sink<T> toSink(Sink<T> sink, CoreSubscriber<T> contextHolder) {\n+\t\treturn new FluxProcessorSink<>(sink, contextHolder);\n+\t}\n+\n+\tstatic final class FluxProcessorSink<T> extends FluxCreate.SerializedSink<T, Sink<T>> {", "originalCommit": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ0ODYyNQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445448625", "bodyText": "since the sink isn't really used, can also be replaced with TestPublisher which makes it easier to assert subscribers:\n\t\tTestPublisher<Integer> testPublisher = TestPublisher.create();\n\n\t\ttestPublisher.flux().publish().autoConnect(0, cancel::set);\n\t\ttestPublisher.assertSubscribers();\n\t\t\n\t\tcancel.get().dispose();\n\t\ttestPublisher.assertNoSubscribers();", "author": "simonbasle", "createdAt": "2020-06-25T10:03:58Z", "path": "reactor-core/src/test/java/reactor/core/publisher/FluxAutoConnectTest.java", "diffHunk": "@@ -43,42 +43,42 @@ public void constructors() {\n \t\n \t@Test\n \tpublic void connectImmediately() {\n-\t\tFluxProcessor<Integer, Integer> e = Processors.multicast();\n+\t\tSink<Integer> e = Sinks.multicast();", "originalCommit": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ1MTg3MQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445451871", "bodyText": "let's use Sinks.multicast(), replay(0) being kind of a corner case.\nAlso change the corresponding snippet in the asciidoc!", "author": "simonbasle", "createdAt": "2020-06-25T10:10:02Z", "path": "reactor-core/src/test/java/reactor/guide/GuideTests.java", "diffHunk": "@@ -201,21 +201,20 @@ public void advancedCold() {\n \n \t@Test\n \tpublic void advancedHot() {\n-\t\tSink<String> hotSource = Sinks.multicastNoWarmup();\n+\t\tSink<String> hotSource = Sinks.replay(0);", "originalCommit": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ1NDA3MA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445454070", "bodyText": "Add a note that it is better suited to be viewed as a toMono() ?", "author": "simonbasle", "createdAt": "2020-06-25T10:14:14Z", "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -47,25 +53,37 @@ private Sinks() { }\n \t */\n \t@SuppressWarnings(\"deprecation\")\n \tpublic static <T> Sink<T> multicast() {\n-\t\treturn new ProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t\tEmitterProcessor<T> processor = EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE);\n+\t\treturn SinksHelper.toSink(processor, processor);\n \t}\n \n \t/**\n \t * A {@link Sink} with the following characteristics:\n \t * <ul>\n \t *     <li>Multicast</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Backpressure : this sink is not able to honor downstream demand and will emit `onError` if there is a mismatch.</li>\n \t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n-\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n-\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n-\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscribe.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> Sink<T> multicastNoBackpressure() {\n+\t\tDirectProcessor<T> processor = DirectProcessor.create();\n+\t\treturn SinksHelper.toSink(processor, processor);\n+\t}\n+\n+\t/**\n+\t * A {@link Sink} with the following characteristics:\n+\t * <ul>", "originalCommit": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ1NTAwOQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445455009", "bodyText": "put it next to promise, as both behave closer to Mono. That makes me wonder if it would be better backed by a MonoProcessor? likely to be used as toMono() more often and thus benefit from the 0-overhead conversion? or maybe add a constructor parameter to DirectProcessor that allows its toMono() method to do Mono.fromDirect(this) rather than next()?", "author": "simonbasle", "createdAt": "2020-06-25T10:16:03Z", "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -47,25 +53,37 @@ private Sinks() { }\n \t */\n \t@SuppressWarnings(\"deprecation\")\n \tpublic static <T> Sink<T> multicast() {\n-\t\treturn new ProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t\tEmitterProcessor<T> processor = EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE);\n+\t\treturn SinksHelper.toSink(processor, processor);\n \t}\n \n \t/**\n \t * A {@link Sink} with the following characteristics:\n \t * <ul>\n \t *     <li>Multicast</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Backpressure : this sink is not able to honor downstream demand and will emit `onError` if there is a mismatch.</li>\n \t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n-\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n-\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n-\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscribe.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> Sink<T> multicastNoBackpressure() {\n+\t\tDirectProcessor<T> processor = DirectProcessor.create();\n+\t\treturn SinksHelper.toSink(processor, processor);\n+\t}\n+\n+\t/**\n+\t * A {@link Sink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink does not need any demand since it can only signal error or completion</li>\n+\t *     <li>Replaying: Replay the terminal signal (error or complete).</li>\n \t * </ul>\n-\t * <p>\n-\t * <img class=\"marble\" src=\"doc-files/marbles/sinkNoWarmup.svg\" alt=\"\">\n \t */\n \t@SuppressWarnings(\"deprecation\")\n-\tpublic static <T> Sink<T> multicastNoWarmup() {\n-\t\treturn new ProcessorSink<>(ReplayProcessor.create(0));\n+\tpublic static Sink<Void> coordinator() {", "originalCommit": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA4NDE0NQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449084145", "bodyText": "wdyt about the suggestion of changing from DirectProcessor (which can always be created via multicast().onBackpressureError() anyways) to MonoProcessor @smaldini ?", "author": "simonbasle", "createdAt": "2020-07-02T15:27:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ1NTAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNDczNQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449134735", "bodyText": "In a separate PR we will have VoidProcessor for this", "author": "smaldini", "createdAt": "2020-07-02T16:27:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ1NTAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ1NTI1MQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445455251", "bodyText": "add  (which is implicit). at the end", "author": "simonbasle", "createdAt": "2020-06-25T10:16:29Z", "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -112,92 +132,73 @@ private Sinks() { }\n \t */\n \t@SuppressWarnings(\"deprecation\")\n \tpublic static <T> Sink<T> unicast() {\n-\t\treturn new ProcessorSink<>(UnicastProcessor.create());\n+\t\tUnicastProcessor<T> processor = UnicastProcessor.create();\n+\t\treturn SinksHelper.toSink(processor, processor);\n \t}\n \n \t/**\n \t * A {@link Sink} that works like a conceptual Promise: it can be completed\n \t * with or without a value at any time, but only once. This completion is replayed to late subscribers.\n-\t * Calling {@link Sink#next(Object)} is enough and does not require a following {@link Sink#complete()}.\n+\t * Calling {@link Sink#emitNext(Object)} is enough and does not require a following {@link Sink#emitComplete()}.", "originalCommit": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ1NTc4NQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445455785", "bodyText": "also add that as a result the Sinks closely follows the Mono contract and is better suited to be viewed as toMono() (hinting at 0-overhead conversion to mono vs overhead conversion to flux)", "author": "simonbasle", "createdAt": "2020-06-25T10:17:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ1NTI1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ1NjIxMw==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r445456213", "bodyText": "change to \"and expect usage to be externally synchronized so as to respect\"", "author": "simonbasle", "createdAt": "2020-06-25T10:18:23Z", "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -112,92 +132,73 @@ private Sinks() { }\n \t */\n \t@SuppressWarnings(\"deprecation\")\n \tpublic static <T> Sink<T> unicast() {\n-\t\treturn new ProcessorSink<>(UnicastProcessor.create());\n+\t\tUnicastProcessor<T> processor = UnicastProcessor.create();\n+\t\treturn SinksHelper.toSink(processor, processor);\n \t}\n \n \t/**\n \t * A {@link Sink} that works like a conceptual Promise: it can be completed\n \t * with or without a value at any time, but only once. This completion is replayed to late subscribers.\n-\t * Calling {@link Sink#next(Object)} is enough and does not require a following {@link Sink#complete()}.\n+\t * Calling {@link Sink#emitNext(Object)} is enough and does not require a following {@link Sink#emitComplete()}.\n \t */\n \tpublic static <T> Sink<T> promise() {\n-\t\treturn new MonoProcessorSink<>(MonoProcessor.create());\n+\t\treturn MonoProcessor.create();\n \t}\n \n-\t// == concrete classes ==\n-\n-\tstatic final class ProcessorSink<T>\n-\t\t\timplements Sink<T> {\n-\n-\t\tfinal FluxSink<T>         delegateSink;\n-\t\tfinal FluxProcessor<T, T> processor;\n-\n-\t\t@SuppressWarnings(\"deprecation\")\n-\t\tProcessorSink(FluxProcessor<T, T> processor) {\n-\t\t\tthis.processor = processor;\n-\t\t\tthis.delegateSink = processor.sink();\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic Flux<T> toFlux() {\n-\t\t\treturn Flux.from(processor);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic Mono<T> toMono() {\n-\t\t\treturn Mono.from(processor);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void complete() {\n-\t\t\tdelegateSink.complete();\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void error(Throwable e) {\n-\t\t\tdelegateSink.error(e);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic Sink<T> next(T t) {\n-\t\t\tdelegateSink.next(t);\n-\t\t\treturn this;\n-\t\t}\n+\t/**\n+\t * Return unsafe {@link Sink} that are not serialized and expect the signal producer to respect", "originalCommit": "3d171d8870cd3d3ee46d5fc06aac05b98ff3046d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5981100d27d02470de0b807433e63042353be2d0", "url": "https://github.com/reactor/reactor-core/commit/5981100d27d02470de0b807433e63042353be2d0", "message": "Add Sinks builders and address some PR feedback\n- Reuse onBackpressureXxx naming conventions\n- deprecate FluxProcessor#switchOnNext\n- add FluxProcessor#isIdentityProcessor\n- add FluxProcessor#fromSink", "committedDate": "2020-07-01T01:36:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAxMzY2MQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449013661", "bodyText": "shouldn't it be downstream?", "author": "simonbasle", "createdAt": "2020-07-02T13:46:35Z", "path": "reactor-core/src/main/java/reactor/core/publisher/DelegateSinkFluxProcessor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Scannable;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Stephane Maldini\n+ */\n+final class DelegateSinkFluxProcessor<IN> extends FluxProcessor<IN, IN> {\n+\n+\tfinal Flux<IN> downstream;\n+\tfinal Sink<IN> upstream;\n+\n+\tDelegateSinkFluxProcessor(Flux<IN> downstream,\n+\t\t\t\t\t\t\t  Sink<IN> upstream) {\n+\t\tthis.downstream = Objects.requireNonNull(downstream, \"Downstream must not be null\");\n+\t\tthis.upstream = Objects.requireNonNull(upstream, \"Upstream must not be null\");\n+\t}\n+\n+\t@Override\n+\tpublic Context currentContext() {\n+\t\tif(upstream instanceof CoreSubscriber){", "originalCommit": "5981100d27d02470de0b807433e63042353be2d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAxNTI4OQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449015289", "bodyText": "there seem to be a reversion of downstream and upstream terms compared to their usual meaning, maybe different terms would be better. ie do we expect the downstream to basically be the same as Sink.toFlux() ?", "author": "simonbasle", "createdAt": "2020-07-02T13:48:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAxMzY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNTkxMg==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449135912", "bodyText": "The same existed in FluxProcessor but yeah upstream is the receiving side and downstream the producing side here. Can change to less ambiguous term tho e.g. sink and flux", "author": "smaldini", "createdAt": "2020-07-02T16:29:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAxMzY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3NDU0Mw==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449574543", "bodyText": "yeah, had to double-back during the review. I think it would benefit readability for our future selves \ud83d\ude04", "author": "simonbasle", "createdAt": "2020-07-03T13:07:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAxMzY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyMTI3NA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449021274", "bodyText": "nitpick: this looks like - 1 (a subtraction): replace with\nProvide unicast sinks: at most one `Subscriber` per `Sink`", "author": "simonbasle", "createdAt": "2020-07-02T13:57:20Z", "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -87,118 +78,315 @@ private Sinks() { }\n \t}\n \n \t/**\n-\t * A {@link Sink} with the following characteristics:\n-\t * <ul>\n-\t *     <li>Multicast</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n-\t *     <li>Replaying: by {@code historySize}. Keeps the last {@code historySize} elements and\n-\t *     replays them instantly to new subscribers before continuing with \"live\" elements.</li>\n-\t *     <li>Without {@link Subscriber}: buffers enough elements pushed without a subscriber to\n-\t *     honor the {@code historySize}.</li>\n-\t * </ul>\n+\t * A {@link Sink} that works like a conceptual Promise: it can be completed\n+\t * with or without a value at any time, but only once. This completion is replayed to late subscribers.\n+\t * Calling {@link Sink#emitNext(Object)} is enough and will implicitly produce a follow-up {@link Sink#emitComplete()}.\n+\t * As a result the Sink closely follows the {@link Mono} contract and is better suited to be consumed via {@link Sink#toMono}\n \t */\n-\t@SuppressWarnings(\"deprecation\")\n-\tpublic static <T> Sink<T> replay(int historySize) {\n-\t\tReplayProcessor<T> processor = ReplayProcessor.create(historySize);\n-\t\treturn SinksHelper.toSink(processor, processor);\n+\tpublic static <T> Sink<T> promise() {\n+\t\treturn MonoProcessor.create();\n \t}\n \n \t/**\n-\t * A {@link Sink} with the following characteristics:\n-\t * <ul>\n-\t *     <li>Multicast</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n-\t *     <li>Replaying: all elements pushed to this sink are replayed to new subscribers.</li>\n-\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered,\n-\t *     even when there is no subscriber.</li>\n-\t * </ul>\n+\t * Return a builder for more advanced use cases such as building operators.\n+\t * Unsafe {@link Sink} are not serialized and expect usage to be externally synchronized to respect\n+\t * the Reactive Streams specification. The builder also allows to create {@link FluxProcessor} and {@link MonoProcessor}.\n+\t *\n+\t * @return {@link UnsafeSpec}\n \t */\n-\t@SuppressWarnings(\"deprecation\")\n-\tpublic static <T> Sink<T> replayAll() {\n-\t\tReplayProcessor<T> processor = ReplayProcessor.create();\n-\t\treturn SinksHelper.toSink(processor, processor);\n+\tpublic static UnsafeSpec unsafe() {\n+\t\treturn SinksSpecs.UNSAFE_SPEC;\n \t}\n \n \t/**\n-\t * A {@link Sink} with the following characteristics:\n-\t * <ul>\n-\t *     <li><strong>Unicast</strong>: contrary to most other {@link Sink}, the\n-\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n-\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n-\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n-\t *     be replayed once the {@link Subscriber} subscribes.</li>\n-\t * </ul>\n+\t * A builder for more advanced use cases such as building operators.\n+\t * Unsafe {@link Sink} are not serialized and expect usage to be externally synchronized to respect\n+\t * the Reactive Streams specification. The builder also allows to create {@link FluxProcessor} and {@link MonoProcessor}.\n \t */\n-\t@SuppressWarnings(\"deprecation\")\n-\tpublic static <T> Sink<T> unicast() {\n-\t\tUnicastProcessor<T> processor = UnicastProcessor.create();\n-\t\treturn SinksHelper.toSink(processor, processor);\n+\tpublic interface UnsafeSpec {\n+\t\t/**\n+\t\t * Help building {@link Sink} that will broadcast signals to a single {@link Subscriber}\n+\t\t *\n+\t\t * @return {@link UnicastSpec}\n+\t\t */\n+\t\tUnicastSpec unicast();\n+\n+\t\t/**\n+\t\t * Help building {@link Sink} that will broadcast signals to multiple {@link Subscriber}\n+\t\t *\n+\t\t * @return {@link MulticastSpec}\n+\t\t */\n+\t\tMulticastSpec multicast();\n+\n+\t\t/**\n+\t\t * Help building {@link Sink} that will broadcast signals to multiple {@link Subscriber} with the ability to retain\n+\t\t * and replay all or an arbitrary number of elements.\n+\t\t *\n+\t\t * @return {@link MulticastReplaySpec}\n+\t\t */\n+\t\tMulticastReplaySpec replay();\n \t}\n \n \t/**\n-\t * A {@link Sink} that works like a conceptual Promise: it can be completed\n-\t * with or without a value at any time, but only once. This completion is replayed to late subscribers.\n-\t * Calling {@link Sink#emitNext(Object)} is enough and does not require a following {@link Sink#emitComplete()}.\n+\t * Provide unicast - 1 sink, 1 {@link Subscriber}", "originalCommit": "5981100d27d02470de0b807433e63042353be2d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyMTc1NQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449021755", "bodyText": "same phrasing remark as above", "author": "simonbasle", "createdAt": "2020-07-02T13:58:00Z", "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -87,118 +78,315 @@ private Sinks() { }\n \t}\n \n \t/**\n-\t * A {@link Sink} with the following characteristics:\n-\t * <ul>\n-\t *     <li>Multicast</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n-\t *     <li>Replaying: by {@code historySize}. Keeps the last {@code historySize} elements and\n-\t *     replays them instantly to new subscribers before continuing with \"live\" elements.</li>\n-\t *     <li>Without {@link Subscriber}: buffers enough elements pushed without a subscriber to\n-\t *     honor the {@code historySize}.</li>\n-\t * </ul>\n+\t * A {@link Sink} that works like a conceptual Promise: it can be completed\n+\t * with or without a value at any time, but only once. This completion is replayed to late subscribers.\n+\t * Calling {@link Sink#emitNext(Object)} is enough and will implicitly produce a follow-up {@link Sink#emitComplete()}.\n+\t * As a result the Sink closely follows the {@link Mono} contract and is better suited to be consumed via {@link Sink#toMono}\n \t */\n-\t@SuppressWarnings(\"deprecation\")\n-\tpublic static <T> Sink<T> replay(int historySize) {\n-\t\tReplayProcessor<T> processor = ReplayProcessor.create(historySize);\n-\t\treturn SinksHelper.toSink(processor, processor);\n+\tpublic static <T> Sink<T> promise() {\n+\t\treturn MonoProcessor.create();\n \t}\n \n \t/**\n-\t * A {@link Sink} with the following characteristics:\n-\t * <ul>\n-\t *     <li>Multicast</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n-\t *     <li>Replaying: all elements pushed to this sink are replayed to new subscribers.</li>\n-\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered,\n-\t *     even when there is no subscriber.</li>\n-\t * </ul>\n+\t * Return a builder for more advanced use cases such as building operators.\n+\t * Unsafe {@link Sink} are not serialized and expect usage to be externally synchronized to respect\n+\t * the Reactive Streams specification. The builder also allows to create {@link FluxProcessor} and {@link MonoProcessor}.\n+\t *\n+\t * @return {@link UnsafeSpec}\n \t */\n-\t@SuppressWarnings(\"deprecation\")\n-\tpublic static <T> Sink<T> replayAll() {\n-\t\tReplayProcessor<T> processor = ReplayProcessor.create();\n-\t\treturn SinksHelper.toSink(processor, processor);\n+\tpublic static UnsafeSpec unsafe() {\n+\t\treturn SinksSpecs.UNSAFE_SPEC;\n \t}\n \n \t/**\n-\t * A {@link Sink} with the following characteristics:\n-\t * <ul>\n-\t *     <li><strong>Unicast</strong>: contrary to most other {@link Sink}, the\n-\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n-\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n-\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n-\t *     be replayed once the {@link Subscriber} subscribes.</li>\n-\t * </ul>\n+\t * A builder for more advanced use cases such as building operators.\n+\t * Unsafe {@link Sink} are not serialized and expect usage to be externally synchronized to respect\n+\t * the Reactive Streams specification. The builder also allows to create {@link FluxProcessor} and {@link MonoProcessor}.\n \t */\n-\t@SuppressWarnings(\"deprecation\")\n-\tpublic static <T> Sink<T> unicast() {\n-\t\tUnicastProcessor<T> processor = UnicastProcessor.create();\n-\t\treturn SinksHelper.toSink(processor, processor);\n+\tpublic interface UnsafeSpec {\n+\t\t/**\n+\t\t * Help building {@link Sink} that will broadcast signals to a single {@link Subscriber}\n+\t\t *\n+\t\t * @return {@link UnicastSpec}\n+\t\t */\n+\t\tUnicastSpec unicast();\n+\n+\t\t/**\n+\t\t * Help building {@link Sink} that will broadcast signals to multiple {@link Subscriber}\n+\t\t *\n+\t\t * @return {@link MulticastSpec}\n+\t\t */\n+\t\tMulticastSpec multicast();\n+\n+\t\t/**\n+\t\t * Help building {@link Sink} that will broadcast signals to multiple {@link Subscriber} with the ability to retain\n+\t\t * and replay all or an arbitrary number of elements.\n+\t\t *\n+\t\t * @return {@link MulticastReplaySpec}\n+\t\t */\n+\t\tMulticastReplaySpec replay();\n \t}\n \n \t/**\n-\t * A {@link Sink} that works like a conceptual Promise: it can be completed\n-\t * with or without a value at any time, but only once. This completion is replayed to late subscribers.\n-\t * Calling {@link Sink#emitNext(Object)} is enough and does not require a following {@link Sink#emitComplete()}.\n+\t * Provide unicast - 1 sink, 1 {@link Subscriber}\n \t */\n-\tpublic static <T> Sink<T> promise() {\n-\t\treturn MonoProcessor.create();\n+\tpublic interface UnicastSpec {\n+\t\t/**\n+\t\t * A {@link Sink} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li><strong>Unicast</strong>: contrary to most other {@link Sink}, the\n+\t\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n+\t\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t\t * </ul>\n+\t\t */\n+\t\t<T> Sink<T> onBackpressureBuffer();\n+\n+\t\t/**\n+\t\t * A {@link Sink} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li><strong>Unicast</strong>: contrary to most other {@link Sink}, the\n+\t\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t\t *    <li>Without {@link Subscriber}: depending on the queue, all elements pushed to this sink are remembered and will\n+\t\t * \t\t  be replayed once the {@link Subscriber} subscribes.</li>\n+\t\t * </ul>\n+\t\t *\n+\t\t * @param queue an arbitrary queue to use that must at least support Single Producer / Single Consumer semantics\n+\t\t */\n+\t\t<T> Sink<T> onBackpressureBuffer(Queue<T> queue);\n+\n+\t\t/**\n+\t\t * A {@link Sink} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li><strong>Unicast</strong>: contrary to most other {@link Sink}, the\n+\t\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t\t *     <li>Without {@link Subscriber}: depending on the queue, all elements pushed to this sink are remembered and will\n+\t\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t\t * </ul>\n+\t\t *\n+\t\t * @param queue an arbitrary queue to use that must at least support Single Producer / Single Consumer semantics\n+\t\t * @param endCallback when a terminal signal is observed: error, complete or cancel\n+\t\t */\n+\t\t<T> Sink<T> onBackpressureBuffer(Queue<T> queue, Disposable endCallback);\n \t}\n \n \t/**\n-\t * Return unsafe {@link Sink} that are not serialized and expect the signal producer to respect\n-\t * the Reactive Streams specification.\n-\t *\n-\t * @return {@link UnsafeSinks}\n+\t * Provide multicast - 1 sink, N {@link Subscriber}", "originalCommit": "5981100d27d02470de0b807433e63042353be2d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyMjgyNA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449022824", "bodyText": "According to the javadoc above, there is no exception for the first subscribe (elements are discarded if pushed before any Subscriber) => the last sentence should be removed", "author": "simonbasle", "createdAt": "2020-07-02T13:59:35Z", "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -87,118 +78,315 @@ private Sinks() { }\n \t}\n \n \t/**\n-\t * A {@link Sink} with the following characteristics:\n-\t * <ul>\n-\t *     <li>Multicast</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n-\t *     <li>Replaying: by {@code historySize}. Keeps the last {@code historySize} elements and\n-\t *     replays them instantly to new subscribers before continuing with \"live\" elements.</li>\n-\t *     <li>Without {@link Subscriber}: buffers enough elements pushed without a subscriber to\n-\t *     honor the {@code historySize}.</li>\n-\t * </ul>\n+\t * A {@link Sink} that works like a conceptual Promise: it can be completed\n+\t * with or without a value at any time, but only once. This completion is replayed to late subscribers.\n+\t * Calling {@link Sink#emitNext(Object)} is enough and will implicitly produce a follow-up {@link Sink#emitComplete()}.\n+\t * As a result the Sink closely follows the {@link Mono} contract and is better suited to be consumed via {@link Sink#toMono}\n \t */\n-\t@SuppressWarnings(\"deprecation\")\n-\tpublic static <T> Sink<T> replay(int historySize) {\n-\t\tReplayProcessor<T> processor = ReplayProcessor.create(historySize);\n-\t\treturn SinksHelper.toSink(processor, processor);\n+\tpublic static <T> Sink<T> promise() {\n+\t\treturn MonoProcessor.create();\n \t}\n \n \t/**\n-\t * A {@link Sink} with the following characteristics:\n-\t * <ul>\n-\t *     <li>Multicast</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n-\t *     <li>Replaying: all elements pushed to this sink are replayed to new subscribers.</li>\n-\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered,\n-\t *     even when there is no subscriber.</li>\n-\t * </ul>\n+\t * Return a builder for more advanced use cases such as building operators.\n+\t * Unsafe {@link Sink} are not serialized and expect usage to be externally synchronized to respect\n+\t * the Reactive Streams specification. The builder also allows to create {@link FluxProcessor} and {@link MonoProcessor}.\n+\t *\n+\t * @return {@link UnsafeSpec}\n \t */\n-\t@SuppressWarnings(\"deprecation\")\n-\tpublic static <T> Sink<T> replayAll() {\n-\t\tReplayProcessor<T> processor = ReplayProcessor.create();\n-\t\treturn SinksHelper.toSink(processor, processor);\n+\tpublic static UnsafeSpec unsafe() {\n+\t\treturn SinksSpecs.UNSAFE_SPEC;\n \t}\n \n \t/**\n-\t * A {@link Sink} with the following characteristics:\n-\t * <ul>\n-\t *     <li><strong>Unicast</strong>: contrary to most other {@link Sink}, the\n-\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n-\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n-\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n-\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n-\t *     be replayed once the {@link Subscriber} subscribes.</li>\n-\t * </ul>\n+\t * A builder for more advanced use cases such as building operators.\n+\t * Unsafe {@link Sink} are not serialized and expect usage to be externally synchronized to respect\n+\t * the Reactive Streams specification. The builder also allows to create {@link FluxProcessor} and {@link MonoProcessor}.\n \t */\n-\t@SuppressWarnings(\"deprecation\")\n-\tpublic static <T> Sink<T> unicast() {\n-\t\tUnicastProcessor<T> processor = UnicastProcessor.create();\n-\t\treturn SinksHelper.toSink(processor, processor);\n+\tpublic interface UnsafeSpec {\n+\t\t/**\n+\t\t * Help building {@link Sink} that will broadcast signals to a single {@link Subscriber}\n+\t\t *\n+\t\t * @return {@link UnicastSpec}\n+\t\t */\n+\t\tUnicastSpec unicast();\n+\n+\t\t/**\n+\t\t * Help building {@link Sink} that will broadcast signals to multiple {@link Subscriber}\n+\t\t *\n+\t\t * @return {@link MulticastSpec}\n+\t\t */\n+\t\tMulticastSpec multicast();\n+\n+\t\t/**\n+\t\t * Help building {@link Sink} that will broadcast signals to multiple {@link Subscriber} with the ability to retain\n+\t\t * and replay all or an arbitrary number of elements.\n+\t\t *\n+\t\t * @return {@link MulticastReplaySpec}\n+\t\t */\n+\t\tMulticastReplaySpec replay();\n \t}\n \n \t/**\n-\t * A {@link Sink} that works like a conceptual Promise: it can be completed\n-\t * with or without a value at any time, but only once. This completion is replayed to late subscribers.\n-\t * Calling {@link Sink#emitNext(Object)} is enough and does not require a following {@link Sink#emitComplete()}.\n+\t * Provide unicast - 1 sink, 1 {@link Subscriber}\n \t */\n-\tpublic static <T> Sink<T> promise() {\n-\t\treturn MonoProcessor.create();\n+\tpublic interface UnicastSpec {\n+\t\t/**\n+\t\t * A {@link Sink} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li><strong>Unicast</strong>: contrary to most other {@link Sink}, the\n+\t\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n+\t\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t\t * </ul>\n+\t\t */\n+\t\t<T> Sink<T> onBackpressureBuffer();\n+\n+\t\t/**\n+\t\t * A {@link Sink} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li><strong>Unicast</strong>: contrary to most other {@link Sink}, the\n+\t\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t\t *    <li>Without {@link Subscriber}: depending on the queue, all elements pushed to this sink are remembered and will\n+\t\t * \t\t  be replayed once the {@link Subscriber} subscribes.</li>\n+\t\t * </ul>\n+\t\t *\n+\t\t * @param queue an arbitrary queue to use that must at least support Single Producer / Single Consumer semantics\n+\t\t */\n+\t\t<T> Sink<T> onBackpressureBuffer(Queue<T> queue);\n+\n+\t\t/**\n+\t\t * A {@link Sink} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li><strong>Unicast</strong>: contrary to most other {@link Sink}, the\n+\t\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t\t *     <li>Without {@link Subscriber}: depending on the queue, all elements pushed to this sink are remembered and will\n+\t\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t\t * </ul>\n+\t\t *\n+\t\t * @param queue an arbitrary queue to use that must at least support Single Producer / Single Consumer semantics\n+\t\t * @param endCallback when a terminal signal is observed: error, complete or cancel\n+\t\t */\n+\t\t<T> Sink<T> onBackpressureBuffer(Queue<T> queue, Disposable endCallback);\n \t}\n \n \t/**\n-\t * Return unsafe {@link Sink} that are not serialized and expect the signal producer to respect\n-\t * the Reactive Streams specification.\n-\t *\n-\t * @return {@link UnsafeSinks}\n+\t * Provide multicast - 1 sink, N {@link Subscriber}\n \t */\n-\tpublic static UnsafeSinks unsafe() {\n-\t\treturn SinksHelper.INSTANCE;\n+\tpublic interface MulticastSpec {\n+\n+\t\t/**\n+\t\t * A {@link Sink} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li>Multicast</li>\n+\t\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t\t *     elements pushed via {@link Sink#emitNext(Object)} before the first {@link Subscriber} is registered.</li>\n+\t\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t\t *     of multiple subscribers.</li>\n+\t\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t\t *     subscriber (see below).</li>\n+\t\t * </ul>\n+\t\t * <p>\n+\t\t * <img class=\"marble\" src=\"doc-files/marbles/sinkWarmup.svg\" alt=\"\">\n+\t\t */\n+\t\t<T> Sink<T> onBackpressureBuffer();\n+\n+\t\t/**\n+\t\t * A {@link Sink} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li>Multicast</li>\n+\t\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@param bufferSize}\n+\t\t *     elements pushed via {@link Sink#emitNext(Object)} before the first {@link Subscriber} is registered.</li>\n+\t\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t\t *     of multiple subscribers.</li>\n+\t\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t\t *     subscriber (see below).</li>\n+\t\t * </ul>\n+\t\t * <p>\n+\t\t * <img class=\"marble\" src=\"doc-files/marbles/sinkWarmup.svg\" alt=\"\">\n+\t\t *\n+\t\t * @param bufferSize the maximum queue size\n+\t\t */\n+\t\t<T> Sink<T> onBackpressureBuffer(int bufferSize);\n+\n+\t\t/**\n+\t\t * A {@link Sink} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li>Multicast</li>\n+\t\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@param bufferSize}\n+\t\t *     elements pushed via {@link Sink#emitNext(Object)} before the first {@link Subscriber} is registered.</li>\n+\t\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t\t *     of multiple subscribers.</li>\n+\t\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t\t *     subscriber (see below).</li>\n+\t\t * </ul>\n+\t\t * <p>\n+\t\t * <img class=\"marble\" src=\"doc-files/marbles/sinkWarmup.svg\" alt=\"\">\n+\t\t *\n+\t\t * @param bufferSize the maximum queue size\n+\t\t * @param autoCancel should the sink fully shutdowns (not publishing anymore) when the last subscriber cancels\n+\t\t */\n+\t\t<T> Sink<T> onBackpressureBuffer(int bufferSize, boolean autoCancel);\n+\n+\t\t/**\n+\t\t * A {@link Sink} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li>Multicast</li>\n+\t\t *     <li>Without {@link Subscriber}: elements pushed via {@link Sink#emitNext(Object)} are discarded</li>\n+\t\t *     <li>Backpressure : this sink is not able to honor downstream demand and will emit `onError` if there is a mismatch.</li>\n+\t\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first", "originalCommit": "5981100d27d02470de0b807433e63042353be2d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUyNzM2MA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r464527360", "bodyText": "fixed in 8cb6485", "author": "simonbasle", "createdAt": "2020-08-03T16:35:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyMjgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1MzQwMQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449053401", "bodyText": "I like the *Spec idea, but at the same time it reintroduces potential for overwhelming users, between all the available overloads.", "author": "simonbasle", "createdAt": "2020-07-02T14:43:18Z", "path": "reactor-core/src/main/java/reactor/core/publisher/SinksSpecs.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package reactor.core.publisher;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Disposable;\n+import reactor.core.Scannable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.util.Queue;\n+\n+final class SinksSpecs {\n+\tstatic final UnicastSpecImpl         UNICAST_SPEC                 = new UnicastSpecImpl(true);\n+\tstatic final MulticastSpecImpl       MULTICAST_SPEC               = new MulticastSpecImpl(true);\n+\tstatic final MulticastReplaySpecImpl MULTICAST_REPLAY_SPEC        = new MulticastReplaySpecImpl(true);\n+\tstatic final UnsafeSpecImpl          UNSAFE_SPEC                  = new UnsafeSpecImpl();\n+\tstatic final UnicastSpecImpl         UNSAFE_UNICAST_SPEC          = new UnicastSpecImpl(false);\n+\tstatic final MulticastSpecImpl       UNSAFE_MULTICAST_SPEC        = new MulticastSpecImpl(false);\n+\tstatic final MulticastReplaySpecImpl UNSAFE_MULTICAST_REPLAY_SPEC = new MulticastReplaySpecImpl(false);\n+\n+}\n+\n+final class FluxProcessorSink<T> extends FluxCreate.SerializedSink<T, Sink<T>> {\n+\tfinal CoreSubscriber<T> contextHolder;\n+\n+\tFluxProcessorSink(Sink<T> sink, CoreSubscriber<T> contextHolder) {\n+\t\tsuper(sink);\n+\t\tthis.contextHolder = contextHolder;\n+\t}\n+\n+\t@Override\n+\tContext currentContext() {\n+\t\treturn contextHolder.currentContext();\n+\t}\n+\n+\t@Override\n+\tpublic boolean isCancelled() {\n+\t\treturn Scannable.from(sink).scanOrDefault(Attr.CANCELLED, false);\n+\t}\n+}\n+\n+abstract class SinkSpecImpl {\n+\tfinal boolean serialized;\n+\n+\tSinkSpecImpl(boolean serialized) {\n+\t\tthis.serialized = serialized;\n+\t}\n+\n+\tfinal <T> Sink<T> toSerializedSink(FluxProcessor<T, T> sink) {\n+\t\tif (serialized) {\n+\t\t\treturn new FluxProcessorSink<>(sink, sink);\n+\t\t}\n+\t\treturn sink;\n+\t}\n+}\n+\n+final class UnsafeSpecImpl implements Sinks.UnsafeSpec {\n+\n+\t@Override\n+\tpublic Sinks.UnicastSpec unicast() {\n+\t\treturn SinksSpecs.UNSAFE_UNICAST_SPEC;\n+\t}\n+\n+\t@Override\n+\tpublic Sinks.MulticastSpec multicast() {\n+\t\treturn SinksSpecs.UNSAFE_MULTICAST_SPEC;\n+\t}\n+\n+\t@Override\n+\tpublic Sinks.MulticastReplaySpec replay() {\n+\t\treturn SinksSpecs.UNSAFE_MULTICAST_REPLAY_SPEC;\n+\t}\n+}\n+\n+@SuppressWarnings(\"deprecated\")\n+final class UnicastSpecImpl extends SinkSpecImpl implements Sinks.UnicastSpec {\n+\tUnicastSpecImpl(boolean serialized) {\n+\t\tsuper(serialized);\n+\t}\n+\n+\t@Override\n+\tpublic <T> Sink<T> onBackpressureBuffer() {\n+\t\treturn toSerializedSink(UnicastProcessor.create());\n+\t}\n+\n+\t@Override\n+\tpublic <T> Sink<T> onBackpressureBuffer(Queue<T> queue) {\n+\t\treturn toSerializedSink(UnicastProcessor.create(queue));\n+\t}\n+\n+\t@Override\n+\tpublic <T> Sink<T> onBackpressureBuffer(Queue<T> queue, Disposable endCallback) {\n+\t\treturn toSerializedSink(UnicastProcessor.create(queue, endCallback));\n+\t}\n+}\n+\n+@SuppressWarnings(\"deprecated\")\n+final class MulticastSpecImpl extends SinkSpecImpl implements Sinks.MulticastSpec {\n+\tMulticastSpecImpl(boolean serialized) {\n+\t\tsuper(serialized);\n+\t}\n+\n+\t@Override\n+\tpublic <T> Sink<T> onBackpressureBuffer() {\n+\t\treturn toSerializedSink(EmitterProcessor.create());\n+\t}\n+\n+\t@Override\n+\tpublic <T> Sink<T> onBackpressureBuffer(int bufferSize) {\n+\t\treturn toSerializedSink(EmitterProcessor.create(bufferSize));\n+\t}\n+\n+\t@Override\n+\tpublic <T> Sink<T> onBackpressureBuffer(int bufferSize, boolean autoCancel) {\n+\t\treturn toSerializedSink(EmitterProcessor.create(bufferSize, autoCancel));\n+\t}\n+\n+\t@Override\n+\tpublic <T> Sink<T> onBackpressureError() {\n+\t\treturn toSerializedSink(DirectProcessor.create());\n+\t}\n+}\n+\n+@SuppressWarnings(\"deprecated\")\n+final class MulticastReplaySpecImpl extends SinkSpecImpl implements Sinks.MulticastReplaySpec {", "originalCommit": "5981100d27d02470de0b807433e63042353be2d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA4Njk4OA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449086988", "bodyText": "I do like the split and the choice of basic vs unsafe, though... And the fact that these two flavors otherwise align perfectly in terms of choice in the number of factory methods \ud83d\udc4d", "author": "simonbasle", "createdAt": "2020-07-02T15:29:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1MzQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1NjcyNQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449056725", "bodyText": "please don't change the indentation of unchanged lines. these were indented with intentional newlines", "author": "simonbasle", "createdAt": "2020-07-02T14:48:16Z", "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -51,15 +51,11 @@\n \t@Nested\n \tclass MulticastNoWarmup {\n \n-\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay(0);\n+\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay().limit(0);\n \n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemantics() {\n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, NONE),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, NONE)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, NONE), expectBufferingBeforeFirstSubscriber(supplier, NONE));", "originalCommit": "5981100d27d02470de0b807433e63042353be2d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1Njg3Mg==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449056872", "bodyText": "same as above, these were indented with intentional newlines", "author": "simonbasle", "createdAt": "2020-07-02T14:48:29Z", "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -69,17 +65,13 @@\n \t\t//TODO Multicast has slightly different behavior with early onNext + onError : doesn't buffer elements for benefit of 1st subscriber\n \t\t//(this is a behavioral difference in EmitterProcessor)\n \n-\t\tfinal Supplier<Sink<Integer>> supplier = Sinks::multicast;\n+\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.multicast().onBackpressureBuffer();\n \n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemantics() {\n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, NONE),\n-\t\t\t\t\tdynamicContainer(\"buffers all before 1st subscriber, except for errors\",\n-\t\t\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, ALL)\n-\t\t\t\t\t\t\t\t\t.getChildren().filter(dn -> !dn.getDisplayName().equals(\"replayAndErrorFirstSubscriber\")))\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, NONE), dynamicContainer(\"buffers all before 1st subscriber, except for errors\", expectBufferingBeforeFirstSubscriber(supplier, ALL).getChildren()", "originalCommit": "5981100d27d02470de0b807433e63042353be2d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1NzIzNA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449057234", "bodyText": "same as above, these were indented with intentional newlines", "author": "simonbasle", "createdAt": "2020-07-02T14:49:03Z", "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -94,22 +86,19 @@ void noReplayBeforeFirstSubscriberIfEarlyError() {\n \t\t\tsink.emitError(new IllegalStateException(\"boom\"));\n \t\t\tflux.subscribe(first);\n \n-\t\t\tfirst.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t\tfirst.assertNoValues()\n+\t\t\t\t .assertErrorMessage(\"boom\");\n \t\t}\n \t}\n \n \t@Nested\n \tclass MulticastReplayAll {\n \n-\t\tfinal Supplier<Sink<Integer>> supplier = Sinks::replayAll;\n+\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay().all();\n \n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemantics() {\n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, ALL),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, ALL)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, ALL), expectBufferingBeforeFirstSubscriber(supplier, ALL));", "originalCommit": "5981100d27d02470de0b807433e63042353be2d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1NzM3Ng==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449057376", "bodyText": "same as above, these were indented with intentional newlines", "author": "simonbasle", "createdAt": "2020-07-02T14:49:15Z", "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -119,51 +108,36 @@ void noReplayBeforeFirstSubscriberIfEarlyError() {\n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemanticsSize5() {\n \t\t\tfinal int historySize = 5;\n-\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay(historySize);\n+\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay().limit(historySize);\n \n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, historySize),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, historySize)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, historySize), expectBufferingBeforeFirstSubscriber(supplier, historySize));", "originalCommit": "5981100d27d02470de0b807433e63042353be2d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1NzQ5NA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449057494", "bodyText": "same as above, these were indented with intentional newlines", "author": "simonbasle", "createdAt": "2020-07-02T14:49:25Z", "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -119,51 +108,36 @@ void noReplayBeforeFirstSubscriberIfEarlyError() {\n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemanticsSize5() {\n \t\t\tfinal int historySize = 5;\n-\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay(historySize);\n+\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay().limit(historySize);\n \n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, historySize),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, historySize)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, historySize), expectBufferingBeforeFirstSubscriber(supplier, historySize));\n \t\t}\n \n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemanticsSize0() {\n \t\t\tfinal int historySize = 0;\n-\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay(historySize);\n+\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay().limit(historySize);\n \n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, historySize),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, historySize)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, historySize), expectBufferingBeforeFirstSubscriber(supplier, historySize));", "originalCommit": "5981100d27d02470de0b807433e63042353be2d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1NzU5OA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449057598", "bodyText": "same as above, these were indented with intentional newlines", "author": "simonbasle", "createdAt": "2020-07-02T14:49:35Z", "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -119,51 +108,36 @@ void noReplayBeforeFirstSubscriberIfEarlyError() {\n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemanticsSize5() {\n \t\t\tfinal int historySize = 5;\n-\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay(historySize);\n+\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay().limit(historySize);\n \n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, historySize),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, historySize)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, historySize), expectBufferingBeforeFirstSubscriber(supplier, historySize));\n \t\t}\n \n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemanticsSize0() {\n \t\t\tfinal int historySize = 0;\n-\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay(historySize);\n+\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay().limit(historySize);\n \n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, historySize),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, historySize)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, historySize), expectBufferingBeforeFirstSubscriber(supplier, historySize));\n \t\t}\n \n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemanticsSize100() {\n \t\t\tfinal int historySize = 100;\n-\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay(historySize);\n+\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay().limit(historySize);\n \n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, historySize),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, historySize)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, historySize), expectBufferingBeforeFirstSubscriber(supplier, historySize));", "originalCommit": "5981100d27d02470de0b807433e63042353be2d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1Nzc2Ng==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449057766", "bodyText": "same as above, these were indented with intentional newlines", "author": "simonbasle", "createdAt": "2020-07-02T14:49:49Z", "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -119,51 +108,36 @@ void noReplayBeforeFirstSubscriberIfEarlyError() {\n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemanticsSize5() {\n \t\t\tfinal int historySize = 5;\n-\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay(historySize);\n+\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay().limit(historySize);\n \n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, historySize),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, historySize)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, historySize), expectBufferingBeforeFirstSubscriber(supplier, historySize));\n \t\t}\n \n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemanticsSize0() {\n \t\t\tfinal int historySize = 0;\n-\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay(historySize);\n+\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay().limit(historySize);\n \n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, historySize),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, historySize)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, historySize), expectBufferingBeforeFirstSubscriber(supplier, historySize));\n \t\t}\n \n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemanticsSize100() {\n \t\t\tfinal int historySize = 100;\n-\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay(historySize);\n+\t\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.replay().limit(historySize);\n \n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectMulticast(supplier),\n-\t\t\t\t\texpectReplay(supplier, historySize),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, historySize)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectMulticast(supplier), expectReplay(supplier, historySize), expectBufferingBeforeFirstSubscriber(supplier, historySize));\n \t\t}\n \t}\n \n \t@Nested\n \tclass Unicast {\n \n-\t\tfinal Supplier<Sink<Integer>> supplier = Sinks::unicast;\n+\t\tfinal Supplier<Sink<Integer>> supplier = () -> Sinks.unicast().onBackpressureBuffer();\n \n \t\t@TestFactory\n \t\tStream<DynamicContainer> checkSemantics() {\n-\t\t\treturn Stream.of(\n-\t\t\t\t\texpectUnicast(supplier),\n-\t\t\t\t\texpectBufferingBeforeFirstSubscriber(supplier, ALL)\n-\t\t\t);\n+\t\t\treturn Stream.of(expectUnicast(supplier), expectBufferingBeforeFirstSubscriber(supplier, ALL));", "originalCommit": "5981100d27d02470de0b807433e63042353be2d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA2MTExNA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449061114", "bodyText": "past this point the indentation was tuned a bit to avoid code creeping towards the right. this looks like good old callback hell \ud83d\ude48 \ud83d\ude06", "author": "simonbasle", "createdAt": "2020-07-02T14:54:40Z", "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -494,300 +477,327 @@ DynamicContainer expectUnicast(Supplier<Sink<Integer>> sinkSupplier) {\n \t\t\t\t\tfinally {\n \t\t\t\t\t\tes.shutdownNow();\n \t\t\t\t\t}\n-\t\t\t\t})\n-\t\t));\n+\t\t\t\t})));\n \t}\n \n \tDynamicContainer expectReplay(Supplier<Sink<Integer>> sinkSupplier, int expectedReplay) {\n \t\tif (expectedReplay == NONE) {\n-\t\t\treturn dynamicContainer(\"no replay\", Stream.of(\n-\t\t\t\t\tdynamicTest(\"doesNotReplayToLateSubscribers\", () -> {\n-\t\t\t\t\t\tSink<Integer> sink = sinkSupplier.get();\n-\t\t\t\t\t\tFlux<Integer> flux = sink.toFlux();\n-\t\t\t\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n-\t\t\t\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n-\n-\t\t\t\t\t\tflux.subscribe(s1);\n-\t\t\t\t\t\tsink.emitNext(1);\n-\t\t\t\t\t\tsink.emitNext(2);\n-\t\t\t\t\t\tsink.emitNext(3);\n-\t\t\t\t\t\ts1.assertValues(1, 2, 3);\n-\n-\t\t\t\t\t\tflux.subscribe(s2);\n-\t\t\t\t\t\ts2.assertNoValues().assertNotComplete();\n-\n-\t\t\t\t\t\tsink.emitComplete();\n-\t\t\t\t\t\ts1.assertValueCount(3).assertComplete();\n-\t\t\t\t\t\ts2.assertNoValues().assertComplete();\n-\t\t\t\t\t}),\n-\n-\t\t\t\t\tdynamicTest(\"immediatelyCompleteLateSubscriber\", () -> {\n-\t\t\t\t\t\tSink<Integer> sink = sinkSupplier.get();\n-\t\t\t\t\t\tFlux<Integer> flux = sink.toFlux();\n-\n-\t\t\t\t\t\tflux.subscribe(); //first subscriber\n-\t\t\t\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n-\n-\t\t\t\t\t\tsink.emitNext(1);\n-\t\t\t\t\t\tsink.emitComplete();\n-\t\t\t\t\t\tflux.subscribe(late);\n-\n-\t\t\t\t\t\tlate.assertNoValues().assertComplete();\n-\t\t\t\t\t}),\n-\n-\t\t\t\t\tdynamicTest(\"immediatelyErrorLateSubscriber\", () -> {\n-\t\t\t\t\t\tSink<Integer> sink = sinkSupplier.get();\n-\t\t\t\t\t\tFlux<Integer> flux = sink.toFlux();\n-\n-\t\t\t\t\t\tflux.onErrorReturn(-1).subscribe(); //first subscriber, ignore errors\n-\t\t\t\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n-\n-\t\t\t\t\t\tsink.emitNext(1);\n-\t\t\t\t\t\tsink.emitError(new IllegalStateException(\"boom\"));\n-\t\t\t\t\t\tflux.subscribe(late);\n-\n-\t\t\t\t\t\tlate.assertNoValues().assertErrorMessage(\"boom\");\n-\t\t\t\t\t})\n-\t\t\t));\n+\t\t\treturn dynamicContainer(\"no replay\", Stream.of(dynamicTest(\"doesNotReplayToLateSubscribers\", () -> {", "originalCommit": "5981100d27d02470de0b807433e63042353be2d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA5NTkyNw==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449095927", "bodyText": "remaining extraneous either", "author": "simonbasle", "createdAt": "2020-07-02T15:37:30Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxProcessor.java", "diffHunk": "@@ -229,7 +239,7 @@ public Context currentContext() {\n \t * for the\n \t * available strategies\n \t * @return a serializing {@link FluxSink}\n-\t * @deprecated Prefer clear cut usage of either {@link Processors} or {@link Sinks}, to be removed in 3.5\n+\t * @deprecated Prefer clear cut usage of either {@link Sinks}, to be removed in 3.5", "originalCommit": "5981100d27d02470de0b807433e63042353be2d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExNTg5NQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449115895", "bodyText": "rename to SerializedSinkWithContext", "author": "simonbasle", "createdAt": "2020-07-02T15:56:52Z", "path": "reactor-core/src/main/java/reactor/core/publisher/SinksSpecs.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package reactor.core.publisher;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Disposable;\n+import reactor.core.Scannable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.util.Queue;\n+\n+final class SinksSpecs {\n+\tstatic final UnicastSpecImpl         UNICAST_SPEC                 = new UnicastSpecImpl(true);\n+\tstatic final MulticastSpecImpl       MULTICAST_SPEC               = new MulticastSpecImpl(true);\n+\tstatic final MulticastReplaySpecImpl MULTICAST_REPLAY_SPEC        = new MulticastReplaySpecImpl(true);\n+\tstatic final UnsafeSpecImpl          UNSAFE_SPEC                  = new UnsafeSpecImpl();\n+\tstatic final UnicastSpecImpl         UNSAFE_UNICAST_SPEC          = new UnicastSpecImpl(false);\n+\tstatic final MulticastSpecImpl       UNSAFE_MULTICAST_SPEC        = new MulticastSpecImpl(false);\n+\tstatic final MulticastReplaySpecImpl UNSAFE_MULTICAST_REPLAY_SPEC = new MulticastReplaySpecImpl(false);\n+\n+}\n+\n+final class FluxProcessorSink<T> extends FluxCreate.SerializedSink<T, Sink<T>> {", "originalCommit": "5981100d27d02470de0b807433e63042353be2d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUxOTUyNQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r464519525", "bodyText": "splitted out and renamed in 6f60e9f", "author": "simonbasle", "createdAt": "2020-08-03T16:21:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExNTg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEyMTUyNg==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449121526", "bodyText": "I'm not sure xxxProcessor tests should use the Sinks path. After all, these classes are there to explicitly test a specific concrete implementation and would likely survive the switch of said concrete implementation to package-private. On the other hand, if the implementation of Sinks.unicast() somehow changes then coverage would drop for UnicastProcessor.\nThis comment applies to other xxxProcessorTest cases.", "author": "simonbasle", "createdAt": "2020-07-02T16:05:28Z", "path": "reactor-core/src/test/java/reactor/core/publisher/UnicastProcessorTest.java", "diffHunk": "@@ -65,20 +65,19 @@ public void secondSubscriberRejectedProperly() {\n \n \t@Test\n \tpublic void multiThreadedProducer() {\n-\t\tUnicastProcessor<Integer> processor = UnicastProcessor.create();\n-\t\tFluxSink<Integer> sink = processor.sink();\n+\t\tSink<Integer> sink = Sinks.unicast().onBackpressureBuffer();", "originalCommit": "5981100d27d02470de0b807433e63042353be2d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEyNDA3MA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r449124070", "bodyText": "reiterating that replay().limit(0) is probably a bit too confusing. multicast().onBackpressureError() sounds like the best example to give, showcasing only live data makes it past the sink.\nAlso change in advancedFeatures.adoc.", "author": "simonbasle", "createdAt": "2020-07-02T16:09:49Z", "path": "reactor-core/src/test/java/reactor/guide/GuideTests.java", "diffHunk": "@@ -201,21 +201,20 @@ public void advancedCold() {\n \n \t@Test\n \tpublic void advancedHot() {\n-\t\tSinks.StandaloneFluxSink<String> hotSource = Sinks.multicastNoWarmup();\n-\n-\t\tFlux<String> hotFlux = hotSource.asFlux().map(String::toUpperCase);\n+\t\tSink<String> hotSource = Sinks.replay().limit(0);", "originalCommit": "5981100d27d02470de0b807433e63042353be2d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUxODY2MA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r464518660", "bodyText": "fixed in 7b6b655", "author": "simonbasle", "createdAt": "2020-08-03T16:19:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEyNDA3MA=="}], "type": "inlineReview"}, {"oid": "adf69c237b92ae3328b33e58f40c88b9784411b0", "url": "https://github.com/reactor/reactor-core/commit/adf69c237b92ae3328b33e58f40c88b9784411b0", "message": "Tweak redundant imports", "committedDate": "2020-07-31T23:19:04Z", "type": "forcePushed"}, {"oid": "7b6b655f0ca41a4ea96c54f3819a48d8e99c80eb", "url": "https://github.com/reactor/reactor-core/commit/7b6b655f0ca41a4ea96c54f3819a48d8e99c80eb", "message": "fix refguide use of Sinks.many().replay().limit(0)", "committedDate": "2020-08-03T16:18:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk4ODUzMA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r464988530", "bodyText": "either not needed anymore", "author": "aneveu", "createdAt": "2020-08-04T11:40:52Z", "path": "reactor-core/src/main/java/reactor/core/publisher/DirectProcessor.java", "diffHunk": "@@ -78,10 +79,10 @@\n  * </p>\n  *\n  * @param <T> the input and output value type\n- * @deprecated Prefer clear cut usage of either {@link Processors} or {@link Sinks}, to be removed in 3.5\n+ * @deprecated Prefer clear cut usage of either {@link Sinks}, to be removed in 3.5", "originalCommit": "8cb64857c3c6a6ce5ae2e8e6d9f4fa54bf09c366", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk4OTQ3OQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r464989479", "bodyText": "either not needed anymore", "author": "aneveu", "createdAt": "2020-08-04T11:43:00Z", "path": "reactor-core/src/main/java/reactor/core/publisher/EmitterProcessor.java", "diffHunk": "@@ -51,10 +51,10 @@\n  * @param <T> the input and output value type\n  *\n  * @author Stephane Maldini\n- * @deprecated Prefer clear cut usage of either {@link Processors} or {@link Sinks}, to be removed in 3.5\n+ * @deprecated Prefer clear cut usage of either {@link Sinks}, to be removed in 3.5", "originalCommit": "8cb64857c3c6a6ce5ae2e8e6d9f4fa54bf09c366", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MDQ4MQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r465150481", "bodyText": "either not needed anymore", "author": "aneveu", "createdAt": "2020-08-04T15:47:54Z", "path": "reactor-core/src/main/java/reactor/core/publisher/ReplayProcessor.java", "diffHunk": "@@ -46,11 +47,11 @@\n  * <p>\n  *\n  * @param <T> the value type\n- * @deprecated Prefer clear cut usage of either {@link Processors} or {@link Sinks}, to be removed in 3.5\n+ * @deprecated Prefer clear cut usage of either {@link Sinks}, to be removed in 3.5", "originalCommit": "f9026ae5240238fd353b119d1c89bff9fa10676b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MjM0NQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r465152345", "bodyText": "Should we keep the Standalone prefix in this class name?", "author": "aneveu", "createdAt": "2020-08-04T15:50:39Z", "path": "reactor-core/src/main/java/reactor/core/publisher/SinksSpecs.java", "diffHunk": "@@ -0,0 +1,385 @@\n+package reactor.core.publisher;\n+\n+import java.time.Duration;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.stream.Stream;\n+\n+import org.reactivestreams.Subscription;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Disposable;\n+import reactor.core.Exceptions;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Sinks.Emission;\n+import reactor.core.publisher.Sinks.Many;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+final class SinksSpecs {\n+\tstatic final ManySpecImpl            MANY_SPEC                    = new ManySpecImpl();\n+\tstatic final UnicastSpecImpl         UNICAST_SPEC                 = new UnicastSpecImpl(true);\n+\tstatic final MulticastSpecImpl       MULTICAST_SPEC               = new MulticastSpecImpl(true);\n+\tstatic final MulticastReplaySpecImpl MULTICAST_REPLAY_SPEC        = new MulticastReplaySpecImpl(true);\n+\tstatic final UnsafeManySpecImpl      UNSAFE_MANY_SPEC             = new UnsafeManySpecImpl();\n+\tstatic final UnicastSpecImpl         UNSAFE_UNICAST_SPEC          = new UnicastSpecImpl(false);\n+\tstatic final MulticastSpecImpl       UNSAFE_MULTICAST_SPEC        = new MulticastSpecImpl(false);\n+\tstatic final MulticastReplaySpecImpl UNSAFE_MULTICAST_REPLAY_SPEC = new MulticastReplaySpecImpl(false);\n+\n+}\n+\n+final class SerializedStandaloneSink<T> implements Many<T>, Scannable {", "originalCommit": "f9026ae5240238fd353b119d1c89bff9fa10676b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1NTc0NA==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r465155744", "bodyText": "either not needed anymore", "author": "aneveu", "createdAt": "2020-08-04T15:55:43Z", "path": "reactor-core/src/main/java/reactor/core/publisher/UnicastProcessor.java", "diffHunk": "@@ -83,11 +84,12 @@\n  * </p>\n  *\n  * @param <T> the input and output type\n- * @deprecated Prefer clear cut usage of either {@link Processors} or {@link Sinks}, to be removed in 3.5\n+ * @deprecated Prefer clear cut usage of either {@link Sinks}, to be removed in 3.5", "originalCommit": "f9026ae5240238fd353b119d1c89bff9fa10676b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE2MjAzMQ==", "url": "https://github.com/reactor/reactor-core/pull/2218#discussion_r465162031", "bodyText": "not really important but the name of the variable was already quite unclear before and it becomes completely impossible to link to anything now \ud83d\ude05", "author": "aneveu", "createdAt": "2020-08-04T16:05:11Z", "path": "reactor-core/src/test/java/reactor/core/publisher/FluxFilterWhenTest.java", "diffHunk": "@@ -254,13 +254,13 @@ protected void hookFinally(SignalType type) {\n \n \t@Test\n \tpublic void cancel() {\n-\t\tfinal FluxIdentityProcessor<Boolean> pp = Processors.multicast();\n+\t\tfinal Sinks.Many<Boolean> pp = Sinks.many().multicast().onBackpressureBuffer();", "originalCommit": "f9026ae5240238fd353b119d1c89bff9fa10676b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "406003bcd7b10283c040f7b409e475ab16ae9c36", "url": "https://github.com/reactor/reactor-core/commit/406003bcd7b10283c040f7b409e475ab16ae9c36", "message": "Rework of M1 Sinks, further separate standalone Sinks API (#1037, #2218)\n\nThis commit is a rework of the `Sinks` approach introduced in 3.4.0-M1\n(see #2179 and #2188).\n\nSince the original goal is the ultimate hiding of most processors\nimplementations, the `Processors` factory has been removed. In a similar\neffort NOT to give traction to processor use, `FluxIdentityProcessor`\nhas also been removed and replaced by the pre-existing equivalent of\n`FluxProcessor<T, T>`.\n\nThe `StandaloneFluxSink` and `StandaloneMonoSink` have been reworked:\nthere is no `SequenceSink` and `ScalarSink` common superinterface, so\nthese new sinks don't share API with pre-existing `FluxSink` and\n`MonoSink` anymore. The later are both reserved for in-operator sink\nusage, with an API that reflects their association with a single\nsubscription.\n\nInstead, this commit introduces flavors of sinks that are meant to be\nused as publishers, regrouped under the `Sinks` class to clearly mark\nthey're 3 sides of a similar concept: `Sinks.Empty`, `Sinks.One` and\n`Sinks.Many`. The intent is to always keep the `Sinks` prefix to clarify\nthe nature of the objects.\n\nThese sinks don't expose a fluent API, but rather expose `emitXxx`\nmethods that trigger relevant signals in their `Subscriber`s. They also\neach expose a \"view method\", either `asMono()` or `asFlux`, which allows\ndownstream code to see the sink as a `Publisher` and subscribe to it.\nThese emit methods return a `Sinks.Emission` enum indicating success or\nfailure to emit, further distinguishing between cases for failure.\nThis later point fixes #1037.\n\nThis different API allows efficient instance creation since the\nconcrete implementations are processors which also directly implement\nthe sinks and their view.\n\nReviewed-in: #2218\nCo-authored-by: Stephane Maldini <smaldini@netflix.com>\nCo-authored-by: Simon Basl\u00e9 <sbasle@vmware.com>", "committedDate": "2020-08-05T09:42:41Z", "type": "commit"}, {"oid": "a3bccb838e931355febf3538ea593cead2575e3b", "url": "https://github.com/reactor/reactor-core/commit/a3bccb838e931355febf3538ea593cead2575e3b", "message": "fix #2049 Fail fast if EmitterProcessor queue is full\n\nThis commit replaces the wait-loop in 10ns increments with a fail-fast\nwhich returns Emission.FAIL_OVERFLOW if the backpressure queue is full.\n\nReviewed-in: #2218\nCo-authored-by: Stephane Maldini <smaldini@netflix.com>\nCo-authored-by: Simon Basl\u00e9 <sbasle@vmware.com>", "committedDate": "2020-08-05T09:46:41Z", "type": "commit"}, {"oid": "a3bccb838e931355febf3538ea593cead2575e3b", "url": "https://github.com/reactor/reactor-core/commit/a3bccb838e931355febf3538ea593cead2575e3b", "message": "fix #2049 Fail fast if EmitterProcessor queue is full\n\nThis commit replaces the wait-loop in 10ns increments with a fail-fast\nwhich returns Emission.FAIL_OVERFLOW if the backpressure queue is full.\n\nReviewed-in: #2218\nCo-authored-by: Stephane Maldini <smaldini@netflix.com>\nCo-authored-by: Simon Basl\u00e9 <sbasle@vmware.com>", "committedDate": "2020-08-05T09:46:41Z", "type": "forcePushed"}]}