{"pr_number": 2019, "pr_title": "Fix early cancellation handling and improve switchOnFirst", "pr_createdAt": "2020-01-22T14:27:58Z", "pr_url": "https://github.com/reactor/reactor-core/pull/2019", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0MzE2MA==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r371843160", "bodyText": "you should use the constant STATE_REQUESTED here too", "author": "simonbasle", "createdAt": "2020-01-28T14:42:33Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -523,58 +559,141 @@ public void onError(Throwable throwable) {\n                 parent.cancel();\n             }\n \n-            inner.onError(throwable);\n+            delegate.onError(throwable);\n         }\n \n         @Override\n         public void onComplete() {\n-            if (!parent.done) {\n+            if (!parent.done && cancelSourceOnComplete) {\n                 parent.cancel();\n             }\n \n-            inner.onComplete();\n+            delegate.onComplete();\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            long r = this.requested;\n+\n+            if (r > STATE_REQUESTED) {\n+                long u;\n+                for (;;) {\n+                    if (r == Long.MAX_VALUE) {\n+                        return;\n+                    }\n+                    u = Operators.addCap(r, n);\n+                    if (REQUESTED.compareAndSet(this, r, u)) {\n+                        return;\n+                    }\n+                    else {\n+                        r = requested;\n+\n+                        if (r < 0) {\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (r == STATE_CANCELLED) {\n+                return;\n+            }\n+\n+            s.request(n);\n+        }\n+\n+        void tryRequest() {\n+            final Subscription s = this.s;\n+            long r = REQUESTED.getAndSet(this, -1);", "originalCommit": "877b27053c1efc5fd287d1617535114e32ccb1d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0NTQxMA==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r371845410", "bodyText": "just for clarity's sake, use this.requested here", "author": "simonbasle", "createdAt": "2020-01-28T14:46:00Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -523,58 +559,141 @@ public void onError(Throwable throwable) {\n                 parent.cancel();\n             }\n \n-            inner.onError(throwable);\n+            delegate.onError(throwable);\n         }\n \n         @Override\n         public void onComplete() {\n-            if (!parent.done) {\n+            if (!parent.done && cancelSourceOnComplete) {\n                 parent.cancel();\n             }\n \n-            inner.onComplete();\n+            delegate.onComplete();\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            long r = this.requested;\n+\n+            if (r > STATE_REQUESTED) {\n+                long u;\n+                for (;;) {\n+                    if (r == Long.MAX_VALUE) {\n+                        return;\n+                    }\n+                    u = Operators.addCap(r, n);\n+                    if (REQUESTED.compareAndSet(this, r, u)) {\n+                        return;\n+                    }\n+                    else {\n+                        r = requested;", "originalCommit": "877b27053c1efc5fd287d1617535114e32ccb1d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0Njc1Nw==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r371846757", "bodyText": "shouldn't it break from the for(;;) loop rather than completely exiting?\nI get the return in the case where we detect we're running in unbounded mode, but here we're aggregating requests and it is not clear to me how they will be propagated upstream...", "author": "simonbasle", "createdAt": "2020-01-28T14:48:11Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -523,58 +559,141 @@ public void onError(Throwable throwable) {\n                 parent.cancel();\n             }\n \n-            inner.onError(throwable);\n+            delegate.onError(throwable);\n         }\n \n         @Override\n         public void onComplete() {\n-            if (!parent.done) {\n+            if (!parent.done && cancelSourceOnComplete) {\n                 parent.cancel();\n             }\n \n-            inner.onComplete();\n+            delegate.onComplete();\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            long r = this.requested;\n+\n+            if (r > STATE_REQUESTED) {\n+                long u;\n+                for (;;) {\n+                    if (r == Long.MAX_VALUE) {\n+                        return;\n+                    }\n+                    u = Operators.addCap(r, n);\n+                    if (REQUESTED.compareAndSet(this, r, u)) {\n+                        return;", "originalCommit": "877b27053c1efc5fd287d1617535114e32ccb1d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE2MTAwMA==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r374161000", "bodyText": "if it is a long max value then it means that it was requested and not consumed yet. Therefore we have simply returned without checking anything. Actually, I can add tests which check the correctness just in case you are worried about that path", "author": "OlegDokuka", "createdAt": "2020-02-03T15:18:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0Njc1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI4MTU5Mg==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r375281592", "bodyText": "what guarantees that the n you just added to r in addCap are actually propagated upstream? since you're returning, and r > STATE_REQUESTED, there's no chance the tryRequest will swap the new r for -1 and perform s.request(r), so that amount n is lost. Am I missing something?", "author": "simonbasle", "createdAt": "2020-02-05T14:20:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0Njc1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc3NTQ5Nw==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r375775497", "bodyText": "I'm not sure.\nLet's consider the following:\nState 1: No subscription; actual makes a request so we get in into the request method:\nLine 576 : we read the current request size\nLine 578 we check that r is higher than -1 and in into for-loop\nCases: Line 585: perform CAS operation which means if it is (1 - true, 2 - false):\n\nthen we have won racing and the last observed request was higher than -1 so there is no upstream subscription and we can exit request method\nthen we read the request field at Line 589 and perform a check on request is less than 0 (which means it is either canceled or we lost the racing so we have to break the loop and go straight to reading subscription s and perform a direct request(n).", "author": "OlegDokuka", "createdAt": "2020-02-06T11:14:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0Njc1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk4MDE1NQ==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388980155", "bodyText": "thanks for the explanations, comments and face-to-face review, this is clear to me now \ud83d\udc4d", "author": "simonbasle", "createdAt": "2020-03-06T15:47:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0Njc1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0NzUwMQ==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r371847501", "bodyText": "this is only done when this.requested == STATE_REQUESTED, ie in tryRequest, in turn only invoked in onSubscribe, correct?", "author": "simonbasle", "createdAt": "2020-01-28T14:49:15Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -523,58 +559,141 @@ public void onError(Throwable throwable) {\n                 parent.cancel();\n             }\n \n-            inner.onError(throwable);\n+            delegate.onError(throwable);\n         }\n \n         @Override\n         public void onComplete() {\n-            if (!parent.done) {\n+            if (!parent.done && cancelSourceOnComplete) {\n                 parent.cancel();\n             }\n \n-            inner.onComplete();\n+            delegate.onComplete();\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            long r = this.requested;\n+\n+            if (r > STATE_REQUESTED) {\n+                long u;\n+                for (;;) {\n+                    if (r == Long.MAX_VALUE) {\n+                        return;\n+                    }\n+                    u = Operators.addCap(r, n);\n+                    if (REQUESTED.compareAndSet(this, r, u)) {\n+                        return;\n+                    }\n+                    else {\n+                        r = requested;\n+\n+                        if (r < 0) {\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (r == STATE_CANCELLED) {\n+                return;\n+            }\n+\n+            s.request(n);", "originalCommit": "877b27053c1efc5fd287d1617535114e32ccb1d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE2NjkwMA==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r374166900", "bodyText": "correct, since there is a guard for that at line 578 I'm not trying to double-check that again here. it is assumed if the execution got there than the state is requested", "author": "OlegDokuka", "createdAt": "2020-02-03T15:27:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0NzUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI4MjYzNg==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r375282636", "bodyText": "what I meant is \"what if the state was NOT requested, but a second batch of request (eg. this operator is called with request(3) then request(4)). wouldn't the second request call be \"lost\"?", "author": "simonbasle", "createdAt": "2020-02-05T14:21:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0NzUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU3ODU2MQ==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r387578561", "bodyText": "It is not going to be lost. Consider the following\nState 1 [r: 0]\nrequest(3) -> State 2 [r: 3]\nState 2 [r: 3] race with [onSubscribe]\nCase 1:\ntryRequest( getAndSet(-1) ) Happens Before request( REQUESTED.addAndGet(4) )\nResult:\nrequest(3) followed by\nrequest(4) with a happens-before guarantee\nCase 2:\nrequest ( REQUESTED.addAndGet(4)) happens before tryRequest( getAndSet(-1) )\nResult:\nrequest(7)", "author": "OlegDokuka", "createdAt": "2020-03-04T10:32:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0NzUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0OTY4OA==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r371849688", "bodyText": "comments above apply to this class as well", "author": "simonbasle", "createdAt": "2020-01-28T14:52:39Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -523,58 +559,141 @@ public void onError(Throwable throwable) {\n                 parent.cancel();\n             }\n \n-            inner.onError(throwable);\n+            delegate.onError(throwable);\n         }\n \n         @Override\n         public void onComplete() {\n-            if (!parent.done) {\n+            if (!parent.done && cancelSourceOnComplete) {\n                 parent.cancel();\n             }\n \n-            inner.onComplete();\n+            delegate.onComplete();\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            long r = this.requested;\n+\n+            if (r > STATE_REQUESTED) {\n+                long u;\n+                for (;;) {\n+                    if (r == Long.MAX_VALUE) {\n+                        return;\n+                    }\n+                    u = Operators.addCap(r, n);\n+                    if (REQUESTED.compareAndSet(this, r, u)) {\n+                        return;\n+                    }\n+                    else {\n+                        r = requested;\n+\n+                        if (r < 0) {\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (r == STATE_CANCELLED) {\n+                return;\n+            }\n+\n+            s.request(n);\n+        }\n+\n+        void tryRequest() {\n+            final Subscription s = this.s;\n+            long r = REQUESTED.getAndSet(this, -1);\n+\n+            if (r > 0) {\n+                s.request(r);\n+            }\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            final long state = REQUESTED.getAndSet(this, STATE_CANCELLED);\n+\n+            if (state == STATE_CANCELLED) {\n+                return;\n+            }\n+\n+            if (state == STATE_REQUESTED) {\n+                s.cancel();\n+                return;\n+            }\n+\n+            parent.cancel();\n         }\n \n         @Override\n         public Object scanUnsafe(Attr key) {\n             if (key == Attr.PARENT) return parent;\n-            if (key == Attr.ACTUAL) return inner;\n+            if (key == Attr.ACTUAL) return delegate;\n \n             return null;\n         }\n     }\n \n-    static final class SwitchOnFirstConditionalInnerSubscriber<T> implements InnerConsumer<T>,\n+    static final class SwitchOnFirstConditionalControlSubscriber<T> implements InnerOperator<T, T>, ControlSubscriber<T>,", "originalCommit": "877b27053c1efc5fd287d1617535114e32ccb1d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI3NDE3Mw==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r375274173", "bodyText": "small nitpick: group these with other STATE_ and put the blank line above", "author": "simonbasle", "createdAt": "2020-02-05T14:07:11Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -34,17 +35,22 @@\n  * @param <R>\n  */\n final class FluxSwitchOnFirst<T, R> extends InternalFluxOperator<T, R> {\n+    static final int STATE_CANCELLED = -2;\n+    static final int STATE_REQUESTED = -1;\n ", "originalCommit": "877b27053c1efc5fd287d1617535114e32ccb1d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8af77968e12abb7bfaccdd7c5417e23e6546985b", "url": "https://github.com/reactor/reactor-core/commit/8af77968e12abb7bfaccdd7c5417e23e6546985b", "message": "provides refactoring\n\n1) Applies Name changes in internal class naming\n2) Provides Additional parameter which allows cancelling the source Publisher or continuing it work regardless derived Publisher completion\n3) Provides ability to cancel source if there is no elements but downstream has already been cancelled\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>", "committedDate": "2020-03-06T12:02:30Z", "type": "commit"}, {"oid": "97161681ee1d43e5b9d39cb1f71af31166990297", "url": "https://github.com/reactor/reactor-core/commit/97161681ee1d43e5b9d39cb1f71af31166990297", "message": "provides source leaning and minor refactoring\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>", "committedDate": "2020-03-06T12:02:30Z", "type": "commit"}, {"oid": "97161681ee1d43e5b9d39cb1f71af31166990297", "url": "https://github.com/reactor/reactor-core/commit/97161681ee1d43e5b9d39cb1f71af31166990297", "message": "provides source leaning and minor refactoring\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>", "committedDate": "2020-03-06T12:02:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg2NjU2NQ==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388866565", "bodyText": "@simonbasle I ended up with the conclusion that context can not be mutable for upstream, thus removed that tricky part", "author": "OlegDokuka", "createdAt": "2020-03-06T12:04:59Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -56,87 +64,73 @@ public int getPrefetch() {\n     @SuppressWarnings(\"unchecked\")\n     public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {\n         if (actual instanceof Fuseable.ConditionalSubscriber) {\n-            source.subscribe(new SwitchOnFirstConditionalInner<>((Fuseable.ConditionalSubscriber<? super R>) actual, transformer));\n-            return null;\n+            return new SwitchOnFirstConditionalMain<>((Fuseable.ConditionalSubscriber<? super R>) actual, transformer, cancelSourceOnComplete);\n         }\n-        return new SwitchOnFirstInner<>(actual, transformer);\n+        return new SwitchOnFirstMain<>(actual, transformer, cancelSourceOnComplete);\n     }\n \n-    static abstract class AbstractSwitchOnFirstInner<T, R> extends Flux<T>\n+    static abstract class AbstractSwitchOnFirstMain<T, R> extends Flux<T>\n             implements InnerOperator<T, R> {\n \n-        final CoreSubscriber<? super R>                                        outer;\n+        final ControlSubscriber<? super R>                                     outer;\n         final BiFunction<Signal<? extends T>, Flux<T>, Publisher<? extends R>> transformer;\n \n         Subscription s;\n         Throwable    throwable;\n         T            first;\n         boolean      done;\n \n-        volatile boolean cancelled;\n-\n         volatile CoreSubscriber<? super T> inner;\n         @SuppressWarnings(\"rawtypes\")\n-        static final AtomicReferenceFieldUpdater<AbstractSwitchOnFirstInner, CoreSubscriber> INNER =\n-                AtomicReferenceFieldUpdater.newUpdater(AbstractSwitchOnFirstInner.class, CoreSubscriber.class, \"inner\");\n+        static final AtomicReferenceFieldUpdater<AbstractSwitchOnFirstMain, CoreSubscriber> INNER =\n+                AtomicReferenceFieldUpdater.newUpdater(AbstractSwitchOnFirstMain.class, CoreSubscriber.class, \"inner\");\n \n         volatile int wip;\n         @SuppressWarnings(\"rawtypes\")\n-        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstInner> WIP =\n-                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstInner.class, \"wip\");\n+        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstMain> WIP =\n+                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstMain.class, \"wip\");\n \n         volatile int state;\n         @SuppressWarnings(\"rawtypes\")\n-        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstInner> STATE =\n-                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstInner.class, \"state\");\n+        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstMain> STATE =\n+                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstMain.class, \"state\");\n \n         @SuppressWarnings(\"unchecked\")\n-        AbstractSwitchOnFirstInner(\n+        AbstractSwitchOnFirstMain(\n                 CoreSubscriber<? super R> outer,\n-                BiFunction<Signal<? extends T>, Flux<T>, Publisher<? extends R>> transformer) {\n+                BiFunction<Signal<? extends T>, Flux<T>, Publisher<? extends R>> transformer,\n+                boolean cancelSourceOnComplete) {\n             this.outer = outer instanceof Fuseable.ConditionalSubscriber\n-                ? new SwitchOnFirstConditionalInnerSubscriber<>(this, (Fuseable.ConditionalSubscriber<R>) outer)\n-                : new SwitchOnFirstInnerSubscriber<>(this, outer);\n+                ? new SwitchOnFirstConditionalControlSubscriber<>(this, (Fuseable.ConditionalSubscriber<R>) outer, cancelSourceOnComplete)\n+                : new SwitchOnFirstControlSubscriber<>(this, outer, cancelSourceOnComplete);\n             this.transformer = transformer;\n         }\n \n         @Override\n         @Nullable\n         public Object scanUnsafe(Attr key) {\n-            if (key == Attr.CANCELLED) return cancelled;\n-            if (key == Attr.TERMINATED) return done || cancelled;\n+            final boolean isCancelled = this.inner == Operators.emptySubscriber();\n+\n+            if (key == Attr.CANCELLED) return isCancelled && !this.done;\n+            if (key == Attr.TERMINATED) return this.done || isCancelled;\n \n             return InnerOperator.super.scanUnsafe(key);\n         }\n \n         @Override\n         public CoreSubscriber<? super R> actual() {\n-            return outer;\n-        }\n-\n-        @Override\n-        public Context currentContext() {", "originalCommit": "97161681ee1d43e5b9d39cb1f71af31166990297", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk1OTYzNw==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388959637", "bodyText": "this boils down to outer.currentContext(), so ok", "author": "simonbasle", "createdAt": "2020-03-06T15:13:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg2NjU2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg2Njg1Mg==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388866852", "bodyText": "Using empty subscriber instance (which I assume for internal usage only) in order to indicate canceled state and", "author": "OlegDokuka", "createdAt": "2020-03-06T12:05:49Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -56,87 +64,73 @@ public int getPrefetch() {\n     @SuppressWarnings(\"unchecked\")\n     public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {\n         if (actual instanceof Fuseable.ConditionalSubscriber) {\n-            source.subscribe(new SwitchOnFirstConditionalInner<>((Fuseable.ConditionalSubscriber<? super R>) actual, transformer));\n-            return null;\n+            return new SwitchOnFirstConditionalMain<>((Fuseable.ConditionalSubscriber<? super R>) actual, transformer, cancelSourceOnComplete);\n         }\n-        return new SwitchOnFirstInner<>(actual, transformer);\n+        return new SwitchOnFirstMain<>(actual, transformer, cancelSourceOnComplete);\n     }\n \n-    static abstract class AbstractSwitchOnFirstInner<T, R> extends Flux<T>\n+    static abstract class AbstractSwitchOnFirstMain<T, R> extends Flux<T>\n             implements InnerOperator<T, R> {\n \n-        final CoreSubscriber<? super R>                                        outer;\n+        final ControlSubscriber<? super R>                                     outer;\n         final BiFunction<Signal<? extends T>, Flux<T>, Publisher<? extends R>> transformer;\n \n         Subscription s;\n         Throwable    throwable;\n         T            first;\n         boolean      done;\n \n-        volatile boolean cancelled;\n-\n         volatile CoreSubscriber<? super T> inner;\n         @SuppressWarnings(\"rawtypes\")\n-        static final AtomicReferenceFieldUpdater<AbstractSwitchOnFirstInner, CoreSubscriber> INNER =\n-                AtomicReferenceFieldUpdater.newUpdater(AbstractSwitchOnFirstInner.class, CoreSubscriber.class, \"inner\");\n+        static final AtomicReferenceFieldUpdater<AbstractSwitchOnFirstMain, CoreSubscriber> INNER =\n+                AtomicReferenceFieldUpdater.newUpdater(AbstractSwitchOnFirstMain.class, CoreSubscriber.class, \"inner\");\n \n         volatile int wip;\n         @SuppressWarnings(\"rawtypes\")\n-        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstInner> WIP =\n-                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstInner.class, \"wip\");\n+        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstMain> WIP =\n+                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstMain.class, \"wip\");\n \n         volatile int state;\n         @SuppressWarnings(\"rawtypes\")\n-        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstInner> STATE =\n-                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstInner.class, \"state\");\n+        static final AtomicIntegerFieldUpdater<AbstractSwitchOnFirstMain> STATE =\n+                AtomicIntegerFieldUpdater.newUpdater(AbstractSwitchOnFirstMain.class, \"state\");\n \n         @SuppressWarnings(\"unchecked\")\n-        AbstractSwitchOnFirstInner(\n+        AbstractSwitchOnFirstMain(\n                 CoreSubscriber<? super R> outer,\n-                BiFunction<Signal<? extends T>, Flux<T>, Publisher<? extends R>> transformer) {\n+                BiFunction<Signal<? extends T>, Flux<T>, Publisher<? extends R>> transformer,\n+                boolean cancelSourceOnComplete) {\n             this.outer = outer instanceof Fuseable.ConditionalSubscriber\n-                ? new SwitchOnFirstConditionalInnerSubscriber<>(this, (Fuseable.ConditionalSubscriber<R>) outer)\n-                : new SwitchOnFirstInnerSubscriber<>(this, outer);\n+                ? new SwitchOnFirstConditionalControlSubscriber<>(this, (Fuseable.ConditionalSubscriber<R>) outer, cancelSourceOnComplete)\n+                : new SwitchOnFirstControlSubscriber<>(this, outer, cancelSourceOnComplete);\n             this.transformer = transformer;\n         }\n \n         @Override\n         @Nullable\n         public Object scanUnsafe(Attr key) {\n-            if (key == Attr.CANCELLED) return cancelled;\n-            if (key == Attr.TERMINATED) return done || cancelled;\n+            final boolean isCancelled = this.inner == Operators.emptySubscriber();\n+\n+            if (key == Attr.CANCELLED) return isCancelled && !this.done;\n+            if (key == Attr.TERMINATED) return this.done || isCancelled;\n \n             return InnerOperator.super.scanUnsafe(key);\n         }\n \n         @Override\n         public CoreSubscriber<? super R> actual() {\n-            return outer;\n-        }\n-\n-        @Override\n-        public Context currentContext() {\n-            CoreSubscriber<? super T> actual = inner;\n-\n-            if (actual != null) {\n-                return actual.currentContext();\n-            }\n-\n-            return outer.currentContext();\n+            return this.outer;\n         }\n \n         @Override\n         public void cancel() {\n-            if (!cancelled) {\n-                cancelled = true;\n-                s.cancel();\n+            if (INNER.getAndSet(this, Operators.emptySubscriber()) != Operators.emptySubscriber()) {", "originalCommit": "97161681ee1d43e5b9d39cb1f71af31166990297", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk2MDgyMg==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388960822", "bodyText": "I guess to be extra sure to be shielded from Operators.emptySubscriber() ever returning a new instance, you can directly use Operators.EMPTY_SUBSCRIBER ? (fine for usage internal to the publisher package)", "author": "simonbasle", "createdAt": "2020-03-06T15:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg2Njg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg2NzI1OQ==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388867259", "bodyText": "double-check here in order to ensure that we really need to request the first element. if the subscription has been canceled already then noops required", "author": "OlegDokuka", "createdAt": "2020-03-06T12:06:45Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -147,36 +141,38 @@ public void cancel() {\n         public void onSubscribe(Subscription s) {\n             if (Operators.validate(this.s, s)) {\n                 this.s = s;\n-                s.request(1);\n+                this.outer.sendSubscription();\n+                if (this.inner != Operators.emptySubscriber()) {", "originalCommit": "97161681ee1d43e5b9d39cb1f71af31166990297", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk2MTQ4NQ==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388961485", "bodyText": "again, you can use Operators.EMPTY_SUBSCRIBER to be 100% shielded from API implementation details", "author": "simonbasle", "createdAt": "2020-03-06T15:16:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg2NzI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg3MDE5Mw==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388870193", "bodyText": "I made emptySubscriber an instance of ConditionalSubscriber specifically for that case", "author": "OlegDokuka", "createdAt": "2020-03-06T12:14:37Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -420,64 +419,45 @@ public boolean tryOnNext(T t) {\n         }\n \n         @Override\n-        public void request(long n) {\n-            if (Operators.validate(n)) {\n-                if (first != null) {\n-                    if (drainRegular() && n != Long.MAX_VALUE) {\n-                        if (--n > 0) {\n-                            s.request(n);\n-                            return;\n-                        }\n-\n-                        return;\n-                    }\n-                }\n-\n-                s.request(n);\n-            }\n-        }\n-\n-        @Override\n-        void drain() {\n-            drainRegular();\n-        }\n-\n-        boolean drainRegular() {\n+        @SuppressWarnings(\"unchecked\")\n+        boolean drain() {\n             if (WIP.getAndIncrement(this) != 0) {\n                 return false;\n             }\n \n-            T f = first;\n+            T f = this.first;\n             int m = 1;\n             boolean sent = false;\n-            @SuppressWarnings(\"unchecked\")\n             Fuseable.ConditionalSubscriber<? super T> a =\n-                    (Fuseable.ConditionalSubscriber<? super T>) inner;\n+                    (Fuseable.ConditionalSubscriber<? super T>) this.inner;\n \n             for (;;) {\n                 if (f != null) {\n-                    first = null;\n+                    this.first = null;\n \n-                    if (cancelled) {\n-                        Operators.onDiscard(f, a.currentContext());\n+                    if (a == Operators.emptySubscriber()) {", "originalCommit": "97161681ee1d43e5b9d39cb1f71af31166990297", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk3OTM4OA==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388979388", "bodyText": "I'll evaluate that change separately in a comment below (the conditional one). ok for conditional \u2705  Otherwise, same as elsewhere, can use EMPTY_SUBSCRIBER constant.", "author": "simonbasle", "createdAt": "2020-03-06T15:46:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg3MDE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg3MDQ2OQ==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388870469", "bodyText": "Should not be a big deal to support ConditionalSubscriber interface which includes CoreSubscriber interface as well", "author": "OlegDokuka", "createdAt": "2020-03-06T12:15:19Z", "path": "reactor-core/src/main/java/reactor/core/publisher/Operators.java", "diffHunk": "@@ -1413,7 +1413,7 @@ public void subscribe(Subscriber<? super T> s) {\n \t\t}\n \t}\n \n-\tstatic final CoreSubscriber<?> EMPTY_SUBSCRIBER = new CoreSubscriber<Object>() {\n+\tstatic final Fuseable.ConditionalSubscriber<?> EMPTY_SUBSCRIBER = new Fuseable.ConditionalSubscriber<Object>() {", "originalCommit": "97161681ee1d43e5b9d39cb1f71af31166990297", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk4MTYyMw==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388981623", "bodyText": "looks good to me \ud83d\udc4d\nconceptually, instanceof ConditionalSubscriber should be done early on, during subscribe(), at which point the passed Subscriber is not supposed to be an EMPTY_SUBSCRIBER anyway so all good here \u2705", "author": "simonbasle", "createdAt": "2020-03-06T15:50:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg3MDQ2OQ=="}], "type": "inlineReview"}, {"oid": "5fccf4c1acc81d85fed028f25ef2ab769de39d0a", "url": "https://github.com/reactor/reactor-core/commit/5fccf4c1acc81d85fed028f25ef2ab769de39d0a", "message": "fixes tests. ensures cancellation is propagated\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>", "committedDate": "2020-03-06T12:24:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk2MTY2OA==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388961668", "bodyText": "same as above", "author": "simonbasle", "createdAt": "2020-03-06T15:17:07Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -186,29 +182,29 @@ public void onNext(T t) {\n \n         @Override\n         public void onError(Throwable t) {\n-            if (done) {\n+            final CoreSubscriber<? super T> i = this.inner;\n+            if (this.done || i == Operators.emptySubscriber()) {", "originalCommit": "5fccf4c1acc81d85fed028f25ef2ab769de39d0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk2MTgwMQ==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388961801", "bodyText": "same as above", "author": "simonbasle", "createdAt": "2020-03-06T15:17:20Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -223,27 +219,27 @@ public void onError(Throwable t) {\n \n         @Override\n         public void onComplete() {\n-            if (done) {\n+            final CoreSubscriber<? super T> i = this.inner;\n+            if (this.done || i == Operators.emptySubscriber()) {", "originalCommit": "5fccf4c1acc81d85fed028f25ef2ab769de39d0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk2MjE5Mg==", "url": "https://github.com/reactor/reactor-core/pull/2019#discussion_r388962192", "bodyText": "can use EMPTY_SUBSCRIBER constant here too", "author": "simonbasle", "createdAt": "2020-03-06T15:17:57Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java", "diffHunk": "@@ -289,94 +305,78 @@ public void subscribe(CoreSubscriber<? super T> actual) {\n         }\n \n         @Override\n-        public void request(long n) {\n-            if (Operators.validate(n)) {\n-                if (first != null) {\n-                    drain();\n-\n-                    if (n != Long.MAX_VALUE) {\n-                        if (--n > 0) {\n-                            s.request(n);\n-                            return;\n-                        }\n-\n-                        return;\n-                    }\n-                }\n-\n-                s.request(n);\n-            }\n-        }\n-\n-        @Override\n-        void drain() {\n+        boolean drain() {\n             if (WIP.getAndIncrement(this) != 0) {\n-                return;\n+                return false;\n             }\n \n-            T f = first;\n+            CoreSubscriber<? super T> a = this.inner;\n+            T f = this.first;\n             int m = 1;\n-            CoreSubscriber<? super T> a = inner;\n \n             for (;;) {\n                 if (f != null) {\n-                    first = null;\n+                    this.first = null;\n \n-                    if (cancelled) {\n-                        Operators.onDiscard(f, a.currentContext());\n-                        return;\n+                    if (a == Operators.emptySubscriber()) {", "originalCommit": "5fccf4c1acc81d85fed028f25ef2ab769de39d0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "422e5ceb4cdf4b5bdea4220e7d7ada606a846848", "url": "https://github.com/reactor/reactor-core/commit/422e5ceb4cdf4b5bdea4220e7d7ada606a846848", "message": "uses directly the Operators.EMPTY_SUBSCRIBER constant\n\nSigned-off-by: Oleh Dokuka <shadowgun@i.ua>", "committedDate": "2020-03-06T16:20:57Z", "type": "commit"}]}