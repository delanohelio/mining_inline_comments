{"pr_number": 2837, "pr_title": "Asynchronous endpoint selection", "pr_createdAt": "2020-06-25T13:15:24Z", "pr_url": "https://github.com/line/armeria/pull/2837", "timeline": [{"oid": "d77e600fd31624c9bbd2694cf1c36a7c2e6a1c65", "url": "https://github.com/line/armeria/commit/d77e600fd31624c9bbd2694cf1c36a7c2e6a1c65", "message": "Asynchronous endpoint selection\n\nMotivation:\n\nCurrently, sending a request will fail immediately with an\n`EmptyEndpointGroupException` when the target `EndpointGroup` is empty\nwithout waiting at all.\n\nIf we could wait until the `EndpointGroup` has at least one `Endpoint`,\nwe will be able to avoid the `EmptyEndpointGroupException` at least for\nthe case where the `Endpoint`s disappear temporarily.\n\nModifications:\n\n- Rename `EndpointSelector.select()` to `selectNow()`.\n- Add `EndpointSelector.select()` that performs asynchronous endpoint\n  selection with timeout.\n- Add `AbstractEndpointSelector` that implements the asynchronous\n  `select()`.\n- Modify `DefaultClientRequestContext` and `ClientUtil` to use the new\n  asynchronous `EndpointSelector.select()` if `selectNow()` returns\n  `null`, so that it waits up to the connect timeout.\n- Modify `UserClient` require `futureConverter` and `errorResponseFunction`\n  at its construction time.\n  - The method signatures of `protected execute()` have been changed.\n- Make `AbstractListenable` more suitable for frequent updates, so we\n  can add and remove many listeners when an `EndpointGroup` is empty.\n- Miscellaneous:\n  - Update `web-licenses.txt`\n\nResult:\n\n- Fixes #1910\n- (Breaking) `EndpointSelector` API has been changed.\n  - It is not a functional interface anymore.\n  - `select()` has been renamed to `selectNow()`.\n  - An asynchronous `select()` has been added.\n- (Breaking) `UserClient` API has been changed.\n  - Its constructor requires more parameters.\n  - `execute()` requires less parameters.", "committedDate": "2020-06-25T13:13:01Z", "type": "commit"}, {"oid": "6c65d471eb3957dc82a88efb18b1745a856cacd6", "url": "https://github.com/line/armeria/commit/6c65d471eb3957dc82a88efb18b1745a856cacd6", "message": "Cancel timeout tasks", "committedDate": "2020-06-26T00:55:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk3NjU0Nw==", "url": "https://github.com/line/armeria/pull/2837#discussion_r445976547", "bodyText": "Could remove AbstractEndpointSelector.this.?", "author": "ikhoon", "createdAt": "2020-06-26T05:35:48Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/AbstractEndpointSelector.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+\n+/**\n+ * A skeletal {@link EndpointSelector} implementation. This abstract class implements the\n+ * {@link #select(ClientRequestContext, ScheduledExecutorService, long)} method by listening to\n+ * the change events emitted by {@link EndpointGroup} specified at construction time.\n+ */\n+public abstract class AbstractEndpointSelector implements EndpointSelector {\n+\n+    private final EndpointGroup endpointGroup;\n+\n+    /**\n+     * Creates a new instance that selects an {@link Endpoint} from the specified {@link EndpointGroup}.\n+     */\n+    protected AbstractEndpointSelector(EndpointGroup endpointGroup) {\n+        this.endpointGroup = requireNonNull(endpointGroup, \"endpointGroup\");\n+    }\n+\n+    /**\n+     * Returns the {@link EndpointGroup} being selected by this {@link EndpointSelector}.\n+     */\n+    protected final EndpointGroup group() {\n+        return endpointGroup;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<Endpoint> select(ClientRequestContext ctx,\n+                                                    ScheduledExecutorService executor,\n+                                                    long timeoutMillis) {\n+        Endpoint endpoint = selectNow(ctx);\n+        if (endpoint != null) {\n+            return UnmodifiableFuture.completedFuture(endpoint);\n+        }\n+\n+        final ListeningFuture listeningFuture = new ListeningFuture(ctx, executor);\n+        endpointGroup.addListener(listeningFuture);\n+\n+        // Try to select again because the EndpointGroup might have been updated\n+        // between selectNow() and addListener() above.\n+        endpoint = selectNow(ctx);\n+        if (endpoint != null) {\n+            endpointGroup.removeListener(listeningFuture);\n+            return UnmodifiableFuture.completedFuture(endpoint);\n+        }\n+\n+        // Schedule the timeout task.\n+        final ScheduledFuture<?> timeoutFuture =\n+                executor.schedule(() -> listeningFuture.complete(null),\n+                                  timeoutMillis, TimeUnit.MILLISECONDS);\n+        listeningFuture.timeoutFuture = timeoutFuture;\n+\n+        // Cancel the timeout task if necessary, just in case listeningFuture is\n+        // completed even before we assign timeoutFuture to listeningFuture.timeoutFuture.\n+        if (listeningFuture.isDone()) {\n+            timeoutFuture.cancel(false);\n+        }\n+\n+        return listeningFuture;\n+    }\n+\n+    private class ListeningFuture extends CompletableFuture<Endpoint> implements Consumer<List<Endpoint>> {\n+        private final ClientRequestContext ctx;\n+        private final Executor executor;\n+        @Nullable\n+        private volatile Endpoint selectedEndpoint;\n+        @Nullable\n+        private volatile ScheduledFuture<?> timeoutFuture;\n+\n+        ListeningFuture(ClientRequestContext ctx, Executor executor) {\n+            this.ctx = ctx;\n+            this.executor = executor;\n+        }\n+\n+        @Override\n+        public void accept(List<Endpoint> unused) {\n+            if (selectedEndpoint != null || isDone()) {\n+                return;\n+            }\n+\n+            try {\n+                final Endpoint endpoint = AbstractEndpointSelector.this.selectNow(ctx);", "originalCommit": "6c65d471eb3957dc82a88efb18b1745a856cacd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk3ODcwMg==", "url": "https://github.com/line/armeria/pull/2837#discussion_r445978702", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.endpointGroup = null;\n          \n          \n            \n                    endpointGroup = null;", "author": "ikhoon", "createdAt": "2020-06-26T05:44:16Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -194,49 +199,84 @@ private static ServiceRequestContext serviceRequestContext() {\n      *         {@code false} if the initialization has failed and this context's {@link RequestLog} has been\n      *         completed with the cause of the failure.\n      */\n-    public boolean init(EndpointGroup endpointGroup) {\n+    public CompletableFuture<Boolean> init(EndpointGroup endpointGroup) {\n         assert endpoint == null : endpoint;\n         assert !initialized;\n         initialized = true;\n \n-        Throwable cause = null;\n         try {\n             if (endpointGroup instanceof Endpoint) {\n-                this.endpointGroup = null;\n-                updateEndpoint((Endpoint) endpointGroup);\n-                runThreadLocalContextCustomizers();\n+                return initEndpoint((Endpoint) endpointGroup);\n             } else {\n-                this.endpointGroup = endpointGroup;\n-                // Note: thread-local customizer must be run before EndpointSelector.select()\n-                //       so that the customizer can inject the attributes which may be required\n-                //       by the EndpointSelector.\n-                runThreadLocalContextCustomizers();\n-                updateEndpoint(endpointGroup.select(this));\n+                return initEndpointGroup(endpointGroup);\n             }\n         } catch (Throwable t) {\n-            cause = t;\n+            acquireEventLoop(endpointGroup);\n+            failEarly(t);\n+            return UnmodifiableFuture.completedFuture(false);\n         }\n+    }\n \n-        if (eventLoop == null) {\n-            final ReleasableHolder<EventLoop> releasableEventLoop =\n-                    options().factory().acquireEventLoop(sessionProtocol(), endpointGroup, endpoint);\n-            eventLoop = releasableEventLoop.get();\n-            log.whenComplete().thenAccept(unused -> releasableEventLoop.release());\n+    private UnmodifiableFuture<Boolean> initEndpoint(Endpoint endpoint) {\n+        this.endpointGroup = null;", "originalCommit": "6c65d471eb3957dc82a88efb18b1745a856cacd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk4MDI2Mg==", "url": "https://github.com/line/armeria/pull/2837#discussion_r445980262", "bodyText": "Question: Why thenCompose(Function.identity()) is needed here? \ud83e\uddd0", "author": "ikhoon", "createdAt": "2020-06-26T05:50:17Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -194,49 +199,84 @@ private static ServiceRequestContext serviceRequestContext() {\n      *         {@code false} if the initialization has failed and this context's {@link RequestLog} has been\n      *         completed with the cause of the failure.\n      */\n-    public boolean init(EndpointGroup endpointGroup) {\n+    public CompletableFuture<Boolean> init(EndpointGroup endpointGroup) {\n         assert endpoint == null : endpoint;\n         assert !initialized;\n         initialized = true;\n \n-        Throwable cause = null;\n         try {\n             if (endpointGroup instanceof Endpoint) {\n-                this.endpointGroup = null;\n-                updateEndpoint((Endpoint) endpointGroup);\n-                runThreadLocalContextCustomizers();\n+                return initEndpoint((Endpoint) endpointGroup);\n             } else {\n-                this.endpointGroup = endpointGroup;\n-                // Note: thread-local customizer must be run before EndpointSelector.select()\n-                //       so that the customizer can inject the attributes which may be required\n-                //       by the EndpointSelector.\n-                runThreadLocalContextCustomizers();\n-                updateEndpoint(endpointGroup.select(this));\n+                return initEndpointGroup(endpointGroup);\n             }\n         } catch (Throwable t) {\n-            cause = t;\n+            acquireEventLoop(endpointGroup);\n+            failEarly(t);\n+            return UnmodifiableFuture.completedFuture(false);\n         }\n+    }\n \n-        if (eventLoop == null) {\n-            final ReleasableHolder<EventLoop> releasableEventLoop =\n-                    options().factory().acquireEventLoop(sessionProtocol(), endpointGroup, endpoint);\n-            eventLoop = releasableEventLoop.get();\n-            log.whenComplete().thenAccept(unused -> releasableEventLoop.release());\n+    private UnmodifiableFuture<Boolean> initEndpoint(Endpoint endpoint) {\n+        this.endpointGroup = null;\n+        updateEndpoint(endpoint);\n+        runThreadLocalContextCustomizers();\n+        acquireEventLoop(endpoint);\n+        return UnmodifiableFuture.completedFuture(true);\n+    }\n+\n+    private CompletableFuture<Boolean> initEndpointGroup(EndpointGroup endpointGroup) {\n+        this.endpointGroup = endpointGroup;\n+        // Note: thread-local customizer must be run before EndpointSelector.select()\n+        //       so that the customizer can inject the attributes which may be required\n+        //       by the EndpointSelector.\n+        runThreadLocalContextCustomizers();\n+        final Endpoint endpoint = endpointGroup.selectNow(this);\n+        if (endpoint != null) {\n+            updateEndpoint(endpoint);\n+            acquireEventLoop(endpointGroup);\n+            return UnmodifiableFuture.completedFuture(true);\n         }\n \n-        if (cause != null) {\n-            failEarly(cause);\n-            return false;\n-        }\n+        // Use an arbitrary event loop for asynchronous Endpoint selection.\n+        final EventLoop temporaryEventLoop = options().factory().eventLoopSupplier().get();\n+        return endpointGroup.select(this, temporaryEventLoop, connectTimeoutMillis()).handle((e, cause) -> {\n+            updateEndpoint(e);\n+            acquireEventLoop(endpointGroup);\n+\n+            final boolean success;\n+            if (cause != null) {\n+                failEarly(cause);\n+                success = false;\n+            } else {\n+                success = true;\n+            }\n \n-        return true;\n+            final EventLoop acquiredEventLoop = eventLoop();\n+            if (acquiredEventLoop == temporaryEventLoop) {\n+                // We were lucky. No need to hand over to other EventLoop.\n+                return UnmodifiableFuture.completedFuture(success);\n+            } else {\n+                // We need to hand over to the acquired EventLoop.\n+                return CompletableFuture.supplyAsync(() -> success, acquiredEventLoop);\n+            }\n+        }).thenCompose(Function.identity());", "originalCommit": "6c65d471eb3957dc82a88efb18b1745a856cacd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyMzk4Nw==", "url": "https://github.com/line/armeria/pull/2837#discussion_r446023987", "bodyText": "To make CompletableFuture<CompletableFuture<Boolean>> to CompletableFuture<Boolean>?", "author": "minwoox", "createdAt": "2020-06-26T07:48:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk4MDI2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkwMDc3NQ==", "url": "https://github.com/line/armeria/pull/2837#discussion_r446900775", "bodyText": "Ah, flatten! \ud83e\udd23", "author": "ikhoon", "createdAt": "2020-06-29T11:33:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk4MDI2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk4NDE1OA==", "url": "https://github.com/line/armeria/pull/2837#discussion_r445984158", "bodyText": "Could merge two lines?", "author": "ikhoon", "createdAt": "2020-06-26T06:03:25Z", "path": "core/src/main/java/com/linecorp/armeria/internal/client/ClientUtil.java", "diffHunk": "@@ -39,41 +42,77 @@ O initContextAndExecuteWithFallback(\n             U delegate,\n             DefaultClientRequestContext ctx,\n             EndpointGroup endpointGroup,\n-            BiFunction<ClientRequestContext, Throwable, O> fallbackResponseFactory) {\n+            Function<CompletableFuture<O>, O> futureConverter,\n+            BiFunction<ClientRequestContext, Throwable, O> errorResponseFactory) {\n \n         requireNonNull(delegate, \"delegate\");\n         requireNonNull(ctx, \"ctx\");\n         requireNonNull(endpointGroup, \"endpointGroup\");\n-        requireNonNull(fallbackResponseFactory, \"fallbackResponseFactory\");\n+        requireNonNull(futureConverter, \"futureConverter\");\n+        requireNonNull(errorResponseFactory, \"errorResponseFactory\");\n \n         try {\n             endpointGroup = mapEndpoint(ctx, endpointGroup);\n-            if (ctx.init(endpointGroup)) {\n-                return pushAndExecute(delegate, ctx);\n-            } else {\n-                // Context initialization has failed, which means:\n-                // - ctx.log() has been completed with an exception.\n-                // - ctx.request() has been aborted (if not null).\n-                // - the decorator chain was not invoked at all.\n-                // See `init()` and `failEarly()` in `DefaultClientRequestContext`.\n-\n-                // Call the decorator chain anyway so that the request is seen by the decorators.\n-                final O res = pushAndExecute(delegate, ctx);\n-\n-                // We will use the fallback response which is created from the exception\n-                // raised in ctx.init(), so the response returned can be aborted.\n-                if (res instanceof StreamMessage) {\n-                    ((StreamMessage<?>) res).abort();\n+            final CompletableFuture<Boolean> initFuture = ctx.init(endpointGroup);\n+            if (initFuture.isDone()) {\n+                // Initialization has been done immediately.\n+                final boolean success;\n+                try {\n+                    success = initFuture.get();\n+                } catch (Exception e) {\n+                    throw Exceptions.peel(e);\n                 }\n \n-                // No need to call `fail()` because failed by `DefaultRequestContext.init()` already.\n-                final Throwable cause = ctx.log().partial().requestCause();\n-                assert cause != null;\n-                return fallbackResponseFactory.apply(ctx, cause);\n+                return initContextAndExecuteWithFallback(delegate, ctx, errorResponseFactory, success);\n+            } else {\n+                return futureConverter.apply(initFuture.handle((success, cause) -> {\n+                    try {\n+                        if (cause != null) {\n+                            throw cause;\n+                        }\n+\n+                        return initContextAndExecuteWithFallback(\n+                                delegate, ctx, errorResponseFactory, success);", "originalCommit": "6c65d471eb3957dc82a88efb18b1745a856cacd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk4NjY4Ng==", "url": "https://github.com/line/armeria/pull/2837#discussion_r445986686", "bodyText": "Wrap with UnprocessedRequestException.wrap(e) once #2836 is merged?", "author": "ikhoon", "createdAt": "2020-06-26T06:12:11Z", "path": "core/src/main/java/com/linecorp/armeria/internal/client/ClientUtil.java", "diffHunk": "@@ -39,41 +42,77 @@ O initContextAndExecuteWithFallback(\n             U delegate,\n             DefaultClientRequestContext ctx,\n             EndpointGroup endpointGroup,\n-            BiFunction<ClientRequestContext, Throwable, O> fallbackResponseFactory) {\n+            Function<CompletableFuture<O>, O> futureConverter,\n+            BiFunction<ClientRequestContext, Throwable, O> errorResponseFactory) {\n \n         requireNonNull(delegate, \"delegate\");\n         requireNonNull(ctx, \"ctx\");\n         requireNonNull(endpointGroup, \"endpointGroup\");\n-        requireNonNull(fallbackResponseFactory, \"fallbackResponseFactory\");\n+        requireNonNull(futureConverter, \"futureConverter\");\n+        requireNonNull(errorResponseFactory, \"errorResponseFactory\");\n \n         try {\n             endpointGroup = mapEndpoint(ctx, endpointGroup);\n-            if (ctx.init(endpointGroup)) {\n-                return pushAndExecute(delegate, ctx);\n-            } else {\n-                // Context initialization has failed, which means:\n-                // - ctx.log() has been completed with an exception.\n-                // - ctx.request() has been aborted (if not null).\n-                // - the decorator chain was not invoked at all.\n-                // See `init()` and `failEarly()` in `DefaultClientRequestContext`.\n-\n-                // Call the decorator chain anyway so that the request is seen by the decorators.\n-                final O res = pushAndExecute(delegate, ctx);\n-\n-                // We will use the fallback response which is created from the exception\n-                // raised in ctx.init(), so the response returned can be aborted.\n-                if (res instanceof StreamMessage) {\n-                    ((StreamMessage<?>) res).abort();\n+            final CompletableFuture<Boolean> initFuture = ctx.init(endpointGroup);\n+            if (initFuture.isDone()) {\n+                // Initialization has been done immediately.\n+                final boolean success;\n+                try {\n+                    success = initFuture.get();\n+                } catch (Exception e) {\n+                    throw Exceptions.peel(e);", "originalCommit": "6c65d471eb3957dc82a88efb18b1745a856cacd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA5NzIyMQ==", "url": "https://github.com/line/armeria/pull/2837#discussion_r446097221", "bodyText": "Done.", "author": "trustin", "createdAt": "2020-06-26T10:16:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk4NjY4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk5MDI1Mg==", "url": "https://github.com/line/armeria/pull/2837#discussion_r445990252", "bodyText": "Not related to this PR. Could we propagrate the cause to res via res.abort(cause)?", "author": "ikhoon", "createdAt": "2020-06-26T06:23:55Z", "path": "core/src/main/java/com/linecorp/armeria/internal/client/ClientUtil.java", "diffHunk": "@@ -39,41 +42,77 @@ O initContextAndExecuteWithFallback(\n             U delegate,\n             DefaultClientRequestContext ctx,\n             EndpointGroup endpointGroup,\n-            BiFunction<ClientRequestContext, Throwable, O> fallbackResponseFactory) {\n+            Function<CompletableFuture<O>, O> futureConverter,\n+            BiFunction<ClientRequestContext, Throwable, O> errorResponseFactory) {\n \n         requireNonNull(delegate, \"delegate\");\n         requireNonNull(ctx, \"ctx\");\n         requireNonNull(endpointGroup, \"endpointGroup\");\n-        requireNonNull(fallbackResponseFactory, \"fallbackResponseFactory\");\n+        requireNonNull(futureConverter, \"futureConverter\");\n+        requireNonNull(errorResponseFactory, \"errorResponseFactory\");\n \n         try {\n             endpointGroup = mapEndpoint(ctx, endpointGroup);\n-            if (ctx.init(endpointGroup)) {\n-                return pushAndExecute(delegate, ctx);\n-            } else {\n-                // Context initialization has failed, which means:\n-                // - ctx.log() has been completed with an exception.\n-                // - ctx.request() has been aborted (if not null).\n-                // - the decorator chain was not invoked at all.\n-                // See `init()` and `failEarly()` in `DefaultClientRequestContext`.\n-\n-                // Call the decorator chain anyway so that the request is seen by the decorators.\n-                final O res = pushAndExecute(delegate, ctx);\n-\n-                // We will use the fallback response which is created from the exception\n-                // raised in ctx.init(), so the response returned can be aborted.\n-                if (res instanceof StreamMessage) {\n-                    ((StreamMessage<?>) res).abort();\n+            final CompletableFuture<Boolean> initFuture = ctx.init(endpointGroup);\n+            if (initFuture.isDone()) {\n+                // Initialization has been done immediately.\n+                final boolean success;\n+                try {\n+                    success = initFuture.get();\n+                } catch (Exception e) {\n+                    throw Exceptions.peel(e);\n                 }\n \n-                // No need to call `fail()` because failed by `DefaultRequestContext.init()` already.\n-                final Throwable cause = ctx.log().partial().requestCause();\n-                assert cause != null;\n-                return fallbackResponseFactory.apply(ctx, cause);\n+                return initContextAndExecuteWithFallback(delegate, ctx, errorResponseFactory, success);\n+            } else {\n+                return futureConverter.apply(initFuture.handle((success, cause) -> {\n+                    try {\n+                        if (cause != null) {\n+                            throw cause;\n+                        }\n+\n+                        return initContextAndExecuteWithFallback(\n+                                delegate, ctx, errorResponseFactory, success);\n+                    } catch (Throwable t) {\n+                        fail(ctx, t);\n+                        return errorResponseFactory.apply(ctx, t);\n+                    }\n+                }));\n             }\n         } catch (Throwable cause) {\n             fail(ctx, cause);\n-            return fallbackResponseFactory.apply(ctx, cause);\n+            return errorResponseFactory.apply(ctx, cause);\n+        }\n+    }\n+\n+    private static <I extends Request, O extends Response, U extends Client<I, O>>\n+    O initContextAndExecuteWithFallback(\n+            U delegate, DefaultClientRequestContext ctx,\n+            BiFunction<ClientRequestContext, Throwable, O> errorResponseFactory, boolean succeeded)\n+            throws Exception {\n+\n+        if (succeeded) {\n+            return pushAndExecute(delegate, ctx);\n+        } else {\n+            // Context initialization has failed, which means:\n+            // - ctx.log() has been completed with an exception.\n+            // - ctx.request() has been aborted (if not null).\n+            // - the decorator chain was not invoked at all.\n+            // See `init()` and `failEarly()` in `DefaultClientRequestContext`.\n+\n+            // Call the decorator chain anyway so that the request is seen by the decorators.\n+            final O res = pushAndExecute(delegate, ctx);\n+\n+            // We will use the fallback response which is created from the exception\n+            // raised in ctx.init(), so the response returned can be aborted.\n+            if (res instanceof StreamMessage) {\n+                ((StreamMessage<?>) res).abort();\n+            }\n+\n+            // No need to call `fail()` because failed by `DefaultRequestContext.init()` already.\n+            final Throwable cause = ctx.log().partial().requestCause();\n+            assert cause != null;", "originalCommit": "6c65d471eb3957dc82a88efb18b1745a856cacd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1NjgyMg==", "url": "https://github.com/line/armeria/pull/2837#discussion_r446056822", "bodyText": "Done :-)", "author": "trustin", "createdAt": "2020-06-26T08:54:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk5MDI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyMTc0Mw==", "url": "https://github.com/line/armeria/pull/2837#discussion_r446021743", "bodyText": "How about making this private static final and reusing it?", "author": "minwoox", "createdAt": "2020-06-26T07:44:06Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -194,49 +199,84 @@ private static ServiceRequestContext serviceRequestContext() {\n      *         {@code false} if the initialization has failed and this context's {@link RequestLog} has been\n      *         completed with the cause of the failure.\n      */\n-    public boolean init(EndpointGroup endpointGroup) {\n+    public CompletableFuture<Boolean> init(EndpointGroup endpointGroup) {\n         assert endpoint == null : endpoint;\n         assert !initialized;\n         initialized = true;\n \n-        Throwable cause = null;\n         try {\n             if (endpointGroup instanceof Endpoint) {\n-                this.endpointGroup = null;\n-                updateEndpoint((Endpoint) endpointGroup);\n-                runThreadLocalContextCustomizers();\n+                return initEndpoint((Endpoint) endpointGroup);\n             } else {\n-                this.endpointGroup = endpointGroup;\n-                // Note: thread-local customizer must be run before EndpointSelector.select()\n-                //       so that the customizer can inject the attributes which may be required\n-                //       by the EndpointSelector.\n-                runThreadLocalContextCustomizers();\n-                updateEndpoint(endpointGroup.select(this));\n+                return initEndpointGroup(endpointGroup);\n             }\n         } catch (Throwable t) {\n-            cause = t;\n+            acquireEventLoop(endpointGroup);\n+            failEarly(t);\n+            return UnmodifiableFuture.completedFuture(false);\n         }\n+    }\n \n-        if (eventLoop == null) {\n-            final ReleasableHolder<EventLoop> releasableEventLoop =\n-                    options().factory().acquireEventLoop(sessionProtocol(), endpointGroup, endpoint);\n-            eventLoop = releasableEventLoop.get();\n-            log.whenComplete().thenAccept(unused -> releasableEventLoop.release());\n+    private UnmodifiableFuture<Boolean> initEndpoint(Endpoint endpoint) {\n+        this.endpointGroup = null;\n+        updateEndpoint(endpoint);\n+        runThreadLocalContextCustomizers();\n+        acquireEventLoop(endpoint);\n+        return UnmodifiableFuture.completedFuture(true);", "originalCommit": "6c65d471eb3957dc82a88efb18b1745a856cacd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1NDg0OA==", "url": "https://github.com/line/armeria/pull/2837#discussion_r446054848", "bodyText": "It's reused inside UnmodifiableFuture.", "author": "trustin", "createdAt": "2020-06-26T08:51:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyMTc0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1OTg2MA==", "url": "https://github.com/line/armeria/pull/2837#discussion_r446059860", "bodyText": "Ah I missed that as well. \ud83d\ude05", "author": "minwoox", "createdAt": "2020-06-26T09:00:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyMTc0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyMjQwOQ==", "url": "https://github.com/line/armeria/pull/2837#discussion_r446022409", "bodyText": "Can't we do acquireEventLoop(endpointGroup); first and use the eventLoop?", "author": "minwoox", "createdAt": "2020-06-26T07:45:28Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -194,49 +199,84 @@ private static ServiceRequestContext serviceRequestContext() {\n      *         {@code false} if the initialization has failed and this context's {@link RequestLog} has been\n      *         completed with the cause of the failure.\n      */\n-    public boolean init(EndpointGroup endpointGroup) {\n+    public CompletableFuture<Boolean> init(EndpointGroup endpointGroup) {\n         assert endpoint == null : endpoint;\n         assert !initialized;\n         initialized = true;\n \n-        Throwable cause = null;\n         try {\n             if (endpointGroup instanceof Endpoint) {\n-                this.endpointGroup = null;\n-                updateEndpoint((Endpoint) endpointGroup);\n-                runThreadLocalContextCustomizers();\n+                return initEndpoint((Endpoint) endpointGroup);\n             } else {\n-                this.endpointGroup = endpointGroup;\n-                // Note: thread-local customizer must be run before EndpointSelector.select()\n-                //       so that the customizer can inject the attributes which may be required\n-                //       by the EndpointSelector.\n-                runThreadLocalContextCustomizers();\n-                updateEndpoint(endpointGroup.select(this));\n+                return initEndpointGroup(endpointGroup);\n             }\n         } catch (Throwable t) {\n-            cause = t;\n+            acquireEventLoop(endpointGroup);\n+            failEarly(t);\n+            return UnmodifiableFuture.completedFuture(false);\n         }\n+    }\n \n-        if (eventLoop == null) {\n-            final ReleasableHolder<EventLoop> releasableEventLoop =\n-                    options().factory().acquireEventLoop(sessionProtocol(), endpointGroup, endpoint);\n-            eventLoop = releasableEventLoop.get();\n-            log.whenComplete().thenAccept(unused -> releasableEventLoop.release());\n+    private UnmodifiableFuture<Boolean> initEndpoint(Endpoint endpoint) {\n+        this.endpointGroup = null;\n+        updateEndpoint(endpoint);\n+        runThreadLocalContextCustomizers();\n+        acquireEventLoop(endpoint);\n+        return UnmodifiableFuture.completedFuture(true);\n+    }\n+\n+    private CompletableFuture<Boolean> initEndpointGroup(EndpointGroup endpointGroup) {\n+        this.endpointGroup = endpointGroup;\n+        // Note: thread-local customizer must be run before EndpointSelector.select()\n+        //       so that the customizer can inject the attributes which may be required\n+        //       by the EndpointSelector.\n+        runThreadLocalContextCustomizers();\n+        final Endpoint endpoint = endpointGroup.selectNow(this);\n+        if (endpoint != null) {\n+            updateEndpoint(endpoint);\n+            acquireEventLoop(endpointGroup);\n+            return UnmodifiableFuture.completedFuture(true);\n         }\n \n-        if (cause != null) {\n-            failEarly(cause);\n-            return false;\n-        }\n+        // Use an arbitrary event loop for asynchronous Endpoint selection.\n+        final EventLoop temporaryEventLoop = options().factory().eventLoopSupplier().get();", "originalCommit": "6c65d471eb3957dc82a88efb18b1745a856cacd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1NTM5MA==", "url": "https://github.com/line/armeria/pull/2837#discussion_r446055390", "bodyText": "We can, but why?", "author": "trustin", "createdAt": "2020-06-26T08:52:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyMjQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA2ODM0Ng==", "url": "https://github.com/line/armeria/pull/2837#discussion_r446068346", "bodyText": "Forget about this. \ud83d\ude05", "author": "minwoox", "createdAt": "2020-06-26T09:17:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyMjQwOQ=="}], "type": "inlineReview"}, {"oid": "ba5d60b3d1080bc4b3eeee8128163ff5390b3d41", "url": "https://github.com/line/armeria/commit/ba5d60b3d1080bc4b3eeee8128163ff5390b3d41", "message": "Merge branch 'master' into async_endpoint_selection", "committedDate": "2020-06-26T08:44:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0MjE3Mg==", "url": "https://github.com/line/armeria/pull/2837#discussion_r446042172", "bodyText": "If so listeningFuture.timeoutFuture = timeoutFuture; this line should move down.\nHowever, I'm wondering if there's a chance that listeningFuture.isDone() is true after we call endpoint = selectNow(ctx); when endpoint is null. \ud83e\udd14", "author": "minwoox", "createdAt": "2020-06-26T08:26:10Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/AbstractEndpointSelector.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+\n+/**\n+ * A skeletal {@link EndpointSelector} implementation. This abstract class implements the\n+ * {@link #select(ClientRequestContext, ScheduledExecutorService, long)} method by listening to\n+ * the change events emitted by {@link EndpointGroup} specified at construction time.\n+ */\n+public abstract class AbstractEndpointSelector implements EndpointSelector {\n+\n+    private final EndpointGroup endpointGroup;\n+\n+    /**\n+     * Creates a new instance that selects an {@link Endpoint} from the specified {@link EndpointGroup}.\n+     */\n+    protected AbstractEndpointSelector(EndpointGroup endpointGroup) {\n+        this.endpointGroup = requireNonNull(endpointGroup, \"endpointGroup\");\n+    }\n+\n+    /**\n+     * Returns the {@link EndpointGroup} being selected by this {@link EndpointSelector}.\n+     */\n+    protected final EndpointGroup group() {\n+        return endpointGroup;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<Endpoint> select(ClientRequestContext ctx,\n+                                                    ScheduledExecutorService executor,\n+                                                    long timeoutMillis) {\n+        Endpoint endpoint = selectNow(ctx);\n+        if (endpoint != null) {\n+            return UnmodifiableFuture.completedFuture(endpoint);\n+        }\n+\n+        final ListeningFuture listeningFuture = new ListeningFuture(ctx, executor);\n+        endpointGroup.addListener(listeningFuture);\n+\n+        // Try to select again because the EndpointGroup might have been updated\n+        // between selectNow() and addListener() above.\n+        endpoint = selectNow(ctx);\n+        if (endpoint != null) {\n+            endpointGroup.removeListener(listeningFuture);\n+            return UnmodifiableFuture.completedFuture(endpoint);\n+        }\n+\n+        // Schedule the timeout task.\n+        final ScheduledFuture<?> timeoutFuture =\n+                executor.schedule(() -> listeningFuture.complete(null),\n+                                  timeoutMillis, TimeUnit.MILLISECONDS);\n+        listeningFuture.timeoutFuture = timeoutFuture;\n+\n+        // Cancel the timeout task if necessary, just in case listeningFuture is\n+        // completed even before we assign timeoutFuture to listeningFuture.timeoutFuture.", "originalCommit": "6c65d471eb3957dc82a88efb18b1745a856cacd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA2NTY0Mg==", "url": "https://github.com/line/armeria/pull/2837#discussion_r446065642", "bodyText": "Updated the comment to explain better.", "author": "trustin", "createdAt": "2020-06-26T09:12:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0MjE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1MjUwNw==", "url": "https://github.com/line/armeria/pull/2837#discussion_r446052507", "bodyText": "Can we make this as an enum? \ud83e\udd14", "author": "minwoox", "createdAt": "2020-06-26T08:46:33Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/util/IdentityHashStrategy.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common.util;\n+\n+import it.unimi.dsi.fastutil.Hash.Strategy;\n+\n+public final class IdentityHashStrategy<T> implements Strategy<T> {", "originalCommit": "6c65d471eb3957dc82a88efb18b1745a856cacd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1NjIyMw==", "url": "https://github.com/line/armeria/pull/2837#discussion_r446056223", "bodyText": "Then we will lose the type parameter, i.e. the caller has to do an unchecked cast.", "author": "trustin", "createdAt": "2020-06-26T08:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1MjUwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1ODQwMg==", "url": "https://github.com/line/armeria/pull/2837#discussion_r446058402", "bodyText": "Oops, I missed that. \ud83d\ude13", "author": "minwoox", "createdAt": "2020-06-26T08:58:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1MjUwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1MjY2Mw==", "url": "https://github.com/line/armeria/pull/2837#discussion_r446052663", "bodyText": "2020?", "author": "minwoox", "createdAt": "2020-06-26T08:46:52Z", "path": "core/src/test/java/com/linecorp/armeria/client/ClientRequestContextDelayedInitTest.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright 2019 LINE Corporation", "originalCommit": "6c65d471eb3957dc82a88efb18b1745a856cacd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2e80415aab5bdbe9288f20b4ffc21871f15dcab6", "url": "https://github.com/line/armeria/commit/2e80415aab5bdbe9288f20b4ffc21871f15dcab6", "message": "Address the comments from @minwoox and @ikhoon", "committedDate": "2020-06-26T08:53:50Z", "type": "commit"}, {"oid": "23734dac6177fdd8b01d9ed6a45852423b578790", "url": "https://github.com/line/armeria/commit/23734dac6177fdd8b01d9ed6a45852423b578790", "message": "Comment", "committedDate": "2020-06-26T09:11:23Z", "type": "commit"}, {"oid": "521cc113489848cf091df86d603642f15927bd8d", "url": "https://github.com/line/armeria/commit/521cc113489848cf091df86d603642f15927bd8d", "message": "Merge branch 'master' into async_endpoint_selection", "committedDate": "2020-06-26T10:11:03Z", "type": "commit"}, {"oid": "58f7e01faae98a5987189c1b7cb2fef2d18fc280", "url": "https://github.com/line/armeria/commit/58f7e01faae98a5987189c1b7cb2fef2d18fc280", "message": "Wrap with `UnprocessedRequestException` as advised by @ikhoon", "committedDate": "2020-06-26T10:15:18Z", "type": "commit"}]}