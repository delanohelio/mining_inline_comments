{"pr_number": 2392, "pr_title": "Send periodic `102 Processing` headers for long-polling health\u2026", "pr_createdAt": "2020-01-10T10:06:20Z", "pr_url": "https://github.com/line/armeria/pull/2392", "timeline": [{"oid": "7bbe84222163a8936f31869dc06cb7b6cbde994e", "url": "https://github.com/line/armeria/commit/7bbe84222163a8936f31869dc06cb7b6cbde994e", "message": "Send periodic `102 Processing` headers for long-polling health checks\n\nMotivation:\n\nWith long-polling health check, it is currently not possible to\ndistinguish unresponsive servers who just accepts sockets doing nothing.\n`HealthCheckService` must send some informational headers periodically,\nsuch as `102 Processing`.\n\nModifications:\n\n- Change the format of the `armeria-lphc` header value to contain two\n  values:\n  - `maxLongPollingTimeoutSeconds`\n  - `pingIntervalSeconds`\n- Change the behavior of `HealthCheckService` to send `102 Processing`\n  informational headers every `pingIntervalSeconds`.\n  - Updated `HealthCheckServiceBuilder.longPolling()`\n- Change the behavior of `HealthCheckedEndpointGroup` to mark an\n  `Endpoint` as unhealthy when not receiving a ping for last\n  `pingIntervalSeconds * 2` seconds.\n- Miscellaneous:\n  - Removed `Http` from the test classes that test `HealthCheckEndpointGroup`\n\nResult:\n\n- Fixes #2386\n- `HealthCheckedEndpointGroup` now marks an unresponsive endpoints as\n  soon as possible when long-polling is enabled.\n- The old Armeria clients will automatically fall back to traditional\n  periodic health check, because it does not understand the new header\n  format.", "committedDate": "2020-01-10T10:05:08Z", "type": "commit"}, {"oid": "2b52f6fb51a238a1d17da4d8caeb825c222bfb3c", "url": "https://github.com/line/armeria/commit/2b52f6fb51a238a1d17da4d8caeb825c222bfb3c", "message": "Remove unused fields", "committedDate": "2020-01-10T10:09:32Z", "type": "commit"}, {"oid": "e512d5eeea3fc18b46a4e87bd602a03b586c32f7", "url": "https://github.com/line/armeria/commit/e512d5eeea3fc18b46a4e87bd602a03b586c32f7", "message": "Fix test failures", "committedDate": "2020-01-10T10:11:52Z", "type": "commit"}, {"oid": "db00fffa64e6008decb710fdf51a885b082e7513", "url": "https://github.com/line/armeria/commit/db00fffa64e6008decb710fdf51a885b082e7513", "message": "More fixes", "committedDate": "2020-01-10T10:20:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcxNTQ3MA==", "url": "https://github.com/line/armeria/pull/2392#discussion_r365715470", "bodyText": "shouldn't we do this on ctx.executor() not the eventLoop used on the first health check request?\nForget about it. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-01-13T09:51:35Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "diffHunk": "@@ -89,35 +107,188 @@ private synchronized void check() {\n             headers = builder.build();\n         }\n \n-        lastResponse = webClient.execute(headers);\n-        lastResponse.aggregate().handle((res, cause) -> {\n+        try (ClientRequestContextCaptor reqCtxCaptor = Clients.newContextCaptor()) {\n+            lastResponse = webClient.execute(headers);\n+            final ClientRequestContext reqCtx = reqCtxCaptor.get();\n+            lastResponse.subscribe(new HealthCheckResponseSubscriber(reqCtx, lastResponse),\n+                                   reqCtx.eventLoop(), SubscriptionOption.WITH_POOLED_OBJECTS);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized CompletableFuture<?> closeAsync() {\n+        if (lastResponse != null) {\n+            if (!closed) {\n+                closed = true;\n+                lastResponse.abort();\n+            }\n+            return lastResponse.completionFuture().handle((unused1, unused2) -> null);\n+        } else {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+    }\n+\n+    private final class ResponseTimeoutUpdater extends SimpleDecoratingHttpClient {\n+        ResponseTimeoutUpdater(HttpClient delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Exception {\n+            if (maxLongPollingSeconds > 0) {\n+                final long responseTimeoutMillis = ctx.responseTimeoutMillis();\n+                if (responseTimeoutMillis > 0) {\n+                    ctx.extendResponseTimeoutMillis(TimeUnit.SECONDS.toMillis(maxLongPollingSeconds));\n+                }\n+            }\n+            return delegate().execute(ctx, req);\n+        }\n+    }\n+\n+    private class HealthCheckResponseSubscriber implements Subscriber<HttpObject> {\n+\n+        private final ClientRequestContext reqCtx;\n+        private final HttpResponse res;\n+        @SuppressWarnings(\"NotNullFieldNotInitialized\")\n+        private Subscription subscription;\n+        private boolean isHealthy;\n+        private boolean receivedExpectedResponse;\n+        private boolean updatedHealth;\n+\n+        @Nullable\n+        private ScheduledFuture<?> pingCheckFuture;\n+        private long lastPingTimeNanos;\n+\n+        HealthCheckResponseSubscriber(ClientRequestContext reqCtx, HttpResponse res) {\n+            this.reqCtx = reqCtx;\n+            this.res = res;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.subscription = subscription;\n+            subscription.request(1);\n+            maybeSchedulePingCheck();\n+        }\n+\n+        @Override\n+        public void onNext(HttpObject obj) {\n             if (closed) {\n-                return null;\n+                subscription.cancel();\n+                return;\n             }\n \n-            boolean isHealthy = false;\n-            if (res != null) {\n-                switch (res.status().codeClass()) {\n-                    case SUCCESS:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n-                        isHealthy = true;\n+            try {\n+                if (!(obj instanceof ResponseHeaders)) {\n+                    ReferenceCountUtil.release(obj);\n+                    return;\n+                }\n+\n+                final ResponseHeaders headers = (ResponseHeaders) obj;\n+                updateLongPollingSettings(headers);\n+\n+                final HttpStatusClass statusClass = headers.status().codeClass();\n+                switch (statusClass) {\n+                    case INFORMATIONAL:\n+                        maybeSchedulePingCheck();\n                         break;\n                     case SERVER_ERROR:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        receivedExpectedResponse = true;\n+                        break;\n+                    case SUCCESS:\n+                        isHealthy = true;\n+                        receivedExpectedResponse = true;\n                         break;\n                     default:\n-                        if (res.status() == HttpStatus.NOT_MODIFIED) {\n-                            maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        if (headers.status() == HttpStatus.NOT_MODIFIED) {\n                             isHealthy = wasHealthy;\n+                            receivedExpectedResponse = true;\n                         } else {\n                             // Do not use long polling on an unexpected status for safety.\n                             maxLongPollingSeconds = 0;\n+                            logger.warn(\"{} Unexpected health check response: {}\", reqCtx, headers);\n                         }\n                 }\n-            } else {\n+            } finally {\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {\n+            updateHealth();\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            updateHealth();\n+        }\n+\n+        private void updateLongPollingSettings(ResponseHeaders headers) {\n+            final String longPollingSettings = headers.get(ARMERIA_LPHC);\n+            if (longPollingSettings == null) {\n                 maxLongPollingSeconds = 0;\n+                pingIntervalSeconds = 0;\n+                return;\n             }\n \n+            final int commaPos = longPollingSettings.indexOf(',');\n+            long maxLongPollingSeconds = 0;\n+            long pingIntervalSeconds = 0;\n+            try {\n+                maxLongPollingSeconds = Integer.max(\n+                        0, Integer.parseInt(longPollingSettings.substring(0, commaPos).trim()));\n+                pingIntervalSeconds = Integer.max(\n+                        0, Integer.parseInt(longPollingSettings.substring(commaPos + 1).trim()));\n+            } catch (NumberFormatException e) {\n+                // Ignore malformed settings.\n+            }\n+\n+            HttpHealthChecker.this.maxLongPollingSeconds = maxLongPollingSeconds;\n+            if (maxLongPollingSeconds > 0 && pingIntervalSeconds < maxLongPollingSeconds) {\n+                HttpHealthChecker.this.pingIntervalSeconds = pingIntervalSeconds;\n+            } else {\n+                HttpHealthChecker.this.pingIntervalSeconds = 0;\n+            }\n+        }\n+\n+        // TODO(trustin): Remove once https://github.com/line/armeria/issues/1063 is fixed.\n+        private void maybeSchedulePingCheck() {\n+            lastPingTimeNanos = System.nanoTime();\n+\n+            if (pingCheckFuture != null) {\n+                return;\n+            }\n+\n+            final long pingIntervalSeconds = HttpHealthChecker.this.pingIntervalSeconds;\n+            final long pingTimeoutNanos = LongMath.saturatedMultiply(\n+                    TimeUnit.SECONDS.toNanos(pingIntervalSeconds), 2);\n+            if (pingIntervalSeconds <= 0) {\n+                return;\n+            }\n+\n+            pingCheckFuture = reqCtx.eventLoop().scheduleWithFixedDelay(() -> {", "originalCommit": "db00fffa64e6008decb710fdf51a885b082e7513", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY2ODkxNQ==", "url": "https://github.com/line/armeria/pull/2392#discussion_r365668915", "bodyText": "nit: Could return early? You think it is trivial, feel free to ignore this.\ud83d\ude00\nfinal long pingIntervalSeconds = HttpHealthChecker.this.pingIntervalSeconds;\nif (pingIntervalSeconds <= 0) {\n    return;\n}\nfinal long pingTimeoutNanos = LongMath.saturatedMultiply(\n        TimeUnit.SECONDS.toNanos(pingIntervalSeconds), 2);", "author": "ikhoon", "createdAt": "2020-01-13T07:27:41Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "diffHunk": "@@ -89,35 +107,188 @@ private synchronized void check() {\n             headers = builder.build();\n         }\n \n-        lastResponse = webClient.execute(headers);\n-        lastResponse.aggregate().handle((res, cause) -> {\n+        try (ClientRequestContextCaptor reqCtxCaptor = Clients.newContextCaptor()) {\n+            lastResponse = webClient.execute(headers);\n+            final ClientRequestContext reqCtx = reqCtxCaptor.get();\n+            lastResponse.subscribe(new HealthCheckResponseSubscriber(reqCtx, lastResponse),\n+                                   reqCtx.eventLoop(), SubscriptionOption.WITH_POOLED_OBJECTS);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized CompletableFuture<?> closeAsync() {\n+        if (lastResponse != null) {\n+            if (!closed) {\n+                closed = true;\n+                lastResponse.abort();\n+            }\n+            return lastResponse.completionFuture().handle((unused1, unused2) -> null);\n+        } else {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+    }\n+\n+    private final class ResponseTimeoutUpdater extends SimpleDecoratingHttpClient {\n+        ResponseTimeoutUpdater(HttpClient delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Exception {\n+            if (maxLongPollingSeconds > 0) {\n+                final long responseTimeoutMillis = ctx.responseTimeoutMillis();\n+                if (responseTimeoutMillis > 0) {\n+                    ctx.extendResponseTimeoutMillis(TimeUnit.SECONDS.toMillis(maxLongPollingSeconds));\n+                }\n+            }\n+            return delegate().execute(ctx, req);\n+        }\n+    }\n+\n+    private class HealthCheckResponseSubscriber implements Subscriber<HttpObject> {\n+\n+        private final ClientRequestContext reqCtx;\n+        private final HttpResponse res;\n+        @SuppressWarnings(\"NotNullFieldNotInitialized\")\n+        private Subscription subscription;\n+        private boolean isHealthy;\n+        private boolean receivedExpectedResponse;\n+        private boolean updatedHealth;\n+\n+        @Nullable\n+        private ScheduledFuture<?> pingCheckFuture;\n+        private long lastPingTimeNanos;\n+\n+        HealthCheckResponseSubscriber(ClientRequestContext reqCtx, HttpResponse res) {\n+            this.reqCtx = reqCtx;\n+            this.res = res;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.subscription = subscription;\n+            subscription.request(1);\n+            maybeSchedulePingCheck();\n+        }\n+\n+        @Override\n+        public void onNext(HttpObject obj) {\n             if (closed) {\n-                return null;\n+                subscription.cancel();\n+                return;\n             }\n \n-            boolean isHealthy = false;\n-            if (res != null) {\n-                switch (res.status().codeClass()) {\n-                    case SUCCESS:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n-                        isHealthy = true;\n+            try {\n+                if (!(obj instanceof ResponseHeaders)) {\n+                    ReferenceCountUtil.release(obj);\n+                    return;\n+                }\n+\n+                final ResponseHeaders headers = (ResponseHeaders) obj;\n+                updateLongPollingSettings(headers);\n+\n+                final HttpStatusClass statusClass = headers.status().codeClass();\n+                switch (statusClass) {\n+                    case INFORMATIONAL:\n+                        maybeSchedulePingCheck();\n                         break;\n                     case SERVER_ERROR:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        receivedExpectedResponse = true;\n+                        break;\n+                    case SUCCESS:\n+                        isHealthy = true;\n+                        receivedExpectedResponse = true;\n                         break;\n                     default:\n-                        if (res.status() == HttpStatus.NOT_MODIFIED) {\n-                            maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        if (headers.status() == HttpStatus.NOT_MODIFIED) {\n                             isHealthy = wasHealthy;\n+                            receivedExpectedResponse = true;\n                         } else {\n                             // Do not use long polling on an unexpected status for safety.\n                             maxLongPollingSeconds = 0;\n+                            logger.warn(\"{} Unexpected health check response: {}\", reqCtx, headers);\n                         }\n                 }\n-            } else {\n+            } finally {\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {\n+            updateHealth();\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            updateHealth();\n+        }\n+\n+        private void updateLongPollingSettings(ResponseHeaders headers) {\n+            final String longPollingSettings = headers.get(ARMERIA_LPHC);\n+            if (longPollingSettings == null) {\n                 maxLongPollingSeconds = 0;\n+                pingIntervalSeconds = 0;\n+                return;\n             }\n \n+            final int commaPos = longPollingSettings.indexOf(',');\n+            long maxLongPollingSeconds = 0;\n+            long pingIntervalSeconds = 0;\n+            try {\n+                maxLongPollingSeconds = Integer.max(\n+                        0, Integer.parseInt(longPollingSettings.substring(0, commaPos).trim()));\n+                pingIntervalSeconds = Integer.max(\n+                        0, Integer.parseInt(longPollingSettings.substring(commaPos + 1).trim()));\n+            } catch (NumberFormatException e) {\n+                // Ignore malformed settings.\n+            }\n+\n+            HttpHealthChecker.this.maxLongPollingSeconds = maxLongPollingSeconds;\n+            if (maxLongPollingSeconds > 0 && pingIntervalSeconds < maxLongPollingSeconds) {\n+                HttpHealthChecker.this.pingIntervalSeconds = pingIntervalSeconds;\n+            } else {\n+                HttpHealthChecker.this.pingIntervalSeconds = 0;\n+            }\n+        }\n+\n+        // TODO(trustin): Remove once https://github.com/line/armeria/issues/1063 is fixed.\n+        private void maybeSchedulePingCheck() {\n+            lastPingTimeNanos = System.nanoTime();\n+\n+            if (pingCheckFuture != null) {\n+                return;\n+            }\n+\n+            final long pingIntervalSeconds = HttpHealthChecker.this.pingIntervalSeconds;\n+            final long pingTimeoutNanos = LongMath.saturatedMultiply(\n+                    TimeUnit.SECONDS.toNanos(pingIntervalSeconds), 2);\n+            if (pingIntervalSeconds <= 0) {\n+                return;\n+            }", "originalCommit": "db00fffa64e6008decb710fdf51a885b082e7513", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEzNDk2NQ==", "url": "https://github.com/line/armeria/pull/2392#discussion_r366134965", "bodyText": "Indeed.", "author": "trustin", "createdAt": "2020-01-14T03:11:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY2ODkxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NDMzMA==", "url": "https://github.com/line/armeria/pull/2392#discussion_r365744330", "bodyText": "I notice this is copied but wondered, why we don't set closed in this branch?", "author": "anuraaga", "createdAt": "2020-01-13T10:57:31Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "diffHunk": "@@ -89,35 +107,188 @@ private synchronized void check() {\n             headers = builder.build();\n         }\n \n-        lastResponse = webClient.execute(headers);\n-        lastResponse.aggregate().handle((res, cause) -> {\n+        try (ClientRequestContextCaptor reqCtxCaptor = Clients.newContextCaptor()) {\n+            lastResponse = webClient.execute(headers);\n+            final ClientRequestContext reqCtx = reqCtxCaptor.get();\n+            lastResponse.subscribe(new HealthCheckResponseSubscriber(reqCtx, lastResponse),\n+                                   reqCtx.eventLoop(), SubscriptionOption.WITH_POOLED_OBJECTS);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized CompletableFuture<?> closeAsync() {\n+        if (lastResponse != null) {\n+            if (!closed) {\n+                closed = true;\n+                lastResponse.abort();\n+            }\n+            return lastResponse.completionFuture().handle((unused1, unused2) -> null);\n+        } else {", "originalCommit": "db00fffa64e6008decb710fdf51a885b082e7513", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEzNDgyOA==", "url": "https://github.com/line/armeria/pull/2392#discussion_r366134828", "bodyText": "Because it's a bug? \ud83d\ude06", "author": "trustin", "createdAt": "2020-01-14T03:11:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NDMzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0OTAzMw==", "url": "https://github.com/line/armeria/pull/2392#discussion_r365749033", "bodyText": "Don't think these need to be long, especially the ping interval", "author": "anuraaga", "createdAt": "2020-01-13T11:09:45Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "diffHunk": "@@ -89,35 +107,188 @@ private synchronized void check() {\n             headers = builder.build();\n         }\n \n-        lastResponse = webClient.execute(headers);\n-        lastResponse.aggregate().handle((res, cause) -> {\n+        try (ClientRequestContextCaptor reqCtxCaptor = Clients.newContextCaptor()) {\n+            lastResponse = webClient.execute(headers);\n+            final ClientRequestContext reqCtx = reqCtxCaptor.get();\n+            lastResponse.subscribe(new HealthCheckResponseSubscriber(reqCtx, lastResponse),\n+                                   reqCtx.eventLoop(), SubscriptionOption.WITH_POOLED_OBJECTS);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized CompletableFuture<?> closeAsync() {\n+        if (lastResponse != null) {\n+            if (!closed) {\n+                closed = true;\n+                lastResponse.abort();\n+            }\n+            return lastResponse.completionFuture().handle((unused1, unused2) -> null);\n+        } else {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+    }\n+\n+    private final class ResponseTimeoutUpdater extends SimpleDecoratingHttpClient {\n+        ResponseTimeoutUpdater(HttpClient delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Exception {\n+            if (maxLongPollingSeconds > 0) {\n+                final long responseTimeoutMillis = ctx.responseTimeoutMillis();\n+                if (responseTimeoutMillis > 0) {\n+                    ctx.extendResponseTimeoutMillis(TimeUnit.SECONDS.toMillis(maxLongPollingSeconds));\n+                }\n+            }\n+            return delegate().execute(ctx, req);\n+        }\n+    }\n+\n+    private class HealthCheckResponseSubscriber implements Subscriber<HttpObject> {\n+\n+        private final ClientRequestContext reqCtx;\n+        private final HttpResponse res;\n+        @SuppressWarnings(\"NotNullFieldNotInitialized\")\n+        private Subscription subscription;\n+        private boolean isHealthy;\n+        private boolean receivedExpectedResponse;\n+        private boolean updatedHealth;\n+\n+        @Nullable\n+        private ScheduledFuture<?> pingCheckFuture;\n+        private long lastPingTimeNanos;\n+\n+        HealthCheckResponseSubscriber(ClientRequestContext reqCtx, HttpResponse res) {\n+            this.reqCtx = reqCtx;\n+            this.res = res;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.subscription = subscription;\n+            subscription.request(1);\n+            maybeSchedulePingCheck();\n+        }\n+\n+        @Override\n+        public void onNext(HttpObject obj) {\n             if (closed) {\n-                return null;\n+                subscription.cancel();\n+                return;\n             }\n \n-            boolean isHealthy = false;\n-            if (res != null) {\n-                switch (res.status().codeClass()) {\n-                    case SUCCESS:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n-                        isHealthy = true;\n+            try {\n+                if (!(obj instanceof ResponseHeaders)) {\n+                    ReferenceCountUtil.release(obj);\n+                    return;\n+                }\n+\n+                final ResponseHeaders headers = (ResponseHeaders) obj;\n+                updateLongPollingSettings(headers);\n+\n+                final HttpStatusClass statusClass = headers.status().codeClass();\n+                switch (statusClass) {\n+                    case INFORMATIONAL:\n+                        maybeSchedulePingCheck();\n                         break;\n                     case SERVER_ERROR:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        receivedExpectedResponse = true;\n+                        break;\n+                    case SUCCESS:\n+                        isHealthy = true;\n+                        receivedExpectedResponse = true;\n                         break;\n                     default:\n-                        if (res.status() == HttpStatus.NOT_MODIFIED) {\n-                            maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        if (headers.status() == HttpStatus.NOT_MODIFIED) {\n                             isHealthy = wasHealthy;\n+                            receivedExpectedResponse = true;\n                         } else {\n                             // Do not use long polling on an unexpected status for safety.\n                             maxLongPollingSeconds = 0;\n+                            logger.warn(\"{} Unexpected health check response: {}\", reqCtx, headers);\n                         }\n                 }\n-            } else {\n+            } finally {\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {\n+            updateHealth();\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            updateHealth();\n+        }\n+\n+        private void updateLongPollingSettings(ResponseHeaders headers) {\n+            final String longPollingSettings = headers.get(ARMERIA_LPHC);\n+            if (longPollingSettings == null) {\n                 maxLongPollingSeconds = 0;\n+                pingIntervalSeconds = 0;\n+                return;\n             }\n \n+            final int commaPos = longPollingSettings.indexOf(',');\n+            long maxLongPollingSeconds = 0;", "originalCommit": "db00fffa64e6008decb710fdf51a885b082e7513", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEzNDkyOQ==", "url": "https://github.com/line/armeria/pull/2392#discussion_r366134929", "bodyText": "All changed to int", "author": "trustin", "createdAt": "2020-01-14T03:11:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0OTAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc1MTkzNg==", "url": "https://github.com/line/armeria/pull/2392#discussion_r365751936", "bodyText": "Should extend itself be a no-op if the timeout is 0?", "author": "anuraaga", "createdAt": "2020-01-13T11:17:30Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "diffHunk": "@@ -89,35 +107,188 @@ private synchronized void check() {\n             headers = builder.build();\n         }\n \n-        lastResponse = webClient.execute(headers);\n-        lastResponse.aggregate().handle((res, cause) -> {\n+        try (ClientRequestContextCaptor reqCtxCaptor = Clients.newContextCaptor()) {\n+            lastResponse = webClient.execute(headers);\n+            final ClientRequestContext reqCtx = reqCtxCaptor.get();\n+            lastResponse.subscribe(new HealthCheckResponseSubscriber(reqCtx, lastResponse),\n+                                   reqCtx.eventLoop(), SubscriptionOption.WITH_POOLED_OBJECTS);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized CompletableFuture<?> closeAsync() {\n+        if (lastResponse != null) {\n+            if (!closed) {\n+                closed = true;\n+                lastResponse.abort();\n+            }\n+            return lastResponse.completionFuture().handle((unused1, unused2) -> null);\n+        } else {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+    }\n+\n+    private final class ResponseTimeoutUpdater extends SimpleDecoratingHttpClient {\n+        ResponseTimeoutUpdater(HttpClient delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Exception {\n+            if (maxLongPollingSeconds > 0) {\n+                final long responseTimeoutMillis = ctx.responseTimeoutMillis();\n+                if (responseTimeoutMillis > 0) {", "originalCommit": "db00fffa64e6008decb710fdf51a885b082e7513", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEzNDg4Mg==", "url": "https://github.com/line/armeria/pull/2392#discussion_r366134882", "bodyText": "Good point. No need for if.", "author": "trustin", "createdAt": "2020-01-14T03:11:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc1MTkzNg=="}], "type": "inlineReview"}, {"oid": "46299fd0238d40a7e5cf755cc2d00f440a0aa43f", "url": "https://github.com/line/armeria/commit/46299fd0238d40a7e5cf755cc2d00f440a0aa43f", "message": "Address the comments from @ikhoon and @anuraaga", "committedDate": "2020-01-14T03:11:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjIzNDc0OA==", "url": "https://github.com/line/armeria/pull/2392#discussion_r366234748", "bodyText": "Just noticed this is probably for #1913.\nDo you think we can special case 4XX with something like \"Received 4XX health check response. This generally indicates a misconfiguration of the client. Did you happen to forget to configure the endpoint group option with those of the client?\"", "author": "anuraaga", "createdAt": "2020-01-14T09:38:27Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/healthcheck/HttpHealthChecker.java", "diffHunk": "@@ -89,35 +107,189 @@ private synchronized void check() {\n             headers = builder.build();\n         }\n \n-        lastResponse = webClient.execute(headers);\n-        lastResponse.aggregate().handle((res, cause) -> {\n+        try (ClientRequestContextCaptor reqCtxCaptor = Clients.newContextCaptor()) {\n+            lastResponse = webClient.execute(headers);\n+            final ClientRequestContext reqCtx = reqCtxCaptor.get();\n+            lastResponse.subscribe(new HealthCheckResponseSubscriber(reqCtx, lastResponse),\n+                                   reqCtx.eventLoop(), SubscriptionOption.WITH_POOLED_OBJECTS);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized CompletableFuture<?> closeAsync() {\n+        if (lastResponse == null) {\n+            // Called even before the first request is sent.\n+            closed = true;\n+            return CompletableFuture.completedFuture(null);\n+        }\n+\n+        if (!closed) {\n+            closed = true;\n+            lastResponse.abort();\n+        }\n+\n+        return lastResponse.completionFuture().handle((unused1, unused2) -> null);\n+    }\n+\n+    private final class ResponseTimeoutUpdater extends SimpleDecoratingHttpClient {\n+        ResponseTimeoutUpdater(HttpClient delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Exception {\n+            if (maxLongPollingSeconds > 0) {\n+                ctx.extendResponseTimeoutMillis(TimeUnit.SECONDS.toMillis(maxLongPollingSeconds));\n+            }\n+            return delegate().execute(ctx, req);\n+        }\n+    }\n+\n+    private class HealthCheckResponseSubscriber implements Subscriber<HttpObject> {\n+\n+        private final ClientRequestContext reqCtx;\n+        private final HttpResponse res;\n+        @SuppressWarnings(\"NotNullFieldNotInitialized\")\n+        private Subscription subscription;\n+        private boolean isHealthy;\n+        private boolean receivedExpectedResponse;\n+        private boolean updatedHealth;\n+\n+        @Nullable\n+        private ScheduledFuture<?> pingCheckFuture;\n+        private long lastPingTimeNanos;\n+\n+        HealthCheckResponseSubscriber(ClientRequestContext reqCtx, HttpResponse res) {\n+            this.reqCtx = reqCtx;\n+            this.res = res;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.subscription = subscription;\n+            subscription.request(1);\n+            maybeSchedulePingCheck();\n+        }\n+\n+        @Override\n+        public void onNext(HttpObject obj) {\n             if (closed) {\n-                return null;\n+                subscription.cancel();\n+                return;\n             }\n \n-            boolean isHealthy = false;\n-            if (res != null) {\n-                switch (res.status().codeClass()) {\n-                    case SUCCESS:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n-                        isHealthy = true;\n+            try {\n+                if (!(obj instanceof ResponseHeaders)) {\n+                    ReferenceCountUtil.release(obj);\n+                    return;\n+                }\n+\n+                final ResponseHeaders headers = (ResponseHeaders) obj;\n+                updateLongPollingSettings(headers);\n+\n+                final HttpStatusClass statusClass = headers.status().codeClass();\n+                switch (statusClass) {\n+                    case INFORMATIONAL:\n+                        maybeSchedulePingCheck();\n                         break;\n                     case SERVER_ERROR:\n-                        maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        receivedExpectedResponse = true;\n+                        break;\n+                    case SUCCESS:\n+                        isHealthy = true;\n+                        receivedExpectedResponse = true;\n                         break;\n                     default:\n-                        if (res.status() == HttpStatus.NOT_MODIFIED) {\n-                            maxLongPollingSeconds = getMaxLongPollingSeconds(res);\n+                        if (headers.status() == HttpStatus.NOT_MODIFIED) {\n                             isHealthy = wasHealthy;\n+                            receivedExpectedResponse = true;\n                         } else {\n                             // Do not use long polling on an unexpected status for safety.\n                             maxLongPollingSeconds = 0;\n+                            logger.warn(\"{} Unexpected health check response: {}\", reqCtx, headers);", "originalCommit": "46299fd0238d40a7e5cf755cc2d00f440a0aa43f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}