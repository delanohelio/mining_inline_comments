{"pr_number": 2531, "pr_title": "More ways to customize export keys for `RequestContextExporter`", "pr_createdAt": "2020-02-25T10:44:03Z", "pr_url": "https://github.com/line/armeria/pull/2531", "timeline": [{"oid": "67fd22028f48c7f55fbc35c0a5b9b5ff64dcda42", "url": "https://github.com/line/armeria/commit/67fd22028f48c7f55fbc35c0a5b9b5ff64dcda42", "message": "Provide a way to customize export keys for `RequestContextExporter`\n\nMotivation:\n\nA user can export built-in properties and context attributes with predefined key or prefix.\nSometiems, he / she wants export it with a different key for `JSON` structured logging.\nPlease see #2512 for more detail discussion.\n\nModifications:\n\n- Add new builder methods to `RequestContextBuilder` for customizing the exporting key\n- Introduce new alias format for Logback.\n  - <alias>=<build-in properties>\n  - <alias>=attr:com.example.Foo#ATTR_BAR\n  For example:\n  ```xml\n  <export>request_id=req.id</export>\n  <export>my_foo_bar=attr:com.example.Foo#ATTR_BAR</export>\n  ```\n- Move exporting from `RequestContextExporter` into `BuiltInProperty`\n\nResult:\nYou can now customize an MDC key for `RequestContext` through logback configuration.\nFixes: #2512", "committedDate": "2020-02-25T10:41:41Z", "type": "commit"}, {"oid": "8f064deae887ec6d1b23e26698697ebc1f0e87d6", "url": "https://github.com/line/armeria/commit/8f064deae887ec6d1b23e26698697ebc1f0e87d6", "message": "Fix broken tests", "committedDate": "2020-02-25T12:55:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMDk2Ng==", "url": "https://github.com/line/armeria/pull/2531#discussion_r384930966", "bodyText": "Probably not worth a method?", "author": "trustin", "createdAt": "2020-02-27T06:15:07Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/BuiltInProperty.java", "diffHunk": "@@ -182,9 +309,82 @@\n                         .collect(toImmutableList());\n     }\n \n+    static BuiltInProperty findByKey(String key) {\n+        return keyToEnum.entrySet().stream()\n+                        .filter(e -> e.getKey().equals(key))\n+                        .map(Entry::getValue)\n+                        .findFirst().orElse(null);\n+    }\n+\n+    private static BaseEncoding lowerCasedBase16() {\n+        return lowerCasedBase16;\n+    }", "originalCommit": "8f064deae887ec6d1b23e26698697ebc1f0e87d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzNzYyMw==", "url": "https://github.com/line/armeria/pull/2531#discussion_r384937623", "bodyText": "I tried to avoid an illegal forward reference. Now, I found a workaround for this.\nLet me use a qualified name. \ud83d\ude00", "author": "ikhoon", "createdAt": "2020-02-27T06:40:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMDk2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk0NTg2OA==", "url": "https://github.com/line/armeria/pull/2531#discussion_r384945868", "bodyText": "Oops, the qualified name only works with a constructor.\nhttps://stackoverflow.com/questions/30169153/illegal-forward-reference-in-enum/30169296", "author": "ikhoon", "createdAt": "2020-02-27T07:09:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMDk2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk0NjM1Ng==", "url": "https://github.com/line/armeria/pull/2531#discussion_r384946356", "bodyText": "Doh! No worries then. \ud83d\ude05", "author": "trustin", "createdAt": "2020-02-27T07:11:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMDk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMTMyOQ==", "url": "https://github.com/line/armeria/pull/2531#discussion_r384931329", "bodyText": "What do you think about using an array like other ExportEntrys for better export performance?", "author": "trustin", "createdAt": "2020-02-27T06:16:17Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporter.java", "diffHunk": "@@ -101,7 +59,7 @@ public static RequestContextExporterBuilder builder() {\n         return new RequestContextExporterBuilder();\n     }\n \n-    private final ImmutableSet<BuiltInProperty> builtInPropertySet;\n+    private final ImmutableSet<ExportEntry<BuiltInProperty>> builtInPropertySet;", "originalCommit": "8f064deae887ec6d1b23e26698697ebc1f0e87d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk2NDk1Mg==", "url": "https://github.com/line/armeria/pull/2531#discussion_r384964952", "bodyText": "Sure, changed ImmutableSet to an array.", "author": "ikhoon", "createdAt": "2020-02-27T08:04:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMTMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMjEyMA==", "url": "https://github.com/line/armeria/pull/2531#discussion_r384932120", "bodyText": "How about making a breaking change here? We could remove addAttribute(..., boolean) and never prepend \"attrs.\" for simplicity. \"attrs.\" could be prepended only when a user used \"attrs.foo:....\".", "author": "trustin", "createdAt": "2020-02-27T06:19:31Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java", "diffHunk": "@@ -75,35 +88,72 @@ public boolean containsBuiltIn(BuiltInProperty property) {\n      */\n     @Deprecated\n     public Set<BuiltInProperty> getBuiltIns() {\n-        return ImmutableSet.copyOf(builtIns);\n+        return builtIns.stream().map(entry -> entry.key).collect(toImmutableSet());\n     }\n \n     /**\n      * Adds the specified {@link AttributeKey} to the export list.\n+     * The specified {@code alias} prefixed with {@value PREFIX_ATTRS} is used for the export key.\n+     * This method is a shortcut for {@code addAttribute(alias, attrKey, true)}.", "originalCommit": "8f064deae887ec6d1b23e26698697ebc1f0e87d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzNTE5MQ==", "url": "https://github.com/line/armeria/pull/2531#discussion_r384935191", "bodyText": "Agreed, You're telling me. :-) I tried to avoid breaking changes but the final API seems weird.\nLet me address it.", "author": "ikhoon", "createdAt": "2020-02-27T06:31:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMjEyMA=="}], "type": "inlineReview"}, {"oid": "7b16a945898c1fe8ed1a7db058e874afac5c9fde", "url": "https://github.com/line/armeria/commit/7b16a945898c1fe8ed1a7db058e874afac5c9fde", "message": "Address comments by @trustin", "committedDate": "2020-02-27T07:38:24Z", "type": "commit"}, {"oid": "462f6a69f6a6e9f16df9888f7fd31b13f25e2bb3", "url": "https://github.com/line/armeria/commit/462f6a69f6a6e9f16df9888f7fd31b13f25e2bb3", "message": "Address comments by @trustin / Update documentation", "committedDate": "2020-02-27T11:50:22Z", "type": "commit"}, {"oid": "06757c434df558dc0fc2a36ec1687efb48808d12", "url": "https://github.com/line/armeria/commit/06757c434df558dc0fc2a36ec1687efb48808d12", "message": "Add nullable on BuiltInProperty.findByKey", "committedDate": "2020-02-28T06:39:05Z", "type": "commit"}, {"oid": "8e91ff73a96dd0df33e85328c3bc0d4a561326de", "url": "https://github.com/line/armeria/commit/8e91ff73a96dd0df33e85328c3bc0d4a561326de", "message": "Address comments by @minwoox\n\n- Remove `req.rpc_method` in favor of `req.name`\n- Remove `req.rpc_params` in favor of `req.content`\n- Remove `req.rpc_result` in favor of `res.content`\n- Add `req.content` for the RPC params and the content preview of the request\n- Add `res.content` for the RPC result and the content preview of the response", "committedDate": "2020-02-28T08:35:00Z", "type": "commit"}, {"oid": "74d8c16d71cb68d0c27004b4d219fc0a127a183d", "url": "https://github.com/line/armeria/commit/74d8c16d71cb68d0c27004b4d219fc0a127a183d", "message": "Remove table summary", "committedDate": "2020-02-28T08:40:36Z", "type": "commit"}, {"oid": "e350d4371bd6f4a47f01d9bac6fc0d5791715c7b", "url": "https://github.com/line/armeria/commit/e350d4371bd6f4a47f01d9bac6fc0d5791715c7b", "message": "Fix Javadoc", "committedDate": "2020-02-28T08:48:53Z", "type": "commit"}, {"oid": "f0dc14191e6689059dd9a04bac405cc09eaf9906", "url": "https://github.com/line/armeria/commit/f0dc14191e6689059dd9a04bac405cc09eaf9906", "message": "Fix documentation, SOME_VALUE -> SOME_KEY", "committedDate": "2020-02-28T09:23:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU3MTgzNg==", "url": "https://github.com/line/armeria/pull/2531#discussion_r385571836", "bodyText": "nit: The preview content of the", "author": "minwoox", "createdAt": "2020-02-28T08:48:42Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/BuiltInProperty.java", "diffHunk": "@@ -39,131 +56,259 @@\n      * {@code \"remote.host\"} - the host name part of the remote socket address. Unavailable if the connection\n      * is not established yet.\n      */\n-    REMOTE_HOST(\"remote.host\"),\n+    REMOTE_HOST(\"remote.host\", log -> {\n+        final InetSocketAddress addr = log.context().remoteAddress();\n+        return addr != null ? addr.getHostString() : null;\n+    }),\n     /**\n      * {@code \"remote.ip\"} - the IP address part of the remote socket address. Unavailable if the connection\n      * is not established yet.\n      */\n-    REMOTE_IP(\"remote.ip\"),\n+    REMOTE_IP(\"remote.ip\", log -> {\n+        final InetSocketAddress addr = log.context().remoteAddress();\n+        return addr != null ? addr.getAddress().getHostAddress() : null;\n+    }),\n     /**\n      * {@code \"remote.port\"} - the port number part of the remote socket address. Unavailable if the connection\n      * is not established yet.\n      */\n-    REMOTE_PORT(\"remote.port\"),\n+    REMOTE_PORT(\"remote.port\", log -> {\n+        final InetSocketAddress addr = log.context().remoteAddress();\n+        return addr != null ? String.valueOf(addr.getPort()) : null;\n+    }),\n     /**\n      * {@code \"local.host\"} - the host name part of the local socket address. Unavailable if the connection\n      * is not established yet.\n      */\n-    LOCAL_HOST(\"local.host\"),\n+    LOCAL_HOST(\"local.host\", log -> {\n+        final InetSocketAddress addr = log.context().localAddress();\n+        return addr != null ? addr.getHostString() : null;\n+    }),\n     /**\n      * {@code \"local.ip\"} - the IP address part of the local socket address. Unavailable if the connection\n      * is not established yet.\n      */\n-    LOCAL_IP(\"local.ip\"),\n+    LOCAL_IP(\"local.ip\", log -> {\n+        final InetSocketAddress addr = log.context().localAddress();\n+        return addr != null ? addr.getAddress().getHostAddress() : null;\n+    }),\n     /**\n      * {@code \"local.port\"} - the port number part of the local socket address. Unavailable if the connection\n      * is not established yet.\n      */\n-    LOCAL_PORT(\"local.port\"),\n+    LOCAL_PORT(\"local.port\", log -> {\n+        final InetSocketAddress addr = log.context().localAddress();\n+        return addr != null ? String.valueOf(addr.getPort()) : null;\n+    }),\n     /**\n      * {@code \"client.ip\"} - the IP address who initiated a request. Unavailable if the connection is not\n      * established yet.\n      */\n-    CLIENT_IP(\"client.ip\"),\n+    CLIENT_IP(\"client.ip\", log -> {\n+        final RequestContext ctx = log.context();\n+        final InetAddress caddr =\n+                ctx instanceof ServiceRequestContext ? ((ServiceRequestContext) ctx).clientAddress() : null;\n+        return caddr != null ? caddr.getHostAddress() : null;\n+    }),\n     /**\n      * {@code \"scheme\"} - the scheme of the request, represented by {@link Scheme#uriText()}, such as\n      * {@code \"tbinary+h2\"}.\n      */\n-    SCHEME(\"scheme\"),\n+    SCHEME(\"scheme\", log -> {\n+        if (log.isAvailable(RequestLogProperty.SCHEME)) {\n+            return log.scheme().uriText();\n+        } else {\n+            return \"unknown+\" + log.context().sessionProtocol().uriText();\n+        }\n+    }),\n     /**\n      * {@code \"elapsed_nanos\"} - the amount of time in nanoseconds taken to handle the request. Unavailable if\n      * the request was not handled completely yet.\n      */\n-    ELAPSED_NANOS(\"elapsed_nanos\"),\n+    ELAPSED_NANOS(\"elapsed_nanos\", log -> {\n+        if (log.isAvailable(RequestLogProperty.RESPONSE_END_TIME)) {\n+            return String.valueOf(log.totalDurationNanos());\n+        }\n+        return null;\n+    }),\n     /**\n      * {@code \"req.direction\"} - the direction of the request, which is {@code \"INBOUND\"} for servers and\n-     *  {@code \"OUTBOUND\"} for clients.\n+     * {@code \"OUTBOUND\"} for clients.\n      */\n-    REQ_DIRECTION(\"req.direction\"),\n+    REQ_DIRECTION(\"req.direction\", log -> {\n+        final RequestContext ctx = log.context();\n+        if (ctx instanceof ServiceRequestContext) {\n+            return \"INBOUND\";\n+        } else if (ctx instanceof ClientRequestContext) {\n+            return \"OUTBOUND\";\n+        } else {\n+            return \"UNKNOWN\";\n+        }\n+    }),\n     /**\n      * {@code \"req.authority\"} - the authority of the request, represented as {@code \"<hostname>[:<port>]\"}.\n      * The port number is omitted when it is same with the default port number of the current {@link Scheme}.\n      */\n-    REQ_AUTHORITY(\"req.authority\"),\n+    REQ_AUTHORITY(\"req.authority\", BuiltInProperty::getAuthority),\n     /**\n      * {@code \"req.id\"} - the ID of the request.\n      */\n-    REQ_ID(\"req.id\"),\n+    REQ_ID(\"req.id\", log -> log.context().id().text()),\n     /**\n      * {@code \"req.path\"} - the path of the request.\n      */\n-    REQ_PATH(\"req.path\"),\n+    REQ_PATH(\"req.path\", log -> log.context().path()),\n     /**\n      * {@code \"req.query\"} - the query of the request.\n      */\n-    REQ_QUERY(\"req.query\"),\n+    REQ_QUERY(\"req.query\", log -> log.context().query()),\n     /**\n      * {@code \"req.method\"} - the method name of the request, such as {@code \"GET\"} and {@code \"POST\"}.\n      */\n-    REQ_METHOD(\"req.method\"),\n+    REQ_METHOD(\"req.method\", log -> log.context().method().name()),\n     /**\n      * {@code \"req.name\"} - the human-readable name of the request, such as RPC method name or annotated\n      * service method name. This property is often used as a meter tag or distributed trace's span name.\n      */\n-    REQ_NAME(\"req.name\"),\n-    /**\n-     * {@code \"req.rpc_method\"} - the RPC method name of the request. Unavailable if the current request is not\n-     * an RPC request or is not decoded yet.\n-     */\n-    REQ_RPC_METHOD(\"req.rpc_method\"),\n-    /**\n-     * {@code \"req.rpc_params\"} - the RPC parameter list, represented by {@link Arrays#toString(Object...)}.\n-     * Unavailable if the current request is not an RPC request or is not decoded yet.\n-     */\n-    REQ_RPC_PARAMS(\"req.rpc_params\"),\n+    REQ_NAME(\"req.name\", log -> log.isAvailable(RequestLogProperty.NAME) ? log.name() : null),\n+\n     /**\n      * {@code \"req.content_length\"} - the byte-length of the request content. Unavailable if the current\n      * request is not fully received yet.\n      */\n-    REQ_CONTENT_LENGTH(\"req.content_length\"),\n+    REQ_CONTENT_LENGTH(\"req.content_length\", log -> {\n+        if (log.isAvailable(RequestLogProperty.REQUEST_LENGTH)) {\n+            return String.valueOf(log.requestLength());\n+        }\n+        return null;\n+    }),\n+\n     /**\n-     * {@code \"res.status_code\"} - the protocol-specific integer representation of the response status code.\n-     * Unavailable if the current response is not fully sent yet.\n+     * {@code \"req.content\"} - the content of the request. The content may have one of the following:\n+     *\n+     * <table>\n+     * <tr><th>request type</th><th>description</th></tr>\n+     *\n+     * <tr><td>RPC</td>\n+     * <td>The RPC parameter list, represented by {@link Arrays#toString(Object...)} for the {@link RpcRequest}.\n+     * Unavailable if the current request is not an RPC request or is not decoded yet.</td></tr>\n+     *\n+     * <tr><td>HTTP</td>\n+     * <td>The preview of request content of the {@link Request}.", "originalCommit": "74d8c16d71cb68d0c27004b4d219fc0a127a183d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU3MjAwNQ==", "url": "https://github.com/line/armeria/pull/2531#discussion_r385572005", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-02-28T08:49:03Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/BuiltInProperty.java", "diffHunk": "@@ -39,131 +56,259 @@\n      * {@code \"remote.host\"} - the host name part of the remote socket address. Unavailable if the connection\n      * is not established yet.\n      */\n-    REMOTE_HOST(\"remote.host\"),\n+    REMOTE_HOST(\"remote.host\", log -> {\n+        final InetSocketAddress addr = log.context().remoteAddress();\n+        return addr != null ? addr.getHostString() : null;\n+    }),\n     /**\n      * {@code \"remote.ip\"} - the IP address part of the remote socket address. Unavailable if the connection\n      * is not established yet.\n      */\n-    REMOTE_IP(\"remote.ip\"),\n+    REMOTE_IP(\"remote.ip\", log -> {\n+        final InetSocketAddress addr = log.context().remoteAddress();\n+        return addr != null ? addr.getAddress().getHostAddress() : null;\n+    }),\n     /**\n      * {@code \"remote.port\"} - the port number part of the remote socket address. Unavailable if the connection\n      * is not established yet.\n      */\n-    REMOTE_PORT(\"remote.port\"),\n+    REMOTE_PORT(\"remote.port\", log -> {\n+        final InetSocketAddress addr = log.context().remoteAddress();\n+        return addr != null ? String.valueOf(addr.getPort()) : null;\n+    }),\n     /**\n      * {@code \"local.host\"} - the host name part of the local socket address. Unavailable if the connection\n      * is not established yet.\n      */\n-    LOCAL_HOST(\"local.host\"),\n+    LOCAL_HOST(\"local.host\", log -> {\n+        final InetSocketAddress addr = log.context().localAddress();\n+        return addr != null ? addr.getHostString() : null;\n+    }),\n     /**\n      * {@code \"local.ip\"} - the IP address part of the local socket address. Unavailable if the connection\n      * is not established yet.\n      */\n-    LOCAL_IP(\"local.ip\"),\n+    LOCAL_IP(\"local.ip\", log -> {\n+        final InetSocketAddress addr = log.context().localAddress();\n+        return addr != null ? addr.getAddress().getHostAddress() : null;\n+    }),\n     /**\n      * {@code \"local.port\"} - the port number part of the local socket address. Unavailable if the connection\n      * is not established yet.\n      */\n-    LOCAL_PORT(\"local.port\"),\n+    LOCAL_PORT(\"local.port\", log -> {\n+        final InetSocketAddress addr = log.context().localAddress();\n+        return addr != null ? String.valueOf(addr.getPort()) : null;\n+    }),\n     /**\n      * {@code \"client.ip\"} - the IP address who initiated a request. Unavailable if the connection is not\n      * established yet.\n      */\n-    CLIENT_IP(\"client.ip\"),\n+    CLIENT_IP(\"client.ip\", log -> {\n+        final RequestContext ctx = log.context();\n+        final InetAddress caddr =\n+                ctx instanceof ServiceRequestContext ? ((ServiceRequestContext) ctx).clientAddress() : null;\n+        return caddr != null ? caddr.getHostAddress() : null;\n+    }),\n     /**\n      * {@code \"scheme\"} - the scheme of the request, represented by {@link Scheme#uriText()}, such as\n      * {@code \"tbinary+h2\"}.\n      */\n-    SCHEME(\"scheme\"),\n+    SCHEME(\"scheme\", log -> {\n+        if (log.isAvailable(RequestLogProperty.SCHEME)) {\n+            return log.scheme().uriText();\n+        } else {\n+            return \"unknown+\" + log.context().sessionProtocol().uriText();\n+        }\n+    }),\n     /**\n      * {@code \"elapsed_nanos\"} - the amount of time in nanoseconds taken to handle the request. Unavailable if\n      * the request was not handled completely yet.\n      */\n-    ELAPSED_NANOS(\"elapsed_nanos\"),\n+    ELAPSED_NANOS(\"elapsed_nanos\", log -> {\n+        if (log.isAvailable(RequestLogProperty.RESPONSE_END_TIME)) {\n+            return String.valueOf(log.totalDurationNanos());\n+        }\n+        return null;\n+    }),\n     /**\n      * {@code \"req.direction\"} - the direction of the request, which is {@code \"INBOUND\"} for servers and\n-     *  {@code \"OUTBOUND\"} for clients.\n+     * {@code \"OUTBOUND\"} for clients.\n      */\n-    REQ_DIRECTION(\"req.direction\"),\n+    REQ_DIRECTION(\"req.direction\", log -> {\n+        final RequestContext ctx = log.context();\n+        if (ctx instanceof ServiceRequestContext) {\n+            return \"INBOUND\";\n+        } else if (ctx instanceof ClientRequestContext) {\n+            return \"OUTBOUND\";\n+        } else {\n+            return \"UNKNOWN\";\n+        }\n+    }),\n     /**\n      * {@code \"req.authority\"} - the authority of the request, represented as {@code \"<hostname>[:<port>]\"}.\n      * The port number is omitted when it is same with the default port number of the current {@link Scheme}.\n      */\n-    REQ_AUTHORITY(\"req.authority\"),\n+    REQ_AUTHORITY(\"req.authority\", BuiltInProperty::getAuthority),\n     /**\n      * {@code \"req.id\"} - the ID of the request.\n      */\n-    REQ_ID(\"req.id\"),\n+    REQ_ID(\"req.id\", log -> log.context().id().text()),\n     /**\n      * {@code \"req.path\"} - the path of the request.\n      */\n-    REQ_PATH(\"req.path\"),\n+    REQ_PATH(\"req.path\", log -> log.context().path()),\n     /**\n      * {@code \"req.query\"} - the query of the request.\n      */\n-    REQ_QUERY(\"req.query\"),\n+    REQ_QUERY(\"req.query\", log -> log.context().query()),\n     /**\n      * {@code \"req.method\"} - the method name of the request, such as {@code \"GET\"} and {@code \"POST\"}.\n      */\n-    REQ_METHOD(\"req.method\"),\n+    REQ_METHOD(\"req.method\", log -> log.context().method().name()),\n     /**\n      * {@code \"req.name\"} - the human-readable name of the request, such as RPC method name or annotated\n      * service method name. This property is often used as a meter tag or distributed trace's span name.\n      */\n-    REQ_NAME(\"req.name\"),\n-    /**\n-     * {@code \"req.rpc_method\"} - the RPC method name of the request. Unavailable if the current request is not\n-     * an RPC request or is not decoded yet.\n-     */\n-    REQ_RPC_METHOD(\"req.rpc_method\"),\n-    /**\n-     * {@code \"req.rpc_params\"} - the RPC parameter list, represented by {@link Arrays#toString(Object...)}.\n-     * Unavailable if the current request is not an RPC request or is not decoded yet.\n-     */\n-    REQ_RPC_PARAMS(\"req.rpc_params\"),\n+    REQ_NAME(\"req.name\", log -> log.isAvailable(RequestLogProperty.NAME) ? log.name() : null),\n+\n     /**\n      * {@code \"req.content_length\"} - the byte-length of the request content. Unavailable if the current\n      * request is not fully received yet.\n      */\n-    REQ_CONTENT_LENGTH(\"req.content_length\"),\n+    REQ_CONTENT_LENGTH(\"req.content_length\", log -> {\n+        if (log.isAvailable(RequestLogProperty.REQUEST_LENGTH)) {\n+            return String.valueOf(log.requestLength());\n+        }\n+        return null;\n+    }),\n+\n     /**\n-     * {@code \"res.status_code\"} - the protocol-specific integer representation of the response status code.\n-     * Unavailable if the current response is not fully sent yet.\n+     * {@code \"req.content\"} - the content of the request. The content may have one of the following:\n+     *\n+     * <table>\n+     * <tr><th>request type</th><th>description</th></tr>\n+     *\n+     * <tr><td>RPC</td>\n+     * <td>The RPC parameter list, represented by {@link Arrays#toString(Object...)} for the {@link RpcRequest}.\n+     * Unavailable if the current request is not an RPC request or is not decoded yet.</td></tr>\n+     *\n+     * <tr><td>HTTP</td>\n+     * <td>The preview of request content of the {@link Request}.\n+     * Unavailable if the preview is disabled or not fully received yet.</td></tr>\n+     *\n+     * </table>\n      */\n-    RES_STATUS_CODE(\"res.status_code\"),\n+    REQ_CONTENT(\"req.content\", log -> {\n+        if (log.isAvailable(RequestLogProperty.REQUEST_CONTENT)) {\n+            final Object requestContent = log.requestContent();\n+            if (requestContent instanceof RpcRequest) {\n+                return String.valueOf(((RpcRequest) requestContent).params());\n+            }\n+        }\n+        if (log.isAvailable(RequestLogProperty.REQUEST_CONTENT_PREVIEW)) {\n+            return log.requestContentPreview();\n+        }\n+        return null;\n+    }),\n+\n     /**\n-     * {@code \"res.rpc_result\"} - the RPC result value of the response. Unavailable if the current response\n-     * is not fully sent yet.\n+     * {@code \"res.status_code\"} - the protocol-specific integer representation of the response status code.\n+     * Unavailable if the current response is not fully sent yet.\n      */\n-    RES_RPC_RESULT(\"res.rpc_result\"),\n+    RES_STATUS_CODE(\"res.status_code\", log -> {\n+        if (log.isAvailable(RequestLogProperty.RESPONSE_HEADERS)) {\n+            return log.responseHeaders().status().codeAsText();\n+        }\n+        return null;\n+    }),\n+\n     /**\n      * {@code \"res.content_length\"} - the byte-length of the response content. Unavailable if the current\n      * response is not fully sent yet.\n      */\n-    RES_CONTENT_LENGTH(\"res.content_length\"),\n+    RES_CONTENT_LENGTH(\"res.content_length\", log -> {\n+        if (log.isAvailable(RequestLogProperty.RESPONSE_LENGTH)) {\n+            return String.valueOf(log.responseLength());\n+        }\n+        return null;\n+    }),\n+\n+    /**\n+     * {@code \"res.content\"} - the content of the request. The content may have one of the following:\n+     *\n+     * <table>\n+     * <tr><th>response type</th><th>description</th></tr>\n+     *\n+     * <tr><td>RPC</td>\n+     * <td>The RPC result value of the {@link RpcResponse}.\n+     * Unavailable if the current response is not fully sent yet.</td></tr>\n+     *\n+     * <tr><td>HTTP</td>\n+     * <td>The preview of response content of the {@link Response}.", "originalCommit": "74d8c16d71cb68d0c27004b4d219fc0a127a183d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e26db03fa5440b1b5ab7f55adbf2bc1ee8aecc0e", "url": "https://github.com/line/armeria/commit/e26db03fa5440b1b5ab7f55adbf2bc1ee8aecc0e", "message": "Fix broken tests", "committedDate": "2020-02-28T09:57:09Z", "type": "commit"}, {"oid": "772b5343695d9ef7ae3c0dc98186acd7a4e542e1", "url": "https://github.com/line/armeria/commit/772b5343695d9ef7ae3c0dc98186acd7a4e542e1", "message": "Adress comments by @minwoox / Update documentation", "committedDate": "2020-02-28T10:05:15Z", "type": "commit"}, {"oid": "4793f6690e1fbe754edb74be2095c2e687108448", "url": "https://github.com/line/armeria/commit/4793f6690e1fbe754edb74be2095c2e687108448", "message": "Fix documentation", "committedDate": "2020-02-28T10:13:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYzMzQwNQ==", "url": "https://github.com/line/armeria/pull/2531#discussion_r385633405", "bodyText": "Could be simplified to return addBuiltIn(property, property.key) ?", "author": "trustin", "createdAt": "2020-02-28T10:59:36Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java", "diffHunk": "@@ -52,9 +51,22 @@\n \n     /**\n      * Adds the specified {@link BuiltInProperty} to the export list.\n+     * The {@link BuiltInProperty#key} will be used for the export key.\n      */\n     public RequestContextExporterBuilder addBuiltIn(BuiltInProperty property) {\n-        builtIns.add(requireNonNull(property, \"property\"));\n+        requireNonNull(property, \"property\");\n+        builtIns.add(new ExportEntry<>(property, property.key));\n+        return this;", "originalCommit": "4793f6690e1fbe754edb74be2095c2e687108448", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY0NjM4Mw==", "url": "https://github.com/line/armeria/pull/2531#discussion_r385646383", "bodyText": "Oops..", "author": "ikhoon", "createdAt": "2020-02-28T11:30:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYzMzQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYzMzgyNw==", "url": "https://github.com/line/armeria/pull/2531#discussion_r385633827", "bodyText": "Ditto - Could delegate to addHttpResponseHeader(CharSequence, String).", "author": "trustin", "createdAt": "2020-02-28T11:00:35Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java", "diffHunk": "@@ -128,30 +143,54 @@ public boolean containsAttribute(AttributeKey<?> key) {\n     @Deprecated\n     public Map<String, AttributeKey<?>> getAttributes() {\n         return attrs.stream().collect(\n-                toImmutableMap(e -> e.exportKey.substring(PREFIX_ATTRS.length()), e -> e.key));\n+                toImmutableMap(e -> {\n+                    if (e.exportKey.startsWith(PREFIX_ATTRS)) {\n+                        return e.exportKey.substring(PREFIX_ATTRS.length());\n+                    }\n+                    return e.exportKey;\n+                }, e -> e.key));\n     }\n \n     /**\n      * Adds the specified HTTP request header name to the export list.\n      */\n     public RequestContextExporterBuilder addHttpRequestHeader(CharSequence name) {\n-        addHttpHeader(PREFIX_HTTP_REQ_HEADERS, httpReqHeaders, requireNonNull(name, \"name\"));\n+        final AsciiString key = toHeaderName(requireNonNull(name, \"name\"));\n+        final String exportKey = PREFIX_HTTP_REQ_HEADERS + key;\n+        httpReqHeaders.add(new ExportEntry<>(key, exportKey));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP request header name to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     */\n+    public RequestContextExporterBuilder addHttpRequestHeader(CharSequence headerName, String alias) {\n+        requireNonNull(headerName, \"headerName\");\n+        requireNonNull(alias, \"alias\");\n+        httpReqHeaders.add(new ExportEntry<>(toHeaderName(headerName), alias));\n         return this;\n     }\n \n     /**\n      * Adds the specified HTTP response header name to the export list.\n      */\n     public RequestContextExporterBuilder addHttpResponseHeader(CharSequence name) {\n-        addHttpHeader(PREFIX_HTTP_RES_HEADERS, httpResHeaders, requireNonNull(name, \"name\"));\n+        final AsciiString key = toHeaderName(requireNonNull(name, \"name\"));\n+        final String exportKey = PREFIX_HTTP_RES_HEADERS + key;\n+        httpResHeaders.add(new ExportEntry<>(key, exportKey));\n         return this;", "originalCommit": "4793f6690e1fbe754edb74be2095c2e687108448", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY0NjQxMw==", "url": "https://github.com/line/armeria/pull/2531#discussion_r385646413", "bodyText": "It could but it will call toHeaderName(headerName) twice.\n    public RequestContextExporterBuilder addHttpResponseHeader(CharSequence headerName) {\n        final AsciiString key = toHeaderName(requireNonNull(headerName, \"headerName\"));\n        final String exportKey = PREFIX_HTTP_RES_HEADERS + key;\n        return addHttpResponseHeader(headerName, exportKey);\n    }", "author": "ikhoon", "createdAt": "2020-02-28T11:30:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYzMzgyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY0OTExNg==", "url": "https://github.com/line/armeria/pull/2531#discussion_r385649116", "bodyText": "Will add another private method. :-)", "author": "ikhoon", "createdAt": "2020-02-28T11:36:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYzMzgyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYzMzkyNg==", "url": "https://github.com/line/armeria/pull/2531#discussion_r385633926", "bodyText": "Ditto - Could delegate to addHttpRequestHeader(CharSequence, String).", "author": "trustin", "createdAt": "2020-02-28T11:00:47Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java", "diffHunk": "@@ -128,30 +143,54 @@ public boolean containsAttribute(AttributeKey<?> key) {\n     @Deprecated\n     public Map<String, AttributeKey<?>> getAttributes() {\n         return attrs.stream().collect(\n-                toImmutableMap(e -> e.exportKey.substring(PREFIX_ATTRS.length()), e -> e.key));\n+                toImmutableMap(e -> {\n+                    if (e.exportKey.startsWith(PREFIX_ATTRS)) {\n+                        return e.exportKey.substring(PREFIX_ATTRS.length());\n+                    }\n+                    return e.exportKey;\n+                }, e -> e.key));\n     }\n \n     /**\n      * Adds the specified HTTP request header name to the export list.\n      */\n     public RequestContextExporterBuilder addHttpRequestHeader(CharSequence name) {\n-        addHttpHeader(PREFIX_HTTP_REQ_HEADERS, httpReqHeaders, requireNonNull(name, \"name\"));\n+        final AsciiString key = toHeaderName(requireNonNull(name, \"name\"));\n+        final String exportKey = PREFIX_HTTP_REQ_HEADERS + key;\n+        httpReqHeaders.add(new ExportEntry<>(key, exportKey));\n+        return this;", "originalCommit": "4793f6690e1fbe754edb74be2095c2e687108448", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY0NjY5Nw==", "url": "https://github.com/line/armeria/pull/2531#discussion_r385646697", "bodyText": "Ditto because of the same reason (#2531 (comment)) :-)", "author": "ikhoon", "createdAt": "2020-02-28T11:30:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYzMzkyNg=="}], "type": "inlineReview"}, {"oid": "205178a7817283c293c46ddc600762bfee3a698b", "url": "https://github.com/line/armeria/commit/205178a7817283c293c46ddc600762bfee3a698b", "message": "Add comments by @trustin", "committedDate": "2020-02-28T11:32:32Z", "type": "commit"}, {"oid": "3589c9b4d0fb586e11047d26cf0f3dc98c8d0897", "url": "https://github.com/line/armeria/commit/3589c9b4d0fb586e11047d26cf0f3dc98c8d0897", "message": "Address comments by @trustin 2", "committedDate": "2020-02-28T11:42:08Z", "type": "commit"}]}