{"pr_number": 2840, "pr_title": "OAuth2 Support", "pr_createdAt": "2020-06-25T18:15:33Z", "pr_url": "https://github.com/line/armeria/pull/2840", "timeline": [{"oid": "7fd029fcf187c240548009b895e78163edf59710", "url": "https://github.com/line/armeria/commit/7fd029fcf187c240548009b895e78163edf59710", "message": "OAuth 2.0 server-side token authorization:\n * OAuth2TokenIntrospectionAuthorizer - implementing Token Introspection [RFC7662] - https://tools.ietf.org/html/rfc7662\n\nOAuth 2.0 client-side authorization grants for confidential clients (OAuth2Client), including:\n * OAuth2ClientCredentialsGrant - implementing Client Credentials Grant [RFC6749], Section 4.4 - https://tools.ietf.org/html/rfc6749#section-4.4\n * OAuth2ResourceOwnerPasswordCredentialsGrant - implementing Resource Owner Password Credentials Grant [RFC6749], Section 4.3 - https://tools.ietf.org/html/rfc6749#section-4.3\n\nOAuth 2.0 Token Revocation [RFC7009] - https://tools.ietf.org/html/rfc7009", "committedDate": "2020-06-25T18:09:41Z", "type": "commit"}, {"oid": "8c9c81f30683fd44cec2f629fd8d543b8ad43d21", "url": "https://github.com/line/armeria/commit/8c9c81f30683fd44cec2f629fd8d543b8ad43d21", "message": "Add the major version to artifacts (#2843)", "committedDate": "2020-06-30T01:45:24Z", "type": "commit"}, {"oid": "e1d8b5ea43d8c459bd76307f8c7cef711f9f146d", "url": "https://github.com/line/armeria/commit/e1d8b5ea43d8c459bd76307f8c7cef711f9f146d", "message": "Merge branch 'master' into oauth2-issue2268", "committedDate": "2020-06-30T01:48:06Z", "type": "commit"}, {"oid": "4e4b80ee25148be663faa0a929741aa7777a305c", "url": "https://github.com/line/armeria/commit/4e4b80ee25148be663faa0a929741aa7777a305c", "message": "Merge branch 'master' into oauth2-issue2268", "committedDate": "2020-06-30T02:02:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1MDI5Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r449950297", "bodyText": "obtainAccessToken() is an asynchronous operation, so I guess just using synchronized will not prevent a subclass from obtaining tokens simultaneously. Am I missing something? Also, it'd be nice if we can reduce the potential lock contention which may block the event loop.", "author": "trustin", "createdAt": "2020-07-06T02:00:07Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractOAuth2AuthorizationGrant.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.auth.oauth2.AccessTokenCapsule;\n+import com.linecorp.armeria.common.auth.oauth2.RefreshAccessTokenRequest;\n+import com.linecorp.armeria.common.auth.oauth2.TokenRequestException;\n+\n+/**\n+ * Base implementation of OAuth 2.0 Access Token Grant flow to obtain Access Token.\n+ * Implements Access Token loading, storing and refreshing.\n+ */\n+abstract class AbstractOAuth2AuthorizationGrant implements OAuth2AuthorizationGrant {\n+\n+    /**\n+     * A period when the token should be refreshed proactively prior to its expiry.\n+     */\n+    private static final Duration DEFAULT_REFRESH_BEFORE = Duration.ofMinutes(1L); // 1 minute\n+\n+    private final AtomicReference<AccessTokenCapsule> tokenRef;\n+\n+    private final RefreshAccessTokenRequest refreshRequest;\n+\n+    private final Duration refreshBefore;\n+\n+    @Nullable\n+    private final Supplier<AccessTokenCapsule> tokenSupplier;\n+    @Nullable\n+    private final Consumer<AccessTokenCapsule> tokenConsumer;\n+\n+    AbstractOAuth2AuthorizationGrant(RefreshAccessTokenRequest refreshRequest, @Nullable Duration refreshBefore,\n+                                     @Nullable Supplier<AccessTokenCapsule> tokenSupplier,\n+                                     @Nullable Consumer<AccessTokenCapsule> tokenConsumer) {\n+        tokenRef = new AtomicReference<>();\n+        this.refreshRequest = requireNonNull(refreshRequest, \"refreshRequest\");\n+        this.refreshBefore = refreshBefore == null ? DEFAULT_REFRESH_BEFORE : refreshBefore;\n+        this.tokenSupplier = tokenSupplier;\n+        this.tokenConsumer = tokenConsumer;\n+    }\n+\n+    protected abstract CompletableFuture<AccessTokenCapsule> obtainAccessToken(\n+            @Nullable AccessTokenCapsule token);\n+\n+    private CompletableFuture<AccessTokenCapsule> obtainAccessTokenExclusively(\n+            @Nullable AccessTokenCapsule token) {\n+        return obtainAccessToken(token).thenApply(t -> {\n+            tokenRef.set(t); // reset the token reference\n+            if (tokenConsumer != null) {\n+                tokenConsumer.accept(t); // store token to an optional storage (e.g. secret store)\n+            }\n+            return t;\n+        });\n+    }\n+\n+    private CompletableFuture<AccessTokenCapsule> refreshAccessToken(AccessTokenCapsule token) {\n+        if (token.refreshToken() != null) {\n+            // try refreshing token if refresh token was previously provided\n+            try {\n+                return refreshRequest.make(token);\n+            } catch (TokenRequestException e) {\n+                // token refresh request failed\n+                // try to re-obtain access token\n+                return obtainAccessToken(token);\n+            }\n+        }\n+        // try to re-obtain access token\n+        return obtainAccessToken(token);\n+    }\n+\n+    private CompletableFuture<AccessTokenCapsule> getOrRefreshAccessToken(AccessTokenCapsule token,\n+                                                                          boolean reset,\n+                                                                          boolean lock) {\n+        // check if it's still valid\n+        final Instant instant = Instant.now().plus(refreshBefore);\n+        if (token.isValid(instant)) {\n+            // simply return a valid token\n+            if (reset) {\n+                return CompletableFuture.completedFuture(token).thenApply(t -> {\n+                    tokenRef.set(t); // reset the token reference\n+                    return t;\n+                });\n+            } else {\n+                return CompletableFuture.completedFuture(token);\n+            }\n+        } else {\n+            if (lock) {\n+                synchronized (tokenRef) {\n+                    // refresh token exclusively\n+                    return refreshAccessTokenExclusively(instant);\n+                }\n+            } else {\n+                // refresh token exclusively\n+                return refreshAccessTokenExclusively(instant);\n+            }\n+        }\n+    }\n+\n+    private CompletableFuture<AccessTokenCapsule> refreshAccessTokenExclusively(Instant instant) {\n+        // after acquiring the lock, re-check if it's a valid token\n+        final AccessTokenCapsule token = tokenRef.get();\n+        if (token.isValid(instant)) {\n+            // simply return a valid token\n+            return CompletableFuture.completedFuture(token);\n+        }\n+        // otherwise, refresh it\n+        return refreshAccessToken(token).thenApply(t -> {\n+            tokenRef.set(t); // reset the token reference\n+            if (tokenConsumer != null) {\n+                tokenConsumer.accept(t); // store token to an optional storage (e.g. secret store)\n+            }\n+            return t;\n+        });\n+    }\n+\n+    @Override\n+    public CompletionStage<AccessTokenCapsule> getAccessToken() {\n+        AccessTokenCapsule token = tokenRef.get();\n+        if (token != null) {\n+            // token already present\n+            return getOrRefreshAccessToken(token, false, true);\n+        }\n+        // token is not yet present\n+        // lock and obtain token exclusively\n+        synchronized (tokenRef) {", "originalCommit": "4e4b80ee25148be663faa0a929741aa7777a305c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEwMTkwNw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r453101907", "bodyText": "You are right! This was wrong. Changed the implementation to use a single-thread executor to obtain new or refresh existing token.", "author": "max904-github", "createdAt": "2020-07-10T22:17:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1MDI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1MDg5NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r449950895", "bodyText": "Supplier<? extends Map.Entry<String, String>>", "author": "trustin", "createdAt": "2020-07-06T02:03:33Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractOAuth2AuthorizationGrantBuilder.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.auth.oauth2.AbstractAccessTokenRequest;\n+import com.linecorp.armeria.common.auth.oauth2.AccessTokenCapsule;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.RefreshAccessTokenRequest;\n+\n+abstract class AbstractOAuth2AuthorizationGrantBuilder {\n+\n+    private final WebClient accessTokenEndpoint;\n+    private final String accessTokenEndpointPath;\n+\n+    @Nullable\n+    private ClientAuthorization clientAuthorization;\n+\n+    @Nullable\n+    private Duration refreshBefore;\n+\n+    @Nullable\n+    private Supplier<AccessTokenCapsule> tokenSupplier;\n+\n+    @Nullable\n+    private Consumer<AccessTokenCapsule> tokenConsumer;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Access Token request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a>.\n+     *\n+     * @param accessTokenEndpoint A {@link WebClient} to facilitate an Access Token request. Must correspond to\n+     *                            the Access Token endpoint of the OAuth 2 system.\n+     * @param accessTokenEndpointPath A URI path that corresponds to the Access Token endpoint of the\n+     *                                OAuth 2 system.\n+     */\n+    AbstractOAuth2AuthorizationGrantBuilder(WebClient accessTokenEndpoint, String accessTokenEndpointPath) {\n+        this.accessTokenEndpoint = requireNonNull(accessTokenEndpoint, \"accessTokenEndpoint\");\n+        this.accessTokenEndpointPath = requireNonNull(accessTokenEndpointPath, \"accessTokenEndpointPath\");\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    protected AbstractOAuth2AuthorizationGrantBuilder clientAuthorization(\n+            Supplier<String> authorizationSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofAuthorization(authorizationSupplier, authorizationType);\n+        return this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     */\n+    protected AbstractOAuth2AuthorizationGrantBuilder clientBasicAuthorization(\n+            Supplier<String> authorizationSupplier) {\n+        clientAuthorization = ClientAuthorization.ofBasicAuthorization(authorizationSupplier);\n+        return this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    protected AbstractOAuth2AuthorizationGrantBuilder clientCredentials(\n+            Supplier<Map.Entry<String, String>> credentialsSupplier, String authorizationType) {", "originalCommit": "4e4b80ee25148be663faa0a929741aa7777a305c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4MTQwMg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r452781402", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-07-10T11:15:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1MDg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1MDkyOQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r449950929", "bodyText": "Supplier<? extends Map.Entry<String, String>>", "author": "trustin", "createdAt": "2020-07-06T02:03:51Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractOAuth2AuthorizationGrantBuilder.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.auth.oauth2.AbstractAccessTokenRequest;\n+import com.linecorp.armeria.common.auth.oauth2.AccessTokenCapsule;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.RefreshAccessTokenRequest;\n+\n+abstract class AbstractOAuth2AuthorizationGrantBuilder {\n+\n+    private final WebClient accessTokenEndpoint;\n+    private final String accessTokenEndpointPath;\n+\n+    @Nullable\n+    private ClientAuthorization clientAuthorization;\n+\n+    @Nullable\n+    private Duration refreshBefore;\n+\n+    @Nullable\n+    private Supplier<AccessTokenCapsule> tokenSupplier;\n+\n+    @Nullable\n+    private Consumer<AccessTokenCapsule> tokenConsumer;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Access Token request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a>.\n+     *\n+     * @param accessTokenEndpoint A {@link WebClient} to facilitate an Access Token request. Must correspond to\n+     *                            the Access Token endpoint of the OAuth 2 system.\n+     * @param accessTokenEndpointPath A URI path that corresponds to the Access Token endpoint of the\n+     *                                OAuth 2 system.\n+     */\n+    AbstractOAuth2AuthorizationGrantBuilder(WebClient accessTokenEndpoint, String accessTokenEndpointPath) {\n+        this.accessTokenEndpoint = requireNonNull(accessTokenEndpoint, \"accessTokenEndpoint\");\n+        this.accessTokenEndpointPath = requireNonNull(accessTokenEndpointPath, \"accessTokenEndpointPath\");\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    protected AbstractOAuth2AuthorizationGrantBuilder clientAuthorization(\n+            Supplier<String> authorizationSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofAuthorization(authorizationSupplier, authorizationType);\n+        return this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     */\n+    protected AbstractOAuth2AuthorizationGrantBuilder clientBasicAuthorization(\n+            Supplier<String> authorizationSupplier) {\n+        clientAuthorization = ClientAuthorization.ofBasicAuthorization(authorizationSupplier);\n+        return this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    protected AbstractOAuth2AuthorizationGrantBuilder clientCredentials(\n+            Supplier<Map.Entry<String, String>> credentialsSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofCredentials(credentialsSupplier, authorizationType);\n+        return this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     */\n+    protected AbstractOAuth2AuthorizationGrantBuilder clientCredentials(\n+            Supplier<Map.Entry<String, String>> credentialsSupplier) {", "originalCommit": "4e4b80ee25148be663faa0a929741aa7777a305c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4MTQ1Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r452781457", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-07-10T11:15:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1MDkyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1MTEwNQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r449951105", "bodyText": "How about making refreshBefore non-null here and moving the default to the builder?", "author": "trustin", "createdAt": "2020-07-06T02:04:53Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractOAuth2AuthorizationGrant.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.auth.oauth2.AccessTokenCapsule;\n+import com.linecorp.armeria.common.auth.oauth2.RefreshAccessTokenRequest;\n+import com.linecorp.armeria.common.auth.oauth2.TokenRequestException;\n+\n+/**\n+ * Base implementation of OAuth 2.0 Access Token Grant flow to obtain Access Token.\n+ * Implements Access Token loading, storing and refreshing.\n+ */\n+abstract class AbstractOAuth2AuthorizationGrant implements OAuth2AuthorizationGrant {\n+\n+    /**\n+     * A period when the token should be refreshed proactively prior to its expiry.\n+     */\n+    private static final Duration DEFAULT_REFRESH_BEFORE = Duration.ofMinutes(1L); // 1 minute\n+\n+    private final AtomicReference<AccessTokenCapsule> tokenRef;\n+\n+    private final RefreshAccessTokenRequest refreshRequest;\n+\n+    private final Duration refreshBefore;\n+\n+    @Nullable\n+    private final Supplier<AccessTokenCapsule> tokenSupplier;\n+    @Nullable\n+    private final Consumer<AccessTokenCapsule> tokenConsumer;\n+\n+    AbstractOAuth2AuthorizationGrant(RefreshAccessTokenRequest refreshRequest, @Nullable Duration refreshBefore,", "originalCommit": "4e4b80ee25148be663faa0a929741aa7777a305c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4Mzg2MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r452783860", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-07-10T11:21:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1MTEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1MTM1NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r449951354", "bodyText": "Could return non-null once we move the default value into this class.", "author": "trustin", "createdAt": "2020-07-06T02:06:15Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractOAuth2AuthorizationGrantBuilder.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.auth.oauth2.AbstractAccessTokenRequest;\n+import com.linecorp.armeria.common.auth.oauth2.AccessTokenCapsule;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.RefreshAccessTokenRequest;\n+\n+abstract class AbstractOAuth2AuthorizationGrantBuilder {\n+\n+    private final WebClient accessTokenEndpoint;\n+    private final String accessTokenEndpointPath;\n+\n+    @Nullable\n+    private ClientAuthorization clientAuthorization;\n+\n+    @Nullable\n+    private Duration refreshBefore;\n+\n+    @Nullable\n+    private Supplier<AccessTokenCapsule> tokenSupplier;\n+\n+    @Nullable\n+    private Consumer<AccessTokenCapsule> tokenConsumer;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Access Token request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a>.\n+     *\n+     * @param accessTokenEndpoint A {@link WebClient} to facilitate an Access Token request. Must correspond to\n+     *                            the Access Token endpoint of the OAuth 2 system.\n+     * @param accessTokenEndpointPath A URI path that corresponds to the Access Token endpoint of the\n+     *                                OAuth 2 system.\n+     */\n+    AbstractOAuth2AuthorizationGrantBuilder(WebClient accessTokenEndpoint, String accessTokenEndpointPath) {\n+        this.accessTokenEndpoint = requireNonNull(accessTokenEndpoint, \"accessTokenEndpoint\");\n+        this.accessTokenEndpointPath = requireNonNull(accessTokenEndpointPath, \"accessTokenEndpointPath\");\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    protected AbstractOAuth2AuthorizationGrantBuilder clientAuthorization(\n+            Supplier<String> authorizationSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofAuthorization(authorizationSupplier, authorizationType);\n+        return this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     */\n+    protected AbstractOAuth2AuthorizationGrantBuilder clientBasicAuthorization(\n+            Supplier<String> authorizationSupplier) {\n+        clientAuthorization = ClientAuthorization.ofBasicAuthorization(authorizationSupplier);\n+        return this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    protected AbstractOAuth2AuthorizationGrantBuilder clientCredentials(\n+            Supplier<Map.Entry<String, String>> credentialsSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofCredentials(credentialsSupplier, authorizationType);\n+        return this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     */\n+    protected AbstractOAuth2AuthorizationGrantBuilder clientCredentials(\n+            Supplier<Map.Entry<String, String>> credentialsSupplier) {\n+        clientAuthorization = ClientAuthorization.ofCredentials(credentialsSupplier);\n+        return this;\n+    }\n+\n+    /**\n+     * A period when the token should be refreshed proactively prior to its expiry.\n+     */\n+    protected AbstractOAuth2AuthorizationGrantBuilder refreshBefore(Duration refreshBefore) {\n+        this.refreshBefore = requireNonNull(refreshBefore, \"refreshBefore\");\n+        return this;\n+    }\n+\n+    @Nullable\n+    protected Duration refreshBefore() {", "originalCommit": "4e4b80ee25148be663faa0a929741aa7777a305c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NDEzNw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r452784137", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-07-10T11:22:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1MTM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1MTU0NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r449951545", "bodyText": "Could we make all protected methods in this class final? (except the abstract ones of course)", "author": "trustin", "createdAt": "2020-07-06T02:07:27Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractOAuth2AuthorizationGrantBuilder.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.auth.oauth2.AbstractAccessTokenRequest;\n+import com.linecorp.armeria.common.auth.oauth2.AccessTokenCapsule;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.RefreshAccessTokenRequest;\n+\n+abstract class AbstractOAuth2AuthorizationGrantBuilder {", "originalCommit": "4e4b80ee25148be663faa0a929741aa7777a305c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NDM2OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r452794368", "bodyText": "fixed by using different builder inheritance technique", "author": "max904-github", "createdAt": "2020-07-10T11:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1MTU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1MTc0Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r449951747", "bodyText": "Global comment: Please add final to all public/protected members that users are not expected to extend/override.", "author": "trustin", "createdAt": "2020-07-06T02:08:42Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/OAuth2Client.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.function.Function;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.HttpClient;\n+import com.linecorp.armeria.client.SimpleDecoratingHttpClient;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * Decorates a {@link HttpClient} with an OAuth 2.0 Authorization Grant flow.\n+ */\n+public class OAuth2Client extends SimpleDecoratingHttpClient {", "originalCommit": "4e4b80ee25148be663faa0a929741aa7777a305c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1MjA0NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r449952044", "bodyText": "Is the comment an example value? If so, could you add e.g.?\nIndentation - should be aligned at .", "author": "trustin", "createdAt": "2020-07-06T02:10:14Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/OAuth2Client.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.function.Function;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.HttpClient;\n+import com.linecorp.armeria.client.SimpleDecoratingHttpClient;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * Decorates a {@link HttpClient} with an OAuth 2.0 Authorization Grant flow.\n+ */\n+public class OAuth2Client extends SimpleDecoratingHttpClient {\n+\n+    /**\n+     * Creates a new {@link HttpClient} decorator that handles OAuth 2.0 Authorization Grant flow.\n+     * @param authorizationGrant An {@link OAuth2AuthorizationGrant} implementing specific\n+     *                           OAuth 2.0 Authorization Grant flow.\n+     */\n+    public static Function<? super HttpClient, OAuth2Client> newDecorator(\n+            OAuth2AuthorizationGrant authorizationGrant) {\n+        return delegate -> new OAuth2Client(delegate, authorizationGrant);\n+    }\n+\n+    private final OAuth2AuthorizationGrant authorizationGrant;\n+\n+    /**\n+     * Creates a new instance that decorates the specified {@link HttpClient} with\n+     * an OAuth 2.0 Authorization Grant flow.\n+     */\n+    OAuth2Client(HttpClient delegate, OAuth2AuthorizationGrant authorizationGrant) {\n+        super(delegate);\n+        this.authorizationGrant = requireNonNull(authorizationGrant, \"authorizationGrant\");\n+    }\n+\n+    @Override\n+    public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Exception {\n+        return HttpResponse.from(authorizationGrant.getAccessToken().thenApply(accessToken -> {\n+            // Create a new request with an additional 'Authorization' header\n+            final HttpRequest newReq =\n+                req.withHeaders(req.headers().toBuilder()\n+                    .set(HttpHeaderNames.AUTHORIZATION, accessToken.authorization()) // Bearer mF_9.B5f-4.1JqM", "originalCommit": "4e4b80ee25148be663faa0a929741aa7777a305c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NjI1Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r452796257", "bodyText": "removed the comment and fixed the indentation", "author": "max904-github", "createdAt": "2020-07-10T11:53:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1MjA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1MjE0Mg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r449952142", "bodyText": "You can do return Exceptions.throwUnsafely(...).", "author": "trustin", "createdAt": "2020-07-06T02:10:43Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/OAuth2Client.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.function.Function;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.HttpClient;\n+import com.linecorp.armeria.client.SimpleDecoratingHttpClient;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * Decorates a {@link HttpClient} with an OAuth 2.0 Authorization Grant flow.\n+ */\n+public class OAuth2Client extends SimpleDecoratingHttpClient {\n+\n+    /**\n+     * Creates a new {@link HttpClient} decorator that handles OAuth 2.0 Authorization Grant flow.\n+     * @param authorizationGrant An {@link OAuth2AuthorizationGrant} implementing specific\n+     *                           OAuth 2.0 Authorization Grant flow.\n+     */\n+    public static Function<? super HttpClient, OAuth2Client> newDecorator(\n+            OAuth2AuthorizationGrant authorizationGrant) {\n+        return delegate -> new OAuth2Client(delegate, authorizationGrant);\n+    }\n+\n+    private final OAuth2AuthorizationGrant authorizationGrant;\n+\n+    /**\n+     * Creates a new instance that decorates the specified {@link HttpClient} with\n+     * an OAuth 2.0 Authorization Grant flow.\n+     */\n+    OAuth2Client(HttpClient delegate, OAuth2AuthorizationGrant authorizationGrant) {\n+        super(delegate);\n+        this.authorizationGrant = requireNonNull(authorizationGrant, \"authorizationGrant\");\n+    }\n+\n+    @Override\n+    public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Exception {\n+        return HttpResponse.from(authorizationGrant.getAccessToken().thenApply(accessToken -> {\n+            // Create a new request with an additional 'Authorization' header\n+            final HttpRequest newReq =\n+                req.withHeaders(req.headers().toBuilder()\n+                    .set(HttpHeaderNames.AUTHORIZATION, accessToken.authorization()) // Bearer mF_9.B5f-4.1JqM\n+                    .build());\n+            // Update the ctx.request\n+            ctx.updateRequest(newReq);\n+            try {\n+                return unwrap().execute(ctx, newReq);\n+            } catch (Exception e) {\n+                Exceptions.throwUnsafely(Exceptions.peel(e));\n+                //noinspection ReturnOfNull\n+                return null; // will never get here", "originalCommit": "4e4b80ee25148be663faa0a929741aa7777a305c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NjU4Mg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r452796582", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-07-10T11:53:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1MjE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1MzM5Mw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r449953393", "bodyText": "How about making all these protected setters package-local? Looks like all subclasses are in the same package.", "author": "trustin", "createdAt": "2020-07-06T02:17:35Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractOAuth2AuthorizationGrantBuilder.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.auth.oauth2.AbstractAccessTokenRequest;\n+import com.linecorp.armeria.common.auth.oauth2.AccessTokenCapsule;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.RefreshAccessTokenRequest;\n+\n+abstract class AbstractOAuth2AuthorizationGrantBuilder {\n+\n+    private final WebClient accessTokenEndpoint;\n+    private final String accessTokenEndpointPath;\n+\n+    @Nullable\n+    private ClientAuthorization clientAuthorization;\n+\n+    @Nullable\n+    private Duration refreshBefore;\n+\n+    @Nullable\n+    private Supplier<AccessTokenCapsule> tokenSupplier;\n+\n+    @Nullable\n+    private Consumer<AccessTokenCapsule> tokenConsumer;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Access Token request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a>.\n+     *\n+     * @param accessTokenEndpoint A {@link WebClient} to facilitate an Access Token request. Must correspond to\n+     *                            the Access Token endpoint of the OAuth 2 system.\n+     * @param accessTokenEndpointPath A URI path that corresponds to the Access Token endpoint of the\n+     *                                OAuth 2 system.\n+     */\n+    AbstractOAuth2AuthorizationGrantBuilder(WebClient accessTokenEndpoint, String accessTokenEndpointPath) {\n+        this.accessTokenEndpoint = requireNonNull(accessTokenEndpoint, \"accessTokenEndpoint\");\n+        this.accessTokenEndpointPath = requireNonNull(accessTokenEndpointPath, \"accessTokenEndpointPath\");\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    protected AbstractOAuth2AuthorizationGrantBuilder clientAuthorization(\n+            Supplier<String> authorizationSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofAuthorization(authorizationSupplier, authorizationType);\n+        return this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     */\n+    protected AbstractOAuth2AuthorizationGrantBuilder clientBasicAuthorization(\n+            Supplier<String> authorizationSupplier) {", "originalCommit": "4e4b80ee25148be663faa0a929741aa7777a305c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NzY5MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r452797691", "bodyText": "made those methods public and used different builder inheritance technique.\nbtw, it's expected to have more grants and grant builders in future.", "author": "max904-github", "createdAt": "2020-07-10T11:56:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1MzM5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1NDI4OQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r449954289", "bodyText": "Global comment: You don't need to copy the Javadoc from the superclass if you did not change anything. Javadoc tool will do that for you.", "author": "trustin", "createdAt": "2020-07-06T02:22:54Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/OAuth2ClientCredentialsGrantBuilder.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.auth.oauth2.AbstractAccessTokenRequest;\n+import com.linecorp.armeria.common.auth.oauth2.AccessTokenCapsule;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.ClientCredentialsTokenRequest;\n+\n+/**\n+ * Builds {@link OAuth2ClientCredentialsGrant}.\n+ */\n+public class OAuth2ClientCredentialsGrantBuilder extends AbstractOAuth2AuthorizationGrantBuilder {\n+\n+    /**\n+     * A common abstraction for the requests implementing various Access Token request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a>.\n+     * @param accessTokenEndpoint A {@link WebClient} to facilitate an Access Token request. Must correspond to\n+     *                            the Access Token endpoint of the OAuth 2 system.\n+     * @param accessTokenEndpointPath A URI path that corresponds to the Access Token endpoint of the\n+     */\n+    OAuth2ClientCredentialsGrantBuilder(WebClient accessTokenEndpoint, String accessTokenEndpointPath) {\n+        super(accessTokenEndpoint, accessTokenEndpointPath);\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    @Override\n+    protected OAuth2ClientCredentialsGrantBuilder clientAuthorization(\n+            Supplier<String> authorizationSupplier, String authorizationType) {\n+        super.clientAuthorization(authorizationSupplier, authorizationType);\n+        return this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     */\n+    @Override\n+    protected OAuth2ClientCredentialsGrantBuilder clientBasicAuthorization(\n+            Supplier<String> authorizationSupplier) {\n+        super.clientBasicAuthorization(authorizationSupplier);\n+        return this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */", "originalCommit": "4e4b80ee25148be663faa0a929741aa7777a305c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5ODU5NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r452798595", "bodyText": "removed those methods altogether", "author": "max904-github", "createdAt": "2020-07-10T11:58:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1NDI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1NDU4Mg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r449954582", "bodyText": "Global comment: How about accepting the required properties at the construction time of the builder? e.g. OAuth2ClientCredentialsGrant.builder(...., ClientAuthorization)? This prevents a user from forgetting to set a required property ever.", "author": "trustin", "createdAt": "2020-07-06T02:24:51Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/OAuth2ClientCredentialsGrantBuilder.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.auth.oauth2.AbstractAccessTokenRequest;\n+import com.linecorp.armeria.common.auth.oauth2.AccessTokenCapsule;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.ClientCredentialsTokenRequest;\n+\n+/**\n+ * Builds {@link OAuth2ClientCredentialsGrant}.\n+ */\n+public class OAuth2ClientCredentialsGrantBuilder extends AbstractOAuth2AuthorizationGrantBuilder {\n+\n+    /**\n+     * A common abstraction for the requests implementing various Access Token request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a>.\n+     * @param accessTokenEndpoint A {@link WebClient} to facilitate an Access Token request. Must correspond to\n+     *                            the Access Token endpoint of the OAuth 2 system.\n+     * @param accessTokenEndpointPath A URI path that corresponds to the Access Token endpoint of the\n+     */\n+    OAuth2ClientCredentialsGrantBuilder(WebClient accessTokenEndpoint, String accessTokenEndpointPath) {\n+        super(accessTokenEndpoint, accessTokenEndpointPath);\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    @Override\n+    protected OAuth2ClientCredentialsGrantBuilder clientAuthorization(\n+            Supplier<String> authorizationSupplier, String authorizationType) {\n+        super.clientAuthorization(authorizationSupplier, authorizationType);\n+        return this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     */\n+    @Override\n+    protected OAuth2ClientCredentialsGrantBuilder clientBasicAuthorization(\n+            Supplier<String> authorizationSupplier) {\n+        super.clientBasicAuthorization(authorizationSupplier);\n+        return this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    @Override\n+    protected OAuth2ClientCredentialsGrantBuilder clientCredentials(\n+            Supplier<Map.Entry<String, String>> credentialsSupplier, String authorizationType) {\n+        super.clientCredentials(credentialsSupplier, authorizationType);\n+        return this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     */\n+    @Override\n+    protected OAuth2ClientCredentialsGrantBuilder clientCredentials(\n+            Supplier<Map.Entry<String, String>> credentialsSupplier) {\n+        super.clientCredentials(credentialsSupplier);\n+        return this;\n+    }\n+\n+    /**\n+     * A period when the token should be refreshed proactively prior to its expiry.\n+     */\n+    @Override\n+    protected OAuth2ClientCredentialsGrantBuilder refreshBefore(Duration refreshBefore) {\n+        super.refreshBefore(refreshBefore);\n+        return this;\n+    }\n+\n+    /**\n+     * A {@link Supplier} to load Access Token from, to be able to restore the previous session. OPTIONAL.\n+     */\n+    @Override\n+    protected OAuth2ClientCredentialsGrantBuilder tokenSupplier(Supplier<AccessTokenCapsule> tokenSupplier) {\n+        super.tokenSupplier(tokenSupplier);\n+        return this;\n+    }\n+\n+    /**\n+     * A {@link Consumer} to store Access Token to, to be able restore the previous session. OPTIONAL.\n+     */\n+    @Override\n+    protected OAuth2ClientCredentialsGrantBuilder tokenConsumer(Consumer<AccessTokenCapsule> tokenConsumer) {\n+        super.tokenConsumer(tokenConsumer);\n+        return this;\n+    }\n+\n+    @Override\n+    protected AbstractAccessTokenRequest buildObtainRequest(WebClient accessTokenEndpoint,\n+                                                            String accessTokenEndpointPath,\n+                                                            @Nullable ClientAuthorization clientAuthorization) {\n+        return new ClientCredentialsTokenRequest(accessTokenEndpoint, accessTokenEndpointPath,\n+                                                 // clientAuthorization require for this Grant flow\n+                                                 requireNonNull(clientAuthorization, \"clientAuthorization\"));", "originalCommit": "4e4b80ee25148be663faa0a929741aa7777a305c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwMjU4NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r452802584", "bodyText": "It's a bit tricky. For instance, clientAuthorization is required for OAuth2ClientCredentialsGrant but there are several different ways to build it (using authorizationSupplier or credentialsSupplier).", "author": "max904-github", "createdAt": "2020-07-10T12:07:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1NDU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1NDk5OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r449954998", "bodyText": "com.linecorp.armeria.common.auth.oauth2 or com.linecorp.armeria.client.auth.oauth2?", "author": "trustin", "createdAt": "2020-07-06T02:27:04Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/UnsupportedMediaTypeException.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;", "originalCommit": "4e4b80ee25148be663faa0a929741aa7777a305c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwMzgxOA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r452803818", "bodyText": "moved to com.linecorp.armeria.common.auth.oauth2", "author": "max904-github", "createdAt": "2020-07-10T12:10:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1NDk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1NTI1Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r449955256", "bodyText": "com.linecorp.armeria.common.auth.oauth2 or com.linecorp.armeria.client.auth.oauth2?", "author": "trustin", "createdAt": "2020-07-06T02:28:26Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/UnsupportedResponseException.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;", "originalCommit": "4e4b80ee25148be663faa0a929741aa7777a305c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwMzkzNg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r452803936", "bodyText": "moved to com.linecorp.armeria.common.auth.oauth2", "author": "max904-github", "createdAt": "2020-07-10T12:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1NTI1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1NjYwNA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r449956604", "bodyText": "Could just use + operator?", "author": "trustin", "createdAt": "2020-07-06T02:35:27Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/AccessTokenCapsule.java", "diffHunk": "@@ -0,0 +1,407 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static java.time.format.DateTimeFormatter.ISO_INSTANT;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+/**\n+ * Defines a structure of the Access Token Response, as per\n+ * <a href=\"https://tools.ietf.org/html/rfc6749#section-5.1\">[RFC6749], Section 5.1</a>.\n+ */\n+public class AccessTokenCapsule implements Serializable {\n+\n+    private static final long serialVersionUID = 8698118404098897958L;\n+\n+    /**\n+     * Creates a new {@link AccessTokenCapsule} based on the {@code JSON}-formatted raw response body and\n+     * optional raw formatted {@code scope} used to request the token.\n+     * @param rawResponse {@code JSON}-formatted raw response body.\n+     * @param requestScope OPTIONAL. A list of space-delimited, case-sensitive strings.\n+     *                     The strings are defined by the authorization server.\n+     *                     The authorization server MAY fully or partially ignore the scope requested by the\n+     *                     client, based on the authorization server policy or the resource owner's\n+     *                     instructions. If the issued access token scope is different from the one requested\n+     *                     by the client, the authorization server MUST include the \"scope\" response\n+     *                     parameter to inform the client of the actual scope granted.\n+     *                     If the client omits the scope parameter when requesting authorization, the\n+     *                     authorization server MUST either process the request using a pre-defined default\n+     *                     value or fail the request indicating an invalid scope.\n+     * @return A new instance of {@link AccessTokenCapsule}.\n+     */\n+    public static AccessTokenCapsule of(String rawResponse, @Nullable String requestScope) {\n+        return AccessTokenCapsuleBuilder.of(rawResponse, requestScope);\n+    }\n+\n+    /**\n+     * Creates a new {@link AccessTokenCapsuleBuilder} to build a new {@link AccessTokenCapsule} and\n+     * supplied it with a value of {@code access_token} Access Token response field.\n+     * @return A new instance of {@link AccessTokenCapsuleBuilder}.\n+     */\n+    public static AccessTokenCapsuleBuilder builder(String accessToken) {\n+        return new AccessTokenCapsuleBuilder(accessToken);\n+    }\n+\n+    static final String ACCESS_TOKEN = \"access_token\";\n+    static final String TOKEN_TYPE = \"token_type\";\n+    static final String EXPIRES_IN = \"expires_in\";\n+    static final String REFRESH_TOKEN = \"refresh_token\";\n+    static final String SCOPE = \"scope\";\n+\n+    static final String ISSUED_AT = \"issued_at\";\n+\n+    static final String SCOPE_SEPARATOR = \" \";\n+    static final String AUTHORIZATION_SEPARATOR = \" \";\n+\n+    static final String DEFAULT_TOKEN_TYPE = \"bearer\";\n+\n+    static final ObjectMapper JSON = new ObjectMapper();\n+\n+    /**\n+     * {@code access_token} Access Token response field,\n+     * REQUIRED. The access token issued by the authorization server.\n+     */\n+    private final String accessToken;\n+\n+    /**\n+     * {@code token_type} Access Token response field,\n+     * REQUIRED. The type of the token issued as described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-7.1\">[RFC6749], Section 7.1</a>, e.g. \"bearer\".\n+     * Value is case insensitive.\n+     */\n+    @Nullable\n+    private final String tokenType;\n+\n+    /**\n+     * {@code expires_in} Access Token response field,\n+     * RECOMMENDED. The lifetime in seconds of the access token. For example, the value \"3600\" denotes\n+     * that the access token will expire in one hour from the time the response was generated. If\n+     * omitted, the authorization server SHOULD provide the expiration time via other means or\n+     * document the default value.\n+     */\n+    @Nullable\n+    private final Duration expiresIn;\n+\n+    /**\n+     * {@code refresh_token} Access Token response field,\n+     * OPTIONAL. The refresh token, which can be used to obtain new access tokens using the same\n+     * authorization grant as described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-6\">[RFC6749], Section 6</a>.\n+     */\n+    @Nullable\n+    private final String refreshToken;\n+\n+    /**\n+     * {@code scope} Access Token response field,\n+     * OPTIONAL, if identical to the scope requested by the client; otherwise, REQUIRED. The scope of\n+     * the access token as described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-3.3\">[RFC6749], Section 3.3</a>.\n+     * A list of space-delimited, case-sensitive scope strings. The strings are defined by the authorization\n+     * server.\n+     * The authorization server MAY fully or partially ignore the scope requested by the client, based\n+     * on the authorization server policy or the resource owner's instructions.  If the issued access\n+     * token scope is different from the one requested by the client, the authorization server MUST\n+     * include the \"scope\" response parameter to inform the client of the actual scope granted.\n+     * If the client omits the scope parameter when requesting authorization, the authorization server\n+     * MUST either process the request using a pre-defined default value or fail the request\n+     * indicating an invalid scope.\n+     */\n+    @Nullable\n+    private final String scope;\n+\n+    /**\n+     * A {@link Set} of case-sensitive scope strings. The strings are defined by the authorization\n+     * server.\n+     */\n+    private final Set<String> scopeSet;\n+\n+    /**\n+     * A {@link Map} of extra system-specific token parameters included with Access Token response,\n+     * OPTIONAL.\n+     */\n+    private final Map<String, String> extras;\n+\n+    private final Instant issuedAt;\n+\n+    @Nullable\n+    private String rawResponse;\n+\n+    @Nullable\n+    private transient Instant expiresAt;\n+\n+    @Nullable\n+    private transient String authorization;\n+\n+    @Nullable\n+    private transient String toString;\n+\n+    AccessTokenCapsule(String accessToken, @Nullable String tokenType,\n+                       Instant issuedAt, @Nullable Duration expiresIn,\n+                       @Nullable String refreshToken, @Nullable List<String> scopeList,\n+                       @Nullable ImmutableMap<String, String> extras,\n+                       @Nullable String rawResponse) {\n+        // token fields\n+        this.accessToken = requireNonNull(accessToken, ACCESS_TOKEN);\n+        this.tokenType = tokenType;\n+        this.expiresIn = expiresIn;\n+        this.issuedAt = requireNonNull(issuedAt, ISSUED_AT);\n+        this.refreshToken = refreshToken;\n+        scope = toScopeString(scopeList);\n+        scopeSet = (scopeList == null) ? ImmutableSet.of() : ImmutableSet.copyOf(scopeList);\n+        this.extras = (extras == null) ? ImmutableMap.of() : extras;\n+        // raw response\n+        this.rawResponse = rawResponse;\n+    }\n+\n+    /**\n+     * {@code access_token} Access Token response field,\n+     * REQUIRED. The access token issued by the authorization server.\n+     */\n+    public String accessToken() {\n+        return accessToken;\n+    }\n+\n+    /**\n+     * {@code token_type}  Access Token response field,\n+     * REQUIRED. The type of the token issued as described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-7.1\">[RFC6749], Section 7.1</a>.\n+     * Value is case insensitive.\n+     */\n+    @Nullable\n+    public String tokenType() {\n+        return tokenType;\n+    }\n+\n+    /**\n+     * {@code expires_in} Access Token response field,\n+     * RECOMMENDED. {@link Duration} indicating the lifetime of the access token. For example,\n+     * the value 3600 seconds denotes that the access token will expire in one hour from the time\n+     * the response was generated. If omitted, the authorization server SHOULD provide the expiration\n+     * time via other means or document the default value.\n+     */\n+    @Nullable\n+    public Duration expiresIn() {\n+        return expiresIn;\n+    }\n+\n+    /**\n+     * An {@link Instant} indicating when the Access Token was issued.\n+     * The value is NOT supplied with the Access Token response and calculated approximately using\n+     * {@code expires_in} field.\n+     */\n+    public Instant issuedAt() {\n+        return issuedAt;\n+    }\n+\n+    /**\n+     * An {@link Instant} representing a derived value using {@code issuedAt + expiresIn}.\n+     */\n+    @Nullable\n+    public Instant expiresAt() {\n+        if (expiresIn == null) {\n+            return null;\n+        }\n+        if (expiresAt == null) {\n+            expiresAt = issuedAt.plus(expiresIn);\n+        }\n+        return expiresAt;\n+    }\n+\n+    /**\n+     * Indicates whether or not the Access Token expire at the given {@link Instant} time based on\n+     * {@link #expiresAt()} function.\n+     */\n+    public boolean isValid(Instant instant) {\n+        final Instant expires = expiresAt();\n+        return (expires == null) || requireNonNull(instant, \"instant\").isBefore(expires);\n+    }\n+\n+    /**\n+     * Indicates whether or not the Access Token already expired based on {@link #expiresAt()} function.\n+     */\n+    public boolean isValid() {\n+        return isValid(Instant.now());\n+    }\n+\n+    /**\n+     * {@code refresh_token} Access Token response field,\n+     * OPTIONAL. The refresh token, which can be used to obtain new access tokens using the same\n+     * authorization grant as described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-6\">[RFC6749], Section 6</a>.\n+     */\n+    @Nullable\n+    public String refreshToken() {\n+        return refreshToken;\n+    }\n+\n+    /**\n+     * {@code scope} Access Token response field,\n+     * OPTIONAL, if identical to the scope requested by the client; otherwise, REQUIRED. The scope of\n+     * the access token as described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-3.3\">[RFC6749], Section 3.3</a>.\n+     * A list of space-delimited, case-sensitive scope strings. The strings are defined by the authorization\n+     * server.\n+     * The authorization server MAY fully or partially ignore the scope requested by the client, based\n+     * on the authorization server policy or the resource owner's instructions.  If the issued access\n+     * token scope is different from the one requested by the client, the authorization server MUST\n+     * include the \"scope\" response parameter to inform the client of the actual scope granted.\n+     * If the client omits the scope parameter when requesting authorization, the authorization server\n+     * MUST either process the request using a pre-defined default value or fail the request\n+     * indicating an invalid scope.\n+     */\n+    @Nullable\n+    public String scope() {\n+        return scope;\n+    }\n+\n+    /**\n+     * {@code scope} Access Token response field,\n+     * OPTIONAL, if identical to the scope requested by the client; otherwise, REQUIRED. The scope of\n+     * the access token as described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-3.3\">[RFC6749], Section 3.3</a>.\n+     * A {@link Set} of case-sensitive scope strings. The strings are defined by the authorization\n+     * server.\n+     * The authorization server MAY fully or partially ignore the scope requested by the client, based\n+     * on the authorization server policy or the resource owner's instructions.  If the issued access\n+     * token scope is different from the one requested by the client, the authorization server MUST\n+     * include the \"scope\" response parameter to inform the client of the actual scope granted.\n+     * If the client omits the scope parameter when requesting authorization, the authorization server\n+     * MUST either process the request using a pre-defined default value or fail the request\n+     * indicating an invalid scope.\n+     */\n+    public Set<String> scopeSet() {\n+        return scopeSet;\n+    }\n+\n+    /**\n+     * A {@link Map} of extra system-specific token parameters included with Access Token response,\n+     * OPTIONAL.\n+     */\n+    public Map<String, String> extras() {\n+        return extras;\n+    }\n+\n+    /**\n+     * A value of the {@link HttpHeaderNames#AUTHORIZATION} header based on this access token.\n+     */\n+    public String authorization() {\n+        if (authorization == null) {\n+            final String type = (tokenType == null) ? DEFAULT_TOKEN_TYPE : tokenType;\n+            authorization = String.join(AUTHORIZATION_SEPARATOR,\n+                                        CaseUtil.firstUpperAllLowerCase(type), accessToken);", "originalCommit": "4e4b80ee25148be663faa0a929741aa7777a305c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxNDU0MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r452814540", "bodyText": "changed to concatenation", "author": "max904-github", "createdAt": "2020-07-10T12:34:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1NjYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1NjY5NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r449956694", "bodyText": "How about adding 'why'?", "author": "trustin", "createdAt": "2020-07-06T02:36:06Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/AccessTokenCapsule.java", "diffHunk": "@@ -0,0 +1,407 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static java.time.format.DateTimeFormatter.ISO_INSTANT;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+/**\n+ * Defines a structure of the Access Token Response, as per\n+ * <a href=\"https://tools.ietf.org/html/rfc6749#section-5.1\">[RFC6749], Section 5.1</a>.\n+ */\n+public class AccessTokenCapsule implements Serializable {\n+\n+    private static final long serialVersionUID = 8698118404098897958L;\n+\n+    /**\n+     * Creates a new {@link AccessTokenCapsule} based on the {@code JSON}-formatted raw response body and\n+     * optional raw formatted {@code scope} used to request the token.\n+     * @param rawResponse {@code JSON}-formatted raw response body.\n+     * @param requestScope OPTIONAL. A list of space-delimited, case-sensitive strings.\n+     *                     The strings are defined by the authorization server.\n+     *                     The authorization server MAY fully or partially ignore the scope requested by the\n+     *                     client, based on the authorization server policy or the resource owner's\n+     *                     instructions. If the issued access token scope is different from the one requested\n+     *                     by the client, the authorization server MUST include the \"scope\" response\n+     *                     parameter to inform the client of the actual scope granted.\n+     *                     If the client omits the scope parameter when requesting authorization, the\n+     *                     authorization server MUST either process the request using a pre-defined default\n+     *                     value or fail the request indicating an invalid scope.\n+     * @return A new instance of {@link AccessTokenCapsule}.\n+     */\n+    public static AccessTokenCapsule of(String rawResponse, @Nullable String requestScope) {\n+        return AccessTokenCapsuleBuilder.of(rawResponse, requestScope);\n+    }\n+\n+    /**\n+     * Creates a new {@link AccessTokenCapsuleBuilder} to build a new {@link AccessTokenCapsule} and\n+     * supplied it with a value of {@code access_token} Access Token response field.\n+     * @return A new instance of {@link AccessTokenCapsuleBuilder}.\n+     */\n+    public static AccessTokenCapsuleBuilder builder(String accessToken) {\n+        return new AccessTokenCapsuleBuilder(accessToken);\n+    }\n+\n+    static final String ACCESS_TOKEN = \"access_token\";\n+    static final String TOKEN_TYPE = \"token_type\";\n+    static final String EXPIRES_IN = \"expires_in\";\n+    static final String REFRESH_TOKEN = \"refresh_token\";\n+    static final String SCOPE = \"scope\";\n+\n+    static final String ISSUED_AT = \"issued_at\";\n+\n+    static final String SCOPE_SEPARATOR = \" \";\n+    static final String AUTHORIZATION_SEPARATOR = \" \";\n+\n+    static final String DEFAULT_TOKEN_TYPE = \"bearer\";\n+\n+    static final ObjectMapper JSON = new ObjectMapper();\n+\n+    /**\n+     * {@code access_token} Access Token response field,\n+     * REQUIRED. The access token issued by the authorization server.\n+     */\n+    private final String accessToken;\n+\n+    /**\n+     * {@code token_type} Access Token response field,\n+     * REQUIRED. The type of the token issued as described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-7.1\">[RFC6749], Section 7.1</a>, e.g. \"bearer\".\n+     * Value is case insensitive.\n+     */\n+    @Nullable\n+    private final String tokenType;\n+\n+    /**\n+     * {@code expires_in} Access Token response field,\n+     * RECOMMENDED. The lifetime in seconds of the access token. For example, the value \"3600\" denotes\n+     * that the access token will expire in one hour from the time the response was generated. If\n+     * omitted, the authorization server SHOULD provide the expiration time via other means or\n+     * document the default value.\n+     */\n+    @Nullable\n+    private final Duration expiresIn;\n+\n+    /**\n+     * {@code refresh_token} Access Token response field,\n+     * OPTIONAL. The refresh token, which can be used to obtain new access tokens using the same\n+     * authorization grant as described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-6\">[RFC6749], Section 6</a>.\n+     */\n+    @Nullable\n+    private final String refreshToken;\n+\n+    /**\n+     * {@code scope} Access Token response field,\n+     * OPTIONAL, if identical to the scope requested by the client; otherwise, REQUIRED. The scope of\n+     * the access token as described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-3.3\">[RFC6749], Section 3.3</a>.\n+     * A list of space-delimited, case-sensitive scope strings. The strings are defined by the authorization\n+     * server.\n+     * The authorization server MAY fully or partially ignore the scope requested by the client, based\n+     * on the authorization server policy or the resource owner's instructions.  If the issued access\n+     * token scope is different from the one requested by the client, the authorization server MUST\n+     * include the \"scope\" response parameter to inform the client of the actual scope granted.\n+     * If the client omits the scope parameter when requesting authorization, the authorization server\n+     * MUST either process the request using a pre-defined default value or fail the request\n+     * indicating an invalid scope.\n+     */\n+    @Nullable\n+    private final String scope;\n+\n+    /**\n+     * A {@link Set} of case-sensitive scope strings. The strings are defined by the authorization\n+     * server.\n+     */\n+    private final Set<String> scopeSet;\n+\n+    /**\n+     * A {@link Map} of extra system-specific token parameters included with Access Token response,\n+     * OPTIONAL.\n+     */\n+    private final Map<String, String> extras;\n+\n+    private final Instant issuedAt;\n+\n+    @Nullable\n+    private String rawResponse;\n+\n+    @Nullable\n+    private transient Instant expiresAt;\n+\n+    @Nullable\n+    private transient String authorization;\n+\n+    @Nullable\n+    private transient String toString;\n+\n+    AccessTokenCapsule(String accessToken, @Nullable String tokenType,\n+                       Instant issuedAt, @Nullable Duration expiresIn,\n+                       @Nullable String refreshToken, @Nullable List<String> scopeList,\n+                       @Nullable ImmutableMap<String, String> extras,\n+                       @Nullable String rawResponse) {\n+        // token fields\n+        this.accessToken = requireNonNull(accessToken, ACCESS_TOKEN);\n+        this.tokenType = tokenType;\n+        this.expiresIn = expiresIn;\n+        this.issuedAt = requireNonNull(issuedAt, ISSUED_AT);\n+        this.refreshToken = refreshToken;\n+        scope = toScopeString(scopeList);\n+        scopeSet = (scopeList == null) ? ImmutableSet.of() : ImmutableSet.copyOf(scopeList);\n+        this.extras = (extras == null) ? ImmutableMap.of() : extras;\n+        // raw response\n+        this.rawResponse = rawResponse;\n+    }\n+\n+    /**\n+     * {@code access_token} Access Token response field,\n+     * REQUIRED. The access token issued by the authorization server.\n+     */\n+    public String accessToken() {\n+        return accessToken;\n+    }\n+\n+    /**\n+     * {@code token_type}  Access Token response field,\n+     * REQUIRED. The type of the token issued as described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-7.1\">[RFC6749], Section 7.1</a>.\n+     * Value is case insensitive.\n+     */\n+    @Nullable\n+    public String tokenType() {\n+        return tokenType;\n+    }\n+\n+    /**\n+     * {@code expires_in} Access Token response field,\n+     * RECOMMENDED. {@link Duration} indicating the lifetime of the access token. For example,\n+     * the value 3600 seconds denotes that the access token will expire in one hour from the time\n+     * the response was generated. If omitted, the authorization server SHOULD provide the expiration\n+     * time via other means or document the default value.\n+     */\n+    @Nullable\n+    public Duration expiresIn() {\n+        return expiresIn;\n+    }\n+\n+    /**\n+     * An {@link Instant} indicating when the Access Token was issued.\n+     * The value is NOT supplied with the Access Token response and calculated approximately using\n+     * {@code expires_in} field.\n+     */\n+    public Instant issuedAt() {\n+        return issuedAt;\n+    }\n+\n+    /**\n+     * An {@link Instant} representing a derived value using {@code issuedAt + expiresIn}.\n+     */\n+    @Nullable\n+    public Instant expiresAt() {\n+        if (expiresIn == null) {\n+            return null;\n+        }\n+        if (expiresAt == null) {\n+            expiresAt = issuedAt.plus(expiresIn);\n+        }\n+        return expiresAt;\n+    }\n+\n+    /**\n+     * Indicates whether or not the Access Token expire at the given {@link Instant} time based on\n+     * {@link #expiresAt()} function.\n+     */\n+    public boolean isValid(Instant instant) {\n+        final Instant expires = expiresAt();\n+        return (expires == null) || requireNonNull(instant, \"instant\").isBefore(expires);\n+    }\n+\n+    /**\n+     * Indicates whether or not the Access Token already expired based on {@link #expiresAt()} function.\n+     */\n+    public boolean isValid() {\n+        return isValid(Instant.now());\n+    }\n+\n+    /**\n+     * {@code refresh_token} Access Token response field,\n+     * OPTIONAL. The refresh token, which can be used to obtain new access tokens using the same\n+     * authorization grant as described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-6\">[RFC6749], Section 6</a>.\n+     */\n+    @Nullable\n+    public String refreshToken() {\n+        return refreshToken;\n+    }\n+\n+    /**\n+     * {@code scope} Access Token response field,\n+     * OPTIONAL, if identical to the scope requested by the client; otherwise, REQUIRED. The scope of\n+     * the access token as described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-3.3\">[RFC6749], Section 3.3</a>.\n+     * A list of space-delimited, case-sensitive scope strings. The strings are defined by the authorization\n+     * server.\n+     * The authorization server MAY fully or partially ignore the scope requested by the client, based\n+     * on the authorization server policy or the resource owner's instructions.  If the issued access\n+     * token scope is different from the one requested by the client, the authorization server MUST\n+     * include the \"scope\" response parameter to inform the client of the actual scope granted.\n+     * If the client omits the scope parameter when requesting authorization, the authorization server\n+     * MUST either process the request using a pre-defined default value or fail the request\n+     * indicating an invalid scope.\n+     */\n+    @Nullable\n+    public String scope() {\n+        return scope;\n+    }\n+\n+    /**\n+     * {@code scope} Access Token response field,\n+     * OPTIONAL, if identical to the scope requested by the client; otherwise, REQUIRED. The scope of\n+     * the access token as described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-3.3\">[RFC6749], Section 3.3</a>.\n+     * A {@link Set} of case-sensitive scope strings. The strings are defined by the authorization\n+     * server.\n+     * The authorization server MAY fully or partially ignore the scope requested by the client, based\n+     * on the authorization server policy or the resource owner's instructions.  If the issued access\n+     * token scope is different from the one requested by the client, the authorization server MUST\n+     * include the \"scope\" response parameter to inform the client of the actual scope granted.\n+     * If the client omits the scope parameter when requesting authorization, the authorization server\n+     * MUST either process the request using a pre-defined default value or fail the request\n+     * indicating an invalid scope.\n+     */\n+    public Set<String> scopeSet() {\n+        return scopeSet;\n+    }\n+\n+    /**\n+     * A {@link Map} of extra system-specific token parameters included with Access Token response,\n+     * OPTIONAL.\n+     */\n+    public Map<String, String> extras() {\n+        return extras;\n+    }\n+\n+    /**\n+     * A value of the {@link HttpHeaderNames#AUTHORIZATION} header based on this access token.\n+     */\n+    public String authorization() {\n+        if (authorization == null) {\n+            final String type = (tokenType == null) ? DEFAULT_TOKEN_TYPE : tokenType;\n+            authorization = String.join(AUTHORIZATION_SEPARATOR,\n+                                        CaseUtil.firstUpperAllLowerCase(type), accessToken);\n+        }\n+        return authorization;\n+    }\n+\n+    /**\n+     * {@code JSON}-formatted raw Token Introspection Response body. If the {@link AccessTokenCapsule} was not\n+     * parsed out of the raw response body, this value calculated based on the other {@link AccessTokenCapsule}\n+     * values.\n+     */\n+    public String rawResponse() {\n+        if (rawResponse == null) {\n+            // WARNING: do not include {@code issuedAt} to the raw response", "originalCommit": "4e4b80ee25148be663faa0a929741aa7777a305c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwNTEzNg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r452805136", "bodyText": "added", "author": "max904-github", "createdAt": "2020-07-10T12:13:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1NjY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1Nzc0Mg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r449957742", "bodyText": "Better using Ascii?", "author": "trustin", "createdAt": "2020-07-06T02:41:11Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/CaseUtil.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import javax.annotation.Nullable;\n+\n+final class CaseUtil {\n+\n+  @Nullable\n+  static String firstUpperCase(@Nullable String word) {\n+    if (word == null || word.isEmpty()) {\n+      return word;\n+    }\n+    return Character.toUpperCase(word.charAt(0)) + word.substring(1);", "originalCommit": "4e4b80ee25148be663faa0a929741aa7777a305c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwOTUyMg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r452809522", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-07-10T12:23:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1Nzc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1Nzc2OQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r449957769", "bodyText": "Better using Ascii?", "author": "trustin", "createdAt": "2020-07-06T02:41:19Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/CaseUtil.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import javax.annotation.Nullable;\n+\n+final class CaseUtil {\n+\n+  @Nullable\n+  static String firstUpperCase(@Nullable String word) {\n+    if (word == null || word.isEmpty()) {\n+      return word;\n+    }\n+    return Character.toUpperCase(word.charAt(0)) + word.substring(1);\n+  }\n+\n+  @Nullable\n+  static String firstUpperAllLowerCase(@Nullable String word) {\n+    if (word == null || word.isEmpty()) {\n+      return word;\n+    }\n+    return Character.toUpperCase(word.charAt(0)) + word.substring(1).toLowerCase();", "originalCommit": "4e4b80ee25148be663faa0a929741aa7777a305c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwOTU4Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r452809586", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-07-10T12:23:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1Nzc2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1ODg0NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r449958845", "bodyText": "Could be char?", "author": "trustin", "createdAt": "2020-07-06T02:47:03Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/ClientAuthorization.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Provides client authorization for the OAuth 2.0 requests,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+ * For example:\n+ * <pre>{@code\n+ * Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3\n+ * }</pre>\n+ * Fetches authorization source from the designated authorization or credentials supplier, which\n+ * might be facilitated by a secure Secret provider. Will fetch the authorization source for each\n+ * request. Therefore the designated supplier must cache the value in order to avoid unnecessary\n+ * network hops.\n+ * The authorization source might either provide complete authorization token or client credentials.\n+ */\n+public final class ClientAuthorization {\n+\n+  private static final String DEFAULT_AUTHORIZATION_TYPE = \"Basic\";\n+  private static final String AUTHORIZATION_SEPARATOR = \" \";\n+  private static final String CREDENTIALS_SEPARATOR = \":\";", "originalCommit": "4e4b80ee25148be663faa0a929741aa7777a305c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxMjY5Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r452812697", "bodyText": "changed to char", "author": "max904-github", "createdAt": "2020-07-10T12:30:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1ODg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1ODg5MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r449958891", "bodyText": "Could be char?", "author": "trustin", "createdAt": "2020-07-06T02:47:12Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/ClientAuthorization.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Provides client authorization for the OAuth 2.0 requests,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+ * For example:\n+ * <pre>{@code\n+ * Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3\n+ * }</pre>\n+ * Fetches authorization source from the designated authorization or credentials supplier, which\n+ * might be facilitated by a secure Secret provider. Will fetch the authorization source for each\n+ * request. Therefore the designated supplier must cache the value in order to avoid unnecessary\n+ * network hops.\n+ * The authorization source might either provide complete authorization token or client credentials.\n+ */\n+public final class ClientAuthorization {\n+\n+  private static final String DEFAULT_AUTHORIZATION_TYPE = \"Basic\";\n+  private static final String AUTHORIZATION_SEPARATOR = \" \";\n+  private static final String CREDENTIALS_SEPARATOR = \":\";\n+\n+  private static final String CLIENT_ID = \"client_id\";\n+  private static final String CLIENT_SECRET = \"client_secret\";\n+  private static final char FORM_ENTRY_SEPARATOR = '=';\n+  private static final char FORM_TUPLE_SEPARATOR = '&';", "originalCommit": "4e4b80ee25148be663faa0a929741aa7777a305c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxMjU1OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r452812558", "bodyText": "already a char", "author": "max904-github", "createdAt": "2020-07-10T12:30:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1ODg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1ODk3Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r449958976", "bodyText": "Could just use + operator", "author": "trustin", "createdAt": "2020-07-06T02:47:36Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/ClientAuthorization.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Provides client authorization for the OAuth 2.0 requests,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+ * For example:\n+ * <pre>{@code\n+ * Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3\n+ * }</pre>\n+ * Fetches authorization source from the designated authorization or credentials supplier, which\n+ * might be facilitated by a secure Secret provider. Will fetch the authorization source for each\n+ * request. Therefore the designated supplier must cache the value in order to avoid unnecessary\n+ * network hops.\n+ * The authorization source might either provide complete authorization token or client credentials.\n+ */\n+public final class ClientAuthorization {\n+\n+  private static final String DEFAULT_AUTHORIZATION_TYPE = \"Basic\";\n+  private static final String AUTHORIZATION_SEPARATOR = \" \";\n+  private static final String CREDENTIALS_SEPARATOR = \":\";\n+\n+  private static final String CLIENT_ID = \"client_id\";\n+  private static final String CLIENT_SECRET = \"client_secret\";\n+  private static final char FORM_ENTRY_SEPARATOR = '=';\n+  private static final char FORM_TUPLE_SEPARATOR = '&';\n+\n+  private final String authorizationType;\n+  @Nullable\n+  private final Supplier<String> authorizationSupplier;\n+  @Nullable\n+  private final Supplier<Map.Entry<String, String>> credentialsSupplier;\n+\n+  /**\n+   * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+   * authorization type,\n+   * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+   *\n+   * @param authorizationSupplier A supplier of encoded client authorization token.\n+   * @param authorizationType One of the registered HTTP authentication schemes as per\n+   *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+   *                          HTTP Authentication Scheme Registry</a>.\n+   */\n+  public static ClientAuthorization ofAuthorization(\n+      Supplier<String> authorizationSupplier, String authorizationType) {\n+    return new ClientAuthorization(requireNonNull(authorizationSupplier, \"authorizationSupplier\"),\n+        null, requireNonNull(authorizationType, \"authorizationType\"));\n+  }\n+\n+  /**\n+   * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+   * {@code Basic} authorization type,\n+   * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+   *\n+   * @param authorizationSupplier A supplier of encoded client authorization token.\n+   */\n+  public static ClientAuthorization ofBasicAuthorization(\n+      Supplier<String> authorizationSupplier) {\n+    return new ClientAuthorization(requireNonNull(authorizationSupplier, \"authorizationSupplier\"),\n+        null, null);\n+  }\n+\n+  /**\n+   * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+   * authorization type,\n+   * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+   *\n+   * @param credentialsSupplier A supplier of client credentials.\n+   * @param authorizationType One of the registered HTTP authentication schemes as per\n+   *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+   *                          HTTP Authentication Scheme Registry</a>.\n+   */\n+  public static ClientAuthorization ofCredentials(\n+      Supplier<Map.Entry<String, String>> credentialsSupplier, String authorizationType) {\n+    return new ClientAuthorization(null,\n+        requireNonNull(credentialsSupplier, \"credentialsSupplier\"),\n+        requireNonNull(authorizationType, \"authorizationType\"));\n+  }\n+\n+  /**\n+   * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+   * {@code Basic} authorization type,\n+   * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+   *\n+   * @param credentialsSupplier A supplier of client credentials.\n+   */\n+  public static ClientAuthorization ofCredentials(\n+      Supplier<Map.Entry<String, String>> credentialsSupplier) {\n+    return new ClientAuthorization(null,\n+        requireNonNull(credentialsSupplier, \"credentialsSupplier\"), null);\n+  }\n+\n+  private ClientAuthorization(@Nullable Supplier<String> authorizationSupplier,\n+      @Nullable Supplier<Map.Entry<String, String>> credentialsSupplier,\n+      @Nullable String authorizationType) {\n+    if (authorizationSupplier == null && credentialsSupplier == null) {\n+      throw new NullPointerException(\"authorizationSupplier && credentialsSupplier\");\n+    }\n+    this.authorizationSupplier = authorizationSupplier;\n+    this.credentialsSupplier = credentialsSupplier;\n+    this.authorizationType =\n+        authorizationType == null ? DEFAULT_AUTHORIZATION_TYPE : authorizationType;\n+  }\n+\n+  private String composeAuthorizationString() {\n+    final String clientAuthorization;\n+    if (authorizationSupplier != null) {\n+      clientAuthorization = authorizationSupplier.get();\n+    } else if (credentialsSupplier != null) {\n+      final Map.Entry<String, String> clientCredentials = credentialsSupplier.get();\n+      clientAuthorization = encodeClientCredentials(clientCredentials.getKey(), clientCredentials.getValue());\n+    } else {\n+      // we should not get here\n+      throw new NullPointerException(\"authorizationSupplier && credentialsSupplier\");\n+    }\n+    return clientAuthorization;\n+  }\n+\n+  /**\n+   * Fetches client authorization token or client credentials from the supplier and composes client\n+   * {@code Authorization} header value,\n+   * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>:\n+   * <pre>{@code\n+   * Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3\n+   * }</pre>.\n+   *\n+   * @return encoded client {@code Authorization} header value.\n+   */\n+  public String authorizationHeaderValue() {\n+    return String.join(AUTHORIZATION_SEPARATOR,\n+                       CaseUtil.firstUpperAllLowerCase(authorizationType), composeAuthorizationString());\n+  }\n+\n+  /**\n+   * Fetches client credentials from the supplier and composes required body parameters,\n+   * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>:\n+   * <pre>{@code\n+   * client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw\n+   * }</pre>.\n+   *\n+   * @return encoded client credentials request body parameters.\n+   */\n+  public String credentialsBodyParameters() {\n+    requireNonNull(credentialsSupplier, \"credentialsSupplier\");\n+    final Map.Entry<String, String> clientCredentials = credentialsSupplier.get();\n+    final StringBuilder builder = new StringBuilder()\n+        .append(CLIENT_ID).append(FORM_ENTRY_SEPARATOR)\n+        .append(urlEncode(clientCredentials.getKey()))\n+        .append(FORM_TUPLE_SEPARATOR)\n+        .append(CLIENT_SECRET).append(FORM_ENTRY_SEPARATOR)\n+        .append(urlEncode(clientCredentials.getValue()));\n+    return builder.toString();\n+  }\n+\n+  private static String encodeClientCredentials(String clientId, String clientSecret) {\n+      return Base64.getEncoder()\n+                   .encodeToString(\n+                           String.join(CREDENTIALS_SEPARATOR, clientId, clientSecret)", "originalCommit": "4e4b80ee25148be663faa0a929741aa7777a305c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxMjkzOQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r452812939", "bodyText": "changed to concatenation", "author": "max904-github", "createdAt": "2020-07-10T12:31:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1ODk3Ng=="}], "type": "inlineReview"}, {"oid": "7e258fbe3783684db657d1a998fc24a181a80b55", "url": "https://github.com/line/armeria/commit/7e258fbe3783684db657d1a998fc24a181a80b55", "message": "- incorporated review comments by @trustin and @minwoox\n- fixed thread synchronization issue at AbstractOAuth2AuthorizationGrant and perform obtain/refresh requests using dedicated thread to minimize blocking of the event loop.", "committedDate": "2020-07-12T10:32:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4MjU1MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r453582550", "bodyText": "Question: do you think it is better to abbreviate Authorization into Authz?", "author": "trustin", "createdAt": "2020-07-13T11:27:17Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/OAuth2AuthorizationGrant.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import java.util.concurrent.CompletionStage;\n+\n+import com.linecorp.armeria.common.auth.oauth2.AccessTokenCapsule;\n+\n+/**\n+ * Represents an OAuth 2.0 Access Token Grant flow to obtain Access Token.\n+ */\n+@FunctionalInterface\n+public interface OAuth2AuthorizationGrant {", "originalCommit": "7e258fbe3783684db657d1a998fc24a181a80b55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQyMDY2Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r454420666", "bodyText": "You like reducing the number of symbols used in the class name or you are concerned about some ambiguity? The user won't interact with those classes directly.\nOn the client, the user interacts with OAuth2Client and one of the available Grants (OAuth2ClientCredentialsGrant or OAuth2ResourceOwnerPasswordCredentialsGrant).\nOn the server, the user interacts with OAuth2TokenIntrospectionAuthorizer.", "author": "max904-github", "createdAt": "2020-07-14T14:57:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4MjU1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc1Mzk2NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r456753964", "bodyText": "Thanks for explanation. Sounds good as it is, then. \ud83d\udc4d", "author": "trustin", "createdAt": "2020-07-18T05:53:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4MjU1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4MzMzNw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r453583337", "bodyText": "Is the term Capsule something defined in OAuth 2 or an authorization jargon? If not, what would be a better name? GrantedAccessToken? \ud83e\udd14", "author": "trustin", "createdAt": "2020-07-13T11:28:57Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/OAuth2AuthorizationGrant.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import java.util.concurrent.CompletionStage;\n+\n+import com.linecorp.armeria.common.auth.oauth2.AccessTokenCapsule;\n+\n+/**\n+ * Represents an OAuth 2.0 Access Token Grant flow to obtain Access Token.\n+ */\n+@FunctionalInterface\n+public interface OAuth2AuthorizationGrant {\n+\n+    /**\n+     * Produces OAuth 2.0 Access Token\n+     */\n+    CompletionStage<AccessTokenCapsule> getAccessToken();", "originalCommit": "7e258fbe3783684db657d1a998fc24a181a80b55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM5NDA5Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r454394097", "bodyText": "No, Capsule is not part of OAuth 2. It's just a word to describe a shell or a container that contains Access Token, Refresh Token and some other elements. It's not really a descriptor (which is what we get as a result of introspection). You don't like the word Capsule or you think it could be confusing?", "author": "max904-github", "createdAt": "2020-07-14T14:23:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4MzMzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MzE1MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r454783151", "bodyText": "I prefer OAuth2AccessToken \ud83d\ude09", "author": "ikhoon", "createdAt": "2020-07-15T04:26:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4MzMzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODAxODU0OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r458018548", "bodyText": "Renamed to OAuth2AccessToken", "author": "max904-github", "createdAt": "2020-07-21T11:12:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4MzMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc1MjYzNg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r454752636", "bodyText": "You can use QueryParams instead of the manual building of parameters string. \ud83d\ude09", "author": "ikhoon", "createdAt": "2020-07-15T02:28:21Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/ClientAuthorization.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Provides client authorization for the OAuth 2.0 requests,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+ * For example:\n+ * <pre>{@code\n+ * Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3\n+ * }</pre>\n+ * Fetches authorization source from the designated authorization or credentials supplier, which\n+ * might be facilitated by a secure Secret provider. Will fetch the authorization source for each\n+ * request. Therefore the designated supplier must cache the value in order to avoid unnecessary\n+ * network hops.\n+ * The authorization source might either provide complete authorization token or client credentials.\n+ */\n+public final class ClientAuthorization {\n+\n+  private static final String DEFAULT_AUTHORIZATION_TYPE = \"Basic\";\n+  private static final char AUTHORIZATION_SEPARATOR = ' ';\n+  private static final char CREDENTIALS_SEPARATOR = ':';\n+\n+  private static final String CLIENT_ID = \"client_id\";\n+  private static final String CLIENT_SECRET = \"client_secret\";\n+  private static final char FORM_ENTRY_SEPARATOR = '=';\n+  private static final char FORM_TUPLE_SEPARATOR = '&';\n+\n+  private final String authorizationType;\n+  @Nullable\n+  private final Supplier<String> authorizationSupplier;\n+  @Nullable\n+  private final Supplier<? extends Map.Entry<String, String>> credentialsSupplier;\n+\n+  /**\n+   * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+   * authorization type,\n+   * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+   *\n+   * @param authorizationSupplier A supplier of encoded client authorization token.\n+   * @param authorizationType One of the registered HTTP authentication schemes as per\n+   *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+   *                          HTTP Authentication Scheme Registry</a>.\n+   */\n+  public static ClientAuthorization ofAuthorization(\n+      Supplier<String> authorizationSupplier, String authorizationType) {\n+    return new ClientAuthorization(requireNonNull(authorizationSupplier, \"authorizationSupplier\"),\n+        null, requireNonNull(authorizationType, \"authorizationType\"));\n+  }\n+\n+  /**\n+   * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+   * {@code Basic} authorization type,\n+   * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+   *\n+   * @param authorizationSupplier A supplier of encoded client authorization token.\n+   */\n+  public static ClientAuthorization ofBasicAuthorization(\n+      Supplier<String> authorizationSupplier) {\n+    return new ClientAuthorization(requireNonNull(authorizationSupplier, \"authorizationSupplier\"),\n+        null, null);\n+  }\n+\n+  /**\n+   * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+   * authorization type,\n+   * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+   *\n+   * @param credentialsSupplier A supplier of client credentials.\n+   * @param authorizationType One of the registered HTTP authentication schemes as per\n+   *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+   *                          HTTP Authentication Scheme Registry</a>.\n+   */\n+  public static ClientAuthorization ofCredentials(\n+      Supplier<? extends Map.Entry<String, String>> credentialsSupplier, String authorizationType) {\n+    return new ClientAuthorization(null,\n+        requireNonNull(credentialsSupplier, \"credentialsSupplier\"),\n+        requireNonNull(authorizationType, \"authorizationType\"));\n+  }\n+\n+  /**\n+   * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+   * {@code Basic} authorization type,\n+   * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+   *\n+   * @param credentialsSupplier A supplier of client credentials.\n+   */\n+  public static ClientAuthorization ofCredentials(\n+      Supplier<? extends Map.Entry<String, String>> credentialsSupplier) {\n+    return new ClientAuthorization(null,\n+        requireNonNull(credentialsSupplier, \"credentialsSupplier\"), null);\n+  }\n+\n+  private ClientAuthorization(@Nullable Supplier<String> authorizationSupplier,\n+      @Nullable Supplier<? extends Map.Entry<String, String>> credentialsSupplier,\n+      @Nullable String authorizationType) {\n+    if (authorizationSupplier == null && credentialsSupplier == null) {\n+      throw new NullPointerException(\"authorizationSupplier && credentialsSupplier\");\n+    }\n+    this.authorizationSupplier = authorizationSupplier;\n+    this.credentialsSupplier = credentialsSupplier;\n+    this.authorizationType =\n+        authorizationType == null ? DEFAULT_AUTHORIZATION_TYPE : authorizationType;\n+  }\n+\n+  private String composeAuthorizationString() {\n+    final String clientAuthorization;\n+    if (authorizationSupplier != null) {\n+      clientAuthorization = authorizationSupplier.get();\n+    } else if (credentialsSupplier != null) {\n+      final Map.Entry<String, String> clientCredentials = credentialsSupplier.get();\n+      clientAuthorization = encodeClientCredentials(clientCredentials.getKey(), clientCredentials.getValue());\n+    } else {\n+      // we should not get here\n+      throw new NullPointerException(\"authorizationSupplier && credentialsSupplier\");\n+    }\n+    return clientAuthorization;\n+  }\n+\n+  /**\n+   * Fetches client authorization token or client credentials from the supplier and composes client\n+   * {@code Authorization} header value,\n+   * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>:\n+   * <pre>{@code\n+   * Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3\n+   * }</pre>.\n+   *\n+   * @return encoded client {@code Authorization} header value.\n+   */\n+  public String authorizationHeaderValue() {\n+    return CaseUtil.firstUpperAllLowerCase(authorizationType) +\n+           AUTHORIZATION_SEPARATOR + composeAuthorizationString();\n+  }\n+\n+  /**\n+   * Fetches client credentials from the supplier and composes required body parameters,\n+   * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>:\n+   * <pre>{@code\n+   * client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw\n+   * }</pre>.\n+   *\n+   * @return encoded client credentials request body parameters.\n+   */\n+  public String credentialsBodyParameters() {\n+    requireNonNull(credentialsSupplier, \"credentialsSupplier\");\n+    final Map.Entry<String, String> clientCredentials = credentialsSupplier.get();\n+    final StringBuilder builder = new StringBuilder()\n+        .append(CLIENT_ID).append(FORM_ENTRY_SEPARATOR)\n+        .append(urlEncode(clientCredentials.getKey()))\n+        .append(FORM_TUPLE_SEPARATOR)\n+        .append(CLIENT_SECRET).append(FORM_ENTRY_SEPARATOR)\n+        .append(urlEncode(clientCredentials.getValue()));", "originalCommit": "7e258fbe3783684db657d1a998fc24a181a80b55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzkyMzUwNQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r457923505", "bodyText": "Fixed", "author": "max904-github", "createdAt": "2020-07-21T08:23:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc1MjYzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc1NDcxMQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r454754711", "bodyText": "Ditto, You can use QueryParams instead of the manual building of the parameters string.", "author": "ikhoon", "createdAt": "2020-07-15T02:36:19Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/AbstractAuthorizationRequest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n+\n+/**\n+ * A common abstraction for the requests implementing various Authorization request/response flows,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a> and other relevant specifications.\n+ * @param <T> the type of the authorization result.\n+ */\n+abstract class AbstractAuthorizationRequest<T> {\n+\n+    private static final String FORM_ENTRY_SEPARATOR = \"=\";\n+    private static final String FORM_TUPLE_SEPARATOR = \"&\";\n+\n+    private final WebClient endpoint;\n+    private final String endpointPath;\n+    @Nullable\n+    private final ClientAuthorization clientAuthorization;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Authorization request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a> and other relevant specifications.\n+     *\n+     * @param authorizationEndpoint A {@link WebClient} to facilitate the Authorization requests. Must\n+     *                              correspond to the required Authorization endpoint of the OAuth 2 system.\n+     * @param authorizationEndpointPath A URI path that corresponds to the Authorization endpoint of the\n+     *                                  OAuth 2 system.\n+     * @param clientAuthorization Provides client authorization for the OAuth requests,\n+     *                            as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     */\n+    protected AbstractAuthorizationRequest(WebClient authorizationEndpoint, String authorizationEndpointPath,\n+                                           @Nullable ClientAuthorization clientAuthorization) {\n+        endpoint = Objects.requireNonNull(authorizationEndpoint, \"authorizationEndpoint\");\n+        endpointPath = Objects.requireNonNull(authorizationEndpointPath, \"authorizationEndpointPath\");\n+        this.clientAuthorization = clientAuthorization; // optional\n+    }\n+\n+    /**\n+     * Returns the {@link WebClient} of the authorization endpoint.\n+     */\n+    protected WebClient endpoint() {\n+        return endpoint;\n+    }\n+\n+    /**\n+     * Returns the authorization endpoint path.\n+     */\n+    protected String endpointPath() {\n+        return endpointPath;\n+    }\n+\n+    /**\n+     * Returns the value for the {@link HttpHeaderNames#AUTHORIZATION}.\n+     */\n+    @Nullable\n+    protected String authorizationHeaderValue() {\n+        return clientAuthorization == null ? null : clientAuthorization.authorizationHeaderValue();\n+    }\n+\n+    /**\n+     * Composes headers for the authorization request.\n+     */\n+    protected RequestHeaders composeRequestHeaders() {\n+        final RequestHeadersBuilder headersBuilder =\n+                RequestHeaders.of(HttpMethod.POST, endpointPath()).toBuilder();\n+        final String authorizationHeaderValue = authorizationHeaderValue();\n+        if (authorizationHeaderValue != null) {\n+            headersBuilder.add(HttpHeaderNames.AUTHORIZATION, authorizationHeaderValue);\n+        }\n+        headersBuilder.add(HttpHeaderNames.CONTENT_TYPE, MediaType.FORM_DATA.toString());\n+        return headersBuilder.build();\n+    }\n+\n+    /**\n+     * Extracts the result and convert it to the target type {@code T} or throw an error in case of an error\n+     * result.\n+     * @param response An {@link AggregatedHttpResponse} returned by the authorization endpoint.\n+     * @param requestData A {@link Map} that contains all the elements of the request form sent with the\n+     *                    request.\n+     * @throws TokenRequestException when the endpoint returns {code HTTP 400 (Bad Request)} status and the\n+     *                               response payload contains the details of the error.\n+     * @throws InvalidClientException when the endpoint returns {@code HTTP 401 (Unauthorized)} status, which\n+     *                                typically indicates that client authentication failed (e.g.: unknown\n+     *                                client, no client authentication included, or unsupported authentication\n+     *                                method).\n+     * @throws UnsupportedMediaTypeException if the media type of the response does not match the expected\n+     *                                       (JSON).\n+     */\n+    @Nullable\n+    protected T extractResults(AggregatedHttpResponse response, Map<String, String> requestData) {\n+        final HttpStatus status = response.status();\n+        switch (status.code()) {\n+            case 200: // OK\n+                // expected Content-Type: application/json;charset=UTF-8\n+                validateContentType(response, MediaType.JSON);\n+                return extractOkResults(response, requestData);\n+            case 400: // Bad Request\n+                // expected Content-Type: application/json;charset=UTF-8\n+                validateContentType(response, MediaType.JSON);\n+                throw onBadRequestError(response);\n+            case 401: // Unauthorized\n+                throw onUnauthorizedError(response);\n+        }\n+        throw new UnsupportedResponseException(status.code(), status.toString(), response.contentUtf8());\n+    }\n+\n+    /**\n+     * Validates the content type of the response.\n+     */\n+    private static void validateContentType(AggregatedHttpResponse response, MediaType expectedType) {\n+        final MediaType contentType = response.contentType();\n+        if (contentType == null) {\n+            // if omitted, assume that the type matches the expected\n+            return;\n+        }\n+        final String mediaType = contentType.nameWithoutParameters();\n+        if (!mediaType.equalsIgnoreCase(expectedType.nameWithoutParameters())) {\n+            throw new UnsupportedMediaTypeException(mediaType,\n+                                                    response.status().toString(), response.contentUtf8());\n+        }\n+    }\n+\n+    /**\n+     * Extracts data from OK response and converts it to the target type {@code T}.\n+     */\n+    protected abstract T extractOkResults(AggregatedHttpResponse response, Map<String, String> requestData);\n+\n+    /**\n+     * Composes {@link TokenRequestException} upon 400 Bad Request response\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-5.2\">[RFC6749], Section 5.2</a>.\n+     * @param errorResponse response received from the server\n+     * @return an instance of {@link TokenRequestException}\n+     */\n+    protected TokenRequestException onBadRequestError(AggregatedHttpResponse errorResponse) {\n+        return TokenRequestException.builder().of(errorResponse.contentUtf8());\n+    }\n+\n+    /**\n+     * Composes {@link InvalidClientException} upon 401 Unauthorized response\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-5.2\">[RFC6749], Section 5.2</a> (invalid_client).\n+     * @param errorResponse response received from the server\n+     * @return an instance of {@link InvalidClientException}\n+     */\n+    protected TokenRequestException onUnauthorizedError(AggregatedHttpResponse errorResponse) {\n+        final StringBuilder messageBuilder = new StringBuilder().append(errorResponse.status());\n+        final String wwwAuthenticate = errorResponse.headers().get(HttpHeaderNames.WWW_AUTHENTICATE);\n+        if (wwwAuthenticate != null) {\n+            messageBuilder.append(\": \").append(wwwAuthenticate);\n+        }\n+        final HttpData errorResponseContents = errorResponse.content();\n+        if (!errorResponse.content().isEmpty()) {\n+            messageBuilder.append(\": \").append(errorResponseContents.toStringUtf8());\n+        }\n+        return new InvalidClientException(messageBuilder.toString(), null);\n+    }\n+\n+    /**\n+     * Makes a request to the authorization endpoint using supplied {@code requestForm} parameters and converts\n+     * the result to the given type {@code T}.\n+     */\n+    protected CompletableFuture<T> make(LinkedHashMap<String, String> requestForm) {\n+        final HttpData requestContents = HttpData.ofUtf8(\n+                requestForm.entrySet().stream().map(AbstractAuthorizationRequest::urlEncode)\n+                           .collect(Collectors.joining(FORM_TUPLE_SEPARATOR)));\n+        final RequestHeaders requestHeaders = composeRequestHeaders();\n+        final HttpResponse response = endpoint().execute(requestHeaders, requestContents);\n+        // when response aggregated, then extract the results...\n+        return response.aggregate().thenApply(r -> extractResults(r, Collections.unmodifiableMap(requestForm)));\n+    }\n+\n+    private static String urlEncode(Map.Entry<String, String> entry) {\n+        return entry.getKey() + FORM_ENTRY_SEPARATOR + urlEncode(entry.getValue());\n+    }", "originalCommit": "7e258fbe3783684db657d1a998fc24a181a80b55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzkyNzIzMQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r457927231", "bodyText": "Fixed", "author": "max904-github", "createdAt": "2020-07-21T08:29:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc1NDcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc2MzI1Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r454763256", "bodyText": "Could you use JUnit 5 and ServerExtension? We prefer JUnit 5 for the new test code.\nhttps://armeria.dev/community/developer-guide#use-junit-5-instead-of-junit-4-for-testing", "author": "ikhoon", "createdAt": "2020-07-15T03:07:41Z", "path": "oauth2/src/test/java/com/linecorp/armeria/client/auth/oauth2/OAuth2ClientCredentialsGrantTest.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.stream.Collectors;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.auth.oauth2.InvalidClientException;\n+import com.linecorp.armeria.common.auth.oauth2.MockOAuth2AccessToken;\n+import com.linecorp.armeria.common.auth.oauth2.MockOAuth2ClientCredentialsService;\n+import com.linecorp.armeria.common.auth.oauth2.MockOAuth2IntrospectionService;\n+import com.linecorp.armeria.server.AbstractHttpService;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.auth.oauth2.OAuth2TokenIntrospectionAuthorizer;\n+import com.linecorp.armeria.testing.junit4.server.ServerRule;\n+\n+public class OAuth2ClientCredentialsGrantTest {\n+\n+    static final String CLIENT_CREDENTIALS = \"dGVzdF9jbGllbnQ6Y2xpZW50X3NlY3JldA==\"; //test_client:client_secret\n+    static final String SERVER_CREDENTIALS = \"dGVzdF9zZXJ2ZXI6c2VydmVyX3NlY3JldA==\"; //test_server:server_secret\n+\n+    static final MockOAuth2AccessToken TOKEN =\n+        MockOAuth2AccessToken.generate(\"test_client\", null, Duration.ofHours(3L),\n+                                       ImmutableMap.of(\"extension_field\", \"twenty-seven\"), \"read\", \"write\");\n+\n+    static final HttpService SERVICE = new AbstractHttpService() {\n+        @Override\n+        protected HttpResponse doGet(ServiceRequestContext ctx, HttpRequest req)\n+                throws Exception {\n+            return HttpResponse.of(HttpStatus.OK);\n+        }\n+    };\n+\n+    @Rule\n+    public ServerRule authServerRule = new ServerRule() {", "originalCommit": "7e258fbe3783684db657d1a998fc24a181a80b55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk5MTg5MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r457991890", "bodyText": "Migrated to ServerExtension and JUnit 5.", "author": "max904-github", "createdAt": "2020-07-21T10:20:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc2MzI1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc3MzM0MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r454773340", "bodyText": "OAuth2Client looks nice! However, it has to create WebClient every time for different resource owners. \ud83e\udd14\nHow about adding a new method such as signedRequest(HttpRequest) to OAuth2ClientCredentialsGrant? Then users can set an HttpRequest that has AUTHORIZATION header to the existing WebClient without creating a new one.\nclass OAuth2ClientCredentialsGrant {\n    CompletableFuture<HttpRequest> signedRequest(HttpRequest req) {\n        return getAccessToken().thenApply(accessToken -> {\n            return req.withHeaders(/* set AUTHORIZATION header */);\n        });\n    }\n}\n\nHttpRequest request = HttpRequest.of(HttpMethod.GET, \"/resource-read-write/\");\nCompletableFuture<HttpRequest> signedRequest = grant.signRequest(request);\nAggregatedHttpResponse response = \n        signedRequest.thenCompose(signed -> client.execute(signed).aggregate()).join();", "author": "ikhoon", "createdAt": "2020-07-15T03:48:22Z", "path": "oauth2/src/test/java/com/linecorp/armeria/client/auth/oauth2/OAuth2ClientCredentialsGrantTest.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.stream.Collectors;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.auth.oauth2.InvalidClientException;\n+import com.linecorp.armeria.common.auth.oauth2.MockOAuth2AccessToken;\n+import com.linecorp.armeria.common.auth.oauth2.MockOAuth2ClientCredentialsService;\n+import com.linecorp.armeria.common.auth.oauth2.MockOAuth2IntrospectionService;\n+import com.linecorp.armeria.server.AbstractHttpService;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.auth.oauth2.OAuth2TokenIntrospectionAuthorizer;\n+import com.linecorp.armeria.testing.junit4.server.ServerRule;\n+\n+public class OAuth2ClientCredentialsGrantTest {\n+\n+    static final String CLIENT_CREDENTIALS = \"dGVzdF9jbGllbnQ6Y2xpZW50X3NlY3JldA==\"; //test_client:client_secret\n+    static final String SERVER_CREDENTIALS = \"dGVzdF9zZXJ2ZXI6c2VydmVyX3NlY3JldA==\"; //test_server:server_secret\n+\n+    static final MockOAuth2AccessToken TOKEN =\n+        MockOAuth2AccessToken.generate(\"test_client\", null, Duration.ofHours(3L),\n+                                       ImmutableMap.of(\"extension_field\", \"twenty-seven\"), \"read\", \"write\");\n+\n+    static final HttpService SERVICE = new AbstractHttpService() {\n+        @Override\n+        protected HttpResponse doGet(ServiceRequestContext ctx, HttpRequest req)\n+                throws Exception {\n+            return HttpResponse.of(HttpStatus.OK);\n+        }\n+    };\n+\n+    @Rule\n+    public ServerRule authServerRule = new ServerRule() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.annotatedService(\"/token\", new MockOAuth2ClientCredentialsService()\n+                    .withAuthorizedClient(\"test_client\", \"client_secret\")\n+                    .withAuthorizedClient(\"test_server\", \"server_secret\")\n+                    .withClientToken(\"test_client\", TOKEN));\n+            sb.annotatedService(\"/introspect\", new MockOAuth2IntrospectionService()\n+                    .withAuthorizedClient(\"test_client\", \"client_secret\")\n+                    .withAuthorizedClient(\"test_server\", \"server_secret\")\n+                    .withClientToken(\"test_client\", TOKEN));\n+        }\n+    };\n+\n+    private final ServerRule resourceServerRule = new ServerRule(false) {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            final WebClient introspectClient = WebClient.of(authServerRule.httpUri());\n+            sb.service(\"/resource-read-write/\",\n+                       OAuth2TokenIntrospectionAuthorizer.builder(introspectClient, \"/introspect/token/\")\n+                                                         .realm(\"protected resource read-write\")\n+                                                         .accessTokenType(\"Bearer\")\n+                                                         .clientBasicAuthorization(() -> SERVER_CREDENTIALS)\n+                                                         .permittedScope(\"read\", \"write\")\n+                                                         .build().asAuthService(SERVICE));\n+            sb.service(\"/resource-read/\",\n+                       OAuth2TokenIntrospectionAuthorizer.builder(introspectClient, \"/introspect/token/\")\n+                                                         .realm(\"protected resource read\")\n+                                                         .accessTokenType(\"Bearer\")\n+                                                         .clientBasicAuthorization(() -> SERVER_CREDENTIALS)\n+                                                         .permittedScope(\"read\")\n+                                                         .build().asAuthService(SERVICE));\n+            sb.service(\"/resource-read-write-update/\",\n+                       OAuth2TokenIntrospectionAuthorizer.builder(introspectClient, \"/introspect/token/\")\n+                                                         .realm(\"protected resource read-write-update\")\n+                                                         .accessTokenType(\"Bearer\")\n+                                                         .clientBasicAuthorization(() -> SERVER_CREDENTIALS)\n+                                                         .permittedScope(\"read\", \"write\", \"update\")\n+                                                         .build().asAuthService(SERVICE));\n+        }\n+    };\n+\n+    @Test\n+    public void testOk() throws Exception {\n+        try (Server resourceServer = resourceServerRule.start()) {\n+\n+            final WebClient authClient = WebClient.of(authServerRule.httpUri());\n+            final OAuth2ClientCredentialsGrant grant = OAuth2ClientCredentialsGrant\n+                    .builder(authClient, \"/token/client/\")\n+                    .clientBasicAuthorization(() -> CLIENT_CREDENTIALS).build();\n+\n+            final WebClient client = WebClient.builder(resourceServerRule.httpUri())\n+                                              .decorator(OAuth2Client.newDecorator(grant))", "originalCommit": "7e258fbe3783684db657d1a998fc24a181a80b55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk3NDQyOQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r457974429", "bodyText": "Good idea! Added this as withAuthorization to OAuth2AuthorizationGrant interface and supplied with the unit testing.", "author": "max904-github", "createdAt": "2020-07-21T09:49:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc3MzM0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc3OTYzNw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r454779637", "bodyText": "Question: Is there a special reason that we call join() here? Shouldn't we return CompletableFuture<AccessTokenCapsule>?\nIIUC, tokenRef could be set by refreshAccessTokenAsync(token).whenComplete(...)", "author": "ikhoon", "createdAt": "2020-07-15T04:12:43Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractOAuth2AuthorizationGrant.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.auth.oauth2.AccessTokenCapsule;\n+import com.linecorp.armeria.common.auth.oauth2.InvalidClientException;\n+import com.linecorp.armeria.common.auth.oauth2.RefreshAccessTokenRequest;\n+import com.linecorp.armeria.common.auth.oauth2.TokenRequestException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedMediaTypeException;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * Base implementation of OAuth 2.0 Access Token Grant flow to obtain Access Token.\n+ * Implements Access Token loading, storing and refreshing.\n+ */\n+abstract class AbstractOAuth2AuthorizationGrant implements OAuth2AuthorizationGrant, AutoCloseable {\n+\n+    /**\n+     * Holds a reference to the access token capsule.\n+     */\n+    private final AtomicReference<AccessTokenCapsule> tokenRef;\n+\n+    /**\n+     * Executes obtain and refresh token operations serially on a separate thread.\n+     */\n+    private final ExecutorService serialExecutor;\n+\n+    private final RefreshAccessTokenRequest refreshRequest;\n+\n+    private final Duration refreshBefore;\n+\n+    @Nullable\n+    private final Supplier<AccessTokenCapsule> tokenSupplier;\n+    @Nullable\n+    private final Consumer<AccessTokenCapsule> tokenConsumer;\n+\n+    AbstractOAuth2AuthorizationGrant(RefreshAccessTokenRequest refreshRequest, Duration refreshBefore,\n+                                     @Nullable Supplier<AccessTokenCapsule> tokenSupplier,\n+                                     @Nullable Consumer<AccessTokenCapsule> tokenConsumer) {\n+        tokenRef = new AtomicReference<>();\n+        serialExecutor = Executors.newSingleThreadExecutor();\n+        this.refreshRequest = requireNonNull(refreshRequest, \"refreshRequest\");\n+        this.refreshBefore = requireNonNull(refreshBefore, \"refreshBefore\");\n+        this.tokenSupplier = tokenSupplier;\n+        this.tokenConsumer = tokenConsumer;\n+    }\n+\n+    /**\n+     * Obtains a new access token from the token end-point asynchronously.\n+     * @return A {@link CompletableFuture} carrying the requested {@link AccessTokenCapsule} or an exception,\n+     *         if the request failed.\n+     * @throws TokenRequestException when the endpoint returns {code HTTP 400 (Bad Request)} status and the\n+     *                               response payload contains the details of the error.\n+     * @throws InvalidClientException when the endpoint returns {@code HTTP 401 (Unauthorized)} status, which\n+     *                                typically indicates that client authentication failed (e.g.: unknown\n+     *                                client, no client authentication included, or unsupported authentication\n+     *                                method).\n+     * @throws UnsupportedMediaTypeException if the media type of the response does not match the expected\n+     *                                       (JSON).\n+     */\n+    protected abstract CompletableFuture<AccessTokenCapsule> obtainAccessTokenAsync(\n+            @Nullable AccessTokenCapsule token);\n+\n+    /**\n+     * Obtains a new access token from the token end-point.\n+     * Optionally stores access token to registered {@link Consumer} for longer term storage.\n+     * @return an {@link AccessTokenCapsule} that contains requested access token.\n+     * @throws TokenRequestException when the endpoint returns {code HTTP 400 (Bad Request)} status and the\n+     *                               response payload contains the details of the error.\n+     * @throws InvalidClientException when the endpoint returns {@code HTTP 401 (Unauthorized)} status, which\n+     *                                typically indicates that client authentication failed (e.g.: unknown\n+     *                                client, no client authentication included, or unsupported authentication\n+     *                                method).\n+     * @throws UnsupportedMediaTypeException if the media type of the response does not match the expected\n+     *                                       (JSON).\n+     */\n+    private AccessTokenCapsule obtainAccessToken() {\n+        final AccessTokenCapsule token = obtainAccessTokenAsync(null).join();\n+        tokenRef.set(token); // reset the token reference\n+        if (tokenConsumer != null) {\n+            tokenConsumer.accept(token); // store token to an optional storage (e.g. secret store)\n+        }\n+        return token;\n+    }\n+\n+    /**\n+     * Refreshes access token using refresh token provided with the previous access token response\n+     * asynchronously, otherwise, if no refresh token available, re-obtains a new access token from the token\n+     * end-point.\n+     * @return A {@link CompletableFuture} carrying the requested {@link AccessTokenCapsule} or an exception,\n+     *         if the request failed.\n+     * @throws TokenRequestException when the endpoint returns {code HTTP 400 (Bad Request)} status and the\n+     *                               response payload contains the details of the error.\n+     * @throws InvalidClientException when the endpoint returns {@code HTTP 401 (Unauthorized)} status, which\n+     *                                typically indicates that client authentication failed (e.g.: unknown\n+     *                                client, no client authentication included, or unsupported authentication\n+     *                                method).\n+     * @throws UnsupportedMediaTypeException if the media type of the response does not match the expected\n+     *                                       (JSON).\n+     */\n+    private CompletableFuture<AccessTokenCapsule> refreshAccessTokenAsync(AccessTokenCapsule token) {\n+        if (token.refreshToken() != null) {\n+            // try refreshing token if refresh token was previously provided\n+            return refreshRequest.make(token);\n+        }\n+        // try to re-obtain access token\n+        return obtainAccessTokenAsync(token);\n+    }\n+\n+    /**\n+     * Refreshes access token using refresh token provided with the previous access token response, otherwise,\n+     * if no refresh token available, re-obtains a new access token from the token end-point.\n+     * If the refresh token request fails with {@link TokenRequestException}, tries to re-obtains a new access\n+     * token from the token end-point.\n+     * Optionally stores access token to registered {@link Consumer} for longer term storage.\n+     * @return an {@link AccessTokenCapsule} that contains requested access token.\n+     * @throws TokenRequestException when the endpoint returns {code HTTP 400 (Bad Request)} status and the\n+     *                               response payload contains the details of the error.\n+     * @throws InvalidClientException when the endpoint returns {@code HTTP 401 (Unauthorized)} status, which\n+     *                                typically indicates that client authentication failed (e.g.: unknown\n+     *                                client, no client authentication included, or unsupported authentication\n+     *                                method).\n+     * @throws UnsupportedMediaTypeException if the media type of the response does not match the expected\n+     *                                       (JSON).\n+     */\n+    private AccessTokenCapsule refreshAccessToken(Instant instant) {\n+        // after acquiring the lock, re-check if it's a valid token\n+        final AccessTokenCapsule token = tokenRef.get();\n+        if (token.isValid(instant)) {\n+            // simply return a valid token\n+            return token;\n+        }\n+        // otherwise, refresh it\n+        AccessTokenCapsule refreshedToken;\n+        try {\n+            refreshedToken = refreshAccessTokenAsync(token).join();", "originalCommit": "7e258fbe3783684db657d1a998fc24a181a80b55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk5NjM5Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r457996396", "bodyText": "Yes, there is a special reason for synchronizing the request execution here.\nIn order to deal with concurrency issues, all token obtain and refresh requests have to be executed serially by a dedicated serialExecutor, which was introduced based on the previous @trustin comment. So the obtaining or refreshing of the access token is indeed happens asynchronously by the serialExecutor, but anything that happens during the refresh or obtain have to be serialized.", "author": "max904-github", "createdAt": "2020-07-21T10:28:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc3OTYzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk5NjYzNA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r457996634", "bodyText": "I've added a special test that tests the concurrency.", "author": "max904-github", "createdAt": "2020-07-21T10:29:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc3OTYzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIwNTUyOA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r459205528", "bodyText": "I think we can compose asynchronous functions using CompletableFuture.thenCompose and process it sequentially.\nCompletableFuture<OAuth2AccessToken> oAuth2AccessToken =\n    refreshAccessTokenAsync(token).thenCompose(this::obtainAccessTokenAsync);", "author": "ikhoon", "createdAt": "2020-07-23T04:14:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc3OTYzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI4OTM5OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r459289398", "bodyText": "Sorry, I might have confused you with my explanation. This is roughly how it was implemented earlier, but this may cause concurrency issues obtaining or refreshing access token. The problem is the following: getAccessToken() method should be done asynchronously, but every such call has to be done sequentially in order to avoid concurrency issues accessing the OAuth 2 endpoint (the client may only obtain access token once and refresh the token when the time comes). As a result, I've introduced single-thread executor that can serialize asynchronous access token requests.\nImagine, there are two client requests sent to the protected resource simultaneously. Each will trigger getAccessToken() executed concurrently. Now, since the relevant chunks of getAccessToken() will be executed serially by the executor, the first request will obtain the access token, while the second request will re-use it and will not re-obtain the access token.\nI've created OAuth2ClientCredentialsGrantTest#testConcurrent() to test such concurrent use case.", "author": "max904-github", "createdAt": "2020-07-23T08:25:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc3OTYzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM2NTExNw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r459365117", "bodyText": "I see, thanks for the kind explanation. Let me take a look OAuth2ClientCredentialsGrantTest#testConcurrent(). \ud83d\ude00", "author": "ikhoon", "createdAt": "2020-07-23T10:50:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc3OTYzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzMDY2MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r459430661", "bodyText": "If you consider that the two clients are sending getAccessToken() concurrently, how about using an async Caffeine cache?\nAsyncCache<GrantedOAuth2AccessToken, CompletableFuture<GrantedOAuth2AccessToken>>\n            accessTokenCache = Caffeine.newBuilder().maximumSize(1000 /* need sensible default */)\n                                       .buildAsync();\n\nCompletableFuture<GrantedOAuth2AccessToken> accessTokenFuture = \n        accessTokenCache\n            .asMap()\n            .computeIfAbsent(accessToken, key -> {\n                 // Only one thread will be executed to obtain access token\n                 // Note that we should not put `RequestContextAwareFuture` to the cache.\n                 // Need to peel `GrantedOAuth2AccessToken` \n                 // and save it with `CompletableFuture.completeValue(...)`\n                 return obtainAccessTokenAsync(key);\n            });\nI hope this workaround will solve the executor problem and concurrent issue.", "author": "ikhoon", "createdAt": "2020-07-23T13:01:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc3OTYzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5Mjg4Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r459492887", "bodyText": "Looked at ConcurrentMap#computeIfAbsent(). Here is its code:\n    default V computeIfAbsent(K key,\n            Function<? super K, ? extends V> mappingFunction) {\n        Objects.requireNonNull(mappingFunction);\n        V oldValue, newValue;\n        return ((oldValue = get(key)) == null\n                && (newValue = mappingFunction.apply(key)) != null\n                && (oldValue = putIfAbsent(key, newValue)) == null)\n            ? newValue\n            : oldValue;\n    }\n\nIt does not actually guaranty that the mappingFunction (obtainAccessTokenAsync) will be executed only once, which we need in this case. Instead, it guarantees that the new value will be put only once.\nBesides, even for a regular token read a hash lookup will take place, instead of simply reading a value. Therefore, we would add an additional cost to a frequent operation (of reading token) in sake of very rare operation (of obtaining new or refreshing token).\nIn any case, thanks for a suggestion, this was worth looking at.", "author": "max904-github", "createdAt": "2020-07-23T14:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc3OTYzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxNDM3NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r459814374", "bodyText": "It does not actually guaranty that the mappingFunction (obtainAccessTokenAsync) will be executed only once, which we need in this case. Instead, it guarantees that the new value will be put only once.\n\nYes, ConcurrentMap does not guarantee to execute only once but Caffeine cache uses ConcurrentHashMap internally.\nConcurrentHashMap override the implementation of ConcurrentMap.\n    public V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {\n               ...\n               Node<K,V> r = new ReservationNode<K,V>();\n                synchronized (r) {\n                    if (casTabAt(tab, i, null, r)) {\n                        binCount = 1;\n                        Node<K,V> node = null;\n                        try {\n                            if ((val = mappingFunction.apply(key)) != null)\n                                node = new Node<K,V>(h, key, val);\n                        } finally {\n                            setTabAt(tab, i, node);\n                        }\n                    }\n                }\n    }\nhttps://github.com/openjdk/jdk/blob/e427697e55c0d7b9089ba1f6ed24d4a313e9315b/src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java#L1703-L1713\nAfter looking at Caffeine cache API, I realized that we don't need to call asMap()\nIt could be used like:\nAsyncCache<GrantedOAuth2AccessToken, GrantedOAuth2AccessToken> cache = ...\nCompletableFuture<GrantedOAuth2AccessToken> future = cache.get(token, (key, executor) -> {\n    // internally call ConcurrentHashMap.computeIfAbsent(...)\n    return obtainAccessTokenAsync(key);\n});", "author": "ikhoon", "createdAt": "2020-07-24T01:37:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc3OTYzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc3NTY2Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r460775666", "bodyText": "Unfortunately, the AsyncCache does not use java.util.concurrent.ConcurrentHashMap#computeIfAbsent directly. Instead, it has its own com.github.benmanes.caffeine.cache.LocalCache#computeIfAbsent API and implementations like com.github.benmanes.caffeine.cache.BoundedLocalCache#computeIfAbsent. I did not perform and deep code analysis or conducted any hands-on testing, but as far as I can see, it only guarantees a consistency of the operation on LocalCache<K, CompletableFuture<V>>. Although the future instances will be obtained serially, it does not prevent two mappingFunctions to execute simultaneously, at least I don't see such mechanism. If you have better insight, please explain me how it's achieved.\nPlease also comment on the why with this Cache approach \"we would add an additional cost to a frequent operation (of reading token) in sake of very rare operation (of obtaining new or refreshing token)\". Cache lookup will have to be executed for each outgoing request vs simple AtomicReference#get(). For thousands of requests it could be significant cost.", "author": "max904-github", "createdAt": "2020-07-27T09:50:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc3OTYzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkzNDU1MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r460934551", "bodyText": "Unfortunately, the AsyncCache does not use java.util.concurrent.ConcurrentHashMap#computeIfAbsent directly. Instead, it has its own com.github.benmanes.caffeine.cache.LocalCache#computeIfAbsent API and implementations like com.github.benmanes.caffeine.cache.BoundedLocalCache#computeIfAbsent.\n\nBoundedLocalCache keeps its data on ConcurrentHashMap. You can easily check it by breaking point on the mappingFunction.\nhttps://github.com/ben-manes/caffeine/blob/master/caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java#L213\n\nCache approach \"we would add an additional cost to a frequent operation (of reading token) in sake of very rare operation (of obtaining new or refreshing token)\".\n\nThe reason why I suggested to use cache is:\n\nWe can remove the serial executor. It is hard to tune.\n\nIf AbstractOAuth2AuthorizationGrant has a static singleton executor, then it could have trouble with the scalability problem. Because the submitted tasks are blocking IO.\nIf AbstractOAuth2AuthorizationGrant has its own executor, users might not handle many resource owners\n\n\nArmeria is a non-blocking microservice framework. If it is possible, we don't have to block IO.\nThe verification logic on tokenRef is pretty difficult for me. I think we can hide the logic.\n\n\nCache lookup will have to be executed for each outgoing request vs simple AtomicReference#get(). For thousands of requests it could be significant cost.\n\nYes, that's true. Hash lookup operation is expensive that AtomicReference. However, I think the context switching cost is more expensive than them.", "author": "ikhoon", "createdAt": "2020-07-27T14:32:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc3OTYzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI2NDgxNg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r461264816", "bodyText": "Just to help clarify (regardless of your final decisions), Caffeine does perform the Map.compute calls atomically. In the case of computeIfAbsent it is actually a fast-path ConcurrentHashMap#get followed by a ConcurrentHashMap#compute if absent. This allows us to optimistically return a valid value cheaply, whereas ConcurrentHashMap#computeIfAbsent pessimistically locks which limits read concurrency. We fallback to a compute in order to handle cases like expired entries still in the map and similar caching details.\nThe AsyncCache will perform the map operations atomically, but only establishes the mapping for the future. The future is therefore independent, so atomically established and asynchronously completed. If the future fails (exceptionally or returns a null result), then a whenComplete handler will remove it from the cache.\nThe simplest way to think about Caffeine is as ConcurrentHashMap with extra features, which tries as much as possible to not deviate. There are very small differences, primarily that our #clear cannot block on unestablished mappings hidden by the iterator, whereas CHM does by traversing its internal table. But from atomicity standpoint we try hard to be correct while also performant. A Cache ~= CHM, AsyncCache ~= CHM<K, CF<V>>, and the asMap views let you use the collections api rather than a cache-oriented one.\nThe JavaDoc can always be improved, but does try to convey this atomicity. If you have any suggestions to clarify it, please let me know.\nAs an aside, I often use Failsafe for failure handling, retries, etc. You could avoid the join by using an async fallback so that the returned future encapsulates this error handling logic. That avoids surprises like starving FJP when its workers are all blocked waiting on tasks queued for execution. I am assuming that you'd prefer returning an async result rather than a synchronous API.\nvar fallback = Fallback.ofStage(this::obtainAccessToken)\n    .handleIf(e -> Exceptions.peel(e) instanceof TokenRequestException);\nreturn Failsafe.with(fallback).getAsync(() -> refreshAccessTokenAsync(token));", "author": "ben-manes", "createdAt": "2020-07-28T01:33:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc3OTYzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxMzkzMg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r461313932", "bodyText": "Thanks a lot for chiming in, @ben-manes!\n+1 for going full-async rather than using a dedicated executor.", "author": "trustin", "createdAt": "2020-07-28T04:42:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc3OTYzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1MzM0OQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r461453349", "bodyText": "Thank you @ben-manes for clarification!\nLet me comment on some points...\n\n\nThe AsyncCache will perform the map operations atomically, but only establishes the mapping for the future. The future is therefore independent, so atomically established and asynchronously completed.\n\n\nThis is actually the key part of the clarification in our context. And this is how I interpreted the AsyncCache code.\nIn our case the mapping function have to be executed serially, that's the only way to guarantee that Obtain or Refresh operation executed only once.\n\n\nArmeria is a non-blocking microservice framework. If it is possible, we don't have to block IO.\n\n\nI think I can understand that. That's why Obtain/Refresh token operation executed asynchronously by a different (executor) thread.\n\n\nThe verification logic on tokenRef is pretty difficult for me. I think we can hide the logic.\n\n\nApparently not behind the AsyncCache, as explained above.\nLet me summarize some concrete requirements so you can advise better:\n\ngetAccessToken() shall be asynchronous;\ngetAccessToken() shall be extremely cheap when the access token already issued;\nWhen the token not yet available or expired, Obtain or Refresh access token shall take place only once - no duplicate requests should be issued towards the OAuth 2 endpoint;\n\nI'm not saying the solution with the Executor is perfect, but at the moment I only see Queue or Executor approach can reasonably facilitate the three requirements above.\nIf you just don't like seeing such complexity inside the Grant, this can easily be achieved by extracting it into some more generic utility class.\n\n\nYes, that's true. Hash lookup operation is expensive that AtomicReference. However, I think the context switching cost is more expensive than them.\n\n\nNot sure I understand where the context switching takes place (as oppose to the hash lookup)? In regular case AtomicReference#get() is all we are going to have. Once in a while, on a rare occasion (either when there is no access token issued yet or when the access token to be renewed) the processing will take its turn through the serial executor. This minimizes the negative impact comparing to frequent hash lookup taking place for each request.\nFor the Obtain/Refresh operations context switching is unavoidable and must be facilitated by a different thread to avoid blocking the event loop. These operations may take significant time to complete (OAuth 2 endpoint will perform authentication, authorization, security artifact generation and provisioning, etc). Some operations may take much longer and involve continuous polling of the OAuth 2 token endpoint (e.g. Device Authorization Flow, especially authorization_pending and slow_down type of responses - this one I was planning to add next as the code already developed).", "author": "max904-github", "createdAt": "2020-07-28T09:39:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc3OTYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MDA5NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r454780094", "bodyText": "Do we have to create a new ExecutorService for every request? I think this might cause GC pressure in the high traffic. \ud83e\udd14", "author": "ikhoon", "createdAt": "2020-07-15T04:14:38Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractOAuth2AuthorizationGrant.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.auth.oauth2.AccessTokenCapsule;\n+import com.linecorp.armeria.common.auth.oauth2.InvalidClientException;\n+import com.linecorp.armeria.common.auth.oauth2.RefreshAccessTokenRequest;\n+import com.linecorp.armeria.common.auth.oauth2.TokenRequestException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedMediaTypeException;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * Base implementation of OAuth 2.0 Access Token Grant flow to obtain Access Token.\n+ * Implements Access Token loading, storing and refreshing.\n+ */\n+abstract class AbstractOAuth2AuthorizationGrant implements OAuth2AuthorizationGrant, AutoCloseable {\n+\n+    /**\n+     * Holds a reference to the access token capsule.\n+     */\n+    private final AtomicReference<AccessTokenCapsule> tokenRef;\n+\n+    /**\n+     * Executes obtain and refresh token operations serially on a separate thread.\n+     */\n+    private final ExecutorService serialExecutor;\n+\n+    private final RefreshAccessTokenRequest refreshRequest;\n+\n+    private final Duration refreshBefore;\n+\n+    @Nullable\n+    private final Supplier<AccessTokenCapsule> tokenSupplier;\n+    @Nullable\n+    private final Consumer<AccessTokenCapsule> tokenConsumer;\n+\n+    AbstractOAuth2AuthorizationGrant(RefreshAccessTokenRequest refreshRequest, Duration refreshBefore,\n+                                     @Nullable Supplier<AccessTokenCapsule> tokenSupplier,\n+                                     @Nullable Consumer<AccessTokenCapsule> tokenConsumer) {\n+        tokenRef = new AtomicReference<>();\n+        serialExecutor = Executors.newSingleThreadExecutor();", "originalCommit": "7e258fbe3783684db657d1a998fc24a181a80b55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MTI5NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r454781295", "bodyText": "I think expires is not that short. So RefreshAccessTokenRequest might not be used for short live requests.", "author": "ikhoon", "createdAt": "2020-07-15T04:19:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MDA5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODAwNjE4NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r458006185", "bodyText": "There will be a dedicated instance created per Grant. Typically there should be only few Grants created ever - it's a resource that corresponds to a given OAuth 2.0 authorization endpoint. Do you think there is still a risk?\nDo you mean refreshBefore? RefreshAccessTokenRequest is connected to token expiration period and determined by the OAuth 2 authorization endpoint. This validity period of the token is large enough and typically expressed in hours or days. There is not much sense to issue token just for a few seconds. Therefore, even default 1 minute to refresh before its expiry should be good enough for most of the cases. It can also be customized with the builder.\nAlso, the Grant lifespan should be independent from any client resource request.", "author": "max904-github", "createdAt": "2020-07-21T10:48:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MDA5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIwMzM0OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r459203348", "bodyText": "There will be a dedicated instance created per Grant. Typically there should be only few Grants created ever - it's a resource that corresponds to a given OAuth 2.0 authorization endpoint. Do you think there is still a risk?\n\nFrom the perspective of OAuth2ClientCredentialsGrant, that is true. Users do not need to create many OAuth2ClientCredentialsGrants.\nBut OAuth2ResourceOwnerPasswordCredentialsGrant also inherits AbstractOAuth2AuthorizationGrant too. What if users want to handle various resource owners?\nIIUC, based on the current implementation, they have to create OAuth2ResourceOwnerPasswordCredentialsGrant for every resource owner.", "author": "ikhoon", "createdAt": "2020-07-23T04:02:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MDA5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI5Mjk3MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r459292971", "bodyText": "Do you mean some multi-tenant use case, where the client serves multiple users? You are right, this will cause each Grant instance to have a dedicated single-thread executor. How do you suggest to make sharing of such thread/executor efficient and safe? I do not like an idea of injecting an external executor or a thread into the Grant. Should I simply make it static?", "author": "max904-github", "createdAt": "2020-07-23T08:31:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MDA5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5NTQwOQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r459495409", "bodyText": "Another alternative to static could be to wrap the Executor with some custom class (e.g. OAuth2AuthorizationGrantExecutor) and let it be injected via the GrantBuilder.", "author": "max904-github", "createdAt": "2020-07-23T14:32:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MDA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MTYzOQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r454781639", "bodyText": "Ditto, Couldn't we return CompletableFuture<AccessTokenCapsule>?", "author": "ikhoon", "createdAt": "2020-07-15T04:20:46Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractOAuth2AuthorizationGrant.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.auth.oauth2.AccessTokenCapsule;\n+import com.linecorp.armeria.common.auth.oauth2.InvalidClientException;\n+import com.linecorp.armeria.common.auth.oauth2.RefreshAccessTokenRequest;\n+import com.linecorp.armeria.common.auth.oauth2.TokenRequestException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedMediaTypeException;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * Base implementation of OAuth 2.0 Access Token Grant flow to obtain Access Token.\n+ * Implements Access Token loading, storing and refreshing.\n+ */\n+abstract class AbstractOAuth2AuthorizationGrant implements OAuth2AuthorizationGrant, AutoCloseable {\n+\n+    /**\n+     * Holds a reference to the access token capsule.\n+     */\n+    private final AtomicReference<AccessTokenCapsule> tokenRef;\n+\n+    /**\n+     * Executes obtain and refresh token operations serially on a separate thread.\n+     */\n+    private final ExecutorService serialExecutor;\n+\n+    private final RefreshAccessTokenRequest refreshRequest;\n+\n+    private final Duration refreshBefore;\n+\n+    @Nullable\n+    private final Supplier<AccessTokenCapsule> tokenSupplier;\n+    @Nullable\n+    private final Consumer<AccessTokenCapsule> tokenConsumer;\n+\n+    AbstractOAuth2AuthorizationGrant(RefreshAccessTokenRequest refreshRequest, Duration refreshBefore,\n+                                     @Nullable Supplier<AccessTokenCapsule> tokenSupplier,\n+                                     @Nullable Consumer<AccessTokenCapsule> tokenConsumer) {\n+        tokenRef = new AtomicReference<>();\n+        serialExecutor = Executors.newSingleThreadExecutor();\n+        this.refreshRequest = requireNonNull(refreshRequest, \"refreshRequest\");\n+        this.refreshBefore = requireNonNull(refreshBefore, \"refreshBefore\");\n+        this.tokenSupplier = tokenSupplier;\n+        this.tokenConsumer = tokenConsumer;\n+    }\n+\n+    /**\n+     * Obtains a new access token from the token end-point asynchronously.\n+     * @return A {@link CompletableFuture} carrying the requested {@link AccessTokenCapsule} or an exception,\n+     *         if the request failed.\n+     * @throws TokenRequestException when the endpoint returns {code HTTP 400 (Bad Request)} status and the\n+     *                               response payload contains the details of the error.\n+     * @throws InvalidClientException when the endpoint returns {@code HTTP 401 (Unauthorized)} status, which\n+     *                                typically indicates that client authentication failed (e.g.: unknown\n+     *                                client, no client authentication included, or unsupported authentication\n+     *                                method).\n+     * @throws UnsupportedMediaTypeException if the media type of the response does not match the expected\n+     *                                       (JSON).\n+     */\n+    protected abstract CompletableFuture<AccessTokenCapsule> obtainAccessTokenAsync(\n+            @Nullable AccessTokenCapsule token);\n+\n+    /**\n+     * Obtains a new access token from the token end-point.\n+     * Optionally stores access token to registered {@link Consumer} for longer term storage.\n+     * @return an {@link AccessTokenCapsule} that contains requested access token.\n+     * @throws TokenRequestException when the endpoint returns {code HTTP 400 (Bad Request)} status and the\n+     *                               response payload contains the details of the error.\n+     * @throws InvalidClientException when the endpoint returns {@code HTTP 401 (Unauthorized)} status, which\n+     *                                typically indicates that client authentication failed (e.g.: unknown\n+     *                                client, no client authentication included, or unsupported authentication\n+     *                                method).\n+     * @throws UnsupportedMediaTypeException if the media type of the response does not match the expected\n+     *                                       (JSON).\n+     */\n+    private AccessTokenCapsule obtainAccessToken() {\n+        final AccessTokenCapsule token = obtainAccessTokenAsync(null).join();", "originalCommit": "7e258fbe3783684db657d1a998fc24a181a80b55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODAwNjYxNQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r458006615", "bodyText": "See my previous comment on the subject...\nYes, there is a special reason for synchronizing the request execution here.\nIn order to deal with concurrency issues, all token obtain and refresh requests have to be executed serially by a dedicated serialExecutor, which was introduced based on the previous @trustin comment. So the obtaining or refreshing of the access token is indeed happens asynchronously by the serialExecutor, but anything that happens during the refresh or obtain have to be serialized.", "author": "max904-github", "createdAt": "2020-07-21T10:49:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MTYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA0ODM5MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r462048390", "bodyText": "Perhaps we could ensure serial execution without using a dedicated executor? For example, we could write some arbiter class that keeps the CompletableFuture of the previous task and add a callback to it to run the next task?", "author": "trustin", "createdAt": "2020-07-29T05:33:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MTYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwNTc3Mw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r462105773", "bodyText": "I'm sure we can. We just need to find the right way. Let me think about your suggestion. We would still need another thread (or executor) to execute Obtain/Refresh, right? Your original comment was to avoid blocking the event loop.", "author": "max904-github", "createdAt": "2020-07-29T07:49:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MTYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIwOTI4OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r462209288", "bodyText": "We would still need another thread (or executor) to execute Obtain/Refresh, right?\n\nIf what 'obtain/refresh' does is simply doing some HTTP calls and waiting for them, we do not need another thread or executor. That's the whole point of going asynchronous. \ud83d\ude09 Do you have any specific task that will block for a long time during obtain/refresh? I'd be happy to help you make them fully asynchronous.", "author": "trustin", "createdAt": "2020-07-29T10:48:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MTYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMwOTcwNQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r462309705", "bodyText": "If what 'obtain/refresh' does is simply doing some HTTP calls and waiting for them, we do not need another thread or executor. That's the whole point of going asynchronous. \ud83d\ude09 Do you have any specific task that will block for a long time during obtain/refresh? I'd be happy to help you make them fully asynchronous.\n\nYes, I do. I have pointed at such example in the other thread. Some grants may involve continuous polling of the OAuth 2 token endpoint. For example Device Authorization Flow which I have also implemented but did not include into this PR. This Flow assumes that the token obtained through a series or requests to which the OAuth 2 token endpoint responds with authorization_pending specifying some backoff or instructing to slow_down, and finally with the access token itself. This grant type is common to equipment activation (including consumer electronics), where the device starts the token Obtain cycle, while the authorization takes place independently by the user given the previously issued User Code. Many of us dealt with such grant type activating some apps on a smart TV, for instance.\n      +----------+                                +----------------+\n      |          |>---(A)-- Client Identifier --->|                |\n      |          |                                |                |\n      |          |<---(B)-- Device Code,      ---<|                |\n      |          |          User Code,            |                |\n      |  Device  |          & Verification URI    |                |\n      |  Client  |                                |                |\n      |          |  [polling]                     |                |\n      |          |>---(E)-- Device Code       --->|                |\n      |          |          & Client Identifier   |                |\n      |          |                                |  Authorization |\n      |          |<---(F)-- Access Token      ---<|     Server     |\n      +----------+   (& Optional Refresh Token)   |                |\n            v                                     |                |\n            :                                     |                |\n           (C) User Code & Verification URI       |                |\n            :                                     |                |\n            v                                     |                |\n      +----------+                                |                |\n      | End User |                                |                |\n      |    at    |<---(D)-- End user reviews  --->|                |\n      |  Browser |          authorization request |                |\n      +----------+                                +----------------+", "author": "max904-github", "createdAt": "2020-07-29T13:45:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MTYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA0MTU1OQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r463041559", "bodyText": "Yes, such periodic check with backoff can be done completely asynchronously. That's how we do in RetryingClient. Of course it's more complicated than synchronous flow, but we'd like to make sure all this can be done in our event loop thread, so that a user doesn't have to manage another thread pool. How about focusing on making what's in this pull request asynchronous first? We could then discuss/cowork in more detail about how to make the second part asynchronous.", "author": "trustin", "createdAt": "2020-07-30T14:33:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MTYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQzOTI1OQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r464439259", "bodyText": "Made a refactoring for this. Please see my other comment with a summary.", "author": "max904-github", "createdAt": "2020-08-03T14:11:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MTYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MjE2OQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r454782169", "bodyText": "nit: Could merge two lines.", "author": "ikhoon", "createdAt": "2020-07-15T04:22:32Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractOAuth2AuthorizationGrantBuilder.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.auth.oauth2.AbstractAccessTokenRequest;\n+import com.linecorp.armeria.common.auth.oauth2.AccessTokenCapsule;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.RefreshAccessTokenRequest;\n+\n+@SuppressWarnings(\"rawtypes\")\n+abstract class AbstractOAuth2AuthorizationGrantBuilder<T extends AbstractOAuth2AuthorizationGrantBuilder> {\n+\n+    /**\n+     * A period when the token should be refreshed proactively prior to its expiry.\n+     */\n+    private static final Duration DEFAULT_REFRESH_BEFORE = Duration.ofMinutes(1L); // 1 minute\n+\n+    private final WebClient accessTokenEndpoint;\n+    private final String accessTokenEndpointPath;\n+\n+    @Nullable\n+    private ClientAuthorization clientAuthorization;\n+\n+    private Duration refreshBefore = DEFAULT_REFRESH_BEFORE;\n+\n+    @Nullable\n+    private Supplier<AccessTokenCapsule> tokenSupplier;\n+\n+    @Nullable\n+    private Consumer<AccessTokenCapsule> tokenConsumer;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Access Token request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a>.\n+     *\n+     * @param accessTokenEndpoint A {@link WebClient} to facilitate an Access Token request. Must correspond to\n+     *                            the Access Token endpoint of the OAuth 2 system.\n+     * @param accessTokenEndpointPath A URI path that corresponds to the Access Token endpoint of the\n+     *                                OAuth 2 system.\n+     */\n+    AbstractOAuth2AuthorizationGrantBuilder(WebClient accessTokenEndpoint, String accessTokenEndpointPath) {\n+        this.accessTokenEndpoint = requireNonNull(accessTokenEndpoint, \"accessTokenEndpoint\");\n+        this.accessTokenEndpointPath = requireNonNull(accessTokenEndpointPath, \"accessTokenEndpointPath\");\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientAuthorization(\n+            Supplier<String> authorizationSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofAuthorization(authorizationSupplier, authorizationType);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientBasicAuthorization(\n+            Supplier<String> authorizationSupplier) {", "originalCommit": "7e258fbe3783684db657d1a998fc24a181a80b55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzkyODQ4Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r457928487", "bodyText": "Fixed", "author": "max904-github", "createdAt": "2020-07-21T08:31:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MjE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MjQ0MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r454782441", "bodyText": "nit: Could merge two lines.", "author": "ikhoon", "createdAt": "2020-07-15T04:23:39Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractOAuth2AuthorizationGrantBuilder.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.auth.oauth2.AbstractAccessTokenRequest;\n+import com.linecorp.armeria.common.auth.oauth2.AccessTokenCapsule;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.RefreshAccessTokenRequest;\n+\n+@SuppressWarnings(\"rawtypes\")\n+abstract class AbstractOAuth2AuthorizationGrantBuilder<T extends AbstractOAuth2AuthorizationGrantBuilder> {\n+\n+    /**\n+     * A period when the token should be refreshed proactively prior to its expiry.\n+     */\n+    private static final Duration DEFAULT_REFRESH_BEFORE = Duration.ofMinutes(1L); // 1 minute\n+\n+    private final WebClient accessTokenEndpoint;\n+    private final String accessTokenEndpointPath;\n+\n+    @Nullable\n+    private ClientAuthorization clientAuthorization;\n+\n+    private Duration refreshBefore = DEFAULT_REFRESH_BEFORE;\n+\n+    @Nullable\n+    private Supplier<AccessTokenCapsule> tokenSupplier;\n+\n+    @Nullable\n+    private Consumer<AccessTokenCapsule> tokenConsumer;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Access Token request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a>.\n+     *\n+     * @param accessTokenEndpoint A {@link WebClient} to facilitate an Access Token request. Must correspond to\n+     *                            the Access Token endpoint of the OAuth 2 system.\n+     * @param accessTokenEndpointPath A URI path that corresponds to the Access Token endpoint of the\n+     *                                OAuth 2 system.\n+     */\n+    AbstractOAuth2AuthorizationGrantBuilder(WebClient accessTokenEndpoint, String accessTokenEndpointPath) {\n+        this.accessTokenEndpoint = requireNonNull(accessTokenEndpoint, \"accessTokenEndpoint\");\n+        this.accessTokenEndpointPath = requireNonNull(accessTokenEndpointPath, \"accessTokenEndpointPath\");\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientAuthorization(\n+            Supplier<String> authorizationSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofAuthorization(authorizationSupplier, authorizationType);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientBasicAuthorization(\n+            Supplier<String> authorizationSupplier) {\n+        clientAuthorization = ClientAuthorization.ofBasicAuthorization(authorizationSupplier);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientCredentials(\n+            Supplier<? extends Map.Entry<String, String>> credentialsSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofCredentials(credentialsSupplier, authorizationType);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientCredentials(\n+            Supplier<? extends Map.Entry<String, String>> credentialsSupplier) {\n+        clientAuthorization = ClientAuthorization.ofCredentials(credentialsSupplier);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * A period when the token should be refreshed proactively prior to its expiry.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T refreshBefore(Duration refreshBefore) {\n+        this.refreshBefore = requireNonNull(refreshBefore, \"refreshBefore\");\n+        return (T) this;\n+    }\n+\n+    public final Duration refreshBefore() {\n+        return refreshBefore;\n+    }\n+\n+    @Nullable\n+    public final Supplier<AccessTokenCapsule> tokenSupplier() {\n+        return tokenSupplier;\n+    }\n+\n+    /**\n+     * A {@link Supplier} to load Access Token from, to be able to restore the previous session. OPTIONAL.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T tokenSupplier(\n+            Supplier<AccessTokenCapsule> tokenSupplier) {", "originalCommit": "7e258fbe3783684db657d1a998fc24a181a80b55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzkyODU0Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r457928546", "bodyText": "Fixed", "author": "max904-github", "createdAt": "2020-07-21T08:31:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MjQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MjQ3Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r454782476", "bodyText": "Could merge two lines.\nGlobal comment Consumer<? super AccessTokenCapsule> and Supplier<? extends AccessTokenCapsule>", "author": "ikhoon", "createdAt": "2020-07-15T04:23:49Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractOAuth2AuthorizationGrantBuilder.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.auth.oauth2.AbstractAccessTokenRequest;\n+import com.linecorp.armeria.common.auth.oauth2.AccessTokenCapsule;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.RefreshAccessTokenRequest;\n+\n+@SuppressWarnings(\"rawtypes\")\n+abstract class AbstractOAuth2AuthorizationGrantBuilder<T extends AbstractOAuth2AuthorizationGrantBuilder> {\n+\n+    /**\n+     * A period when the token should be refreshed proactively prior to its expiry.\n+     */\n+    private static final Duration DEFAULT_REFRESH_BEFORE = Duration.ofMinutes(1L); // 1 minute\n+\n+    private final WebClient accessTokenEndpoint;\n+    private final String accessTokenEndpointPath;\n+\n+    @Nullable\n+    private ClientAuthorization clientAuthorization;\n+\n+    private Duration refreshBefore = DEFAULT_REFRESH_BEFORE;\n+\n+    @Nullable\n+    private Supplier<AccessTokenCapsule> tokenSupplier;\n+\n+    @Nullable\n+    private Consumer<AccessTokenCapsule> tokenConsumer;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Access Token request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a>.\n+     *\n+     * @param accessTokenEndpoint A {@link WebClient} to facilitate an Access Token request. Must correspond to\n+     *                            the Access Token endpoint of the OAuth 2 system.\n+     * @param accessTokenEndpointPath A URI path that corresponds to the Access Token endpoint of the\n+     *                                OAuth 2 system.\n+     */\n+    AbstractOAuth2AuthorizationGrantBuilder(WebClient accessTokenEndpoint, String accessTokenEndpointPath) {\n+        this.accessTokenEndpoint = requireNonNull(accessTokenEndpoint, \"accessTokenEndpoint\");\n+        this.accessTokenEndpointPath = requireNonNull(accessTokenEndpointPath, \"accessTokenEndpointPath\");\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientAuthorization(\n+            Supplier<String> authorizationSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofAuthorization(authorizationSupplier, authorizationType);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientBasicAuthorization(\n+            Supplier<String> authorizationSupplier) {\n+        clientAuthorization = ClientAuthorization.ofBasicAuthorization(authorizationSupplier);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientCredentials(\n+            Supplier<? extends Map.Entry<String, String>> credentialsSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofCredentials(credentialsSupplier, authorizationType);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientCredentials(\n+            Supplier<? extends Map.Entry<String, String>> credentialsSupplier) {\n+        clientAuthorization = ClientAuthorization.ofCredentials(credentialsSupplier);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * A period when the token should be refreshed proactively prior to its expiry.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T refreshBefore(Duration refreshBefore) {\n+        this.refreshBefore = requireNonNull(refreshBefore, \"refreshBefore\");\n+        return (T) this;\n+    }\n+\n+    public final Duration refreshBefore() {\n+        return refreshBefore;\n+    }\n+\n+    @Nullable\n+    public final Supplier<AccessTokenCapsule> tokenSupplier() {\n+        return tokenSupplier;\n+    }\n+\n+    /**\n+     * A {@link Supplier} to load Access Token from, to be able to restore the previous session. OPTIONAL.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T tokenSupplier(\n+            Supplier<AccessTokenCapsule> tokenSupplier) {\n+        this.tokenSupplier = requireNonNull(tokenSupplier, \"tokenSupplier\");\n+        return (T) this;\n+    }\n+\n+    @Nullable\n+    public final Consumer<AccessTokenCapsule> tokenConsumer() {\n+        return tokenConsumer;\n+    }\n+\n+    /**\n+     * A {@link Consumer} to store Access Token to, to be able restore the previous session. OPTIONAL.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T tokenConsumer(\n+            Consumer<AccessTokenCapsule> tokenConsumer) {", "originalCommit": "7e258fbe3783684db657d1a998fc24a181a80b55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzkzMjQxNQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r457932415", "bodyText": "Fixed", "author": "max904-github", "createdAt": "2020-07-21T08:38:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MjQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MzUyNA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r454783524", "bodyText": "Do we need to catch an Exception?\nI think we can just return unwrap().execute(ctx, newReq) without try...catch", "author": "ikhoon", "createdAt": "2020-07-15T04:27:47Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/OAuth2Client.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.function.Function;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.HttpClient;\n+import com.linecorp.armeria.client.SimpleDecoratingHttpClient;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * Decorates a {@link HttpClient} with an OAuth 2.0 Authorization Grant flow.\n+ */\n+public class OAuth2Client extends SimpleDecoratingHttpClient {\n+\n+    /**\n+     * Creates a new {@link HttpClient} decorator that handles OAuth 2.0 Authorization Grant flow.\n+     * @param authorizationGrant An {@link OAuth2AuthorizationGrant} implementing specific\n+     *                           OAuth 2.0 Authorization Grant flow.\n+     */\n+    public static Function<? super HttpClient, OAuth2Client> newDecorator(\n+            OAuth2AuthorizationGrant authorizationGrant) {\n+        return delegate -> new OAuth2Client(delegate, authorizationGrant);\n+    }\n+\n+    private final OAuth2AuthorizationGrant authorizationGrant;\n+\n+    /**\n+     * Creates a new instance that decorates the specified {@link HttpClient} with\n+     * an OAuth 2.0 Authorization Grant flow.\n+     */\n+    OAuth2Client(HttpClient delegate, OAuth2AuthorizationGrant authorizationGrant) {\n+        super(delegate);\n+        this.authorizationGrant = requireNonNull(authorizationGrant, \"authorizationGrant\");\n+    }\n+\n+    @Override\n+    public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Exception {\n+        return HttpResponse.from(authorizationGrant.getAccessToken().thenApply(accessToken -> {\n+            // Create a new request with an additional 'Authorization' header\n+            final HttpRequest newReq =\n+                req.withHeaders(req.headers().toBuilder()\n+                                   .set(HttpHeaderNames.AUTHORIZATION, accessToken.authorization())\n+                                   .build());\n+            // Update the ctx.request\n+            ctx.updateRequest(newReq);\n+            try {\n+                return unwrap().execute(ctx, newReq);\n+            } catch (Exception e) {\n+                return Exceptions.throwUnsafely(Exceptions.peel(e));\n+            }", "originalCommit": "7e258fbe3783684db657d1a998fc24a181a80b55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk0MDM4NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r457940385", "bodyText": "Unfortunately, unwrap().execute(ctx, newReq) executed within lambda expression and has to be handled. The code won't compile if I remove try...catch.", "author": "max904-github", "createdAt": "2020-07-21T08:51:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MzUyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIwODU5NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r459208594", "bodyText": "I see!", "author": "ikhoon", "createdAt": "2020-07-23T04:29:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MzUyNA=="}], "type": "inlineReview"}, {"oid": "44ac8f0b4e478dad703a33614736f8e561c22b09", "url": "https://github.com/line/armeria/commit/44ac8f0b4e478dad703a33614736f8e561c22b09", "message": "- incorporated review comments by @ikhoon", "committedDate": "2020-07-21T11:01:36Z", "type": "commit"}, {"oid": "71764df4cfc611e905efe7f57e8b3418237f0808", "url": "https://github.com/line/armeria/commit/71764df4cfc611e905efe7f57e8b3418237f0808", "message": "- renamed AccessTokenCapsule to OAuth2AccessToken\n- renamed TokenDescriptor to OAuth2TokenDescriptor", "committedDate": "2020-07-21T11:12:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUyNDYyMw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r458524623", "bodyText": "I realized that we already have a class named OAuth2Token at com.linecorp.armeria.common.auth. How about OAuth2AccessTokenResponse?", "author": "trustin", "createdAt": "2020-07-22T04:18:53Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/OAuth2AccessToken.java", "diffHunk": "@@ -0,0 +1,407 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static java.time.format.DateTimeFormatter.ISO_INSTANT;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+/**\n+ * Defines a structure of the Access Token Response, as per\n+ * <a href=\"https://tools.ietf.org/html/rfc6749#section-5.1\">[RFC6749], Section 5.1</a>.\n+ */\n+public class OAuth2AccessToken implements Serializable {", "originalCommit": "71764df4cfc611e905efe7f57e8b3418237f0808", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYxODc0MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r458618741", "bodyText": "I don't like the name Response. It implies something ephemeral. The name should imply that this object contains the Access Token.", "author": "max904-github", "createdAt": "2020-07-22T08:19:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUyNDYyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTMwODA1NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r459308054", "bodyText": "What about OAuth2AccessTokenRecord or, as per you other suggestion, GrantedOAuth2AccessToken?", "author": "max904-github", "createdAt": "2020-07-23T08:58:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUyNDYyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTMxMDYxNQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r459310615", "bodyText": "GrantedOAuth2AccessToken or GrantedOAuth2Token? I wonder if we can drop Access here since a token usually means an access token. I'm not an expert on this topic, so it's your call.", "author": "trustin", "createdAt": "2020-07-23T09:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUyNDYyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTMyNDMyNQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r459324325", "bodyText": "No, we should not drop Access for two reasons:\n\nThis object represents exactly the issued Access Token (as per RFC6749, Section 5.1).\nThere are common Token operations that apply to different type of tokens, like Access Token or Refresh Token. For instance, OAuth2TokenDescriptor or TokenRevocationRequest may apply to either Access or Refresh tokens.\n\nI'll go ahead and rename it to GrantedOAuth2AccessToken then.", "author": "max904-github", "createdAt": "2020-07-23T09:29:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUyNDYyMw=="}], "type": "inlineReview"}, {"oid": "ed953b11229b23d72d7156c62d2a91826db4a702", "url": "https://github.com/line/armeria/commit/ed953b11229b23d72d7156c62d2a91826db4a702", "message": "- renamed AbstractAuthorizationRequest to AbstractOAuth2Request\n- minor refactoring of AbstractOAuth2Request", "committedDate": "2020-07-22T10:45:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIwNzY3Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r459207676", "bodyText": "nit: Could you use 4 spaces for indentation?", "author": "ikhoon", "createdAt": "2020-07-23T04:24:32Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/ClientAuthorization.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+\n+/**\n+ * Provides client authorization for the OAuth 2.0 requests,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+ * For example:\n+ * <pre>{@code\n+ * Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3\n+ * }</pre>\n+ * Fetches authorization source from the designated authorization or credentials supplier, which\n+ * might be facilitated by a secure Secret provider. Will fetch the authorization source for each\n+ * request. Therefore the designated supplier must cache the value in order to avoid unnecessary\n+ * network hops.\n+ * The authorization source might either provide complete authorization token or client credentials.\n+ */\n+public final class ClientAuthorization {\n+\n+  private static final String DEFAULT_AUTHORIZATION_TYPE = \"Basic\";", "originalCommit": "ed953b11229b23d72d7156c62d2a91826db4a702", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI5NDI4OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r459294288", "bodyText": "Fixed", "author": "max904-github", "createdAt": "2020-07-23T08:34:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIwNzY3Ng=="}], "type": "inlineReview"}, {"oid": "ba6f23bd28e4660016609fddc85dc13f0c2b845e", "url": "https://github.com/line/armeria/commit/ba6f23bd28e4660016609fddc85dc13f0c2b845e", "message": "- moved RefreshAccessTokenRequest, ClientCredentialsTokenRequest, ResourceOwnerPasswordCredentialsTokenRequest and AbstractAccessTokenRequest to the client package.\n- moved TokenIntrospectionRequest to the server package.\n- fixed indentation at ClientAuthorization.", "committedDate": "2020-07-23T09:04:15Z", "type": "commit"}, {"oid": "b7b8ccb65dad74e731cf206dde240eb0d9e6bf5b", "url": "https://github.com/line/armeria/commit/b7b8ccb65dad74e731cf206dde240eb0d9e6bf5b", "message": "- renamed OAuth2AccessToken -> GrantedOAuth2AccessToken.", "committedDate": "2020-07-23T09:57:53Z", "type": "commit"}, {"oid": "aaa285b1122f1a4016e22f556f332910279fae73", "url": "https://github.com/line/armeria/commit/aaa285b1122f1a4016e22f556f332910279fae73", "message": "- introduced TokenLifecycleManager to abstract token lifecycle management out of OAuth2AuthorizationGrant;\n- introduced SerialFuture execute asynchronous actions (Callable<CompletionStage<T>>) serially;\n- added optional Executor to AbstractOAuth2AuthorizationGrant and AbstractOAuth2AuthorizationGrantBuilder to support asynchronous execution by a dedicated thread pool;", "committedDate": "2020-08-03T14:02:10Z", "type": "commit"}, {"oid": "e2eef13ef36d705634355e43cb7c3123382f44bd", "url": "https://github.com/line/armeria/commit/e2eef13ef36d705634355e43cb7c3123382f44bd", "message": "- enhanced SerialFutureTest;", "committedDate": "2020-08-04T09:30:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2NzQ0MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469067441", "bodyText": "Is it possible to use QueryParams instead of Map<String, String> here?", "author": "trustin", "createdAt": "2020-08-12T07:42:46Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/AbstractOAuth2Request.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n+\n+/**\n+ * A common abstraction for the requests implementing various OAuth 2.0 request/response flows,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a> and other relevant specifications.\n+ * @param <T> the type of the authorization result.\n+ */\n+public abstract class AbstractOAuth2Request<T> {\n+\n+    private final WebClient endpoint;\n+    private final String endpointPath;\n+    @Nullable\n+    private final ClientAuthorization clientAuthorization;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Authorization request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a> and other relevant specifications.\n+     *\n+     * @param endpoint A {@link WebClient} to facilitate the Authorization requests. Must\n+     *                 correspond to the required Authorization endpoint of the OAuth 2 system.\n+     * @param endpointPath A URI path that corresponds to the Authorization endpoint of the\n+     *                     OAuth 2 system.\n+     * @param clientAuthorization Provides client authorization for the OAuth requests,\n+     *                            as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     */\n+    protected AbstractOAuth2Request(WebClient endpoint, String endpointPath,\n+                                    @Nullable ClientAuthorization clientAuthorization) {\n+        this.endpoint = Objects.requireNonNull(endpoint, \"endpoint\");\n+        this.endpointPath = Objects.requireNonNull(endpointPath, \"endpointPath\");\n+        this.clientAuthorization = clientAuthorization; // optional\n+    }\n+\n+    /**\n+     * Returns the {@link WebClient} of the authorization endpoint.\n+     */\n+    protected WebClient endpoint() {\n+        return endpoint;\n+    }\n+\n+    /**\n+     * Returns the authorization endpoint path.\n+     */\n+    protected String endpointPath() {\n+        return endpointPath;\n+    }\n+\n+    /**\n+     * Returns the client authorization object.\n+     */\n+    @Nullable\n+    protected ClientAuthorization clientAuthorization() {\n+        return clientAuthorization;\n+    }\n+\n+    /**\n+     * Extracts data from OK response and converts it to the target type {@code T}.\n+     */\n+    protected abstract T extractOkResults(AggregatedHttpResponse response, Map<String, String> requestData);\n+\n+    /**\n+     * Returns the value for the {@link HttpHeaderNames#AUTHORIZATION}.\n+     */\n+    @Nullable\n+    protected String authorizationHeaderValue() {\n+        return clientAuthorization == null ? null : clientAuthorization.authorizationHeaderValue();\n+    }\n+\n+    /**\n+     * Sets client credentials as form data parameters,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     */\n+    protected void setCredentialsAsBodyParameters(QueryParamsBuilder formBuilder) {\n+        if (clientAuthorization != null) {\n+            clientAuthorization.setCredentialsAsBodyParameters(formBuilder);\n+        }\n+    }\n+\n+    /**\n+     * Makes a request to the authorization endpoint using supplied {@code requestForm} parameters and converts\n+     * the result to the given type {@code T}.\n+     */\n+    protected CompletableFuture<T> executeWithParameters(LinkedHashMap<String, String> requestFormData) {", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMyMDI3MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471320270", "bodyText": "Fixed", "author": "max904-github", "createdAt": "2020-08-17T08:24:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2NzQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2ODA1Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469068056", "bodyText": "Ditto - could use QueryParams?", "author": "trustin", "createdAt": "2020-08-12T07:43:53Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/AbstractOAuth2Request.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n+\n+/**\n+ * A common abstraction for the requests implementing various OAuth 2.0 request/response flows,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a> and other relevant specifications.\n+ * @param <T> the type of the authorization result.\n+ */\n+public abstract class AbstractOAuth2Request<T> {\n+\n+    private final WebClient endpoint;\n+    private final String endpointPath;\n+    @Nullable\n+    private final ClientAuthorization clientAuthorization;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Authorization request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a> and other relevant specifications.\n+     *\n+     * @param endpoint A {@link WebClient} to facilitate the Authorization requests. Must\n+     *                 correspond to the required Authorization endpoint of the OAuth 2 system.\n+     * @param endpointPath A URI path that corresponds to the Authorization endpoint of the\n+     *                     OAuth 2 system.\n+     * @param clientAuthorization Provides client authorization for the OAuth requests,\n+     *                            as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     */\n+    protected AbstractOAuth2Request(WebClient endpoint, String endpointPath,\n+                                    @Nullable ClientAuthorization clientAuthorization) {\n+        this.endpoint = Objects.requireNonNull(endpoint, \"endpoint\");\n+        this.endpointPath = Objects.requireNonNull(endpointPath, \"endpointPath\");\n+        this.clientAuthorization = clientAuthorization; // optional\n+    }\n+\n+    /**\n+     * Returns the {@link WebClient} of the authorization endpoint.\n+     */\n+    protected WebClient endpoint() {\n+        return endpoint;\n+    }\n+\n+    /**\n+     * Returns the authorization endpoint path.\n+     */\n+    protected String endpointPath() {\n+        return endpointPath;\n+    }\n+\n+    /**\n+     * Returns the client authorization object.\n+     */\n+    @Nullable\n+    protected ClientAuthorization clientAuthorization() {\n+        return clientAuthorization;\n+    }\n+\n+    /**\n+     * Extracts data from OK response and converts it to the target type {@code T}.\n+     */\n+    protected abstract T extractOkResults(AggregatedHttpResponse response, Map<String, String> requestData);\n+\n+    /**\n+     * Returns the value for the {@link HttpHeaderNames#AUTHORIZATION}.\n+     */\n+    @Nullable\n+    protected String authorizationHeaderValue() {\n+        return clientAuthorization == null ? null : clientAuthorization.authorizationHeaderValue();\n+    }\n+\n+    /**\n+     * Sets client credentials as form data parameters,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     */\n+    protected void setCredentialsAsBodyParameters(QueryParamsBuilder formBuilder) {\n+        if (clientAuthorization != null) {\n+            clientAuthorization.setCredentialsAsBodyParameters(formBuilder);\n+        }\n+    }\n+\n+    /**\n+     * Makes a request to the authorization endpoint using supplied {@code requestForm} parameters and converts\n+     * the result to the given type {@code T}.\n+     */\n+    protected CompletableFuture<T> executeWithParameters(LinkedHashMap<String, String> requestFormData) {\n+        final Map<String, String> requestData = Collections.unmodifiableMap(requestFormData);\n+        final HttpResponse response = endpoint().execute(createHttpRequest(endpointPath, requestData));\n+        // when response aggregated, then extract the results...\n+        return response.aggregate().thenApply(r -> extractResults(r, Collections.unmodifiableMap(requestData)));\n+    }\n+\n+    /**\n+     * Produces {@link HttpRequest} based on this object.\n+     */\n+    private HttpRequest createHttpRequest(String endpointPath, Map<String, String> requestFormData) {\n+        final QueryParamsBuilder requestFormBuilder = QueryParams.builder();\n+        requestFormBuilder.add(requestFormData.entrySet());\n+\n+        final RequestHeadersBuilder headersBuilder =\n+                RequestHeaders.of(HttpMethod.POST, endpointPath).toBuilder();\n+        final String authorizationHeaderValue = authorizationHeaderValue();\n+        if (authorizationHeaderValue != null) {\n+            headersBuilder.add(HttpHeaderNames.AUTHORIZATION, authorizationHeaderValue);\n+        } else {\n+            setCredentialsAsBodyParameters(requestFormBuilder);\n+        }\n+        headersBuilder.add(HttpHeaderNames.CONTENT_TYPE, MediaType.FORM_DATA.toString());\n+\n+        return HttpRequest.of(headersBuilder.build(), HttpData.ofUtf8(requestFormBuilder.toQueryString()));\n+    }\n+\n+    /**\n+     * Extracts the result and convert it to the target type {@code T} or throw an error in case of an error\n+     * result.\n+     * @param response An {@link AggregatedHttpResponse} returned by the authorization endpoint.\n+     * @param requestData A {@link Map} that contains all the elements of the request form sent with the\n+     *                    request.\n+     * @throws TokenRequestException when the endpoint returns {code HTTP 400 (Bad Request)} status and the\n+     *                               response payload contains the details of the error.\n+     * @throws InvalidClientException when the endpoint returns {@code HTTP 401 (Unauthorized)} status, which\n+     *                                typically indicates that client authentication failed (e.g.: unknown\n+     *                                client, no client authentication included, or unsupported authentication\n+     *                                method).\n+     * @throws UnsupportedMediaTypeException if the media type of the response does not match the expected\n+     *                                       (JSON).\n+     */\n+    @Nullable\n+    protected T extractResults(AggregatedHttpResponse response, Map<String, String> requestData) {", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMyMDM1NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471320355", "bodyText": "Fixed", "author": "max904-github", "createdAt": "2020-08-17T08:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2ODA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4NzQ2NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469087465", "bodyText": "This is interesting. I was rather expecting something like:\nAuthService.builder()\n           .addOAuth2(OAuth2TokenIntrospectionAuthorizer.builder()....build())\n           .newDecorator(); // or .build(..);\nOne missing piece here is that you cannot specify the failure handler. To solve this problem, what do you think about adding some default methods to Authorizer? e.g.\npublic interface Authorizer<T> {\n    ...\n    @Nullable // null means 'use the default or what's specified in the builder.'\n    default AuthSuccessHandler successHandler() { return null; }\n    @Nullable // null means 'use the default or what's specified in the builder.'\n    default AuthFailureHandler failureHandler() { return null; }\n}\n.. so that you can specify the success/failure handler specific to OAuth2.", "author": "trustin", "createdAt": "2020-08-12T08:19:49Z", "path": "oauth2/src/main/java/com/linecorp/armeria/server/auth/oauth2/OAuth2TokenIntrospectionAuthorizer.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.cache.Cache;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.auth.OAuth2Token;\n+import com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.auth.AuthFailureHandler;\n+import com.linecorp.armeria.server.auth.AuthService;\n+import com.linecorp.armeria.server.auth.Authorizer;\n+\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Determines whether a given {@link OAuth2Token} is authorized for the service registered in using OAuth 2.0\n+ * Token Introspection. {@code ctx} can be used for storing authorization information about the request for use\n+ * in business logic.\n+ */\n+public class OAuth2TokenIntrospectionAuthorizer implements Authorizer<OAuth2Token> {\n+\n+    /**\n+     * Returns a newly created {@link OAuth2TokenIntrospectionAuthorizerBuilder}.\n+     *\n+     * @param introspectionEndpoint A {@link WebClient} to facilitate the Token Introspection request. Must\n+     *                              correspond to the Token Introspection endpoint of the OAuth 2.0 system.\n+     * @param introspectionEndpointPath A URI path that corresponds to the Token Introspection endpoint of the\n+     *                                  OAuth 2.0 system.\n+     */\n+    public static OAuth2TokenIntrospectionAuthorizerBuilder builder(WebClient introspectionEndpoint,\n+                                                                    String introspectionEndpointPath) {\n+        return new OAuth2TokenIntrospectionAuthorizerBuilder(introspectionEndpoint, introspectionEndpointPath);\n+    }\n+\n+    static final AttributeKey<Integer> ERROR_CODE = AttributeKey.valueOf(\"x-oauth2-error\");\n+    static final AttributeKey<String> ERROR_TYPE = AttributeKey.valueOf(\"x-oauth2-error-type\");\n+    static final String UNSUPPORTED_TOKEN_TYPE = \"unsupported_token_type\";\n+    static final String INVALID_TOKEN = \"invalid_token\";\n+    static final String INSUFFICIENT_SCOPE = \"insufficient_scope\";\n+\n+    private final Cache<String, OAuth2TokenDescriptor> tokenCache;\n+    private final Set<String> permittedScope;\n+    @Nullable\n+    private final String accessTokenType;\n+    @Nullable\n+    private final String realm;\n+    private final TokenIntrospectionRequest tokenIntrospectionRequest;\n+    private final AuthFailureHandler authFailureHandler;\n+\n+    OAuth2TokenIntrospectionAuthorizer(Cache<String, OAuth2TokenDescriptor> tokenCache,\n+                                       @Nullable String accessTokenType, @Nullable String realm,\n+                                       Set<String> permittedScope,\n+                                       TokenIntrospectionRequest tokenIntrospectionRequest) {\n+        this.tokenCache = requireNonNull(tokenCache, \"tokenCache\");\n+        this.accessTokenType = accessTokenType;\n+        this.realm = realm;\n+        this.permittedScope = requireNonNull(permittedScope, \"permittedScope\");\n+        this.tokenIntrospectionRequest =\n+                requireNonNull(tokenIntrospectionRequest, \"tokenIntrospectionRequest\");\n+        authFailureHandler =\n+                new OAuth2AuthorizationFailureHandler(accessTokenType, realm, String.join(\" \", permittedScope));\n+    }\n+\n+    /**\n+     * Creates a new {@link AuthService} that authorizes HTTP requests using OAuth 2.0 Token Introspection.\n+     */\n+    public AuthService asAuthService(HttpService delegate) {\n+        return AuthService.builder()\n+                          .addOAuth2(this)\n+                          .onFailure(authFailureHandler())\n+                          .build(delegate);\n+    }", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE5NzYzMg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r472197632", "bodyText": "Sorry, did not understand your proposal. What exactly am I missing?", "author": "max904-github", "createdAt": "2020-08-18T13:29:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4NzQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU4MzUzNA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r472583534", "bodyText": "I meant:\nA usual pattern for creating an AuthService with an Authorizer is to pass an Authorizer when building an AuthService with an AuthServiceBuilder. What's suggested here is the opposite; a user calls Authorizer.asAuthService(). Could we change this so it's consistent with others?", "author": "trustin", "createdAt": "2020-08-19T01:32:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4NzQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE0OTUyMQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r477149521", "bodyText": "As you pointed, the usual pattern does not allow configuring the failure processing bound to the authorization logic. That's why I had to do it this way.\nDo you suggest modifying com.linecorp.armeria.server.auth.Authorizer and com.linecorp.armeria.server.auth.AuthServiceBuilder to support success and failure handlers provided by the Authorizer?", "author": "max904-github", "createdAt": "2020-08-26T09:05:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4NzQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg0MzkwMg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r503843902", "bodyText": "Do you suggest modifying com.linecorp.armeria.server.auth.Authorizer and com.linecorp.armeria.server.auth.AuthServiceBuilder to support success and failure handlers provided by the Authorizer?\n\nExactly! (Sorry about a very late reply. \ud83d\ude4f Was busy joining a new company \ud83d\ude09)", "author": "trustin", "createdAt": "2020-10-13T10:32:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4NzQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1Mjc3OQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r504552779", "bodyText": "No problem. I will follow your proposal and push an update in the next few days.", "author": "max904-github", "createdAt": "2020-10-14T09:57:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4NzQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4Nzg3NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469087875", "bodyText": "With the change I suggested above, we will not need this method.", "author": "trustin", "createdAt": "2020-08-12T08:20:28Z", "path": "oauth2/src/main/java/com/linecorp/armeria/server/auth/oauth2/OAuth2TokenIntrospectionAuthorizer.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.cache.Cache;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.auth.OAuth2Token;\n+import com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.auth.AuthFailureHandler;\n+import com.linecorp.armeria.server.auth.AuthService;\n+import com.linecorp.armeria.server.auth.Authorizer;\n+\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Determines whether a given {@link OAuth2Token} is authorized for the service registered in using OAuth 2.0\n+ * Token Introspection. {@code ctx} can be used for storing authorization information about the request for use\n+ * in business logic.\n+ */\n+public class OAuth2TokenIntrospectionAuthorizer implements Authorizer<OAuth2Token> {\n+\n+    /**\n+     * Returns a newly created {@link OAuth2TokenIntrospectionAuthorizerBuilder}.\n+     *\n+     * @param introspectionEndpoint A {@link WebClient} to facilitate the Token Introspection request. Must\n+     *                              correspond to the Token Introspection endpoint of the OAuth 2.0 system.\n+     * @param introspectionEndpointPath A URI path that corresponds to the Token Introspection endpoint of the\n+     *                                  OAuth 2.0 system.\n+     */\n+    public static OAuth2TokenIntrospectionAuthorizerBuilder builder(WebClient introspectionEndpoint,\n+                                                                    String introspectionEndpointPath) {\n+        return new OAuth2TokenIntrospectionAuthorizerBuilder(introspectionEndpoint, introspectionEndpointPath);\n+    }\n+\n+    static final AttributeKey<Integer> ERROR_CODE = AttributeKey.valueOf(\"x-oauth2-error\");\n+    static final AttributeKey<String> ERROR_TYPE = AttributeKey.valueOf(\"x-oauth2-error-type\");\n+    static final String UNSUPPORTED_TOKEN_TYPE = \"unsupported_token_type\";\n+    static final String INVALID_TOKEN = \"invalid_token\";\n+    static final String INSUFFICIENT_SCOPE = \"insufficient_scope\";\n+\n+    private final Cache<String, OAuth2TokenDescriptor> tokenCache;\n+    private final Set<String> permittedScope;\n+    @Nullable\n+    private final String accessTokenType;\n+    @Nullable\n+    private final String realm;\n+    private final TokenIntrospectionRequest tokenIntrospectionRequest;\n+    private final AuthFailureHandler authFailureHandler;\n+\n+    OAuth2TokenIntrospectionAuthorizer(Cache<String, OAuth2TokenDescriptor> tokenCache,\n+                                       @Nullable String accessTokenType, @Nullable String realm,\n+                                       Set<String> permittedScope,\n+                                       TokenIntrospectionRequest tokenIntrospectionRequest) {\n+        this.tokenCache = requireNonNull(tokenCache, \"tokenCache\");\n+        this.accessTokenType = accessTokenType;\n+        this.realm = realm;\n+        this.permittedScope = requireNonNull(permittedScope, \"permittedScope\");\n+        this.tokenIntrospectionRequest =\n+                requireNonNull(tokenIntrospectionRequest, \"tokenIntrospectionRequest\");\n+        authFailureHandler =\n+                new OAuth2AuthorizationFailureHandler(accessTokenType, realm, String.join(\" \", permittedScope));\n+    }\n+\n+    /**\n+     * Creates a new {@link AuthService} that authorizes HTTP requests using OAuth 2.0 Token Introspection.\n+     */\n+    public AuthService asAuthService(HttpService delegate) {\n+        return AuthService.builder()\n+                          .addOAuth2(this)\n+                          .onFailure(authFailureHandler())\n+                          .build(delegate);\n+    }\n+\n+    /**\n+     * Creates a new {@link AuthService} that authorizes HTTP requests using OAuth 2.0 Token Introspection.\n+     * Returns this service as a decorator.\n+     */\n+    public Function<? super HttpService, ? extends HttpService> asDecorator() {\n+        return this::asAuthService;\n+    }", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzNjA4NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469236085", "bodyText": "We can drop protected if this class is package-local.", "author": "trustin", "createdAt": "2020-08-12T12:53:06Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractAccessTokenRequest.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken.SCOPE;\n+\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.auth.oauth2.AbstractOAuth2Request;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken;\n+\n+/**\n+ * A common abstraction for the requests implementing various Access Token request/response flows,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a>.\n+ */\n+abstract class AbstractAccessTokenRequest extends AbstractOAuth2Request<GrantedOAuth2AccessToken> {\n+\n+    protected static final String GRANT_TYPE = \"grant_type\";", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMyODEyMw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471328123", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-08-17T08:38:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzNjA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzNjQyMQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469236421", "bodyText": "We can drop protected if this class is package-local.", "author": "trustin", "createdAt": "2020-08-12T12:53:44Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractAccessTokenRequest.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken.SCOPE;\n+\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.auth.oauth2.AbstractOAuth2Request;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken;\n+\n+/**\n+ * A common abstraction for the requests implementing various Access Token request/response flows,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a>.\n+ */\n+abstract class AbstractAccessTokenRequest extends AbstractOAuth2Request<GrantedOAuth2AccessToken> {\n+\n+    protected static final String GRANT_TYPE = \"grant_type\";\n+\n+    /**\n+     * A common abstraction for the requests implementing various Access Token request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a>.\n+     *\n+     * @param accessTokenEndpoint A {@link WebClient} to facilitate an Access Token request. Must correspond to\n+     *                            the Access Token endpoint of the OAuth 2 system.\n+     * @param accessTokenEndpointPath A URI path that corresponds to the Access Token endpoint of the\n+     *                                OAuth 2 system.\n+     * @param clientAuthorization Provides client authorization for the OAuth requests,\n+     *                            as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     */\n+    protected AbstractAccessTokenRequest(WebClient accessTokenEndpoint, String accessTokenEndpointPath,", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMyODIwNA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471328204", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-08-17T08:39:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzNjQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzODEwMA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469238100", "bodyText": "Does it make sense to drop client from all client*() builder methods for brevity?", "author": "trustin", "createdAt": "2020-08-12T12:56:28Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractOAuth2AuthorizationGrantBuilder.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken;\n+\n+@SuppressWarnings(\"rawtypes\")\n+abstract class AbstractOAuth2AuthorizationGrantBuilder<T extends AbstractOAuth2AuthorizationGrantBuilder> {\n+\n+    /**\n+     * A period when the token should be refreshed proactively prior to its expiry.\n+     */\n+    private static final Duration DEFAULT_REFRESH_BEFORE = Duration.ofMinutes(1L); // 1 minute\n+\n+    private final WebClient accessTokenEndpoint;\n+    private final String accessTokenEndpointPath;\n+\n+    @Nullable\n+    private ClientAuthorization clientAuthorization;\n+\n+    private Duration refreshBefore = DEFAULT_REFRESH_BEFORE;\n+\n+    @Nullable\n+    private Supplier<? extends GrantedOAuth2AccessToken> tokenSupplier;\n+\n+    @Nullable\n+    private Consumer<? super GrantedOAuth2AccessToken> tokenConsumer;\n+\n+    @Nullable\n+    private Executor executor;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Access Token request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a>.\n+     *\n+     * @param accessTokenEndpoint A {@link WebClient} to facilitate an Access Token request. Must correspond to\n+     *                            the Access Token endpoint of the OAuth 2 system.\n+     * @param accessTokenEndpointPath A URI path that corresponds to the Access Token endpoint of the\n+     *                                OAuth 2 system.\n+     */\n+    AbstractOAuth2AuthorizationGrantBuilder(WebClient accessTokenEndpoint, String accessTokenEndpointPath) {\n+        this.accessTokenEndpoint = requireNonNull(accessTokenEndpoint, \"accessTokenEndpoint\");\n+        this.accessTokenEndpointPath = requireNonNull(accessTokenEndpointPath, \"accessTokenEndpointPath\");\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientAuthorization(\n+            Supplier<String> authorizationSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofAuthorization(authorizationSupplier, authorizationType);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientBasicAuthorization(Supplier<String> authorizationSupplier) {\n+        clientAuthorization = ClientAuthorization.ofBasicAuthorization(authorizationSupplier);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientCredentials(\n+            Supplier<? extends Map.Entry<String, String>> credentialsSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofCredentials(credentialsSupplier, authorizationType);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientCredentials(", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMyOTc1NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471329755", "bodyText": "no, because there are userCredentials as well. here \"client\" is the OAuth2 spec term, which represents client application/device/etc vs. \"user\" which represents a human being", "author": "max904-github", "createdAt": "2020-08-17T08:41:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzODEwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwNTg3Mg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471905872", "bodyText": "Got it. Thanks.", "author": "trustin", "createdAt": "2020-08-18T04:25:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzODEwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzOTIyOA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469239228", "bodyText": "Global comment:\n\nIn our convention, the getter methods are usually hidden (i.e. they are protected or package-local). Could you reduce the visibility of the getters in builder classes?\nMissing Javadoc", "author": "trustin", "createdAt": "2020-08-12T12:58:12Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractOAuth2AuthorizationGrantBuilder.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken;\n+\n+@SuppressWarnings(\"rawtypes\")\n+abstract class AbstractOAuth2AuthorizationGrantBuilder<T extends AbstractOAuth2AuthorizationGrantBuilder> {\n+\n+    /**\n+     * A period when the token should be refreshed proactively prior to its expiry.\n+     */\n+    private static final Duration DEFAULT_REFRESH_BEFORE = Duration.ofMinutes(1L); // 1 minute\n+\n+    private final WebClient accessTokenEndpoint;\n+    private final String accessTokenEndpointPath;\n+\n+    @Nullable\n+    private ClientAuthorization clientAuthorization;\n+\n+    private Duration refreshBefore = DEFAULT_REFRESH_BEFORE;\n+\n+    @Nullable\n+    private Supplier<? extends GrantedOAuth2AccessToken> tokenSupplier;\n+\n+    @Nullable\n+    private Consumer<? super GrantedOAuth2AccessToken> tokenConsumer;\n+\n+    @Nullable\n+    private Executor executor;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Access Token request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a>.\n+     *\n+     * @param accessTokenEndpoint A {@link WebClient} to facilitate an Access Token request. Must correspond to\n+     *                            the Access Token endpoint of the OAuth 2 system.\n+     * @param accessTokenEndpointPath A URI path that corresponds to the Access Token endpoint of the\n+     *                                OAuth 2 system.\n+     */\n+    AbstractOAuth2AuthorizationGrantBuilder(WebClient accessTokenEndpoint, String accessTokenEndpointPath) {\n+        this.accessTokenEndpoint = requireNonNull(accessTokenEndpoint, \"accessTokenEndpoint\");\n+        this.accessTokenEndpointPath = requireNonNull(accessTokenEndpointPath, \"accessTokenEndpointPath\");\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientAuthorization(\n+            Supplier<String> authorizationSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofAuthorization(authorizationSupplier, authorizationType);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientBasicAuthorization(Supplier<String> authorizationSupplier) {\n+        clientAuthorization = ClientAuthorization.ofBasicAuthorization(authorizationSupplier);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientCredentials(\n+            Supplier<? extends Map.Entry<String, String>> credentialsSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofCredentials(credentialsSupplier, authorizationType);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientCredentials(\n+            Supplier<? extends Map.Entry<String, String>> credentialsSupplier) {\n+        clientAuthorization = ClientAuthorization.ofCredentials(credentialsSupplier);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * A period when the token should be refreshed proactively prior to its expiry.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T refreshBefore(Duration refreshBefore) {\n+        this.refreshBefore = requireNonNull(refreshBefore, \"refreshBefore\");\n+        return (T) this;\n+    }\n+\n+    public final Duration refreshBefore() {\n+        return refreshBefore;\n+    }", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMzNDIyMQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471334221", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-08-17T08:50:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzOTIyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzOTg1MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469239850", "bodyText": "How about just executor() for consistency with other existing builders?", "author": "trustin", "createdAt": "2020-08-12T12:59:14Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractOAuth2AuthorizationGrantBuilder.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken;\n+\n+@SuppressWarnings(\"rawtypes\")\n+abstract class AbstractOAuth2AuthorizationGrantBuilder<T extends AbstractOAuth2AuthorizationGrantBuilder> {\n+\n+    /**\n+     * A period when the token should be refreshed proactively prior to its expiry.\n+     */\n+    private static final Duration DEFAULT_REFRESH_BEFORE = Duration.ofMinutes(1L); // 1 minute\n+\n+    private final WebClient accessTokenEndpoint;\n+    private final String accessTokenEndpointPath;\n+\n+    @Nullable\n+    private ClientAuthorization clientAuthorization;\n+\n+    private Duration refreshBefore = DEFAULT_REFRESH_BEFORE;\n+\n+    @Nullable\n+    private Supplier<? extends GrantedOAuth2AccessToken> tokenSupplier;\n+\n+    @Nullable\n+    private Consumer<? super GrantedOAuth2AccessToken> tokenConsumer;\n+\n+    @Nullable\n+    private Executor executor;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Access Token request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a>.\n+     *\n+     * @param accessTokenEndpoint A {@link WebClient} to facilitate an Access Token request. Must correspond to\n+     *                            the Access Token endpoint of the OAuth 2 system.\n+     * @param accessTokenEndpointPath A URI path that corresponds to the Access Token endpoint of the\n+     *                                OAuth 2 system.\n+     */\n+    AbstractOAuth2AuthorizationGrantBuilder(WebClient accessTokenEndpoint, String accessTokenEndpointPath) {\n+        this.accessTokenEndpoint = requireNonNull(accessTokenEndpoint, \"accessTokenEndpoint\");\n+        this.accessTokenEndpointPath = requireNonNull(accessTokenEndpointPath, \"accessTokenEndpointPath\");\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientAuthorization(\n+            Supplier<String> authorizationSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofAuthorization(authorizationSupplier, authorizationType);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientBasicAuthorization(Supplier<String> authorizationSupplier) {\n+        clientAuthorization = ClientAuthorization.ofBasicAuthorization(authorizationSupplier);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientCredentials(\n+            Supplier<? extends Map.Entry<String, String>> credentialsSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofCredentials(credentialsSupplier, authorizationType);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientCredentials(\n+            Supplier<? extends Map.Entry<String, String>> credentialsSupplier) {\n+        clientAuthorization = ClientAuthorization.ofCredentials(credentialsSupplier);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * A period when the token should be refreshed proactively prior to its expiry.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T refreshBefore(Duration refreshBefore) {\n+        this.refreshBefore = requireNonNull(refreshBefore, \"refreshBefore\");\n+        return (T) this;\n+    }\n+\n+    public final Duration refreshBefore() {\n+        return refreshBefore;\n+    }\n+\n+    @Nullable\n+    public final Supplier<? extends GrantedOAuth2AccessToken> tokenSupplier() {\n+        return tokenSupplier;\n+    }\n+\n+    /**\n+     * A {@link Supplier} to load Access Token from, to be able to restore the previous session. OPTIONAL.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T tokenSupplier(Supplier<? extends GrantedOAuth2AccessToken> tokenSupplier) {\n+        this.tokenSupplier = requireNonNull(tokenSupplier, \"tokenSupplier\");\n+        return (T) this;\n+    }\n+\n+    @Nullable\n+    public final Consumer<? super GrantedOAuth2AccessToken> tokenConsumer() {\n+        return tokenConsumer;\n+    }\n+\n+    /**\n+     * A {@link Consumer} to store Access Token to, to be able restore the previous session. OPTIONAL.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T tokenConsumer(Consumer<? super GrantedOAuth2AccessToken> tokenConsumer) {\n+        this.tokenConsumer = requireNonNull(tokenConsumer, \"tokenConsumer\");\n+        return (T) this;\n+    }\n+\n+    /**\n+     * An optional {@link Executor} that facilitates asynchronous access token obtain and refresh operations.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T withExecutor(Executor executor) {\n+        this.executor = requireNonNull(executor, \"executor\");\n+        return (T) this;\n+    }\n+\n+    public final Executor withExecutor() {\n+        return executor;\n+    }", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMzNDI4NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471334284", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-08-17T08:50:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzOTg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI0MDUyNQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469240525", "bodyText": "Global comment: Consider dropping protected from package-local classes.", "author": "trustin", "createdAt": "2020-08-12T13:00:10Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractOAuth2AuthorizationGrantBuilder.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken;\n+\n+@SuppressWarnings(\"rawtypes\")\n+abstract class AbstractOAuth2AuthorizationGrantBuilder<T extends AbstractOAuth2AuthorizationGrantBuilder> {\n+\n+    /**\n+     * A period when the token should be refreshed proactively prior to its expiry.\n+     */\n+    private static final Duration DEFAULT_REFRESH_BEFORE = Duration.ofMinutes(1L); // 1 minute\n+\n+    private final WebClient accessTokenEndpoint;\n+    private final String accessTokenEndpointPath;\n+\n+    @Nullable\n+    private ClientAuthorization clientAuthorization;\n+\n+    private Duration refreshBefore = DEFAULT_REFRESH_BEFORE;\n+\n+    @Nullable\n+    private Supplier<? extends GrantedOAuth2AccessToken> tokenSupplier;\n+\n+    @Nullable\n+    private Consumer<? super GrantedOAuth2AccessToken> tokenConsumer;\n+\n+    @Nullable\n+    private Executor executor;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Access Token request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a>.\n+     *\n+     * @param accessTokenEndpoint A {@link WebClient} to facilitate an Access Token request. Must correspond to\n+     *                            the Access Token endpoint of the OAuth 2 system.\n+     * @param accessTokenEndpointPath A URI path that corresponds to the Access Token endpoint of the\n+     *                                OAuth 2 system.\n+     */\n+    AbstractOAuth2AuthorizationGrantBuilder(WebClient accessTokenEndpoint, String accessTokenEndpointPath) {\n+        this.accessTokenEndpoint = requireNonNull(accessTokenEndpoint, \"accessTokenEndpoint\");\n+        this.accessTokenEndpointPath = requireNonNull(accessTokenEndpointPath, \"accessTokenEndpointPath\");\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientAuthorization(\n+            Supplier<String> authorizationSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofAuthorization(authorizationSupplier, authorizationType);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientBasicAuthorization(Supplier<String> authorizationSupplier) {\n+        clientAuthorization = ClientAuthorization.ofBasicAuthorization(authorizationSupplier);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientCredentials(\n+            Supplier<? extends Map.Entry<String, String>> credentialsSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofCredentials(credentialsSupplier, authorizationType);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientCredentials(\n+            Supplier<? extends Map.Entry<String, String>> credentialsSupplier) {\n+        clientAuthorization = ClientAuthorization.ofCredentials(credentialsSupplier);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * A period when the token should be refreshed proactively prior to its expiry.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T refreshBefore(Duration refreshBefore) {\n+        this.refreshBefore = requireNonNull(refreshBefore, \"refreshBefore\");\n+        return (T) this;\n+    }\n+\n+    public final Duration refreshBefore() {\n+        return refreshBefore;\n+    }\n+\n+    @Nullable\n+    public final Supplier<? extends GrantedOAuth2AccessToken> tokenSupplier() {\n+        return tokenSupplier;\n+    }\n+\n+    /**\n+     * A {@link Supplier} to load Access Token from, to be able to restore the previous session. OPTIONAL.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T tokenSupplier(Supplier<? extends GrantedOAuth2AccessToken> tokenSupplier) {\n+        this.tokenSupplier = requireNonNull(tokenSupplier, \"tokenSupplier\");\n+        return (T) this;\n+    }\n+\n+    @Nullable\n+    public final Consumer<? super GrantedOAuth2AccessToken> tokenConsumer() {\n+        return tokenConsumer;\n+    }\n+\n+    /**\n+     * A {@link Consumer} to store Access Token to, to be able restore the previous session. OPTIONAL.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T tokenConsumer(Consumer<? super GrantedOAuth2AccessToken> tokenConsumer) {\n+        this.tokenConsumer = requireNonNull(tokenConsumer, \"tokenConsumer\");\n+        return (T) this;\n+    }\n+\n+    /**\n+     * An optional {@link Executor} that facilitates asynchronous access token obtain and refresh operations.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T withExecutor(Executor executor) {\n+        this.executor = requireNonNull(executor, \"executor\");\n+        return (T) this;\n+    }\n+\n+    public final Executor withExecutor() {\n+        return executor;\n+    }\n+\n+    protected abstract AbstractAccessTokenRequest buildObtainRequest(\n+            WebClient accessTokenEndpoint, String accessTokenEndpointPath,\n+            @Nullable ClientAuthorization clientAuthorization);\n+\n+    protected final AbstractAccessTokenRequest buildObtainRequest() {\n+        return buildObtainRequest(accessTokenEndpoint, accessTokenEndpointPath, clientAuthorization);\n+    }\n+\n+    protected final RefreshAccessTokenRequest buildRefreshRequest() {\n+        return new RefreshAccessTokenRequest(accessTokenEndpoint, accessTokenEndpointPath, clientAuthorization);\n+    }", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI0MTA0NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469241045", "bodyText": "Global comment: Please add final to all classes that can be final.", "author": "trustin", "createdAt": "2020-08-12T13:00:56Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/ClientCredentialsTokenRequest.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken.SCOPE;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.LinkedHashMap;\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken;\n+import com.linecorp.armeria.common.auth.oauth2.InvalidClientException;\n+import com.linecorp.armeria.common.auth.oauth2.TokenRequestException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedMediaTypeException;\n+\n+/**\n+ * Implements Client Credentials Grant request/response flow,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-4.4\">[RFC6749], Section 4.4</a>.\n+ */\n+class ClientCredentialsTokenRequest extends AbstractAccessTokenRequest {", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMzNTc2OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471335768", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-08-17T08:52:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI0MTA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI0MTE4MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469241180", "bodyText": "nit: indentation", "author": "trustin", "createdAt": "2020-08-12T13:01:10Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/ClientCredentialsTokenRequest.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken.SCOPE;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.LinkedHashMap;\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken;\n+import com.linecorp.armeria.common.auth.oauth2.InvalidClientException;\n+import com.linecorp.armeria.common.auth.oauth2.TokenRequestException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedMediaTypeException;\n+\n+/**\n+ * Implements Client Credentials Grant request/response flow,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-4.4\">[RFC6749], Section 4.4</a>.\n+ */\n+class ClientCredentialsTokenRequest extends AbstractAccessTokenRequest {\n+\n+    private static final String CLIENT_CREDENTIALS_GRANT_TYPE = \"client_credentials\";\n+\n+    /**\n+     * Implements Client Credentials Grant request/response flow,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-4.4\">[RFC6749], Section 4.4</a>.\n+     *\n+     * @param accessTokenEndpoint A {@link WebClient} to facilitate an Access Token request. Must correspond to\n+     *                            the Access Token endpoint of the OAuth 2 system.\n+     * @param accessTokenEndpointPath A URI path that corresponds to the Access Token endpoint of the\n+     *                                OAuth 2 system.\n+     * @param clientAuthorization Provides client authorization for the OAuth requests,\n+     *                            as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     */\n+    ClientCredentialsTokenRequest(WebClient accessTokenEndpoint, String accessTokenEndpointPath,\n+                                         ClientAuthorization clientAuthorization) {", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMzNjAwOA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471336008", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-08-17T08:53:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI0MTE4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI0NDM4NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469244384", "bodyText": "Do you have a better name than this? with*() usually returns a new object modified from the callee in our API, e.g. HttpData.withEndOfStream(), HttpRequest.withHeaders(). How about overloading getAccessToken()?", "author": "trustin", "createdAt": "2020-08-12T13:06:21Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/OAuth2AuthorizationGrant.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import java.util.concurrent.CompletionStage;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken;\n+\n+/**\n+ * Represents an OAuth 2.0 Access Token Grant flow to obtain Access Token.\n+ */\n+public interface OAuth2AuthorizationGrant {\n+\n+    /**\n+     * Produces OAuth 2.0 Access Token\n+     */\n+    CompletionStage<GrantedOAuth2AccessToken> getAccessToken();\n+\n+    /**\n+     * Produces (if necessary) OAuth 2.0 Access Token and adds it to the {@code req} in form of the\n+     * {@code Authorization} header.\n+     * @param req {@link HttpRequest} to wrap with OAuth 2.0 authorization.\n+     * @return {@link CompletionStage} that refers to {@link HttpRequest} wrapped wrap with\n+     *         OAuth 2.0 authorization information.\n+     */\n+    default CompletionStage<HttpRequest> withAuthorization(HttpRequest req) {", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMzOTc5NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471339795", "bodyText": "with*() usually returns a new object modified from the callee in our API\nThis is exactly what this method does:\nCompletionStage withAuthorization(HttpRequest req) - wraps HttpRequest with the authorization information.\nThis function proposed by one of your colleagues earlier in the review.\nOverloading getAccessToken() does not make sense as the signature and the semantics of the functions completely different.", "author": "max904-github", "createdAt": "2020-08-17T08:59:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI0NDM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMzgzMg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471903832", "bodyText": "I see. Seems reasonable to me.", "author": "trustin", "createdAt": "2020-08-18T04:17:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI0NDM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI0NjAzMQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469246031", "bodyText": "Could use withAuthorization().", "author": "trustin", "createdAt": "2020-08-12T13:08:56Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/OAuth2Client.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.function.Function;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.HttpClient;\n+import com.linecorp.armeria.client.SimpleDecoratingHttpClient;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * Decorates a {@link HttpClient} with an OAuth 2.0 Authorization Grant flow.\n+ */\n+public class OAuth2Client extends SimpleDecoratingHttpClient {\n+\n+    /**\n+     * Creates a new {@link HttpClient} decorator that handles OAuth 2.0 Authorization Grant flow.\n+     * @param authorizationGrant An {@link OAuth2AuthorizationGrant} implementing specific\n+     *                           OAuth 2.0 Authorization Grant flow.\n+     */\n+    public static Function<? super HttpClient, OAuth2Client> newDecorator(\n+            OAuth2AuthorizationGrant authorizationGrant) {\n+        return delegate -> new OAuth2Client(delegate, authorizationGrant);\n+    }\n+\n+    private final OAuth2AuthorizationGrant authorizationGrant;\n+\n+    /**\n+     * Creates a new instance that decorates the specified {@link HttpClient} with\n+     * an OAuth 2.0 Authorization Grant flow.\n+     */\n+    OAuth2Client(HttpClient delegate, OAuth2AuthorizationGrant authorizationGrant) {\n+        super(delegate);\n+        this.authorizationGrant = requireNonNull(authorizationGrant, \"authorizationGrant\");\n+    }\n+\n+    @Override\n+    public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Exception {\n+        return HttpResponse.from(authorizationGrant.getAccessToken().thenApply(accessToken -> {\n+            // Create a new request with an additional 'Authorization' header\n+            final HttpRequest newReq =\n+                req.withHeaders(req.headers().toBuilder()\n+                                   .set(HttpHeaderNames.AUTHORIZATION, accessToken.authorization())\n+                                   .build());", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM0MTgzNQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471341835", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-08-17T09:03:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI0NjAzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI0Njk3Mw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469246973", "bodyText": "Global comment: All concrete builders should be final unless there's a good reason for not doing so.", "author": "trustin", "createdAt": "2020-08-12T13:10:24Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/OAuth2ClientCredentialsGrantBuilder.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+\n+/**\n+ * Builds {@link OAuth2ClientCredentialsGrant}.\n+ */\n+public class OAuth2ClientCredentialsGrantBuilder", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM0Mjk5Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471342996", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-08-17T09:05:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI0Njk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI1MjkwMg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469252902", "bodyText": "Does it make sense to use auth.BasicToken instead of Map.Entry?", "author": "trustin", "createdAt": "2020-08-12T13:19:34Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/OAuth2ResourceOwnerPasswordCredentialsGrantBuilder.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+\n+/**\n+ * Builds {@link OAuth2ClientCredentialsGrant}.\n+ */\n+public class OAuth2ResourceOwnerPasswordCredentialsGrantBuilder\n+        extends AbstractOAuth2AuthorizationGrantBuilder<OAuth2ResourceOwnerPasswordCredentialsGrantBuilder> {\n+\n+    @Nullable\n+    private Supplier<? extends Map.Entry<String, String>> userCredentialsSupplier;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Access Token request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a>.\n+     * @param accessTokenEndpoint A {@link WebClient} to facilitate an Access Token request. Must correspond to\n+     *                            the Access Token endpoint of the OAuth 2 system.\n+     * @param accessTokenEndpointPath A URI path that corresponds to the Access Token endpoint of the\n+     */\n+    OAuth2ResourceOwnerPasswordCredentialsGrantBuilder(\n+            WebClient accessTokenEndpoint, String accessTokenEndpointPath) {\n+        super(accessTokenEndpoint, accessTokenEndpointPath);\n+    }\n+\n+    /**\n+     * A supplier of user credentials: \"username\" and \"password\" used to grant the Access Token. REQUIRED.\n+     */\n+    public OAuth2ResourceOwnerPasswordCredentialsGrantBuilder userCredentialsSupplier(\n+            Supplier<Entry<String, String>> userCredentialsSupplier) {", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM0NzEwOQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471347109", "bodyText": "No, it should be very generic. Credentials will come most likely from some kind of \"secret\" store like Vault (e.g. LogicalResponse)", "author": "max904-github", "createdAt": "2020-08-17T09:13:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI1MjkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwNDAzNQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471904035", "bodyText": "I see. Thanks for education. \ud83d\ude47", "author": "trustin", "createdAt": "2020-08-18T04:18:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI1MjkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI1MzI1OQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469253259", "bodyText": "Could use QueryParams?", "author": "trustin", "createdAt": "2020-08-12T13:20:07Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/RefreshAccessTokenRequest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken.REFRESH_TOKEN;\n+import static com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken.SCOPE;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.LinkedHashMap;\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken;\n+import com.linecorp.armeria.common.auth.oauth2.InvalidClientException;\n+import com.linecorp.armeria.common.auth.oauth2.TokenRequestException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedMediaTypeException;\n+\n+/**\n+ * Implements Access Token Refresh request\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-6\">[RFC6749], Section 6</a>.\n+ */\n+class RefreshAccessTokenRequest extends AbstractAccessTokenRequest {\n+\n+    /**\n+     * Implements Client Credentials Grant request/response flow,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-6\">[RFC6749], Section 6</a>.\n+     *\n+     * @param accessTokenEndpoint A {@link WebClient} to facilitate an Access Token request. Must correspond to\n+     *                            the Access Token endpoint of the OAuth 2 system.\n+     * @param accessTokenEndpointPath A URI path that corresponds to the Access Token endpoint of the\n+     *                                OAuth 2 system.\n+     * @param clientAuthorization Provides client authorization for the OAuth requests,\n+     *                            as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     */\n+    RefreshAccessTokenRequest(WebClient accessTokenEndpoint, String accessTokenEndpointPath,\n+                              @Nullable ClientAuthorization clientAuthorization) {\n+        super(accessTokenEndpoint, accessTokenEndpointPath, clientAuthorization);\n+    }\n+\n+    /**\n+     * Makes Access Token Refresh request using the given {@code refresh_token} and handles the response\n+     * converting the result data to {@link GrantedOAuth2AccessToken}.\n+     * @param refreshToken The Refresh Token issued to the client to re-new an Access Token.\n+     * @param scope OPTIONAL. Scope to request for the token. A list of space-delimited,\n+     *              case-sensitive strings. The strings are defined by the authorization server.\n+     *              The authorization server MAY fully or partially ignore the scope requested by the\n+     *              client, based on the authorization server policy or the resource owner's\n+     *              instructions. If the issued access token scope is different from the one requested\n+     *              by the client, the authorization server MUST include the \"scope\" response\n+     *              parameter to inform the client of the actual scope granted.\n+     *              If the client omits the scope parameter when requesting authorization, the\n+     *              authorization server MUST either process the request using a pre-defined default\n+     *              value or fail the request indicating an invalid scope.\n+     * @return A {@link CompletableFuture} carrying the target result as {@link GrantedOAuth2AccessToken}.\n+     * @throws TokenRequestException when the endpoint returns {code HTTP 400 (Bad Request)} status and the\n+     *                               response payload contains the details of the error.\n+     * @throws InvalidClientException when the endpoint returns {@code HTTP 401 (Unauthorized)} status, which\n+     *                                typically indicates that client authentication failed (e.g.: unknown\n+     *                                client, no client authentication included, or unsupported authentication\n+     *                                method).\n+     * @throws UnsupportedMediaTypeException if the media type of the response does not match the expected\n+     *                                       (JSON).\n+     */\n+    public CompletableFuture<GrantedOAuth2AccessToken> make(String refreshToken, @Nullable String scope) {\n+\n+        requireNonNull(refreshToken, REFRESH_TOKEN);\n+        final LinkedHashMap<String, String> requestFormItems = new LinkedHashMap<>(3);", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM0NzE5OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471347198", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-08-17T09:13:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI1MzI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI1MzcxNQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469253715", "bodyText": "Ditto - could use Supplier<BasicToken>?", "author": "trustin", "createdAt": "2020-08-12T13:20:48Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/ResourceOwnerPasswordCredentialsTokenRequest.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken.SCOPE;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken;\n+import com.linecorp.armeria.common.auth.oauth2.InvalidClientException;\n+import com.linecorp.armeria.common.auth.oauth2.TokenRequestException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedMediaTypeException;\n+\n+/**\n+ * Implements Resource Owner Password Credentials Grant request\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-4.3\">[RFC6749], Section 4.3</a>.\n+ */\n+class ResourceOwnerPasswordCredentialsTokenRequest extends AbstractAccessTokenRequest {\n+\n+    private static final String USERNAME = \"username\";\n+    private static final String PASSWORD = \"password\";\n+    private static final String PASSWORD_GRANT_TYPE = PASSWORD;\n+\n+    private final Supplier<? extends Map.Entry<String, String>> userCredentialsSupplier;\n+\n+    /**\n+     * Implements Resource Owner Password Credentials Grant request/response flow,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-4.3\">[RFC6749], Section 4.3</a>.\n+     *\n+     * @param accessTokenEndpoint A {@link WebClient} to facilitate an Access Token request. Must correspond to\n+     *                            the Access Token endpoint of the OAuth 2 system.\n+     * @param accessTokenEndpointPath A URI path that corresponds to the Access Token endpoint of the\n+     *                                OAuth 2 system.\n+     * @param clientAuthorization Provides client authorization for the OAuth requests,\n+     *                            as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     * @param userCredentialsSupplier A supplier of user credentials: \"username\" and \"password\" used to grant\n+     *                                the Access Token.\n+     */\n+    ResourceOwnerPasswordCredentialsTokenRequest(\n+            WebClient accessTokenEndpoint, String accessTokenEndpointPath,\n+            @Nullable ClientAuthorization clientAuthorization,\n+            Supplier<? extends Map.Entry<String, String>> userCredentialsSupplier) {", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM0Nzg5NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471347894", "bodyText": "Same response as above...\nNo, it should be very generic. Credentials will come most likely from some kind of \"secret\" store like Vault (e.g. LogicalResponse).", "author": "max904-github", "createdAt": "2020-08-17T09:15:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI1MzcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI1NTI4MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469255280", "bodyText": "Global comment: Could we use UnmodifiableFuture.completedFuture() wherever possible, so that a caller cannot complete or cancel the returned future arbitrarily?", "author": "trustin", "createdAt": "2020-08-12T13:23:03Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/TokenLifecycleManager.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Instant;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiPredicate;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.auth.oauth2.SerialFuture;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * Holds a token object and facilitates its lifecycle based on a number of procedures,\n+ * such as supply, update, load, store.\n+ * @param <T> the type of the token object\n+ */\n+class TokenLifecycleManager<T> {\n+\n+    /**\n+     * Holds a reference to the token.\n+     */\n+    private final AtomicReference<T> ref;\n+\n+    /**\n+     * Executes token operations serially on a separate thread.\n+     */\n+    private final SerialFuture serialFuture;\n+\n+    private final BiPredicate<? super T, Instant> validator;\n+\n+    private final Predicate<? super T> isUpdatable;\n+\n+    private final Predicate<Throwable> shallResupply;\n+\n+    private final Function<? super T, CompletionStage<? extends T>> serviceSupplier;\n+\n+    @Nullable\n+    private final Function<? super T, CompletionStage<? extends T>> serviceUpdater;\n+\n+    @Nullable\n+    private final Supplier<? extends T> storageSupplier;\n+\n+    @Nullable\n+    private final Consumer<? super T> storageConsumer;\n+\n+    /**\n+     * Constructs new {@link TokenLifecycleManager}.\n+     * @param validator A {@link BiPredicate} that tests the token for validity at the {@link Instant} time.\n+     * @param isUpdatable A {@link Predicate} that tests whether the token object can be updated or re-supplied.\n+     * @param shallResupply A {@link Predicate} that tests whether given {@link Throwable} indicates that\n+     *                      the token shall be re-supplied after the update operation failure.\n+     * @param serviceSupplier A {@link Function} that supplies an initial token object.\n+     * @param serviceUpdater A {@link Function} that updates token object.\n+     * @param storageSupplier A {@link Supplier} that can optionally load previously stored token object.\n+     * @param storageConsumer A {@link Consumer} that can optionally store token object.\n+     * @param executor An optional {@link Executor} that facilitates asynchronous supply and update operations.\n+     *                 A new single thread {@link Executor} will be created using\n+     *                 {@link Executors#newSingleThreadExecutor()} if the {@code null}.\n+     */\n+    TokenLifecycleManager(BiPredicate<? super T, Instant> validator,\n+                          Predicate<? super T> isUpdatable, Predicate<Throwable> shallResupply,\n+                          Function<? super T, CompletionStage<? extends T>> serviceSupplier,\n+                          @Nullable Function<? super T, CompletionStage<? extends T>> serviceUpdater,\n+                          @Nullable Supplier<? extends T> storageSupplier,\n+                          @Nullable Consumer<? super T> storageConsumer,\n+                          @Nullable Executor executor) {\n+        ref = new AtomicReference<>();\n+        serialFuture = new SerialFuture(executor);\n+        this.validator = requireNonNull(validator, \"validator\");\n+        this.isUpdatable = requireNonNull(isUpdatable, \"isUpdatable\");\n+        this.shallResupply = requireNonNull(shallResupply, \"shallResupply\");\n+        this.serviceSupplier = requireNonNull(serviceSupplier, \"serviceSupplier\");\n+        this.serviceUpdater = serviceUpdater;\n+        this.storageSupplier = storageSupplier;\n+        this.storageConsumer = storageConsumer;\n+    }\n+\n+    /**\n+     * Provides managed token object asynchronously. This operation may involve initial token supply or\n+     * token update operation, if required.\n+     */\n+    public CompletionStage<T> get() {\n+        final T t = ref.get();\n+        if (t != null) {\n+            // token already present\n+            return validateOrUpdate(t);\n+        }\n+\n+        // token is not yet present\n+        // try to supply an initial token serially using a serial execution\n+        return serialFuture.executeAsync(this::supplySerially);\n+    }\n+\n+    private CompletionStage<T> supplySerially() {\n+        // re-check if the token already present\n+        T t = ref.get();\n+        if (t != null) {\n+            // token already present\n+            return validateOrUpdate(t, false);\n+        }\n+\n+        // token not yet loaded\n+        // try loading from storage\n+        t = load();\n+        if (t != null) {\n+            // token loaded\n+            return validateOrUpdate(t, true);\n+        }\n+\n+        // token has never been supplied\n+        // otherwise, supply initial value\n+        return supplyInitial();\n+    }\n+\n+    /**\n+     * Updates the token object if it's invalid at the given {@link Instant} time.\n+     */\n+    private CompletionStage<T> updateSerially(Instant instant) {\n+        // after acquiring the lock, re-check if it's a valid token\n+        final T t = ref.get();\n+        if (validator.test(t, instant)) {\n+            // simply return a valid token\n+            return CompletableFuture.completedFuture(t);", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM1MDQ1Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471350457", "bodyText": "I was not aware of this class. But I prefer to stick to Java API whenever possible.", "author": "max904-github", "createdAt": "2020-08-17T09:19:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI1NTI4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI1NzA4OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469257088", "bodyText": "How about adding a hyperlink to a good resource about OAuth 2.0 for the text OAuth 2.0?", "author": "trustin", "createdAt": "2020-08-12T13:25:37Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/package-info.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+/**\n+ * Client-side OAuth 2.0 implementation.", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQxMDk1Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471410956", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-08-17T11:18:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI1NzA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI1OTg5Mw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469259893", "bodyText": "I see both *Request and *Grant require WebClient as an endpoint. How about letting a user specify a WebClient when creating an OAuth2Client or OAuth2*Authorizer and changing *Request and *Grant to require a WebClient when sending a request? This way, we can keep only one WebClient in OAuth2Client or OAuth2*Authorizer.\nOr, is there a use case for specifying different WebClient for each request?", "author": "trustin", "createdAt": "2020-08-12T13:29:43Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/AbstractOAuth2Request.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n+\n+/**\n+ * A common abstraction for the requests implementing various OAuth 2.0 request/response flows,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a> and other relevant specifications.\n+ * @param <T> the type of the authorization result.\n+ */\n+public abstract class AbstractOAuth2Request<T> {\n+\n+    private final WebClient endpoint;\n+    private final String endpointPath;\n+    @Nullable\n+    private final ClientAuthorization clientAuthorization;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Authorization request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a> and other relevant specifications.\n+     *\n+     * @param endpoint A {@link WebClient} to facilitate the Authorization requests. Must\n+     *                 correspond to the required Authorization endpoint of the OAuth 2 system.\n+     * @param endpointPath A URI path that corresponds to the Authorization endpoint of the\n+     *                     OAuth 2 system.\n+     * @param clientAuthorization Provides client authorization for the OAuth requests,\n+     *                            as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     */\n+    protected AbstractOAuth2Request(WebClient endpoint, String endpointPath,\n+                                    @Nullable ClientAuthorization clientAuthorization) {", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQxMzAyNQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471413025", "bodyText": "Requests aren't public. Grant passes WebClient to Requests whenever appropriate. So there are no multiple WebClients.\n\n\nis there a use case for specifying different WebClient for each request\nIt all depends on the particular Grant. The Grant decides (as per the spec) whether to use the same endpoint/WebClient for different operations/requests or not.", "author": "max904-github", "createdAt": "2020-08-17T11:23:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI1OTg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwNDIyNQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471904225", "bodyText": "OK!", "author": "trustin", "createdAt": "2020-08-18T04:19:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI1OTg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2NDk1OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469264958", "bodyText": "Should these be public? If we want to hide these fields, we could add private or remove public. If it's accessed by the classes in other package, we could extract these constants into a class like OAuth2Constants in internal.common.auth.oauth2 package to hide them from the public API.", "author": "trustin", "createdAt": "2020-08-12T13:37:26Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/GrantedOAuth2AccessToken.java", "diffHunk": "@@ -0,0 +1,407 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static java.time.format.DateTimeFormatter.ISO_INSTANT;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+/**\n+ * Defines a structure of the Access Token Response, as per\n+ * <a href=\"https://tools.ietf.org/html/rfc6749#section-5.1\">[RFC6749], Section 5.1</a>.\n+ */\n+public class GrantedOAuth2AccessToken implements Serializable {\n+\n+    private static final long serialVersionUID = 8698118404098897958L;\n+\n+    /**\n+     * Creates a new {@link GrantedOAuth2AccessToken} based on the {@code JSON}-formatted raw response body and\n+     * optional raw formatted {@code scope} used to request the token.\n+     * @param rawResponse {@code JSON}-formatted raw response body.\n+     * @param requestScope OPTIONAL. A list of space-delimited, case-sensitive strings.\n+     *                     The strings are defined by the authorization server.\n+     *                     The authorization server MAY fully or partially ignore the scope requested by the\n+     *                     client, based on the authorization server policy or the resource owner's\n+     *                     instructions. If the issued access token scope is different from the one requested\n+     *                     by the client, the authorization server MUST include the \"scope\" response\n+     *                     parameter to inform the client of the actual scope granted.\n+     *                     If the client omits the scope parameter when requesting authorization, the\n+     *                     authorization server MUST either process the request using a pre-defined default\n+     *                     value or fail the request indicating an invalid scope.\n+     * @return A new instance of {@link GrantedOAuth2AccessToken}.\n+     */\n+    public static GrantedOAuth2AccessToken of(String rawResponse, @Nullable String requestScope) {\n+        return GrantedOAuth2AccessTokenBuilder.of(rawResponse, requestScope);\n+    }\n+\n+    /**\n+     * Creates a new {@link GrantedOAuth2AccessTokenBuilder} to build a new {@link GrantedOAuth2AccessToken} and\n+     * supplied it with a value of {@code access_token} Access Token response field.\n+     * @return A new instance of {@link GrantedOAuth2AccessTokenBuilder}.\n+     */\n+    public static GrantedOAuth2AccessTokenBuilder builder(String accessToken) {\n+        return new GrantedOAuth2AccessTokenBuilder(accessToken);\n+    }\n+\n+    public static final String ACCESS_TOKEN = \"access_token\";\n+    public static final String REFRESH_TOKEN = \"refresh_token\";\n+    public static final String SCOPE = \"scope\";\n+    public static final String TOKEN_TYPE = \"token_type\";\n+    public static final String EXPIRES_IN = \"expires_in\";", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQxNDgxMQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471414811", "bodyText": "Those were not public before, but since you've asked me to put various requests into different packages, I've made those public. Weather or not those constants extracted into a separate class, those would remain public.", "author": "max904-github", "createdAt": "2020-08-17T11:26:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2NDk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwNDcwNQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471904705", "bodyText": "Yeah, what I'm suggesting is to extract these public constants into a new class like OAuth2Constants in an internal package - internal.common.auth.oauth2. We exclude the internal packages from our Javadoc and a user usually knows it's not a good idea to use the classes in an 'internal' package, so we are sort of 'hiding' it from the public API, although not perfect.", "author": "trustin", "createdAt": "2020-08-18T04:21:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2NDk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5ODEzOQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r472098139", "bodyText": "moved to internal as suggested", "author": "max904-github", "createdAt": "2020-08-18T11:09:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2NDk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2NTU0OQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469265549", "bodyText": "Global comment: Could use {@value ...} expression, e.g. {@value #ACCESS_TOKEN}.", "author": "trustin", "createdAt": "2020-08-12T13:38:15Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/GrantedOAuth2AccessToken.java", "diffHunk": "@@ -0,0 +1,407 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static java.time.format.DateTimeFormatter.ISO_INSTANT;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+/**\n+ * Defines a structure of the Access Token Response, as per\n+ * <a href=\"https://tools.ietf.org/html/rfc6749#section-5.1\">[RFC6749], Section 5.1</a>.\n+ */\n+public class GrantedOAuth2AccessToken implements Serializable {\n+\n+    private static final long serialVersionUID = 8698118404098897958L;\n+\n+    /**\n+     * Creates a new {@link GrantedOAuth2AccessToken} based on the {@code JSON}-formatted raw response body and\n+     * optional raw formatted {@code scope} used to request the token.\n+     * @param rawResponse {@code JSON}-formatted raw response body.\n+     * @param requestScope OPTIONAL. A list of space-delimited, case-sensitive strings.\n+     *                     The strings are defined by the authorization server.\n+     *                     The authorization server MAY fully or partially ignore the scope requested by the\n+     *                     client, based on the authorization server policy or the resource owner's\n+     *                     instructions. If the issued access token scope is different from the one requested\n+     *                     by the client, the authorization server MUST include the \"scope\" response\n+     *                     parameter to inform the client of the actual scope granted.\n+     *                     If the client omits the scope parameter when requesting authorization, the\n+     *                     authorization server MUST either process the request using a pre-defined default\n+     *                     value or fail the request indicating an invalid scope.\n+     * @return A new instance of {@link GrantedOAuth2AccessToken}.\n+     */\n+    public static GrantedOAuth2AccessToken of(String rawResponse, @Nullable String requestScope) {\n+        return GrantedOAuth2AccessTokenBuilder.of(rawResponse, requestScope);\n+    }\n+\n+    /**\n+     * Creates a new {@link GrantedOAuth2AccessTokenBuilder} to build a new {@link GrantedOAuth2AccessToken} and\n+     * supplied it with a value of {@code access_token} Access Token response field.\n+     * @return A new instance of {@link GrantedOAuth2AccessTokenBuilder}.\n+     */\n+    public static GrantedOAuth2AccessTokenBuilder builder(String accessToken) {\n+        return new GrantedOAuth2AccessTokenBuilder(accessToken);\n+    }\n+\n+    public static final String ACCESS_TOKEN = \"access_token\";\n+    public static final String REFRESH_TOKEN = \"refresh_token\";\n+    public static final String SCOPE = \"scope\";\n+    public static final String TOKEN_TYPE = \"token_type\";\n+    public static final String EXPIRES_IN = \"expires_in\";\n+\n+    static final String ISSUED_AT = \"issued_at\";\n+\n+    static final String SCOPE_SEPARATOR = \" \";\n+    static final char AUTHORIZATION_SEPARATOR = ' ';\n+\n+    static final String DEFAULT_TOKEN_TYPE = \"bearer\";\n+\n+    static final ObjectMapper JSON = new ObjectMapper();\n+\n+    /**\n+     * {@code access_token} Access Token response field,\n+     * REQUIRED. The access token issued by the authorization server.\n+     */\n+    private final String accessToken;\n+\n+    /**\n+     * {@code token_type} Access Token response field,\n+     * REQUIRED. The type of the token issued as described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-7.1\">[RFC6749], Section 7.1</a>, e.g. \"bearer\".\n+     * Value is case insensitive.\n+     */\n+    @Nullable\n+    private final String tokenType;\n+\n+    /**\n+     * {@code expires_in} Access Token response field,\n+     * RECOMMENDED. The lifetime in seconds of the access token. For example, the value \"3600\" denotes\n+     * that the access token will expire in one hour from the time the response was generated. If\n+     * omitted, the authorization server SHOULD provide the expiration time via other means or\n+     * document the default value.\n+     */\n+    @Nullable\n+    private final Duration expiresIn;\n+\n+    /**\n+     * {@code refresh_token} Access Token response field,\n+     * OPTIONAL. The refresh token, which can be used to obtain new access tokens using the same\n+     * authorization grant as described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-6\">[RFC6749], Section 6</a>.\n+     */\n+    @Nullable\n+    private final String refreshToken;\n+\n+    /**\n+     * {@code scope} Access Token response field,\n+     * OPTIONAL, if identical to the scope requested by the client; otherwise, REQUIRED. The scope of\n+     * the access token as described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-3.3\">[RFC6749], Section 3.3</a>.\n+     * A list of space-delimited, case-sensitive scope strings. The strings are defined by the authorization\n+     * server.\n+     * The authorization server MAY fully or partially ignore the scope requested by the client, based\n+     * on the authorization server policy or the resource owner's instructions.  If the issued access\n+     * token scope is different from the one requested by the client, the authorization server MUST\n+     * include the \"scope\" response parameter to inform the client of the actual scope granted.\n+     * If the client omits the scope parameter when requesting authorization, the authorization server\n+     * MUST either process the request using a pre-defined default value or fail the request\n+     * indicating an invalid scope.\n+     */\n+    @Nullable\n+    private final String scope;\n+\n+    /**\n+     * A {@link Set} of case-sensitive scope strings. The strings are defined by the authorization\n+     * server.\n+     */\n+    private final Set<String> scopeSet;\n+\n+    /**\n+     * A {@link Map} of extra system-specific token parameters included with Access Token response,\n+     * OPTIONAL.\n+     */\n+    private final Map<String, String> extras;\n+\n+    private final Instant issuedAt;\n+\n+    @Nullable\n+    private String rawResponse;\n+\n+    @Nullable\n+    private transient Instant expiresAt;\n+\n+    @Nullable\n+    private transient String authorization;\n+\n+    @Nullable\n+    private transient String toString;\n+\n+    GrantedOAuth2AccessToken(String accessToken, @Nullable String tokenType,\n+                             Instant issuedAt, @Nullable Duration expiresIn,\n+                             @Nullable String refreshToken, @Nullable List<String> scopeList,\n+                             @Nullable ImmutableMap<String, String> extras,\n+                             @Nullable String rawResponse) {\n+        // token fields\n+        this.accessToken = requireNonNull(accessToken, ACCESS_TOKEN);\n+        this.tokenType = tokenType;\n+        this.expiresIn = expiresIn;\n+        this.issuedAt = requireNonNull(issuedAt, ISSUED_AT);\n+        this.refreshToken = refreshToken;\n+        scope = toScopeString(scopeList);\n+        scopeSet = (scopeList == null) ? ImmutableSet.of() : ImmutableSet.copyOf(scopeList);\n+        this.extras = (extras == null) ? ImmutableMap.of() : extras;\n+        // raw response\n+        this.rawResponse = rawResponse;\n+    }\n+\n+    /**\n+     * {@code access_token} Access Token response field,", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEwMjEyOQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r472102129", "bodyText": "Somehow it does not work well with static imports", "author": "max904-github", "createdAt": "2020-08-18T11:18:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2NTU0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjExMDYzMw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r472110633", "bodyText": "Does {@value ClassName#FIELD_NAME} work, then?", "author": "trustin", "createdAt": "2020-08-18T11:35:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2NTU0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE2OTI5MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r472169290", "bodyText": "yes. fixed", "author": "max904-github", "createdAt": "2020-08-18T13:01:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2NTU0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2NzQxMw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469267413", "bodyText": "Could share one ObjectMapper instance across all classes unless some needs to be configured differently?", "author": "trustin", "createdAt": "2020-08-12T13:40:47Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/OAuth2TokenDescriptor.java", "diffHunk": "@@ -0,0 +1,511 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+/**\n+ * Defines a structure of the Token Introspection Response, as per\n+ * <a href=\"https://tools.ietf.org/html/rfc7662#section-2.2\">[RFC7662], Section 2.2</a>.\n+ */\n+public class OAuth2TokenDescriptor implements Serializable {\n+\n+    private static final long serialVersionUID = -3976877781134216467L;\n+\n+    /**\n+     * Creates a new {@link OAuth2TokenDescriptor} based on the {@code JSON}-formatted raw response body.\n+     * @param rawResponse {@code JSON}-formatted raw response body.\n+     * @return A new instance of {@link OAuth2TokenDescriptor}.\n+     */\n+    public static OAuth2TokenDescriptor of(String rawResponse) {\n+        return OAuth2TokenDescriptorBuilder.of(rawResponse);\n+    }\n+\n+    /**\n+     * Creates a new {@link OAuth2TokenDescriptorBuilder} to build a new {@link OAuth2TokenDescriptor} and\n+     * supplied it with a value of {@code active} Token Introspection Response field.\n+     * @return A new instance of {@link OAuth2TokenDescriptorBuilder}.\n+     */\n+    public static OAuth2TokenDescriptorBuilder builder(boolean active) {\n+        return new OAuth2TokenDescriptorBuilder(active);\n+    }\n+\n+    static final String ACTIVE = \"active\";\n+    static final String SCOPE = \"scope\";\n+    static final String CLIENT_ID = \"client_id\";\n+    static final String USER_NAME = \"username\";\n+    static final String TOKEN_TYPE = \"token_type\";\n+    static final String EXPIRES_AT = \"exp\";\n+    static final String ISSUED_AT = \"iat\";\n+    static final String NOT_BEFORE = \"nbf\";\n+    static final String SUBJECT = \"sub\";\n+    static final String AUDIENCE = \"aud\";\n+    static final String ISSUER = \"iss\";\n+    static final String JWT_ID = \"jti\";\n+\n+    static final String SCOPE_SEPARATOR = \" \";\n+\n+    static final ObjectMapper JSON = new ObjectMapper();", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE5NjU0MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r472196541", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-08-18T13:28:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2NzQxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2NzcxOQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469267719", "bodyText": "Could use {@value ...}", "author": "trustin", "createdAt": "2020-08-12T13:41:14Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/OAuth2TokenDescriptor.java", "diffHunk": "@@ -0,0 +1,511 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+/**\n+ * Defines a structure of the Token Introspection Response, as per\n+ * <a href=\"https://tools.ietf.org/html/rfc7662#section-2.2\">[RFC7662], Section 2.2</a>.\n+ */\n+public class OAuth2TokenDescriptor implements Serializable {\n+\n+    private static final long serialVersionUID = -3976877781134216467L;\n+\n+    /**\n+     * Creates a new {@link OAuth2TokenDescriptor} based on the {@code JSON}-formatted raw response body.\n+     * @param rawResponse {@code JSON}-formatted raw response body.\n+     * @return A new instance of {@link OAuth2TokenDescriptor}.\n+     */\n+    public static OAuth2TokenDescriptor of(String rawResponse) {\n+        return OAuth2TokenDescriptorBuilder.of(rawResponse);\n+    }\n+\n+    /**\n+     * Creates a new {@link OAuth2TokenDescriptorBuilder} to build a new {@link OAuth2TokenDescriptor} and\n+     * supplied it with a value of {@code active} Token Introspection Response field.\n+     * @return A new instance of {@link OAuth2TokenDescriptorBuilder}.\n+     */\n+    public static OAuth2TokenDescriptorBuilder builder(boolean active) {\n+        return new OAuth2TokenDescriptorBuilder(active);\n+    }\n+\n+    static final String ACTIVE = \"active\";\n+    static final String SCOPE = \"scope\";\n+    static final String CLIENT_ID = \"client_id\";\n+    static final String USER_NAME = \"username\";\n+    static final String TOKEN_TYPE = \"token_type\";\n+    static final String EXPIRES_AT = \"exp\";\n+    static final String ISSUED_AT = \"iat\";\n+    static final String NOT_BEFORE = \"nbf\";\n+    static final String SUBJECT = \"sub\";\n+    static final String AUDIENCE = \"aud\";\n+    static final String ISSUER = \"iss\";\n+    static final String JWT_ID = \"jti\";\n+\n+    static final String SCOPE_SEPARATOR = \" \";\n+\n+    static final ObjectMapper JSON = new ObjectMapper();\n+\n+    /**\n+     * {@code active} Token Introspection Response field,\n+     * REQUIRED. Boolean indicator of whether or not the presented token is currently active. The\n+     * specifics of a token's \"active\" state will vary depending on the implementation of the\n+     * authorization server and the information it keeps about its tokens, but a \"true\" value return\n+     * for the \"active\" property will generally indicate that a given token has been issued by this\n+     * authorization server, has not been revoked by the resource owner, and is within its given time\n+     * window of validity (e.g., after its issuance time and before its expiration time).\n+     */\n+    private final boolean active;\n+\n+    /**\n+     * {@code scope} Token Introspection Response field,\n+     * OPTIONAL. A JSON string containing a space-separated list of scopes associated with this token,\n+     * in the format described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-3.3\">[RFC6749], Section 3.3</a>.\n+     */\n+    @Nullable\n+    private final String scope;\n+\n+    /**\n+     * A {@link Set} of case-sensitive scope strings. The strings are defined by the authorization\n+     * server.\n+     */\n+    private final Set<String> scopeSet;\n+\n+    /**\n+     * {@code client_id} Token Introspection Response field,\n+     * OPTIONAL. Client identifier for the OAuth 2.0 client that requested this token.\n+     */\n+    @Nullable\n+    private final String clientId;\n+\n+    /**\n+     * {@code username} Token Introspection Response field,\n+     * OPTIONAL. Human-readable identifier for the resource owner who authorized this token.\n+     */\n+    @Nullable\n+    private final String userName;\n+\n+    /**\n+     * {@code token_type} Token Introspection Response field,\n+     * OPTIONAL. Type of the token as defined at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-7.1\">[RFC6749], Section 7.1</a>.\n+     */\n+    @Nullable\n+    private final String tokenType;\n+\n+    /**\n+     * {@code exp} Token Introspection Response field,\n+     * OPTIONAL. Integer timestamp, measured in the number of seconds since January 1 1970 UTC,\n+     * indicating when this token will expire, as defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    private final Instant expiresAt;\n+\n+    /**\n+     * {@code iat} Token Introspection Response field,\n+     * OPTIONAL. Integer timestamp, measured in the number of seconds since January 1 1970 UTC,\n+     * indicating when this token was originally issued, as defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    private final Instant issuedAt;\n+\n+    /**\n+     * {@code nbf} Token Introspection Response field,\n+     * OPTIONAL. Integer timestamp, measured in the number of seconds since January 1 1970 UTC,\n+     * indicating when this token is not to be used before, as defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    private final Instant notBefore;\n+\n+    /**\n+     * {@code sub} Token Introspection Response field,\n+     * OPTIONAL. Subject of the token. Usually a machine-readable\n+     * identifier of the resource owner who authorized this token. As defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    private final String subject;\n+\n+    /**\n+     * {@code aud} Token Introspection Response field,\n+     * OPTIONAL. Service-specific string identifier or list of string identifiers representing the\n+     * intended audience for this token, as defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    private final String audience;\n+\n+    /**\n+     * {@code iss} Token Introspection Response field,\n+     * OPTIONAL. String representing the issuer of this token, as defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    private final String issuer;\n+\n+    /**\n+     * {@code jti} Token Introspection Response field,\n+     * OPTIONAL. String identifier for the token - JWT ID, as defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    private final String jwtId;\n+\n+    /**\n+     * A {@link Map} of extra system-specific token parameters included with Token Introspection Response,\n+     * OPTIONAL.\n+     */\n+    private final Map<String, String> extras;\n+\n+    @Nullable\n+    private String rawResponse;\n+\n+    @Nullable\n+    private transient String toString;\n+\n+    OAuth2TokenDescriptor(boolean active, @Nullable List<String> scopeList, @Nullable String clientId,\n+                          @Nullable String userName, @Nullable String tokenType,\n+                          @Nullable Instant expiresAt, @Nullable Instant issuedAt,\n+                          @Nullable Instant notBefore, @Nullable String subject,\n+                          @Nullable String audience, @Nullable String issuer,\n+                          @Nullable String jwtId, @Nullable ImmutableMap<String, String> extras,\n+                          @Nullable String rawResponse) {\n+        this.active = active;\n+        scope = toScopeString(scopeList);\n+        scopeSet = (scopeList == null) ? ImmutableSet.of() : ImmutableSet.copyOf(scopeList);\n+        this.clientId = clientId;\n+        this.userName = userName;\n+        this.tokenType = tokenType;\n+        this.expiresAt = expiresAt;\n+        this.issuedAt = issuedAt;\n+        this.notBefore = notBefore;\n+        this.subject = subject;\n+        this.audience = audience;\n+        this.issuer = issuer;\n+        this.jwtId = jwtId;\n+        this.extras = (extras == null) ? ImmutableMap.of() : extras;\n+        // raw response\n+        this.rawResponse = rawResponse;\n+    }\n+\n+    /**\n+     * {@code active} Token Introspection Response field,\n+     * REQUIRED. Boolean indicator of whether or not the presented token is currently active. The\n+     * specifics of a token's \"active\" state will vary depending on the implementation of the\n+     * authorization server and the information it keeps about its tokens, but a \"true\" value return\n+     * for the \"active\" property will generally indicate that a given token has been issued by this\n+     * authorization server, has not been revoked by the resource owner, and is within its given time\n+     * window of validity (e.g., after its issuance time and before its expiration time).\n+     */\n+    public boolean isActive() {\n+        return active;\n+    }\n+\n+    /**\n+     * Indicates whether or not the Token expire at the given {@link Instant} time based on\n+     * {@link #expiresAt()} function.\n+     */\n+    public boolean isValid(Instant instant) {\n+        final Instant expires = expiresAt();\n+        return (expires == null) || requireNonNull(instant, \"instant\").isBefore(expires);\n+    }\n+\n+    /**\n+     * Indicates whether or not the Token already expired based on {@link #expiresAt()} function.\n+     */\n+    public boolean isValid() {\n+        return isValid(Instant.now());\n+    }\n+\n+    /**\n+     * Indicates whether or not the Token used prematurely based on {@link #notBefore()} function.\n+     */\n+    public boolean isNotBefore() {\n+        final Instant notBefore = notBefore();\n+        return (notBefore == null) || Instant.now().isAfter(notBefore);\n+    }\n+\n+    /**\n+     * {@code scope} Token Introspection Response field,\n+     * OPTIONAL. A JSON string containing a space-separated list of scopes associated with this token,\n+     * in the format described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-3.3\">[RFC6749], Section 3.3</a>.\n+     */\n+    @Nullable\n+    public String scope() {\n+        return scope;\n+    }\n+\n+    /**\n+     * {@code scope} Token Introspection Response field,\n+     * OPTIONAL. A {@link Set} of case-sensitive scope strings. The strings are defined by the authorization\n+     * server.\n+     */\n+    public Set<String> scopeSet() {\n+        return scopeSet;\n+    }\n+\n+    /**\n+     * {@code client_id} Token Introspection Response field,\n+     * OPTIONAL. Client identifier for the OAuth 2.0 client that requested this token.\n+     */\n+    @Nullable\n+    public String clientId() {\n+        return clientId;\n+    }\n+\n+    /**\n+     * {@code username} Token Introspection Response field,\n+     * OPTIONAL. Human-readable identifier for the resource owner who authorized this token.\n+     */\n+    @Nullable\n+    public String userName() {\n+        return userName;\n+    }\n+\n+    /**\n+     * {@code token_type} Token Introspection Response field,\n+     * OPTIONAL. Type of the token as defined at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-7.1\">[RFC6749], Section 7.1</a>.\n+     */\n+    @Nullable\n+    public String tokenType() {\n+        return tokenType;\n+    }\n+\n+    /**\n+     * {@code exp} Token Introspection Response field,\n+     * OPTIONAL. {@link Instant} timestamp, indicating when this token will expire, as defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    public Instant expiresAt() {\n+        return expiresAt;\n+    }\n+\n+    /**\n+     * {@code iat} Token Introspection Response field,\n+     * OPTIONAL. {@link Instant} timestamp, indicating when this token was originally issued, as defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    public Instant issuedAt() {\n+        return issuedAt;\n+    }\n+\n+    /**\n+     * {@link Duration} indicating the lifetime of the access token. The value is NOT supplied with the\n+     * Token Introspection response and calculated based on {@code iat} and {@code exp} response fields every\n+     * time this method invoked.\n+     */\n+    @Nullable\n+    public Duration expiresIn() {\n+        if (issuedAt != null && expiresAt != null) {\n+            return Duration.ofMillis(issuedAt.until(expiresAt, ChronoUnit.MILLIS));\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * {@code nbf} Token Introspection Response field,\n+     * OPTIONAL. {@link Instant} timestamp, indicating when this token is not to be used before, as defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    public Instant notBefore() {\n+        return notBefore;\n+    }\n+\n+    /**\n+     * {@code sub} Token Introspection Response field,\n+     * OPTIONAL. Subject of the token. Usually a machine-readable\n+     * identifier of the resource owner who authorized this token. As defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    public String subject() {\n+        return subject;\n+    }\n+\n+    /**\n+     * {@code aud} Token Introspection Response field,\n+     * OPTIONAL. Service-specific string identifier or list of string identifiers representing the\n+     * intended audience for this token, as defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    public String audience() {\n+        return audience;\n+    }\n+\n+    /**\n+     * {@code iss} Token Introspection Response field,\n+     * OPTIONAL. String representing the issuer of this token, as defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    public String issuer() {\n+        return issuer;\n+    }\n+\n+    /**\n+     * {@code jti} Token Introspection Response field,", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEwMjIxMw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r472102213", "bodyText": "Somehow it does not work well with static imports", "author": "max904-github", "createdAt": "2020-08-18T11:18:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2NzcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE2OTYwNw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r472169607", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-08-18T13:01:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2NzcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2ODQ4MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469268480", "bodyText": "Should this method be moved to OAuth2TokenDescriptor and renamed to builder(String)?", "author": "trustin", "createdAt": "2020-08-12T13:42:20Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/OAuth2TokenDescriptorBuilder.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor.ACTIVE;\n+import static com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor.AUDIENCE;\n+import static com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor.CLIENT_ID;\n+import static com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor.EXPIRES_AT;\n+import static com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor.ISSUED_AT;\n+import static com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor.ISSUER;\n+import static com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor.JSON;\n+import static com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor.JWT_ID;\n+import static com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor.NOT_BEFORE;\n+import static com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor.SCOPE;\n+import static com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor.SCOPE_SEPARATOR;\n+import static com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor.SUBJECT;\n+import static com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor.TOKEN_TYPE;\n+import static com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor.USER_NAME;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Instant;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Builds an instance of {@link OAuth2TokenDescriptor}.\n+ */\n+public class OAuth2TokenDescriptorBuilder {\n+\n+    private static final TypeReference<LinkedHashMap<String, String>> MAP_TYPE =\n+            new TypeReference<LinkedHashMap<String, String>>() {};\n+\n+    static OAuth2TokenDescriptor of(String rawResponse) {", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQxNjQ5MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471416490", "bodyText": "it's already there:\n    public static OAuth2TokenDescriptor of(String rawResponse) {\n        return OAuth2TokenDescriptorBuilder.of(rawResponse);\n    }", "author": "max904-github", "createdAt": "2020-08-17T11:30:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2ODQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NzkzNA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552447934", "bodyText": "I actually meant inlining and removing this method.", "author": "trustin", "createdAt": "2021-01-06T09:02:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2ODQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2OTE4OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469269188", "bodyText": "Could we remove public or move to internal.common.auth.oauth2?", "author": "trustin", "createdAt": "2020-08-12T13:43:23Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/SerialFuture.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * Executes submitted {@link Callable} actions asynchronously in sequence.\n+ */\n+public class SerialFuture {", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQxNjkyNw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471416927", "bodyText": "This is a generic utility class", "author": "max904-github", "createdAt": "2020-08-17T11:31:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2OTE4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwNTIxNQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471905215", "bodyText": "Yes, but I'd like to hide it from the public API and consider making it public when there are demands from users, because it's not an essential part of OAuth 2 support.", "author": "trustin", "createdAt": "2020-08-18T04:22:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2OTE4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE3MDA3Mw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r472170073", "bodyText": "moved to internal", "author": "max904-github", "createdAt": "2020-08-18T13:02:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2OTE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2OTQwNg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469269406", "bodyText": "this(null)", "author": "trustin", "createdAt": "2020-08-12T13:43:40Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/SerialFuture.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * Executes submitted {@link Callable} actions asynchronously in sequence.\n+ */\n+public class SerialFuture {\n+\n+    private final Queue<Runnable> actions = new LinkedList<>();\n+\n+    @Nullable\n+    private Runnable active;\n+\n+    @Nullable\n+    Executor executor;\n+\n+    /**\n+     * Constructs {@link SerialFuture} with a supplied {@link Executor}.\n+     * @param executor An {@link Executor} to execute asynchronous actions.\n+     */\n+    public SerialFuture(@Nullable Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    /**\n+     * Constructs {@link SerialFuture}.\n+     */\n+    public SerialFuture() {\n+        executor = null;", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQxNzI2Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471417266", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-08-17T11:32:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2OTQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3MDIzMg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469270232", "bodyText": "Please use handle with a null-returning BiFunction, because whenComplete() has a known performance issue in Java 8.", "author": "trustin", "createdAt": "2020-08-12T13:44:51Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/SerialFuture.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * Executes submitted {@link Callable} actions asynchronously in sequence.\n+ */\n+public class SerialFuture {\n+\n+    private final Queue<Runnable> actions = new LinkedList<>();\n+\n+    @Nullable\n+    private Runnable active;\n+\n+    @Nullable\n+    Executor executor;\n+\n+    /**\n+     * Constructs {@link SerialFuture} with a supplied {@link Executor}.\n+     * @param executor An {@link Executor} to execute asynchronous actions.\n+     */\n+    public SerialFuture(@Nullable Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    /**\n+     * Constructs {@link SerialFuture}.\n+     */\n+    public SerialFuture() {\n+        executor = null;\n+    }\n+\n+    /**\n+     * Executes submitted {@link Callable} action asynchronously in sequence.\n+     * @param action An asynchronous {@link Callable} action to be executed in sequence.\n+     *               It returns {@link CompletionStage} that produces the final result when the action\n+     *               completes.\n+     * @return Returns a new {@link CompletionStage} with the same result or exception as the {@code action},\n+     *         that executes the given action when this stage completes.\n+     */\n+    public synchronized <V> CompletionStage<V> executeAsync(Callable<CompletionStage<V>> action) {\n+        final CompletableFuture<V> result = new CompletableFuture<>();\n+        actions.add(() -> {\n+            final CompletionStage<V> future;\n+            try {\n+                future = action.call();\n+            } catch (Exception e) {\n+                result.completeExceptionally(Exceptions.peel(e));\n+                executeNext();\n+                return;\n+            }\n+            future.whenComplete((v, ex) -> {", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQzOTgzMQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471439831", "bodyText": "I'm not aware of such performance issue. Could you provide some links?", "author": "max904-github", "createdAt": "2020-08-17T12:19:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3MDIzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwNTU5Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471905596", "bodyText": "#1440", "author": "trustin", "createdAt": "2020-08-18T04:24:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3MDIzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAzMzM3NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r472033374", "bodyText": "Interesting. This ticket reported against whenCompleteAsync(). Does it also apply to whenComplete()?", "author": "max904-github", "createdAt": "2020-08-18T09:10:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3MDIzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjExMTE3OQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r472111179", "bodyText": "Yeah, it applies to both whenCompleteAsync() and whenComplete() IIRC, because they both go to uniWhenComplete().", "author": "trustin", "createdAt": "2020-08-18T11:36:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3MDIzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE3NzI3MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r472177270", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-08-18T13:09:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3MDIzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3MDc1Mw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469270753", "bodyText": "Could catch Throwable and call executeNext() in finally.", "author": "trustin", "createdAt": "2020-08-12T13:45:35Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/SerialFuture.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * Executes submitted {@link Callable} actions asynchronously in sequence.\n+ */\n+public class SerialFuture {\n+\n+    private final Queue<Runnable> actions = new LinkedList<>();\n+\n+    @Nullable\n+    private Runnable active;\n+\n+    @Nullable\n+    Executor executor;\n+\n+    /**\n+     * Constructs {@link SerialFuture} with a supplied {@link Executor}.\n+     * @param executor An {@link Executor} to execute asynchronous actions.\n+     */\n+    public SerialFuture(@Nullable Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    /**\n+     * Constructs {@link SerialFuture}.\n+     */\n+    public SerialFuture() {\n+        executor = null;\n+    }\n+\n+    /**\n+     * Executes submitted {@link Callable} action asynchronously in sequence.\n+     * @param action An asynchronous {@link Callable} action to be executed in sequence.\n+     *               It returns {@link CompletionStage} that produces the final result when the action\n+     *               completes.\n+     * @return Returns a new {@link CompletionStage} with the same result or exception as the {@code action},\n+     *         that executes the given action when this stage completes.\n+     */\n+    public synchronized <V> CompletionStage<V> executeAsync(Callable<CompletionStage<V>> action) {\n+        final CompletableFuture<V> result = new CompletableFuture<>();\n+        actions.add(() -> {\n+            final CompletionStage<V> future;\n+            try {\n+                future = action.call();\n+            } catch (Exception e) {\n+                result.completeExceptionally(Exceptions.peel(e));\n+                executeNext();\n+                return;\n+            }\n+            future.whenComplete((v, ex) -> {\n+                if (ex == null) {\n+                    result.complete(v);\n+                } else {\n+                    result.completeExceptionally(ex);\n+                }\n+                executeNext();\n+            });\n+        });\n+\n+        if (active == null) {\n+            executeNext();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Calls submitted {@link Callable} action asynchronously in sequence.\n+     * @param action A {@link Callable} action to be called asynchronously in sequence.\n+     *               It returns that produces the final result of computation.\n+     * @return Returns a new {@link CompletionStage} with the same result or exception as the {@code action},\n+     *         that executes the given action when this stage completes.\n+     */\n+    public synchronized <V> CompletionStage<V> callAsync(Callable<V> action) {\n+        final CompletableFuture<V> result = new CompletableFuture<>();\n+        actions.add(() -> {\n+            try {\n+                result.complete(action.call());\n+                executeNext();\n+            } catch (Exception e) {\n+                result.completeExceptionally(Exceptions.peel(e));\n+                executeNext();\n+            }", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ0MDc0OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471440748", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-08-17T12:21:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3MDc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3MTIxMA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469271210", "bodyText": "Catch Throwable, since nobody will probably catch when Error is thrown here?", "author": "trustin", "createdAt": "2020-08-12T13:46:18Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/SerialFuture.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * Executes submitted {@link Callable} actions asynchronously in sequence.\n+ */\n+public class SerialFuture {\n+\n+    private final Queue<Runnable> actions = new LinkedList<>();\n+\n+    @Nullable\n+    private Runnable active;\n+\n+    @Nullable\n+    Executor executor;\n+\n+    /**\n+     * Constructs {@link SerialFuture} with a supplied {@link Executor}.\n+     * @param executor An {@link Executor} to execute asynchronous actions.\n+     */\n+    public SerialFuture(@Nullable Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    /**\n+     * Constructs {@link SerialFuture}.\n+     */\n+    public SerialFuture() {\n+        executor = null;\n+    }\n+\n+    /**\n+     * Executes submitted {@link Callable} action asynchronously in sequence.\n+     * @param action An asynchronous {@link Callable} action to be executed in sequence.\n+     *               It returns {@link CompletionStage} that produces the final result when the action\n+     *               completes.\n+     * @return Returns a new {@link CompletionStage} with the same result or exception as the {@code action},\n+     *         that executes the given action when this stage completes.\n+     */\n+    public synchronized <V> CompletionStage<V> executeAsync(Callable<CompletionStage<V>> action) {\n+        final CompletableFuture<V> result = new CompletableFuture<>();\n+        actions.add(() -> {\n+            final CompletionStage<V> future;\n+            try {\n+                future = action.call();\n+            } catch (Exception e) {", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ0MTQzMg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471441432", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-08-17T12:22:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3MTIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3MjE3MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469272170", "bodyText": "How about accepting URI when constructing this exception and returning a URI?", "author": "trustin", "createdAt": "2020-08-12T13:47:41Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/TokenRequestException.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A common token request exception type.\n+ */\n+public class TokenRequestException extends RuntimeException {\n+\n+  private static final long serialVersionUID = 3324433572773111913L;\n+\n+  private static final TokenRequestExceptionBuilder BUILDER = new TokenRequestExceptionBuilder();\n+\n+  /**\n+   * Returns a {@link TokenRequestExceptionBuilder} to build error-specific types\n+   * of {@link TokenRequestException}.\n+   */\n+  public static TokenRequestExceptionBuilder builder() {\n+    return BUILDER;\n+  }\n+\n+  @Nullable\n+  private final String errorUri;\n+\n+  /**\n+   * Constructs a new {@link TokenRequestException} using {@code errorDescription} and {@code errorUri}.\n+   * @param errorDescription OPTIONAL. Human-readable ASCII [USASCII] text providing additional information,\n+   *                         used to assist the client developer in understanding the error that occurred.\n+   *                         Values for the {@code errorDescription} parameter MUST NOT include\n+   *                         characters outside the set {@code %x20-21} / {@code %x23-5B} / {@code %x5D-7E}.\n+   * @param errorUri OPTIONAL. A URI identifying a human-readable web page with information about the error,\n+   *                 used to provide the client developer with additional information about the error.\n+   *                 Values for the {@code errorUri} parameter MUST conform to the URI-reference syntax and\n+   *                 thus MUST NOT include characters outside\n+   *                 the set {@code %x21} / {@code %x23-5B} / {@code %x5D-7E}.\n+   */\n+  public TokenRequestException(String errorDescription, @Nullable String errorUri) {\n+    super(errorDescription);\n+    this.errorUri = errorUri;\n+  }\n+\n+  /**\n+   * Constructs a new {@link TokenRequestException} using {@code errorDescription} and {@code errorUri}.\n+   * @param errorDescription OPTIONAL. Human-readable ASCII [USASCII] text providing additional information,\n+   *                         used to assist the client developer in understanding the error that occurred.\n+   *                         Values for the {@code errorDescription} parameter MUST NOT include\n+   *                         characters outside the set {@code %x20-21} / {@code %x23-5B} / {@code %x5D-7E}.\n+   * @param errorUri OPTIONAL. A URI identifying a human-readable web page with information about the error,\n+   *                 used to provide the client developer with additional information about the error.\n+   *                 Values for the {@code errorUri} parameter MUST conform to the URI-reference syntax and\n+   *                 thus MUST NOT include characters outside\n+   *                 the set {@code %x21} / {@code %x23-5B} / {@code %x5D-7E}.\n+   * @param cause the cause (which is saved for later retrieval by the {@link #getCause()} method).\n+   *              (A {@code null} value is permitted, and indicates that the cause is nonexistent or unknown.)\n+   */\n+  public TokenRequestException(String errorDescription, @Nullable String errorUri, Throwable cause) {\n+    super(errorDescription, cause);\n+    this.errorUri = errorUri;\n+  }\n+\n+  /**\n+   * A URI identifying a human-readable web page with information about the error, used to provide the client\n+   * developer with additional information about the error.\n+   * Values for the {@code errorUri} parameter MUST conform to the URI-reference syntax and thus MUST NOT\n+   * include characters outside the set {@code %x21} / {@code %x23-5B} / {@code %x5D-7E}.\n+   */\n+  @Nullable\n+  public String getErrorUri() {", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ0Mjk2MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471442961", "bodyText": "This URI comes in the error response body (as per the spec). I did not want to parse it. What if it's invalid or corrupt? Then we will fail processing the exception with another exception.", "author": "max904-github", "createdAt": "2020-08-17T12:25:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3MjE3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3MjkzMg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469272932", "bodyText": "Could be made static and moved to TokenRequestException?", "author": "trustin", "createdAt": "2020-08-12T13:48:47Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/TokenRequestExceptionBuilder.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import java.util.LinkedHashMap;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * A builder of a {@link TokenRequestException}.\n+ */\n+public class TokenRequestExceptionBuilder {\n+\n+    private static final String ERROR = \"error\";\n+    private static final String ERROR_DESCRIPTION = \"error_description\";\n+    private static final String ERROR_URI = \"error_uri\";\n+\n+    // RFC6749 (The OAuth 2.0 Authorization Framework) - https://tools.ietf.org/html/rfc6749#section-5.2\n+    private static final String INVALID_REQUEST = \"invalid_request\";\n+    private static final String INVALID_CLIENT = \"invalid_client\";\n+    private static final String INVALID_GRANT = \"invalid_grant\";\n+    private static final String UNAUTHORIZED_CLIENT = \"unauthorized_client\";\n+    private static final String UNSUPPORTED_GRANT_TYPE = \"unsupported_grant_type\";\n+    private static final String INVALID_SCOPE = \"invalid_scope\";\n+\n+    // RFC7009 (OAuth 2.0 Token Revocation) - https://tools.ietf.org/html/rfc7009\n+    private static final String UNSUPPORTED_TOKEN_TYPE = \"unsupported_token_type\";\n+\n+    static final ObjectMapper JSON = new ObjectMapper();\n+    private static final TypeReference<LinkedHashMap<String, String>> MAP_TYPE =\n+            new TypeReference<LinkedHashMap<String, String>>() {};\n+\n+    /**\n+     * Parses {@code JSON} error response body and created a new instance of {@link TokenRequestException}\n+     * using the response data.\n+     * @param rawResponse {@code JSON} formatted error response body.\n+     * @return a new instance of {@link TokenRequestException}\n+     */\n+    public TokenRequestException of(String rawResponse) {", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ0NzQ3Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471447477", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-08-17T12:34:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3MjkzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3NDIxNA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469274214", "bodyText": "getMediaType() or mediaType()?\nCould accept and return MediaType?", "author": "trustin", "createdAt": "2020-08-12T13:50:30Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/UnsupportedMediaTypeException.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+/**\n+ * A response {@code Content-Type} header does not match the expected type.\n+ */\n+public class UnsupportedMediaTypeException extends RuntimeException {\n+\n+    private static final long serialVersionUID = 5350546517834409748L;\n+\n+    private final String mediaType;\n+\n+    /**\n+     * Constructs new {@link UnsupportedMediaTypeException}.\n+     * @param mediaType A {@code Content-Type} of the response.\n+     * @param status An HTTP status of the response.\n+     * @param message A response content\n+     */\n+    public UnsupportedMediaTypeException(String mediaType, String status, @Nullable String message) {\n+        super(join(mediaType, status, message));\n+        this.mediaType = mediaType;\n+    }\n+\n+    /**\n+     * Constructs new {@link UnsupportedMediaTypeException}.\n+     * @param mediaType A {@code Content-Type} of the response.\n+     * @param status An HTTP status of the response.\n+     * @param message A response content\n+     * @param cause the cause (which is saved for later retrieval by the {@link #getCause()} method).\n+     *              (A {@code null} value is permitted, and indicates that the cause is nonexistent or unknown.)\n+     */\n+    public UnsupportedMediaTypeException(String mediaType, String status, @Nullable String message,\n+                                         @Nullable Throwable cause) {\n+        super(join(mediaType, status, message), cause);\n+        this.mediaType = mediaType;\n+    }\n+\n+    private static String join(String mediaType, String status, @Nullable String message) {\n+        final StringBuilder builder = new StringBuilder();\n+        builder.append(status).append(\": \")\n+               .append(HttpHeaderNames.CONTENT_TYPE).append(\" - \")\n+               .append(mediaType);\n+        return (message == null) ? builder.toString() : builder.append(\": \").append(message).toString();\n+    }\n+\n+    /**\n+     * A {@code Content-Type} of the response.\n+     */\n+    public String getMediaType() {", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ0ODAzOQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471448039", "bodyText": "Same reason here...\nThis mediaType comes in the error response body (as per the spec). I did not want to parse it. What if it's invalid or corrupt? Then we will fail processing the exception with another exception.", "author": "max904-github", "createdAt": "2020-08-17T12:35:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3NDIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMzYyNg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471903626", "bodyText": "SGTM", "author": "trustin", "createdAt": "2020-08-18T04:16:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3NDIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3NTMyMA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469275320", "bodyText": "How about just accepting and returning an HttpStatus?", "author": "trustin", "createdAt": "2020-08-12T13:52:00Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/UnsupportedResponseException.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A response type in not supported by the given request/response flow.\n+ */\n+public class UnsupportedResponseException extends RuntimeException {\n+\n+    private static final long serialVersionUID = 4982498806675787821L;\n+\n+    private final int statusCode;\n+\n+    /**\n+     * Constructs new {@link UnsupportedMediaTypeException}.\n+     * @param statusCode A status code of the response.\n+     * @param status An HTTP status of the response.\n+     * @param message A response content\n+     */\n+    public UnsupportedResponseException(int statusCode, String status, @Nullable String message) {\n+        super(join(status, message));\n+        this.statusCode = statusCode;\n+    }\n+\n+    /**\n+     * Constructs new {@link UnsupportedMediaTypeException}.\n+     * @param statusCode A status code of the response.\n+     * @param status An HTTP status of the response.\n+     * @param message A response content\n+     * @param cause the cause (which is saved for later retrieval by the {@link #getCause()} method).\n+     *              (A {@code null} value is permitted, and indicates that the cause is nonexistent or unknown.)\n+     */\n+    public UnsupportedResponseException(int statusCode, String status,", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ1MTY0Mw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471451643", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-08-17T12:42:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3NTMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3NTkyNg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r469275926", "bodyText": "Does it make sense to hide this from the public API?", "author": "trustin", "createdAt": "2020-08-12T13:52:47Z", "path": "oauth2/src/main/java/com/linecorp/armeria/server/auth/oauth2/OAuth2AuthorizationFailureHandler.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.auth.oauth2;\n+\n+import static com.linecorp.armeria.server.auth.oauth2.OAuth2TokenIntrospectionAuthorizer.ERROR_CODE;\n+import static com.linecorp.armeria.server.auth.oauth2.OAuth2TokenIntrospectionAuthorizer.ERROR_TYPE;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.auth.AuthFailureHandler;\n+import com.linecorp.armeria.server.auth.AuthServiceBuilder;\n+import com.linecorp.armeria.server.auth.Authorizer;\n+\n+/**\n+ * A callback which is invoked to handle OAuth 2.0 authorization failure indicated by {@link Authorizer}.\n+ * Composes OAuth 2.0 authorization error response in one of the following ways:\n+ * <ul>\n+ *    <li>\n+ *    invalid_request\n+ *          <p>The request is missing a required parameter, includes an\n+ *          unsupported parameter or parameter value, repeats the same\n+ *          parameter, uses more than one method for including an access\n+ *          token, or is otherwise malformed. The resource server SHOULD\n+ *          respond with the HTTP 400 (Bad Request) status code.</p>\n+ *          Example:\n+ *          <pre>{@code\n+ *              HTTP/1.1 400 Bad Request\n+ *              Content-Type: application/json;charset=UTF-8\n+ *              {\"error\":\"unsupported_token_type\"}\n+ *          }</pre>\n+ *    </li>\n+ *    <li>\n+ *    invalid_token\n+ *          <p>The access token provided is expired, revoked, malformed, or\n+ *          invalid for other reasons. The resource SHOULD respond with\n+ *          the HTTP 401 (Unauthorized) status code. The client MAY\n+ *          request a new access token and retry the protected resource\n+ *          request.</p>\n+ *          Example:\n+ *          <pre>{@code\n+ *              HTTP/1.1 401 Unauthorized\n+ *              WWW-Authenticate: Bearer realm=\"example\",\n+ *                                error=\"invalid_token\",\n+ *                                scope=\"read write\"\n+ *          }</pre>\n+ *    </li>\n+ *    <li>\n+ *    insufficient_scope\n+ *          <p>The request requires higher privileges than provided by the\n+ *          access token. The resource server SHOULD respond with the HTTP\n+ *          403 (Forbidden) status code and MAY include the \"scope\"\n+ *          attribute with the scope necessary to access the protected\n+ *          resource.</p>\n+ *          Example:\n+ *          <pre>{@code\n+ *              HTTP/1.1 403 Forbidden\n+ *              Content-Type: application/json;charset=UTF-8\n+ *              {\"error\":\"insufficient_scope\"}\n+ *          }</pre>\n+ *    </li>\n+ * </ul>\n+ *\n+ * @see AuthServiceBuilder#onFailure(AuthFailureHandler)\n+ */\n+public class OAuth2AuthorizationFailureHandler implements AuthFailureHandler {", "originalCommit": "e2eef13ef36d705634355e43cb7c3123382f44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ1Njg2OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471456868", "bodyText": "fixed", "author": "max904-github", "createdAt": "2020-08-17T12:52:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3NTkyNg=="}], "type": "inlineReview"}, {"oid": "c417198fb4cf397ae8ee568015a077f591be3376", "url": "https://github.com/line/armeria/commit/c417198fb4cf397ae8ee568015a077f591be3376", "message": "- review comments by @trustin;", "committedDate": "2020-08-17T15:56:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwNjI0Mw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r471906243", "bodyText": "As I mentioned, the *Request classes in common.auth.oauth2 could be hidden from the public API by moving them to internal.common.auth.oauth2.", "author": "trustin", "createdAt": "2020-08-18T04:27:14Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/AbstractOAuth2Request.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n+\n+/**\n+ * A common abstraction for the requests implementing various OAuth 2.0 request/response flows,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a> and other relevant specifications.\n+ * @param <T> the type of the authorization result.\n+ */\n+public abstract class AbstractOAuth2Request<T> {", "originalCommit": "c417198fb4cf397ae8ee568015a077f591be3376", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5ODI0Mw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r472098243", "bodyText": "moved to internal as suggested", "author": "max904-github", "createdAt": "2020-08-18T11:10:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwNjI0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjExMDI4OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r472110288", "bodyText": "Thanks, @max904-github. Will review again soon.", "author": "trustin", "createdAt": "2020-08-18T11:34:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwNjI0Mw=="}], "type": "inlineReview"}, {"oid": "49ea469bfaad45281267252a0f1c2f29df6434f6", "url": "https://github.com/line/armeria/commit/49ea469bfaad45281267252a0f1c2f29df6434f6", "message": "- more review comments by @trustin:\n- introduced \"internal\" packages and moved *Request classes there;\n- introduced OAuth2Constants class;\n- replaced CompletableFuture.whenComplete() with CompletableFuture.handle();", "committedDate": "2020-08-18T13:10:35Z", "type": "commit"}, {"oid": "cc067f420001186399ba8247c9c17986d35ff6a6", "url": "https://github.com/line/armeria/commit/cc067f420001186399ba8247c9c17986d35ff6a6", "message": "- more review comments by @trustin:\n- shared common ObjectMapper for JSON parsing;", "committedDate": "2020-08-18T13:28:16Z", "type": "commit"}, {"oid": "6892ba1a7e1d82c89ed46b4ad920bd39f941fa25", "url": "https://github.com/line/armeria/commit/6892ba1a7e1d82c89ed46b4ad920bd39f941fa25", "message": "- replaced ServerRule -> ServerExtension in the unit tests;", "committedDate": "2020-08-18T13:46:21Z", "type": "commit"}, {"oid": "03990d397ebec1d726d13088485e91f01ec7e50d", "url": "https://github.com/line/armeria/commit/03990d397ebec1d726d13088485e91f01ec7e50d", "message": "- junit refactoring;", "committedDate": "2020-08-18T13:58:28Z", "type": "commit"}, {"oid": "140357b0ca349368c992e2d002d708450f03f9e5", "url": "https://github.com/line/armeria/commit/140357b0ca349368c992e2d002d708450f03f9e5", "message": "Merge branch 'master' into oauth2-issue2268", "committedDate": "2020-08-19T01:28:05Z", "type": "commit"}, {"oid": "e93caa314f04eff006b9baf1cda2686bc965da55", "url": "https://github.com/line/armeria/commit/e93caa314f04eff006b9baf1cda2686bc965da55", "message": "- fixed build errors related with relocated classes in 1.0;", "committedDate": "2020-09-07T08:29:05Z", "type": "commit"}, {"oid": "85d92d51d2a0dc70eac909d6db3a76bdb63e473b", "url": "https://github.com/line/armeria/commit/85d92d51d2a0dc70eac909d6db3a76bdb63e473b", "message": "review comments by @trustin:\n- added Authorizer.successHandler() and Authorizer.failureHandler() methods and set those no NULL by default;\n- eliminated OAuth2TokenIntrospectionAuthorizer.asAuthService() and OAuth2TokenIntrospectionAuthorizer.asDecorator() methods.", "committedDate": "2020-10-20T12:04:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAzOTU4Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r515039586", "bodyText": "What would happen if a user adds more than one authorizer? Wouldn't each authorizer need to have its own success/failure handler pair?", "author": "trustin", "createdAt": "2020-10-30T11:43:22Z", "path": "core/src/main/java/com/linecorp/armeria/server/auth/AuthServiceBuilder.java", "diffHunk": "@@ -140,6 +141,7 @@ public AuthServiceBuilder addOAuth2(Authorizer<? super OAuth2Token> authorizer,\n             return authorizer.authorize(ctx, token);\n         };\n         add(requestAuthorizer);\n+        setAuthorizerHandlers(authorizer);", "originalCommit": "85d92d51d2a0dc70eac909d6db3a76bdb63e473b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkyMTg2NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r540921864", "bodyText": "I don't think it makes sense or even possible to chain success/failure handlers. Unlike authorizers, which represent decision making points, handlers represent concrete actions, like AuthSuccessHandler successHandler = Service::serve;. How can this action get chained or replicated?\nThe problem is that for some protocols like OAuth 2 the action (concretely failureHandler) is bound to the decision making. That's why it made sense to add handlers to an Authorizer as you've suggested. However, Authorizer chaining brings ambiguity to that.\nIMHO Authorizer chaining is quite ambiguous and dangerous even without that, at least in the way the logic implemented right now - it goes against some basic authorization principles. Solution implemented today represents a permissive mechanism where two conflicting policies (represented by Authorizers) may permit the client even if one of the policies explicitly says NO. It should work the other way around - it should permit the client only if ALL policies said YES.\nDo you know of the use cases when it's required to have authorizers chaining? Could it be solved via multiple AuthServices instead?", "author": "max904-github", "createdAt": "2020-12-11T12:45:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAzOTU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2Mjg4NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r542162885", "bodyText": "Hey, thanks for the feedback and sorry for giving a poor suggestion.\nThe authorizer chaining was introduced to handle the case where a service has to support different protocols, e.g. OAuth1, OAuth2 and authorize by source IP address, etc.\nI think it can't be solved by having multiple AuthServices in the pipeline because the first AuthService will have to authorize the request to make the second AuthService evaluated.\nIdeally, we could change the return value of Authorizer.authorize() so it can represent one of the following states:\n\nAUTHORIZED - successHandler will handle the request.\nUNAUTHORIZED - failureHandler will handle the request.\nNEXT - ask the next authorizer. If reached at the last authorizer, failureHandler will handle the request.\n\nHowever, we can't do this due to backward compatibility.\nHow about doing this until we release Armeria 2 (maybe late 2021?) as a compromise?\n\nWhen authorizer returns true, use the authorizer's successHandler.\nWhen authorizer returns false, try the next authorizer. (i.e. retain the current AuthService behavior.)\nWhen the last authorizer returns false, use the last authorizer's failureHandler.", "author": "trustin", "createdAt": "2020-12-14T07:25:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAzOTU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI4OTM2OQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r542289369", "bodyText": "Sure, let me think about it. However, I see some problem immediately - this will break the tie between the Authorizer and Success/FailureHandlers. Following your proposal, in case when there are two Authorizers, then AuthService could engage SuccessHandler associated with the first Authorizer and engage FailureHandler associated with the second Authorizer. It could be messy. If we keep Authorizer chaining, we have to disassociate handlers from the Authorizers (i.e. revert the last changes I did).", "author": "max904-github", "createdAt": "2020-12-14T10:50:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAzOTU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwNDU0MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r542304540", "bodyText": "Yeah, I thought about that problem where only the last failure handler will be used. I see a few ways to address this:\n\nDocument the behavior (only the last authorizer's failureHandler will be used).\nMake sure all authorizers except the last one did not override failureHandler() method. Raise an exception if not.\nRevert the change that added successHandler() and failureHandler().\n\nBut we need to how we can make OAuth2TokenIntrospectionAuthorizer to configure AuthServiceBuilder. It'd be nice if AuthService.onFailure() is automatically called when OAuth2TokenIntrospectionAuthorizer for example.\n\n\n\nWhich would be the best?", "author": "trustin", "createdAt": "2020-12-14T11:14:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAzOTU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc1ODQzNg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r546758436", "bodyText": "I think if we want to keep Authorizer chaining in place, we should make following adjustments:\nAs you pointed, ideally, we should change Authorizer.authorize() signature to return {AUTHORIZED, UNAUTHORIZED, NEXT}. However, I\u2019m not sure when would the authorizer return NEXT really \u2013 as you know most on the authorization systems always return some kind of opaque NO_ACCESS, no matter whether the user specified wrong credentials, has insufficient rights or simply absent in the authorization DB altogether.\nTherefore, we should change chaining semantics from \u201cgoing next on failure\u201d to \u201cgoing next on success\u201d. I.e. reverse the current AuthService behavior:\n\nWhen authorizer returns false, use the authorizer's failure handler.\nWhen authorizer returns true, try the next authorizer.\nReaching the end of the success chain engages common success handler.\n\nThis will require minimal changes to the API, however, the chaining will work differently.\nOn the implementation side the AuthService will still have common success and default failure handlers. Each Authorizer may be permitted to define only custom failure handler (which will serve as authorization sequence terminator). If an Authorizer provides its own handler, the AuthService will use that to terminate, but if the Authorizer does not provide a custom handler, the AuthService will use the default one.\nWhat do you think?", "author": "max904-github", "createdAt": "2020-12-21T15:09:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAzOTU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc4Mjc3Mw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r546782773", "bodyText": "We could make it even more complex and introduce a \u201cchaining mode\u201d for the chain to work: {AND, OR}. The Authorizer would remain binary (true/false), but the AuthService to engage next Authorizer and terminate the sequence either on failure (AND) or on success (OR). The AND case I have described above. The OR case would look like the following:\nThe AuthService invokes the first Authorizer form the chain. If it succeeds, it terminates the chain and invokes common success handler. If it fails, the AuthService tries the next Authorizer, and so on. At the end of the chain, if none of the Authroizers returned success, the AuthService selects the Authorizer to handle the failure handler (typically first or last, or even designated one). The AuthService always engages matching failure handler from the selected Authorizer. If an authorizer does not define a failure handler, the AuthService selects the one that does or engages default failure handler.\nI think AND mode should be the default one, as it matches security practices better. OR mode should be specified explicitly.\nTo summarize the interface changes:\n\nAuthService will have successHandler as before and existing failureHandler will rename to defaultFailureHandler.\nAuthService will have a chainMode that defaults to AND.\nAuthService will have an additional configuration on which Authorizer to select in OR mode with following policies: {FIRST, LAST, FIRST_WITH_HANDLER, LAST_WITH_HANDLER, SELECTED}.\nAuthorizer will have failureHandler with default implementation to NULL, and will no longer have successHandler.", "author": "max904-github", "createdAt": "2020-12-21T15:51:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAzOTU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzE4NTc4Mw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r547185783", "bodyText": "Thanks for the idea. I have a few comments.\n\nAuthService will have a chainMode that defaults to AND.\n\nI guess we can't default to AND in this case because it will be a breaking change, because AuthService and Authrizer are unfortunately (?) not unstable. For now, could we just stay with the current behavior of 'success if true, next if false'? I think it's fine as long as a user has one authorizer. We can redesign this properly in Armeria 2 or defer the changes like introducing chainMode, unless this problem blocks you from implementing OAuth2. This way, we could merge your work sooner without making too much changes in the core API.\n\nAuthorizer will have failureHandler with default implementation to NULL, and will no longer have successHandler.\n\nWouldn't it be better having successHandler for each authorizer? An authorizer might want to perform some action specific to its corresponding auth mechanism, e.g. updating metrics, redirecting to an intermediary page, etc.", "author": "trustin", "createdAt": "2020-12-22T10:07:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAzOTU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzgyMTQ2NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r547821465", "bodyText": "Ok, I will implement it in the following way \"for now\" following OR mode.\nThe AuthService invokes the first Authorizer form the chain. If it succeeds, it terminates the chain and invokes associated successHandler. If successHandler not defined for given Authorizer, it will invoke default/common successHandler. If the Authorizer fails (returns false), the AuthService tries the next Authorizer, and so on. At the end of the chain, if none of the Authroizers returned success, the AuthService selects the Authorizer to handle the failureHandler (LAST_WITH_HANDLER - the last one that has specific failureHandler defined). The AuthService always engages matching failureHandler from the selected Authorizer. If none of the Authorizers define a failureHandler, the AuthService selects engages default/common failureHandler.\nSummary of the interface changes:\n\nAuthService will have successHandler and failureHandler as before - these will play a role of default/common handlers.\nAuthService will have LAST_WITH_HANDLER Authorizer selection strategy hardcoded.\nAuthorizer will have failureHandler and successHandler set to NULL by default, as before.\n\nThis solution will be fully backward compatible and the new changes will mostly take place in AuthService#serve() method.", "author": "max904-github", "createdAt": "2020-12-23T08:52:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAzOTU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM3ODMyMQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r548378321", "bodyText": "Excellent. Thank you so much for your understanding. I agree that this is not ideal but it will help us move forward. Looking forward to this PR being merged and your follow-up PRs! \ud83d\ude47", "author": "trustin", "createdAt": "2020-12-24T04:35:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAzOTU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDc5MDk4NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r550790985", "bodyText": "Pushed the requested changes as described above. Had to extract chaining logic into dedicated AuthorizerChain and extract HttpRequest token authorization into dedicated DelegatingHttpRequestAuthorizer classes. Made a minor correction to existing test case (AuthorizerTest#orElseToString()).\nSorry for the delays - got lot's of work lately.", "author": "max904-github", "createdAt": "2021-01-01T18:00:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAzOTU4Ng=="}], "type": "inlineReview"}, {"oid": "0f28657a06d6af6ced09d7191746aedfb3acc93b", "url": "https://github.com/line/armeria/commit/0f28657a06d6af6ced09d7191746aedfb3acc93b", "message": "Merge branch 'master' into oauth2-issue2268", "committedDate": "2020-11-26T05:15:22Z", "type": "commit"}, {"oid": "dd0a7906c377dfa3b6c130b59aaf723f8d368be6", "url": "https://github.com/line/armeria/commit/dd0a7906c377dfa3b6c130b59aaf723f8d368be6", "message": "Review comments by @trustin - solution for Authorizer chaining problem:\n\nThe AuthService invokes the first Authorizer form the chain. If it succeeds, it terminates the chain and invokes associated successHandler. If successHandler not defined for given Authorizer, it will invoke default/common successHandler. If the Authorizer fails (returns false), the AuthService tries the next Authorizer, and so on. At the end of the chain, if none of the Authroizers returned success, the AuthService selects the Authorizer to handle the failureHandler (LAST_WITH_HANDLER - the last one that has specific failureHandler defined). The AuthService always engages matching failureHandler from the selected Authorizer. If none of the Authorizers define a failureHandler, the AuthService selects engages default/common failureHandler.\n\nSummary of the interface changes:\n\n- AuthService has successHandler and failureHandler as before - these play a role of default/common handlers.\n- AuthService has LAST_WITH_HANDLER Authorizer selection strategy hardcoded.\n- Authorizer has failureHandler and successHandler set to NULL by default, as before.\n- extracted Authorizer chaining logic into a dedicated class AuthorizerChain;\n- extracted HttpRequest authorization logic into a separate class DelegatingHttpRequestAuthorizer.\n\nThis solution is fully backward compatible and the new changes mostly applied to AuthService#serve() and AuthServiceBuilder.", "committedDate": "2021-01-01T17:55:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTczODUyMw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r551738523", "bodyText": "Could use @ParameterizedTest with @CsvSource?", "author": "trustin", "createdAt": "2021-01-05T06:23:56Z", "path": "core/src/test/java/com/linecorp/armeria/server/auth/AuthorizerTest.java", "diffHunk": "@@ -126,17 +129,71 @@ public void orElseSecond() {\n \n     @Test\n     public void orElseToString() {\n-        final Authorizer<Object> a = new AuthorizerWithToString(\"A\");\n-        final Authorizer<Object> b = new AuthorizerWithToString(\"B\");\n-        final Authorizer<Object> c = new AuthorizerWithToString(\"C\");\n-        final Authorizer<Object> d = new AuthorizerWithToString(\"D\");\n+        final Authorizer<Object> a = new NamedAuthorizer<>(\"A\");\n+        final Authorizer<Object> b = new NamedAuthorizer<>(\"B\");\n+        final Authorizer<Object> c = new NamedAuthorizer<>(\"C\");\n+        final Authorizer<Object> d = new NamedAuthorizer<>(\"D\");\n+        final Authorizer<Object> e = new NamedAuthorizer<>(\"E\");\n \n         // A + B\n         assertThat(a.orElse(b).toString()).isEqualTo(\"[A, B]\");\n-        // A + B\n+        // A + B + C\n         assertThat(a.orElse(b).orElse(c).toString()).isEqualTo(\"[A, B, C]\");\n-        // (A + B) + (C + D)\n-        assertThat(a.orElse(b).orElse(c.orElse(d)).toString()).isEqualTo(\"[A, B, C, D]\");\n+        // A + B + (C + D) + E\n+        assertThat(a.orElse(b).orElse(c.orElse(d)).orElse(e).toString()).isEqualTo(\"[A, B, [C, D], E]\");\n+    }\n+\n+    @Test\n+    public void orElseHandler() {", "originalCommit": "dd0a7906c377dfa3b6c130b59aaf723f8d368be6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2NzU2MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552067561", "bodyText": "Done. Used @MethodSource instead of @CsvSource since JUnit 5 lacks array parameter conversions. Also migrated the unit test fully to JUnit 5 as @ParameterizedTest was in conflict with Junit 4.", "author": "max904-github", "createdAt": "2021-01-05T17:06:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTczODUyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQyNjM0Mg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552426342", "bodyText": "Thank you for migration, @max904-github \ud83d\ude47", "author": "trustin", "createdAt": "2021-01-06T08:10:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTczODUyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc0MDEwMg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r551740102", "bodyText": "How about accepting a list of Authorizers and making an immutable copy of the list rather than keeping a mutable list?", "author": "trustin", "createdAt": "2021-01-05T06:29:04Z", "path": "core/src/main/java/com/linecorp/armeria/server/auth/AuthorizerChain.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.auth;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * Chains multiple {@link Authorizer}s together into a single {@link Authorizer}.\n+ * Utilizes {@link AuthorizerSelectionStrategy} to select corresponding {@link AuthFailureHandler}.\n+ */\n+final class AuthorizerChain<T> implements Authorizer<T> {\n+\n+    enum AuthorizerSelectionStrategy {\n+        /**\n+         * Select a handler provided by the first {@link Authorizer} in the chain.\n+         */\n+        FIRST,\n+        /**\n+         * Select a handler provided by the last {@link Authorizer} in the chain.\n+         */\n+        LAST,\n+        /**\n+         * Select a handler provided by the first {@link Authorizer} in the chain that has an associated\n+         * handler actually defined (non-NULL).\n+         */\n+        FIRST_WITH_HANDLER,\n+        /**\n+         * Select a handler provided by the last {@link Authorizer} in the chain that has an associated\n+         * handler actually defined (non-NULL).\n+         */\n+        LAST_WITH_HANDLER\n+    }\n+\n+    private final LinkedList<Authorizer<T>> authorizers = new LinkedList<>();\n+    private final AuthorizerSelectionStrategy selectionStrategy;\n+    @Nullable\n+    private AuthSuccessHandler successHandler;\n+    @Nullable\n+    private AuthFailureHandler failureHandler;\n+\n+    AuthorizerChain(Authorizer<T> firstAuthorizer, AuthorizerSelectionStrategy selectionStrategy) {", "originalCommit": "dd0a7906c377dfa3b6c130b59aaf723f8d368be6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2ODQ1NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552068454", "bodyText": "Done. However, note that AuthorizerChain still won't be immutable due to dynamic handlers assignment.", "author": "max904-github", "createdAt": "2021-01-05T17:07:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc0MDEwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc0MDY3NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r551740674", "bodyText": "We should not update the internal state of this class here. Could we return a new AuthorizerChain with a newly constructed list? e.g.\nfinal List<Authorizer<T>> newAuthorizers =\n    ImmutableList.builder()\n                 .addAll(authorizers)\n                 .add(requireNonNull(nextAuthorizer, \"nextAuthorizer\")\n                 .build();\nreturn new AuthorizerChain<>(newAuthorizers, ...);", "author": "trustin", "createdAt": "2021-01-05T06:31:08Z", "path": "core/src/main/java/com/linecorp/armeria/server/auth/AuthorizerChain.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.auth;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * Chains multiple {@link Authorizer}s together into a single {@link Authorizer}.\n+ * Utilizes {@link AuthorizerSelectionStrategy} to select corresponding {@link AuthFailureHandler}.\n+ */\n+final class AuthorizerChain<T> implements Authorizer<T> {\n+\n+    enum AuthorizerSelectionStrategy {\n+        /**\n+         * Select a handler provided by the first {@link Authorizer} in the chain.\n+         */\n+        FIRST,\n+        /**\n+         * Select a handler provided by the last {@link Authorizer} in the chain.\n+         */\n+        LAST,\n+        /**\n+         * Select a handler provided by the first {@link Authorizer} in the chain that has an associated\n+         * handler actually defined (non-NULL).\n+         */\n+        FIRST_WITH_HANDLER,\n+        /**\n+         * Select a handler provided by the last {@link Authorizer} in the chain that has an associated\n+         * handler actually defined (non-NULL).\n+         */\n+        LAST_WITH_HANDLER\n+    }\n+\n+    private final LinkedList<Authorizer<T>> authorizers = new LinkedList<>();\n+    private final AuthorizerSelectionStrategy selectionStrategy;\n+    @Nullable\n+    private AuthSuccessHandler successHandler;\n+    @Nullable\n+    private AuthFailureHandler failureHandler;\n+\n+    AuthorizerChain(Authorizer<T> firstAuthorizer, AuthorizerSelectionStrategy selectionStrategy) {\n+        authorizers.add(requireNonNull(firstAuthorizer, \"firstAuthorizer\"));\n+        this.selectionStrategy = requireNonNull(selectionStrategy, \"selectionStrategy\");\n+        if (selectionStrategy == AuthorizerSelectionStrategy.FIRST) {\n+            // this could be NULL\n+            failureHandler = authorizers.getFirst().failureHandler();\n+        }\n+    }\n+\n+    /**\n+     * Adds a new {@link Authorizer} to the chain.\n+     * @return an original {@link AuthorizerChain} instance with added {@link Authorizer}.\n+     */\n+    @Override\n+    public Authorizer<T> orElse(Authorizer<T> nextAuthorizer) {\n+        authorizers.add(requireNonNull(nextAuthorizer, \"nextAuthorizer\"));", "originalCommit": "dd0a7906c377dfa3b6c130b59aaf723f8d368be6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2ODY0Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552068646", "bodyText": "Done. However, note that AuthorizerChain still won't be immutable due to dynamic handlers assignment.", "author": "max904-github", "createdAt": "2021-01-05T17:08:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc0MDY3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc0MjM3MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r551742371", "bodyText": "(Global comment) Shall we remove Async suffix from all async operations? Armeria operations are usually asynchronous anyway. \ud83d\ude04", "author": "trustin", "createdAt": "2021-01-05T06:36:45Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractOAuth2AuthorizationGrant.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken;\n+import com.linecorp.armeria.common.auth.oauth2.InvalidClientException;\n+import com.linecorp.armeria.common.auth.oauth2.TokenRequestException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedMediaTypeException;\n+import com.linecorp.armeria.internal.client.auth.oauth2.RefreshAccessTokenRequest;\n+\n+/**\n+ * Base implementation of OAuth 2.0 Access Token Grant flow to obtain Access Token.\n+ * Implements Access Token loading, storing and refreshing.\n+ */\n+abstract class AbstractOAuth2AuthorizationGrant implements OAuth2AuthorizationGrant {\n+\n+    private final RefreshAccessTokenRequest refreshRequest;\n+\n+    private final Duration refreshBefore;\n+\n+    /**\n+     * Holds a token object and facilitates its lifecycle.\n+     */\n+    private final TokenLifecycleManager<GrantedOAuth2AccessToken> tokenManager;\n+\n+    AbstractOAuth2AuthorizationGrant(RefreshAccessTokenRequest refreshRequest, Duration refreshBefore,\n+                                     @Nullable Supplier<? extends GrantedOAuth2AccessToken> tokenSupplier,\n+                                     @Nullable Consumer<? super GrantedOAuth2AccessToken> tokenConsumer,\n+                                     @Nullable Executor executor) {\n+        this.refreshRequest = requireNonNull(refreshRequest, \"refreshRequest\");\n+        this.refreshBefore = requireNonNull(refreshBefore, \"refreshBefore\");\n+        tokenManager = new TokenLifecycleManager<>(this::isValid, this::canRefresh,\n+                                                   this::shallObtainInsteadOfUpdate,\n+                                                   this::obtainAccessTokenAsync, this::refreshAccessTokenAsync,\n+                                                   tokenSupplier, tokenConsumer, executor);\n+    }\n+\n+    /**\n+     * Tests the token for validity at the given {@link Instant} time.\n+     */\n+    private boolean isValid(GrantedOAuth2AccessToken token, Instant now) {\n+        return token.isValid(now.plus(refreshBefore));\n+    }\n+\n+    /**\n+     * Tests whether the token object can be refreshed or re-obtained.\n+     */\n+    private boolean canRefresh(GrantedOAuth2AccessToken token) {\n+        return token.refreshToken() != null;\n+    }\n+\n+    /**\n+     * Tests whether given {@link Throwable} indicates that the token shall be re-obtained\n+     * after the refresh operation failure.\n+     */\n+    private boolean shallObtainInsteadOfUpdate(Throwable throwable) {\n+        return throwable instanceof TokenRequestException;\n+    }\n+\n+    /**\n+     * Refreshes access token.\n+     */\n+    private CompletionStage<GrantedOAuth2AccessToken> refreshAccessTokenAsync(GrantedOAuth2AccessToken token) {", "originalCommit": "dd0a7906c377dfa3b6c130b59aaf723f8d368be6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2OTY3NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552069675", "bodyText": "Done", "author": "max904-github", "createdAt": "2021-01-05T17:09:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc0MjM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc0MjQ0MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r551742440", "bodyText": "(Global comment) Could you make all protected methods in package-private classes package-private?", "author": "trustin", "createdAt": "2021-01-05T06:36:56Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractOAuth2AuthorizationGrant.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken;\n+import com.linecorp.armeria.common.auth.oauth2.InvalidClientException;\n+import com.linecorp.armeria.common.auth.oauth2.TokenRequestException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedMediaTypeException;\n+import com.linecorp.armeria.internal.client.auth.oauth2.RefreshAccessTokenRequest;\n+\n+/**\n+ * Base implementation of OAuth 2.0 Access Token Grant flow to obtain Access Token.\n+ * Implements Access Token loading, storing and refreshing.\n+ */\n+abstract class AbstractOAuth2AuthorizationGrant implements OAuth2AuthorizationGrant {\n+\n+    private final RefreshAccessTokenRequest refreshRequest;\n+\n+    private final Duration refreshBefore;\n+\n+    /**\n+     * Holds a token object and facilitates its lifecycle.\n+     */\n+    private final TokenLifecycleManager<GrantedOAuth2AccessToken> tokenManager;\n+\n+    AbstractOAuth2AuthorizationGrant(RefreshAccessTokenRequest refreshRequest, Duration refreshBefore,\n+                                     @Nullable Supplier<? extends GrantedOAuth2AccessToken> tokenSupplier,\n+                                     @Nullable Consumer<? super GrantedOAuth2AccessToken> tokenConsumer,\n+                                     @Nullable Executor executor) {\n+        this.refreshRequest = requireNonNull(refreshRequest, \"refreshRequest\");\n+        this.refreshBefore = requireNonNull(refreshBefore, \"refreshBefore\");\n+        tokenManager = new TokenLifecycleManager<>(this::isValid, this::canRefresh,\n+                                                   this::shallObtainInsteadOfUpdate,\n+                                                   this::obtainAccessTokenAsync, this::refreshAccessTokenAsync,\n+                                                   tokenSupplier, tokenConsumer, executor);\n+    }\n+\n+    /**\n+     * Tests the token for validity at the given {@link Instant} time.\n+     */\n+    private boolean isValid(GrantedOAuth2AccessToken token, Instant now) {\n+        return token.isValid(now.plus(refreshBefore));\n+    }\n+\n+    /**\n+     * Tests whether the token object can be refreshed or re-obtained.\n+     */\n+    private boolean canRefresh(GrantedOAuth2AccessToken token) {\n+        return token.refreshToken() != null;\n+    }\n+\n+    /**\n+     * Tests whether given {@link Throwable} indicates that the token shall be re-obtained\n+     * after the refresh operation failure.\n+     */\n+    private boolean shallObtainInsteadOfUpdate(Throwable throwable) {\n+        return throwable instanceof TokenRequestException;\n+    }\n+\n+    /**\n+     * Refreshes access token.\n+     */\n+    private CompletionStage<GrantedOAuth2AccessToken> refreshAccessTokenAsync(GrantedOAuth2AccessToken token) {\n+        return refreshRequest.make(token);\n+    }\n+\n+    /**\n+     * Obtains a new access token from the token end-point asynchronously.\n+     * @return A {@link CompletableFuture} carrying the requested {@link GrantedOAuth2AccessToken} or an\n+     *         exception, if the request failed.\n+     * @throws TokenRequestException when the endpoint returns {code HTTP 400 (Bad Request)} status and the\n+     *                               response payload contains the details of the error.\n+     * @throws InvalidClientException when the endpoint returns {@code HTTP 401 (Unauthorized)} status, which\n+     *                                typically indicates that client authentication failed (e.g.: unknown\n+     *                                client, no client authentication included, or unsupported authentication\n+     *                                method).\n+     * @throws UnsupportedMediaTypeException if the media type of the response does not match the expected\n+     *                                       (JSON).\n+     */\n+    protected abstract CompletableFuture<GrantedOAuth2AccessToken> obtainAccessTokenAsync(", "originalCommit": "dd0a7906c377dfa3b6c130b59aaf723f8d368be6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMxOTEzNQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552319135", "bodyText": "Done", "author": "max904-github", "createdAt": "2021-01-06T01:51:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc0MjQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc0MzIyNw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r551743227", "bodyText": "(Global comment) Could you add @UnstableApi annotation to all new public classes and all new packages we are introducing in this pull request, so we have some wiggle room when we have to break backward compatibility in future 1.x releases?", "author": "trustin", "createdAt": "2021-01-05T06:39:49Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/OAuth2AuthorizationGrant.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import java.util.concurrent.CompletionStage;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken;\n+\n+/**\n+ * Represents an OAuth 2.0 Access Token Grant flow to obtain Access Token.\n+ */\n+public interface OAuth2AuthorizationGrant {", "originalCommit": "dd0a7906c377dfa3b6c130b59aaf723f8d368be6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3MDA5MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552070090", "bodyText": "Done", "author": "max904-github", "createdAt": "2021-01-05T17:10:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc0MzIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc0MzQzOQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r551743439", "bodyText": "(Global comment) final in all public classes that are not intended for extension.", "author": "trustin", "createdAt": "2021-01-05T06:40:44Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/OAuth2Client.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.function.Function;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.HttpClient;\n+import com.linecorp.armeria.client.SimpleDecoratingHttpClient;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * Decorates a {@link HttpClient} with an OAuth 2.0 Authorization Grant flow.\n+ */\n+public class OAuth2Client extends SimpleDecoratingHttpClient {", "originalCommit": "dd0a7906c377dfa3b6c130b59aaf723f8d368be6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3MDE3MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552070171", "bodyText": "Done", "author": "max904-github", "createdAt": "2021-01-05T17:10:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc0MzQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc0NDg2MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r551744860", "bodyText": "(Global comment) Please add @UnstableApi to all new packages, including the internal ones.", "author": "trustin", "createdAt": "2021-01-05T06:45:39Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/package-info.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+/**\n+ * Client-side <a href=\"https://en.wikipedia.org/wiki/OAuth#OAuth_2.0\">OAuth 2.0</a> implementation artifacts.\n+ */\n+@NonNullByDefault\n+package com.linecorp.armeria.client.auth.oauth2;", "originalCommit": "dd0a7906c377dfa3b6c130b59aaf723f8d368be6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3MDQxOA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552070418", "bodyText": "Done", "author": "max904-github", "createdAt": "2021-01-05T17:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc0NDg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc0NjE1OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r551746158", "bodyText": "(Global comment)\n\n4-space indentation?\nPlease let me know if you forked any existing source code when writing this pull request. (Thought it's possible since these classes have different indentation.) If you forked something, we need to make it clear that we did.", "author": "trustin", "createdAt": "2021-01-05T06:49:51Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/InvalidClientException.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Client authentication failed (e.g., unknown client, no client authentication included, or\n+ * unsupported authentication method). The authorization server MAY return an HTTP 401\n+ * (Unauthorized) status code to indicate which HTTP authentication schemes are supported. If the\n+ * client attempted to authenticate via the \"Authorization\" request header field, the authorization\n+ * server MUST respond with an HTTP 401 (Unauthorized) status code and include the\n+ * \"WWW-Authenticate\" response header field matching the authentication scheme used by the client.\n+ */\n+public class InvalidClientException extends TokenRequestException {\n+\n+  private static final long serialVersionUID = -1894934023468438715L;", "originalCommit": "dd0a7906c377dfa3b6c130b59aaf723f8d368be6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3MTgyNQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552071825", "bodyText": "Fixed. The original prototype used Google style, that's why 2-spaces. The prototype is being ported (with somewhat significant changes), so it's not really a fork. No need to preserve the originals after the porting finished.", "author": "max904-github", "createdAt": "2021-01-05T17:13:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc0NjE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc0NzA1NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r551747055", "bodyText": "Could just do rawResponse().hashCode() because rawResponse() will never return null.", "author": "trustin", "createdAt": "2021-01-05T06:53:00Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/OAuth2TokenDescriptor.java", "diffHunk": "@@ -0,0 +1,510 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.ACTIVE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.AUDIENCE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.CLIENT_ID;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.EXPIRES_AT;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.ISSUED_AT;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.ISSUER;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.JWT_ID;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.NOT_BEFORE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.SCOPE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.SUBJECT;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.TOKEN_TYPE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.USER_NAME;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.ResponseParserUtil.JSON;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants;\n+\n+/**\n+ * Defines a structure of the Token Introspection Response, as per\n+ * <a href=\"https://tools.ietf.org/html/rfc7662#section-2.2\">[RFC7662], Section 2.2</a>.\n+ */\n+public class OAuth2TokenDescriptor implements Serializable {\n+\n+    private static final long serialVersionUID = -3976877781134216467L;\n+\n+    /**\n+     * Creates a new {@link OAuth2TokenDescriptor} based on the {@code JSON}-formatted raw response body.\n+     * @param rawResponse {@code JSON}-formatted raw response body.\n+     * @return A new instance of {@link OAuth2TokenDescriptor}.\n+     */\n+    public static OAuth2TokenDescriptor of(String rawResponse) {\n+        return OAuth2TokenDescriptorBuilder.of(rawResponse);\n+    }\n+\n+    /**\n+     * Creates a new {@link OAuth2TokenDescriptorBuilder} to build a new {@link OAuth2TokenDescriptor} and\n+     * supplied it with a value of {@code active} Token Introspection Response field.\n+     * @return A new instance of {@link OAuth2TokenDescriptorBuilder}.\n+     */\n+    public static OAuth2TokenDescriptorBuilder builder(boolean active) {\n+        return new OAuth2TokenDescriptorBuilder(active);\n+    }\n+\n+    static final String SCOPE_SEPARATOR = \" \";\n+\n+    /**\n+     * {@value OAuth2Constants#ACTIVE} Token Introspection Response field,\n+     * REQUIRED. Boolean indicator of whether or not the presented token is currently active. The\n+     * specifics of a token's \"active\" state will vary depending on the implementation of the\n+     * authorization server and the information it keeps about its tokens, but a \"true\" value return\n+     * for the \"active\" property will generally indicate that a given token has been issued by this\n+     * authorization server, has not been revoked by the resource owner, and is within its given time\n+     * window of validity (e.g., after its issuance time and before its expiration time).\n+     */\n+    private final boolean active;\n+\n+    /**\n+     * {@value OAuth2Constants#SCOPE} Token Introspection Response field,\n+     * OPTIONAL. A JSON string containing a space-separated list of scopes associated with this token,\n+     * in the format described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-3.3\">[RFC6749], Section 3.3</a>.\n+     */\n+    @Nullable\n+    private final String scope;\n+\n+    /**\n+     * A {@link Set} of case-sensitive scope strings. The strings are defined by the authorization\n+     * server.\n+     */\n+    private final Set<String> scopeSet;\n+\n+    /**\n+     * {@value OAuth2Constants#CLIENT_ID} Token Introspection Response field,\n+     * OPTIONAL. Client identifier for the OAuth 2.0 client that requested this token.\n+     */\n+    @Nullable\n+    private final String clientId;\n+\n+    /**\n+     * {@value OAuth2Constants#USER_NAME} Token Introspection Response field,\n+     * OPTIONAL. Human-readable identifier for the resource owner who authorized this token.\n+     */\n+    @Nullable\n+    private final String userName;\n+\n+    /**\n+     * {@value OAuth2Constants#TOKEN_TYPE} Token Introspection Response field,\n+     * OPTIONAL. Type of the token as defined at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-7.1\">[RFC6749], Section 7.1</a>.\n+     */\n+    @Nullable\n+    private final String tokenType;\n+\n+    /**\n+     * {@value OAuth2Constants#EXPIRES_AT} Token Introspection Response field,\n+     * OPTIONAL. Integer timestamp, measured in the number of seconds since January 1 1970 UTC,\n+     * indicating when this token will expire, as defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    private final Instant expiresAt;\n+\n+    /**\n+     * {@value OAuth2Constants#ISSUED_AT} Token Introspection Response field,\n+     * OPTIONAL. Integer timestamp, measured in the number of seconds since January 1 1970 UTC,\n+     * indicating when this token was originally issued, as defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    private final Instant issuedAt;\n+\n+    /**\n+     * {@value OAuth2Constants#NOT_BEFORE} Token Introspection Response field,\n+     * OPTIONAL. Integer timestamp, measured in the number of seconds since January 1 1970 UTC,\n+     * indicating when this token is not to be used before, as defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    private final Instant notBefore;\n+\n+    /**\n+     * {@value OAuth2Constants#SUBJECT} Token Introspection Response field,\n+     * OPTIONAL. Subject of the token. Usually a machine-readable\n+     * identifier of the resource owner who authorized this token. As defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    private final String subject;\n+\n+    /**\n+     * {@value OAuth2Constants#AUDIENCE} Token Introspection Response field,\n+     * OPTIONAL. Service-specific string identifier or list of string identifiers representing the\n+     * intended audience for this token, as defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    private final String audience;\n+\n+    /**\n+     * {@value OAuth2Constants#ISSUER} Token Introspection Response field,\n+     * OPTIONAL. String representing the issuer of this token, as defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    private final String issuer;\n+\n+    /**\n+     * {@value OAuth2Constants#JWT_ID} Token Introspection Response field,\n+     * OPTIONAL. String identifier for the token - JWT ID, as defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    private final String jwtId;\n+\n+    /**\n+     * A {@link Map} of extra system-specific token parameters included with Token Introspection Response,\n+     * OPTIONAL.\n+     */\n+    private final Map<String, String> extras;\n+\n+    @Nullable\n+    private String rawResponse;\n+\n+    @Nullable\n+    private transient String toString;\n+\n+    OAuth2TokenDescriptor(boolean active, @Nullable List<String> scopeList, @Nullable String clientId,\n+                          @Nullable String userName, @Nullable String tokenType,\n+                          @Nullable Instant expiresAt, @Nullable Instant issuedAt,\n+                          @Nullable Instant notBefore, @Nullable String subject,\n+                          @Nullable String audience, @Nullable String issuer,\n+                          @Nullable String jwtId, @Nullable ImmutableMap<String, String> extras,\n+                          @Nullable String rawResponse) {\n+        this.active = active;\n+        scope = toScopeString(scopeList);\n+        scopeSet = (scopeList == null) ? ImmutableSet.of() : ImmutableSet.copyOf(scopeList);\n+        this.clientId = clientId;\n+        this.userName = userName;\n+        this.tokenType = tokenType;\n+        this.expiresAt = expiresAt;\n+        this.issuedAt = issuedAt;\n+        this.notBefore = notBefore;\n+        this.subject = subject;\n+        this.audience = audience;\n+        this.issuer = issuer;\n+        this.jwtId = jwtId;\n+        this.extras = (extras == null) ? ImmutableMap.of() : extras;\n+        // raw response\n+        this.rawResponse = rawResponse;\n+    }\n+\n+    /**\n+     * {@value OAuth2Constants#ACTIVE} Token Introspection Response field,\n+     * REQUIRED. Boolean indicator of whether or not the presented token is currently active. The\n+     * specifics of a token's \"active\" state will vary depending on the implementation of the\n+     * authorization server and the information it keeps about its tokens, but a \"true\" value return\n+     * for the \"active\" property will generally indicate that a given token has been issued by this\n+     * authorization server, has not been revoked by the resource owner, and is within its given time\n+     * window of validity (e.g., after its issuance time and before its expiration time).\n+     */\n+    public boolean isActive() {\n+        return active;\n+    }\n+\n+    /**\n+     * Indicates whether or not the Token expire at the given {@link Instant} time based on\n+     * {@link #expiresAt()} function.\n+     */\n+    public boolean isValid(Instant instant) {\n+        final Instant expires = expiresAt();\n+        return (expires == null) || requireNonNull(instant, \"instant\").isBefore(expires);\n+    }\n+\n+    /**\n+     * Indicates whether or not the Token already expired based on {@link #expiresAt()} function.\n+     */\n+    public boolean isValid() {\n+        return isValid(Instant.now());\n+    }\n+\n+    /**\n+     * Indicates whether or not the Token used prematurely based on {@link #notBefore()} function.\n+     */\n+    public boolean isNotBefore() {\n+        final Instant notBefore = notBefore();\n+        return (notBefore == null) || Instant.now().isAfter(notBefore);\n+    }\n+\n+    /**\n+     * {@value OAuth2Constants#SCOPE} Token Introspection Response field,\n+     * OPTIONAL. A JSON string containing a space-separated list of scopes associated with this token,\n+     * in the format described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-3.3\">[RFC6749], Section 3.3</a>.\n+     */\n+    @Nullable\n+    public String scope() {\n+        return scope;\n+    }\n+\n+    /**\n+     * {@value OAuth2Constants#SCOPE} Token Introspection Response field,\n+     * OPTIONAL. A {@link Set} of case-sensitive scope strings. The strings are defined by the authorization\n+     * server.\n+     */\n+    public Set<String> scopeSet() {\n+        return scopeSet;\n+    }\n+\n+    /**\n+     * {@value OAuth2Constants#CLIENT_ID} Token Introspection Response field,\n+     * OPTIONAL. Client identifier for the OAuth 2.0 client that requested this token.\n+     */\n+    @Nullable\n+    public String clientId() {\n+        return clientId;\n+    }\n+\n+    /**\n+     * {@value OAuth2Constants#USER_NAME} Token Introspection Response field,\n+     * OPTIONAL. Human-readable identifier for the resource owner who authorized this token.\n+     */\n+    @Nullable\n+    public String userName() {\n+        return userName;\n+    }\n+\n+    /**\n+     * {@value OAuth2Constants#TOKEN_TYPE} Token Introspection Response field,\n+     * OPTIONAL. Type of the token as defined at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-7.1\">[RFC6749], Section 7.1</a>.\n+     */\n+    @Nullable\n+    public String tokenType() {\n+        return tokenType;\n+    }\n+\n+    /**\n+     * {@value OAuth2Constants#EXPIRES_AT} Token Introspection Response field,\n+     * OPTIONAL. {@link Instant} timestamp, indicating when this token will expire, as defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    public Instant expiresAt() {\n+        return expiresAt;\n+    }\n+\n+    /**\n+     * {@value OAuth2Constants#ISSUED_AT} Token Introspection Response field,\n+     * OPTIONAL. {@link Instant} timestamp, indicating when this token was originally issued, as defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    public Instant issuedAt() {\n+        return issuedAt;\n+    }\n+\n+    /**\n+     * {@link Duration} indicating the lifetime of the access token. The value is NOT supplied with the\n+     * Token Introspection response and calculated based on {@value OAuth2Constants#ISSUED_AT} and\n+     * {@value OAuth2Constants#EXPIRES_AT} response fields every time this method invoked.\n+     */\n+    @Nullable\n+    public Duration expiresIn() {\n+        if (issuedAt != null && expiresAt != null) {\n+            return Duration.ofMillis(issuedAt.until(expiresAt, ChronoUnit.MILLIS));\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * {@value OAuth2Constants#NOT_BEFORE} Token Introspection Response field,\n+     * OPTIONAL. {@link Instant} timestamp, indicating when this token is not to be used before, as defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    public Instant notBefore() {\n+        return notBefore;\n+    }\n+\n+    /**\n+     * {@value OAuth2Constants#SUBJECT} Token Introspection Response field,\n+     * OPTIONAL. Subject of the token. Usually a machine-readable\n+     * identifier of the resource owner who authorized this token. As defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    public String subject() {\n+        return subject;\n+    }\n+\n+    /**\n+     * {@value OAuth2Constants#AUDIENCE} Token Introspection Response field,\n+     * OPTIONAL. Service-specific string identifier or list of string identifiers representing the\n+     * intended audience for this token, as defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    public String audience() {\n+        return audience;\n+    }\n+\n+    /**\n+     * {@value OAuth2Constants#ISSUER} Token Introspection Response field,\n+     * OPTIONAL. String representing the issuer of this token, as defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    public String issuer() {\n+        return issuer;\n+    }\n+\n+    /**\n+     * {@value OAuth2Constants#JWT_ID} Token Introspection Response field,\n+     * OPTIONAL. String identifier for the token - JWT ID, as defined at\n+     * <a href=\"https://tools.ietf.org/html/rfc7519\">[RFC7519]</a>.\n+     */\n+    @Nullable\n+    public String jwtId() {\n+        return jwtId;\n+    }\n+\n+    /**\n+     * A {@link Map} of extra system-specific token parameters included with Token Introspection Response,\n+     * OPTIONAL.\n+     */\n+    public Map<String, String> extras() {\n+        return extras;\n+    }\n+\n+    /**\n+     * {@code JSON}-formatted raw Token Introspection Response body. If the {@link OAuth2TokenDescriptor} was\n+     * not parsed out of the raw response body, this value calculated based on the other\n+     * {@link OAuth2TokenDescriptor} values.\n+     */\n+    public String rawResponse() {\n+        if (rawResponse == null) {\n+            rawResponse = composeRawResponse(active, scope, clientId, userName, tokenType,\n+                                             expiresAt, issuedAt, notBefore,\n+                                             subject, audience, issuer,\n+                                             jwtId, extras);\n+        }\n+        return rawResponse;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (toString == null) {\n+            toString = rawResponse();\n+        }\n+        return toString;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (!(o instanceof OAuth2TokenDescriptor)) {\n+            return false;\n+        }\n+        final OAuth2TokenDescriptor that = (OAuth2TokenDescriptor) o;\n+        return Objects.equals(rawResponse(), that.rawResponse());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hashCode(rawResponse());", "originalCommit": "dd0a7906c377dfa3b6c130b59aaf723f8d368be6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3MTkxNg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552071916", "bodyText": "Done", "author": "max904-github", "createdAt": "2021-01-05T17:13:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc0NzA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc0NzM3MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r551747370", "bodyText": "4-space indentation", "author": "trustin", "createdAt": "2021-01-05T06:53:53Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/TokenRequestException.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A common token request exception type.\n+ */\n+public class TokenRequestException extends RuntimeException {", "originalCommit": "dd0a7906c377dfa3b6c130b59aaf723f8d368be6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3MjAxMA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552072010", "bodyText": "Fixed", "author": "max904-github", "createdAt": "2021-01-05T17:13:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc0NzM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc0NzYzMA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r551747630", "bodyText": "(Global comment) Could you add final to any methods in a non-final class if it's not meant to be overridden?", "author": "trustin", "createdAt": "2021-01-05T06:54:48Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/TokenRequestException.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A common token request exception type.\n+ */\n+public class TokenRequestException extends RuntimeException {\n+\n+  private static final long serialVersionUID = 3324433572773111913L;\n+\n+  /**\n+   * Returns a {@link TokenRequestExceptionBuilder} to build error-specific types\n+   * of {@link TokenRequestException}.\n+   */\n+  public static TokenRequestException of(String rawResponse) {\n+    return TokenRequestExceptionBuilder.parse(rawResponse);\n+  }\n+\n+  @Nullable\n+  private final String errorUri;\n+\n+  /**\n+   * Constructs a new {@link TokenRequestException} using {@code errorDescription} and {@code errorUri}.\n+   * @param errorDescription OPTIONAL. Human-readable ASCII [USASCII] text providing additional information,\n+   *                         used to assist the client developer in understanding the error that occurred.\n+   *                         Values for the {@code errorDescription} parameter MUST NOT include\n+   *                         characters outside the set {@code %x20-21} / {@code %x23-5B} / {@code %x5D-7E}.\n+   * @param errorUri OPTIONAL. A URI identifying a human-readable web page with information about the error,\n+   *                 used to provide the client developer with additional information about the error.\n+   *                 Values for the {@code errorUri} parameter MUST conform to the URI-reference syntax and\n+   *                 thus MUST NOT include characters outside\n+   *                 the set {@code %x21} / {@code %x23-5B} / {@code %x5D-7E}.\n+   */\n+  public TokenRequestException(String errorDescription, @Nullable String errorUri) {\n+    super(errorDescription);\n+    this.errorUri = errorUri;\n+  }\n+\n+  /**\n+   * Constructs a new {@link TokenRequestException} using {@code errorDescription} and {@code errorUri}.\n+   * @param errorDescription OPTIONAL. Human-readable ASCII [USASCII] text providing additional information,\n+   *                         used to assist the client developer in understanding the error that occurred.\n+   *                         Values for the {@code errorDescription} parameter MUST NOT include\n+   *                         characters outside the set {@code %x20-21} / {@code %x23-5B} / {@code %x5D-7E}.\n+   * @param errorUri OPTIONAL. A URI identifying a human-readable web page with information about the error,\n+   *                 used to provide the client developer with additional information about the error.\n+   *                 Values for the {@code errorUri} parameter MUST conform to the URI-reference syntax and\n+   *                 thus MUST NOT include characters outside\n+   *                 the set {@code %x21} / {@code %x23-5B} / {@code %x5D-7E}.\n+   * @param cause the cause (which is saved for later retrieval by the {@link #getCause()} method).\n+   *              (A {@code null} value is permitted, and indicates that the cause is nonexistent or unknown.)\n+   */\n+  public TokenRequestException(String errorDescription, @Nullable String errorUri, Throwable cause) {\n+    super(errorDescription, cause);\n+    this.errorUri = errorUri;\n+  }\n+\n+  /**\n+   * A URI identifying a human-readable web page with information about the error, used to provide the client\n+   * developer with additional information about the error.\n+   * Values for the {@code errorUri} parameter MUST conform to the URI-reference syntax and thus MUST NOT\n+   * include characters outside the set {@code %x21} / {@code %x23-5B} / {@code %x5D-7E}.\n+   */\n+  @Nullable\n+  public String getErrorUri() {", "originalCommit": "dd0a7906c377dfa3b6c130b59aaf723f8d368be6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3MjY1NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552072655", "bodyText": "Fixed this one. But since most of the public classes marked final now, there is no need to mark every method.", "author": "max904-github", "createdAt": "2021-01-05T17:14:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc0NzYzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc1NTM4MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r551755381", "bodyText": "How about introducing a new parent exception such as OAuth2Exception? TokenRequestException could extend it as well.\nThe exception name sounds too generic. Should we add OAuth2 in its name? e.g. UnsupportedOAuth2MediaTypeException?", "author": "trustin", "createdAt": "2021-01-05T07:19:07Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/UnsupportedMediaTypeException.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+/**\n+ * A response {@code Content-Type} header does not match the expected type.\n+ */\n+public class UnsupportedMediaTypeException extends RuntimeException {", "originalCommit": "dd0a7906c377dfa3b6c130b59aaf723f8d368be6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2Mjc1NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552062754", "bodyText": "UnsupportedResponseException and UnsupportedMediaTypeException are indeed generic exceptions. I wish they were placed somewhere inside the core internal. These are not related to OAuth2 or token processing.", "author": "max904-github", "createdAt": "2021-01-05T16:58:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc1NTM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ1NTYzMw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552455633", "bodyText": "How about simply replacing UnsupportedResponse/MediaTypeException with an InvalidResponseException which is a sister of InvalidRequestException? That would make it clear that the failure occurred due to a bad OAuth2 response.", "author": "trustin", "createdAt": "2021-01-06T09:17:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc1NTM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk2MDk4Mw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553960983", "bodyText": "Introduced InvalidResponseException as a parent of UnsupportedResponse/MediaTypeException.", "author": "max904-github", "createdAt": "2021-01-08T14:04:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc1NTM4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc1NTUyNQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r551755525", "bodyText": "How about introducing a new parent exception such as OAuth2Exception? TokenRequestException could extend it as well.\nThe exception name sounds too generic. Should we add OAuth2 in its name? e.g. UnsupportedOAuth2ResponseException?", "author": "trustin", "createdAt": "2021-01-05T07:19:39Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/UnsupportedResponseException.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.HttpStatus;\n+\n+/**\n+ * A response type in not supported by the given request/response flow.\n+ */\n+public class UnsupportedResponseException extends RuntimeException {", "originalCommit": "dd0a7906c377dfa3b6c130b59aaf723f8d368be6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2NTYwMA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552065600", "bodyText": "UnsupportedResponseException and UnsupportedMediaTypeException are indeed generic exceptions. I wish they were placed somewhere inside the core internal. These are not related to OAuth2 or token processing.", "author": "max904-github", "createdAt": "2021-01-05T17:03:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc1NTUyNQ=="}], "type": "inlineReview"}, {"oid": "2d0f4b99b2b20210852d7ebde932c54e3208ac3f", "url": "https://github.com/line/armeria/commit/2d0f4b99b2b20210852d7ebde932c54e3208ac3f", "message": "Review comments by @trustin - Various minor changes", "committedDate": "2021-01-06T01:50:09Z", "type": "commit"}, {"oid": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "url": "https://github.com/line/armeria/commit/d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "message": "More review comments by @trustin - Various minor changes", "committedDate": "2021-01-06T02:04:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQyNjg3Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552426877", "bodyText": "Could just pass self and nextAuthorizer in as a constructor parameter?", "author": "trustin", "createdAt": "2021-01-06T08:12:14Z", "path": "core/src/main/java/com/linecorp/armeria/server/auth/Authorizer.java", "diffHunk": "@@ -48,49 +48,31 @@\n      */\n     default Authorizer<T> orElse(Authorizer<T> nextAuthorizer) {\n         final Authorizer<T> self = this;\n-        return new Authorizer<T>() {\n-            @Nullable\n-            private String strVal;\n-\n-            @Override\n-            public CompletionStage<Boolean> authorize(ServiceRequestContext ctx, T data) {\n-                return AuthorizerUtil.authorize(self, ctx, data).thenComposeAsync(result -> {\n-                    if (result == null) {\n-                        throw AuthorizerUtil.newNullResultException(self);\n-                    } else {\n-                        return result ? CompletableFuture.completedFuture(true)\n-                                      : AuthorizerUtil.authorize(nextAuthorizer, ctx, data);\n-                    }\n-                }, ctx.eventLoop());\n-            }\n-\n-            @Override\n-            public String toString() {\n-                if (strVal != null) {\n-                    return strVal;\n-                }\n-\n-                final StringBuilder buf = new StringBuilder();\n-\n-                // Append the first authorizer.\n-                if (self.getClass() == getClass()) {\n-                    final String s = self.toString();\n-                    buf.append(s, 0, s.length() - 1);\n-                } else {\n-                    buf.append('[').append(self);\n-                }\n-                buf.append(\", \");\n+        return new AuthorizerChain<>(self, AuthorizerSelectionStrategy.LAST_WITH_HANDLER)\n+                .orElse(nextAuthorizer);", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk2Mjc2OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553962768", "bodyText": "Right. Just wanted to stick close to the original version.\nFixed now.", "author": "max904-github", "createdAt": "2021-01-08T14:07:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQyNjg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQyNzc3Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552427776", "bodyText": "How about simplifying a little bit?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    requireNonNull(authorizers, \"authorizers\");\n          \n          \n            \n                    final Iterator<? extends Authorizer<T>> it = authorizers.iterator();\n          \n          \n            \n                    checkArgument(it.hasNext(), \"List of authorizers is empty\");\n          \n          \n            \n                    final Authorizer<T> firstAuthorizer = it.next();\n          \n          \n            \n                    requireNonNull(firstAuthorizer, \"firstAuthorizer\");\n          \n          \n            \n                    this.authorizers = ImmutableList.copyOf(authorizers);\n          \n          \n            \n                    requireNonNull(authorizers, \"authorizers\");\n          \n          \n            \n                    this.authorizers = ImmutableList.copyOf(authorizers);\n          \n          \n            \n                    checkArgument(!this.authorizers.isEmpty(), \"authorizers is empty.\");\n          \n          \n            \n                    final Authorizer<T> firstAuthorizer = this.authorizers.get(0);", "author": "trustin", "createdAt": "2021-01-06T08:14:34Z", "path": "core/src/main/java/com/linecorp/armeria/server/auth/AuthorizerChain.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.auth;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * Chains multiple {@link Authorizer}s together into a single {@link Authorizer}.\n+ * Utilizes {@link AuthorizerSelectionStrategy} to select corresponding {@link AuthFailureHandler}.\n+ */\n+final class AuthorizerChain<T> implements Authorizer<T> {\n+\n+    enum AuthorizerSelectionStrategy {\n+        /**\n+         * Select a handler provided by the first {@link Authorizer} in the chain.\n+         */\n+        FIRST,\n+        /**\n+         * Select a handler provided by the last {@link Authorizer} in the chain.\n+         */\n+        LAST,\n+        /**\n+         * Select a handler provided by the first {@link Authorizer} in the chain that has an associated\n+         * handler actually defined (non-NULL).\n+         */\n+        FIRST_WITH_HANDLER,\n+        /**\n+         * Select a handler provided by the last {@link Authorizer} in the chain that has an associated\n+         * handler actually defined (non-NULL).\n+         */\n+        LAST_WITH_HANDLER\n+    }\n+\n+    private final List<? extends Authorizer<T>> authorizers;\n+    private final AuthorizerSelectionStrategy selectionStrategy;\n+    @Nullable\n+    private AuthSuccessHandler successHandler;\n+    @Nullable\n+    private AuthFailureHandler failureHandler;\n+\n+    AuthorizerChain(Iterable<? extends Authorizer<T>> authorizers,\n+                    AuthorizerSelectionStrategy selectionStrategy) {\n+        requireNonNull(authorizers, \"authorizers\");\n+        final Iterator<? extends Authorizer<T>> it = authorizers.iterator();\n+        checkArgument(it.hasNext(), \"List of authorizers is empty\");\n+        final Authorizer<T> firstAuthorizer = it.next();\n+        requireNonNull(firstAuthorizer, \"firstAuthorizer\");\n+        this.authorizers = ImmutableList.copyOf(authorizers);", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk2NTM2Mw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553965363", "bodyText": "thanks. done.", "author": "max904-github", "createdAt": "2021-01-08T14:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQyNzc3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQyODA1OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552428058", "bodyText": "We could inline this constructor in Authorizer.orElse() and remove this one.", "author": "trustin", "createdAt": "2021-01-06T08:15:17Z", "path": "core/src/main/java/com/linecorp/armeria/server/auth/AuthorizerChain.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.auth;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * Chains multiple {@link Authorizer}s together into a single {@link Authorizer}.\n+ * Utilizes {@link AuthorizerSelectionStrategy} to select corresponding {@link AuthFailureHandler}.\n+ */\n+final class AuthorizerChain<T> implements Authorizer<T> {\n+\n+    enum AuthorizerSelectionStrategy {\n+        /**\n+         * Select a handler provided by the first {@link Authorizer} in the chain.\n+         */\n+        FIRST,\n+        /**\n+         * Select a handler provided by the last {@link Authorizer} in the chain.\n+         */\n+        LAST,\n+        /**\n+         * Select a handler provided by the first {@link Authorizer} in the chain that has an associated\n+         * handler actually defined (non-NULL).\n+         */\n+        FIRST_WITH_HANDLER,\n+        /**\n+         * Select a handler provided by the last {@link Authorizer} in the chain that has an associated\n+         * handler actually defined (non-NULL).\n+         */\n+        LAST_WITH_HANDLER\n+    }\n+\n+    private final List<? extends Authorizer<T>> authorizers;\n+    private final AuthorizerSelectionStrategy selectionStrategy;\n+    @Nullable\n+    private AuthSuccessHandler successHandler;\n+    @Nullable\n+    private AuthFailureHandler failureHandler;\n+\n+    AuthorizerChain(Iterable<? extends Authorizer<T>> authorizers,\n+                    AuthorizerSelectionStrategy selectionStrategy) {\n+        requireNonNull(authorizers, \"authorizers\");\n+        final Iterator<? extends Authorizer<T>> it = authorizers.iterator();\n+        checkArgument(it.hasNext(), \"List of authorizers is empty\");\n+        final Authorizer<T> firstAuthorizer = it.next();\n+        requireNonNull(firstAuthorizer, \"firstAuthorizer\");\n+        this.authorizers = ImmutableList.copyOf(authorizers);\n+        this.selectionStrategy = requireNonNull(selectionStrategy, \"selectionStrategy\");\n+        if (selectionStrategy == AuthorizerSelectionStrategy.FIRST) {\n+            // this could be NULL\n+            failureHandler = firstAuthorizer.failureHandler();\n+        }\n+    }\n+\n+    AuthorizerChain(Authorizer<T> firstAuthorizer, AuthorizerSelectionStrategy selectionStrategy) {\n+        this(ImmutableList.of(requireNonNull(firstAuthorizer, \"firstAuthorizer\")), selectionStrategy);\n+    }", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk2NjIzMg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553966232", "bodyText": "done", "author": "max904-github", "createdAt": "2021-01-08T14:13:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQyODA1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQyOTIzOA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552429238", "bodyText": "How about managing these two states on a per-authorization basis? Otherwise we may have an issue when authorizing multiple requests at the same time. See below for the suggestion.", "author": "trustin", "createdAt": "2021-01-06T08:17:57Z", "path": "core/src/main/java/com/linecorp/armeria/server/auth/AuthorizerChain.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.auth;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * Chains multiple {@link Authorizer}s together into a single {@link Authorizer}.\n+ * Utilizes {@link AuthorizerSelectionStrategy} to select corresponding {@link AuthFailureHandler}.\n+ */\n+final class AuthorizerChain<T> implements Authorizer<T> {\n+\n+    enum AuthorizerSelectionStrategy {\n+        /**\n+         * Select a handler provided by the first {@link Authorizer} in the chain.\n+         */\n+        FIRST,\n+        /**\n+         * Select a handler provided by the last {@link Authorizer} in the chain.\n+         */\n+        LAST,\n+        /**\n+         * Select a handler provided by the first {@link Authorizer} in the chain that has an associated\n+         * handler actually defined (non-NULL).\n+         */\n+        FIRST_WITH_HANDLER,\n+        /**\n+         * Select a handler provided by the last {@link Authorizer} in the chain that has an associated\n+         * handler actually defined (non-NULL).\n+         */\n+        LAST_WITH_HANDLER\n+    }\n+\n+    private final List<? extends Authorizer<T>> authorizers;\n+    private final AuthorizerSelectionStrategy selectionStrategy;\n+    @Nullable\n+    private AuthSuccessHandler successHandler;\n+    @Nullable\n+    private AuthFailureHandler failureHandler;", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk2MDM1Mw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553960353", "bodyText": "Yes, this chain processing does not look nice at the second look - we WILL have a problem with multiple requests. But not sure how we could make successHandler and failureHandler local as those exposed by Authorizer interface.\nThe only solution I can see right now is to return successHandler and failureHandler alongside the authorization status.", "author": "max904-github", "createdAt": "2021-01-08T14:02:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQyOTIzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDAwNTM3Mw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r554005373", "bodyText": "Yes, this chain processing does not look nice at the second look - we WILL have a problem with multiple requests. But not sure how we could make successHandler and failureHandler local as those exposed by Authorizer interface.\nThe only solution I can see right now is to return successHandler and failureHandler alongside the authorization status.\n\nPlease advise on the best/optimal/acceptable solution.", "author": "max904-github", "createdAt": "2021-01-08T15:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQyOTIzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDAyMDk1MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r554020950", "bodyText": "What about the following solution?\npublic interface Authorizer<T> {\n\n    CompletionStage<Boolean> authorize(ServiceRequestContext ctx, T data);\n\n    default CompletionStage<AuthorizationStatus> authorizeAndSupplyHandlers(ServiceRequestContext ctx, T data) {\n        authorize(ctx, data).thenApply(status -> new AuthorizationStatusImpl(status));\n    }\n\n    ...\n}\n\n\npublic interface AuthorizationStatus {\n\n    boolean status();\n\n    @Nullable\n    AuthSuccessHandler successHandler();\n\n    @Nullable\n    AuthFailureHandler failureHandler();\n}\n\n\nclass AuthorizationStatusImpl implements AuthorizationStatus {\n\n    private final boolean status;\n    @Nullable\n    private final AuthSuccessHandler successHandler;\n    @Nullable\n    private final AuthFailureHandler failureHandler;\n\n    AuthorizationStatusImpl(boolean status, @Nullable AuthSuccessHandler successHandler, @Nullable AuthFailureHandler failureHandler) {\n        this.status = status;\n        this.successHandler = successHandler;\n        this.failureHandler = failureHandler;\n    }\n\n    AuthorizationStatusImpl(boolean status) {\n        this(status, null, null);\n    }\n\n    boolean status() {\n        return status;\n    }\n\n    AuthSuccessHandler successHandler() {\n        return successHandler;\n    }\n\n    AuthFailureHandler failureHandler() {\n        return failureHandler;\n    }\n}\n\nThis will allow removing successHandler()/failureHandler() from the Authorizer interface while keeping backward compatibility with the original interface. AuthorizerChain and OAuth2 will implement the new authorizeAndSupplyHandlers method.", "author": "max904-github", "createdAt": "2021-01-08T15:45:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQyOTIzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDIwNTQ4Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r554205486", "bodyText": "I've implemented this approach in the latest commit. It looks fine. Please review.", "author": "max904-github", "createdAt": "2021-01-08T21:42:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQyOTIzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTc1MDAzOQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r561750039", "bodyText": "That sounds good to me. Let me take a close look soon.", "author": "trustin", "createdAt": "2021-01-21T10:08:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQyOTIzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQyOTcyNw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552429727", "bodyText": "We could add successHandler and failureHandler as parameters here and remove the member fields above.", "author": "trustin", "createdAt": "2021-01-06T08:19:12Z", "path": "core/src/main/java/com/linecorp/armeria/server/auth/AuthorizerChain.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.auth;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * Chains multiple {@link Authorizer}s together into a single {@link Authorizer}.\n+ * Utilizes {@link AuthorizerSelectionStrategy} to select corresponding {@link AuthFailureHandler}.\n+ */\n+final class AuthorizerChain<T> implements Authorizer<T> {\n+\n+    enum AuthorizerSelectionStrategy {\n+        /**\n+         * Select a handler provided by the first {@link Authorizer} in the chain.\n+         */\n+        FIRST,\n+        /**\n+         * Select a handler provided by the last {@link Authorizer} in the chain.\n+         */\n+        LAST,\n+        /**\n+         * Select a handler provided by the first {@link Authorizer} in the chain that has an associated\n+         * handler actually defined (non-NULL).\n+         */\n+        FIRST_WITH_HANDLER,\n+        /**\n+         * Select a handler provided by the last {@link Authorizer} in the chain that has an associated\n+         * handler actually defined (non-NULL).\n+         */\n+        LAST_WITH_HANDLER\n+    }\n+\n+    private final List<? extends Authorizer<T>> authorizers;\n+    private final AuthorizerSelectionStrategy selectionStrategy;\n+    @Nullable\n+    private AuthSuccessHandler successHandler;\n+    @Nullable\n+    private AuthFailureHandler failureHandler;\n+\n+    AuthorizerChain(Iterable<? extends Authorizer<T>> authorizers,\n+                    AuthorizerSelectionStrategy selectionStrategy) {\n+        requireNonNull(authorizers, \"authorizers\");\n+        final Iterator<? extends Authorizer<T>> it = authorizers.iterator();\n+        checkArgument(it.hasNext(), \"List of authorizers is empty\");\n+        final Authorizer<T> firstAuthorizer = it.next();\n+        requireNonNull(firstAuthorizer, \"firstAuthorizer\");\n+        this.authorizers = ImmutableList.copyOf(authorizers);\n+        this.selectionStrategy = requireNonNull(selectionStrategy, \"selectionStrategy\");\n+        if (selectionStrategy == AuthorizerSelectionStrategy.FIRST) {\n+            // this could be NULL\n+            failureHandler = firstAuthorizer.failureHandler();\n+        }\n+    }\n+\n+    AuthorizerChain(Authorizer<T> firstAuthorizer, AuthorizerSelectionStrategy selectionStrategy) {\n+        this(ImmutableList.of(requireNonNull(firstAuthorizer, \"firstAuthorizer\")), selectionStrategy);\n+    }\n+\n+    /**\n+     * Adds a new {@link Authorizer} to the chain.\n+     * @return an original {@link AuthorizerChain} instance with added {@link Authorizer}.\n+     */\n+    @Override\n+    public Authorizer<T> orElse(Authorizer<T> nextAuthorizer) {\n+        final ImmutableList.Builder<Authorizer<T>> newAuthorizersBuilder = ImmutableList.builder();\n+        newAuthorizersBuilder.addAll(authorizers).add(requireNonNull(nextAuthorizer, \"nextAuthorizer\"));\n+        return new AuthorizerChain<>(newAuthorizersBuilder.build(), selectionStrategy);\n+    }\n+\n+    /**\n+     * Triggers an authorization on the chain of {@link Authorizer}s.\n+     * @return a {@link CompletionStage} that will resolve to {@code true} if any of {@link Authorizer}s in the\n+     *         chain authorize the request, or {@code false} if none of {@link Authorizer}s in the chain\n+     *         authorize the request. If the future resolves exceptionally, the request will not be authorized.\n+     */\n+    @Override\n+    public CompletionStage<Boolean> authorize(ServiceRequestContext ctx, T data) {\n+        return authorize(authorizers.iterator(), ctx, data);\n+    }\n+\n+    private CompletionStage<Boolean> authorize(Iterator<? extends Authorizer<T>> iterator,\n+                                               ServiceRequestContext ctx, T data) {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk2MDQxOQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553960419", "bodyText": "How can we avoid having successHandler and failureHandler member fields as those exposed by Authorizer interface?\nThe only solution I can see right now is to return successHandler and failureHandler alongside the authorization status.", "author": "max904-github", "createdAt": "2021-01-08T14:03:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQyOTcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzMDI4MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552430280", "bodyText": "nit: in JUnit 5 tests, you don't need to make your test classes and methods public. Please remove all public modifiers.", "author": "trustin", "createdAt": "2021-01-06T08:20:43Z", "path": "core/src/test/java/com/linecorp/armeria/server/auth/AuthorizerTest.java", "diffHunk": "@@ -29,35 +30,42 @@\n \n import java.util.concurrent.CompletionException;\n import java.util.concurrent.CompletionStage;\n+import java.util.stream.Stream;\n \n import javax.annotation.Nullable;\n \n-import org.junit.AfterClass;\n-import org.junit.BeforeClass;\n-import org.junit.ClassRule;\n-import org.junit.Test;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n \n import com.linecorp.armeria.common.HttpMethod;\n import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.HttpService;\n import com.linecorp.armeria.server.ServiceRequestContext;\n-import com.linecorp.armeria.testing.junit4.common.EventLoopRule;\n+import com.linecorp.armeria.testing.junit5.common.EventLoopExtension;\n \n public class AuthorizerTest {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk2NzczMQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553967731", "bodyText": "right. done.", "author": "max904-github", "createdAt": "2021-01-08T14:16:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzMDI4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzExNDc3NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563114774", "bodyText": "The test class itself can also be package-private.", "author": "trustin", "createdAt": "2021-01-23T11:22:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzMDI4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkxOTY2Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563919666", "bodyText": "fixed", "author": "max904-github", "createdAt": "2021-01-25T17:46:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzMDI4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzMDM4Mw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552430383", "bodyText": "Missing final", "author": "trustin", "createdAt": "2021-01-06T08:21:01Z", "path": "core/src/test/java/com/linecorp/armeria/server/auth/AuthorizerTest.java", "diffHunk": "@@ -29,35 +30,42 @@\n \n import java.util.concurrent.CompletionException;\n import java.util.concurrent.CompletionStage;\n+import java.util.stream.Stream;\n \n import javax.annotation.Nullable;\n \n-import org.junit.AfterClass;\n-import org.junit.BeforeClass;\n-import org.junit.ClassRule;\n-import org.junit.Test;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n \n import com.linecorp.armeria.common.HttpMethod;\n import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.HttpService;\n import com.linecorp.armeria.server.ServiceRequestContext;\n-import com.linecorp.armeria.testing.junit4.common.EventLoopRule;\n+import com.linecorp.armeria.testing.junit5.common.EventLoopExtension;\n \n public class AuthorizerTest {\n \n-    @ClassRule\n-    public static final EventLoopRule eventLoop = new EventLoopRule();\n+    @RegisterExtension\n+    static EventLoopExtension eventLoop = new EventLoopExtension();", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk2ODcxNw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553968717", "bodyText": "copy-paste from some other Armeria's test.\nfixed.", "author": "max904-github", "createdAt": "2021-01-08T14:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzMDM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzMDc0MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552430741", "bodyText": "Could be final.", "author": "trustin", "createdAt": "2021-01-06T08:22:03Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractOAuth2AuthorizationGrant.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken;\n+import com.linecorp.armeria.common.auth.oauth2.InvalidClientException;\n+import com.linecorp.armeria.common.auth.oauth2.TokenRequestException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedMediaTypeException;\n+import com.linecorp.armeria.internal.client.auth.oauth2.RefreshAccessTokenRequest;\n+\n+/**\n+ * Base implementation of OAuth 2.0 Access Token Grant flow to obtain Access Token.\n+ * Implements Access Token loading, storing and refreshing.\n+ */\n+abstract class AbstractOAuth2AuthorizationGrant implements OAuth2AuthorizationGrant {\n+\n+    private final RefreshAccessTokenRequest refreshRequest;\n+\n+    private final Duration refreshBefore;\n+\n+    /**\n+     * Holds a token object and facilitates its lifecycle.\n+     */\n+    private final TokenLifecycleManager<GrantedOAuth2AccessToken> tokenManager;\n+\n+    AbstractOAuth2AuthorizationGrant(RefreshAccessTokenRequest refreshRequest, Duration refreshBefore,\n+                                     @Nullable Supplier<? extends GrantedOAuth2AccessToken> tokenSupplier,\n+                                     @Nullable Consumer<? super GrantedOAuth2AccessToken> tokenConsumer,\n+                                     @Nullable Executor executor) {\n+        this.refreshRequest = requireNonNull(refreshRequest, \"refreshRequest\");\n+        this.refreshBefore = requireNonNull(refreshBefore, \"refreshBefore\");\n+        tokenManager = new TokenLifecycleManager<>(this::isValid, this::canRefresh,\n+                                                   this::shallObtainInsteadOfUpdate,\n+                                                   this::obtainAccessToken, this::refreshAccessToken,\n+                                                   tokenSupplier, tokenConsumer, executor);\n+    }\n+\n+    /**\n+     * Tests the token for validity at the given {@link Instant} time.\n+     */\n+    private boolean isValid(GrantedOAuth2AccessToken token, Instant now) {\n+        return token.isValid(now.plus(refreshBefore));\n+    }\n+\n+    /**\n+     * Tests whether the token object can be refreshed or re-obtained.\n+     */\n+    private boolean canRefresh(GrantedOAuth2AccessToken token) {\n+        return token.refreshToken() != null;\n+    }\n+\n+    /**\n+     * Tests whether given {@link Throwable} indicates that the token shall be re-obtained\n+     * after the refresh operation failure.\n+     */\n+    private boolean shallObtainInsteadOfUpdate(Throwable throwable) {\n+        return throwable instanceof TokenRequestException;\n+    }\n+\n+    /**\n+     * Refreshes access token.\n+     */\n+    private CompletionStage<GrantedOAuth2AccessToken> refreshAccessToken(GrantedOAuth2AccessToken token) {\n+        return refreshRequest.make(token);\n+    }\n+\n+    /**\n+     * Obtains a new access token from the token end-point asynchronously.\n+     * @return A {@link CompletableFuture} carrying the requested {@link GrantedOAuth2AccessToken} or an\n+     *         exception, if the request failed.\n+     * @throws TokenRequestException when the endpoint returns {code HTTP 400 (Bad Request)} status and the\n+     *                               response payload contains the details of the error.\n+     * @throws InvalidClientException when the endpoint returns {@code HTTP 401 (Unauthorized)} status, which\n+     *                                typically indicates that client authentication failed (e.g.: unknown\n+     *                                client, no client authentication included, or unsupported authentication\n+     *                                method).\n+     * @throws UnsupportedMediaTypeException if the media type of the response does not match the expected\n+     *                                       (JSON).\n+     */\n+    abstract CompletableFuture<GrantedOAuth2AccessToken> obtainAccessToken(\n+            @Nullable GrantedOAuth2AccessToken token);\n+\n+    /**\n+     * Produces valid OAuth 2.0 Access Token.\n+     * Returns cached access token if previously obtained from the token end-point.\n+     * Optionally loads access token from longer term storage provided by registered {@link Supplier}.\n+     * If access token has not previously obtained, obtains is from the OAuth 2.0 token end-point using\n+     * dedicated single-thread {@link ExecutorService} which makes sure all token obtain and refresh requests\n+     * executed serially.\n+     * Validates access token and refreshes it if necessary.\n+     */\n+    @Override\n+    public CompletionStage<GrantedOAuth2AccessToken> getAccessToken() {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk2OTgyMA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553969820", "bodyText": "fixed", "author": "max904-github", "createdAt": "2021-01-08T14:20:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzMDc0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzMTQxNw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552431417", "bodyText": "Could be final?", "author": "trustin", "createdAt": "2021-01-06T08:23:44Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/OAuth2ClientCredentialsGrant.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken;\n+import com.linecorp.armeria.internal.client.auth.oauth2.ClientCredentialsTokenRequest;\n+import com.linecorp.armeria.internal.client.auth.oauth2.RefreshAccessTokenRequest;\n+\n+/**\n+ * An implementation of OAuth 2.0 Client Credentials Grant flow to obtain Access Token,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-4.4\">[RFC6749], Section 4.4</a>.\n+ * Implements Access Token loading, storing, obtaining and refreshing.\n+ */\n+@UnstableApi\n+public class OAuth2ClientCredentialsGrant extends AbstractOAuth2AuthorizationGrant {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk3MDExNA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553970114", "bodyText": "fixed", "author": "max904-github", "createdAt": "2021-01-08T14:20:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzMTQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzMTU4Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552431587", "bodyText": "Could be final?", "author": "trustin", "createdAt": "2021-01-06T08:24:13Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/OAuth2ResourceOwnerPasswordCredentialsGrant.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken;\n+import com.linecorp.armeria.internal.client.auth.oauth2.RefreshAccessTokenRequest;\n+import com.linecorp.armeria.internal.client.auth.oauth2.ResourceOwnerPasswordCredentialsTokenRequest;\n+\n+/**\n+ * An implementation of OAuth 2.0 Resource Owner Password Credentials Grant flow to obtain Access Token,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-4.3\">[RFC6749], Section 4.3</a>.\n+ * Implements Access Token loading, storing, obtaining and refreshing.\n+ */\n+@UnstableApi\n+public class OAuth2ResourceOwnerPasswordCredentialsGrant extends AbstractOAuth2AuthorizationGrant {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk3MDE2NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553970165", "bodyText": "fixed", "author": "max904-github", "createdAt": "2021-01-08T14:20:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzMTU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzMTg4MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552431881", "bodyText": "public could be removed", "author": "trustin", "createdAt": "2021-01-06T08:24:58Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/TokenLifecycleManager.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Instant;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiPredicate;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+import com.linecorp.armeria.internal.common.auth.oauth2.SerialFuture;\n+\n+/**\n+ * Holds a token object and facilitates its lifecycle based on a number of procedures,\n+ * such as supply, update, load, store.\n+ * @param <T> the type of the token object\n+ */\n+class TokenLifecycleManager<T> {\n+\n+    /**\n+     * Holds a reference to the token.\n+     */\n+    private final AtomicReference<T> ref;\n+\n+    /**\n+     * Executes token operations serially on a separate thread.\n+     */\n+    private final SerialFuture serialFuture;\n+\n+    private final BiPredicate<? super T, Instant> validator;\n+\n+    private final Predicate<? super T> isUpdatable;\n+\n+    private final Predicate<Throwable> shallResupply;\n+\n+    private final Function<? super T, CompletionStage<? extends T>> serviceSupplier;\n+\n+    @Nullable\n+    private final Function<? super T, CompletionStage<? extends T>> serviceUpdater;\n+\n+    @Nullable\n+    private final Supplier<? extends T> storageSupplier;\n+\n+    @Nullable\n+    private final Consumer<? super T> storageConsumer;\n+\n+    /**\n+     * Constructs new {@link TokenLifecycleManager}.\n+     * @param validator A {@link BiPredicate} that tests the token for validity at the {@link Instant} time.\n+     * @param isUpdatable A {@link Predicate} that tests whether the token object can be updated or re-supplied.\n+     * @param shallResupply A {@link Predicate} that tests whether given {@link Throwable} indicates that\n+     *                      the token shall be re-supplied after the update operation failure.\n+     * @param serviceSupplier A {@link Function} that supplies an initial token object.\n+     * @param serviceUpdater A {@link Function} that updates token object.\n+     * @param storageSupplier A {@link Supplier} that can optionally load previously stored token object.\n+     * @param storageConsumer A {@link Consumer} that can optionally store token object.\n+     * @param executor An optional {@link Executor} that facilitates asynchronous supply and update operations.\n+     *                 A new single thread {@link Executor} will be created using\n+     *                 {@link Executors#newSingleThreadExecutor()} if the {@code null}.\n+     */\n+    TokenLifecycleManager(BiPredicate<? super T, Instant> validator,\n+                          Predicate<? super T> isUpdatable, Predicate<Throwable> shallResupply,\n+                          Function<? super T, CompletionStage<? extends T>> serviceSupplier,\n+                          @Nullable Function<? super T, CompletionStage<? extends T>> serviceUpdater,\n+                          @Nullable Supplier<? extends T> storageSupplier,\n+                          @Nullable Consumer<? super T> storageConsumer,\n+                          @Nullable Executor executor) {\n+        ref = new AtomicReference<>();\n+        serialFuture = new SerialFuture(executor);\n+        this.validator = requireNonNull(validator, \"validator\");\n+        this.isUpdatable = requireNonNull(isUpdatable, \"isUpdatable\");\n+        this.shallResupply = requireNonNull(shallResupply, \"shallResupply\");\n+        this.serviceSupplier = requireNonNull(serviceSupplier, \"serviceSupplier\");\n+        this.serviceUpdater = serviceUpdater;\n+        this.storageSupplier = storageSupplier;\n+        this.storageConsumer = storageConsumer;\n+    }\n+\n+    /**\n+     * Provides managed token object asynchronously. This operation may involve initial token supply or\n+     * token update operation, if required.\n+     */\n+    public CompletionStage<T> get() {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk3MDk0Mg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553970942", "bodyText": "fixed", "author": "max904-github", "createdAt": "2021-01-08T14:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzMTg4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzMjYzMA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552432630", "bodyText": "Could you rename to asHeaderValue() for consistency with other classes?", "author": "trustin", "createdAt": "2021-01-06T08:26:39Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/ClientAuthorization.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.internal.common.auth.oauth2.CaseUtil;\n+\n+/**\n+ * Provides client authorization for the OAuth 2.0 requests,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+ * For example:\n+ * <pre>{@code\n+ * Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3\n+ * }</pre>\n+ * Fetches authorization source from the designated authorization or credentials supplier, which\n+ * might be facilitated by a secure Secret provider. Will fetch the authorization source for each\n+ * request. Therefore the designated supplier must cache the value in order to avoid unnecessary\n+ * network hops.\n+ * The authorization source might either provide complete authorization token or client credentials.\n+ */\n+@UnstableApi\n+public final class ClientAuthorization {\n+\n+    private static final String DEFAULT_AUTHORIZATION_TYPE = \"Basic\";\n+    private static final char AUTHORIZATION_SEPARATOR = ' ';\n+    private static final char CREDENTIALS_SEPARATOR = ':';\n+\n+    private static final String CLIENT_ID = \"client_id\";\n+    private static final String CLIENT_SECRET = \"client_secret\";\n+\n+    private final String authorizationType;\n+    @Nullable\n+    private final Supplier<String> authorizationSupplier;\n+    @Nullable\n+    private final Supplier<? extends Map.Entry<String, String>> credentialsSupplier;\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    public static ClientAuthorization ofAuthorization(\n+            Supplier<String> authorizationSupplier, String authorizationType) {\n+        return new ClientAuthorization(requireNonNull(authorizationSupplier, \"authorizationSupplier\"),\n+                                       null, requireNonNull(authorizationType, \"authorizationType\"));\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     */\n+    public static ClientAuthorization ofBasicAuthorization(\n+            Supplier<String> authorizationSupplier) {\n+        return new ClientAuthorization(requireNonNull(authorizationSupplier, \"authorizationSupplier\"),\n+                                       null, null);\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    public static ClientAuthorization ofCredentials(\n+            Supplier<? extends Map.Entry<String, String>> credentialsSupplier, String authorizationType) {\n+        return new ClientAuthorization(null,\n+                                       requireNonNull(credentialsSupplier, \"credentialsSupplier\"),\n+                                       requireNonNull(authorizationType, \"authorizationType\"));\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     */\n+    public static ClientAuthorization ofCredentials(\n+            Supplier<? extends Map.Entry<String, String>> credentialsSupplier) {\n+        return new ClientAuthorization(null,\n+                                       requireNonNull(credentialsSupplier, \"credentialsSupplier\"), null);\n+    }\n+\n+    private ClientAuthorization(@Nullable Supplier<String> authorizationSupplier,\n+                                @Nullable Supplier<? extends Map.Entry<String, String>> credentialsSupplier,\n+                                @Nullable String authorizationType) {\n+        if (authorizationSupplier == null && credentialsSupplier == null) {\n+            throw new NullPointerException(\"authorizationSupplier && credentialsSupplier\");\n+        }\n+        this.authorizationSupplier = authorizationSupplier;\n+        this.credentialsSupplier = credentialsSupplier;\n+        this.authorizationType =\n+                authorizationType == null ? DEFAULT_AUTHORIZATION_TYPE : authorizationType;\n+    }\n+\n+    private String composeAuthorizationString() {\n+        final String clientAuthorization;\n+        if (authorizationSupplier != null) {\n+            clientAuthorization = authorizationSupplier.get();\n+        } else if (credentialsSupplier != null) {\n+            final Map.Entry<String, String> clientCredentials = credentialsSupplier.get();\n+            clientAuthorization = encodeClientCredentials(clientCredentials.getKey(),\n+                                                          clientCredentials.getValue());\n+        } else {\n+            // we should not get here\n+            throw new NullPointerException(\"authorizationSupplier && credentialsSupplier\");\n+        }\n+        return clientAuthorization;\n+    }\n+\n+    /**\n+     * Fetches client authorization token or client credentials from the supplier and composes client\n+     * {@code Authorization} header value,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>:\n+     * <pre>{@code\n+     * Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3\n+     * }</pre>.\n+     *\n+     * @return encoded client {@code Authorization} header value.\n+     */\n+    public String authorizationHeaderValue() {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk3NjQ3NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553976475", "bodyText": "agree. done", "author": "max904-github", "createdAt": "2021-01-08T14:32:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzMjYzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzNDA2Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552434066", "bodyText": "How about returning QueryParams, so that a user can choose whether to convert to a String or not?\nHow about renaming to asBodyParameters()? Shorter and 'as' gives a hint of conversion.", "author": "trustin", "createdAt": "2021-01-06T08:30:07Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/ClientAuthorization.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.internal.common.auth.oauth2.CaseUtil;\n+\n+/**\n+ * Provides client authorization for the OAuth 2.0 requests,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+ * For example:\n+ * <pre>{@code\n+ * Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3\n+ * }</pre>\n+ * Fetches authorization source from the designated authorization or credentials supplier, which\n+ * might be facilitated by a secure Secret provider. Will fetch the authorization source for each\n+ * request. Therefore the designated supplier must cache the value in order to avoid unnecessary\n+ * network hops.\n+ * The authorization source might either provide complete authorization token or client credentials.\n+ */\n+@UnstableApi\n+public final class ClientAuthorization {\n+\n+    private static final String DEFAULT_AUTHORIZATION_TYPE = \"Basic\";\n+    private static final char AUTHORIZATION_SEPARATOR = ' ';\n+    private static final char CREDENTIALS_SEPARATOR = ':';\n+\n+    private static final String CLIENT_ID = \"client_id\";\n+    private static final String CLIENT_SECRET = \"client_secret\";\n+\n+    private final String authorizationType;\n+    @Nullable\n+    private final Supplier<String> authorizationSupplier;\n+    @Nullable\n+    private final Supplier<? extends Map.Entry<String, String>> credentialsSupplier;\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    public static ClientAuthorization ofAuthorization(\n+            Supplier<String> authorizationSupplier, String authorizationType) {\n+        return new ClientAuthorization(requireNonNull(authorizationSupplier, \"authorizationSupplier\"),\n+                                       null, requireNonNull(authorizationType, \"authorizationType\"));\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     */\n+    public static ClientAuthorization ofBasicAuthorization(\n+            Supplier<String> authorizationSupplier) {\n+        return new ClientAuthorization(requireNonNull(authorizationSupplier, \"authorizationSupplier\"),\n+                                       null, null);\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    public static ClientAuthorization ofCredentials(\n+            Supplier<? extends Map.Entry<String, String>> credentialsSupplier, String authorizationType) {\n+        return new ClientAuthorization(null,\n+                                       requireNonNull(credentialsSupplier, \"credentialsSupplier\"),\n+                                       requireNonNull(authorizationType, \"authorizationType\"));\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     */\n+    public static ClientAuthorization ofCredentials(\n+            Supplier<? extends Map.Entry<String, String>> credentialsSupplier) {\n+        return new ClientAuthorization(null,\n+                                       requireNonNull(credentialsSupplier, \"credentialsSupplier\"), null);\n+    }\n+\n+    private ClientAuthorization(@Nullable Supplier<String> authorizationSupplier,\n+                                @Nullable Supplier<? extends Map.Entry<String, String>> credentialsSupplier,\n+                                @Nullable String authorizationType) {\n+        if (authorizationSupplier == null && credentialsSupplier == null) {\n+            throw new NullPointerException(\"authorizationSupplier && credentialsSupplier\");\n+        }\n+        this.authorizationSupplier = authorizationSupplier;\n+        this.credentialsSupplier = credentialsSupplier;\n+        this.authorizationType =\n+                authorizationType == null ? DEFAULT_AUTHORIZATION_TYPE : authorizationType;\n+    }\n+\n+    private String composeAuthorizationString() {\n+        final String clientAuthorization;\n+        if (authorizationSupplier != null) {\n+            clientAuthorization = authorizationSupplier.get();\n+        } else if (credentialsSupplier != null) {\n+            final Map.Entry<String, String> clientCredentials = credentialsSupplier.get();\n+            clientAuthorization = encodeClientCredentials(clientCredentials.getKey(),\n+                                                          clientCredentials.getValue());\n+        } else {\n+            // we should not get here\n+            throw new NullPointerException(\"authorizationSupplier && credentialsSupplier\");\n+        }\n+        return clientAuthorization;\n+    }\n+\n+    /**\n+     * Fetches client authorization token or client credentials from the supplier and composes client\n+     * {@code Authorization} header value,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>:\n+     * <pre>{@code\n+     * Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3\n+     * }</pre>.\n+     *\n+     * @return encoded client {@code Authorization} header value.\n+     */\n+    public String authorizationHeaderValue() {\n+        return CaseUtil.firstUpperAllLowerCase(authorizationType) +\n+               AUTHORIZATION_SEPARATOR + composeAuthorizationString();\n+    }\n+\n+    /**\n+     * Fetches client credentials from the supplier and composes required body parameters,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>:\n+     * <pre>{@code\n+     * client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw\n+     * }</pre>.\n+     * The client MAY omit the {@code client_secret} parameter if the client secret is an empty string.\n+     */\n+    public void setCredentialsAsBodyParameters(QueryParamsBuilder formBuilder) {\n+        requireNonNull(credentialsSupplier, \"credentialsSupplier\");\n+        final Map.Entry<String, String> clientCredentials = credentialsSupplier.get();\n+        formBuilder.add(CLIENT_ID, requireNonNull(clientCredentials.getKey(), CLIENT_ID));\n+        final String clientSecret = clientCredentials.getValue();\n+        if (clientSecret != null && !clientSecret.isEmpty()) {\n+            formBuilder.add(CLIENT_SECRET, clientSecret);\n+        }\n+    }\n+\n+    /**\n+     * Fetches client credentials from the supplier and composes required body parameters,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>:\n+     * <pre>{@code\n+     * client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw\n+     * }</pre>.\n+     * The client MAY omit the {@code client_secret} parameter if the client secret is an empty string.\n+     *\n+     * @return encoded client credentials request body parameters as a {@link String}.\n+     */\n+    public String credentialsBodyParameters() {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk3NjU1OQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553976559", "bodyText": "agree. done", "author": "max904-github", "createdAt": "2021-01-08T14:32:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzNDA2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzNDU2MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552434561", "bodyText": "Maybe add instead of set, because we're actually adding? We could simplify even further by removing Credentials, i.e. addAsBodyParameters.", "author": "trustin", "createdAt": "2021-01-06T08:31:32Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/ClientAuthorization.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.internal.common.auth.oauth2.CaseUtil;\n+\n+/**\n+ * Provides client authorization for the OAuth 2.0 requests,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+ * For example:\n+ * <pre>{@code\n+ * Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3\n+ * }</pre>\n+ * Fetches authorization source from the designated authorization or credentials supplier, which\n+ * might be facilitated by a secure Secret provider. Will fetch the authorization source for each\n+ * request. Therefore the designated supplier must cache the value in order to avoid unnecessary\n+ * network hops.\n+ * The authorization source might either provide complete authorization token or client credentials.\n+ */\n+@UnstableApi\n+public final class ClientAuthorization {\n+\n+    private static final String DEFAULT_AUTHORIZATION_TYPE = \"Basic\";\n+    private static final char AUTHORIZATION_SEPARATOR = ' ';\n+    private static final char CREDENTIALS_SEPARATOR = ':';\n+\n+    private static final String CLIENT_ID = \"client_id\";\n+    private static final String CLIENT_SECRET = \"client_secret\";\n+\n+    private final String authorizationType;\n+    @Nullable\n+    private final Supplier<String> authorizationSupplier;\n+    @Nullable\n+    private final Supplier<? extends Map.Entry<String, String>> credentialsSupplier;\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    public static ClientAuthorization ofAuthorization(\n+            Supplier<String> authorizationSupplier, String authorizationType) {\n+        return new ClientAuthorization(requireNonNull(authorizationSupplier, \"authorizationSupplier\"),\n+                                       null, requireNonNull(authorizationType, \"authorizationType\"));\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     */\n+    public static ClientAuthorization ofBasicAuthorization(\n+            Supplier<String> authorizationSupplier) {\n+        return new ClientAuthorization(requireNonNull(authorizationSupplier, \"authorizationSupplier\"),\n+                                       null, null);\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    public static ClientAuthorization ofCredentials(\n+            Supplier<? extends Map.Entry<String, String>> credentialsSupplier, String authorizationType) {\n+        return new ClientAuthorization(null,\n+                                       requireNonNull(credentialsSupplier, \"credentialsSupplier\"),\n+                                       requireNonNull(authorizationType, \"authorizationType\"));\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     */\n+    public static ClientAuthorization ofCredentials(\n+            Supplier<? extends Map.Entry<String, String>> credentialsSupplier) {\n+        return new ClientAuthorization(null,\n+                                       requireNonNull(credentialsSupplier, \"credentialsSupplier\"), null);\n+    }\n+\n+    private ClientAuthorization(@Nullable Supplier<String> authorizationSupplier,\n+                                @Nullable Supplier<? extends Map.Entry<String, String>> credentialsSupplier,\n+                                @Nullable String authorizationType) {\n+        if (authorizationSupplier == null && credentialsSupplier == null) {\n+            throw new NullPointerException(\"authorizationSupplier && credentialsSupplier\");\n+        }\n+        this.authorizationSupplier = authorizationSupplier;\n+        this.credentialsSupplier = credentialsSupplier;\n+        this.authorizationType =\n+                authorizationType == null ? DEFAULT_AUTHORIZATION_TYPE : authorizationType;\n+    }\n+\n+    private String composeAuthorizationString() {\n+        final String clientAuthorization;\n+        if (authorizationSupplier != null) {\n+            clientAuthorization = authorizationSupplier.get();\n+        } else if (credentialsSupplier != null) {\n+            final Map.Entry<String, String> clientCredentials = credentialsSupplier.get();\n+            clientAuthorization = encodeClientCredentials(clientCredentials.getKey(),\n+                                                          clientCredentials.getValue());\n+        } else {\n+            // we should not get here\n+            throw new NullPointerException(\"authorizationSupplier && credentialsSupplier\");\n+        }\n+        return clientAuthorization;\n+    }\n+\n+    /**\n+     * Fetches client authorization token or client credentials from the supplier and composes client\n+     * {@code Authorization} header value,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>:\n+     * <pre>{@code\n+     * Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3\n+     * }</pre>.\n+     *\n+     * @return encoded client {@code Authorization} header value.\n+     */\n+    public String authorizationHeaderValue() {\n+        return CaseUtil.firstUpperAllLowerCase(authorizationType) +\n+               AUTHORIZATION_SEPARATOR + composeAuthorizationString();\n+    }\n+\n+    /**\n+     * Fetches client credentials from the supplier and composes required body parameters,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>:\n+     * <pre>{@code\n+     * client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw\n+     * }</pre>.\n+     * The client MAY omit the {@code client_secret} parameter if the client secret is an empty string.\n+     */\n+    public void setCredentialsAsBodyParameters(QueryParamsBuilder formBuilder) {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk3NjY1OQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553976659", "bodyText": "agree. done", "author": "max904-github", "createdAt": "2021-01-08T14:32:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzNDU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzNjQ5Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552436496", "bodyText": "Do you think it makes sense to have toString method, with redacted credentials?", "author": "trustin", "createdAt": "2021-01-06T08:36:12Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/ClientAuthorization.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.internal.common.auth.oauth2.CaseUtil;\n+\n+/**\n+ * Provides client authorization for the OAuth 2.0 requests,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+ * For example:\n+ * <pre>{@code\n+ * Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3\n+ * }</pre>\n+ * Fetches authorization source from the designated authorization or credentials supplier, which\n+ * might be facilitated by a secure Secret provider. Will fetch the authorization source for each\n+ * request. Therefore the designated supplier must cache the value in order to avoid unnecessary\n+ * network hops.\n+ * The authorization source might either provide complete authorization token or client credentials.\n+ */\n+@UnstableApi\n+public final class ClientAuthorization {\n+\n+    private static final String DEFAULT_AUTHORIZATION_TYPE = \"Basic\";\n+    private static final char AUTHORIZATION_SEPARATOR = ' ';\n+    private static final char CREDENTIALS_SEPARATOR = ':';\n+\n+    private static final String CLIENT_ID = \"client_id\";\n+    private static final String CLIENT_SECRET = \"client_secret\";\n+\n+    private final String authorizationType;\n+    @Nullable\n+    private final Supplier<String> authorizationSupplier;\n+    @Nullable\n+    private final Supplier<? extends Map.Entry<String, String>> credentialsSupplier;\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    public static ClientAuthorization ofAuthorization(\n+            Supplier<String> authorizationSupplier, String authorizationType) {\n+        return new ClientAuthorization(requireNonNull(authorizationSupplier, \"authorizationSupplier\"),\n+                                       null, requireNonNull(authorizationType, \"authorizationType\"));\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     */\n+    public static ClientAuthorization ofBasicAuthorization(\n+            Supplier<String> authorizationSupplier) {\n+        return new ClientAuthorization(requireNonNull(authorizationSupplier, \"authorizationSupplier\"),\n+                                       null, null);\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    public static ClientAuthorization ofCredentials(\n+            Supplier<? extends Map.Entry<String, String>> credentialsSupplier, String authorizationType) {\n+        return new ClientAuthorization(null,\n+                                       requireNonNull(credentialsSupplier, \"credentialsSupplier\"),\n+                                       requireNonNull(authorizationType, \"authorizationType\"));\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     */\n+    public static ClientAuthorization ofCredentials(\n+            Supplier<? extends Map.Entry<String, String>> credentialsSupplier) {\n+        return new ClientAuthorization(null,\n+                                       requireNonNull(credentialsSupplier, \"credentialsSupplier\"), null);\n+    }\n+\n+    private ClientAuthorization(@Nullable Supplier<String> authorizationSupplier,\n+                                @Nullable Supplier<? extends Map.Entry<String, String>> credentialsSupplier,\n+                                @Nullable String authorizationType) {\n+        if (authorizationSupplier == null && credentialsSupplier == null) {\n+            throw new NullPointerException(\"authorizationSupplier && credentialsSupplier\");\n+        }\n+        this.authorizationSupplier = authorizationSupplier;\n+        this.credentialsSupplier = credentialsSupplier;\n+        this.authorizationType =\n+                authorizationType == null ? DEFAULT_AUTHORIZATION_TYPE : authorizationType;\n+    }\n+\n+    private String composeAuthorizationString() {\n+        final String clientAuthorization;\n+        if (authorizationSupplier != null) {\n+            clientAuthorization = authorizationSupplier.get();\n+        } else if (credentialsSupplier != null) {\n+            final Map.Entry<String, String> clientCredentials = credentialsSupplier.get();\n+            clientAuthorization = encodeClientCredentials(clientCredentials.getKey(),\n+                                                          clientCredentials.getValue());\n+        } else {\n+            // we should not get here\n+            throw new NullPointerException(\"authorizationSupplier && credentialsSupplier\");\n+        }\n+        return clientAuthorization;\n+    }\n+\n+    /**\n+     * Fetches client authorization token or client credentials from the supplier and composes client\n+     * {@code Authorization} header value,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>:\n+     * <pre>{@code\n+     * Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3\n+     * }</pre>.\n+     *\n+     * @return encoded client {@code Authorization} header value.\n+     */\n+    public String authorizationHeaderValue() {\n+        return CaseUtil.firstUpperAllLowerCase(authorizationType) +\n+               AUTHORIZATION_SEPARATOR + composeAuthorizationString();\n+    }\n+\n+    /**\n+     * Fetches client credentials from the supplier and composes required body parameters,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>:\n+     * <pre>{@code\n+     * client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw\n+     * }</pre>.\n+     * The client MAY omit the {@code client_secret} parameter if the client secret is an empty string.\n+     */\n+    public void setCredentialsAsBodyParameters(QueryParamsBuilder formBuilder) {\n+        requireNonNull(credentialsSupplier, \"credentialsSupplier\");\n+        final Map.Entry<String, String> clientCredentials = credentialsSupplier.get();\n+        formBuilder.add(CLIENT_ID, requireNonNull(clientCredentials.getKey(), CLIENT_ID));\n+        final String clientSecret = clientCredentials.getValue();\n+        if (clientSecret != null && !clientSecret.isEmpty()) {\n+            formBuilder.add(CLIENT_SECRET, clientSecret);\n+        }\n+    }\n+\n+    /**\n+     * Fetches client credentials from the supplier and composes required body parameters,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>:\n+     * <pre>{@code\n+     * client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw\n+     * }</pre>.\n+     * The client MAY omit the {@code client_secret} parameter if the client secret is an empty string.\n+     *\n+     * @return encoded client credentials request body parameters as a {@link String}.\n+     */\n+    public String credentialsBodyParameters() {\n+        final QueryParamsBuilder formBuilder = QueryParams.builder();\n+        setCredentialsAsBodyParameters(formBuilder);\n+        return formBuilder.toQueryString();\n+    }\n+\n+    private static String encodeClientCredentials(String clientId, String clientSecret) {\n+        return Base64.getEncoder()\n+                     .encodeToString(\n+                             (clientId + CREDENTIALS_SEPARATOR + clientSecret)\n+                                     .getBytes(StandardCharsets.UTF_8));\n+    }\n+}", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk4MTQwOQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553981409", "bodyText": "As you can see, this class ClientAuthorization does not possess any actual credentials. It only holds a reference to the the entire authorization string Supplier or to credentials Supplier. This is done intentionally, so this class does not cache and maintain the lifecycle of the credentials/authorization. Credentials may change over time, credentials (or authorization string) should not be exposed. Therefore, there is nothing to print in the 'toString()' method besides the authorization type (Basic, Bearer, etc). Do you think it still makes sense to print just the type?\nWe should not invoke toString() on either of the suppliers, as it's opaque to our framework and we don't know whether it will expose the credentials or not.", "author": "max904-github", "createdAt": "2021-01-08T14:40:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzNjQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk4NTIzMQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553985231", "bodyText": "printing only the type of the authorization and the type of the source, like:\n{\"type\": \"Basic\", \"source\": \"credentials\"}", "author": "max904-github", "createdAt": "2021-01-08T14:46:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzNjQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTc0ODkwNw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r561748907", "bodyText": "Sounds good to me. Thanks for elaboration, @max904-github", "author": "trustin", "createdAt": "2021-01-21T10:06:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzNjQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzNjc4Mw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552436783", "bodyText": "Could be final?", "author": "trustin", "createdAt": "2021-01-06T08:36:50Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/GrantedOAuth2AccessToken.java", "diffHunk": "@@ -0,0 +1,407 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.ACCESS_TOKEN;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.DEFAULT_TOKEN_TYPE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.EXPIRES_IN;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.REFRESH_TOKEN;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.SCOPE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.TOKEN_TYPE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.ResponseParserUtil.JSON;\n+import static java.time.format.DateTimeFormatter.ISO_INSTANT;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.internal.common.auth.oauth2.CaseUtil;\n+import com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants;\n+\n+/**\n+ * Defines a structure of the Access Token Response, as per\n+ * <a href=\"https://tools.ietf.org/html/rfc6749#section-5.1\">[RFC6749], Section 5.1</a>.\n+ */\n+@UnstableApi\n+public class GrantedOAuth2AccessToken implements Serializable {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk4NjQ3Mw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553986473", "bodyText": "prefer to keep it not final, as it's likely to be extended in future once we get to deal with some more specific token vendors.", "author": "max904-github", "createdAt": "2021-01-08T14:48:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzNjc4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzNzQ1OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552437458", "bodyText": "Could be final", "author": "trustin", "createdAt": "2021-01-06T08:38:16Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/InvalidClientException.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+\n+/**\n+ * Client authentication failed (e.g., unknown client, no client authentication included, or\n+ * unsupported authentication method). The authorization server MAY return an HTTP 401\n+ * (Unauthorized) status code to indicate which HTTP authentication schemes are supported. If the\n+ * client attempted to authenticate via the \"Authorization\" request header field, the authorization\n+ * server MUST respond with an HTTP 401 (Unauthorized) status code and include the\n+ * \"WWW-Authenticate\" response header field matching the authentication scheme used by the client.\n+ */\n+@UnstableApi\n+public class InvalidClientException extends TokenRequestException {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk4NjU4OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553986588", "bodyText": "fixed", "author": "max904-github", "createdAt": "2021-01-08T14:49:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzNzQ1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzNzU0NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552437545", "bodyText": "Could be final", "author": "trustin", "createdAt": "2021-01-06T08:38:27Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/InvalidGrantException.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+\n+/**\n+ * The provided authorization grant (e.g., authorization code, resource owner credentials) or\n+ * refresh token is invalid, expired, revoked, does not match the redirection URI used in the\n+ * authorization request, or was issued to another client.\n+ */\n+@UnstableApi\n+public class InvalidGrantException extends TokenRequestException {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk4NjY3MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553986670", "bodyText": "fixed", "author": "max904-github", "createdAt": "2021-01-08T14:49:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzNzU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzNzY0OQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552437649", "bodyText": "Could be final", "author": "trustin", "createdAt": "2021-01-06T08:38:41Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/InvalidRequestException.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+\n+/**\n+ * The request is missing a required parameter, includes an unsupported parameter value (other than\n+ * grant type), repeats a parameter, includes multiple credentials, utilizes more than one mechanism\n+ * for authenticating the client, or is otherwise malformed.\n+ */\n+@UnstableApi\n+public class InvalidRequestException extends TokenRequestException {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk4Njc0Mg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553986742", "bodyText": "fixed", "author": "max904-github", "createdAt": "2021-01-08T14:49:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzNzY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzNzczNg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552437736", "bodyText": "Could be final.", "author": "trustin", "createdAt": "2021-01-06T08:38:52Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/InvalidScopeException.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+\n+/**\n+ * The requested scope is invalid, unknown, malformed, or exceeds the scope granted by the resource\n+ * owner.\n+ */\n+@UnstableApi\n+public class InvalidScopeException extends TokenRequestException {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk4NjgyMQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553986821", "bodyText": "fixed", "author": "max904-github", "createdAt": "2021-01-08T14:49:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzNzczNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzOTQzMw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552439433", "bodyText": "How about merging TokenRequestExceptionBuilder into this class? It doesn't seem to do anything but parsing.\nHow about renaming this method to parse(rawResponse)?", "author": "trustin", "createdAt": "2021-01-06T08:43:03Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/TokenRequestException.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+\n+/**\n+ * A common token request exception type.\n+ */\n+@UnstableApi\n+public class TokenRequestException extends RuntimeException {\n+\n+    private static final long serialVersionUID = 3324433572773111913L;\n+\n+    /**\n+     * Returns a {@link TokenRequestExceptionBuilder} to build error-specific types\n+     * of {@link TokenRequestException}.\n+     */\n+    public static TokenRequestException of(String rawResponse) {\n+        return TokenRequestExceptionBuilder.parse(rawResponse);\n+    }", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk4NjkyOA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553986928", "bodyText": "fixed", "author": "max904-github", "createdAt": "2021-01-08T14:49:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzOTQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0MDUzNg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552440536", "bodyText": "Could be final?", "author": "trustin", "createdAt": "2021-01-06T08:45:28Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/UnauthorizedClientException.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+\n+/**\n+ * The authenticated client is not authorized to use this authorization grant type.\n+ */\n+@UnstableApi\n+public class UnauthorizedClientException extends TokenRequestException {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk4NzAxMA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553987010", "bodyText": "fixed", "author": "max904-github", "createdAt": "2021-01-08T14:49:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0MDUzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0MDYyOQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552440629", "bodyText": "Could be final?", "author": "trustin", "createdAt": "2021-01-06T08:45:41Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/UnsupportedGrantTypeException.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+\n+/**\n+ * The authorization grant type is not supported by the authorization server.\n+ */\n+@UnstableApi\n+public class UnsupportedGrantTypeException extends TokenRequestException {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk4NzA5OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553987098", "bodyText": "fixed", "author": "max904-github", "createdAt": "2021-01-08T14:49:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0MDYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0MDkxMA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552440910", "bodyText": "Could be final.", "author": "trustin", "createdAt": "2021-01-06T08:46:14Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/UnsupportedTokenTypeException.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+\n+/**\n+ * The authorization server does not support the revocation of the presented token type. That is,\n+ * the client tried to revoke an access token on a server not supporting this feature.\n+ */\n+@UnstableApi\n+public class UnsupportedTokenTypeException extends TokenRequestException {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk4NzE4Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553987186", "bodyText": "fixed", "author": "max904-github", "createdAt": "2021-01-08T14:49:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0MDkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0MTUxMg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552441512", "bodyText": "Could all protected methods in this class be final?", "author": "trustin", "createdAt": "2021-01-06T08:47:38Z", "path": "oauth2/src/main/java/com/linecorp/armeria/internal/common/auth/oauth2/AbstractOAuth2Request.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.auth.oauth2;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.InvalidClientException;\n+import com.linecorp.armeria.common.auth.oauth2.TokenRequestException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedMediaTypeException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedResponseException;\n+\n+/**\n+ * A common abstraction for the requests implementing various OAuth 2.0 request/response flows,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a> and other relevant specifications.\n+ * @param <T> the type of the authorization result.\n+ */\n+@UnstableApi\n+public abstract class AbstractOAuth2Request<T> {\n+\n+    private final WebClient endpoint;\n+    private final String endpointPath;\n+    @Nullable\n+    private final ClientAuthorization clientAuthorization;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Authorization request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a> and other relevant specifications.\n+     *\n+     * @param endpoint A {@link WebClient} to facilitate the Authorization requests. Must\n+     *                 correspond to the required Authorization endpoint of the OAuth 2 system.\n+     * @param endpointPath A URI path that corresponds to the Authorization endpoint of the\n+     *                     OAuth 2 system.\n+     * @param clientAuthorization Provides client authorization for the OAuth requests,\n+     *                            as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     */\n+    protected AbstractOAuth2Request(WebClient endpoint, String endpointPath,\n+                                    @Nullable ClientAuthorization clientAuthorization) {\n+        this.endpoint = Objects.requireNonNull(endpoint, \"endpoint\");\n+        this.endpointPath = Objects.requireNonNull(endpointPath, \"endpointPath\");\n+        this.clientAuthorization = clientAuthorization; // optional\n+    }\n+\n+    /**\n+     * Returns the {@link WebClient} of the authorization endpoint.\n+     */\n+    protected WebClient endpoint() {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk4OTgxMQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553989811", "bodyText": "added to those methods that make sense", "author": "max904-github", "createdAt": "2021-01-08T14:54:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0MTUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0MTk3NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552441975", "bodyText": "Could be final?\naddAsBodyParameters?", "author": "trustin", "createdAt": "2021-01-06T08:48:45Z", "path": "oauth2/src/main/java/com/linecorp/armeria/internal/common/auth/oauth2/AbstractOAuth2Request.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.auth.oauth2;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.InvalidClientException;\n+import com.linecorp.armeria.common.auth.oauth2.TokenRequestException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedMediaTypeException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedResponseException;\n+\n+/**\n+ * A common abstraction for the requests implementing various OAuth 2.0 request/response flows,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a> and other relevant specifications.\n+ * @param <T> the type of the authorization result.\n+ */\n+@UnstableApi\n+public abstract class AbstractOAuth2Request<T> {\n+\n+    private final WebClient endpoint;\n+    private final String endpointPath;\n+    @Nullable\n+    private final ClientAuthorization clientAuthorization;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Authorization request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a> and other relevant specifications.\n+     *\n+     * @param endpoint A {@link WebClient} to facilitate the Authorization requests. Must\n+     *                 correspond to the required Authorization endpoint of the OAuth 2 system.\n+     * @param endpointPath A URI path that corresponds to the Authorization endpoint of the\n+     *                     OAuth 2 system.\n+     * @param clientAuthorization Provides client authorization for the OAuth requests,\n+     *                            as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     */\n+    protected AbstractOAuth2Request(WebClient endpoint, String endpointPath,\n+                                    @Nullable ClientAuthorization clientAuthorization) {\n+        this.endpoint = Objects.requireNonNull(endpoint, \"endpoint\");\n+        this.endpointPath = Objects.requireNonNull(endpointPath, \"endpointPath\");\n+        this.clientAuthorization = clientAuthorization; // optional\n+    }\n+\n+    /**\n+     * Returns the {@link WebClient} of the authorization endpoint.\n+     */\n+    protected WebClient endpoint() {\n+        return endpoint;\n+    }\n+\n+    /**\n+     * Returns the authorization endpoint path.\n+     */\n+    protected String endpointPath() {\n+        return endpointPath;\n+    }\n+\n+    /**\n+     * Returns the client authorization object.\n+     */\n+    @Nullable\n+    protected ClientAuthorization clientAuthorization() {\n+        return clientAuthorization;\n+    }\n+\n+    /**\n+     * Extracts data from OK response and converts it to the target type {@code T}.\n+     */\n+    protected abstract T extractOkResults(AggregatedHttpResponse response, QueryParams requestFormData);\n+\n+    /**\n+     * Returns the value for the {@link HttpHeaderNames#AUTHORIZATION}.\n+     */\n+    @Nullable\n+    protected String authorizationHeaderValue() {\n+        return clientAuthorization == null ? null : clientAuthorization.authorizationHeaderValue();\n+    }\n+\n+    /**\n+     * Sets client credentials as form data parameters,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     */\n+    protected void setCredentialsAsBodyParameters(QueryParamsBuilder formBuilder) {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk5MDUzNw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553990537", "bodyText": "Added final. Renamed to addCredentialsAsBodyParameters since this class in not just about credentials.", "author": "max904-github", "createdAt": "2021-01-08T14:55:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0MTk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0MzMwNg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552443306", "bodyText": "Could these two make() methods become final (unless they are overridden)?", "author": "trustin", "createdAt": "2021-01-06T08:51:44Z", "path": "oauth2/src/main/java/com/linecorp/armeria/internal/common/auth/oauth2/AbstractTokenOperationRequest.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.auth.oauth2;\n+\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.ACCESS_TOKEN;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.TOKEN;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.TOKEN_TYPE_HINT;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.InvalidClientException;\n+import com.linecorp.armeria.common.auth.oauth2.TokenRequestException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedMediaTypeException;\n+\n+/**\n+ * A common abstraction for the requests implementing various Token operations request/response flows,\n+ * such as Token Introspection flow\n+ * (<a href=\"https://tools.ietf.org/html/rfc7662#section-2\">[RFC7662], Section 2</a>),\n+ * and Token Revocation flow (<a href=\"https://tools.ietf.org/html/rfc7009\">[RFC7009]</a>).\n+ * @param <T> the type of the authorization result.\n+ */\n+@UnstableApi\n+public abstract class AbstractTokenOperationRequest<T> extends AbstractOAuth2Request<T> {\n+\n+    /**\n+     * A common abstraction for the requests implementing various Token operations request/response flows,\n+     * such as Token Introspection flow\n+     * (<a href=\"https://tools.ietf.org/html/rfc7662#section-2\">[RFC7662], Section 2</a>),\n+     * and Token Revocation flow (<a href=\"https://tools.ietf.org/html/rfc7009\">[RFC7009]</a>).\n+     *\n+     * @param operationsEndpoint A {@link WebClient} to facilitate the Token Operations requests. Must\n+     *                           correspond to the required Token Operations endpoint of the OAuth 2 system.\n+     * @param operationsEndpointPath A URI path that corresponds to the token Operations endpoint of the\n+     *                               OAuth 2 system.\n+     * @param clientAuthorization Provides client authorization for the OAuth requests,\n+     *                            as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     */\n+    protected AbstractTokenOperationRequest(WebClient operationsEndpoint, String operationsEndpointPath,\n+                                            @Nullable ClientAuthorization clientAuthorization) {\n+        super(operationsEndpoint, operationsEndpointPath, clientAuthorization);\n+    }\n+\n+    /**\n+     * Makes a token operations (Introspection/Revocation) request using given {@code token} and\n+     * optional {@code tokenType}.\n+     * @param token A token this operation request applies to.\n+     * @param tokenType A hint about the type of the token submitted for (Introspection/Revocation) operation.\n+     *                  Either {@code access_token} or {@code refresh_token} as per\n+     *                  <a href=\"https://tools.ietf.org/html/rfc7009#section-2.1\">[RFC7009], Section 2.1</a>.\n+     * @return A {@link CompletableFuture} carrying the target result.\n+     * @throws TokenRequestException when the endpoint returns {code HTTP 400 (Bad Request)} status and the\n+     *                               response payload contains the details of the error.\n+     * @throws InvalidClientException when the endpoint returns {@code HTTP 401 (Unauthorized)} status, which\n+     *                                typically indicates that client authentication failed (e.g.: unknown\n+     *                                client, no client authentication included, or unsupported authentication\n+     *                                method).\n+     * @throws UnsupportedMediaTypeException if the media type of the response does not match the expected\n+     *                                       (JSON).\n+     */\n+    public CompletableFuture<T> make(String token, @Nullable String tokenType) {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk5MTI1OQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553991259", "bodyText": "No, make() is supposed to be overridden.", "author": "max904-github", "createdAt": "2021-01-08T14:56:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0MzMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0MzU5NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552443594", "bodyText": "Could be final?", "author": "trustin", "createdAt": "2021-01-06T08:52:25Z", "path": "oauth2/src/main/java/com/linecorp/armeria/internal/common/auth/oauth2/SerialFuture.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.auth.oauth2;\n+\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * Executes submitted {@link Callable} actions asynchronously in sequence.\n+ */\n+@UnstableApi\n+public class SerialFuture {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk5MTQ3OQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553991479", "bodyText": "fixed", "author": "max904-github", "createdAt": "2021-01-08T14:57:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0MzU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NDA0OQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552444049", "bodyText": "Could be final?", "author": "trustin", "createdAt": "2021-01-06T08:53:31Z", "path": "oauth2/src/main/java/com/linecorp/armeria/server/auth/oauth2/OAuth2TokenIntrospectionAuthorizer.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.auth.oauth2;\n+\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.UNSUPPORTED_TOKEN_TYPE;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.cache.Cache;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.auth.OAuth2Token;\n+import com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor;\n+import com.linecorp.armeria.internal.server.auth.oauth2.TokenIntrospectionRequest;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.auth.AuthFailureHandler;\n+import com.linecorp.armeria.server.auth.Authorizer;\n+\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Determines whether a given {@link OAuth2Token} is authorized for the service registered in using OAuth 2.0\n+ * Token Introspection. {@code ctx} can be used for storing authorization information about the request for use\n+ * in business logic.\n+ */\n+@UnstableApi\n+public class OAuth2TokenIntrospectionAuthorizer implements Authorizer<OAuth2Token> {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk5MTc5Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553991796", "bodyText": "fixed", "author": "max904-github", "createdAt": "2021-01-08T14:57:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NDA0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NDIzNA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552444234", "bodyText": "permittedScopes?", "author": "trustin", "createdAt": "2021-01-06T08:53:54Z", "path": "oauth2/src/main/java/com/linecorp/armeria/server/auth/oauth2/OAuth2TokenIntrospectionAuthorizer.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.auth.oauth2;\n+\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.UNSUPPORTED_TOKEN_TYPE;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.cache.Cache;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.auth.OAuth2Token;\n+import com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor;\n+import com.linecorp.armeria.internal.server.auth.oauth2.TokenIntrospectionRequest;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.auth.AuthFailureHandler;\n+import com.linecorp.armeria.server.auth.Authorizer;\n+\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Determines whether a given {@link OAuth2Token} is authorized for the service registered in using OAuth 2.0\n+ * Token Introspection. {@code ctx} can be used for storing authorization information about the request for use\n+ * in business logic.\n+ */\n+@UnstableApi\n+public class OAuth2TokenIntrospectionAuthorizer implements Authorizer<OAuth2Token> {\n+\n+    /**\n+     * Returns a newly created {@link OAuth2TokenIntrospectionAuthorizerBuilder}.\n+     *\n+     * @param introspectionEndpoint A {@link WebClient} to facilitate the Token Introspection request. Must\n+     *                              correspond to the Token Introspection endpoint of the OAuth 2.0 system.\n+     * @param introspectionEndpointPath A URI path that corresponds to the Token Introspection endpoint of the\n+     *                                  OAuth 2.0 system.\n+     */\n+    public static OAuth2TokenIntrospectionAuthorizerBuilder builder(WebClient introspectionEndpoint,\n+                                                                    String introspectionEndpointPath) {\n+        return new OAuth2TokenIntrospectionAuthorizerBuilder(introspectionEndpoint, introspectionEndpointPath);\n+    }\n+\n+    static final AttributeKey<Integer> ERROR_CODE = AttributeKey.valueOf(\"x-oauth2-error\");\n+    static final AttributeKey<String> ERROR_TYPE = AttributeKey.valueOf(\"x-oauth2-error-type\");\n+    static final String INVALID_TOKEN = \"invalid_token\";\n+    static final String INSUFFICIENT_SCOPE = \"insufficient_scope\";\n+\n+    private final Cache<String, OAuth2TokenDescriptor> tokenCache;\n+    private final Set<String> permittedScope;\n+    @Nullable\n+    private final String accessTokenType;\n+    @Nullable\n+    private final String realm;\n+    private final TokenIntrospectionRequest tokenIntrospectionRequest;\n+    private final AuthFailureHandler authFailureHandler;\n+\n+    OAuth2TokenIntrospectionAuthorizer(Cache<String, OAuth2TokenDescriptor> tokenCache,\n+                                       @Nullable String accessTokenType, @Nullable String realm,\n+                                       Set<String> permittedScope,\n+                                       TokenIntrospectionRequest tokenIntrospectionRequest) {\n+        this.tokenCache = requireNonNull(tokenCache, \"tokenCache\");\n+        this.accessTokenType = accessTokenType;\n+        this.realm = realm;\n+        this.permittedScope = requireNonNull(permittedScope, \"permittedScope\");\n+        this.tokenIntrospectionRequest =\n+                requireNonNull(tokenIntrospectionRequest, \"tokenIntrospectionRequest\");\n+        authFailureHandler =\n+                new OAuth2AuthorizationFailureHandler(accessTokenType, realm, String.join(\" \", permittedScope));\n+    }\n+\n+    /**\n+     * Scopes permitted by this authorizer. The authorizer will accept any scope if empty.\n+     */\n+    public Set<String> permittedScope() {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk5Mjg3MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553992871", "bodyText": "scope is a set of roles/tokens, as per the spec. I wanted to be close to the spec and named it scope in multiple places.", "author": "max904-github", "createdAt": "2021-01-08T14:59:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NDIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NDMyNw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552444327", "bodyText": "permittedScopes?", "author": "trustin", "createdAt": "2021-01-06T08:54:09Z", "path": "oauth2/src/main/java/com/linecorp/armeria/server/auth/oauth2/OAuth2TokenIntrospectionAuthorizer.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.auth.oauth2;\n+\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.UNSUPPORTED_TOKEN_TYPE;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.cache.Cache;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.auth.OAuth2Token;\n+import com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor;\n+import com.linecorp.armeria.internal.server.auth.oauth2.TokenIntrospectionRequest;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.auth.AuthFailureHandler;\n+import com.linecorp.armeria.server.auth.Authorizer;\n+\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Determines whether a given {@link OAuth2Token} is authorized for the service registered in using OAuth 2.0\n+ * Token Introspection. {@code ctx} can be used for storing authorization information about the request for use\n+ * in business logic.\n+ */\n+@UnstableApi\n+public class OAuth2TokenIntrospectionAuthorizer implements Authorizer<OAuth2Token> {\n+\n+    /**\n+     * Returns a newly created {@link OAuth2TokenIntrospectionAuthorizerBuilder}.\n+     *\n+     * @param introspectionEndpoint A {@link WebClient} to facilitate the Token Introspection request. Must\n+     *                              correspond to the Token Introspection endpoint of the OAuth 2.0 system.\n+     * @param introspectionEndpointPath A URI path that corresponds to the Token Introspection endpoint of the\n+     *                                  OAuth 2.0 system.\n+     */\n+    public static OAuth2TokenIntrospectionAuthorizerBuilder builder(WebClient introspectionEndpoint,\n+                                                                    String introspectionEndpointPath) {\n+        return new OAuth2TokenIntrospectionAuthorizerBuilder(introspectionEndpoint, introspectionEndpointPath);\n+    }\n+\n+    static final AttributeKey<Integer> ERROR_CODE = AttributeKey.valueOf(\"x-oauth2-error\");\n+    static final AttributeKey<String> ERROR_TYPE = AttributeKey.valueOf(\"x-oauth2-error-type\");\n+    static final String INVALID_TOKEN = \"invalid_token\";\n+    static final String INSUFFICIENT_SCOPE = \"insufficient_scope\";\n+\n+    private final Cache<String, OAuth2TokenDescriptor> tokenCache;\n+    private final Set<String> permittedScope;\n+    @Nullable\n+    private final String accessTokenType;\n+    @Nullable\n+    private final String realm;\n+    private final TokenIntrospectionRequest tokenIntrospectionRequest;\n+    private final AuthFailureHandler authFailureHandler;\n+\n+    OAuth2TokenIntrospectionAuthorizer(Cache<String, OAuth2TokenDescriptor> tokenCache,\n+                                       @Nullable String accessTokenType, @Nullable String realm,\n+                                       Set<String> permittedScope,", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk5MzA0MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553993041", "bodyText": "same as previous comment", "author": "max904-github", "createdAt": "2021-01-08T14:59:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NDMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NTYwNw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552445607", "bodyText": "final?", "author": "trustin", "createdAt": "2021-01-06T08:56:50Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/OAuth2TokenDescriptor.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.ACTIVE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.AUDIENCE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.CLIENT_ID;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.EXPIRES_AT;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.ISSUED_AT;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.ISSUER;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.JWT_ID;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.NOT_BEFORE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.SCOPE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.SUBJECT;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.TOKEN_TYPE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.USER_NAME;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.ResponseParserUtil.JSON;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants;\n+\n+/**\n+ * Defines a structure of the Token Introspection Response, as per\n+ * <a href=\"https://tools.ietf.org/html/rfc7662#section-2.2\">[RFC7662], Section 2.2</a>.\n+ */\n+@UnstableApi\n+public class OAuth2TokenDescriptor implements Serializable {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk5NDk3OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553994978", "bodyText": "prefer to keep it not final, as it's likely to be extended in future once we get to deal with some more specific token vendors.", "author": "max904-github", "createdAt": "2021-01-08T15:02:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NTYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NTg0MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552445840", "bodyText": "Maybe parse is a better name?", "author": "trustin", "createdAt": "2021-01-06T08:57:17Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/OAuth2TokenDescriptor.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.ACTIVE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.AUDIENCE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.CLIENT_ID;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.EXPIRES_AT;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.ISSUED_AT;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.ISSUER;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.JWT_ID;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.NOT_BEFORE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.SCOPE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.SUBJECT;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.TOKEN_TYPE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.USER_NAME;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.ResponseParserUtil.JSON;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants;\n+\n+/**\n+ * Defines a structure of the Token Introspection Response, as per\n+ * <a href=\"https://tools.ietf.org/html/rfc7662#section-2.2\">[RFC7662], Section 2.2</a>.\n+ */\n+@UnstableApi\n+public class OAuth2TokenDescriptor implements Serializable {\n+\n+    private static final long serialVersionUID = -3976877781134216467L;\n+\n+    /**\n+     * Creates a new {@link OAuth2TokenDescriptor} based on the {@code JSON}-formatted raw response body.\n+     * @param rawResponse {@code JSON}-formatted raw response body.\n+     * @return A new instance of {@link OAuth2TokenDescriptor}.\n+     */\n+    public static OAuth2TokenDescriptor of(String rawResponse) {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk5NzExNQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553997115", "bodyText": "agree. changed", "author": "max904-github", "createdAt": "2021-01-08T15:06:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NTg0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NjM3NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552446375", "bodyText": "Could be final?", "author": "trustin", "createdAt": "2021-01-06T08:58:34Z", "path": "oauth2/src/main/java/com/linecorp/armeria/internal/client/auth/oauth2/AbstractAccessTokenRequest.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.client.auth.oauth2;\n+\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.SCOPE;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken;\n+import com.linecorp.armeria.internal.common.auth.oauth2.AbstractOAuth2Request;\n+\n+/**\n+ * A common abstraction for the requests implementing various Access Token request/response flows,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a>.\n+ */\n+@UnstableApi\n+public abstract class AbstractAccessTokenRequest extends AbstractOAuth2Request<GrantedOAuth2AccessToken> {\n+\n+    /**\n+     * A common abstraction for the requests implementing various Access Token request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a>.\n+     *\n+     * @param accessTokenEndpoint A {@link WebClient} to facilitate an Access Token request. Must correspond to\n+     *                            the Access Token endpoint of the OAuth 2 system.\n+     * @param accessTokenEndpointPath A URI path that corresponds to the Access Token endpoint of the\n+     *                                OAuth 2 system.\n+     * @param clientAuthorization Provides client authorization for the OAuth requests,\n+     *                            as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     */\n+    protected AbstractAccessTokenRequest(WebClient accessTokenEndpoint, String accessTokenEndpointPath,\n+                                         @Nullable ClientAuthorization clientAuthorization) {\n+        super(accessTokenEndpoint, accessTokenEndpointPath, clientAuthorization);\n+    }\n+\n+    /**\n+     * Extracts data from Access Token OK response and converts it to the target\n+     * type {@link GrantedOAuth2AccessToken}.\n+     */\n+    @Override\n+    protected GrantedOAuth2AccessToken extractOkResults(AggregatedHttpResponse response,", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk5ODYxMg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553998612", "bodyText": "prefer to keep it open", "author": "max904-github", "createdAt": "2021-01-08T15:08:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NjM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NjU4Mw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552446583", "bodyText": "call()?", "author": "trustin", "createdAt": "2021-01-06T08:59:01Z", "path": "oauth2/src/main/java/com/linecorp/armeria/internal/common/auth/oauth2/SerialFuture.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.auth.oauth2;\n+\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * Executes submitted {@link Callable} actions asynchronously in sequence.\n+ */\n+@UnstableApi\n+public class SerialFuture {\n+\n+    private final Queue<Runnable> actions = new LinkedList<>();\n+\n+    @Nullable\n+    private Runnable active;\n+\n+    @Nullable\n+    Executor executor;\n+\n+    /**\n+     * Constructs {@link SerialFuture} with a supplied {@link Executor}.\n+     * @param executor An {@link Executor} to execute asynchronous actions.\n+     */\n+    public SerialFuture(@Nullable Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    /**\n+     * Constructs {@link SerialFuture}.\n+     */\n+    public SerialFuture() {\n+        this(null);\n+    }\n+\n+    /**\n+     * Executes submitted {@link Callable} action asynchronously in sequence.\n+     * @param action An asynchronous {@link Callable} action to be executed in sequence.\n+     *               It returns {@link CompletionStage} that produces the final result when the action\n+     *               completes.\n+     * @return Returns a new {@link CompletionStage} with the same result or exception as the {@code action},\n+     *         that executes the given action when this stage completes.\n+     */\n+    public synchronized <V> CompletionStage<V> executeAsync(Callable<CompletionStage<V>> action) {\n+        final CompletableFuture<V> result = new CompletableFuture<>();\n+        actions.add(() -> {\n+            final CompletionStage<V> future;\n+            try {\n+                future = action.call();\n+            } catch (Throwable e) {\n+                result.completeExceptionally(Exceptions.peel(e));\n+                executeNext();\n+                return;\n+            }\n+            // replaced CompletableFuture.whenComplete() with CompletableFuture.handle()\n+            // due to performance issue described at\n+            // <a href=\"https://github.com/line/armeria/pull/1440\">#1440</a>.\n+            future.handle((v, ex) -> {\n+                if (ex == null) {\n+                    result.complete(v);\n+                } else {\n+                    result.completeExceptionally(ex);\n+                }\n+                executeNext();\n+                //noinspection ReturnOfNull\n+                return null;\n+            });\n+        });\n+\n+        if (active == null) {\n+            executeNext();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Calls submitted {@link Callable} action asynchronously in sequence.\n+     * @param action A {@link Callable} action to be called asynchronously in sequence.\n+     *               It returns that produces the final result of computation.\n+     * @return Returns a new {@link CompletionStage} with the same result or exception as the {@code action},\n+     *         that executes the given action when this stage completes.\n+     */\n+    public synchronized <V> CompletionStage<V> callAsync(Callable<V> action) {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NjY2OQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552446669", "bodyText": "execute()?", "author": "trustin", "createdAt": "2021-01-06T08:59:13Z", "path": "oauth2/src/main/java/com/linecorp/armeria/internal/common/auth/oauth2/SerialFuture.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.auth.oauth2;\n+\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * Executes submitted {@link Callable} actions asynchronously in sequence.\n+ */\n+@UnstableApi\n+public class SerialFuture {\n+\n+    private final Queue<Runnable> actions = new LinkedList<>();\n+\n+    @Nullable\n+    private Runnable active;\n+\n+    @Nullable\n+    Executor executor;\n+\n+    /**\n+     * Constructs {@link SerialFuture} with a supplied {@link Executor}.\n+     * @param executor An {@link Executor} to execute asynchronous actions.\n+     */\n+    public SerialFuture(@Nullable Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    /**\n+     * Constructs {@link SerialFuture}.\n+     */\n+    public SerialFuture() {\n+        this(null);\n+    }\n+\n+    /**\n+     * Executes submitted {@link Callable} action asynchronously in sequence.\n+     * @param action An asynchronous {@link Callable} action to be executed in sequence.\n+     *               It returns {@link CompletionStage} that produces the final result when the action\n+     *               completes.\n+     * @return Returns a new {@link CompletionStage} with the same result or exception as the {@code action},\n+     *         that executes the given action when this stage completes.\n+     */\n+    public synchronized <V> CompletionStage<V> executeAsync(Callable<CompletionStage<V>> action) {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk5OTk1Mw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r553999953", "bodyText": "prefer to keep it the way it is. semantics reflect the nature of the execution (similar to CompletableFuture). this is just an internal utility class.", "author": "max904-github", "createdAt": "2021-01-08T15:11:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NjY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTc0ODE5Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r561748197", "bodyText": "No problem with that.", "author": "trustin", "createdAt": "2021-01-21T10:05:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NjY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NzI3MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552447270", "bodyText": "Would it be better renaming to parse(..)?", "author": "trustin", "createdAt": "2021-01-06T09:00:38Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/GrantedOAuth2AccessToken.java", "diffHunk": "@@ -0,0 +1,407 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.ACCESS_TOKEN;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.DEFAULT_TOKEN_TYPE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.EXPIRES_IN;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.REFRESH_TOKEN;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.SCOPE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.TOKEN_TYPE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.ResponseParserUtil.JSON;\n+import static java.time.format.DateTimeFormatter.ISO_INSTANT;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.internal.common.auth.oauth2.CaseUtil;\n+import com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants;\n+\n+/**\n+ * Defines a structure of the Access Token Response, as per\n+ * <a href=\"https://tools.ietf.org/html/rfc6749#section-5.1\">[RFC6749], Section 5.1</a>.\n+ */\n+@UnstableApi\n+public class GrantedOAuth2AccessToken implements Serializable {\n+\n+    private static final long serialVersionUID = 8698118404098897958L;\n+\n+    /**\n+     * Creates a new {@link GrantedOAuth2AccessToken} based on the {@code JSON}-formatted raw response body and\n+     * optional raw formatted {@code scope} used to request the token.\n+     * @param rawResponse {@code JSON}-formatted raw response body.\n+     * @param requestScope OPTIONAL. A list of space-delimited, case-sensitive strings.\n+     *                     The strings are defined by the authorization server.\n+     *                     The authorization server MAY fully or partially ignore the scope requested by the\n+     *                     client, based on the authorization server policy or the resource owner's\n+     *                     instructions. If the issued access token scope is different from the one requested\n+     *                     by the client, the authorization server MUST include the \"scope\" response\n+     *                     parameter to inform the client of the actual scope granted.\n+     *                     If the client omits the scope parameter when requesting authorization, the\n+     *                     authorization server MUST either process the request using a pre-defined default\n+     *                     value or fail the request indicating an invalid scope.\n+     * @return A new instance of {@link GrantedOAuth2AccessToken}.\n+     */\n+    public static GrantedOAuth2AccessToken of(String rawResponse, @Nullable String requestScope) {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDAwMDE4NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r554000184", "bodyText": "agree. changed", "author": "max904-github", "createdAt": "2021-01-08T15:11:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NzI3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NzQwNA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552447404", "bodyText": "parse(...)?", "author": "trustin", "createdAt": "2021-01-06T09:00:56Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/GrantedOAuth2AccessTokenBuilder.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken.ISSUED_AT;\n+import static com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor.SCOPE_SEPARATOR;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.ACCESS_TOKEN;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.EXPIRES_IN;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.REFRESH_TOKEN;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.SCOPE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.TOKEN_TYPE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.ResponseParserUtil.JSON;\n+import static java.time.format.DateTimeFormatter.ISO_INSTANT;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants;\n+\n+/**\n+ * Builds an instance of {@link GrantedOAuth2AccessToken}.\n+ */\n+@UnstableApi\n+public final class GrantedOAuth2AccessTokenBuilder {\n+\n+    private static final TypeReference<LinkedHashMap<String, String>> MAP_TYPE =\n+            new TypeReference<LinkedHashMap<String, String>>() {};\n+\n+    static GrantedOAuth2AccessToken of(String rawResponse, @Nullable String requestScope) {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDAwMDM0MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r554000341", "bodyText": "agree. changed", "author": "max904-github", "createdAt": "2021-01-08T15:11:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NzQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ1MTM4MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552451381", "bodyText": "This class doesn't seem to be used anywhere. Is this something you're gonna use in your follow-up PR?\nIs this class meant to be used by a user? If not, we could move it to internal.common.auth.oauth2 package.", "author": "trustin", "createdAt": "2021-01-06T09:09:01Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/TokenRevocation.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.ACCESS_TOKEN;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.REFRESH_TOKEN;\n+\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.internal.common.auth.oauth2.TokenRevocationRequest;\n+\n+/**\n+ * Implements Token Revocation request/response flow,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc7009\">[RFC7009]</a>.\n+ */\n+@UnstableApi\n+public final class TokenRevocation {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDAwMzYyNg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r554003626", "bodyText": "Yes, this class is meant to be used directly by the user, either on the server or on the client side. Token revocation capability is an important part of OAuth 2.", "author": "max904-github", "createdAt": "2021-01-08T15:16:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ1MTM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTc0NzkyMA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r561747920", "bodyText": "Excellent. Sounds good to me.", "author": "trustin", "createdAt": "2021-01-21T10:05:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ1MTM4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ1Mzc4Mg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r552453782", "bodyText": "Should we rename to scopes()?", "author": "trustin", "createdAt": "2021-01-06T09:13:59Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/GrantedOAuth2AccessTokenBuilder.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken.ISSUED_AT;\n+import static com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor.SCOPE_SEPARATOR;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.ACCESS_TOKEN;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.EXPIRES_IN;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.REFRESH_TOKEN;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.SCOPE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.TOKEN_TYPE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.ResponseParserUtil.JSON;\n+import static java.time.format.DateTimeFormatter.ISO_INSTANT;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants;\n+\n+/**\n+ * Builds an instance of {@link GrantedOAuth2AccessToken}.\n+ */\n+@UnstableApi\n+public final class GrantedOAuth2AccessTokenBuilder {\n+\n+    private static final TypeReference<LinkedHashMap<String, String>> MAP_TYPE =\n+            new TypeReference<LinkedHashMap<String, String>>() {};\n+\n+    static GrantedOAuth2AccessToken of(String rawResponse, @Nullable String requestScope) {\n+\n+        final LinkedHashMap<String, String> map;\n+        try {\n+            map = JSON.readValue(requireNonNull(rawResponse, \"rawResponse\"), MAP_TYPE);\n+        } catch (JsonProcessingException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        final GrantedOAuth2AccessTokenBuilder builder =\n+                new GrantedOAuth2AccessTokenBuilder(requireNonNull(map.remove(ACCESS_TOKEN), ACCESS_TOKEN));\n+\n+        final String tokenType = map.remove(TOKEN_TYPE);\n+        if (tokenType != null) {\n+            builder.tokenType(tokenType);\n+        }\n+        final String issuedAt = map.remove(ISSUED_AT);\n+        if (issuedAt != null) {\n+            builder.issuedAt(ISO_INSTANT.parse(issuedAt, Instant::from));\n+        }\n+        final String expiresIn = map.remove(EXPIRES_IN);\n+        if (expiresIn != null) {\n+            builder.expiresIn(Duration.ofSeconds(Long.parseLong(expiresIn)));\n+        }\n+        final String refreshToken = map.remove(REFRESH_TOKEN);\n+        if (refreshToken != null) {\n+            builder.refreshToken(refreshToken);\n+        }\n+        String scope = map.remove(SCOPE);\n+        if (scope == null) {\n+            scope = requestScope;\n+        }\n+        if (scope != null) {\n+            builder.scope(scope.split(SCOPE_SEPARATOR));\n+        }\n+        builder.extras(map);\n+\n+        builder.rawResponse(rawResponse);\n+\n+        return builder.build();\n+    }\n+\n+    private final String accessToken;\n+\n+    @Nullable\n+    private String tokenType;\n+\n+    @Nullable\n+    private Duration expiresIn;\n+\n+    @Nullable\n+    private String refreshToken;\n+\n+    private final ImmutableList.Builder<String> scope = ImmutableList.builder();\n+\n+    private final ImmutableMap.Builder<String, String> extras = ImmutableMap.builder();\n+\n+    @Nullable\n+    private Instant issuedAt;\n+\n+    @Nullable\n+    private String rawResponse;\n+\n+    /**\n+     * Constructs a new instance of {@link GrantedOAuth2AccessTokenBuilder} given the mandatory value\n+     * {@value OAuth2Constants#ACCESS_TOKEN} of the access token issued by the authorization server.\n+     * @param accessToken {@value OAuth2Constants#ACCESS_TOKEN} Access Token response field,\n+     *                    REQUIRED. The access token issued by the authorization server.\n+     */\n+    GrantedOAuth2AccessTokenBuilder(String accessToken) {\n+        this.accessToken = requireNonNull(accessToken, \"accessToken\");\n+    }\n+\n+    /**\n+     * {@value OAuth2Constants#TOKEN_TYPE} Access Token response field,\n+     * REQUIRED. The type of the token issued as described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-7.1\">[RFC6749], Section 7.1</a>.\n+     * Value is case insensitive.\n+     */\n+    public GrantedOAuth2AccessTokenBuilder tokenType(String tokenType) {\n+        this.tokenType = requireNonNull(tokenType, \"tokenType\");\n+        return this;\n+    }\n+\n+    /**\n+     * {@value OAuth2Constants#EXPIRES_IN} Access Token response field,\n+     * RECOMMENDED. {@link Duration} indicating the lifetime of the access token. For example,\n+     * the value 3600 seconds denotes that the access token will expire in one hour from the time\n+     * the response was generated. If omitted, the authorization server SHOULD provide the expiration\n+     * time via other means or document the default value.\n+     */\n+    public GrantedOAuth2AccessTokenBuilder expiresIn(Duration expiresIn) {\n+        this.expiresIn = requireNonNull(expiresIn, \"expiresIn\");\n+        return this;\n+    }\n+\n+    /**\n+     * An {@link Instant} indicating when the Access Token was issued,\n+     * OPTIONAL. The value is NOT supplied with the Access Token response and calculated approximately using\n+     * {@value OAuth2Constants#EXPIRES_IN} field.\n+     */\n+    public GrantedOAuth2AccessTokenBuilder issuedAt(Instant issuedAt) {\n+        this.issuedAt = requireNonNull(issuedAt, \"issuedAt\");\n+        return this;\n+    }\n+\n+    /**\n+     * {@value OAuth2Constants#REFRESH_TOKEN} Access Token response field,\n+     * OPTIONAL. The refresh token, which can be used to obtain new access tokens using the same\n+     * authorization grant as described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-6\">[RFC6749], Section 6</a>.\n+     */\n+    public GrantedOAuth2AccessTokenBuilder refreshToken(String refreshToken) {\n+        this.refreshToken = requireNonNull(refreshToken, \"refreshToken\");\n+        return this;\n+    }\n+\n+    /**\n+     * {@value OAuth2Constants#SCOPE} Access Token Response field,\n+     * OPTIONAL. An {@link Iterable} of individual scope values.\n+     */\n+    public GrantedOAuth2AccessTokenBuilder scope(Iterable<String> scope) {", "originalCommit": "d5a2061fbc22a4eef3b9cad11dc35c485638c67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDAwNDA1NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r554004054", "bodyText": "scope is a set of roles/tokens, as per the spec. I wanted to be close to the spec and named it scope in multiple places.", "author": "max904-github", "createdAt": "2021-01-08T15:17:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ1Mzc4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTc0NzY3OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r561747678", "bodyText": "I see. Thanks a lot for education.", "author": "trustin", "createdAt": "2021-01-21T10:04:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ1Mzc4Mg=="}], "type": "inlineReview"}, {"oid": "e5581c70d971f62eb34c2226861e6edadabd386d", "url": "https://github.com/line/armeria/commit/e5581c70d971f62eb34c2226861e6edadabd386d", "message": "More review comments by @trustin - Various minor changes.\nNot yet the final set - need to solve Authorizer.successHandler()/failureHandler() problem!", "committedDate": "2021-01-08T15:52:52Z", "type": "commit"}, {"oid": "ebb4822c919067ba8c42888f55f70fae5a7e418b", "url": "https://github.com/line/armeria/commit/ebb4822c919067ba8c42888f55f70fae5a7e418b", "message": "Another attempt to make Authorizer chaining right", "committedDate": "2021-01-08T21:41:10Z", "type": "commit"}, {"oid": "3dda250ada08c00be95ddb63f284a3e74f35fa25", "url": "https://github.com/line/armeria/commit/3dda250ada08c00be95ddb63f284a3e74f35fa25", "message": "Optimized SerialFuture implementation:\n- replaced 'serialized' with ReentrantReadWriteLock and replaced LinkedList with ConcurrentLinkedQueue,\n- refactored the test using JUnit5 @ParameterizedTest", "committedDate": "2021-01-15T08:44:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzEwODY0MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563108640", "bodyText": "Incorrect class name?", "author": "trustin", "createdAt": "2021-01-23T11:14:22Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/InvalidResponseException.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+\n+/**\n+ * An HTTP response that is not valid for the given request/response flow.\n+ */\n+@UnstableApi\n+public class InvalidResponseException extends RuntimeException {\n+\n+    private static final long serialVersionUID = -6985569386139579552L;\n+\n+    private final String status;\n+\n+    /**\n+     * Constructs new {@link UnsupportedMediaTypeException}.", "originalCommit": "e5581c70d971f62eb34c2226861e6edadabd386d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkyNDg3Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563924876", "bodyText": "Fixed", "author": "max904-github", "createdAt": "2021-01-25T17:53:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzEwODY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzExMTgwNA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563111804", "bodyText": "Could just use AtomicInteger?", "author": "trustin", "createdAt": "2021-01-23T11:18:22Z", "path": "oauth2/src/test/java/com/linecorp/armeria/internal/common/auth/oauth2/SerialFutureTest.java", "diffHunk": "@@ -18,427 +18,263 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n-import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n import java.util.concurrent.Callable;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.Executor;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ForkJoinPool;\n+import java.util.function.IntFunction;\n+import java.util.stream.Collectors;\n \n-import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n \n public class SerialFutureTest {\n \n-    volatile int counter;\n-\n-    @Test\n-    void testExecuteAsyncWithExecutorInParallel1() throws Exception {\n-        final Executor executor = Executors.newWorkStealingPool();\n-        final SerialFuture serialFuture = new SerialFuture();\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testExecuteAsync1(boolean withExecutor) throws Exception {\n+        final Executor executor = withExecutor ? Executors.newWorkStealingPool() : null;\n+        final SerialFuture serialFuture = new SerialFuture(executor);\n \n-        final int n = 10;\n+        final int inc = 1;\n+        final int count = 20;\n         final long timeout = 10L;\n-        counter = 0;\n-\n-        // test action that allows invoking serialFuture#executeAsync(Callable) in parallel\n-        // use Executor to implement asynchronous Callable action\n-        final Callable<CompletableFuture<Integer>> testAction = () ->\n-            serialFuture.executeAsync(() ->\n-                CompletableFuture.supplyAsync(() -> {\n-                    int c = counter;\n-                    try {\n-                        Thread.sleep(timeout);\n-                    } catch (InterruptedException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                    c += 1;\n-                    counter = c;\n-                    return c;\n-                }, executor)\n-            ).toCompletableFuture();\n-        final List<Callable<CompletableFuture<Integer>>> testActions = new ArrayList<>(n);\n-        for (int i = 0; i < n; i++) {\n-            testActions.add(testAction);\n-        }\n-\n-        // invoke test actions in parallel\n-        final ForkJoinPool pool = new ForkJoinPool(n);\n-        final CompletableFuture<?>[] futures = pool.invokeAll(testActions).parallelStream().map(f -> {\n-            try {\n-                return f.get();\n-            } catch (InterruptedException | ExecutionException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }).toArray(CompletableFuture[]::new);\n-\n+        final int[] seq = createArithmeticSequence(inc, inc, count);\n+\n+        final VolatileCounter counter = new VolatileCounter();\n+        final IntFunction<CompletableFuture<Integer>> testAction = i ->\n+                serialFuture.executeAsync(() -> timeoutAction(counter, inc, timeout)).toCompletableFuture();\n+        final CompletableFuture<?>[] futures = Arrays.stream(seq)\n+                                                     .mapToObj(testAction)\n+                                                     .toArray(CompletableFuture[]::new);\n         // wait for all futures to complete\n         CompletableFuture.allOf(futures).join();\n \n-        assertThat(counter).isEqualTo(n);\n-        final int[] array = Arrays.stream(futures).mapToInt(future -> (Integer) future.join()).toArray();\n-        checkSequentialRange(array, n);\n+        assertThat(counter.get()).isEqualTo(count);\n+        final int[] array = Arrays.stream(futures).mapToInt(future -> (Integer) future.join())\n+                                  .toArray();\n+        assertThat(array).containsExactly(seq);\n     }\n \n-    @Test\n-    void testExecuteAsyncWithExecutorInParallel2() throws Exception {\n-        // execute all actions using dedicated Executor\n-        final Executor executor = Executors.newWorkStealingPool();\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testExecuteAsyncInParallel1(boolean withExecutor) throws Exception {\n+        final Executor executor = withExecutor ? Executors.newWorkStealingPool() : null;\n         final SerialFuture serialFuture = new SerialFuture(executor);\n \n-        final int n = 10;\n+        final int inc = 1;\n+        final int count = 20;\n         final long timeout = 10L;\n-        counter = 0;\n+        final int[] seq = createArithmeticSequence(inc, inc, count);\n \n-        // test action that allows invoking serialFuture#executeAsync(Callable) in parallel\n+        final VolatileCounter counter = new VolatileCounter();\n+        // test action that allows invoking serialFuture#callAsync(Callable) in parallel\n         // use Executor as part of SerialFuture instance\n         final Callable<CompletableFuture<Integer>> testAction = () ->\n-            serialFuture.executeAsync(() ->\n-                CompletableFuture.supplyAsync(() -> {\n-                    int c = counter;\n-                    try {\n-                        Thread.sleep(timeout);\n-                    } catch (InterruptedException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                    c += 1;\n-                    counter = c;\n-                    return c;\n-                })\n-            ).toCompletableFuture();\n-        final List<Callable<CompletableFuture<Integer>>> testActions = new ArrayList<>(n);\n-        for (int i = 0; i < n; i++) {\n-            testActions.add(testAction);\n-        }\n-\n+                serialFuture.executeAsync(() -> timeoutAction(counter, inc, timeout)).toCompletableFuture();\n+        final List<Callable<CompletableFuture<Integer>>> testActions = Arrays.stream(seq)\n+                                                                             .mapToObj(i -> testAction)\n+                                                                             .collect(Collectors.toList());\n         // invoke test actions in parallel\n-        final ForkJoinPool pool = new ForkJoinPool(n);\n+        final ForkJoinPool pool = new ForkJoinPool(count);\n         final CompletableFuture<?>[] futures = pool.invokeAll(testActions).parallelStream().map(f -> {\n             try {\n                 return f.get();\n             } catch (InterruptedException | ExecutionException e) {\n                 throw new RuntimeException(e);\n             }\n         }).toArray(CompletableFuture[]::new);\n+        // wait for all futures to complete\n+        CompletableFuture.allOf(futures).join();\n \n+        assertThat(counter.get()).isEqualTo(count);\n+        final int[] array = Arrays.stream(futures)\n+                                  .mapToInt(future -> (Integer) future.join())\n+                                  .toArray();\n+        System.out.println(Arrays.toString(array));\n+        assertThat(array).containsExactlyInAnyOrder(seq);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testExecuteAsync2(boolean withExecutor) throws Exception {\n+        final Executor executor = Executors.newWorkStealingPool();\n+        final SerialFuture serialFuture = new SerialFuture(withExecutor ? executor : null);\n+\n+        final int inc = 1;\n+        final int count = 20;\n+        final long timeout = 10L;\n+        final int[] seq = createArithmeticSequence(inc, inc, count);\n+\n+        final VolatileCounter counter = new VolatileCounter();\n+        final IntFunction<CompletableFuture<Integer>> testAction = i ->\n+                serialFuture.executeAsync(() ->\n+                                                  CompletableFuture.supplyAsync(() ->\n+                                                                                        simpleTimeoutAction(\n+                                                                                                counter, inc,\n+                                                                                                timeout),\n+                                                                                executor))\n+                            .toCompletableFuture();\n+        final CompletableFuture<?>[] futures = Arrays.stream(seq)\n+                                                     .mapToObj(testAction)\n+                                                     .toArray(CompletableFuture[]::new);\n         // wait for all futures to complete\n         CompletableFuture.allOf(futures).join();\n \n-        assertThat(counter).isEqualTo(n);\n-        final int[] array = Arrays.stream(futures).mapToInt(future -> (Integer) future.join()).toArray();\n-        checkSequentialRange(array, n);\n+        assertThat(counter.get()).isEqualTo(count);\n+        final int[] array = Arrays.stream(futures).mapToInt(future -> (Integer) future.join())\n+                                  .toArray();\n+        assertThat(array).containsExactly(seq);\n     }\n \n-    @Test\n-    void testExecuteAsyncWithoutExecutorInParallel() throws Exception {\n-        // do not use Executor, execute all actions from the invoker thread\n-        final SerialFuture serialFuture = new SerialFuture();\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testExecuteAsyncInParallel2(boolean withExecutor) throws Exception {\n+        final Executor executor = Executors.newWorkStealingPool();\n+        final SerialFuture serialFuture = new SerialFuture(withExecutor ? executor : null);\n \n-        final int n = 10;\n+        final int inc = 1;\n+        final int count = 20;\n         final long timeout = 10L;\n-        counter = 0;\n+        final int[] seq = createArithmeticSequence(inc, inc, count);\n \n-        // test action that allows invoking serialFuture#executeAsync(Callable) in parallel\n+        final VolatileCounter counter = new VolatileCounter();\n+        // test action that allows invoking serialFuture#callAsync(Callable) in parallel\n+        // use Executor as part of SerialFuture instance\n         final Callable<CompletableFuture<Integer>> testAction = () ->\n-            serialFuture.executeAsync(() ->\n-                CompletableFuture.supplyAsync(() -> {\n-                    int c = counter;\n-                    try {\n-                        Thread.sleep(timeout);\n-                    } catch (InterruptedException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                    c += 1;\n-                    counter = c;\n-                    return c;\n-                })\n-            ).toCompletableFuture();\n-        final List<Callable<CompletableFuture<Integer>>> testActions = new ArrayList<>(n);\n-        for (int i = 0; i < n; i++) {\n-            testActions.add(testAction);\n-        }\n-\n+                serialFuture.executeAsync(() ->\n+                                                  CompletableFuture.supplyAsync(() ->\n+                                                                                        simpleTimeoutAction(\n+                                                                                                counter, inc,\n+                                                                                                timeout),\n+                                                                                executor))\n+                            .toCompletableFuture();\n+        final List<Callable<CompletableFuture<Integer>>> testActions = Arrays.stream(seq)\n+                                                                             .mapToObj(i -> testAction)\n+                                                                             .collect(Collectors.toList());\n         // invoke test actions in parallel\n-        final ForkJoinPool pool = new ForkJoinPool(n);\n+        final ForkJoinPool pool = new ForkJoinPool(count);\n         final CompletableFuture<?>[] futures = pool.invokeAll(testActions).parallelStream().map(f -> {\n             try {\n                 return f.get();\n             } catch (InterruptedException | ExecutionException e) {\n                 throw new RuntimeException(e);\n             }\n         }).toArray(CompletableFuture[]::new);\n-\n         // wait for all futures to complete\n         CompletableFuture.allOf(futures).join();\n \n-        assertThat(counter).isEqualTo(n);\n-        final int[] array = Arrays.stream(futures).mapToInt(future -> (Integer) future.join()).toArray();\n-        checkSequentialRange(array, n);\n+        assertThat(counter.get()).isEqualTo(count);\n+        final int[] array = Arrays.stream(futures).mapToInt(future -> (Integer) future.join())\n+                                  .toArray();\n+        System.out.println(Arrays.toString(array));\n+        assertThat(array).containsExactlyInAnyOrder(seq);\n     }\n \n-    @Test\n-    void testExecuteAsyncWithExecutor1() throws Exception {\n-        final Executor executor = Executors.newWorkStealingPool();\n-        final SerialFuture serialFuture = new SerialFuture();\n-\n-        final int n = 10;\n-        final long timeout = 10L;\n-        counter = 0;\n-\n-        final CompletableFuture<?>[] futures = new CompletableFuture<?>[n];\n-        // invoke serialFuture#executeAsync(Callable) one by one from the test thread\n-        // use Executor to implement asynchronous Callable action\n-        for (int i = 0; i < n; i++) {\n-            futures[i] = serialFuture.executeAsync(() ->\n-                CompletableFuture.supplyAsync(() -> {\n-                    int c = counter;\n-                    try {\n-                        Thread.sleep(timeout);\n-                    } catch (InterruptedException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                    c += 1;\n-                    counter = c;\n-                    return c;\n-                }, executor)\n-            ).toCompletableFuture();\n-        }\n-        CompletableFuture.allOf(futures).join();\n-\n-        assertThat(counter).isEqualTo(n);\n-        final int[] array = Arrays.stream(futures).mapToInt(future -> (Integer) future.join()).toArray();\n-        checkSequentialRange(array, n);\n-    }\n-\n-    @Test\n-    void testExecuteAsyncWithExecutor2() throws Exception {\n-        // execute all actions using dedicated Executor\n-        final Executor executor = Executors.newWorkStealingPool();\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testCallAsync(boolean withExecutor) throws Exception {\n+        final Executor executor = withExecutor ? Executors.newWorkStealingPool() : null;\n         final SerialFuture serialFuture = new SerialFuture(executor);\n \n-        final int n = 10;\n+        final int inc = 1;\n+        final int count = 20;\n         final long timeout = 10L;\n-        counter = 0;\n-\n-        final CompletableFuture<?>[] futures = new CompletableFuture<?>[n];\n-        // invoke serialFuture#executeAsync(Callable) one by one from the test thread\n-        // use Executor as part of SerialFuture instance\n-        for (int i = 0; i < n; i++) {\n-            futures[i] = serialFuture.executeAsync(() -> {\n-                int c = counter;\n-                try {\n-                    Thread.sleep(timeout);\n-                } catch (InterruptedException e) {\n-                    throw new RuntimeException(e);\n-                }\n-                c += 1;\n-                counter = c;\n-                return CompletableFuture.completedFuture(c);\n-            }).toCompletableFuture();\n-        }\n-        CompletableFuture.allOf(futures).join();\n-\n-        assertThat(counter).isEqualTo(n);\n-        final int[] array = Arrays.stream(futures).mapToInt(future -> (Integer) future.join()).toArray();\n-        checkSequentialRange(array, n);\n-    }\n-\n-    @Test\n-    void testExecuteAsyncWithoutExecutor() throws Exception {\n-        final SerialFuture serialFuture = new SerialFuture();\n-\n-        final int n = 10;\n-        final long timeout = 10L;\n-        counter = 0;\n-\n-        final CompletableFuture<?>[] futures = new CompletableFuture<?>[n];\n-        // invoke serialFuture#executeAsync(Callable) one by one from the test thread\n-        // do not use Executor, execute all actions from the invoker thread\n-        for (int i = 0; i < n; i++) {\n-            futures[i] = serialFuture.executeAsync(() -> {\n-                int c = counter;\n-                try {\n-                    Thread.sleep(timeout);\n-                } catch (InterruptedException e) {\n-                    throw new RuntimeException(e);\n-                }\n-                c += 1;\n-                counter = c;\n-                return CompletableFuture.completedFuture(c);\n-            }).toCompletableFuture();\n-        }\n+        final int[] seq = createArithmeticSequence(inc, inc, count);\n+\n+        final VolatileCounter counter = new VolatileCounter();\n+        final IntFunction<CompletableFuture<Integer>> testAction = i ->\n+                serialFuture.callAsync(() -> simpleTimeoutAction(counter, inc, timeout)).toCompletableFuture();\n+        final CompletableFuture<?>[] futures = Arrays.stream(seq)\n+                                                     .mapToObj(testAction)\n+                                                     .toArray(CompletableFuture[]::new);\n+        // wait for all futures to complete\n         CompletableFuture.allOf(futures).join();\n \n-        assertThat(counter).isEqualTo(n);\n-        final int[] array = Arrays.stream(futures).mapToInt(future -> (Integer) future.join()).toArray();\n-        checkSequentialRange(array, n);\n+        assertThat(counter.get()).isEqualTo(count);\n+        final int[] array = Arrays.stream(futures).mapToInt(future -> (Integer) future.join())\n+                                  .toArray();\n+        assertThat(array).containsExactly(seq);\n     }\n \n-    @Test\n-    void testCallAsyncWithExecutorInParallel() throws Exception {\n-        // execute all actions using dedicated Executor\n-        final Executor executor = Executors.newWorkStealingPool();\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testCallAsyncInParallel(boolean withExecutor) throws Exception {\n+        final Executor executor = withExecutor ? Executors.newWorkStealingPool() : null;\n         final SerialFuture serialFuture = new SerialFuture(executor);\n \n-        final int n = 10;\n+        final int inc = 1;\n+        final int count = 20;\n         final long timeout = 10L;\n-        counter = 0;\n+        final int[] seq = createArithmeticSequence(inc, inc, count);\n \n+        final VolatileCounter counter = new VolatileCounter();\n         // test action that allows invoking serialFuture#callAsync(Callable) in parallel\n         // use Executor as part of SerialFuture instance\n         final Callable<CompletableFuture<Integer>> testAction = () ->\n-            serialFuture.callAsync(() -> {\n-                int c = counter;\n-                try {\n-                    Thread.sleep(timeout);\n-                } catch (InterruptedException e) {\n-                    throw new RuntimeException(e);\n-                }\n-                c += 1;\n-                counter = c;\n-                return c;\n-            }).toCompletableFuture();\n-        final List<Callable<CompletableFuture<Integer>>> testActions = new ArrayList<>(n);\n-        for (int i = 0; i < n; i++) {\n-            testActions.add(testAction);\n-        }\n-\n+                serialFuture.callAsync(() -> simpleTimeoutAction(counter, inc, timeout)).toCompletableFuture();\n+        final List<Callable<CompletableFuture<Integer>>> testActions = Arrays.stream(seq)\n+                                                                             .mapToObj(i -> testAction)\n+                                                                             .collect(Collectors.toList());\n         // invoke test actions in parallel\n-        final ForkJoinPool pool = new ForkJoinPool(n);\n+        final ForkJoinPool pool = new ForkJoinPool(count);\n         final CompletableFuture<?>[] futures = pool.invokeAll(testActions).parallelStream().map(f -> {\n             try {\n                 return f.get();\n             } catch (InterruptedException | ExecutionException e) {\n                 throw new RuntimeException(e);\n             }\n         }).toArray(CompletableFuture[]::new);\n-\n         // wait for all futures to complete\n         CompletableFuture.allOf(futures).join();\n \n-        assertThat(counter).isEqualTo(n);\n-        final int[] array = Arrays.stream(futures).mapToInt(future -> (Integer) future.join()).toArray();\n-        checkSequentialRange(array, n);\n+        assertThat(counter.get()).isEqualTo(count);\n+        final int[] array = Arrays.stream(futures).mapToInt(future -> (Integer) future.join())\n+                                  .toArray();\n+        System.out.println(Arrays.toString(array));\n+        assertThat(array).containsExactlyInAnyOrder(seq);\n     }\n \n-    @Test\n-    void testCallAsyncWithoutExecutorInParallel() throws Exception {\n-        // do not use Executor, execute all actions from the invoker thread\n-        final SerialFuture serialFuture = new SerialFuture();\n-\n-        final int n = 10;\n-        final long timeout = 10L;\n-        counter = 0;\n-\n-        // test action that allows invoking serialFuture#callAsync(Callable) in parallel\n-        final Callable<CompletableFuture<Integer>> testAction = () ->\n-            serialFuture.callAsync(() -> {\n-                int c = counter;\n-                try {\n-                    Thread.sleep(timeout);\n-                } catch (InterruptedException e) {\n-                    throw new RuntimeException(e);\n-                }\n-                c += 1;\n-                counter = c;\n-                return c;\n-            }).toCompletableFuture();\n-        final List<Callable<CompletableFuture<Integer>>> testActions = new ArrayList<>(n);\n-        for (int i = 0; i < n; i++) {\n-            testActions.add(testAction);\n+    private static int simpleTimeoutAction(VolatileCounter counter, int inc, long timeout) {\n+        int c = counter.get();\n+        try {\n+            Thread.sleep(timeout);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n         }\n-\n-        // invoke test actions in parallel\n-        final ForkJoinPool pool = new ForkJoinPool(n);\n-        final CompletableFuture<?>[] futures = pool.invokeAll(testActions).parallelStream().map(f -> {\n-            try {\n-                return f.get();\n-            } catch (InterruptedException | ExecutionException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }).toArray(CompletableFuture[]::new);\n-\n-        // wait for all futures to complete\n-        CompletableFuture.allOf(futures).join();\n-\n-        assertThat(counter).isEqualTo(n);\n-        final int[] array = Arrays.stream(futures).mapToInt(future -> (Integer) future.join()).toArray();\n-        checkSequentialRange(array, n);\n+        c += inc;\n+        counter.set(c);\n+        return c;\n     }\n \n-    @Test\n-    void testCallAsyncWithExecutor() throws Exception {\n-        // execute all actions using dedicated Executor\n-        final Executor executor = Executors.newWorkStealingPool();\n-        final SerialFuture serialFuture = new SerialFuture(executor);\n-\n-        final int n = 10;\n-        final long timeout = 10L;\n-        counter = 0;\n+    private static CompletionStage<Integer> timeoutAction(VolatileCounter counter, int inc, long timeout) {\n+        return CompletableFuture.completedFuture(simpleTimeoutAction(counter, inc, timeout));\n+    }\n \n-        final CompletableFuture<?>[] futures = new CompletableFuture<?>[n];\n-        // invoke serialFuture#callAsync(Callable) one by one from the test thread\n-        // use Executor as part of SerialFuture instance\n-        for (int i = 0; i < n; i++) {\n-            futures[i] = serialFuture.callAsync(() -> {\n-                int c = counter;\n-                try {\n-                    Thread.sleep(timeout);\n-                } catch (InterruptedException e) {\n-                    throw new RuntimeException(e);\n-                }\n-                c += 1;\n-                counter = c;\n-                return c;\n-            }).toCompletableFuture();\n+    private static int[] createArithmeticSequence(int start, int inc, int count) {\n+        final int[] seq = new int[count];\n+        int current = start;\n+        for (int i = 0; i < count; i++) {\n+            seq[i] = current;\n+            current += inc;\n         }\n-        CompletableFuture.allOf(futures).join();\n-\n-        assertThat(counter).isEqualTo(n);\n-        final int[] array = Arrays.stream(futures).mapToInt(future -> (Integer) future.join()).toArray();\n-        checkSequentialRange(array, n);\n+        return seq;\n     }\n \n-    @Test\n-    void testCallAsyncWithoutExecutor() throws Exception {\n-        final SerialFuture serialFuture = new SerialFuture();\n+    private static final class VolatileCounter {", "originalCommit": "3dda250ada08c00be95ddb63f284a3e74f35fa25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkyNzAwMA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563927000", "bodyText": "It could, but I did not want to add any synchronization to impact the test. Do you have any particular concern?", "author": "max904-github", "createdAt": "2021-01-25T17:56:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzExMTgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTI0ODY0MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r565248640", "bodyText": "AtomicInteger is just a container of a volatile integer, which basically is identical to VolatileCounter, i.e. no need to write a new class for this.", "author": "trustin", "createdAt": "2021-01-27T11:53:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzExMTgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTYzNzYxNQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r569637615", "bodyText": "Replaced with AtomicInteger", "author": "max904-github", "createdAt": "2021-02-03T18:13:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzExMTgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzExOTUwNA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563119504", "bodyText": "final?", "author": "trustin", "createdAt": "2021-01-23T11:27:47Z", "path": "core/src/main/java/com/linecorp/armeria/server/auth/AbstractAuthorizerWithHandlers.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.auth;\n+\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * Provides base implementation for an {@link Authorizer} that defines custom\n+ * {@link AuthSuccessHandler}/{@link AuthFailureHandler}s.\n+ * @param <T> a type of authorization data. This typically is {@link HttpRequest}.\n+ */\n+@UnstableApi\n+public abstract class AbstractAuthorizerWithHandlers<T> implements Authorizer<T> {\n+\n+    @Override\n+    public CompletionStage<Boolean> authorize(ServiceRequestContext ctx, T data) {", "originalCommit": "ebb4822c919067ba8c42888f55f70fae5a7e418b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkyODcxMA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563928710", "bodyText": "sure. fixed", "author": "max904-github", "createdAt": "2021-01-25T17:58:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzExOTUwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzEyMzkxNQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563123915", "bodyText": "Does AuthorizationResult sound better?", "author": "trustin", "createdAt": "2021-01-23T11:33:19Z", "path": "core/src/main/java/com/linecorp/armeria/server/auth/AuthorizationStatus.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.auth;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+\n+/**\n+ * Provides a status of the request authorization operation, optionally combined with {@link AuthSuccessHandler}\n+ * and {@link AuthFailureHandler} to facilitate custom status handling.\n+ */\n+@UnstableApi\n+public interface AuthorizationStatus {", "originalCommit": "ebb4822c919067ba8c42888f55f70fae5a7e418b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkzMzg3Mg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563933872", "bodyText": "As you wish. Maybe you should validate the design approach first and then perform some low-level brushing up of the API. Otherwise, I may be doing bunch of refactorings for something that could still be a through-ways code.\nDo you agree with the API change in general, introducing AuthorizationStatus instead of the binary status?", "author": "max904-github", "createdAt": "2021-01-25T18:06:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzEyMzkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTI1NDQ4NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r565254484", "bodyText": "Your new API makes sense, so I just left the comments for minor stuff. Yeah, I agree with the idea.\nI thought it may be better introducing a new interface that supercedes Authorizer, but perhaps we can live with the default method for now.\nCould you just add some Javadoc in Authorizer that a user is expected to implement the new method and leave the old method empty, with an example?", "author": "trustin", "createdAt": "2021-01-27T12:03:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzEyMzkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTI1OTM0Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r565259347", "bodyText": "At second thought, what do you think about declaring a new interface? e.g.\n\nAdd interface AuthorizationFunction { CompletionStage<AuthorizationStatue> authorize(...) ... }\nDeprecate Authorizer and add Authorizer.toAuthorizationFunction()\nAdd various AuthServiceBuilder.add*() methods that accept AuthorizationFunction.\n\nNote we can't add add(Iterable<? extends AuthorizationFunction>) though.\n\n\nDeprecate the AuthServiceBuilder.add*() methods that accept Authorizer.\nModify AuthServiceBuilder and AuthService so they use AuthorizationFunction internally.", "author": "trustin", "createdAt": "2021-01-27T12:11:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzEyMzkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTI2NzE4Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r565267187", "bodyText": "Another question: What do you think about having three statuses?\n\nAuthorized\nUnauthorized\nUnauthorized (Unrecognized or unsupported auth scheme, e.g. no 'Authorization' header)\n\nWould the third status be useful for supporting multiple authorization mechanisms? We could add an option that tells AuthService to ignore the AuthorizationFunctions that returned the third status to support multiple authentication schemes. For example:\n// This will reject a request when:\n// - Any of the three functions return 'Unauthorized' (2nd status).\n// - All of the three functions return 'Unauthorized (unsupported)' (3rd status).\n// and accept a request when:\n// - None of the three functions return 'Unauthorized' (2nd status).\nAuthService\n  .builder()\n  .add(oauth1func)\n  .add(oauth2func)\n  .add(basicFunc)\n  .ignoreThirdStatus() // We need a better name.\n  .build();\n\n// If `ignoreThirdStatus()` is not called, the third status will be treated same as the second status.", "author": "trustin", "createdAt": "2021-01-27T12:25:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzEyMzkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTY0NzIzNw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r569647237", "bodyText": "At second thought, what do you think about declaring a new interface? e.g.\n* Add interface AuthorizationFunction { CompletionStage<AuthorizationStatue> authorize(...) ... }\n* Deprecate Authorizer and add Authorizer.toAuthorizationFunction()\n...\n\nLooks like a massive refactoring! I don't see the end of this PR. Do you see specific reason to deprecate Authorizer as part of this?\nI do feel that current authorization interfaces are somewhat limiting but we should think of the missing capabilities and design new interfaces around it.\nCould you please check my question at the bottom regarding fine-grained access control.", "author": "max904-github", "createdAt": "2021-02-03T18:28:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzEyMzkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTY4OTYzMw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r569689633", "bodyText": "Another question: What do you think about having three statuses?\n* Authorized\n* Unauthorized\n* Unauthorized (Unrecognized or unsupported auth scheme, e.g. no 'Authorization' header)\n\nSince the introduction of the AuthorizationStatus it's certainly possible to move away from the binary status. New statuses should even be backward compatible with binary status, just like I did with the handlers. However, it would be very difficult to keep backward compatibility semantically as it will contradict the presence of the third status. I thought you were against making such changes currently.\nOn the other hand, yes, it would be useful to have a special status to indicate that the Authorizer wants to ignore given authorization request. But how common this use case would be? I would question the need of Authorizer chaining in general. I think it's at least confusing but it might be dangerous in some cases. I don't see the need to have a chain of the authorizers to handle the same authorization scheme.\nIn order to support multiple authorization schemes, we should define clear and unambiguous map of Authorizers associated with different authorization schemes:\nAuthServiceBuilder.add(type, authorizer) - maps an authorizer to a type (Basic, OAuth1a, OAuth2, ...); this should allow mapping to custom authorization schemes unknown to us.\nAuthServiceBuilder.setTypeDetector(typeDetector) - to customize predefined type detection mechanism or to support custom authorization types.\nAnother authorization interfaces evolution I could think of related to fine-grained access control, where the standard authorization logic could be mapped to a particular Route.\nAuthServiceBuilder.addAccessRules(Route route, Iterable<String> roles)\nAdditionally, we should define common policy for the routes no associated rules:\nAuthServiceBuilder.permitIfNoRulesDefined(boolean permit)\nHaving this on the AuthService has much more sense than defining it for each authorization scheme based on Authorizer. All the context mapping would take place inside the AuthService and it would work across multiple schemes. Wile the Authorizer implements and extended method like below:\nCompletionStage<AuthorizationStatus> authorizeAndSupplyHandlers(ServiceRequestContext ctx,\n        @Nullable T data, Iterable<String> requiredRoles, boolean permitIfNoRulesDefined)\n\nAs I pointed, in future, we could add support @javax.annotation.security.RolesAllowed annotation directly on the method signature (like most of JEE and JAX-RS frameworks do) like the following:\n    @Put(\"/hello/{name}\")\n    @RolesAllowed ({\"read\", \"write\"})\n    public HttpResponse putHello(@Param(\"name\") String name) {\n\nHaving AuthServiceBuilder.addAccessRules allows us or the user translating the roles annotations to an access control policy - we could load it from a file, for instance.", "author": "max904-github", "createdAt": "2021-02-03T19:29:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzEyMzkxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzEyNDE1Mg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563124152", "bodyText": "status -> authorized?", "author": "trustin", "createdAt": "2021-01-23T11:33:38Z", "path": "core/src/main/java/com/linecorp/armeria/server/auth/AuthorizationStatus.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.auth;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+\n+/**\n+ * Provides a status of the request authorization operation, optionally combined with {@link AuthSuccessHandler}\n+ * and {@link AuthFailureHandler} to facilitate custom status handling.\n+ */\n+@UnstableApi\n+public interface AuthorizationStatus {\n+\n+    /**\n+     * Creates {@link AuthorizationStatus} based on boolean status.\n+     */\n+    static AuthorizationStatus of(boolean status) {", "originalCommit": "ebb4822c919067ba8c42888f55f70fae5a7e418b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk1OTMwMQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563959301", "bodyText": "Same comment as the above. No problem to make this change, but I would like to get the design approach validated first.", "author": "max904-github", "createdAt": "2021-01-25T18:44:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzEyNDE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzEyNTM0MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563125341", "bodyText": "isAuthorized()?", "author": "trustin", "createdAt": "2021-01-23T11:35:17Z", "path": "core/src/main/java/com/linecorp/armeria/server/auth/AuthorizationStatus.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.auth;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+\n+/**\n+ * Provides a status of the request authorization operation, optionally combined with {@link AuthSuccessHandler}\n+ * and {@link AuthFailureHandler} to facilitate custom status handling.\n+ */\n+@UnstableApi\n+public interface AuthorizationStatus {\n+\n+    /**\n+     * Creates {@link AuthorizationStatus} based on boolean status.\n+     */\n+    static AuthorizationStatus of(boolean status) {\n+        return new AuthorizationStatusImpl(status);\n+    }\n+\n+    /**\n+     * Creates {@link AuthorizationStatus} based on boolean status.\n+     */\n+    @Nullable\n+    static AuthorizationStatus of(@Nullable Boolean status) {\n+        if (status == null) {\n+            return null;\n+        }\n+        return new AuthorizationStatusImpl(status);\n+    }\n+\n+    /**\n+     * Creates {@link AuthorizationStatus} success status with optional {@link AuthSuccessHandler}.\n+     */\n+    static AuthorizationStatus ofSuccess(@Nullable AuthSuccessHandler successHandler) {\n+        return new AuthorizationStatusImpl(successHandler);\n+    }\n+\n+    /**\n+     * Creates {@link AuthorizationStatus} success status with optional {@link AuthFailureHandler}.\n+     */\n+    static AuthorizationStatus ofFailure(@Nullable AuthFailureHandler failureHandler) {\n+        return new AuthorizationStatusImpl(failureHandler);\n+    }\n+\n+    /**\n+     * A status of the request authorization operation.\n+     * @return {@code true} if the request is authorized, or {@code false} otherwise.\n+     */\n+    boolean status();", "originalCommit": "ebb4822c919067ba8c42888f55f70fae5a7e418b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk1OTM3Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563959376", "bodyText": "Same comment as the above. No problem to make this change, but I would like to get the design approach validated first.", "author": "max904-github", "createdAt": "2021-01-25T18:44:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzEyNTM0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzEyNTgzOA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563125838", "bodyText": "Could you explain what null means and when null is returned in Javadoc?", "author": "trustin", "createdAt": "2021-01-23T11:35:52Z", "path": "core/src/main/java/com/linecorp/armeria/server/auth/AuthorizationStatus.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.auth;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+\n+/**\n+ * Provides a status of the request authorization operation, optionally combined with {@link AuthSuccessHandler}\n+ * and {@link AuthFailureHandler} to facilitate custom status handling.\n+ */\n+@UnstableApi\n+public interface AuthorizationStatus {\n+\n+    /**\n+     * Creates {@link AuthorizationStatus} based on boolean status.\n+     */\n+    static AuthorizationStatus of(boolean status) {\n+        return new AuthorizationStatusImpl(status);\n+    }\n+\n+    /**\n+     * Creates {@link AuthorizationStatus} based on boolean status.", "originalCommit": "ebb4822c919067ba8c42888f55f70fae5a7e418b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk1ODYxOQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563958619", "bodyText": "I've used the Nullable signature\n@Nullable static AuthorizationStatus of(@Nullable Boolean status)\nto deal with conversion of binary status and AuthorizationStatus. Since the old-style authorization returned  CompletableFuture<Boolean> which could could be effectively NULL, this conversion allows to keep the processing of the result inside the AuthService as below:\n                if (cause == null) {\n                    if (result != null) {\n                        return result.status() ? ...", "author": "max904-github", "createdAt": "2021-01-25T18:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzEyNTgzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTI1NzE5MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r565257190", "bodyText": "I see. If this is not meant to be used by a user, how about hiding it somewhere, such as AuthService?", "author": "trustin", "createdAt": "2021-01-27T12:08:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzEyNTgzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTcxMzU0MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r569713540", "bodyText": "Removed this method from AuthorizationStatus and moved the NULL check to the Authorizer", "author": "max904-github", "createdAt": "2021-02-03T20:08:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzEyNTgzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzEyNzU0OQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563127549", "bodyText": "Could you explain what null data means and what the expected behavior of the method in Javadoc?", "author": "trustin", "createdAt": "2021-01-23T11:37:56Z", "path": "core/src/main/java/com/linecorp/armeria/server/auth/Authorizer.java", "diffHunk": "@@ -43,38 +43,28 @@\n      */\n     CompletionStage<Boolean> authorize(ServiceRequestContext ctx, T data);\n \n+    /**\n+     * Authorizes the given {@code data}.\n+     *\n+     * @return a {@link CompletionStage} that will resolve to {@link AuthorizationStatus}. If the future\n+     *     resolves exceptionally, the request will not be authorized.\n+     */\n+    default CompletionStage<AuthorizationStatus> authorizeAndSupplyHandlers(ServiceRequestContext ctx,\n+                                                                            @Nullable T data) {\n+        if (data == null) {", "originalCommit": "ebb4822c919067ba8c42888f55f70fae5a7e418b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk1MTI0Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563951246", "bodyText": "NULL data means that the authorization material might be absent on the request (token missing or something).\nThe original code looked like the following:\n        final Authorizer<HttpRequest> requestAuthorizer = (ctx, req) -> {\n            final T token = tokenExtractor.apply(req.headers());\n            if (token == null) {\n                return CompletableFuture.completedFuture(false);\n            }\n            return authorizer.authorize(ctx, token);\n        };\n\nNow, it's been extracted into a separate class DelegatingHttpRequestAuthorizer and the authorization decision consolidated in the actual Authorizer, instead of some inline code somewhere inside the builder.\nThe Authorizer signature should have allowed NULL, but unfortunately it did not. So I fully preserve previous contract:\nCompletionStage<Boolean> authorize(ServiceRequestContext ctx, T data);\n\nAdded following comment:\n     * @param data an actual authorization data, like {@link HttpRequest}, token extracted from it or\n     *     {@code null} if such authorization data is missing.", "author": "max904-github", "createdAt": "2021-01-25T18:32:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzEyNzU0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTI0NzgwMw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r565247803", "bodyText": "Thanks a lot. Makes sense.", "author": "trustin", "createdAt": "2021-01-27T11:51:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzEyNzU0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzE1MDI2MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563150261", "bodyText": "nit style:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.endpoint = Objects.requireNonNull(endpoint, \"endpoint\");\n          \n          \n            \n                    this.endpointPath = Objects.requireNonNull(endpointPath, \"endpointPath\");\n          \n          \n            \n                    this.endpoint = requireNonNull(endpoint, \"endpoint\");\n          \n          \n            \n                    this.endpointPath = requireNonNull(endpointPath, \"endpointPath\");", "author": "ikhoon", "createdAt": "2021-01-23T13:00:46Z", "path": "oauth2/src/main/java/com/linecorp/armeria/internal/common/auth/oauth2/AbstractOAuth2Request.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.auth.oauth2;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.InvalidClientException;\n+import com.linecorp.armeria.common.auth.oauth2.TokenRequestException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedMediaTypeException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedResponseException;\n+\n+/**\n+ * A common abstraction for the requests implementing various OAuth 2.0 request/response flows,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a> and other relevant specifications.\n+ * @param <T> the type of the authorization result.\n+ */\n+@UnstableApi\n+public abstract class AbstractOAuth2Request<T> {\n+\n+    private final WebClient endpoint;\n+    private final String endpointPath;\n+    @Nullable\n+    private final ClientAuthorization clientAuthorization;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Authorization request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a> and other relevant specifications.\n+     *\n+     * @param endpoint A {@link WebClient} to facilitate the Authorization requests. Must\n+     *                 correspond to the required Authorization endpoint of the OAuth 2 system.\n+     * @param endpointPath A URI path that corresponds to the Authorization endpoint of the\n+     *                     OAuth 2 system.\n+     * @param clientAuthorization Provides client authorization for the OAuth requests,\n+     *                            as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     */\n+    protected AbstractOAuth2Request(WebClient endpoint, String endpointPath,\n+                                    @Nullable ClientAuthorization clientAuthorization) {\n+        this.endpoint = Objects.requireNonNull(endpoint, \"endpoint\");\n+        this.endpointPath = Objects.requireNonNull(endpointPath, \"endpointPath\");", "originalCommit": "3dda250ada08c00be95ddb63f284a3e74f35fa25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk2MDIwNw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563960207", "bodyText": "fixed", "author": "max904-github", "createdAt": "2021-01-25T18:45:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzE1MDI2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzE1MDM2OQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563150369", "bodyText": "A MediaType will be converted to a String in StringValueConverter.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    headersBuilder.add(HttpHeaderNames.CONTENT_TYPE, MediaType.FORM_DATA.toString());\n          \n          \n            \n                    headersBuilder.addObject(HttpHeaderNames.CONTENT_TYPE, MediaType.FORM_DATA);", "author": "ikhoon", "createdAt": "2021-01-23T13:02:13Z", "path": "oauth2/src/main/java/com/linecorp/armeria/internal/common/auth/oauth2/AbstractOAuth2Request.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.auth.oauth2;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.InvalidClientException;\n+import com.linecorp.armeria.common.auth.oauth2.TokenRequestException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedMediaTypeException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedResponseException;\n+\n+/**\n+ * A common abstraction for the requests implementing various OAuth 2.0 request/response flows,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a> and other relevant specifications.\n+ * @param <T> the type of the authorization result.\n+ */\n+@UnstableApi\n+public abstract class AbstractOAuth2Request<T> {\n+\n+    private final WebClient endpoint;\n+    private final String endpointPath;\n+    @Nullable\n+    private final ClientAuthorization clientAuthorization;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Authorization request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a> and other relevant specifications.\n+     *\n+     * @param endpoint A {@link WebClient} to facilitate the Authorization requests. Must\n+     *                 correspond to the required Authorization endpoint of the OAuth 2 system.\n+     * @param endpointPath A URI path that corresponds to the Authorization endpoint of the\n+     *                     OAuth 2 system.\n+     * @param clientAuthorization Provides client authorization for the OAuth requests,\n+     *                            as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     */\n+    protected AbstractOAuth2Request(WebClient endpoint, String endpointPath,\n+                                    @Nullable ClientAuthorization clientAuthorization) {\n+        this.endpoint = Objects.requireNonNull(endpoint, \"endpoint\");\n+        this.endpointPath = Objects.requireNonNull(endpointPath, \"endpointPath\");\n+        this.clientAuthorization = clientAuthorization; // optional\n+    }\n+\n+    /**\n+     * Returns the {@link WebClient} of the authorization endpoint.\n+     */\n+    protected final WebClient endpoint() {\n+        return endpoint;\n+    }\n+\n+    /**\n+     * Returns the authorization endpoint path.\n+     */\n+    protected final String endpointPath() {\n+        return endpointPath;\n+    }\n+\n+    /**\n+     * Returns the client authorization object.\n+     */\n+    @Nullable\n+    protected final ClientAuthorization clientAuthorization() {\n+        return clientAuthorization;\n+    }\n+\n+    /**\n+     * Extracts data from OK response and converts it to the target type {@code T}.\n+     */\n+    protected abstract T extractOkResults(AggregatedHttpResponse response, QueryParams requestFormData);\n+\n+    /**\n+     * Returns the value for the {@link HttpHeaderNames#AUTHORIZATION}.\n+     */\n+    @Nullable\n+    protected final String authorizationHeaderValue() {\n+        return clientAuthorization == null ? null : clientAuthorization.asHeaderValue();\n+    }\n+\n+    /**\n+     * Sets client credentials as form data parameters,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     */\n+    protected final void addCredentialsAsBodyParameters(QueryParamsBuilder formBuilder) {\n+        if (clientAuthorization != null) {\n+            clientAuthorization.addAsBodyParameters(formBuilder);\n+        }\n+    }\n+\n+    /**\n+     * Makes a request to the authorization endpoint using supplied {@code requestForm} parameters and converts\n+     * the result to the given type {@code T}.\n+     */\n+    protected CompletableFuture<T> executeWithParameters(QueryParams requestFormData) {\n+        final HttpResponse response = endpoint().execute(createHttpRequest(endpointPath, requestFormData));\n+        // when response aggregated, then extract the results...\n+        return response.aggregate().thenApply(r -> extractResults(r, requestFormData));\n+    }\n+\n+    /**\n+     * Produces {@link HttpRequest} based on this object.\n+     */\n+    private HttpRequest createHttpRequest(String endpointPath, QueryParams requestFormData) {\n+        final RequestHeadersBuilder headersBuilder =\n+                RequestHeaders.of(HttpMethod.POST, endpointPath).toBuilder();\n+        final String authorizationHeaderValue = authorizationHeaderValue();\n+        if (authorizationHeaderValue != null) {\n+            headersBuilder.add(HttpHeaderNames.AUTHORIZATION, authorizationHeaderValue);\n+        } else {\n+            requestFormData = requestFormData.withMutations(this::addCredentialsAsBodyParameters);\n+        }\n+        headersBuilder.add(HttpHeaderNames.CONTENT_TYPE, MediaType.FORM_DATA.toString());", "originalCommit": "3dda250ada08c00be95ddb63f284a3e74f35fa25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk2MjA5OQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563962099", "bodyText": "Thought this could handle only a fine set of the specific classes like Date or Instant.\nModified it as per your suggesting, assuming it works with generic objects.", "author": "max904-github", "createdAt": "2021-01-25T18:48:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzE1MDM2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTI0NzUzMw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r565247533", "bodyText": "MediaType is one of the supported types, so no worries :-)", "author": "trustin", "createdAt": "2021-01-27T11:51:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzE1MDM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzE1MDQ1Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563150457", "bodyText": "We can directly create a RequestHeadersBuilder\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final RequestHeadersBuilder headersBuilder =\n          \n          \n            \n                            RequestHeaders.of(HttpMethod.POST, endpointPath).toBuilder();\n          \n          \n            \n                    final RequestHeadersBuilder headersBuilder =\n          \n          \n            \n                            RequestHeaders.builder(HttpMethod.POST, endpointPath);", "author": "ikhoon", "createdAt": "2021-01-23T13:03:23Z", "path": "oauth2/src/main/java/com/linecorp/armeria/internal/common/auth/oauth2/AbstractOAuth2Request.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.auth.oauth2;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.InvalidClientException;\n+import com.linecorp.armeria.common.auth.oauth2.TokenRequestException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedMediaTypeException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedResponseException;\n+\n+/**\n+ * A common abstraction for the requests implementing various OAuth 2.0 request/response flows,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a> and other relevant specifications.\n+ * @param <T> the type of the authorization result.\n+ */\n+@UnstableApi\n+public abstract class AbstractOAuth2Request<T> {\n+\n+    private final WebClient endpoint;\n+    private final String endpointPath;\n+    @Nullable\n+    private final ClientAuthorization clientAuthorization;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Authorization request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a> and other relevant specifications.\n+     *\n+     * @param endpoint A {@link WebClient} to facilitate the Authorization requests. Must\n+     *                 correspond to the required Authorization endpoint of the OAuth 2 system.\n+     * @param endpointPath A URI path that corresponds to the Authorization endpoint of the\n+     *                     OAuth 2 system.\n+     * @param clientAuthorization Provides client authorization for the OAuth requests,\n+     *                            as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     */\n+    protected AbstractOAuth2Request(WebClient endpoint, String endpointPath,\n+                                    @Nullable ClientAuthorization clientAuthorization) {\n+        this.endpoint = Objects.requireNonNull(endpoint, \"endpoint\");\n+        this.endpointPath = Objects.requireNonNull(endpointPath, \"endpointPath\");\n+        this.clientAuthorization = clientAuthorization; // optional\n+    }\n+\n+    /**\n+     * Returns the {@link WebClient} of the authorization endpoint.\n+     */\n+    protected final WebClient endpoint() {\n+        return endpoint;\n+    }\n+\n+    /**\n+     * Returns the authorization endpoint path.\n+     */\n+    protected final String endpointPath() {\n+        return endpointPath;\n+    }\n+\n+    /**\n+     * Returns the client authorization object.\n+     */\n+    @Nullable\n+    protected final ClientAuthorization clientAuthorization() {\n+        return clientAuthorization;\n+    }\n+\n+    /**\n+     * Extracts data from OK response and converts it to the target type {@code T}.\n+     */\n+    protected abstract T extractOkResults(AggregatedHttpResponse response, QueryParams requestFormData);\n+\n+    /**\n+     * Returns the value for the {@link HttpHeaderNames#AUTHORIZATION}.\n+     */\n+    @Nullable\n+    protected final String authorizationHeaderValue() {\n+        return clientAuthorization == null ? null : clientAuthorization.asHeaderValue();\n+    }\n+\n+    /**\n+     * Sets client credentials as form data parameters,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     */\n+    protected final void addCredentialsAsBodyParameters(QueryParamsBuilder formBuilder) {\n+        if (clientAuthorization != null) {\n+            clientAuthorization.addAsBodyParameters(formBuilder);\n+        }\n+    }\n+\n+    /**\n+     * Makes a request to the authorization endpoint using supplied {@code requestForm} parameters and converts\n+     * the result to the given type {@code T}.\n+     */\n+    protected CompletableFuture<T> executeWithParameters(QueryParams requestFormData) {\n+        final HttpResponse response = endpoint().execute(createHttpRequest(endpointPath, requestFormData));\n+        // when response aggregated, then extract the results...\n+        return response.aggregate().thenApply(r -> extractResults(r, requestFormData));\n+    }\n+\n+    /**\n+     * Produces {@link HttpRequest} based on this object.\n+     */\n+    private HttpRequest createHttpRequest(String endpointPath, QueryParams requestFormData) {\n+        final RequestHeadersBuilder headersBuilder =\n+                RequestHeaders.of(HttpMethod.POST, endpointPath).toBuilder();", "originalCommit": "3dda250ada08c00be95ddb63f284a3e74f35fa25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk2MzIzNA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563963234", "bodyText": "Right. Fixed", "author": "max904-github", "createdAt": "2021-01-25T18:50:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzE1MDQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzE1MTMwMw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563151303", "bodyText": "Use the local variable?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!errorResponse.content().isEmpty()) {\n          \n          \n            \n                    if (!errorResponseContents.isEmpty()) {", "author": "ikhoon", "createdAt": "2021-01-23T13:12:28Z", "path": "oauth2/src/main/java/com/linecorp/armeria/internal/common/auth/oauth2/AbstractOAuth2Request.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.auth.oauth2;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.InvalidClientException;\n+import com.linecorp.armeria.common.auth.oauth2.TokenRequestException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedMediaTypeException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedResponseException;\n+\n+/**\n+ * A common abstraction for the requests implementing various OAuth 2.0 request/response flows,\n+ * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a> and other relevant specifications.\n+ * @param <T> the type of the authorization result.\n+ */\n+@UnstableApi\n+public abstract class AbstractOAuth2Request<T> {\n+\n+    private final WebClient endpoint;\n+    private final String endpointPath;\n+    @Nullable\n+    private final ClientAuthorization clientAuthorization;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Authorization request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a> and other relevant specifications.\n+     *\n+     * @param endpoint A {@link WebClient} to facilitate the Authorization requests. Must\n+     *                 correspond to the required Authorization endpoint of the OAuth 2 system.\n+     * @param endpointPath A URI path that corresponds to the Authorization endpoint of the\n+     *                     OAuth 2 system.\n+     * @param clientAuthorization Provides client authorization for the OAuth requests,\n+     *                            as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     */\n+    protected AbstractOAuth2Request(WebClient endpoint, String endpointPath,\n+                                    @Nullable ClientAuthorization clientAuthorization) {\n+        this.endpoint = Objects.requireNonNull(endpoint, \"endpoint\");\n+        this.endpointPath = Objects.requireNonNull(endpointPath, \"endpointPath\");\n+        this.clientAuthorization = clientAuthorization; // optional\n+    }\n+\n+    /**\n+     * Returns the {@link WebClient} of the authorization endpoint.\n+     */\n+    protected final WebClient endpoint() {\n+        return endpoint;\n+    }\n+\n+    /**\n+     * Returns the authorization endpoint path.\n+     */\n+    protected final String endpointPath() {\n+        return endpointPath;\n+    }\n+\n+    /**\n+     * Returns the client authorization object.\n+     */\n+    @Nullable\n+    protected final ClientAuthorization clientAuthorization() {\n+        return clientAuthorization;\n+    }\n+\n+    /**\n+     * Extracts data from OK response and converts it to the target type {@code T}.\n+     */\n+    protected abstract T extractOkResults(AggregatedHttpResponse response, QueryParams requestFormData);\n+\n+    /**\n+     * Returns the value for the {@link HttpHeaderNames#AUTHORIZATION}.\n+     */\n+    @Nullable\n+    protected final String authorizationHeaderValue() {\n+        return clientAuthorization == null ? null : clientAuthorization.asHeaderValue();\n+    }\n+\n+    /**\n+     * Sets client credentials as form data parameters,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     */\n+    protected final void addCredentialsAsBodyParameters(QueryParamsBuilder formBuilder) {\n+        if (clientAuthorization != null) {\n+            clientAuthorization.addAsBodyParameters(formBuilder);\n+        }\n+    }\n+\n+    /**\n+     * Makes a request to the authorization endpoint using supplied {@code requestForm} parameters and converts\n+     * the result to the given type {@code T}.\n+     */\n+    protected CompletableFuture<T> executeWithParameters(QueryParams requestFormData) {\n+        final HttpResponse response = endpoint().execute(createHttpRequest(endpointPath, requestFormData));\n+        // when response aggregated, then extract the results...\n+        return response.aggregate().thenApply(r -> extractResults(r, requestFormData));\n+    }\n+\n+    /**\n+     * Produces {@link HttpRequest} based on this object.\n+     */\n+    private HttpRequest createHttpRequest(String endpointPath, QueryParams requestFormData) {\n+        final RequestHeadersBuilder headersBuilder =\n+                RequestHeaders.of(HttpMethod.POST, endpointPath).toBuilder();\n+        final String authorizationHeaderValue = authorizationHeaderValue();\n+        if (authorizationHeaderValue != null) {\n+            headersBuilder.add(HttpHeaderNames.AUTHORIZATION, authorizationHeaderValue);\n+        } else {\n+            requestFormData = requestFormData.withMutations(this::addCredentialsAsBodyParameters);\n+        }\n+        headersBuilder.add(HttpHeaderNames.CONTENT_TYPE, MediaType.FORM_DATA.toString());\n+\n+        return HttpRequest.of(headersBuilder.build(), HttpData.ofUtf8(requestFormData.toQueryString()));\n+    }\n+\n+    /**\n+     * Extracts the result and convert it to the target type {@code T} or throw an error in case of an error\n+     * result.\n+     * @param response An {@link AggregatedHttpResponse} returned by the authorization endpoint.\n+     * @param requestFormData A {@link QueryParams} that contains all the elements of the request form sent with\n+     *                        the request.\n+     * @throws TokenRequestException when the endpoint returns {code HTTP 400 (Bad Request)} status and the\n+     *                               response payload contains the details of the error.\n+     * @throws InvalidClientException when the endpoint returns {@code HTTP 401 (Unauthorized)} status, which\n+     *                                typically indicates that client authentication failed (e.g.: unknown\n+     *                                client, no client authentication included, or unsupported authentication\n+     *                                method).\n+     * @throws UnsupportedMediaTypeException if the media type of the response does not match the expected\n+     *                                       (JSON).\n+     */\n+    @Nullable\n+    protected T extractResults(AggregatedHttpResponse response, QueryParams requestFormData) {\n+        final HttpStatus status = response.status();\n+        switch (status.code()) {\n+            case 200: // OK\n+                // expected Content-Type: application/json;charset=UTF-8\n+                validateContentType(response, MediaType.JSON);\n+                return extractOkResults(response, requestFormData);\n+            case 400: // Bad Request\n+                // expected Content-Type: application/json;charset=UTF-8\n+                validateContentType(response, MediaType.JSON);\n+                throw onBadRequestError(response);\n+            case 401: // Unauthorized\n+                throw onUnauthorizedError(response);\n+        }\n+        throw new UnsupportedResponseException(status, response.contentUtf8());\n+    }\n+\n+    /**\n+     * Composes {@link TokenRequestException} upon 400 Bad Request response\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-5.2\">[RFC6749], Section 5.2</a>.\n+     * @param errorResponse response received from the server\n+     * @return an instance of {@link TokenRequestException}\n+     */\n+    protected TokenRequestException onBadRequestError(AggregatedHttpResponse errorResponse) {\n+        return TokenRequestException.parse(errorResponse.contentUtf8());\n+    }\n+\n+    /**\n+     * Composes {@link InvalidClientException} upon 401 Unauthorized response\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-5.2\">[RFC6749], Section 5.2</a> (invalid_client).\n+     * @param errorResponse response received from the server\n+     * @return an instance of {@link InvalidClientException}\n+     */\n+    protected TokenRequestException onUnauthorizedError(AggregatedHttpResponse errorResponse) {\n+        final StringBuilder messageBuilder = new StringBuilder().append(errorResponse.status());\n+        final String wwwAuthenticate = errorResponse.headers().get(HttpHeaderNames.WWW_AUTHENTICATE);\n+        if (wwwAuthenticate != null) {\n+            messageBuilder.append(\": \").append(wwwAuthenticate);\n+        }\n+        final HttpData errorResponseContents = errorResponse.content();\n+        if (!errorResponse.content().isEmpty()) {", "originalCommit": "3dda250ada08c00be95ddb63f284a3e74f35fa25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk2NDE4Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563964187", "bodyText": "Yes, this is how it's supposed to be. Fixed.", "author": "max904-github", "createdAt": "2021-01-25T18:52:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzE1MTMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzE1MjAxMw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563152013", "bodyText": "nit: How about checking for null of token before creating QueryParamsBuilder?", "author": "ikhoon", "createdAt": "2021-01-23T13:19:43Z", "path": "oauth2/src/main/java/com/linecorp/armeria/internal/common/auth/oauth2/AbstractTokenOperationRequest.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.auth.oauth2;\n+\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.ACCESS_TOKEN;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.TOKEN;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.TOKEN_TYPE_HINT;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.InvalidClientException;\n+import com.linecorp.armeria.common.auth.oauth2.TokenRequestException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedMediaTypeException;\n+\n+/**\n+ * A common abstraction for the requests implementing various Token operations request/response flows,\n+ * such as Token Introspection flow\n+ * (<a href=\"https://tools.ietf.org/html/rfc7662#section-2\">[RFC7662], Section 2</a>),\n+ * and Token Revocation flow (<a href=\"https://tools.ietf.org/html/rfc7009\">[RFC7009]</a>).\n+ * @param <T> the type of the authorization result.\n+ */\n+@UnstableApi\n+public abstract class AbstractTokenOperationRequest<T> extends AbstractOAuth2Request<T> {\n+\n+    /**\n+     * A common abstraction for the requests implementing various Token operations request/response flows,\n+     * such as Token Introspection flow\n+     * (<a href=\"https://tools.ietf.org/html/rfc7662#section-2\">[RFC7662], Section 2</a>),\n+     * and Token Revocation flow (<a href=\"https://tools.ietf.org/html/rfc7009\">[RFC7009]</a>).\n+     *\n+     * @param operationsEndpoint A {@link WebClient} to facilitate the Token Operations requests. Must\n+     *                           correspond to the required Token Operations endpoint of the OAuth 2 system.\n+     * @param operationsEndpointPath A URI path that corresponds to the token Operations endpoint of the\n+     *                               OAuth 2 system.\n+     * @param clientAuthorization Provides client authorization for the OAuth requests,\n+     *                            as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     */\n+    protected AbstractTokenOperationRequest(WebClient operationsEndpoint, String operationsEndpointPath,\n+                                            @Nullable ClientAuthorization clientAuthorization) {\n+        super(operationsEndpoint, operationsEndpointPath, clientAuthorization);\n+    }\n+\n+    /**\n+     * Makes a token operations (Introspection/Revocation) request using given {@code token} and\n+     * optional {@code tokenType}.\n+     * @param token A token this operation request applies to.\n+     * @param tokenType A hint about the type of the token submitted for (Introspection/Revocation) operation.\n+     *                  Either {@code access_token} or {@code refresh_token} as per\n+     *                  <a href=\"https://tools.ietf.org/html/rfc7009#section-2.1\">[RFC7009], Section 2.1</a>.\n+     * @return A {@link CompletableFuture} carrying the target result.\n+     * @throws TokenRequestException when the endpoint returns {code HTTP 400 (Bad Request)} status and the\n+     *                               response payload contains the details of the error.\n+     * @throws InvalidClientException when the endpoint returns {@code HTTP 401 (Unauthorized)} status, which\n+     *                                typically indicates that client authentication failed (e.g.: unknown\n+     *                                client, no client authentication included, or unsupported authentication\n+     *                                method).\n+     * @throws UnsupportedMediaTypeException if the media type of the response does not match the expected\n+     *                                       (JSON).\n+     */\n+    public CompletableFuture<T> make(String token, @Nullable String tokenType) {\n+        final QueryParamsBuilder requestFormBuilder = QueryParams.builder();\n+\n+        // populate request form data\n+        // MANDATORY token\n+        requestFormBuilder.add(TOKEN, Objects.requireNonNull(token, TOKEN));", "originalCommit": "3dda250ada08c00be95ddb63f284a3e74f35fa25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk2NjQ4Mg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563966482", "bodyText": "changed", "author": "max904-github", "createdAt": "2021-01-25T18:55:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzE1MjAxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzE1MjE0MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563152140", "bodyText": "@UnstableApi could be removed for internal package.", "author": "ikhoon", "createdAt": "2021-01-23T13:21:04Z", "path": "oauth2/src/main/java/com/linecorp/armeria/internal/common/auth/oauth2/CaseUtil.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.auth.oauth2;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+\n+@UnstableApi", "originalCommit": "3dda250ada08c00be95ddb63f284a3e74f35fa25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk2NzMwMw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563967303", "bodyText": "removed", "author": "max904-github", "createdAt": "2021-01-25T18:56:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzE1MjE0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTI0NjM5Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r565246397", "bodyText": "Sorry about this, @max904-github.", "author": "trustin", "createdAt": "2021-01-27T11:49:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzE1MjE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzE1MjI0Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563152247", "bodyText": "global comment in this file: Please use 4 spaces for indentation.", "author": "ikhoon", "createdAt": "2021-01-23T13:22:24Z", "path": "oauth2/src/main/java/com/linecorp/armeria/internal/common/auth/oauth2/CaseUtil.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.auth.oauth2;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+\n+@UnstableApi\n+public final class CaseUtil {\n+\n+  @Nullable\n+  public static String firstUpperCase(@Nullable String word) {\n+    if (word == null || word.isEmpty()) {", "originalCommit": "3dda250ada08c00be95ddb63f284a3e74f35fa25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk2NzM5NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563967394", "bodyText": "fixed", "author": "max904-github", "createdAt": "2021-01-25T18:57:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzE1MjI0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzE1MzE2Mw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563153163", "bodyText": "Remove @UnstableApi\npublic final class for consistency?", "author": "ikhoon", "createdAt": "2021-01-23T13:31:33Z", "path": "oauth2/src/main/java/com/linecorp/armeria/internal/common/auth/oauth2/OAuth2Constants.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.auth.oauth2;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+\n+/**\n+ * Common OAuth 2.0 constants.\n+ */\n+@UnstableApi\n+public interface OAuth2Constants {", "originalCommit": "3dda250ada08c00be95ddb63f284a3e74f35fa25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk3MTAyOQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563971029", "bodyText": "changed as requested", "author": "max904-github", "createdAt": "2021-01-25T19:02:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzE1MzE2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI5NTE2Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563295166", "bodyText": "nit: Add @VisibleForTesting?", "author": "ikhoon", "createdAt": "2021-01-24T13:45:56Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/GrantedOAuth2AccessToken.java", "diffHunk": "@@ -0,0 +1,407 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.ACCESS_TOKEN;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.DEFAULT_TOKEN_TYPE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.EXPIRES_IN;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.REFRESH_TOKEN;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.SCOPE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.TOKEN_TYPE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.ResponseParserUtil.JSON;\n+import static java.time.format.DateTimeFormatter.ISO_INSTANT;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.internal.common.auth.oauth2.CaseUtil;\n+import com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants;\n+\n+/**\n+ * Defines a structure of the Access Token Response, as per\n+ * <a href=\"https://tools.ietf.org/html/rfc6749#section-5.1\">[RFC6749], Section 5.1</a>.\n+ */\n+@UnstableApi\n+public class GrantedOAuth2AccessToken implements Serializable {\n+\n+    private static final long serialVersionUID = 8698118404098897958L;\n+\n+    /**\n+     * Creates a new {@link GrantedOAuth2AccessToken} based on the {@code JSON}-formatted raw response body and\n+     * optional raw formatted {@code scope} used to request the token.\n+     * @param rawResponse {@code JSON}-formatted raw response body.\n+     * @param requestScope OPTIONAL. A list of space-delimited, case-sensitive strings.\n+     *                     The strings are defined by the authorization server.\n+     *                     The authorization server MAY fully or partially ignore the scope requested by the\n+     *                     client, based on the authorization server policy or the resource owner's\n+     *                     instructions. If the issued access token scope is different from the one requested\n+     *                     by the client, the authorization server MUST include the \"scope\" response\n+     *                     parameter to inform the client of the actual scope granted.\n+     *                     If the client omits the scope parameter when requesting authorization, the\n+     *                     authorization server MUST either process the request using a pre-defined default\n+     *                     value or fail the request indicating an invalid scope.\n+     * @return A new instance of {@link GrantedOAuth2AccessToken}.\n+     */\n+    public static GrantedOAuth2AccessToken parse(String rawResponse, @Nullable String requestScope) {\n+        return GrantedOAuth2AccessTokenBuilder.parse(rawResponse, requestScope);\n+    }\n+\n+    /**\n+     * Creates a new {@link GrantedOAuth2AccessTokenBuilder} to build a new {@link GrantedOAuth2AccessToken} and\n+     * supplied it with a value of {@code access_token} Access Token response field.\n+     * @return A new instance of {@link GrantedOAuth2AccessTokenBuilder}.\n+     */\n+    public static GrantedOAuth2AccessTokenBuilder builder(String accessToken) {\n+        return new GrantedOAuth2AccessTokenBuilder(accessToken);\n+    }\n+\n+    static final String ISSUED_AT = \"issued_at\";\n+\n+    static final String SCOPE_SEPARATOR = \" \";", "originalCommit": "3dda250ada08c00be95ddb63f284a3e74f35fa25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk3MTk4Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563971987", "bodyText": "added", "author": "max904-github", "createdAt": "2021-01-25T19:04:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI5NTE2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI5NTYwNA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563295604", "bodyText": "indent?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new GrantedOAuth2AccessToken(accessToken, tokenType,\n          \n          \n            \n                                                  (issuedAt == null) ? Instant.now() : issuedAt, expiresIn,\n          \n          \n            \n                                                        refreshToken, scope.build(), extras.build(), rawResponse);\n          \n          \n            \n                    return new GrantedOAuth2AccessToken(accessToken, tokenType,\n          \n          \n            \n                                                        (issuedAt == null) ? Instant.now() : issuedAt, expiresIn,\n          \n          \n            \n                                                        refreshToken, scope.build(), extras.build(), rawResponse);", "author": "ikhoon", "createdAt": "2021-01-24T13:48:50Z", "path": "oauth2/src/main/java/com/linecorp/armeria/common/auth/oauth2/GrantedOAuth2AccessTokenBuilder.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.auth.oauth2;\n+\n+import static com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken.ISSUED_AT;\n+import static com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor.SCOPE_SEPARATOR;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.ACCESS_TOKEN;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.EXPIRES_IN;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.REFRESH_TOKEN;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.SCOPE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.TOKEN_TYPE;\n+import static com.linecorp.armeria.internal.common.auth.oauth2.ResponseParserUtil.JSON;\n+import static java.time.format.DateTimeFormatter.ISO_INSTANT;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants;\n+\n+/**\n+ * Builds an instance of {@link GrantedOAuth2AccessToken}.\n+ */\n+@UnstableApi\n+public final class GrantedOAuth2AccessTokenBuilder {\n+\n+    private static final TypeReference<LinkedHashMap<String, String>> MAP_TYPE =\n+            new TypeReference<LinkedHashMap<String, String>>() {};\n+\n+    static GrantedOAuth2AccessToken parse(String rawResponse, @Nullable String requestScope) {\n+\n+        final LinkedHashMap<String, String> map;\n+        try {\n+            map = JSON.readValue(requireNonNull(rawResponse, \"rawResponse\"), MAP_TYPE);\n+        } catch (JsonProcessingException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        final GrantedOAuth2AccessTokenBuilder builder =\n+                new GrantedOAuth2AccessTokenBuilder(requireNonNull(map.remove(ACCESS_TOKEN), ACCESS_TOKEN));\n+\n+        final String tokenType = map.remove(TOKEN_TYPE);\n+        if (tokenType != null) {\n+            builder.tokenType(tokenType);\n+        }\n+        final String issuedAt = map.remove(ISSUED_AT);\n+        if (issuedAt != null) {\n+            builder.issuedAt(ISO_INSTANT.parse(issuedAt, Instant::from));\n+        }\n+        final String expiresIn = map.remove(EXPIRES_IN);\n+        if (expiresIn != null) {\n+            builder.expiresIn(Duration.ofSeconds(Long.parseLong(expiresIn)));\n+        }\n+        final String refreshToken = map.remove(REFRESH_TOKEN);\n+        if (refreshToken != null) {\n+            builder.refreshToken(refreshToken);\n+        }\n+        String scope = map.remove(SCOPE);\n+        if (scope == null) {\n+            scope = requestScope;\n+        }\n+        if (scope != null) {\n+            builder.scope(scope.split(SCOPE_SEPARATOR));\n+        }\n+        builder.extras(map);\n+\n+        builder.rawResponse(rawResponse);\n+\n+        return builder.build();\n+    }\n+\n+    private final String accessToken;\n+\n+    @Nullable\n+    private String tokenType;\n+\n+    @Nullable\n+    private Duration expiresIn;\n+\n+    @Nullable\n+    private String refreshToken;\n+\n+    private final ImmutableList.Builder<String> scope = ImmutableList.builder();\n+\n+    private final ImmutableMap.Builder<String, String> extras = ImmutableMap.builder();\n+\n+    @Nullable\n+    private Instant issuedAt;\n+\n+    @Nullable\n+    private String rawResponse;\n+\n+    /**\n+     * Constructs a new instance of {@link GrantedOAuth2AccessTokenBuilder} given the mandatory value\n+     * {@value OAuth2Constants#ACCESS_TOKEN} of the access token issued by the authorization server.\n+     * @param accessToken {@value OAuth2Constants#ACCESS_TOKEN} Access Token response field,\n+     *                    REQUIRED. The access token issued by the authorization server.\n+     */\n+    GrantedOAuth2AccessTokenBuilder(String accessToken) {\n+        this.accessToken = requireNonNull(accessToken, \"accessToken\");\n+    }\n+\n+    /**\n+     * {@value OAuth2Constants#TOKEN_TYPE} Access Token response field,\n+     * REQUIRED. The type of the token issued as described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-7.1\">[RFC6749], Section 7.1</a>.\n+     * Value is case insensitive.\n+     */\n+    public GrantedOAuth2AccessTokenBuilder tokenType(String tokenType) {\n+        this.tokenType = requireNonNull(tokenType, \"tokenType\");\n+        return this;\n+    }\n+\n+    /**\n+     * {@value OAuth2Constants#EXPIRES_IN} Access Token response field,\n+     * RECOMMENDED. {@link Duration} indicating the lifetime of the access token. For example,\n+     * the value 3600 seconds denotes that the access token will expire in one hour from the time\n+     * the response was generated. If omitted, the authorization server SHOULD provide the expiration\n+     * time via other means or document the default value.\n+     */\n+    public GrantedOAuth2AccessTokenBuilder expiresIn(Duration expiresIn) {\n+        this.expiresIn = requireNonNull(expiresIn, \"expiresIn\");\n+        return this;\n+    }\n+\n+    /**\n+     * An {@link Instant} indicating when the Access Token was issued,\n+     * OPTIONAL. The value is NOT supplied with the Access Token response and calculated approximately using\n+     * {@value OAuth2Constants#EXPIRES_IN} field.\n+     */\n+    public GrantedOAuth2AccessTokenBuilder issuedAt(Instant issuedAt) {\n+        this.issuedAt = requireNonNull(issuedAt, \"issuedAt\");\n+        return this;\n+    }\n+\n+    /**\n+     * {@value OAuth2Constants#REFRESH_TOKEN} Access Token response field,\n+     * OPTIONAL. The refresh token, which can be used to obtain new access tokens using the same\n+     * authorization grant as described at\n+     * <a href=\"http://tools.ietf.org/html/rfc6749#section-6\">[RFC6749], Section 6</a>.\n+     */\n+    public GrantedOAuth2AccessTokenBuilder refreshToken(String refreshToken) {\n+        this.refreshToken = requireNonNull(refreshToken, \"refreshToken\");\n+        return this;\n+    }\n+\n+    /**\n+     * {@value OAuth2Constants#SCOPE} Access Token Response field,\n+     * OPTIONAL. An {@link Iterable} of individual scope values.\n+     */\n+    public GrantedOAuth2AccessTokenBuilder scope(Iterable<String> scope) {\n+        this.scope.addAll(requireNonNull(scope, \"scope\"));\n+        return this;\n+    }\n+\n+    /**\n+     * {@value OAuth2Constants#SCOPE} Access Token Response field,\n+     * OPTIONAL. An array of individual scope values.\n+     */\n+    public GrantedOAuth2AccessTokenBuilder scope(String... scope) {\n+        this.scope.add(requireNonNull(scope, \"scope\"));\n+        return this;\n+    }\n+\n+    /**\n+     * A pair of extra system-specific token parameters included with Access Token Response,\n+     * OPTIONAL.\n+     */\n+    public GrantedOAuth2AccessTokenBuilder extras(String key, String value) {\n+        extras.put(key, value);\n+        return this;\n+    }\n+\n+    /**\n+     * A {@link Map} of extra system-specific token parameters included with Access Token Response,\n+     * OPTIONAL.\n+     */\n+    public GrantedOAuth2AccessTokenBuilder extras(Map<String, String> extras) {\n+        this.extras.putAll(extras);\n+        return this;\n+    }\n+\n+    /**\n+     * An {@link Iterable} of extra system-specific token parameters included with Access Token Response,\n+     * OPTIONAL.\n+     */\n+    @SuppressWarnings(\"UnstableApiUsage\")\n+    public GrantedOAuth2AccessTokenBuilder extras(\n+            Iterable<? extends Map.Entry<String, String>> extras) {\n+        this.extras.putAll(extras);\n+        return this;\n+    }\n+\n+    private GrantedOAuth2AccessTokenBuilder rawResponse(String rawResponse) {\n+        this.rawResponse = requireNonNull(rawResponse, \"rawResponse\");\n+        return this;\n+    }\n+\n+    /**\n+     * Builds a new instance of {@link GrantedOAuth2AccessToken} based on the configured parameters.\n+     */\n+    public GrantedOAuth2AccessToken build() {\n+        return new GrantedOAuth2AccessToken(accessToken, tokenType,\n+                                      (issuedAt == null) ? Instant.now() : issuedAt, expiresIn,\n+                                            refreshToken, scope.build(), extras.build(), rawResponse);", "originalCommit": "3dda250ada08c00be95ddb63f284a3e74f35fa25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk3MjQ4NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563972484", "bodyText": "fixed", "author": "max904-github", "createdAt": "2021-01-25T19:05:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI5NTYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzMwNDM1Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563304356", "bodyText": "Armeria does not expose Guava as a public API. It is only used for internal implementation which is relocated and shaded.\nHow about taking cacheSpec and using Caffeine cache instead of Guava cache as we did in \n  \n    \n      armeria/core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java\n    \n    \n         Line 304\n      in\n      bbc877f\n    \n    \n    \n    \n\n        \n          \n           public DnsResolverGroupBuilder cacheSpec(String cacheSpec) {", "author": "ikhoon", "createdAt": "2021-01-24T14:56:47Z", "path": "oauth2/src/main/java/com/linecorp/armeria/server/auth/oauth2/OAuth2TokenIntrospectionAuthorizerBuilder.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor;\n+import com.linecorp.armeria.internal.server.auth.oauth2.TokenIntrospectionRequest;\n+import com.linecorp.armeria.server.auth.Authorizer;\n+\n+/**\n+ * Builds a {@link OAuth2TokenIntrospectionAuthorizer} instance.\n+ */\n+@UnstableApi\n+public final class OAuth2TokenIntrospectionAuthorizerBuilder {\n+\n+    private static final long DEFAULT_CACHE_MAX_SIZE = 1000;\n+    private static final Duration DEFAULT_CACHE_MAX_AGE = Duration.ofHours(1L);\n+\n+    private static Cache<String, OAuth2TokenDescriptor> createDefaultCache() {\n+        final CacheBuilder<Object, Object> cacheBuilder =\n+                CacheBuilder.newBuilder().maximumSize(DEFAULT_CACHE_MAX_SIZE)\n+                            .concurrencyLevel(Runtime.getRuntime().availableProcessors());\n+        cacheBuilder.expireAfterWrite(DEFAULT_CACHE_MAX_AGE);\n+        return cacheBuilder.build();\n+    }\n+\n+    private final WebClient introspectionEndpoint;\n+    private final String introspectionEndpointPath;\n+\n+    @Nullable\n+    private ClientAuthorization clientAuthorization;\n+\n+    @Nullable\n+    private String accessTokenType;\n+\n+    @Nullable\n+    private String realm;\n+\n+    private final ImmutableSet.Builder<String> permittedScope = ImmutableSet.builder();\n+\n+    @Nullable\n+    private Cache<String, OAuth2TokenDescriptor> tokenCache;\n+\n+    /**\n+     * Constructs new new builder for OAuth 2.0 Token Introspection {@link Authorizer},\n+     * as per<a href=\"https://tools.ietf.org/html/rfc7662#section-2\">[RFC7662], Section 2</a>.\n+     *\n+     * @param introspectionEndpoint A {@link WebClient} to facilitate the Token Introspection request. Must\n+     *                              correspond to the Token Introspection endpoint of the OAuth 2.0 system.\n+     * @param introspectionEndpointPath A URI path that corresponds to the Token Introspection endpoint of the\n+     *                                  OAuth 2.0 system.\n+     */\n+    OAuth2TokenIntrospectionAuthorizerBuilder(WebClient introspectionEndpoint,\n+                                              String introspectionEndpointPath) {\n+        this.introspectionEndpoint = requireNonNull(introspectionEndpoint, \"introspectionEndpoint\");\n+        this.introspectionEndpointPath =\n+                requireNonNull(introspectionEndpointPath, \"introspectionEndpointPath\");\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 Introspection requests based on encoded authorization\n+     * token and authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    public OAuth2TokenIntrospectionAuthorizerBuilder clientAuthorization(\n+            Supplier<String> authorizationSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofAuthorization(authorizationSupplier, authorizationType);\n+        return this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 Introspection requests based on encoded authorization\n+     * token and {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     */\n+    public OAuth2TokenIntrospectionAuthorizerBuilder clientBasicAuthorization(\n+            Supplier<String> authorizationSupplier) {\n+        clientAuthorization = ClientAuthorization.ofBasicAuthorization(authorizationSupplier);\n+        return this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 Introspection requests based on client credentials and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    public OAuth2TokenIntrospectionAuthorizerBuilder clientCredentials(\n+            Supplier<? extends Map.Entry<String, String>> credentialsSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofCredentials(credentialsSupplier, authorizationType);\n+        return this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 Introspection requests based on client credentials and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     */\n+    public OAuth2TokenIntrospectionAuthorizerBuilder clientCredentials(\n+            Supplier<? extends Map.Entry<String, String>> credentialsSupplier) {\n+        clientAuthorization = ClientAuthorization.ofCredentials(credentialsSupplier);\n+        return this;\n+    }\n+\n+    /**\n+     * Access Token type permitted by this authorizer,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-7.1\">[RFC6749], Section 7.1</a>.\n+     * The authorizer will accept any type if empty. OPTIONAL.\n+     */\n+    public OAuth2TokenIntrospectionAuthorizerBuilder accessTokenType(String accessTokenType) {\n+        this.accessTokenType = requireNonNull(accessTokenType, \"accessTokenType\");\n+        return this;\n+    }\n+\n+    /**\n+     * An HTTP Realm - a name designating of the protected area. OPTIONAL.\n+     */\n+    public OAuth2TokenIntrospectionAuthorizerBuilder realm(String realm) {\n+        this.realm = requireNonNull(realm, \"realm\");\n+        return this;\n+    }\n+\n+    /**\n+     * An {@link Iterable} of case-sensitive scope strings permitted by this authorizer.\n+     * The authorizer will accept any scope if empty.\n+     */\n+    public OAuth2TokenIntrospectionAuthorizerBuilder permittedScope(Iterable<String> scope) {\n+        permittedScope.addAll(requireNonNull(scope, \"scope\"));\n+        return this;\n+    }\n+\n+    /**\n+     * An array of of case-sensitive scope strings permitted by this authorizer.\n+     * The authorizer will accept any scope if empty.\n+     */\n+    public OAuth2TokenIntrospectionAuthorizerBuilder permittedScope(String... scope) {\n+        permittedScope.add(requireNonNull(scope, \"scope\"));\n+        return this;\n+    }\n+\n+    /**\n+     * Provides caching facility for OAuth 2.0 {@link OAuth2TokenDescriptor} in order to avoid continuous Token\n+     * Introspection as per <a href=\"https://tools.ietf.org/html/rfc7662#section-2.2\">[RFC7662], Section 2.2</a>.\n+     */\n+    public OAuth2TokenIntrospectionAuthorizerBuilder tokenCache(\n+            Cache<String, OAuth2TokenDescriptor> tokenCache) {", "originalCommit": "3dda250ada08c00be95ddb63f284a3e74f35fa25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDcxMDEwMA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r564710100", "bodyText": "Replaced Guava Cache with Caffeine in the latest commit as you requested using the cache spec.", "author": "max904-github", "createdAt": "2021-01-26T17:49:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzMwNDM1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzMwNTk0NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563305944", "bodyText": "Could we make AuthorizationStatus.ofSuccess(null) and CompletableFuture a singleton?\nprivate static final CompletionStage<AuthorizationStatus> SUCCESS_STATUS = \n        CompletableFuture.completedFuture(AuthorizationStatus.ofSuccess(null));", "author": "ikhoon", "createdAt": "2021-01-24T15:08:09Z", "path": "oauth2/src/main/java/com/linecorp/armeria/server/auth/oauth2/OAuth2TokenIntrospectionAuthorizer.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.auth.oauth2;\n+\n+import static com.linecorp.armeria.internal.common.auth.oauth2.OAuth2Constants.UNSUPPORTED_TOKEN_TYPE;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.cache.Cache;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.auth.OAuth2Token;\n+import com.linecorp.armeria.common.auth.oauth2.OAuth2TokenDescriptor;\n+import com.linecorp.armeria.internal.server.auth.oauth2.TokenIntrospectionRequest;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.auth.AbstractAuthorizerWithHandlers;\n+import com.linecorp.armeria.server.auth.AuthFailureHandler;\n+import com.linecorp.armeria.server.auth.AuthorizationStatus;\n+\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Determines whether a given {@link OAuth2Token} is authorized for the service registered in using OAuth 2.0\n+ * Token Introspection. {@code ctx} can be used for storing authorization information about the request for use\n+ * in business logic.\n+ */\n+@UnstableApi\n+public final class OAuth2TokenIntrospectionAuthorizer extends AbstractAuthorizerWithHandlers<OAuth2Token> {\n+\n+    /**\n+     * Returns a newly created {@link OAuth2TokenIntrospectionAuthorizerBuilder}.\n+     *\n+     * @param introspectionEndpoint A {@link WebClient} to facilitate the Token Introspection request. Must\n+     *                              correspond to the Token Introspection endpoint of the OAuth 2.0 system.\n+     * @param introspectionEndpointPath A URI path that corresponds to the Token Introspection endpoint of the\n+     *                                  OAuth 2.0 system.\n+     */\n+    public static OAuth2TokenIntrospectionAuthorizerBuilder builder(WebClient introspectionEndpoint,\n+                                                                    String introspectionEndpointPath) {\n+        return new OAuth2TokenIntrospectionAuthorizerBuilder(introspectionEndpoint, introspectionEndpointPath);\n+    }\n+\n+    static final AttributeKey<Integer> ERROR_CODE = AttributeKey.valueOf(\"x-oauth2-error\");\n+    static final AttributeKey<String> ERROR_TYPE = AttributeKey.valueOf(\"x-oauth2-error-type\");\n+    static final String INVALID_TOKEN = \"invalid_token\";\n+    static final String INSUFFICIENT_SCOPE = \"insufficient_scope\";\n+\n+    private final Cache<String, OAuth2TokenDescriptor> tokenCache;\n+    private final Set<String> permittedScope;\n+    @Nullable\n+    private final String accessTokenType;\n+    @Nullable\n+    private final String realm;\n+    private final TokenIntrospectionRequest tokenIntrospectionRequest;\n+    private final AuthFailureHandler authFailureHandler;\n+\n+    OAuth2TokenIntrospectionAuthorizer(Cache<String, OAuth2TokenDescriptor> tokenCache,\n+                                       @Nullable String accessTokenType, @Nullable String realm,\n+                                       Set<String> permittedScope,\n+                                       TokenIntrospectionRequest tokenIntrospectionRequest) {\n+        this.tokenCache = requireNonNull(tokenCache, \"tokenCache\");\n+        this.accessTokenType = accessTokenType;\n+        this.realm = realm;\n+        this.permittedScope = requireNonNull(permittedScope, \"permittedScope\");\n+        this.tokenIntrospectionRequest =\n+                requireNonNull(tokenIntrospectionRequest, \"tokenIntrospectionRequest\");\n+        authFailureHandler =\n+                new OAuth2AuthorizationFailureHandler(accessTokenType, realm, String.join(\" \", permittedScope));\n+    }\n+\n+    /**\n+     * Scopes permitted by this authorizer. The authorizer will accept any scope if empty.\n+     */\n+    public Set<String> permittedScope() {\n+        return permittedScope;\n+    }\n+\n+    /**\n+     * Authorization type permitted by this authorizer. The authorizer will accept any type if empty.\n+     * One of the registered HTTP authentication schemes as per\n+     * <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     * HTTP Authentication Scheme Registry</a>.\n+     */\n+    @Nullable\n+    public String accessTokenType() {\n+        return accessTokenType;\n+    }\n+\n+    /**\n+     * An HTTP Realm - a name designating the protected area. OPTIONAL.\n+     */\n+    @Nullable\n+    public String realm() {\n+        return realm;\n+    }\n+\n+    /**\n+     * An instance of {@link OAuth2AuthorizationFailureHandler}.\n+     */\n+    public AuthFailureHandler failureHandler() {\n+        return authFailureHandler;\n+    }\n+\n+    @Override\n+    public CompletionStage<AuthorizationStatus> authorizeAndSupplyHandlers(ServiceRequestContext ctx,\n+                                                                           @Nullable OAuth2Token data) {\n+\n+        if (data == null) {\n+            // no access token present\n+            return CompletableFuture.completedFuture(AuthorizationStatus.ofFailure(authFailureHandler));\n+        }\n+        final String accessToken = data.accessToken();\n+        final OAuth2TokenDescriptor tokenDescriptor = tokenCache.getIfPresent(accessToken);\n+        if (tokenDescriptor != null) {\n+            // just re-validate existing token\n+            final AuthorizationStatus status =\n+                    validateDescriptor(ctx, tokenDescriptor) ? AuthorizationStatus.ofSuccess(null)", "originalCommit": "3dda250ada08c00be95ddb63f284a3e74f35fa25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk4MTM3NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563981375", "bodyText": "Added SUCCESS constant to AuthorizationStatus and added the optimization you've suggested.", "author": "max904-github", "createdAt": "2021-01-25T19:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzMwNTk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzQ5OTY5Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563499697", "bodyText": "Add static?", "author": "ikhoon", "createdAt": "2021-01-25T07:07:13Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractOAuth2AuthorizationGrant.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken;\n+import com.linecorp.armeria.common.auth.oauth2.InvalidClientException;\n+import com.linecorp.armeria.common.auth.oauth2.TokenRequestException;\n+import com.linecorp.armeria.common.auth.oauth2.UnsupportedMediaTypeException;\n+import com.linecorp.armeria.internal.client.auth.oauth2.RefreshAccessTokenRequest;\n+\n+/**\n+ * Base implementation of OAuth 2.0 Access Token Grant flow to obtain Access Token.\n+ * Implements Access Token loading, storing and refreshing.\n+ */\n+abstract class AbstractOAuth2AuthorizationGrant implements OAuth2AuthorizationGrant {\n+\n+    private final RefreshAccessTokenRequest refreshRequest;\n+\n+    private final Duration refreshBefore;\n+\n+    /**\n+     * Holds a token object and facilitates its lifecycle.\n+     */\n+    private final TokenLifecycleManager<GrantedOAuth2AccessToken> tokenManager;\n+\n+    AbstractOAuth2AuthorizationGrant(RefreshAccessTokenRequest refreshRequest, Duration refreshBefore,\n+                                     @Nullable Supplier<? extends GrantedOAuth2AccessToken> tokenSupplier,\n+                                     @Nullable Consumer<? super GrantedOAuth2AccessToken> tokenConsumer,\n+                                     @Nullable Executor executor) {\n+        this.refreshRequest = requireNonNull(refreshRequest, \"refreshRequest\");\n+        this.refreshBefore = requireNonNull(refreshBefore, \"refreshBefore\");\n+        tokenManager = new TokenLifecycleManager<>(this::isValid, this::canRefresh,\n+                                                   this::shallObtainInsteadOfUpdate,\n+                                                   this::obtainAccessToken, this::refreshAccessToken,\n+                                                   tokenSupplier, tokenConsumer, executor);\n+    }\n+\n+    /**\n+     * Tests the token for validity at the given {@link Instant} time.\n+     */\n+    private boolean isValid(GrantedOAuth2AccessToken token, Instant now) {\n+        return token.isValid(now.plus(refreshBefore));\n+    }\n+\n+    /**\n+     * Tests whether the token object can be refreshed or re-obtained.\n+     */\n+    private boolean canRefresh(GrantedOAuth2AccessToken token) {\n+        return token.refreshToken() != null;\n+    }\n+\n+    /**\n+     * Tests whether given {@link Throwable} indicates that the token shall be re-obtained\n+     * after the refresh operation failure.\n+     */\n+    private boolean shallObtainInsteadOfUpdate(Throwable throwable) {\n+        return throwable instanceof TokenRequestException;", "originalCommit": "3dda250ada08c00be95ddb63f284a3e74f35fa25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk4MjQ1Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563982457", "bodyText": "changed", "author": "max904-github", "createdAt": "2021-01-25T19:21:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzQ5OTY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzUwMDI0Mg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563500242", "bodyText": "Add @FunctionalInterface?", "author": "ikhoon", "createdAt": "2021-01-25T07:08:34Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/OAuth2AuthorizationGrant.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import java.util.concurrent.CompletionStage;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken;\n+\n+/**\n+ * Represents an OAuth 2.0 Access Token Grant flow to obtain Access Token.\n+ */\n+@UnstableApi", "originalCommit": "3dda250ada08c00be95ddb63f284a3e74f35fa25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk4MzA0MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563983040", "bodyText": "added", "author": "max904-github", "createdAt": "2021-01-25T19:22:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzUwMDI0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzUwMDU0Mw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563500543", "bodyText": "Drop get prefix and just accessToken()?", "author": "ikhoon", "createdAt": "2021-01-25T07:09:20Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/OAuth2AuthorizationGrant.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import java.util.concurrent.CompletionStage;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken;\n+\n+/**\n+ * Represents an OAuth 2.0 Access Token Grant flow to obtain Access Token.\n+ */\n+@UnstableApi\n+public interface OAuth2AuthorizationGrant {\n+\n+    /**\n+     * Produces OAuth 2.0 Access Token\n+     */\n+    CompletionStage<GrantedOAuth2AccessToken> getAccessToken();", "originalCommit": "3dda250ada08c00be95ddb63f284a3e74f35fa25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk4NDQ4NQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563984485", "bodyText": "this method assumes some action to be executed in order to get the token. to me accessToken() looks like reading a field value. do you think this won't be confusing?", "author": "max904-github", "createdAt": "2021-01-25T19:24:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzUwMDU0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTI0NTM4MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r565245380", "bodyText": "+1 for retaining the get prefix.", "author": "trustin", "createdAt": "2021-01-27T11:47:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzUwMDU0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTM3MTQ5Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r565371497", "bodyText": "That makes sense. Let's keep it as it is.", "author": "ikhoon", "createdAt": "2021-01-27T14:53:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzUwMDU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzUwMjc1Ng==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563502756", "bodyText": "How about raising an IllegalStateException if clientAuthorization was already set before.", "author": "ikhoon", "createdAt": "2021-01-25T07:15:19Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractOAuth2AuthorizationGrantBuilder.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken;\n+import com.linecorp.armeria.internal.client.auth.oauth2.AbstractAccessTokenRequest;\n+import com.linecorp.armeria.internal.client.auth.oauth2.RefreshAccessTokenRequest;\n+\n+@SuppressWarnings(\"rawtypes\")\n+abstract class AbstractOAuth2AuthorizationGrantBuilder<T extends AbstractOAuth2AuthorizationGrantBuilder> {\n+\n+    /**\n+     * A period when the token should be refreshed proactively prior to its expiry.\n+     */\n+    private static final Duration DEFAULT_REFRESH_BEFORE = Duration.ofMinutes(1L); // 1 minute\n+\n+    private final WebClient accessTokenEndpoint;\n+    private final String accessTokenEndpointPath;\n+\n+    @Nullable\n+    private ClientAuthorization clientAuthorization;\n+\n+    private Duration refreshBefore = DEFAULT_REFRESH_BEFORE;\n+\n+    @Nullable\n+    private Supplier<? extends GrantedOAuth2AccessToken> tokenSupplier;\n+\n+    @Nullable\n+    private Consumer<? super GrantedOAuth2AccessToken> tokenConsumer;\n+\n+    @Nullable\n+    private Executor executor;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Access Token request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a>.\n+     *\n+     * @param accessTokenEndpoint A {@link WebClient} to facilitate an Access Token request. Must correspond to\n+     *                            the Access Token endpoint of the OAuth 2 system.\n+     * @param accessTokenEndpointPath A URI path that corresponds to the Access Token endpoint of the\n+     *                                OAuth 2 system.\n+     */\n+    AbstractOAuth2AuthorizationGrantBuilder(WebClient accessTokenEndpoint, String accessTokenEndpointPath) {\n+        this.accessTokenEndpoint = requireNonNull(accessTokenEndpoint, \"accessTokenEndpoint\");\n+        this.accessTokenEndpointPath = requireNonNull(accessTokenEndpointPath, \"accessTokenEndpointPath\");\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientAuthorization(\n+            Supplier<String> authorizationSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofAuthorization(authorizationSupplier, authorizationType);", "originalCommit": "3dda250ada08c00be95ddb63f284a3e74f35fa25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDcyMDE4MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r564720181", "bodyText": "added the check", "author": "max904-github", "createdAt": "2021-01-26T18:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzUwMjc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzUwNzMxNA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563507314", "bodyText": "How about narrowing the executor down to EventExecutor to guarantee serial execution.", "author": "ikhoon", "createdAt": "2021-01-25T07:27:03Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/AbstractOAuth2AuthorizationGrantBuilder.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.common.auth.oauth2.GrantedOAuth2AccessToken;\n+import com.linecorp.armeria.internal.client.auth.oauth2.AbstractAccessTokenRequest;\n+import com.linecorp.armeria.internal.client.auth.oauth2.RefreshAccessTokenRequest;\n+\n+@SuppressWarnings(\"rawtypes\")\n+abstract class AbstractOAuth2AuthorizationGrantBuilder<T extends AbstractOAuth2AuthorizationGrantBuilder> {\n+\n+    /**\n+     * A period when the token should be refreshed proactively prior to its expiry.\n+     */\n+    private static final Duration DEFAULT_REFRESH_BEFORE = Duration.ofMinutes(1L); // 1 minute\n+\n+    private final WebClient accessTokenEndpoint;\n+    private final String accessTokenEndpointPath;\n+\n+    @Nullable\n+    private ClientAuthorization clientAuthorization;\n+\n+    private Duration refreshBefore = DEFAULT_REFRESH_BEFORE;\n+\n+    @Nullable\n+    private Supplier<? extends GrantedOAuth2AccessToken> tokenSupplier;\n+\n+    @Nullable\n+    private Consumer<? super GrantedOAuth2AccessToken> tokenConsumer;\n+\n+    @Nullable\n+    private Executor executor;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Access Token request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a>.\n+     *\n+     * @param accessTokenEndpoint A {@link WebClient} to facilitate an Access Token request. Must correspond to\n+     *                            the Access Token endpoint of the OAuth 2 system.\n+     * @param accessTokenEndpointPath A URI path that corresponds to the Access Token endpoint of the\n+     *                                OAuth 2 system.\n+     */\n+    AbstractOAuth2AuthorizationGrantBuilder(WebClient accessTokenEndpoint, String accessTokenEndpointPath) {\n+        this.accessTokenEndpoint = requireNonNull(accessTokenEndpoint, \"accessTokenEndpoint\");\n+        this.accessTokenEndpointPath = requireNonNull(accessTokenEndpointPath, \"accessTokenEndpointPath\");\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientAuthorization(\n+            Supplier<String> authorizationSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofAuthorization(authorizationSupplier, authorizationType);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on encoded authorization token and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param authorizationSupplier A supplier of encoded client authorization token.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientBasicAuthorization(Supplier<String> authorizationSupplier) {\n+        clientAuthorization = ClientAuthorization.ofBasicAuthorization(authorizationSupplier);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     * @param authorizationType One of the registered HTTP authentication schemes as per\n+     *                          <a href=\"https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">\n+     *                          HTTP Authentication Scheme Registry</a>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientCredentials(\n+            Supplier<? extends Map.Entry<String, String>> credentialsSupplier, String authorizationType) {\n+        clientAuthorization = ClientAuthorization.ofCredentials(credentialsSupplier, authorizationType);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Provides client authorization for the OAuth 2.0 requests based on client credentials and\n+     * {@code Basic} authorization type,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749#section-2.3\">[RFC6749], Section 2.3</a>.\n+     *\n+     * @param credentialsSupplier A supplier of client credentials.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T clientCredentials(\n+            Supplier<? extends Map.Entry<String, String>> credentialsSupplier) {\n+        clientAuthorization = ClientAuthorization.ofCredentials(credentialsSupplier);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * A period when the token should be refreshed proactively prior to its expiry.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T refreshBefore(Duration refreshBefore) {\n+        this.refreshBefore = requireNonNull(refreshBefore, \"refreshBefore\");\n+        return (T) this;\n+    }\n+\n+    final Duration refreshBefore() {\n+        return refreshBefore;\n+    }\n+\n+    /**\n+     * A {@link Supplier} to load Access Token from, to be able to restore the previous session. OPTIONAL.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T tokenSupplier(Supplier<? extends GrantedOAuth2AccessToken> tokenSupplier) {\n+        this.tokenSupplier = requireNonNull(tokenSupplier, \"tokenSupplier\");\n+        return (T) this;\n+    }\n+\n+    @Nullable\n+    final Supplier<? extends GrantedOAuth2AccessToken> tokenSupplier() {\n+        return tokenSupplier;\n+    }\n+\n+    /**\n+     * A {@link Consumer} to store Access Token to, to be able restore the previous session. OPTIONAL.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T tokenConsumer(Consumer<? super GrantedOAuth2AccessToken> tokenConsumer) {\n+        this.tokenConsumer = requireNonNull(tokenConsumer, \"tokenConsumer\");\n+        return (T) this;\n+    }\n+\n+    @Nullable\n+    final Consumer<? super GrantedOAuth2AccessToken> tokenConsumer() {\n+        return tokenConsumer;\n+    }\n+\n+    /**\n+     * An optional {@link Executor} that facilitates asynchronous access token obtain and refresh operations.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final T executor(Executor executor) {", "originalCommit": "3dda250ada08c00be95ddb63f284a3e74f35fa25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDAyMDgwMg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r564020802", "bodyText": "Not sure I understood your suggestion. Executor in this context is part of public API. I don't think most of the API users are aware of EventExecutor. What's a purpose of narrowing it down and how EventExecutor will guarantee serial execution? Asynchronous execution is made sure by SerialFuture which uses Executor.", "author": "max904-github", "createdAt": "2021-01-25T20:27:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzUwNzMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzUxMDY2OA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563510668", "bodyText": "Add requireNonNull before creating a lambda?", "author": "ikhoon", "createdAt": "2021-01-25T07:35:23Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/OAuth2Client.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.function.Function;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.HttpClient;\n+import com.linecorp.armeria.client.SimpleDecoratingHttpClient;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * Decorates a {@link HttpClient} with an OAuth 2.0 Authorization Grant flow.\n+ */\n+@UnstableApi\n+public final class OAuth2Client extends SimpleDecoratingHttpClient {\n+\n+    /**\n+     * Creates a new {@link HttpClient} decorator that handles OAuth 2.0 Authorization Grant flow.\n+     * @param authorizationGrant An {@link OAuth2AuthorizationGrant} implementing specific\n+     *                           OAuth 2.0 Authorization Grant flow.\n+     */\n+    public static Function<? super HttpClient, OAuth2Client> newDecorator(\n+            OAuth2AuthorizationGrant authorizationGrant) {\n+        return delegate -> new OAuth2Client(delegate, authorizationGrant);", "originalCommit": "3dda250ada08c00be95ddb63f284a3e74f35fa25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDAyMTQ5Nw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r564021497", "bodyText": "done", "author": "max904-github", "createdAt": "2021-01-25T20:28:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzUxMDY2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzUxNjkzMw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r563516933", "bodyText": "I think some users may want to use a non-supplier version for building this class and others.\nHow about globally applying this pattern to other builder methods?\n// Remove `Supplier` postfix from method name\npublic OAuth2ResourceOwnerPasswordCredentialsGrantBuilder userCredentials(\n        Supplier<Entry<String, String>> userCredentialsSupplier) {\n    this.userCredentialsSupplier = requireNonNull(userCredentialsSupplier, \"userCredentialsSupplier\");\n    return this;\n}\n\npublic OAuth2ResourceOwnerPasswordCredentialsGrantBuilder userCredentials(\n        String username, String password) {\n    requireNonNull(username, \"username\");\n    requireNonNull(password, \"password\");\n    userCredentials(() -> new SimpleEntry<>(username, password));\n    return this;\n}", "author": "ikhoon", "createdAt": "2021-01-25T07:49:26Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/OAuth2ResourceOwnerPasswordCredentialsGrantBuilder.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.internal.client.auth.oauth2.AbstractAccessTokenRequest;\n+import com.linecorp.armeria.internal.client.auth.oauth2.ResourceOwnerPasswordCredentialsTokenRequest;\n+\n+/**\n+ * Builds {@link OAuth2ClientCredentialsGrant}.\n+ */\n+@UnstableApi\n+public final class OAuth2ResourceOwnerPasswordCredentialsGrantBuilder\n+        extends AbstractOAuth2AuthorizationGrantBuilder<OAuth2ResourceOwnerPasswordCredentialsGrantBuilder> {\n+\n+    @Nullable\n+    private Supplier<? extends Map.Entry<String, String>> userCredentialsSupplier;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Access Token request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a>.\n+     * @param accessTokenEndpoint A {@link WebClient} to facilitate an Access Token request. Must correspond to\n+     *                            the Access Token endpoint of the OAuth 2 system.\n+     * @param accessTokenEndpointPath A URI path that corresponds to the Access Token endpoint of the\n+     */\n+    OAuth2ResourceOwnerPasswordCredentialsGrantBuilder(\n+            WebClient accessTokenEndpoint, String accessTokenEndpointPath) {\n+        super(accessTokenEndpoint, accessTokenEndpointPath);\n+    }\n+\n+    /**\n+     * A supplier of user credentials: \"username\" and \"password\" used to grant the Access Token. REQUIRED.\n+     */\n+    public OAuth2ResourceOwnerPasswordCredentialsGrantBuilder userCredentialsSupplier(\n+            Supplier<Entry<String, String>> userCredentialsSupplier) {\n+        this.userCredentialsSupplier = requireNonNull(userCredentialsSupplier, \"userCredentialsSupplier\");\n+        return this;\n+    }", "originalCommit": "3dda250ada08c00be95ddb63f284a3e74f35fa25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDAyNjUyNg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r564026526", "bodyText": "No, don't want to put ownership over any credentials or credentials lifecycle to this infrastructure, especially considering that credentials change over time (sometimes quite often - when those get compromised, when some policy kicks in or when the user simply wishes to change its password). The user can easily do () -> new SimpleEntry<>(username, password) as well, but I would strongly advise against it as it's an anti-pattern.\nIn my typical implementation credentials managed by 3rd-party services like Vault and those could get changed or updated and any moment.", "author": "max904-github", "createdAt": "2021-01-25T20:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzUxNjkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTI0NDgyMA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r565244820", "bodyText": "Then how about just renaming userCredentialsSupplier() method to userCredentials() for brevity?", "author": "trustin", "createdAt": "2021-01-27T11:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzUxNjkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njc0MDU2MQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r566740561", "bodyText": "sure, np", "author": "max904-github", "createdAt": "2021-01-29T10:57:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzUxNjkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzAzNTU2Mg==", "url": "https://github.com/line/armeria/pull/2840#discussion_r567035562", "bodyText": "done", "author": "max904-github", "createdAt": "2021-01-29T19:11:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzUxNjkzMw=="}], "type": "inlineReview"}, {"oid": "a773eb62f0b537bd8016d4235a1d7a4c62713903", "url": "https://github.com/line/armeria/commit/a773eb62f0b537bd8016d4235a1d7a4c62713903", "message": "more review comments by @ikhoon and @trustin", "committedDate": "2021-01-25T21:23:47Z", "type": "commit"}, {"oid": "281c3d274b29a0db34d48479bb9eef85576ba8da", "url": "https://github.com/line/armeria/commit/281c3d274b29a0db34d48479bb9eef85576ba8da", "message": "replaced Guava Cache with Caffeine, as suggested by @ikhoon", "committedDate": "2021-01-26T17:17:10Z", "type": "commit"}, {"oid": "e956b65ebffc5e1b9c9ecfe4d7a672074bb14881", "url": "https://github.com/line/armeria/commit/e956b65ebffc5e1b9c9ecfe4d7a672074bb14881", "message": "raising an IllegalStateException if clientAuthorization was already set before", "committedDate": "2021-01-26T18:04:02Z", "type": "commit"}, {"oid": "18fc816fc4f876d2adc00d122a9f610935d0be10", "url": "https://github.com/line/armeria/commit/18fc816fc4f876d2adc00d122a9f610935d0be10", "message": "renamed public methods:\n- userCredentialsSupplier() -> userCredentials();\n- tokenSupplier() -> tokenPersistencySupplier(), tokenConsumer() -> tokenPersistencyConsumer()", "committedDate": "2021-01-29T11:24:12Z", "type": "commit"}, {"oid": "bce7edcfba0f62af60220d6479bb26ffa964d8aa", "url": "https://github.com/line/armeria/commit/bce7edcfba0f62af60220d6479bb26ffa964d8aa", "message": "- removed AuthorizationStatus.of(@Nullable Boolean status)\n- replaced VolatileCounter with AtomicInteger in the unit test", "committedDate": "2021-02-03T20:06:50Z", "type": "commit"}, {"oid": "bf79a21ebfd3a074b536aa06d08746f7f5bf926b", "url": "https://github.com/line/armeria/commit/bf79a21ebfd3a074b536aa06d08746f7f5bf926b", "message": "- extracted OAuth2TokenScopeValidator to support additional application-level token validation (e.g. fine-grained access control)", "committedDate": "2021-02-16T21:28:34Z", "type": "commit"}, {"oid": "304dadbb37ad454ea90d46e703d5594ead5889ea", "url": "https://github.com/line/armeria/commit/304dadbb37ad454ea90d46e703d5594ead5889ea", "message": "replaced junit4 ServerRule with junit5 ServerExtension;", "committedDate": "2021-02-19T16:07:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4OTg5NjIwMw==", "url": "https://github.com/line/armeria/pull/2840#discussion_r589896203", "bodyText": "Could we change this static member to a static method such as static AuthorizationStatus ofSuccess();?", "author": "ikhoon", "createdAt": "2021-03-09T02:36:23Z", "path": "core/src/main/java/com/linecorp/armeria/server/auth/AuthorizationStatus.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.auth;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+\n+/**\n+ * Provides a status of the request authorization operation, optionally combined with {@link AuthSuccessHandler}\n+ * and {@link AuthFailureHandler} to facilitate custom status handling.\n+ */\n+@UnstableApi\n+public interface AuthorizationStatus {\n+\n+    /**\n+     * Default Authorization Success status with no {@link AuthSuccessHandler} defined.\n+     */\n+    AuthorizationStatus SUCCESS = ofSuccess(null);", "originalCommit": "304dadbb37ad454ea90d46e703d5594ead5889ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTc1MDM0NA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r591750344", "bodyText": "done", "author": "max904-github", "createdAt": "2021-03-10T18:04:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4OTg5NjIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4OTk4MzgxOQ==", "url": "https://github.com/line/armeria/pull/2840#discussion_r589983819", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Supplier<Entry<String, String>> userCredentials) {\n          \n          \n            \n                        Supplier<? extends Entry<String, String>> userCredentials) {", "author": "ikhoon", "createdAt": "2021-03-09T06:48:21Z", "path": "oauth2/src/main/java/com/linecorp/armeria/client/auth/oauth2/OAuth2ResourceOwnerPasswordCredentialsGrantBuilder.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.auth.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.auth.oauth2.ClientAuthorization;\n+import com.linecorp.armeria.internal.client.auth.oauth2.AbstractAccessTokenRequest;\n+import com.linecorp.armeria.internal.client.auth.oauth2.ResourceOwnerPasswordCredentialsTokenRequest;\n+\n+/**\n+ * Builds {@link OAuth2ClientCredentialsGrant}.\n+ */\n+@UnstableApi\n+public final class OAuth2ResourceOwnerPasswordCredentialsGrantBuilder\n+        extends AbstractOAuth2AuthorizationGrantBuilder<OAuth2ResourceOwnerPasswordCredentialsGrantBuilder> {\n+\n+    @Nullable\n+    private Supplier<? extends Map.Entry<String, String>> userCredentialsSupplier;\n+\n+    /**\n+     * A common abstraction for the requests implementing various Access Token request/response flows,\n+     * as per <a href=\"https://tools.ietf.org/html/rfc6749\">[RFC6749]</a>.\n+     * @param accessTokenEndpoint A {@link WebClient} to facilitate an Access Token request. Must correspond to\n+     *                            the Access Token endpoint of the OAuth 2 system.\n+     * @param accessTokenEndpointPath A URI path that corresponds to the Access Token endpoint of the\n+     */\n+    OAuth2ResourceOwnerPasswordCredentialsGrantBuilder(\n+            WebClient accessTokenEndpoint, String accessTokenEndpointPath) {\n+        super(accessTokenEndpoint, accessTokenEndpointPath);\n+    }\n+\n+    /**\n+     * A supplier of user credentials: \"username\" and \"password\" used to grant the Access Token. REQUIRED.\n+     */\n+    public OAuth2ResourceOwnerPasswordCredentialsGrantBuilder userCredentials(\n+            Supplier<Entry<String, String>> userCredentials) {", "originalCommit": "304dadbb37ad454ea90d46e703d5594ead5889ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTc1MDU2MA==", "url": "https://github.com/line/armeria/pull/2840#discussion_r591750560", "bodyText": "missed that. done", "author": "max904-github", "createdAt": "2021-03-10T18:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4OTk4MzgxOQ=="}], "type": "inlineReview"}, {"oid": "4eca1bab0c42240e324136b9103b3957d66ee5c8", "url": "https://github.com/line/armeria/commit/4eca1bab0c42240e324136b9103b3957d66ee5c8", "message": "review comments by @ikhoon", "committedDate": "2021-03-10T18:03:04Z", "type": "commit"}, {"oid": "27cf475d6dab25c2b92b3a532786cbf6324b8641", "url": "https://github.com/line/armeria/commit/27cf475d6dab25c2b92b3a532786cbf6324b8641", "message": "Merge branch 'master' into oauth2-issue2268", "committedDate": "2021-03-28T06:27:21Z", "type": "commit"}, {"oid": "2ec0a16f49049c3d4a190a63cb4e1f7727465ea8", "url": "https://github.com/line/armeria/commit/2ec0a16f49049c3d4a190a63cb4e1f7727465ea8", "message": "Lint", "committedDate": "2021-03-28T07:05:34Z", "type": "commit"}, {"oid": "6fa700ac6847f70810a772e007d5f754af0e7f40", "url": "https://github.com/line/armeria/commit/6fa700ac6847f70810a772e007d5f754af0e7f40", "message": "Minor clean-up", "committedDate": "2021-03-28T08:19:17Z", "type": "commit"}]}