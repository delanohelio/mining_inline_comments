{"pr_number": 2444, "pr_title": "Refactor ContentPreviewer", "pr_createdAt": "2020-02-03T11:07:17Z", "pr_url": "https://github.com/line/armeria/pull/2444", "timeline": [{"oid": "f06cbf001a425968303c50e9b70a3f6e7f33a5db", "url": "https://github.com/line/armeria/commit/f06cbf001a425968303c50e9b70a3f6e7f33a5db", "message": "Refactor ContentPreviewer", "committedDate": "2020-02-03T09:39:50Z", "type": "commit"}, {"oid": "074732a9b46a05b46fc8466a399da18d8fb5bd20", "url": "https://github.com/line/armeria/commit/074732a9b46a05b46fc8466a399da18d8fb5bd20", "message": "Fix", "committedDate": "2020-02-03T11:10:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA0ODA5NQ==", "url": "https://github.com/line/armeria/pull/2444#discussion_r374048095", "bodyText": "I guess this should be moved somewhere else?", "author": "trustin", "createdAt": "2020-02-03T11:19:31Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ContentPreviewerFactory.java", "diffHunk": "@@ -16,216 +16,262 @@\n package com.linecorp.armeria.common.logging;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static java.util.Objects.requireNonNull;\n \n import java.nio.charset.Charset;\n-import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.Set;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n \n-import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableList;\n \n import com.linecorp.armeria.common.HttpHeaders;\n import com.linecorp.armeria.common.MediaType;\n import com.linecorp.armeria.common.RequestContext;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.ResponseHeaders;\n import com.linecorp.armeria.internal.ArmeriaHttpUtil;\n \n+import io.netty.buffer.ByteBuf;\n+\n /**\n  * A factory creating a {@link ContentPreviewer}.\n  */\n @FunctionalInterface\n public interface ContentPreviewerFactory {\n \n     /**\n-     * Creates a new instance of {@link ContentPreviewerFactory} which creates a {@link ContentPreviewer}\n-     * through {@code supplier} for the request/response with the {@code contentType}.\n+     * The default HTTP content-type charset.\n+     * See https://tools.ietf.org/html/rfc2616#section-3.7.1\n      */\n-    static ContentPreviewerFactory of(MediaType contentType, Supplier<? extends ContentPreviewer> supplier) {\n-        return of(ImmutableMap.of(contentType, supplier));\n+    static Charset defaultCharset() {\n+        return ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET;\n     }", "originalCommit": "074732a9b46a05b46fc8466a399da18d8fb5bd20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA0ODkxMA==", "url": "https://github.com/line/armeria/pull/2444#discussion_r374048910", "bodyText": "How about splitting this method into two:\nContentPreviewer requestContentPreviewer(ctx, RequestHeaders headers);\nContentPreviewer responseContentPreviewer(ctx, RequestHeaders reqHeaders, ResponseHeaders resHeaders);\nI guess the behavior of response previewer might be affected by a certain request header, e.g. x-enable-content-preview: 1.", "author": "trustin", "createdAt": "2020-02-03T11:21:23Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ContentPreviewerFactory.java", "diffHunk": "@@ -16,216 +16,262 @@\n package com.linecorp.armeria.common.logging;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static java.util.Objects.requireNonNull;\n \n import java.nio.charset.Charset;\n-import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.Set;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n \n-import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableList;\n \n import com.linecorp.armeria.common.HttpHeaders;\n import com.linecorp.armeria.common.MediaType;\n import com.linecorp.armeria.common.RequestContext;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.ResponseHeaders;\n import com.linecorp.armeria.internal.ArmeriaHttpUtil;\n \n+import io.netty.buffer.ByteBuf;\n+\n /**\n  * A factory creating a {@link ContentPreviewer}.\n  */\n @FunctionalInterface\n public interface ContentPreviewerFactory {\n \n     /**\n-     * Creates a new instance of {@link ContentPreviewerFactory} which creates a {@link ContentPreviewer}\n-     * through {@code supplier} for the request/response with the {@code contentType}.\n+     * The default HTTP content-type charset.\n+     * See https://tools.ietf.org/html/rfc2616#section-3.7.1\n      */\n-    static ContentPreviewerFactory of(MediaType contentType, Supplier<? extends ContentPreviewer> supplier) {\n-        return of(ImmutableMap.of(contentType, supplier));\n+    static Charset defaultCharset() {\n+        return ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET;\n     }\n \n     /**\n-     * Creates a new instance of {@link ContentPreviewerFactory} which creates a {@link ContentPreviewer}\n-     * through {@code supplier} for the request/response with the {@code contentType}.\n+     * Returns a new {@link ContentPreviewerFactory} which creates a {@link ContentPreviewer} when the\n+     * content type of the {@link RequestHeaders} or {@link ResponseHeaders} is one of the specified\n+     * {@code contentTypes}. {@link ContentPreviewer#disabled()} otherwise.\n+     *\n+     * @param function the {@link Function} to create a {@link ContentPreviewer}. The {@link Charset} which\n+     *                 is the argument of the {@link Function} will be retrieved from\n+     *                 {@link MediaType#charset()} or {@link #defaultCharset()} if the charset parameter is\n+     *                 not specified in the {@code \"content-type\"} header.\n+     * @param contentTypes the content types\n      */\n-    static ContentPreviewerFactory of(String contentType, Supplier<? extends ContentPreviewer> supplier) {\n-        return of(MediaType.parse(contentType), supplier);\n+    static ContentPreviewerFactory of(Function<? super Charset, ? extends ContentPreviewer> function,\n+                                      MediaType... contentTypes) {\n+        return of(function, ImmutableList.copyOf(requireNonNull(contentTypes, \"contentTypes\")));\n     }\n \n     /**\n-     * Creates a new instance of {@link ContentPreviewerFactory}\n-     * which wraps a list of {@link ContentPreviewerFactory}s.\n+     * Returns a new {@link ContentPreviewerFactory} which creates a {@link ContentPreviewer} when the\n+     * content type of the {@link RequestHeaders} or {@link ResponseHeaders} is one of the specified\n+     * {@code contentTypes}. {@link ContentPreviewer#disabled()} otherwise.\n+     *\n+     * @param function the {@link Function} to create a {@link ContentPreviewer}. The {@link Charset} which\n+     *                 is the argument of the {@link Function} will be retrieved from\n+     *                 {@link MediaType#charset()} or {@link #defaultCharset()} if the charset parameter is\n+     *                 not specified in the {@code \"content-type\"} header.\n+     * @param contentTypes the content types\n      */\n-    static ContentPreviewerFactory of(ContentPreviewerFactory... factories) {\n-        return of(Arrays.asList(requireNonNull(factories, \"factories\")));\n+    static ContentPreviewerFactory of(Function<? super Charset, ? extends ContentPreviewer> function,\n+                                      String... contentTypes) {\n+        return of(function, Arrays.stream(requireNonNull(contentTypes, \"contentTypes\"))\n+                                  .map(MediaType::parse)\n+                                  .collect(toImmutableList()));\n     }\n \n     /**\n-     * Creates a new instance of {@link ContentPreviewerFactory}\n-     * which wraps a list of {@link ContentPreviewerFactory}s.\n+     * Returns a new {@link ContentPreviewerFactory} which creates a {@link ContentPreviewer} when the\n+     * content type of the {@link RequestHeaders} or {@link ResponseHeaders} is one of the specified\n+     * {@code contentTypes}. {@link ContentPreviewer#disabled()} otherwise.\n+     *\n+     * @param function the {@link Function} to create a {@link ContentPreviewer}. The {@link Charset} which\n+     *                 is the argument of the {@link Function} will be retrieved from\n+     *                 {@link MediaType#charset()} or {@link #defaultCharset()} if the charset parameter is\n+     *                 not specified in the {@code \"content-type\"} header.\n+     * @param contentTypes the content types\n      */\n-    static ContentPreviewerFactory of(Iterable<? extends ContentPreviewerFactory> factories) {\n-        requireNonNull(factories, \"factories\");\n-        final List<ContentPreviewerFactory> factoryList = new ArrayList<>();\n-        final Set<Entry<MediaType, Supplier<ContentPreviewer>>> typeSet = new LinkedHashSet<>();\n-        for (ContentPreviewerFactory factory : factories) {\n-            if (factory == disabled()) {\n-                continue;\n+    static ContentPreviewerFactory of(Function<? super Charset, ? extends ContentPreviewer> function,\n+                                      Iterable<MediaType> contentTypes) {\n+        requireNonNull(function, \"function\");\n+        final List<MediaType> candidates = ImmutableList.copyOf(requireNonNull(contentTypes, \"contentTypes\"));\n+        checkArgument(!candidates.isEmpty(), \"contentTypes is empty.\");\n+        candidates.forEach(\n+                contentType -> checkArgument(contentType != null, \"contentType should not be null.\"));\n+        return (ctx, headers) -> {\n+            final MediaType contentType = headers.contentType();\n+            if (contentType == null) {\n+                return ContentPreviewer.disabled();\n             }\n-            if (factory instanceof CompositeContentPreviewerFactory) {\n-                factoryList.addAll(((CompositeContentPreviewerFactory) factory).factoryList);\n-            } else if (factory instanceof MappedContentPreviewerFactory) {\n-                typeSet.addAll(((MappedContentPreviewerFactory) factory).entries);\n-            } else {\n-                if (!typeSet.isEmpty()) {\n-                    factoryList.add(new MappedContentPreviewerFactory(typeSet));\n-                    typeSet.clear();\n+            for (MediaType candidate : candidates) {\n+                if (contentType.is(candidate)) {\n+                    return function.apply(contentType.charset(defaultCharset()));\n                 }\n-                factoryList.add(factory);\n             }\n-        }\n-        if (!typeSet.isEmpty()) {\n-            factoryList.add(new MappedContentPreviewerFactory(typeSet));\n-        }\n-        switch (factoryList.size()) {\n-            case 0:\n-                return disabled();\n-            case 1:\n-                return factoryList.get(0);\n-            default:\n-                return new CompositeContentPreviewerFactory(factoryList);\n-        }\n-    }\n \n-    /**\n-     * Creates a new instance of {@link ContentPreviewerFactory} which creates a {@link ContentPreviewer}\n-     * through the supplier that matches with {@code \"content-type\"} header.\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    static ContentPreviewerFactory of(Map<MediaType, ? extends Supplier<? extends ContentPreviewer>> map) {\n-        return new MappedContentPreviewerFactory((Map<MediaType, Supplier<ContentPreviewer>>) map);\n+            return ContentPreviewer.disabled();\n+        };\n     }\n \n     /**\n-     * Creates a new instance of {@link ContentPreviewerFactory} which creates a {@link ContentPreviewer}\n-     * through {@code supplier} if a request/response matches any of {@code contentTypes}.\n+     * Returns a new {@link ContentPreviewerFactory} which creates a {@link ContentPreviewer} when the\n+     * content type of the {@link RequestHeaders} or {@link ResponseHeaders} is one of the {@link Map#keySet()}\n+     * in the {@link Map}. The corresponding value {@link Function} will be used to create a\n+     * {@link ContentPreviewer}. The {@link Charset} which is the argument of the {@link Function} will be\n+     * retrieved from {@link MediaType#charset()} or {@link #defaultCharset()} if the charset parameter is\n+     * not specified in the {@code \"content-type\"} header.\n      */\n-    static ContentPreviewerFactory of(Supplier<? extends ContentPreviewer> supplier,\n-                                      Iterable<MediaType> contentTypes) {\n-        requireNonNull(contentTypes, \"contentTypes\");\n-        final Map<MediaType, Supplier<? extends ContentPreviewer>> maps = new HashMap<>();\n-        for (MediaType type : contentTypes) {\n-            maps.put(type, supplier);\n-        }\n-        return of(maps);\n+    static ContentPreviewerFactory of(\n+            Map<MediaType, Function<? super Charset, ? extends ContentPreviewer>> map) {\n+        return new MappedContentPreviewerFactory(map);\n     }\n \n     /**\n-     * Creates a new instance of {@link ContentPreviewerFactory} which creates a {@link ContentPreviewer}\n-     * through {@code supplier} if a request/response matches any of {@code contentTypes}.\n+     * Returns a new {@link ContentPreviewerFactory} which creates a {@link ContentPreviewer}.\n+     * The {@link ContentPreviewer} produces the text with the {@code maxLength} limit\n+     * if the content type of the {@link RequestHeaders} or {@link ResponseHeaders} meets\n+     * any of the following conditions:\n+     * <ul>\n+     *     <li>when it matches {@code text/*} or {@code application/x-www-form-urlencoded}</li>\n+     *     <li>when its charset has been specified</li>\n+     *     <li>when its subtype is {@code \"xml\"} or {@code \"json\"}</li>\n+     *     <li>when its subtype ends with {@code \"+xml\"} or {@code \"+json\"}</li>\n+     * </ul>\n+     *\n+     * <p>Note that {@link #defaultCharset()} is used when a charset is not specified in the\n+     * {@code \"content-type\"} header.\n+     *\n+     * @param maxLength the maximum length of the preview\n      */\n-    static ContentPreviewerFactory of(Supplier<? extends ContentPreviewer> supplier,\n-                                      MediaType... contentTypes) {\n-        return of(supplier, Arrays.asList(contentTypes));\n+    static ContentPreviewerFactory ofText(int maxLength) {\n+        return ofText(maxLength, defaultCharset());\n     }\n \n     /**\n-     * Creates a new instance of {@link ContentPreviewerFactory} which creates a {@link ContentPreviewer}\n-     * through {@code supplier} if the content type of a request/response matches any of {@code contentTypes}.\n+     * Returns a new {@link ContentPreviewerFactory} which creates a {@link ContentPreviewer}.\n+     * The {@link ContentPreviewer} produces the text with the {@code maxLength} limit\n+     * if the content type of the {@link RequestHeaders} or {@link ResponseHeaders} meets\n+     * any of the following conditions:\n+     * <ul>\n+     *     <li>when it matches {@code text/*} or {@code application/x-www-form-urlencoded}</li>\n+     *     <li>when its charset has been specified</li>\n+     *     <li>when its subtype is {@code \"xml\"} or {@code \"json\"}</li>\n+     *     <li>when its subtype ends with {@code \"+xml\"} or {@code \"+json\"}</li>\n+     * </ul>\n+     *\n+     * @param maxLength the maximum length of the preview\n+     * @param defaultCharset the default charset used when a charset is not specified in the\n+     *                       {@code \"content-type\"} header\n      */\n-    static ContentPreviewerFactory of(Supplier<? extends ContentPreviewer> supplier, String... contentTypes) {\n-        return of(supplier, Arrays.stream(contentTypes).map(MediaType::parse).collect(Collectors.toList()));\n-    }\n+    static ContentPreviewerFactory ofText(int maxLength, Charset defaultCharset) {\n+        checkArgument(maxLength > 0, \"maxLength : %d (expected: > 0)\", maxLength);\n+        requireNonNull(defaultCharset, \"defaultCharset\");\n \n-    /**\n-     * Creates a new instance of {@link ContentPreviewerFactory} for creating a {@link ContentPreviewer}\n-     * which produces the text with the maximum {@code length}\n-     * if the content type of a request/response matches any of {@code contentTypes}.\n-     */\n-    static ContentPreviewerFactory ofText(int length, Charset defaultCharset,\n-                                          Iterable<MediaType> contentTypes) {\n-        checkArgument(length >= 0, \"length : %d (expected: >= 0)\", length);\n-        if (length == 0) {\n-            return disabled();\n-        }\n-        return of(() -> ContentPreviewer.ofText(length, defaultCharset), contentTypes);\n+        return new TextualContentPreviewerFactory(charset -> ContentPreviewer.ofText(maxLength, charset),\n+                                                  defaultCharset);\n     }\n \n     /**\n-     * Creates a new instance of {@link ContentPreviewerFactory} for creating a {@link ContentPreviewer}\n-     * which produces the text with the maximum {@code length}\n-     * if the content type of a request/response matches any of {@code contentTypes}.\n+     * Returns a new {@link ContentPreviewerFactory} which creates a {@link ContentPreviewer}.\n+     * The {@link ContentPreviewer} produces the text with the {@code maxLength} limit\n+     * if the content type of the {@link RequestHeaders} or {@link ResponseHeaders} is one of the specified\n+     * {@code contentTypes}.\n+     *\n+     * @param maxLength the maximum length of the preview\n+     * @param defaultCharset the default charset used when a charset is not specified in the\n+     *                       {@code \"content-type\"} header\n+     * @param contentTypes the content types\n      */\n-    static ContentPreviewerFactory ofText(int length, Charset defaultCharset, MediaType... contentTypes) {\n-        return ofText(length, defaultCharset, Arrays.asList(contentTypes));\n+    static ContentPreviewerFactory ofText(int maxLength, Charset defaultCharset, MediaType... contentTypes) {\n+        return ofText(maxLength, defaultCharset,\n+                      ImmutableList.copyOf(requireNonNull(contentTypes, \"contentTypes\")));\n     }\n \n     /**\n-     * Creates a new instance of {@link ContentPreviewerFactory} for creating a {@link ContentPreviewer}\n-     * which produces the text with the maximum {@code length} limit\n-     * if the content type of a request/response matches any of {@code contentTypes}.\n+     * Returns a new {@link ContentPreviewerFactory} which creates a {@link ContentPreviewer}.\n+     * The {@link ContentPreviewer} produces the text with the {@code maxLength} limit\n+     * if the content type of the {@link RequestHeaders} or {@link ResponseHeaders} is one of the specified\n+     * {@code contentTypes}.\n+     *\n+     * @param maxLength the maximum length of the preview\n+     * @param defaultCharset the default charset used when a charset is not specified in the\n+     *                       {@code \"content-type\"} header\n+     * @param contentTypes the content types\n      */\n-    static ContentPreviewerFactory ofText(int length, Charset defaultCharset, String... contentTypes) {\n-        return ofText(length, defaultCharset, Arrays.stream(contentTypes).map(MediaType::parse).collect(\n-                Collectors.toList()));\n+    static ContentPreviewerFactory ofText(int maxLength, Charset defaultCharset, String... contentTypes) {\n+        return ofText(maxLength, defaultCharset, Arrays.stream(requireNonNull(contentTypes, \"contentTypes\"))\n+                                                    .map(MediaType::parse)\n+                                                    .collect(toImmutableList()));\n     }\n \n     /**\n-     * Creates a new instance of {@link ContentPreviewerFactory} for creating a {@link ContentPreviewer}.\n-     * The previewer produces the text with the maximum {@code length} limit\n-     * if the content type of a request/response meets\n-     * any of the following conditions:\n-     * <ul>\n-     *     <li>when it matches {@code text/*} or {@code application/x-www-form-urlencoded}</li>\n-     *     <li>when its charset has been specified</li>\n-     *     <li>when its subtype is {@code \"xml\"} or {@code \"json\"}</li>\n-     *     <li>when its subtype ends with {@code \"+xml\"} or {@code \"+json\"}</li>\n-     * </ul>\n+     * Returns a new {@link ContentPreviewerFactory} which creates a {@link ContentPreviewer}.\n+     * The {@link ContentPreviewer} produces the text with the {@code maxLength} limit\n+     * if the content type of the {@link RequestHeaders} or {@link ResponseHeaders} is one of the specified\n+     * {@code contentTypes}.\n      *\n-     * @param length the maximum length of the preview\n+     * @param maxLength the maximum length of the preview\n      * @param defaultCharset the default charset used when a charset is not specified in the\n      *                       {@code \"content-type\"} header\n+     * @param contentTypes the content types\n      */\n-    static ContentPreviewerFactory ofText(int length, Charset defaultCharset) {\n-        if (length == 0) {\n-            return disabled();\n-        }\n-        return new TextualContentPreviewerFactory(() -> ContentPreviewer.ofText(length, defaultCharset));\n+    static ContentPreviewerFactory ofText(int maxLength, Charset defaultCharset,\n+                                          Iterable<MediaType> contentTypes) {\n+        checkArgument(maxLength > 0, \"maxLength : %d (expected: > 0)\", maxLength);\n+        requireNonNull(defaultCharset, \"defaultCharset\");\n+        final List<MediaType> candidates = ImmutableList.copyOf(requireNonNull(contentTypes, \"contentTypes\"));\n+        checkArgument(!candidates.isEmpty(), \"contentTypes is empty.\");\n+        candidates.forEach(\n+                contentType -> checkArgument(contentType != null, \"contentType should not be null.\"));\n+\n+        return (ctx, headers) -> {\n+            final MediaType contentType = headers.contentType();\n+            if (contentType != null) {\n+                for (MediaType candidate : candidates) {\n+                    if (contentType.is(candidate)) {\n+                        return ContentPreviewer.ofText(maxLength, contentType.charset(defaultCharset));\n+                    }\n+                }\n+            }\n+            return ContentPreviewer.disabled();\n+        };\n     }\n \n     /**\n-     * Creates a new instance of {@link ContentPreviewerFactory} for creating a {@link ContentPreviewer}.\n-     * The previewer produces the text with the maximum {@code length} limit\n-     * if the content type of a request/response meets\n-     * any of the following conditions:\n-     * <ul>\n-     *     <li>when it matches {@code text/*} or {@code application/x-www-form-urlencoded}</li>\n-     *     <li>when its charset has been specified</li>\n-     *     <li>when its subtype is {@code \"xml\"} or {@code \"json\"}</li>\n-     *     <li>when its subtype ends with {@code \"+xml\"} or {@code \"+json\"}</li>\n-     * </ul>\n-     * @param length the maximum length of the preview.\n+     * Returns a new {@link ContentPreviewerFactory} which creates a {@link ContentPreviewer} using the\n+     * specified {@link Function}.\n+     *\n+     * @param maxLength the maximum length of the preview\n+     * @param producer the {@link Function} to produce the preview\n      */\n-    static ContentPreviewerFactory ofText(int length) {\n-        return ofText(length, ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET);\n+    static ContentPreviewerFactory ofBinary(int maxLength, Function<? super ByteBuf, String> producer) {\n+        requireNonNull(producer, \"producer\");\n+        return ofBinary(maxLength, (headers, byteBuf) -> producer.apply(byteBuf));\n     }\n \n     /**\n-     * A dummy {@link ContentPreviewerFactory} which returns {@link ContentPreviewer#disabled()}.\n+     * Returns a new {@link ContentPreviewerFactory} which creates a {@link ContentPreviewer} using the\n+     * specified {@link Function}.\n+     *\n+     * @param maxLength the maximum length of the preview\n+     * @param producer the {@link Function} to produce the preview\n      */\n-    static ContentPreviewerFactory disabled() {\n-        return NoopContentPreviewerFactory.INSTANCE;\n+    static ContentPreviewerFactory ofBinary(int maxLength,\n+                                            BiFunction<? super HttpHeaders, ? super ByteBuf, String> producer) {\n+        checkArgument(maxLength > 0, \"maxLength : %d (expected: > 0)\", maxLength);\n+        requireNonNull(producer, \"producer\");\n+        return (ctx, headers) -> ContentPreviewer.ofBinary(maxLength, producer, headers);\n     }\n \n     /**\n-     * Returns a {@link ContentPreviewer}, given {@link RequestContext} and {@link HttpHeaders}.\n+     * Returns a newly-created {@link ContentPreviewer} with the given {@link RequestContext} and\n+     * {@link HttpHeaders}. Note that the returned {@link ContentPreviewer} can be\n+     * {@link ContentPreviewer#disabled()}.\n      */\n     ContentPreviewer get(RequestContext ctx, HttpHeaders headers);", "originalCommit": "074732a9b46a05b46fc8466a399da18d8fb5bd20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1MjQ4OA==", "url": "https://github.com/line/armeria/pull/2444#discussion_r374052488", "bodyText": "That's a good idea. I need more refactoring. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-02-03T11:30:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA0ODkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA3NjI2MA==", "url": "https://github.com/line/armeria/pull/2444#discussion_r374076260", "bodyText": "I think if length is less than httpData.array() size, the aggregatedLength will hold a wrong value.\nFor example:\n// before\nbufferListLength = 95\nmaxLength = 100\naggregatedLength = 95\n\n// after\ndata.length = 10\nlength = 5\nnewAggregatedLength = 100\nbufferListLength = 105", "author": "ikhoon", "createdAt": "2020-02-03T12:31:20Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/AbstractContentPreviewer.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.logging;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.math.IntMath;\n+\n+import com.linecorp.armeria.common.HttpData;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufHolder;\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.ReferenceCountUtil;\n+\n+abstract class AbstractContentPreviewer implements ContentPreviewer {\n+\n+    private static final ByteBuf[] BYTE_BUFS = new ByteBuf[0];\n+\n+    private final List<ByteBuf> bufferList = new ArrayList<>();\n+    private final int maxLength;\n+\n+    @Nullable\n+    private String produced;\n+    private int aggregatedLength;\n+\n+    AbstractContentPreviewer(int maxLength) {\n+        this.maxLength = maxLength;\n+    }\n+\n+    @Override\n+    public void onData(HttpData data) {\n+        requireNonNull(data, \"data\");\n+        if (data.isEmpty()) {\n+            return;\n+        }\n+        final int length = Math.min(maxLength - aggregatedLength, data.length());\n+        bufferList.add(duplicateData(data, length));\n+\n+        aggregatedLength = IntMath.saturatedAdd(aggregatedLength, length);\n+        if (aggregatedLength >= maxLength || data.isEndOfStream()) {\n+            produce();\n+        }\n+    }\n+\n+    private static ByteBuf duplicateData(HttpData httpData, int length) {\n+        if (httpData instanceof ByteBufHolder) {\n+            final ByteBuf content = ((ByteBufHolder) httpData).content();\n+            if (content.readableBytes() == length) {\n+                // No need to slice.\n+                return content.retainedDuplicate();\n+            }\n+            return content.retainedSlice(content.readerIndex(), length);\n+        } else {\n+            return Unpooled.wrappedBuffer(httpData.array());", "originalCommit": "074732a9b46a05b46fc8466a399da18d8fb5bd20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDEyNzU0NA==", "url": "https://github.com/line/armeria/pull/2444#discussion_r374127544", "bodyText": "Thanks! Just copied it without much thinking \ud83d\ude05.", "author": "minwoox", "createdAt": "2020-02-03T14:20:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA3NjI2MA=="}], "type": "inlineReview"}, {"oid": "67c6ec19579ae4c7a32cd295c7d4e86540ec5134", "url": "https://github.com/line/armeria/commit/67c6ec19579ae4c7a32cd295c7d4e86540ec5134", "message": "WIP", "committedDate": "2020-02-05T07:56:52Z", "type": "commit"}, {"oid": "4893a21df4d7014f8c6cbc4c778f253354369858", "url": "https://github.com/line/armeria/commit/4893a21df4d7014f8c6cbc4c778f253354369858", "message": "Merge branch 'master' into revamp_contentPreviewer", "committedDate": "2020-02-05T08:04:20Z", "type": "commit"}, {"oid": "dbb25a5efc63bfe6a8b61e7b7ab408df53803fab", "url": "https://github.com/line/armeria/commit/dbb25a5efc63bfe6a8b61e7b7ab408df53803fab", "message": "Address comments by @trustin", "committedDate": "2020-02-05T13:20:43Z", "type": "commit"}, {"oid": "78962ae963997d9cfca3ec4615cee3319abff3ca", "url": "https://github.com/line/armeria/commit/78962ae963997d9cfca3ec4615cee3319abff3ca", "message": "Add Javadoc", "committedDate": "2020-02-05T13:28:19Z", "type": "commit"}, {"oid": "3bb7e10b46deb83ba172b1602530952dad1001a9", "url": "https://github.com/line/armeria/commit/3bb7e10b46deb83ba172b1602530952dad1001a9", "message": "Use Bipredicate", "committedDate": "2020-02-06T02:01:04Z", "type": "commit"}, {"oid": "fc2e202dd429868233081b1857bc60e768b630b7", "url": "https://github.com/line/armeria/commit/fc2e202dd429868233081b1857bc60e768b630b7", "message": "Update rst", "committedDate": "2020-02-06T03:35:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYyNzc3Mg==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375627772", "bodyText": "Could be private?", "author": "trustin", "createdAt": "2020-02-06T03:45:25Z", "path": "core/src/main/java/com/linecorp/armeria/client/logging/ContentPreviewingClient.java", "diffHunk": "@@ -49,48 +54,72 @@\n public final class ContentPreviewingClient extends SimpleDecoratingHttpClient {\n \n     /**\n-     * Returns a newly created {@link ContentPreviewingClientBuilder}.\n+     * Creates a new {@link ContentPreviewingClient} decorator which produces text preview with the\n+     * specified {@code maxLength} limit. The preview is produced when the content type of the\n+     * {@link RequestHeaders} or {@link ResponseHeaders} meets any of the following conditions:\n+     * <ul>\n+     *     <li>when it matches {@code text/*} or {@code application/x-www-form-urlencoded}</li>\n+     *     <li>when its charset has been specified</li>\n+     *     <li>when its subtype is {@code \"xml\"} or {@code \"json\"}</li>\n+     *     <li>when its subtype ends with {@code \"+xml\"} or {@code \"+json\"}</li>\n+     * </ul>\n+     *\n+     * @param maxLength the maximum length of the preview\n+     */\n+    public static Function<? super HttpClient, ContentPreviewingClient> newDecorator(int maxLength) {\n+        final ContentPreviewerFactory factory = ContentPreviewerFactory.text(maxLength);\n+        return delegate -> new ContentPreviewingClient(delegate, factory);\n+    }\n+\n+    /**\n+     * Creates a new {@link ContentPreviewingClient} decorator which produces text preview with the\n+     * specified {@code maxLength} limit. The preview is produced when the content type of the\n+     * {@link RequestHeaders} or {@link ResponseHeaders} meets any of the following conditions:\n+     * <ul>\n+     *     <li>when it matches {@code text/*} or {@code application/x-www-form-urlencoded}</li>\n+     *     <li>when its charset has been specified</li>\n+     *     <li>when its subtype is {@code \"xml\"} or {@code \"json\"}</li>\n+     *     <li>when its subtype ends with {@code \"+xml\"} or {@code \"+json\"}</li>\n+     * </ul>\n+     *\n+     * @param maxLength the maximum length of the preview\n+     * @param defaultCharset the default charset used when a charset is not specified in the\n+     *                       {@code \"content-type\"} header\n      */\n-    public static ContentPreviewingClientBuilder builder() {\n-        return new ContentPreviewingClientBuilder();\n+    public static Function<? super HttpClient, ContentPreviewingClient> newDecorator(\n+            int maxLength, Charset defaultCharset) {\n+        final ContentPreviewerFactory factory = ContentPreviewerFactory.text(maxLength, defaultCharset);\n+        return delegate -> new ContentPreviewingClient(delegate, factory);\n     }\n \n     /**\n      * Creates a new {@link ContentPreviewingClient} decorator with the specified\n-     * {@code requestContentPreviewerFactory} and {@code responseContentPreviewerFactory}.\n+     * {@link ContentPreviewerFactory}.\n      */\n     public static Function<? super HttpClient, ContentPreviewingClient> newDecorator(\n-            ContentPreviewerFactory requestContentPreviewerFactory,\n-            ContentPreviewerFactory responseContentPreviewerFactory) {\n-        return builder().requestContentPreviewerFactory(requestContentPreviewerFactory)\n-                        .responseContentPreviewerFactory(responseContentPreviewerFactory)\n-                        .newDecorator();\n+            ContentPreviewerFactory contentPreviewerFactory) {\n+        requireNonNull(contentPreviewerFactory, \"contentPreviewerFactory\");\n+        return delegate -> new ContentPreviewingClient(delegate, contentPreviewerFactory);\n     }\n \n-    @Nullable\n-    private final ContentPreviewerFactory responseContentPreviewerFactory;\n-    private final ContentPreviewerConfigurator configurator;\n+    private final ContentPreviewerFactory contentPreviewerFactory;\n \n     /**\n      * Creates a new instance that decorates the specified {@link HttpClient}.\n      */\n-    ContentPreviewingClient(HttpClient delegate,\n-                            @Nullable ContentPreviewerFactory requestContentPreviewerFactory,\n-                            @Nullable ContentPreviewerFactory responseContentPreviewerFactory) {\n+    ContentPreviewingClient(HttpClient delegate, ContentPreviewerFactory contentPreviewerFactory) {", "originalCommit": "fc2e202dd429868233081b1857bc60e768b630b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY0NzA2MA==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375647060", "bodyText": "Ah yes. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-02-06T05:30:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYyNzc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYyNzk3OA==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375627978", "bodyText": "Better calling the constructor directly after copyOf(), given of() calls copyOf() again?", "author": "trustin", "createdAt": "2020-02-06T03:46:21Z", "path": "core/src/main/java/com/linecorp/armeria/common/MediaTypeSet.java", "diffHunk": "@@ -60,16 +60,36 @@\n \n     private final MediaType[] mediaTypes;\n \n+    /**\n+     * Returns the {@link MediaTypeSet} which is composed of the specified {@link MediaType}s.\n+     */\n+    public static MediaTypeSet of(MediaType... mediaTypes) {\n+        return of(ImmutableList.copyOf(requireNonNull(mediaTypes, \"mediaTypes\")));", "originalCommit": "fc2e202dd429868233081b1857bc60e768b630b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY0NzE2Mg==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375647162", "bodyText": "Yes, we should.", "author": "minwoox", "createdAt": "2020-02-06T05:31:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYyNzk3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYyODIxNw==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375628217", "bodyText": "nit: ImmutableList.Builder", "author": "trustin", "createdAt": "2020-02-06T03:47:44Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ContentPreviewerFactoryBuilder.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.MediaTypeSet;\n+import com.linecorp.armeria.common.RequestContext;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.logging.PreviewSpec.PreviewMode;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+\n+/**\n+ * A builder which builds a {@link ContentPreviewerFactory}.\n+ */\n+public final class ContentPreviewerFactoryBuilder {\n+\n+    //TODO(minwoox): Add setters for the seprate request and response previewer.\n+\n+    private final Builder<PreviewSpec> previewSpecsBuilder = ImmutableList.builder();", "originalCommit": "fc2e202dd429868233081b1857bc60e768b630b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY0NzI3NQ==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375647275", "bodyText": "Fixed!", "author": "minwoox", "createdAt": "2020-02-06T05:31:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYyODIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYyODkyMw==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375628923", "bodyText": "private?", "author": "trustin", "createdAt": "2020-02-06T03:51:28Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ContentPreviewerFactoryBuilder.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.MediaTypeSet;\n+import com.linecorp.armeria.common.RequestContext;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.logging.PreviewSpec.PreviewMode;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+\n+/**\n+ * A builder which builds a {@link ContentPreviewerFactory}.\n+ */\n+public final class ContentPreviewerFactoryBuilder {\n+\n+    //TODO(minwoox): Add setters for the seprate request and response previewer.\n+\n+    private final Builder<PreviewSpec> previewSpecsBuilder = ImmutableList.builder();\n+    private int maxLength;\n+    private Charset defaultCharset = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET;\n+\n+    ContentPreviewerFactoryBuilder() {}\n+\n+    /**\n+     * Sets the maximum length of the produced preview.\n+     */\n+    public ContentPreviewerFactoryBuilder maxLength(int maxLength) {\n+        checkArgument(maxLength > 0, \"maxLength : %d (expected: > 0)\", maxLength);\n+        this.maxLength = maxLength;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the default {@link Charset} used to produce the text preview when a charset is not specified in the\n+     * {@code \"content-type\"} header.\n+     *\n+     * <p>Note that this charset is only for the text preview, not for the binary preview.</p>\n+     */\n+    public ContentPreviewerFactoryBuilder defaultCharset(Charset defaultCharset) {\n+        this.defaultCharset = requireNonNull(defaultCharset, \"defaultCharset\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@link MediaTypeSet} to produce the text preview when the content type of the\n+     * {@link RequestHeaders} or {@link ResponseHeaders} {@linkplain MediaTypeSet#match(MediaType) matches}\n+     * the {@link MediaTypeSet}.\n+     */\n+    public ContentPreviewerFactoryBuilder text(MediaTypeSet mediaTypeSet) {\n+        text0(previewerPredicate(mediaTypeSet), null);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@link MediaTypeSet} to produce the text preview when the content type of the\n+     * {@link RequestHeaders} or {@link ResponseHeaders} {@linkplain MediaTypeSet#match(MediaType) matches}\n+     * the {@link MediaTypeSet}.\n+     *\n+     * @param defaultCharset the default charset used when a charset is not specified in the\n+     *                       {@code \"content-type\"} header\n+     */\n+    public ContentPreviewerFactoryBuilder text(MediaTypeSet mediaTypeSet, Charset defaultCharset) {\n+        return text(previewerPredicate(mediaTypeSet), defaultCharset);\n+    }\n+\n+    /**\n+     * Sets the specified {@link BiPredicate} to produce the text preview when the predicate\n+     * returns {@code true}.\n+     */\n+    public ContentPreviewerFactoryBuilder text(\n+            BiPredicate<? super RequestContext, ? super HttpHeaders> predicate) {\n+        return text0(predicate, null);\n+    }\n+\n+    /**\n+     * Sets the specified {@link BiPredicate} to produce the text preview when the predicate\n+     * returns {@code true}.\n+     *\n+     * @param defaultCharset the default charset used when a charset is not specified in the\n+     *                       {@code \"content-type\"} header\n+     */\n+    public ContentPreviewerFactoryBuilder text(\n+            BiPredicate<? super RequestContext, ? super HttpHeaders> predicate, Charset defaultCharset) {\n+        requireNonNull(defaultCharset, \"defaultCharset\");\n+        return text0(predicate, defaultCharset);\n+    }\n+\n+    private ContentPreviewerFactoryBuilder text0(\n+            BiPredicate<? super RequestContext, ? super HttpHeaders> predicate,\n+            @Nullable Charset defaultCharset) {\n+        requireNonNull(predicate, \"predicate\");\n+        previewSpecsBuilder.add(new PreviewSpec(predicate, PreviewMode.TEXT, defaultCharset, null));\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@link MediaTypeSet} to produce the\n+     * <a href=\"http://en.wikipedia.org/wiki/Hex_dump\">hex dump</a> preview when the content type of the\n+     * {@link RequestHeaders} or {@link ResponseHeaders} {@linkplain MediaTypeSet#match(MediaType) matches}\n+     * the {@link MediaTypeSet}.\n+     */\n+    public ContentPreviewerFactoryBuilder binary(MediaTypeSet mediaTypeSet) {\n+        binary(mediaTypeSet, hexDumpProducer());\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@link MediaTypeSet} to produce the preview using the specified {@link BiFunction}\n+     * when the content type of the {@link RequestHeaders} or {@link ResponseHeaders}\n+     * {@linkplain MediaTypeSet#match(MediaType) matches} the {@link MediaTypeSet}.\n+     */\n+    public ContentPreviewerFactoryBuilder binary(\n+            MediaTypeSet mediaTypeSet, BiFunction<? super HttpHeaders, ? super ByteBuf, String> producer) {\n+        requireNonNull(mediaTypeSet, \"mediaTypesSet\");\n+        return binary(previewerPredicate(mediaTypeSet), producer);\n+    }\n+\n+    /**\n+     * Sets the specified {@link BiPredicate} to produce the\n+     * <a href=\"http://en.wikipedia.org/wiki/Hex_dump\">hex dump</a> preview when the predicate\n+     * returns {@code true}.\n+     */\n+    public ContentPreviewerFactoryBuilder binary(\n+            BiPredicate<? super RequestContext, ? super HttpHeaders> predicate) {\n+        return binary(predicate, hexDumpProducer());\n+    }\n+\n+    /**\n+     * Sets the specified {@link BiPredicate} to produce the preview using the specified\n+     * {@link BiFunction} when the predicate returns {@code true}.\n+     */\n+    public ContentPreviewerFactoryBuilder binary(\n+            BiPredicate<? super RequestContext, ? super HttpHeaders> predicate,\n+            BiFunction<? super HttpHeaders, ? super ByteBuf, String> producer) {\n+        requireNonNull(predicate, \"predicate\");\n+        requireNonNull(producer, \"producer\");\n+        previewSpecsBuilder.add(new PreviewSpec(predicate, PreviewMode.BINARY, null, producer));\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@link MediaTypeSet} <b>NOT</b> to produce the preview when the content type of the\n+     * {@link RequestHeaders} or {@link ResponseHeaders} {@linkplain MediaTypeSet#match(MediaType) matches}\n+     * the {@link MediaTypeSet}.\n+     */\n+    public ContentPreviewerFactoryBuilder disable(MediaTypeSet mediaTypeSet) {\n+        requireNonNull(mediaTypeSet, \"mediaTypesSet\");\n+        return disable(previewerPredicate(mediaTypeSet));\n+    }\n+\n+    /**\n+     * Sets the specified {@link BiPredicate} <b>NOT</b> to produce the preview when the predicate\n+     * returns {@code true}.\n+     */\n+    public ContentPreviewerFactoryBuilder disable(\n+            BiPredicate<? super RequestContext, ? super HttpHeaders> predicate) {\n+        requireNonNull(predicate, \"predicate\");\n+        previewSpecsBuilder.add(new PreviewSpec(predicate, PreviewMode.DISABLED, null, null));\n+        return this;\n+    }\n+\n+    /**\n+     * Returns a newly-created {@link ContentPreviewerFactory} based on the properties of this builder.\n+     */\n+    public ContentPreviewerFactory build() {\n+        return new DefaultContentPreviewFactory(previewSpecsBuilder.build(), maxLength, defaultCharset);\n+    }\n+\n+    private static BiPredicate<? super RequestContext, ? super HttpHeaders> previewerPredicate(\n+            MediaTypeSet mediaTypeSet) {\n+        requireNonNull(mediaTypeSet, \"mediaTypesSet\");\n+        return (ctx, headers) -> {\n+            final MediaType contentType = headers.contentType();\n+            if (contentType == null) {\n+                return false;\n+            }\n+            return mediaTypeSet.match(contentType) != null;\n+        };\n+    }\n+\n+    static BiFunction<? super HttpHeaders, ? super ByteBuf, String> hexDumpProducer() {", "originalCommit": "fc2e202dd429868233081b1857bc60e768b630b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY0NzMzNg==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375647336", "bodyText": "Added @VisibleForTesting", "author": "minwoox", "createdAt": "2020-02-06T05:32:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYyODkyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYyOTE3OA==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375629178", "bodyText": "How about accepting MediaType... and Iterable<MediaType>? MediaTypeSet is Iterable<MediaType>, so the two methods will cover MediaTypeSet as well.", "author": "trustin", "createdAt": "2020-02-06T03:52:49Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ContentPreviewerFactoryBuilder.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.MediaTypeSet;\n+import com.linecorp.armeria.common.RequestContext;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.logging.PreviewSpec.PreviewMode;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+\n+/**\n+ * A builder which builds a {@link ContentPreviewerFactory}.\n+ */\n+public final class ContentPreviewerFactoryBuilder {\n+\n+    //TODO(minwoox): Add setters for the seprate request and response previewer.\n+\n+    private final Builder<PreviewSpec> previewSpecsBuilder = ImmutableList.builder();\n+    private int maxLength;\n+    private Charset defaultCharset = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET;\n+\n+    ContentPreviewerFactoryBuilder() {}\n+\n+    /**\n+     * Sets the maximum length of the produced preview.\n+     */\n+    public ContentPreviewerFactoryBuilder maxLength(int maxLength) {\n+        checkArgument(maxLength > 0, \"maxLength : %d (expected: > 0)\", maxLength);\n+        this.maxLength = maxLength;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the default {@link Charset} used to produce the text preview when a charset is not specified in the\n+     * {@code \"content-type\"} header.\n+     *\n+     * <p>Note that this charset is only for the text preview, not for the binary preview.</p>\n+     */\n+    public ContentPreviewerFactoryBuilder defaultCharset(Charset defaultCharset) {\n+        this.defaultCharset = requireNonNull(defaultCharset, \"defaultCharset\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@link MediaTypeSet} to produce the text preview when the content type of the\n+     * {@link RequestHeaders} or {@link ResponseHeaders} {@linkplain MediaTypeSet#match(MediaType) matches}\n+     * the {@link MediaTypeSet}.\n+     */\n+    public ContentPreviewerFactoryBuilder text(MediaTypeSet mediaTypeSet) {", "originalCommit": "fc2e202dd429868233081b1857bc60e768b630b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYzMTgwMQ==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375631801", "bodyText": "I was a little bit worried because it will make this builder have as twice methods.\nBut it seems not a big deal so let me make a change for that. Thanks!", "author": "minwoox", "createdAt": "2020-02-06T04:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYyOTE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYyOTgxNQ==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375629815", "bodyText": "How about checking if mediaTypes is already a MediaTypeSet?", "author": "trustin", "createdAt": "2020-02-06T03:56:03Z", "path": "core/src/main/java/com/linecorp/armeria/common/MediaTypeSet.java", "diffHunk": "@@ -60,16 +60,36 @@\n \n     private final MediaType[] mediaTypes;\n \n+    /**\n+     * Returns the {@link MediaTypeSet} which is composed of the specified {@link MediaType}s.\n+     */\n+    public static MediaTypeSet of(MediaType... mediaTypes) {\n+        return of(ImmutableList.copyOf(requireNonNull(mediaTypes, \"mediaTypes\")));\n+    }\n+\n+    /**\n+     * Returns the {@link MediaTypeSet} which is composed of the specified {@link MediaType}s.\n+     */\n+    public static MediaTypeSet of(Iterable<MediaType> mediaTypes) {\n+        return new MediaTypeSet(ImmutableList.copyOf(requireNonNull(mediaTypes, \"mediaTypes\")));", "originalCommit": "fc2e202dd429868233081b1857bc60e768b630b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY0NzIwNA==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375647204", "bodyText": "That's good idea!", "author": "minwoox", "createdAt": "2020-02-06T05:31:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYyOTgxNQ=="}], "type": "inlineReview"}, {"oid": "9cca17a7d0a18039c2adea0286d97f3d262c2501", "url": "https://github.com/line/armeria/commit/9cca17a7d0a18039c2adea0286d97f3d262c2501", "message": "Address comments by @trustin", "committedDate": "2020-02-06T05:33:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1MzQyMQ==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375653421", "bodyText": "How about keep accepting MediaTypeSet? The callers of this method could create a MediaTypeSet from the given MediaTypes.", "author": "trustin", "createdAt": "2020-02-06T06:00:42Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ContentPreviewerFactoryBuilder.java", "diffHunk": "@@ -199,17 +240,17 @@ public ContentPreviewerFactory build() {\n     }\n \n     private static BiPredicate<? super RequestContext, ? super HttpHeaders> previewerPredicate(\n-            MediaTypeSet mediaTypeSet) {\n-        requireNonNull(mediaTypeSet, \"mediaTypesSet\");\n+            Iterable<MediaType> meidaTypes) {\n         return (ctx, headers) -> {\n             final MediaType contentType = headers.contentType();\n             if (contentType == null) {\n                 return false;\n             }\n-            return mediaTypeSet.match(contentType) != null;\n+            return Streams.stream(meidaTypes).anyMatch(contentType::belongsTo);\n         };\n     }", "originalCommit": "9cca17a7d0a18039c2adea0286d97f3d262c2501", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1MTM5MA==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375651390", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Iterable<MediaType> meidaTypes) {\n          \n          \n            \n                        Iterable<MediaType> mediaTypes) {", "author": "anuraaga", "createdAt": "2020-02-06T05:51:18Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ContentPreviewerFactoryBuilder.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestContext;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.logging.PreviewSpec.PreviewMode;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+\n+/**\n+ * A builder which builds a {@link ContentPreviewerFactory}.\n+ */\n+public final class ContentPreviewerFactoryBuilder {\n+\n+    //TODO(minwoox): Add setters for the seprate request and response previewer.\n+\n+    private final ImmutableList.Builder<PreviewSpec> previewSpecsBuilder = ImmutableList.builder();\n+    private int maxLength;\n+    private Charset defaultCharset = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET;\n+\n+    ContentPreviewerFactoryBuilder() {}\n+\n+    /**\n+     * Sets the maximum length of the produced preview.\n+     */\n+    public ContentPreviewerFactoryBuilder maxLength(int maxLength) {\n+        checkArgument(maxLength > 0, \"maxLength : %d (expected: > 0)\", maxLength);\n+        this.maxLength = maxLength;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the default {@link Charset} used to produce the text preview when a charset is not specified in the\n+     * {@code \"content-type\"} header.\n+     *\n+     * <p>Note that this charset is only for the text preview, not for the binary preview.</p>\n+     */\n+    public ContentPreviewerFactoryBuilder defaultCharset(Charset defaultCharset) {\n+        this.defaultCharset = requireNonNull(defaultCharset, \"defaultCharset\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@link MediaType}s to produce the text preview when the content type of the\n+     * {@link RequestHeaders} or {@link ResponseHeaders} is one of the {@link MediaType}s.\n+     */\n+    public ContentPreviewerFactoryBuilder text(MediaType... mediaTypes) {\n+        return text(ImmutableList.copyOf(requireNonNull(mediaTypes, \"mediaTypes\")));\n+    }\n+\n+    /**\n+     * Sets the specified {@link MediaType}s to produce the text preview when the content type of the\n+     * {@link RequestHeaders} or {@link ResponseHeaders} is one of the {@link MediaType}s.\n+     */\n+    public ContentPreviewerFactoryBuilder text(Iterable<MediaType> mediaTypes) {\n+        text0(null, previewerPredicate(mediaTypes));\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@link MediaType}s to produce the text preview when the content type of the\n+     * {@link RequestHeaders} or {@link ResponseHeaders} is one of the {@link MediaType}s.\n+     *\n+     * @param defaultCharset the default charset used when a charset is not specified in the\n+     *                       {@code \"content-type\"} header\n+     */\n+    public ContentPreviewerFactoryBuilder text(Charset defaultCharset, MediaType... mediaTypes) {\n+        return text(defaultCharset, ImmutableList.copyOf(requireNonNull(mediaTypes, \"mediaTypes\")));\n+    }\n+\n+    /**\n+     * Sets the specified {@link MediaType}s to produce the text preview when the content type of the\n+     * {@link RequestHeaders} or {@link ResponseHeaders} is one of the {@link MediaType}s.\n+     *\n+     * @param defaultCharset the default charset used when a charset is not specified in the\n+     *                       {@code \"content-type\"} header\n+     */\n+    public ContentPreviewerFactoryBuilder text(Charset defaultCharset, Iterable<MediaType> mediaTypes) {\n+        return text(defaultCharset, previewerPredicate(mediaTypes));\n+    }\n+\n+    /**\n+     * Sets the specified {@link BiPredicate} to produce the text preview when the predicate\n+     * returns {@code true}.\n+     */\n+    public ContentPreviewerFactoryBuilder text(\n+            BiPredicate<? super RequestContext, ? super HttpHeaders> predicate) {\n+        return text0(null, predicate);\n+    }\n+\n+    /**\n+     * Sets the specified {@link BiPredicate} to produce the text preview when the predicate\n+     * returns {@code true}.\n+     *\n+     * @param defaultCharset the default charset used when a charset is not specified in the\n+     *                       {@code \"content-type\"} header\n+     */\n+    public ContentPreviewerFactoryBuilder text(\n+            Charset defaultCharset, BiPredicate<? super RequestContext, ? super HttpHeaders> predicate) {\n+        requireNonNull(defaultCharset, \"defaultCharset\");\n+        return text0(defaultCharset, predicate);\n+    }\n+\n+    private ContentPreviewerFactoryBuilder text0(\n+            @Nullable Charset defaultCharset,\n+            BiPredicate<? super RequestContext, ? super HttpHeaders> predicate) {\n+        requireNonNull(predicate, \"predicate\");\n+        previewSpecsBuilder.add(new PreviewSpec(predicate, PreviewMode.TEXT, defaultCharset, null));\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@link MediaType}s to produce the\n+     * <a href=\"http://en.wikipedia.org/wiki/Hex_dump\">hex dump</a> preview when the content type of the\n+     * {@link RequestHeaders} or {@link ResponseHeaders} is one of the {@link MediaType}s.\n+     */\n+    public ContentPreviewerFactoryBuilder binary(MediaType... mediaTypes) {\n+        return binary(ImmutableList.copyOf(requireNonNull(mediaTypes, \"mediaTypes\")));\n+    }\n+\n+    /**\n+     * Sets the specified {@link MediaType}s to produce the\n+     * <a href=\"http://en.wikipedia.org/wiki/Hex_dump\">hex dump</a> preview when the content type of the\n+     * {@link RequestHeaders} or {@link ResponseHeaders} is one of the {@link MediaType}s.\n+     */\n+    public ContentPreviewerFactoryBuilder binary(Iterable<MediaType> mediaTypes) {\n+        binary(hexDumpProducer(), mediaTypes);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@link MediaType}s to produce the preview using the specified {@link BiFunction}\n+     * when the content type of the {@link RequestHeaders} or {@link ResponseHeaders} is one of the\n+     * {@link MediaType}s.\n+     */\n+    public ContentPreviewerFactoryBuilder binary(\n+            BiFunction<? super HttpHeaders, ? super ByteBuf, String> producer, MediaType... mediaTypes) {\n+        return binary(producer, ImmutableList.copyOf(requireNonNull(mediaTypes, \"mediaTypes\")));\n+    }\n+\n+    /**\n+     * Sets the specified {@link MediaType}s to produce the preview using the specified {@link BiFunction}\n+     * when the content type of the {@link RequestHeaders} or {@link ResponseHeaders} is one of the\n+     * {@link MediaType}s.\n+     */\n+    public ContentPreviewerFactoryBuilder binary(\n+            BiFunction<? super HttpHeaders, ? super ByteBuf, String> producer, Iterable<MediaType> mediaTypes) {\n+        return binary(producer,\n+                      previewerPredicate(ImmutableList.copyOf(requireNonNull(mediaTypes, \"mediaTypes\"))));\n+    }\n+\n+    /**\n+     * Sets the specified {@link BiPredicate} to produce the\n+     * <a href=\"http://en.wikipedia.org/wiki/Hex_dump\">hex dump</a> preview when the predicate\n+     * returns {@code true}.\n+     */\n+    public ContentPreviewerFactoryBuilder binary(\n+            BiPredicate<? super RequestContext, ? super HttpHeaders> predicate) {\n+        return binary(hexDumpProducer(), predicate);\n+    }\n+\n+    /**\n+     * Sets the specified {@link BiPredicate} to produce the preview using the specified\n+     * {@link BiFunction} when the predicate returns {@code true}.\n+     */\n+    public ContentPreviewerFactoryBuilder binary(\n+            BiFunction<? super HttpHeaders, ? super ByteBuf, String> producer,\n+            BiPredicate<? super RequestContext, ? super HttpHeaders> predicate) {\n+        requireNonNull(predicate, \"predicate\");\n+        requireNonNull(producer, \"producer\");\n+        previewSpecsBuilder.add(new PreviewSpec(predicate, PreviewMode.BINARY, null, producer));\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@link MediaType}s <b>NOT</b> to produce the preview when the content type of the\n+     * {@link RequestHeaders} or {@link ResponseHeaders} is one of the {@link MediaType}s\n+     */\n+    public ContentPreviewerFactoryBuilder disable(MediaType... mediaTypes) {\n+        return disable(ImmutableList.copyOf(requireNonNull(mediaTypes, \"mediaTypes\")));\n+    }\n+\n+    /**\n+     * Sets the specified {@link MediaType}s <b>NOT</b> to produce the preview when the content type of the\n+     * {@link RequestHeaders} or {@link ResponseHeaders} is one of the {@link MediaType}s\n+     */\n+    public ContentPreviewerFactoryBuilder disable(Iterable<MediaType> mediaTypes) {\n+        return disable(previewerPredicate(ImmutableList.copyOf(requireNonNull(mediaTypes, \"mediaTypes\"))));\n+    }\n+\n+    /**\n+     * Sets the specified {@link BiPredicate} <b>NOT</b> to produce the preview when the predicate\n+     * returns {@code true}.\n+     */\n+    public ContentPreviewerFactoryBuilder disable(\n+            BiPredicate<? super RequestContext, ? super HttpHeaders> predicate) {\n+        requireNonNull(predicate, \"predicate\");\n+        previewSpecsBuilder.add(new PreviewSpec(predicate, PreviewMode.DISABLED, null, null));\n+        return this;\n+    }\n+\n+    /**\n+     * Returns a newly-created {@link ContentPreviewerFactory} based on the properties of this builder.\n+     */\n+    public ContentPreviewerFactory build() {\n+        return new DefaultContentPreviewFactory(previewSpecsBuilder.build(), maxLength, defaultCharset);\n+    }\n+\n+    private static BiPredicate<? super RequestContext, ? super HttpHeaders> previewerPredicate(\n+            Iterable<MediaType> meidaTypes) {", "originalCommit": "9cca17a7d0a18039c2adea0286d97f3d262c2501", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1NDUzNA==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375654534", "bodyText": "I think we either need to\n\nchange this to UTF_8\nHave a special case for JSON which only supports UTF-8 and is extremely common\n\nI lean towards the former, I think users will have more gotchas with a default matching the ancient HTTP standard vs common practice nowadays, UTF-8 for everything.", "author": "anuraaga", "createdAt": "2020-02-06T06:06:09Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ContentPreviewerFactoryBuilder.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestContext;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.logging.PreviewSpec.PreviewMode;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+\n+/**\n+ * A builder which builds a {@link ContentPreviewerFactory}.\n+ */\n+public final class ContentPreviewerFactoryBuilder {\n+\n+    //TODO(minwoox): Add setters for the seprate request and response previewer.\n+\n+    private final ImmutableList.Builder<PreviewSpec> previewSpecsBuilder = ImmutableList.builder();\n+    private int maxLength;\n+    private Charset defaultCharset = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET;", "originalCommit": "9cca17a7d0a18039c2adea0286d97f3d262c2501", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1OTQyNA==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375659424", "bodyText": "the ancient HTTP standard vs common practice nowadays\n\nYes, it's time to throw the ancient standard away. Thanks!", "author": "minwoox", "createdAt": "2020-02-06T06:28:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1NDUzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY2NTc2Nw==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375665767", "bodyText": "Modern clients almost always send content type with a charset attribute, so defaulting to ISO-8859-1 makes more sense in my opinion. The only exception is JSON, which is by definition UTF-8 if no charset is specified.\n(+1 for latter therefore)", "author": "trustin", "createdAt": "2020-02-06T06:54:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1NDUzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY3NTU2Ng==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375675566", "bodyText": "We seem to already have a strange dichotomy\n\n\nStringRequestConverterFunction and StringResponseConverterFunction have different defaults, former is ISO-8859-1 and latter is UTF-8. I don't see any reason for this other than we feel it's tremendously more convenient for responses to default to UTF-8, but this seems to apply to requests too. Why respect HTTP RFC for requests but not responses?\n\nAlso an example of requests that don't have charset applied even in modern times - manual debug requests from curl\n\n\n\nspring-boot defaults to UTF-8 for both. I think that's a good enough industry standard for us to follow (actually our annotated service is not a drop-in replacement for spring if we don't)\n\n\nhttps://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html\nSearch spring.http.encoding.charset\nConfirmed in code\nhttps://github.com/spring-projects/spring-boot/blame/711391cf2f27dd2637a1bb4d7847a2323b6c4e16/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/web/servlet/server/Encoding.java#L37\nhttps://github.com/spring-projects/spring-boot/blob/711391cf2f27dd2637a1bb4d7847a2323b6c4e16/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/http/HttpMessageConvertersAutoConfiguration.java#L81", "author": "anuraaga", "createdAt": "2020-02-06T07:31:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1NDUzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY3ODAxNQ==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375678015", "bodyText": "I guess even ourselves are confused about the defaults... \ud83d\ude05 Let's just default to UTF-8 then.", "author": "trustin", "createdAt": "2020-02-06T07:39:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1NDUzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY4NTk3Mw==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375685973", "bodyText": "Fixed. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-02-06T08:03:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1NDUzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1NDc4Ng==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375654786", "bodyText": "Does a preview spec also need a default charset? I'm having trouble understanding how this is used.", "author": "anuraaga", "createdAt": "2020-02-06T06:07:14Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/PreviewSpec.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.logging;\n+\n+import java.nio.charset.Charset;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.RequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class PreviewSpec {\n+\n+    private final BiPredicate<? super RequestContext, ? super HttpHeaders> predicate;\n+    private final PreviewMode mode;\n+    @Nullable\n+    private final Charset defaultCharset;\n+    @Nullable\n+    private final BiFunction<? super HttpHeaders, ? super ByteBuf, String> producer;\n+\n+    PreviewSpec(BiPredicate<? super RequestContext, ? super HttpHeaders> predicate,\n+                PreviewMode mode, @Nullable Charset defaultCharset,\n+                @Nullable BiFunction<? super HttpHeaders, ? super ByteBuf, String> producer) {\n+        this.predicate = predicate;\n+        this.mode = mode;\n+        this.defaultCharset = defaultCharset;\n+        this.producer = producer;\n+    }\n+\n+    BiPredicate<? super RequestContext, ? super HttpHeaders> predicate() {\n+        return predicate;\n+    }\n+\n+    PreviewMode mode() {\n+        return mode;\n+    }\n+\n+    @Nullable\n+    Charset defaultCharset() {", "originalCommit": "9cca17a7d0a18039c2adea0286d97f3d262c2501", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY2MDI4MQ==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375660281", "bodyText": "Maybe it's too much to have different default charsets for different media types?\nI think I can just remove this and use one default charset for every text preview when the charset is not specified in the content type. Thanks!", "author": "minwoox", "createdAt": "2020-02-06T06:31:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1NDc4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYzMjA3Ng==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375632076", "bodyText": "nit: Just wrappedBuffer.toString(charset)?", "author": "ikhoon", "createdAt": "2020-02-06T04:09:00Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/TextContentPreviewer.java", "diffHunk": "@@ -13,19 +13,25 @@\n  * License for the specific language governing permissions and limitations\n  * under the License.\n  */\n+\n package com.linecorp.armeria.common.logging;\n \n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.RequestContext;\n+import java.nio.charset.Charset;\n+\n+import io.netty.buffer.ByteBuf;\n \n-final class NoopContentPreviewerFactory implements ContentPreviewerFactory {\n+final class TextContentPreviewer extends LengthLimitingContentPreviewer {\n \n-    static final ContentPreviewerFactory INSTANCE = new NoopContentPreviewerFactory();\n+    private final Charset charset;\n \n-    private NoopContentPreviewerFactory() {}\n+    TextContentPreviewer(int maxLength, Charset charset) {\n+        super(maxLength, charset);\n+        this.charset = charset;\n+    }\n \n     @Override\n-    public ContentPreviewer get(RequestContext ctx, HttpHeaders headers) {\n-        return ContentPreviewer.disabled();\n+    String produce(ByteBuf wrappedBuffer) {\n+        return wrappedBuffer.toString(wrappedBuffer.readerIndex(),\n+                                      wrappedBuffer.readableBytes(), charset);", "originalCommit": "fc2e202dd429868233081b1857bc60e768b630b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY3NjAxMg==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375676012", "bodyText": "Just copied without much thinking as well. \ud83d\ude05", "author": "minwoox", "createdAt": "2020-02-06T07:32:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYzMjA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY0NjI4MQ==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375646281", "bodyText": "nit: Add a space between // and TODO", "author": "ikhoon", "createdAt": "2020-02-06T05:26:47Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ContentPreviewerFactoryBuilder.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.MediaTypeSet;\n+import com.linecorp.armeria.common.RequestContext;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.logging.PreviewSpec.PreviewMode;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+\n+/**\n+ * A builder which builds a {@link ContentPreviewerFactory}.\n+ */\n+public final class ContentPreviewerFactoryBuilder {\n+\n+    //TODO(minwoox): Add setters for the seprate request and response previewer.", "originalCommit": "fc2e202dd429868233081b1857bc60e768b630b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1MjA1MA==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375652050", "bodyText": "nit: Just call Ints.saturatedCast(maxBytesPerChar * maxLength)?", "author": "ikhoon", "createdAt": "2020-02-06T05:54:35Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/LengthLimitingContentPreviewer.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.logging;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.math.IntMath;\n+\n+import com.linecorp.armeria.common.HttpData;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufHolder;\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+\n+abstract class LengthLimitingContentPreviewer implements ContentPreviewer {\n+\n+    private static final ByteBuf[] BYTE_BUFS = new ByteBuf[0];\n+\n+    private final List<ByteBuf> bufferList = new ArrayList<>();\n+    private final int maxLength;\n+    private final int inflatedMaxLength;\n+\n+    @Nullable\n+    private String produced;\n+    private int aggregatedLength;\n+\n+    LengthLimitingContentPreviewer(int maxLength, @Nullable Charset charset) {\n+        this.maxLength = maxLength;\n+        inflatedMaxLength = inflateMaxLength(maxLength, charset);\n+    }\n+\n+    private static int inflateMaxLength(int maxLength, @Nullable Charset charset) {\n+        if (charset == null) {\n+            return maxLength;\n+        }\n+        final long maxBytesPerChar = (long) Math.ceil(CharsetUtil.encoder(charset).maxBytesPerChar());\n+        return (int) Long.min(Integer.MAX_VALUE, maxBytesPerChar * maxLength);", "originalCommit": "fc2e202dd429868233081b1857bc60e768b630b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY3NTkyOA==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375675928", "bodyText": "Fixed. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-02-06T07:32:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1MjA1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1ODQ0OQ==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375658449", "bodyText": "You don't need to address this preview. I just thought we can optimize this after releasing 1.0.\nMediaType class has KNOWN_TYPES. If the contentType is KNOWN_TYPES these predicate results are cachable or statically build with limited size. :-)", "author": "ikhoon", "createdAt": "2020-02-06T06:23:50Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/DefaultContentPreviewFactory.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.logging;\n+\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestContext;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class DefaultContentPreviewFactory implements ContentPreviewerFactory {\n+\n+    private static final List<String> textSubTypes = ImmutableList.of(\"json\", \"xml\");\n+    private static final List<String> textSubTypeSuffixes = ImmutableList.of(\"+json\", \"+xml\");\n+\n+    private final int maxLength;\n+    private final List<PreviewSpec> previewSpecs;\n+    private final Charset defaultCharset;\n+\n+    DefaultContentPreviewFactory(List<PreviewSpec> previewSpecs, int maxLength, Charset defaultCharset) {\n+        this.maxLength = maxLength;\n+        this.previewSpecs = previewSpecs;\n+        this.defaultCharset = defaultCharset;\n+    }\n+\n+    @Override\n+    public ContentPreviewer requestContentPreviewer(RequestContext ctx, RequestHeaders headers) {\n+        return contentPreviewer(ctx, headers);\n+    }\n+\n+    @Override\n+    public ContentPreviewer responseContentPreviewer(RequestContext ctx, ResponseHeaders resHeaders) {\n+        return contentPreviewer(ctx, resHeaders);\n+    }\n+\n+    private ContentPreviewer contentPreviewer(RequestContext ctx, HttpHeaders headers) {\n+        for (PreviewSpec previewSpec : previewSpecs) {\n+            if (previewSpec.predicate().test(ctx, headers)) {\n+                switch (previewSpec.mode()) {\n+                    case TEXT:\n+                        final Charset charset = charset(headers, previewSpec);\n+                        return new TextContentPreviewer(maxLength, charset);\n+                    case BINARY:\n+                        final BiFunction<? super HttpHeaders, ? super ByteBuf, String> producer =\n+                                previewSpec.producer();\n+                        assert producer != null;\n+                        return new ProducerBasedContentPreviewer(maxLength, headers, producer);\n+                    case DISABLED:\n+                        return ContentPreviewer.disabled();\n+                }\n+            }\n+        }\n+\n+        final MediaType contentType = headers.contentType();\n+        if (contentType != null) {\n+            final Charset charset = contentType.charset();\n+            if (charset != null) {\n+                return new TextContentPreviewer(maxLength, charset);\n+            }\n+\n+            if (\"text\".equals(contentType.type()) ||\n+                textSubTypes.contains(contentType.subtype()) ||\n+                textSubTypeSuffixes.stream().anyMatch(contentType.subtype()::endsWith) ||\n+                contentType.is(MediaType.FORM_DATA)) {", "originalCommit": "9cca17a7d0a18039c2adea0286d97f3d262c2501", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY3NTg2Mg==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375675862", "bodyText": "Ah yes, it's probably a good idea to cache the result. But we have to check the performance because we have to do it in thread safely and the size of cached should be limited which means we have to use caffeine. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-02-06T07:32:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1ODQ0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc2NTU2Mg==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375765562", "bodyText": "Yes, we should prove optimized code with benchmarks. By the way I thought we could build this cache when class is loading so we don\u2019t care about thread safety.", "author": "ikhoon", "createdAt": "2020-02-06T10:52:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1ODQ0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc3MDIwOA==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375770208", "bodyText": "How could we do that? I don't probably understand what you mean. Could you elaborate more please? \ud83d\ude04", "author": "minwoox", "createdAt": "2020-02-06T11:01:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1ODQ0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc3Mjk3MQ==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375772971", "bodyText": "Let me try this \ud83d\ude09and will give a feedback.", "author": "ikhoon", "createdAt": "2020-02-06T11:08:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1ODQ0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTgxMzcwMw==", "url": "https://github.com/line/armeria/pull/2444#discussion_r375813703", "bodyText": "I thought this kind of cache. :-) Even though I didn't run a benchmark yet.\ndiff --git a/core/src/main/java/com/linecorp/armeria/common/MediaType.java b/core/src/main/java/com/linecorp/armeria/common/MediaType.java\nindex 9875a1ae0..e7e504290 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/MediaType.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/MediaType.java\n@@ -127,6 +127,10 @@ public final class MediaType {\n \n     private static final Map<MediaType, MediaType> KNOWN_TYPES = Maps.newHashMap();\n \n+    public static Map<MediaType, MediaType> knownTypes() {\n+        return KNOWN_TYPES;\n+    }\n+\n     private static MediaType createConstant(String type, String subtype) {\n         MediaType mediaType =\n                 addKnownType(new MediaType(type, subtype, ImmutableListMultimap.of()));\ndiff --git a/core/src/main/java/com/linecorp/armeria/common/logging/DefaultContentPreviewFactory.java b/core/src/main/java/com/linecorp/armeria/common/logging/DefaultContentPreviewFactory.java\nindex 6a4f2d665..405f69b45 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/logging/DefaultContentPreviewFactory.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/logging/DefaultContentPreviewFactory.java\n@@ -16,8 +16,12 @@\n \n package com.linecorp.armeria.common.logging;\n \n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+\n import java.nio.charset.Charset;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.function.BiFunction;\n \n import com.google.common.collect.ImmutableList;\n@@ -35,6 +39,12 @@ final class DefaultContentPreviewFactory implements ContentPreviewerFactory {\n     private static final List<String> textSubTypes = ImmutableList.of(\"json\", \"xml\");\n     private static final List<String> textSubTypeSuffixes = ImmutableList.of(\"+json\", \"+xml\");\n \n+    private static final Map<MediaType, Boolean> previewableTextMediaTypes =\n+            MediaType.knownTypes()\n+                     .entrySet()\n+                     .stream()\n+                     .collect(toImmutableMap(Entry::getKey, entry -> isTextContent0(entry.getValue())));\n+\n     private final int maxLength;\n     private final List<PreviewSpec> previewSpecs;\n     private final Charset defaultCharset;\n@@ -55,6 +65,22 @@ final class DefaultContentPreviewFactory implements ContentPreviewerFactory {\n         return contentPreviewer(ctx, resHeaders);\n     }\n \n+    private static boolean isTextType(MediaType contentType) {\n+        final Boolean isTextType = previewableTextMediaTypes.get(contentType);\n+        if (isTextType != null) {\n+            return isTextType;\n+        } else {\n+            return isTextContent0(contentType);\n+        }\n+    }\n+\n+    private static boolean isTextContent0(MediaType contentType) {\n+        return \"text\".equals(contentType.type()) ||\n+               textSubTypes.contains(contentType.subtype()) ||\n+               textSubTypeSuffixes.stream().anyMatch(contentType.subtype()::endsWith) ||\n+               contentType.is(MediaType.FORM_DATA);\n+    }\n+\n     private ContentPreviewer contentPreviewer(RequestContext ctx, HttpHeaders headers) {\n         for (PreviewSpec previewSpec : previewSpecs) {\n             if (previewSpec.predicate().test(ctx, headers)) {\n@@ -80,10 +106,7 @@ final class DefaultContentPreviewFactory implements ContentPreviewerFactory {\n                 return new TextContentPreviewer(maxLength, charset);\n             }\n \n-            if (\"text\".equals(contentType.type()) ||\n-                textSubTypes.contains(contentType.subtype()) ||\n-                textSubTypeSuffixes.stream().anyMatch(contentType.subtype()::endsWith) ||\n-                contentType.is(MediaType.FORM_DATA)) {\n+            if (isTextType(contentType)) {\n                 return new TextContentPreviewer(maxLength, defaultCharset);\n             }\n         }", "author": "ikhoon", "createdAt": "2020-02-06T12:47:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1ODQ0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjIwMDk4Mg==", "url": "https://github.com/line/armeria/pull/2444#discussion_r376200982", "bodyText": "Ah, I was thinking caching every media type of request, but yes this is a good approach and we don't even need the benchmark because it's obviously winning.\nAs I left the comment, I will look into this later with other logic which handles text content type. Thanks!", "author": "minwoox", "createdAt": "2020-02-07T03:38:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1ODQ0OQ=="}], "type": "inlineReview"}, {"oid": "0c66fd7e80a81f3711a97aa14e606602044ad04d", "url": "https://github.com/line/armeria/commit/0c66fd7e80a81f3711a97aa14e606602044ad04d", "message": "Address comments from all", "committedDate": "2020-02-06T08:01:05Z", "type": "commit"}]}