{"pr_number": 3080, "pr_title": "Provide request context cancellation", "pr_createdAt": "2020-09-23T00:00:31Z", "pr_url": "https://github.com/line/armeria/pull/3080", "timeline": [{"oid": "1b9772598f84e58ed2f6f8f1645fbfde9de67127", "url": "https://github.com/line/armeria/commit/1b9772598f84e58ed2f6f8f1645fbfde9de67127", "message": "Add request cancel", "committedDate": "2020-09-22T23:49:27Z", "type": "commit"}, {"oid": "3eae085f97feebfe56dd5fc3bd2889eb513be4ba", "url": "https://github.com/line/armeria/commit/3eae085f97feebfe56dd5fc3bd2889eb513be4ba", "message": "Add tests", "committedDate": "2020-09-23T04:00:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxODU0Ng==", "url": "https://github.com/line/armeria/pull/3080#discussion_r494018546", "bodyText": "We should do delegate.close(cause); before ctx.request().abort(cause);", "author": "minwoox", "createdAt": "2020-09-24T03:37:00Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpResponseDecoder.java", "diffHunk": "@@ -391,12 +392,15 @@ public boolean canSchedule() {\n \n                 @Override\n                 public void run() {\n-                    final ResponseTimeoutException cause = ResponseTimeoutException.get();\n-                    delegate.close(cause);\n+                    RuntimeException cause = ResponseTimeoutException.get();\n                     if (ctx != null) {\n+                        if (ctx.isCancelled()) {\n+                            cause = new CancellationException();\n+                        }\n                         ctx.request().abort(cause);\n                         ctx.logBuilder().endResponse(cause);\n                     }\n+                    delegate.close(cause);", "originalCommit": "3eae085f97feebfe56dd5fc3bd2889eb513be4ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxOTgyNQ==", "url": "https://github.com/line/armeria/pull/3080#discussion_r494019825", "bodyText": "It seems like canceling the response timeout to me. Should we rename the TimeoutScheduler? \ud83e\udd14\n/cc @ikhoon", "author": "minwoox", "createdAt": "2020-09-24T03:42:18Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -586,6 +586,16 @@ public boolean isTimedOut() {\n         return responseTimeoutScheduler.isTimedOut();\n     }\n \n+    @Override\n+    public void cancel() {\n+        responseTimeoutScheduler.cancel();", "originalCommit": "3eae085f97feebfe56dd5fc3bd2889eb513be4ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA1NzgzNQ==", "url": "https://github.com/line/armeria/pull/3080#discussion_r494057835", "bodyText": "Agreed. How about making timeoutNow() take an Exception that could be used when TimeoutTask is invoked?\n// in TimeoutScheduler\nvoid timeoutNow(Throwable cause) {\n   ...\n}\n@Nullable\nThrowable timeoutCause() { ... }\n\n// in HttpResponseDecoder\nThrowable cause = timeoutScheduler.timeoutCause();\nif (cause == null) {\n    cause = ResponseTimeoutException.get();\n} \n...", "author": "ikhoon", "createdAt": "2020-09-24T06:03:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxOTgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQxODQ1Ng==", "url": "https://github.com/line/armeria/pull/3080#discussion_r494418456", "bodyText": "I think cancel() is clearer about the behavior we want. Having a cancel(), isCancelled() pair looks better. Also I don't think we need to pass the cause around, the TimeoutTask can determine it in one place. But I agree on renaming TimeoutScheduler to something more general \ud83d\ude04", "author": "tumile", "createdAt": "2020-09-24T15:37:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxOTgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA1MzQ0MA==", "url": "https://github.com/line/armeria/pull/3080#discussion_r494053440", "bodyText": "Don't we need to introduce RequestCancellationException and make it singletone?", "author": "ikhoon", "createdAt": "2020-09-24T05:49:42Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpResponseDecoder.java", "diffHunk": "@@ -391,12 +392,15 @@ public boolean canSchedule() {\n \n                 @Override\n                 public void run() {\n-                    final ResponseTimeoutException cause = ResponseTimeoutException.get();\n-                    delegate.close(cause);\n+                    RuntimeException cause = ResponseTimeoutException.get();\n                     if (ctx != null) {\n+                        if (ctx.isCancelled()) {\n+                            cause = new CancellationException();", "originalCommit": "3eae085f97feebfe56dd5fc3bd2889eb513be4ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA1NDQ2OQ==", "url": "https://github.com/line/armeria/pull/3080#discussion_r494054469", "bodyText": "Is it better to move these methods down to ClientRequestContext? \ud83e\udd14", "author": "ikhoon", "createdAt": "2020-09-24T05:52:58Z", "path": "core/src/main/java/com/linecorp/armeria/common/RequestContext.java", "diffHunk": "@@ -377,6 +378,16 @@ default boolean hasOwnAttr(AttributeKey<?> key) {\n      */\n     boolean isTimedOut();\n \n+    /**\n+     * Cancels the request. Similar to {@link #timeoutNow()}, but throws a {@link CancellationException}.\n+     */\n+    void cancel();\n+\n+    /**\n+     * Returns whether this {@link RequestContext} has been cancelled.\n+     */\n+    boolean isCancelled();", "originalCommit": "3eae085f97feebfe56dd5fc3bd2889eb513be4ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA1ODM1OA==", "url": "https://github.com/line/armeria/pull/3080#discussion_r494058358", "bodyText": "Don't we need to complete whenTimingOut and whenTimedOut even if it is cancelled? Unless the futures never complete forever.", "author": "ikhoon", "createdAt": "2020-09-24T06:04:46Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -416,13 +435,21 @@ private void invokeTimeoutTask() {\n             if (!whenTimedOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n                 whenTimedOut.doComplete();\n             }\n+        } else {\n+            // Set CANCELLED flag first to prevent duplicate execution\n+            state = State.CANCELLED;", "originalCommit": "3eae085f97feebfe56dd5fc3bd2889eb513be4ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM5ODI5OQ==", "url": "https://github.com/line/armeria/pull/3080#discussion_r494398299", "bodyText": "How about calling cancel() the futures?", "author": "tumile", "createdAt": "2020-09-24T15:10:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA1ODM1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwMTg5NA==", "url": "https://github.com/line/armeria/pull/3080#discussion_r494401894", "bodyText": "That sounds nice. Could you reuse cacelled futures if users don\u2019t call whenTime*out yet to avoid additional memory allocation?", "author": "ikhoon", "createdAt": "2020-09-24T15:15:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA1ODM1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQxOTc2NA==", "url": "https://github.com/line/armeria/pull/3080#discussion_r494419764", "bodyText": "Aren't the futures null when users haven't called whenTim*out?", "author": "tumile", "createdAt": "2020-09-24T15:39:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA1ODM1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQyNTEyNQ==", "url": "https://github.com/line/armeria/pull/3080#discussion_r494425125", "bodyText": "Yeah, what I want to say was like \ud83d\ude00:\nif (!isTimedOut) {\n\tif (!whenTimedOutUpdater.compareAndSet(this, null, CANCELLED_FUTURE)) {\n\t    whenTimedOut.doCancel();\n\t}\n    ...\n}", "author": "ikhoon", "createdAt": "2020-09-24T15:47:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA1ODM1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQzMTIzNA==", "url": "https://github.com/line/armeria/pull/3080#discussion_r494431234", "bodyText": "Oh sure \ud83d\ude01", "author": "tumile", "createdAt": "2020-09-24T15:55:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA1ODM1OA=="}], "type": "inlineReview"}, {"oid": "7395d5aa168a1fa9bc47d7f4f4e22af29a784a53", "url": "https://github.com/line/armeria/commit/7395d5aa168a1fa9bc47d7f4f4e22af29a784a53", "message": "Move cancel to ClientRequestContext", "committedDate": "2020-09-26T00:48:36Z", "type": "commit"}, {"oid": "9e18b5d9b04530c19473215aa3d4918f35a9c207", "url": "https://github.com/line/armeria/commit/9e18b5d9b04530c19473215aa3d4918f35a9c207", "message": "Add RequestCancellationException", "committedDate": "2020-09-26T21:26:39Z", "type": "commit"}, {"oid": "50558a44188096ff36b0e0c130217bd6f50c7d9c", "url": "https://github.com/line/armeria/commit/50558a44188096ff36b0e0c130217bd6f50c7d9c", "message": "Fix", "committedDate": "2020-09-26T21:46:50Z", "type": "commit"}, {"oid": "0cb2a997a8e916e4ef7febd444d8afc016f934fd", "url": "https://github.com/line/armeria/commit/0cb2a997a8e916e4ef7febd444d8afc016f934fd", "message": "Merge branch 'master' of github.com:line/armeria into request-cancel", "committedDate": "2020-10-01T22:17:46Z", "type": "commit"}, {"oid": "10713ff0a82020c156e6947f34d5e2394b951201", "url": "https://github.com/line/armeria/commit/10713ff0a82020c156e6947f34d5e2394b951201", "message": "Address comments", "committedDate": "2020-10-03T19:57:55Z", "type": "commit"}, {"oid": "2721572effc2031320bc1b8e8fcb3a6bf00d23c6", "url": "https://github.com/line/armeria/commit/2721572effc2031320bc1b8e8fcb3a6bf00d23c6", "message": "Fix", "committedDate": "2020-10-03T20:31:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1ODI1MA==", "url": "https://github.com/line/armeria/pull/3080#discussion_r499358250", "bodyText": "This is not thread safe and could override the original cause if a request was cancelled already.\nQuestion: Do we need to save cancellationCause in this class?", "author": "ikhoon", "createdAt": "2020-10-05T05:53:53Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -572,28 +576,50 @@ public RequestLogBuilder logBuilder() {\n         return log;\n     }\n \n-    TimeoutScheduler responseTimeoutScheduler() {\n-        return responseTimeoutScheduler;\n+    TimeoutScheduler responseCancellationScheduler() {\n+        return responseCancellationScheduler;\n+    }\n+\n+    @Override\n+    public void cancel(Throwable cause) {\n+        cancellationCause = cause;", "originalCommit": "2721572effc2031320bc1b8e8fcb3a6bf00d23c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk2OTU0Mw==", "url": "https://github.com/line/armeria/pull/3080#discussion_r499969543", "bodyText": "I see. I didn't think it through. I think we can pass the cause to TimeoutScheduler like you suggested, but then should also pass the cause to TimeoutTask.run(cause)? That makes sure the cause is correct when the task runs.\n// ClientContext\nvoid cancel(Throwable cause) {\n    scheduler.finishNow(cause);\n}\n\n@Nullable\nThrowable cancellationCause() {\n    return scheduler.cause(); // null when timeoutTask has not run\n}\n\n// TimeoutScheduler\nvoid init(..., Throwable cause /* the initial cause */) { \n    eventLoop.schedule(() -> invokeTimeoutTask(cause),...);\n}\n\nvoid finishNow(Throwable cause) {\n    // the scheduled task is cleared if not yet executed\n    eventLoop.execute(() -> invokeTimeoutTask(cause));\n}\n\nvoid invokeTimeoutTask(Throwable cause) {\n    ...\n    timeoutTask.run(cause);\n    this.cause = cause; // now we set the final cause. this cannot be changed because state=FINISHED\n}\nWe can cancel handlers if cause not instanceof TimeoutException.", "author": "tumile", "createdAt": "2020-10-06T02:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1ODI1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIzNjMwMA==", "url": "https://github.com/line/armeria/pull/3080#discussion_r500236300", "bodyText": "but then should also pass the cause to TimeoutTask.run(cause)?\n\nThat makes sense. I agree to pass the cause to the task.\n\n// TimeoutScheduler\nvoid init(..., Throwable cause /* the initial cause */) { \n    eventLoop.schedule(() -> invokeTimeoutTask(cause),...);\n}\n\nTimeoutScheduler is an internal class. IMO, isn't RequestTimeoutException sufficient for the initial cause? We can add the initial cause when we need it. \ud83d\ude00", "author": "ikhoon", "createdAt": "2020-10-06T12:31:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1ODI1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMxMTAzNg==", "url": "https://github.com/line/armeria/pull/3080#discussion_r500311036", "bodyText": "But client uses ResponseTimeoutException and service uses RequestTimeoutException. We can check cause == null when it's consumed and resolve to either ResponseTimeoutException or RequestTimeoutException, but I think that's more code ... \ud83d\ude04", "author": "tumile", "createdAt": "2020-10-06T14:05:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1ODI1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMxMzk4Mw==", "url": "https://github.com/line/armeria/pull/3080#discussion_r500313983", "bodyText": "But client uses ResponseTimeoutException and service uses RequestTimeoutException\n\nAh, I didn't think of that. In that case, taking initial cause would be good. \ud83d\udc4d", "author": "ikhoon", "createdAt": "2020-10-06T14:08:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1ODI1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMxNTQxMw==", "url": "https://github.com/line/armeria/pull/3080#discussion_r500315413", "bodyText": "Great, working on it \ud83d\ude80", "author": "tumile", "createdAt": "2020-10-06T14:10:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1ODI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1ODg0Nw==", "url": "https://github.com/line/armeria/pull/3080#discussion_r499358847", "bodyText": "nit: Could you break this line between setTimeoutNanos( and requireNonNull(...) for readability.", "author": "ikhoon", "createdAt": "2020-10-05T05:56:09Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -498,24 +501,25 @@ public void setWriteTimeout(Duration writeTimeout) {\n \n     @Override\n     public long responseTimeoutMillis() {\n-        return TimeUnit.NANOSECONDS.toMillis(responseTimeoutScheduler.timeoutNanos());\n+        return TimeUnit.NANOSECONDS.toMillis(responseCancellationScheduler.timeoutNanos());\n     }\n \n     @Override\n     public void clearResponseTimeout() {\n-        responseTimeoutScheduler.clearTimeout();\n+        responseCancellationScheduler.clearTimeout();\n     }\n \n     @Override\n     public void setResponseTimeoutMillis(TimeoutMode mode, long responseTimeoutMillis) {\n-        responseTimeoutScheduler.setTimeoutNanos(requireNonNull(mode, \"mode\"),\n-                                                 TimeUnit.MILLISECONDS.toNanos(responseTimeoutMillis));\n+        responseCancellationScheduler.setTimeoutNanos(requireNonNull(mode, \"mode\"),\n+                                                      TimeUnit.MILLISECONDS.toNanos(responseTimeoutMillis));\n     }\n \n     @Override\n     public void setResponseTimeout(TimeoutMode mode, Duration responseTimeout) {\n-        responseTimeoutScheduler.setTimeoutNanos(requireNonNull(mode, \"mode\"),\n-                                                 requireNonNull(responseTimeout, \"responseTimeout\").toNanos());\n+        responseCancellationScheduler.setTimeoutNanos(requireNonNull(mode, \"mode\"),", "originalCommit": "2721572effc2031320bc1b8e8fcb3a6bf00d23c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1OTMzMQ==", "url": "https://github.com/line/armeria/pull/3080#discussion_r499359331", "bodyText": "This is not a singleton if Flags.verboseExceptionSampler().isSampled(...) returns true.", "author": "ikhoon", "createdAt": "2020-10-05T05:57:58Z", "path": "core/src/main/java/com/linecorp/armeria/common/RequestCancellationException.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+/**\n+ * A {@link RuntimeException} raised when a request is cancelled by the user.\n+ */\n+public final class RequestCancellationException extends RuntimeException {\n+\n+    private static final long serialVersionUID = -8891853443874862294L;\n+\n+    private static final RequestCancellationException INSTANCE = new RequestCancellationException();\n+\n+    /**\n+     * Returns a singleton {@link RequestCancellationException}.", "originalCommit": "2721572effc2031320bc1b8e8fcb3a6bf00d23c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ1OTgyNQ==", "url": "https://github.com/line/armeria/pull/3080#discussion_r500459825", "bodyText": "I just copied over the code from ResponseTimeoutException. Is it not sufficient? \n  \n    \n      armeria/core/src/main/java/com/linecorp/armeria/client/ResponseTimeoutException.java\n    \n    \n        Lines 34 to 36\n      in\n      454a22c\n    \n    \n    \n    \n\n        \n          \n           public static ResponseTimeoutException get() { \n        \n\n        \n          \n               return Flags.verboseExceptionSampler().isSampled(ResponseTimeoutException.class) ? \n        \n\n        \n          \n                      new ResponseTimeoutException() : INSTANCE;", "author": "tumile", "createdAt": "2020-10-06T17:07:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1OTMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc5NzgyMQ==", "url": "https://github.com/line/armeria/pull/3080#discussion_r500797821", "bodyText": "You have to do this for a singleton, so that the exception becomes immutable:\n\n  \n    \n      armeria/core/src/main/java/com/linecorp/armeria/server/RequestTimeoutException.java\n    \n    \n         Line 29\n      in\n      454a22c\n    \n    \n    \n    \n\n        \n          \n           private static final RequestTimeoutException INSTANCE = new RequestTimeoutException(false); \n        \n    \n  \n\n (Note the boolean parameter)", "author": "trustin", "createdAt": "2020-10-07T07:34:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1OTMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2MjE4MQ==", "url": "https://github.com/line/armeria/pull/3080#discussion_r499362181", "bodyText": "\ud83d\ude47\u200d\u2642\ufe0f", "author": "ikhoon", "createdAt": "2020-10-05T06:08:14Z", "path": "core/src/test/java/com/linecorp/armeria/internal/common/TimeoutSchedulerTest.java", "diffHunk": "@@ -97,58 +98,56 @@ void resetTimeout() {\n     }\n \n     @Test\n-    void resetTimeout_zero() {\n+    void setTimeoutFromNowZero() {", "originalCommit": "2721572effc2031320bc1b8e8fcb3a6bf00d23c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2MjgzNg==", "url": "https://github.com/line/armeria/pull/3080#discussion_r499362836", "bodyText": "Could use WebClient.of(server.httpUri())", "author": "ikhoon", "createdAt": "2020-10-05T06:10:44Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientResponseTimeoutTest.java", "diffHunk": "@@ -117,6 +119,54 @@ void whenTimedOut() {\n         });\n     }\n \n+    @Test\n+    void timeoutWithContext() {\n+        final WebClient client = WebClient\n+                .builder(server.httpUri())\n+                .build();", "originalCommit": "2721572effc2031320bc1b8e8fcb3a6bf00d23c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2Mjk3Ng==", "url": "https://github.com/line/armeria/pull/3080#discussion_r499362976", "bodyText": "Could use WebClient.of(server.httpUri())", "author": "ikhoon", "createdAt": "2020-10-05T06:11:13Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientResponseTimeoutTest.java", "diffHunk": "@@ -117,6 +119,54 @@ void whenTimedOut() {\n         });\n     }\n \n+    @Test\n+    void timeoutWithContext() {\n+        final WebClient client = WebClient\n+                .builder(server.httpUri())\n+                .build();\n+        try (ClientRequestContextCaptor ctxCaptor = Clients.newContextCaptor()) {\n+            final CompletableFuture<AggregatedHttpResponse> response = client.get(\"/no-timeout\").aggregate();\n+            final ClientRequestContext cctx = ctxCaptor.get();\n+            cctx.timeoutNow();\n+            assertThat(cctx.isTimedOut()).isFalse();\n+            assertThatThrownBy(response::join)\n+                    .isInstanceOf(CompletionException.class)\n+                    .hasCauseInstanceOf(ResponseTimeoutException.class);\n+            assertThat(cctx.isTimedOut()).isTrue();\n+        }\n+    }\n+\n+    @Test\n+    void cancel() {\n+        final WebClient client = WebClient\n+                .builder(server.httpUri())\n+                .decorator((delegate, ctx, req) -> {\n+                    ctx.cancel();\n+                    return delegate.execute(ctx, req);\n+                })\n+                .build();\n+        assertThatThrownBy(() -> client.get(\"/no-timeout\").aggregate().join())\n+                .isInstanceOf(CompletionException.class)\n+                .hasCauseInstanceOf(RequestCancellationException.class);\n+    }\n+\n+    @Test\n+    void cancelWithContext() {\n+        final WebClient client = WebClient\n+                .builder(server.httpUri())\n+                .build();", "originalCommit": "2721572effc2031320bc1b8e8fcb3a6bf00d23c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2NDQyNA==", "url": "https://github.com/line/armeria/pull/3080#discussion_r499364424", "bodyText": "This might be flaky. According to the CPU scheduling, isTimedOut() could be returned true.\nHow about checking the condition before calling timeoutNow().", "author": "ikhoon", "createdAt": "2020-10-05T06:16:19Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientResponseTimeoutTest.java", "diffHunk": "@@ -117,6 +119,54 @@ void whenTimedOut() {\n         });\n     }\n \n+    @Test\n+    void timeoutWithContext() {\n+        final WebClient client = WebClient\n+                .builder(server.httpUri())\n+                .build();\n+        try (ClientRequestContextCaptor ctxCaptor = Clients.newContextCaptor()) {\n+            final CompletableFuture<AggregatedHttpResponse> response = client.get(\"/no-timeout\").aggregate();\n+            final ClientRequestContext cctx = ctxCaptor.get();\n+            cctx.timeoutNow();\n+            assertThat(cctx.isTimedOut()).isFalse();", "originalCommit": "2721572effc2031320bc1b8e8fcb3a6bf00d23c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4da1d9f44a60362e5cbd824ff4d62813491bdbcc", "url": "https://github.com/line/armeria/commit/4da1d9f44a60362e5cbd824ff4d62813491bdbcc", "message": "Address comments", "committedDate": "2020-10-06T17:27:58Z", "type": "commit"}, {"oid": "5fde278c3f0d34ca35da652a1c3499ab85503fa9", "url": "https://github.com/line/armeria/commit/5fde278c3f0d34ca35da652a1c3499ab85503fa9", "message": "Retest", "committedDate": "2020-10-07T01:32:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc5ODQ2Mw==", "url": "https://github.com/line/armeria/pull/3080#discussion_r500798463", "bodyText": "Should we make TimeoutException extend this class?", "author": "trustin", "createdAt": "2020-10-07T07:36:10Z", "path": "core/src/main/java/com/linecorp/armeria/common/RequestCancellationException.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+/**\n+ * A {@link RuntimeException} raised when a request is cancelled by the user.\n+ */\n+public final class RequestCancellationException extends RuntimeException {", "originalCommit": "5fde278c3f0d34ca35da652a1c3499ab85503fa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA4NTczOQ==", "url": "https://github.com/line/armeria/pull/3080#discussion_r501085739", "bodyText": "Then ResponseTimeoutException will be an instance of RequestCancellationException \ud83e\udd14. That's a bit mixed up.", "author": "tumile", "createdAt": "2020-10-07T15:02:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc5ODQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU4NjU5MQ==", "url": "https://github.com/line/armeria/pull/3080#discussion_r501586591", "bodyText": "Yeah, that's a little bit weird. Let's leave it as it is for now. Could you add some TODO about this as an inline comment? e.g.\nTODO(trustin): Clean up the type hierarchy between RequestCancellationException,\n               TimeoutException, RequestTimeoutException and ResponseTimeoutException.", "author": "trustin", "createdAt": "2020-10-08T09:43:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc5ODQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYzMzQwNA==", "url": "https://github.com/line/armeria/pull/3080#discussion_r503633404", "bodyText": "Question: Don't we need to introduce ResponseCancellantionExeption for consistency?", "author": "ikhoon", "createdAt": "2020-10-13T02:38:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc5ODQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc1MDMxNA==", "url": "https://github.com/line/armeria/pull/3080#discussion_r503750314", "bodyText": "Question: Don't we need to introduce ResponseCancellantionExeption for consistency?\n\nYeah, RequestCancellationException and ResponseCancellationException could extend a new parent class CancellationException which is similar to TimeoutException.", "author": "trustin", "createdAt": "2020-10-13T08:08:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc5ODQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc1Nzc1MA==", "url": "https://github.com/line/armeria/pull/3080#discussion_r503757750", "bodyText": "Could the type hierarchy be like the following?\nclass CancellationException\nclass RequestCancellationException extends CancellationException\nclass ResponseCancellationException extends CancellationException\n\nclass TimeoutException extends CancellationException\nclass RequestTimeoutException extends TimeoutException\nclass ResponseTimeoutException extends TimeoutException", "author": "trustin", "createdAt": "2020-10-13T08:20:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc5ODQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ0MjMyMQ==", "url": "https://github.com/line/armeria/pull/3080#discussion_r504442321", "bodyText": "@ikhoon @minwoox @tumile Thoughts?", "author": "trustin", "createdAt": "2020-10-14T06:54:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc5ODQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ3MDU3NA==", "url": "https://github.com/line/armeria/pull/3080#discussion_r504470574", "bodyText": "LGTM. \ud83d\udc4d", "author": "minwoox", "createdAt": "2020-10-14T07:48:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc5ODQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU0Mjk2MQ==", "url": "https://github.com/line/armeria/pull/3080#discussion_r504542961", "bodyText": "+1", "author": "ikhoon", "createdAt": "2020-10-14T09:41:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc5ODQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDgwMTQyOQ==", "url": "https://github.com/line/armeria/pull/3080#discussion_r500801429", "bodyText": "How about overriding this method in ClientRequestContext and ServiceRequestContext to provide better Javadoc there? e.g.\n/**\n * Shortcut for {@code cancel(RequestTimeoutException.get()}.\n */\n@Override\nvoid timeoutNow();", "author": "trustin", "createdAt": "2020-10-07T07:41:13Z", "path": "core/src/main/java/com/linecorp/armeria/common/RequestContext.java", "diffHunk": "@@ -365,15 +365,35 @@ default boolean hasOwnAttr(AttributeKey<?> key) {\n     MeterRegistry meterRegistry();\n \n     /**\n-     * Triggers the current timeout immediately if a timeout was scheduled before.\n-     * Otherwise, the current {@link Request} will be timed-out immediately after a timeout scheduler is\n-     * initialized.\n+     * Cancels the current {@link Request} with a {@link Throwable}.\n+     */\n+    void cancel(Throwable cause);\n+\n+    /**\n+     * Shortcut for {@code cancel(RequestCancellationException.get())}.\n+     */\n+    void cancel();\n+\n+    /**\n+     * Shortcut for {@code cancel(RequestTimeoutException.get())} or\n+     * {@code cancel(ResponseTimeoutException.get())}.\n      */\n     void timeoutNow();", "originalCommit": "5fde278c3f0d34ca35da652a1c3499ab85503fa9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "426a237b5b2c2732de1d8d93fb24117777d13d68", "url": "https://github.com/line/armeria/commit/426a237b5b2c2732de1d8d93fb24117777d13d68", "message": "Address comments", "committedDate": "2020-10-07T15:19:05Z", "type": "commit"}, {"oid": "d3df3aec6623d57b34e6753ef47961f846de09c2", "url": "https://github.com/line/armeria/commit/d3df3aec6623d57b34e6753ef47961f846de09c2", "message": "Rename and add cancel handlers", "committedDate": "2020-10-12T19:29:23Z", "type": "commit"}, {"oid": "4b80af345b80c5ea08326291e83705d6ce0b5145", "url": "https://github.com/line/armeria/commit/4b80af345b80c5ea08326291e83705d6ce0b5145", "message": "Add todo for trustin", "committedDate": "2020-10-12T19:44:13Z", "type": "commit"}, {"oid": "dcaf9196b733058e33959941fecfdd51d6ad54d8", "url": "https://github.com/line/armeria/commit/dcaf9196b733058e33959941fecfdd51d6ad54d8", "message": "Cleanup", "committedDate": "2020-10-13T01:28:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyNzA5MQ==", "url": "https://github.com/line/armeria/pull/3080#discussion_r503627091", "bodyText": "Could use a default method?", "author": "ikhoon", "createdAt": "2020-10-13T02:12:39Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientRequestContext.java", "diffHunk": "@@ -441,6 +441,11 @@ default void setResponseTimeout(Duration responseTimeout) {\n      */\n     CompletableFuture<Void> whenResponseTimedOut();\n \n+    /**\n+     * Times out the request. Shortcut for {@code cancel(ResponseTimeoutException.get())}.\n+     */\n+    void timeoutNow();", "originalCommit": "dcaf9196b733058e33959941fecfdd51d6ad54d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyNzg2OQ==", "url": "https://github.com/line/armeria/pull/3080#discussion_r503627869", "bodyText": "Make it default?", "author": "ikhoon", "createdAt": "2020-10-13T02:15:40Z", "path": "core/src/main/java/com/linecorp/armeria/common/RequestContext.java", "diffHunk": "@@ -365,15 +365,34 @@ default boolean hasOwnAttr(AttributeKey<?> key) {\n     MeterRegistry meterRegistry();\n \n     /**\n-     * Triggers the current timeout immediately if a timeout was scheduled before.\n-     * Otherwise, the current {@link Request} will be timed-out immediately after a timeout scheduler is\n-     * initialized.\n+     * Cancels the request with a {@link Throwable}.\n+     */\n+    void cancel(Throwable cause);\n+\n+    /**\n+     * Cancels the request. Shortcut for {@code cancel(RequestCancellationException.get())}.\n+     */\n+    void cancel();\n+\n+    /**\n+     * Times out the request.\n      */\n     void timeoutNow();\n \n     /**\n-     * Returns whether this {@link RequestContext} has been timed-out (e.g., when the\n-     * corresponding request passes a deadline).\n+     * Returns the cause of cancellation, {@code null} if the request has not been cancelled.\n+     */\n+    @Nullable\n+    Throwable cancellationCause();\n+\n+    /**\n+     * Returns whether this {@link RequestContext} has been cancelled.\n+     */\n+    boolean isCancelled();", "originalCommit": "dcaf9196b733058e33959941fecfdd51d6ad54d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyNzg4NA==", "url": "https://github.com/line/armeria/pull/3080#discussion_r503627884", "bodyText": "Ditto.", "author": "ikhoon", "createdAt": "2020-10-13T02:15:43Z", "path": "core/src/main/java/com/linecorp/armeria/common/RequestContext.java", "diffHunk": "@@ -365,15 +365,34 @@ default boolean hasOwnAttr(AttributeKey<?> key) {\n     MeterRegistry meterRegistry();\n \n     /**\n-     * Triggers the current timeout immediately if a timeout was scheduled before.\n-     * Otherwise, the current {@link Request} will be timed-out immediately after a timeout scheduler is\n-     * initialized.\n+     * Cancels the request with a {@link Throwable}.\n+     */\n+    void cancel(Throwable cause);\n+\n+    /**\n+     * Cancels the request. Shortcut for {@code cancel(RequestCancellationException.get())}.\n+     */\n+    void cancel();\n+\n+    /**\n+     * Times out the request.\n      */\n     void timeoutNow();\n \n     /**\n-     * Returns whether this {@link RequestContext} has been timed-out (e.g., when the\n-     * corresponding request passes a deadline).\n+     * Returns the cause of cancellation, {@code null} if the request has not been cancelled.\n+     */\n+    @Nullable\n+    Throwable cancellationCause();\n+\n+    /**\n+     * Returns whether this {@link RequestContext} has been cancelled.\n+     */\n+    boolean isCancelled();\n+\n+    /**\n+     * Returns whether this {@link RequestContext} has been timed-out, that is the cancellation cause is an\n+     * instance of {@link TimeoutException}.\n      */\n     boolean isTimedOut();", "originalCommit": "dcaf9196b733058e33959941fecfdd51d6ad54d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYzMjA3NQ==", "url": "https://github.com/line/armeria/pull/3080#discussion_r503632075", "bodyText": "Ditto.", "author": "ikhoon", "createdAt": "2020-10-13T02:32:51Z", "path": "core/src/main/java/com/linecorp/armeria/server/ServiceRequestContext.java", "diffHunk": "@@ -429,6 +429,11 @@ default void setRequestTimeout(Duration requestTimeout) {\n      */\n     CompletableFuture<Void> whenRequestTimedOut();\n \n+    /**\n+     * Times out the request. Shortcut for {@code cancel(RequestTimeoutException.get())}.\n+     */\n+    void timeoutNow();", "originalCommit": "dcaf9196b733058e33959941fecfdd51d6ad54d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY0NzI2MA==", "url": "https://github.com/line/armeria/pull/3080#discussion_r503647260", "bodyText": "Don't we need to deprecate this?\nIf then, we also need to migrate the code where whenResponseTimingOut() is used.", "author": "ikhoon", "createdAt": "2020-10-13T03:34:03Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -572,28 +573,49 @@ public RequestLogBuilder logBuilder() {\n         return log;\n     }\n \n-    TimeoutScheduler responseTimeoutScheduler() {\n-        return responseTimeoutScheduler;\n+    CancellationScheduler responseCancellationScheduler() {\n+        return responseCancellationScheduler;\n+    }\n+\n+    @Override\n+    public void cancel(Throwable cause) {\n+        responseCancellationScheduler.finishNow(cause);\n+    }\n+\n+    @Override\n+    public void cancel() {\n+        cancel(RequestCancellationException.get());\n     }\n \n     @Override\n     public void timeoutNow() {\n-        responseTimeoutScheduler.timeoutNow();\n+        cancel(ResponseTimeoutException.get());\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Throwable cancellationCause() {\n+        return responseCancellationScheduler.cause();\n+    }\n+\n+    @Override\n+    public boolean isCancelled() {\n+        return cancellationCause() != null;\n     }\n \n     @Override\n     public boolean isTimedOut() {\n-        return responseTimeoutScheduler.isTimedOut();\n+        return cancellationCause() instanceof TimeoutException;\n     }\n \n     @Override\n     public CompletableFuture<Void> whenResponseTimingOut() {", "originalCommit": "dcaf9196b733058e33959941fecfdd51d6ad54d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY1MTQ0OQ==", "url": "https://github.com/line/armeria/pull/3080#discussion_r503651449", "bodyText": "Yes I was thinking we may introduce whenResponseCancelling/Cancelled and deprecate that. If ok I'll look to migrate the code.", "author": "tumile", "createdAt": "2020-10-13T03:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY0NzI2MA=="}], "type": "inlineReview"}, {"oid": "ac49515657c5f822928a28c0cfabec24b413d864", "url": "https://github.com/line/armeria/commit/ac49515657c5f822928a28c0cfabec24b413d864", "message": "Use default methods", "committedDate": "2020-10-13T04:26:54Z", "type": "commit"}, {"oid": "89b3cb8e82d1a26af0c3fbc9759e933a87d7b12e", "url": "https://github.com/line/armeria/commit/89b3cb8e82d1a26af0c3fbc9759e933a87d7b12e", "message": "Deprecate whenTiming/TimedOut", "committedDate": "2020-10-13T05:32:34Z", "type": "commit"}, {"oid": "6e0536fac5dd1d4bdf859344435fe4e18bebeb64", "url": "https://github.com/line/armeria/commit/6e0536fac5dd1d4bdf859344435fe4e18bebeb64", "message": "Retest", "committedDate": "2020-10-13T06:31:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcyOTQ4OQ==", "url": "https://github.com/line/armeria/pull/3080#discussion_r503729489", "bodyText": "Thanks for the clean-up \ud83d\ude47", "author": "trustin", "createdAt": "2020-10-13T07:34:54Z", "path": "core/src/test/java/com/linecorp/armeria/internal/common/CancellationSchedulerTest.java", "diffHunk": "@@ -362,21 +413,24 @@ void evaluatePendingTimeout() {\n     @Test\n     void initializeOnlyOnce() {\n         final AtomicBoolean completed = new AtomicBoolean();\n-        final CancellationScheduler timeoutScheduler = new CancellationScheduler(0);\n+        final CancellationScheduler scheduler = new CancellationScheduler(0);\n         eventExecutor.execute(() -> {\n-            timeoutScheduler.init(eventExecutor, noopTask, MILLISECONDS.toNanos(100), timeoutCause);\n-            assertThat(timeoutScheduler.timeoutNanos()).isEqualTo(MILLISECONDS.toNanos(100));\n+            scheduler.init(eventExecutor, noopTask, MILLISECONDS.toNanos(100), cancellationCause);\n+            assertThat(scheduler.timeoutNanos()).isEqualTo(MILLISECONDS.toNanos(100));\n \n-            timeoutScheduler.init(eventExecutor, noopTask, MILLISECONDS.toNanos(1000), timeoutCause);\n-            assertThat(timeoutScheduler.timeoutNanos()).isEqualTo(MILLISECONDS.toNanos(100));\n+            scheduler.init(eventExecutor, noopTask, MILLISECONDS.toNanos(1000), cancellationCause);\n+            assertThat(scheduler.timeoutNanos()).isEqualTo(MILLISECONDS.toNanos(100));\n             completed.set(true);\n         });\n \n         await().untilTrue(completed);\n     }\n \n     static void assertTimeoutWithTolerance(long actualNanos, long expectedNanos) {\n-        assertThat(actualNanos)\n-                .isCloseTo(expectedNanos, Offset.offset(MILLISECONDS.toNanos(200)));\n+        assertTimeoutWithTolerance(actualNanos, expectedNanos, MILLISECONDS.toNanos(200));\n+    }\n+\n+    static void assertTimeoutWithTolerance(long actualNanos, long expectedNanos, long toleranceNanos) {\n+        assertThat(actualNanos).isCloseTo(expectedNanos, Offset.offset(toleranceNanos));", "originalCommit": "dcaf9196b733058e33959941fecfdd51d6ad54d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc0MTQ0Nw==", "url": "https://github.com/line/armeria/pull/3080#discussion_r503741447", "bodyText": "IIRC we never cancel the future returned by whenTimed/TimingOut(), i.e. any callbacks added by a user will be invoked only when the request has timed out.", "author": "trustin", "createdAt": "2020-10-13T07:54:30Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/CancellationScheduler.java", "diffHunk": "@@ -291,213 +261,252 @@ private void setTimeoutNanosFromNow(long timeoutNanos) {\n         } else {\n             final long startTimeNanos = System.nanoTime();\n             setPendingTimeoutNanos(timeoutNanos);\n-            addPendingTimeoutTask(() -> {\n+            addPendingTask(() -> {\n                 final long passedTimeNanos0 = System.nanoTime() - startTimeNanos;\n                 final long timeoutNanos0 = Math.max(1, timeoutNanos - passedTimeNanos0);\n                 setTimeoutNanosFromNow0(timeoutNanos0);\n             });\n         }\n     }\n \n-    private boolean setTimeoutNanosFromNow0(long newTimeoutNanos) {\n-        assert eventLoop.inEventLoop();\n-\n-        if (state == State.TIMED_OUT || !timeoutTask.canSchedule()) {\n-            return false;\n+    private void setTimeoutNanosFromNow0(long newTimeoutNanos) {\n+        assert eventLoop != null && eventLoop.inEventLoop() && task != null && initialCause != null;\n+        if (state == State.FINISHED || !task.canSchedule()) {\n+            return;\n         }\n-\n         // Cancel the previously scheduled timeout, if exists.\n         clearTimeout0(true);\n-\n-        final long passedTimeNanos = System.nanoTime() - firstExecutionTimeNanos;\n+        final long passedTimeNanos = System.nanoTime() - startTimeNanos;\n         timeoutNanos = LongMath.saturatedAdd(newTimeoutNanos, passedTimeNanos);\n-\n         if (newTimeoutNanos <= 0) {\n-            return true;\n+            return;\n         }\n-\n         state = State.SCHEDULED;\n-        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutNanos, TimeUnit.NANOSECONDS);\n-        return true;\n+        scheduledFuture = eventLoop.schedule(() -> invokeTask(initialCause), newTimeoutNanos, NANOSECONDS);\n+    }\n+\n+    public void finishNow() {\n+        assert initialCause != null;\n+        finishNow(initialCause);\n     }\n \n-    public void timeoutNow() {\n+    public void finishNow(Throwable cause) {\n         if (isInitialized()) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutNow0();\n+                finishNow0(cause);\n             } else {\n-                eventLoop.execute(this::timeoutNow0);\n+                eventLoop.execute(() -> finishNow0(cause));\n             }\n         } else {\n-            addPendingTimeoutTask(this::timeoutNow0);\n+            addPendingTask(() -> finishNow0(cause));\n         }\n     }\n \n-    private void timeoutNow0() {\n-        assert eventLoop.inEventLoop();\n-\n-        if (!timeoutTask.canSchedule()) {\n+    private void finishNow0(Throwable cause) {\n+        assert eventLoop != null && eventLoop.inEventLoop() && task != null;\n+        if (state == State.FINISHED || !task.canSchedule()) {\n             return;\n         }\n-\n-        switch (state) {\n-            case TIMED_OUT:\n-                return;\n-            case INIT:\n-            case INACTIVE:\n-                invokeTimeoutTask();\n-                return;\n-            case SCHEDULED:\n-                if (clearTimeout0(false)) {\n-                    invokeTimeoutTask();\n-                }\n-                return;\n-            default:\n-                throw new Error(); // Should not reach here.\n-        }\n-    }\n-\n-    private void addPendingTimeoutTask(Runnable pendingTimeoutTask) {\n-        if (!pendingTimeoutTaskUpdater.compareAndSet(this, null, pendingTimeoutTask)) {\n-            for (;;) {\n-                final Runnable oldPendingTimeoutTask = this.pendingTimeoutTask;\n-                if (oldPendingTimeoutTask == initializedPendingTimeoutTask) {\n-                    eventLoop.execute(pendingTimeoutTask);\n-                    break;\n-                }\n-\n-                final Runnable newPendingTimeoutTask = () -> {\n-                    oldPendingTimeoutTask.run();\n-                    pendingTimeoutTask.run();\n-                };\n-\n-                if (pendingTimeoutTaskUpdater.compareAndSet(this, oldPendingTimeoutTask,\n-                                                            newPendingTimeoutTask)) {\n-                    break;\n-                }\n+        if (state == State.SCHEDULED) {\n+            if (clearTimeout0(false)) {\n+                invokeTask(cause);\n             }\n+        } else {\n+            invokeTask(cause);\n         }\n     }\n \n-    private void setPendingTimeoutNanos(long pendingTimeoutNanos) {\n-        for (;;) {\n-            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n-            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n-                                                         pendingTimeoutNanos)) {\n-                break;\n-            }\n-        }\n+    public boolean isFinished() {\n+        return state == State.FINISHED;\n     }\n \n-    private void addPendingTimeoutNanos(long pendingTimeoutNanos) {\n-        for (;;) {\n-            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n-            final long newPendingTimeoutNanos =\n-                    LongMath.saturatedAdd(oldPendingTimeoutNanos, pendingTimeoutNanos);\n-            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n-                                                         newPendingTimeoutNanos)) {\n-                break;\n-            }\n-        }\n+    @Nullable\n+    public Throwable cause() {\n+        return cause;\n     }\n \n-    private void invokeTimeoutTask() {\n-        if (timeoutTask != null) {\n-            if (!whenTimingOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n-                if (timeoutTask.canSchedule()) {\n-                    whenTimingOut.doComplete();\n-                }\n-            }\n-\n-            // Set TIMED_OUT flag first to prevent duplicate execution\n-            state = State.TIMED_OUT;\n-\n-            // The returned value of `canSchedule()` could've been changed by the callbacks of `whenTimingOut`\n-            if (timeoutTask.canSchedule()) {\n-                timeoutTask.run();\n-            }\n-\n-            if (!whenTimedOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n-                whenTimedOut.doComplete();\n-            }\n-        }\n+    public long timeoutNanos() {\n+        return isInitialized() ? timeoutNanos : pendingTimeoutNanos;\n     }\n \n-    public boolean isTimedOut() {\n-        return state == State.TIMED_OUT;\n+    public long startTimeNanos() {\n+        return startTimeNanos;\n     }\n \n-    public long timeoutNanos() {\n-        return isInitialized() ? timeoutNanos : pendingTimeoutNanos;\n+    public CompletableFuture<Throwable> whenCancelling() {\n+        final CancellationFuture whenCancelling = this.whenCancelling;\n+        if (whenCancelling != null) {\n+            return whenCancelling;\n+        }\n+        final CancellationFuture cancellationFuture = new CancellationFuture();\n+        if (whenCancellingUpdater.compareAndSet(this, null, cancellationFuture)) {\n+            return cancellationFuture;\n+        } else {\n+            return this.whenCancelling;\n+        }\n     }\n \n-    private boolean isInitialized() {\n-        return pendingTimeoutTask == initializedPendingTimeoutTask;\n+    public CompletableFuture<Throwable> whenCancelled() {\n+        final CancellationFuture whenCancelled = this.whenCancelled;\n+        if (whenCancelled != null) {\n+            return whenCancelled;\n+        }\n+        final CancellationFuture cancellationFuture = new CancellationFuture();\n+        if (whenCancelledUpdater.compareAndSet(this, null, cancellationFuture)) {\n+            return cancellationFuture;\n+        } else {\n+            return this.whenCancelled;\n+        }\n     }\n \n+    @Deprecated\n     public CompletableFuture<Void> whenTimingOut() {\n         final TimeoutFuture whenTimingOut = this.whenTimingOut;\n         if (whenTimingOut != null) {\n             return whenTimingOut;\n         }\n-\n         final TimeoutFuture timeoutFuture = new TimeoutFuture();\n         if (whenTimingOutUpdater.compareAndSet(this, null, timeoutFuture)) {\n+            whenCancelling().thenAccept(cause -> {\n+                if (cause instanceof TimeoutException) {\n+                    timeoutFuture.doComplete();\n+                } else {\n+                    timeoutFuture.doCancel();\n+                }\n+            });\n             return timeoutFuture;\n         } else {\n             return this.whenTimingOut;\n         }\n     }\n \n+    @Deprecated\n     public CompletableFuture<Void> whenTimedOut() {\n         final TimeoutFuture whenTimedOut = this.whenTimedOut;\n         if (whenTimedOut != null) {\n             return whenTimedOut;\n         }\n-\n         final TimeoutFuture timeoutFuture = new TimeoutFuture();\n         if (whenTimedOutUpdater.compareAndSet(this, null, timeoutFuture)) {\n+            whenCancelled().thenAccept(cause -> {\n+                if (cause instanceof TimeoutException) {\n+                    timeoutFuture.doComplete();\n+                } else {\n+                    timeoutFuture.doCancel();", "originalCommit": "6e0536fac5dd1d4bdf859344435fe4e18bebeb64", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc0MTUyNQ==", "url": "https://github.com/line/armeria/pull/3080#discussion_r503741525", "bodyText": "IIRC we never cancel the future returned by whenTimed/TimingOut(), i.e. any callbacks added by a user will be invoked only when the request has timed out.", "author": "trustin", "createdAt": "2020-10-13T07:54:37Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/CancellationScheduler.java", "diffHunk": "@@ -291,213 +261,252 @@ private void setTimeoutNanosFromNow(long timeoutNanos) {\n         } else {\n             final long startTimeNanos = System.nanoTime();\n             setPendingTimeoutNanos(timeoutNanos);\n-            addPendingTimeoutTask(() -> {\n+            addPendingTask(() -> {\n                 final long passedTimeNanos0 = System.nanoTime() - startTimeNanos;\n                 final long timeoutNanos0 = Math.max(1, timeoutNanos - passedTimeNanos0);\n                 setTimeoutNanosFromNow0(timeoutNanos0);\n             });\n         }\n     }\n \n-    private boolean setTimeoutNanosFromNow0(long newTimeoutNanos) {\n-        assert eventLoop.inEventLoop();\n-\n-        if (state == State.TIMED_OUT || !timeoutTask.canSchedule()) {\n-            return false;\n+    private void setTimeoutNanosFromNow0(long newTimeoutNanos) {\n+        assert eventLoop != null && eventLoop.inEventLoop() && task != null && initialCause != null;\n+        if (state == State.FINISHED || !task.canSchedule()) {\n+            return;\n         }\n-\n         // Cancel the previously scheduled timeout, if exists.\n         clearTimeout0(true);\n-\n-        final long passedTimeNanos = System.nanoTime() - firstExecutionTimeNanos;\n+        final long passedTimeNanos = System.nanoTime() - startTimeNanos;\n         timeoutNanos = LongMath.saturatedAdd(newTimeoutNanos, passedTimeNanos);\n-\n         if (newTimeoutNanos <= 0) {\n-            return true;\n+            return;\n         }\n-\n         state = State.SCHEDULED;\n-        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutNanos, TimeUnit.NANOSECONDS);\n-        return true;\n+        scheduledFuture = eventLoop.schedule(() -> invokeTask(initialCause), newTimeoutNanos, NANOSECONDS);\n+    }\n+\n+    public void finishNow() {\n+        assert initialCause != null;\n+        finishNow(initialCause);\n     }\n \n-    public void timeoutNow() {\n+    public void finishNow(Throwable cause) {\n         if (isInitialized()) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutNow0();\n+                finishNow0(cause);\n             } else {\n-                eventLoop.execute(this::timeoutNow0);\n+                eventLoop.execute(() -> finishNow0(cause));\n             }\n         } else {\n-            addPendingTimeoutTask(this::timeoutNow0);\n+            addPendingTask(() -> finishNow0(cause));\n         }\n     }\n \n-    private void timeoutNow0() {\n-        assert eventLoop.inEventLoop();\n-\n-        if (!timeoutTask.canSchedule()) {\n+    private void finishNow0(Throwable cause) {\n+        assert eventLoop != null && eventLoop.inEventLoop() && task != null;\n+        if (state == State.FINISHED || !task.canSchedule()) {\n             return;\n         }\n-\n-        switch (state) {\n-            case TIMED_OUT:\n-                return;\n-            case INIT:\n-            case INACTIVE:\n-                invokeTimeoutTask();\n-                return;\n-            case SCHEDULED:\n-                if (clearTimeout0(false)) {\n-                    invokeTimeoutTask();\n-                }\n-                return;\n-            default:\n-                throw new Error(); // Should not reach here.\n-        }\n-    }\n-\n-    private void addPendingTimeoutTask(Runnable pendingTimeoutTask) {\n-        if (!pendingTimeoutTaskUpdater.compareAndSet(this, null, pendingTimeoutTask)) {\n-            for (;;) {\n-                final Runnable oldPendingTimeoutTask = this.pendingTimeoutTask;\n-                if (oldPendingTimeoutTask == initializedPendingTimeoutTask) {\n-                    eventLoop.execute(pendingTimeoutTask);\n-                    break;\n-                }\n-\n-                final Runnable newPendingTimeoutTask = () -> {\n-                    oldPendingTimeoutTask.run();\n-                    pendingTimeoutTask.run();\n-                };\n-\n-                if (pendingTimeoutTaskUpdater.compareAndSet(this, oldPendingTimeoutTask,\n-                                                            newPendingTimeoutTask)) {\n-                    break;\n-                }\n+        if (state == State.SCHEDULED) {\n+            if (clearTimeout0(false)) {\n+                invokeTask(cause);\n             }\n+        } else {\n+            invokeTask(cause);\n         }\n     }\n \n-    private void setPendingTimeoutNanos(long pendingTimeoutNanos) {\n-        for (;;) {\n-            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n-            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n-                                                         pendingTimeoutNanos)) {\n-                break;\n-            }\n-        }\n+    public boolean isFinished() {\n+        return state == State.FINISHED;\n     }\n \n-    private void addPendingTimeoutNanos(long pendingTimeoutNanos) {\n-        for (;;) {\n-            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n-            final long newPendingTimeoutNanos =\n-                    LongMath.saturatedAdd(oldPendingTimeoutNanos, pendingTimeoutNanos);\n-            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n-                                                         newPendingTimeoutNanos)) {\n-                break;\n-            }\n-        }\n+    @Nullable\n+    public Throwable cause() {\n+        return cause;\n     }\n \n-    private void invokeTimeoutTask() {\n-        if (timeoutTask != null) {\n-            if (!whenTimingOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n-                if (timeoutTask.canSchedule()) {\n-                    whenTimingOut.doComplete();\n-                }\n-            }\n-\n-            // Set TIMED_OUT flag first to prevent duplicate execution\n-            state = State.TIMED_OUT;\n-\n-            // The returned value of `canSchedule()` could've been changed by the callbacks of `whenTimingOut`\n-            if (timeoutTask.canSchedule()) {\n-                timeoutTask.run();\n-            }\n-\n-            if (!whenTimedOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n-                whenTimedOut.doComplete();\n-            }\n-        }\n+    public long timeoutNanos() {\n+        return isInitialized() ? timeoutNanos : pendingTimeoutNanos;\n     }\n \n-    public boolean isTimedOut() {\n-        return state == State.TIMED_OUT;\n+    public long startTimeNanos() {\n+        return startTimeNanos;\n     }\n \n-    public long timeoutNanos() {\n-        return isInitialized() ? timeoutNanos : pendingTimeoutNanos;\n+    public CompletableFuture<Throwable> whenCancelling() {\n+        final CancellationFuture whenCancelling = this.whenCancelling;\n+        if (whenCancelling != null) {\n+            return whenCancelling;\n+        }\n+        final CancellationFuture cancellationFuture = new CancellationFuture();\n+        if (whenCancellingUpdater.compareAndSet(this, null, cancellationFuture)) {\n+            return cancellationFuture;\n+        } else {\n+            return this.whenCancelling;\n+        }\n     }\n \n-    private boolean isInitialized() {\n-        return pendingTimeoutTask == initializedPendingTimeoutTask;\n+    public CompletableFuture<Throwable> whenCancelled() {\n+        final CancellationFuture whenCancelled = this.whenCancelled;\n+        if (whenCancelled != null) {\n+            return whenCancelled;\n+        }\n+        final CancellationFuture cancellationFuture = new CancellationFuture();\n+        if (whenCancelledUpdater.compareAndSet(this, null, cancellationFuture)) {\n+            return cancellationFuture;\n+        } else {\n+            return this.whenCancelled;\n+        }\n     }\n \n+    @Deprecated\n     public CompletableFuture<Void> whenTimingOut() {\n         final TimeoutFuture whenTimingOut = this.whenTimingOut;\n         if (whenTimingOut != null) {\n             return whenTimingOut;\n         }\n-\n         final TimeoutFuture timeoutFuture = new TimeoutFuture();\n         if (whenTimingOutUpdater.compareAndSet(this, null, timeoutFuture)) {\n+            whenCancelling().thenAccept(cause -> {\n+                if (cause instanceof TimeoutException) {\n+                    timeoutFuture.doComplete();\n+                } else {\n+                    timeoutFuture.doCancel();", "originalCommit": "6e0536fac5dd1d4bdf859344435fe4e18bebeb64", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc0MjU1OQ==", "url": "https://github.com/line/armeria/pull/3080#discussion_r503742559", "bodyText": "Can we extend UnmodifiableFuture<Throwable> here?", "author": "trustin", "createdAt": "2020-10-13T07:56:13Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/CancellationScheduler.java", "diffHunk": "@@ -291,213 +261,252 @@ private void setTimeoutNanosFromNow(long timeoutNanos) {\n         } else {\n             final long startTimeNanos = System.nanoTime();\n             setPendingTimeoutNanos(timeoutNanos);\n-            addPendingTimeoutTask(() -> {\n+            addPendingTask(() -> {\n                 final long passedTimeNanos0 = System.nanoTime() - startTimeNanos;\n                 final long timeoutNanos0 = Math.max(1, timeoutNanos - passedTimeNanos0);\n                 setTimeoutNanosFromNow0(timeoutNanos0);\n             });\n         }\n     }\n \n-    private boolean setTimeoutNanosFromNow0(long newTimeoutNanos) {\n-        assert eventLoop.inEventLoop();\n-\n-        if (state == State.TIMED_OUT || !timeoutTask.canSchedule()) {\n-            return false;\n+    private void setTimeoutNanosFromNow0(long newTimeoutNanos) {\n+        assert eventLoop != null && eventLoop.inEventLoop() && task != null && initialCause != null;\n+        if (state == State.FINISHED || !task.canSchedule()) {\n+            return;\n         }\n-\n         // Cancel the previously scheduled timeout, if exists.\n         clearTimeout0(true);\n-\n-        final long passedTimeNanos = System.nanoTime() - firstExecutionTimeNanos;\n+        final long passedTimeNanos = System.nanoTime() - startTimeNanos;\n         timeoutNanos = LongMath.saturatedAdd(newTimeoutNanos, passedTimeNanos);\n-\n         if (newTimeoutNanos <= 0) {\n-            return true;\n+            return;\n         }\n-\n         state = State.SCHEDULED;\n-        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutNanos, TimeUnit.NANOSECONDS);\n-        return true;\n+        scheduledFuture = eventLoop.schedule(() -> invokeTask(initialCause), newTimeoutNanos, NANOSECONDS);\n+    }\n+\n+    public void finishNow() {\n+        assert initialCause != null;\n+        finishNow(initialCause);\n     }\n \n-    public void timeoutNow() {\n+    public void finishNow(Throwable cause) {\n         if (isInitialized()) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutNow0();\n+                finishNow0(cause);\n             } else {\n-                eventLoop.execute(this::timeoutNow0);\n+                eventLoop.execute(() -> finishNow0(cause));\n             }\n         } else {\n-            addPendingTimeoutTask(this::timeoutNow0);\n+            addPendingTask(() -> finishNow0(cause));\n         }\n     }\n \n-    private void timeoutNow0() {\n-        assert eventLoop.inEventLoop();\n-\n-        if (!timeoutTask.canSchedule()) {\n+    private void finishNow0(Throwable cause) {\n+        assert eventLoop != null && eventLoop.inEventLoop() && task != null;\n+        if (state == State.FINISHED || !task.canSchedule()) {\n             return;\n         }\n-\n-        switch (state) {\n-            case TIMED_OUT:\n-                return;\n-            case INIT:\n-            case INACTIVE:\n-                invokeTimeoutTask();\n-                return;\n-            case SCHEDULED:\n-                if (clearTimeout0(false)) {\n-                    invokeTimeoutTask();\n-                }\n-                return;\n-            default:\n-                throw new Error(); // Should not reach here.\n-        }\n-    }\n-\n-    private void addPendingTimeoutTask(Runnable pendingTimeoutTask) {\n-        if (!pendingTimeoutTaskUpdater.compareAndSet(this, null, pendingTimeoutTask)) {\n-            for (;;) {\n-                final Runnable oldPendingTimeoutTask = this.pendingTimeoutTask;\n-                if (oldPendingTimeoutTask == initializedPendingTimeoutTask) {\n-                    eventLoop.execute(pendingTimeoutTask);\n-                    break;\n-                }\n-\n-                final Runnable newPendingTimeoutTask = () -> {\n-                    oldPendingTimeoutTask.run();\n-                    pendingTimeoutTask.run();\n-                };\n-\n-                if (pendingTimeoutTaskUpdater.compareAndSet(this, oldPendingTimeoutTask,\n-                                                            newPendingTimeoutTask)) {\n-                    break;\n-                }\n+        if (state == State.SCHEDULED) {\n+            if (clearTimeout0(false)) {\n+                invokeTask(cause);\n             }\n+        } else {\n+            invokeTask(cause);\n         }\n     }\n \n-    private void setPendingTimeoutNanos(long pendingTimeoutNanos) {\n-        for (;;) {\n-            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n-            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n-                                                         pendingTimeoutNanos)) {\n-                break;\n-            }\n-        }\n+    public boolean isFinished() {\n+        return state == State.FINISHED;\n     }\n \n-    private void addPendingTimeoutNanos(long pendingTimeoutNanos) {\n-        for (;;) {\n-            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n-            final long newPendingTimeoutNanos =\n-                    LongMath.saturatedAdd(oldPendingTimeoutNanos, pendingTimeoutNanos);\n-            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n-                                                         newPendingTimeoutNanos)) {\n-                break;\n-            }\n-        }\n+    @Nullable\n+    public Throwable cause() {\n+        return cause;\n     }\n \n-    private void invokeTimeoutTask() {\n-        if (timeoutTask != null) {\n-            if (!whenTimingOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n-                if (timeoutTask.canSchedule()) {\n-                    whenTimingOut.doComplete();\n-                }\n-            }\n-\n-            // Set TIMED_OUT flag first to prevent duplicate execution\n-            state = State.TIMED_OUT;\n-\n-            // The returned value of `canSchedule()` could've been changed by the callbacks of `whenTimingOut`\n-            if (timeoutTask.canSchedule()) {\n-                timeoutTask.run();\n-            }\n-\n-            if (!whenTimedOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n-                whenTimedOut.doComplete();\n-            }\n-        }\n+    public long timeoutNanos() {\n+        return isInitialized() ? timeoutNanos : pendingTimeoutNanos;\n     }\n \n-    public boolean isTimedOut() {\n-        return state == State.TIMED_OUT;\n+    public long startTimeNanos() {\n+        return startTimeNanos;\n     }\n \n-    public long timeoutNanos() {\n-        return isInitialized() ? timeoutNanos : pendingTimeoutNanos;\n+    public CompletableFuture<Throwable> whenCancelling() {\n+        final CancellationFuture whenCancelling = this.whenCancelling;\n+        if (whenCancelling != null) {\n+            return whenCancelling;\n+        }\n+        final CancellationFuture cancellationFuture = new CancellationFuture();\n+        if (whenCancellingUpdater.compareAndSet(this, null, cancellationFuture)) {\n+            return cancellationFuture;\n+        } else {\n+            return this.whenCancelling;\n+        }\n     }\n \n-    private boolean isInitialized() {\n-        return pendingTimeoutTask == initializedPendingTimeoutTask;\n+    public CompletableFuture<Throwable> whenCancelled() {\n+        final CancellationFuture whenCancelled = this.whenCancelled;\n+        if (whenCancelled != null) {\n+            return whenCancelled;\n+        }\n+        final CancellationFuture cancellationFuture = new CancellationFuture();\n+        if (whenCancelledUpdater.compareAndSet(this, null, cancellationFuture)) {\n+            return cancellationFuture;\n+        } else {\n+            return this.whenCancelled;\n+        }\n     }\n \n+    @Deprecated\n     public CompletableFuture<Void> whenTimingOut() {\n         final TimeoutFuture whenTimingOut = this.whenTimingOut;\n         if (whenTimingOut != null) {\n             return whenTimingOut;\n         }\n-\n         final TimeoutFuture timeoutFuture = new TimeoutFuture();\n         if (whenTimingOutUpdater.compareAndSet(this, null, timeoutFuture)) {\n+            whenCancelling().thenAccept(cause -> {\n+                if (cause instanceof TimeoutException) {\n+                    timeoutFuture.doComplete();\n+                } else {\n+                    timeoutFuture.doCancel();\n+                }\n+            });\n             return timeoutFuture;\n         } else {\n             return this.whenTimingOut;\n         }\n     }\n \n+    @Deprecated\n     public CompletableFuture<Void> whenTimedOut() {\n         final TimeoutFuture whenTimedOut = this.whenTimedOut;\n         if (whenTimedOut != null) {\n             return whenTimedOut;\n         }\n-\n         final TimeoutFuture timeoutFuture = new TimeoutFuture();\n         if (whenTimedOutUpdater.compareAndSet(this, null, timeoutFuture)) {\n+            whenCancelled().thenAccept(cause -> {\n+                if (cause instanceof TimeoutException) {\n+                    timeoutFuture.doComplete();\n+                } else {\n+                    timeoutFuture.doCancel();\n+                }\n+            });\n             return timeoutFuture;\n         } else {\n             return this.whenTimedOut;\n         }\n     }\n \n-    @Nullable\n-    public Long startTimeNanos() {\n-        return state != State.INIT ? firstExecutionTimeNanos : null;\n+    private boolean isInitialized() {\n+        return pendingTask == noopPendingTask && eventLoop != null;\n+    }\n+\n+    private void addPendingTask(Runnable pendingTask) {\n+        if (!pendingTaskUpdater.compareAndSet(this, null, pendingTask)) {\n+            for (;;) {\n+                final Runnable oldPendingTask = this.pendingTask;\n+                assert oldPendingTask != null;\n+                if (oldPendingTask == noopPendingTask) {\n+                    assert eventLoop != null;\n+                    eventLoop.execute(pendingTask);\n+                    break;\n+                }\n+                final Runnable newPendingTask = () -> {\n+                    oldPendingTask.run();\n+                    pendingTask.run();\n+                };\n+                if (pendingTaskUpdater.compareAndSet(this, oldPendingTask, newPendingTask)) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    private void setPendingTimeoutNanos(long pendingTimeoutNanos) {\n+        for (;;) {\n+            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n+            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos, pendingTimeoutNanos)) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private void addPendingTimeoutNanos(long pendingTimeoutNanos) {\n+        for (;;) {\n+            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n+            final long newPendingTimeoutNanos = LongMath.saturatedAdd(oldPendingTimeoutNanos,\n+                                                                      pendingTimeoutNanos);\n+            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n+                                                         newPendingTimeoutNanos)) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private void invokeTask(Throwable cause) {\n+        if (task == null) {\n+            return;\n+        }\n+        if (task.canSchedule()) {\n+            whenCancelling().complete(cause);\n+        }\n+        // Set state first to prevent duplicate execution\n+        state = State.FINISHED;\n+        // The returned value of `canSchedule()` could've been changed by the callbacks of `whenCancelling`\n+        if (task.canSchedule()) {\n+            task.run(cause);\n+        }\n+        this.cause = cause;\n+        whenCancelled().complete(cause);\n     }\n \n     @Nullable\n     @VisibleForTesting\n-    ScheduledFuture<?> timeoutFuture() {\n-        return timeoutFuture;\n+    ScheduledFuture<?> scheduledFuture() {\n+        return scheduledFuture;\n     }\n \n     @VisibleForTesting\n     State state() {\n         return state;\n     }\n \n+    enum State {\n+        INIT,\n+        INACTIVE,\n+        SCHEDULED,\n+        FINISHED\n+    }\n+\n     /**\n-     * A timeout task that is invoked when the deadline exceeded.\n+     * A cancellation task invoked by the scheduler when its timeout exceeds or invoke by the user.\n      */\n-    public interface TimeoutTask extends Runnable {\n+    public interface CancellationTask {\n         /**\n-         * Returns {@code true} if the timeout task can be scheduled.\n+         * Returns {@code true} if the cancellation task can be scheduled.\n          */\n         boolean canSchedule();\n \n         /**\n-         * Invoked when the deadline exceeded.\n+         * Invoked by the scheduler with the cause of cancellation.\n          */\n-        @Override\n-        void run();\n+        void run(Throwable cause);\n+    }\n+\n+    private static class CancellationFuture extends CompletableFuture<Throwable> {", "originalCommit": "6e0536fac5dd1d4bdf859344435fe4e18bebeb64", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc1MzEzMg==", "url": "https://github.com/line/armeria/pull/3080#discussion_r503753132", "bodyText": "We still need these methods because the delegate's methods might have different behavior than the default methods.", "author": "trustin", "createdAt": "2020-10-13T08:12:38Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientRequestContextWrapper.java", "diffHunk": "@@ -140,32 +140,12 @@ public void cancel(Throwable cause) {\n         delegate().cancel(cause);\n     }\n \n-    @Override\n-    public void cancel() {\n-        delegate().cancel();\n-    }\n-\n-    @Override\n-    public void timeoutNow() {\n-        delegate().timeoutNow();\n-    }\n-\n     @Nullable\n     @Override\n     public Throwable cancellationCause() {\n         return delegate().cancellationCause();\n     }\n \n-    @Override\n-    public boolean isCancelled() {\n-        return delegate().isCancelled();\n-    }\n-\n-    @Override\n-    public boolean isTimedOut() {\n-        return delegate().isTimedOut();\n-    }\n-", "originalCommit": "ac49515657c5f822928a28c0cfabec24b413d864", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc1MzYzOQ==", "url": "https://github.com/line/armeria/pull/3080#discussion_r503753639", "bodyText": "Ditto", "author": "trustin", "createdAt": "2020-10-13T08:13:27Z", "path": "core/src/main/java/com/linecorp/armeria/server/ServiceRequestContextWrapper.java", "diffHunk": "@@ -148,32 +148,12 @@ public void cancel(Throwable cause) {\n         delegate().cancel(cause);\n     }\n \n-    @Override\n-    public void cancel() {\n-        delegate().cancel();\n-    }\n-\n-    @Override\n-    public void timeoutNow() {\n-        delegate().timeoutNow();\n-    }\n-\n     @Nullable\n     @Override\n     public Throwable cancellationCause() {\n         return delegate().cancellationCause();\n     }\n \n-    @Override\n-    public boolean isCancelled() {\n-        return delegate().isCancelled();\n-    }\n-\n-    @Override\n-    public boolean isTimedOut() {\n-        return delegate().isTimedOut();\n-    }\n-", "originalCommit": "ac49515657c5f822928a28c0cfabec24b413d864", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "46b7f31a91537de8f0a65fb8ff82e3998253c118", "url": "https://github.com/line/armeria/commit/46b7f31a91537de8f0a65fb8ff82e3998253c118", "message": "Address reviews", "committedDate": "2020-10-13T19:55:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDYwNTA3Nw==", "url": "https://github.com/line/armeria/pull/3080#discussion_r504605077", "bodyText": "Add requireNonNull(cause, \"cause\")?", "author": "ikhoon", "createdAt": "2020-10-14T11:34:11Z", "path": "core/src/main/java/com/linecorp/armeria/server/DefaultServiceRequestContext.java", "diffHunk": "@@ -283,48 +283,62 @@ public SSLSession sslSession() {\n \n     @Override\n     public long requestTimeoutMillis() {\n-        return TimeUnit.NANOSECONDS.toMillis(requestTimeoutScheduler.timeoutNanos());\n+        return TimeUnit.NANOSECONDS.toMillis(requestCancellationScheduler.timeoutNanos());\n     }\n \n     @Override\n     public void clearRequestTimeout() {\n-        requestTimeoutScheduler.clearTimeout();\n+        requestCancellationScheduler.clearTimeout();\n     }\n \n     @Override\n     public void setRequestTimeoutMillis(TimeoutMode mode, long requestTimeoutMillis) {\n-        requestTimeoutScheduler.setTimeoutNanos(requireNonNull(mode, \"mode\"),\n-                                                TimeUnit.MILLISECONDS.toNanos(requestTimeoutMillis));\n+        requestCancellationScheduler.setTimeoutNanos(requireNonNull(mode, \"mode\"),\n+                                                     TimeUnit.MILLISECONDS.toNanos(requestTimeoutMillis));\n     }\n \n     @Override\n     public void setRequestTimeout(TimeoutMode mode, Duration requestTimeout) {\n-        requestTimeoutScheduler.setTimeoutNanos(requireNonNull(mode, \"mode\"),\n-                                                requireNonNull(requestTimeout, \"requestTimeout\").toNanos());\n+        requestCancellationScheduler.setTimeoutNanos(requireNonNull(mode, \"mode\"),\n+                                                     requireNonNull(requestTimeout, \"requestTimeout\")\n+                                                             .toNanos());\n     }\n \n-    TimeoutScheduler requestTimeoutScheduler() {\n-        return requestTimeoutScheduler;\n+    CancellationScheduler requestCancellationScheduler() {\n+        return requestCancellationScheduler;\n     }\n \n     @Override\n-    public void timeoutNow() {\n-        requestTimeoutScheduler.timeoutNow();\n+    public void cancel(Throwable cause) {\n+        requestCancellationScheduler.finishNow(cause);", "originalCommit": "46b7f31a91537de8f0a65fb8ff82e3998253c118", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDYwOTQzMg==", "url": "https://github.com/line/armeria/pull/3080#discussion_r504609432", "bodyText": "This should be called only when a timeout has exceeded.", "author": "ikhoon", "createdAt": "2020-10-14T11:42:34Z", "path": "grpc/src/main/java/com/linecorp/armeria/internal/client/grpc/ArmeriaClientCall.java", "diffHunk": "@@ -194,7 +194,7 @@ public void start(Listener<O> responseListener, Metadata metadata) {\n                 close(status, new Metadata());\n             } else {\n                 ctx.setResponseTimeout(TimeoutMode.SET_FROM_NOW, Duration.ofNanos(remainingNanos));\n-                ctx.whenResponseTimingOut().thenRun(() -> {\n+                ctx.whenResponseCancelling().thenRun(() -> {\n                     final Status status = Status.DEADLINE_EXCEEDED\n                             .augmentDescription(\"deadline exceeded after \" + remainingNanos + \"ns.\");", "originalCommit": "46b7f31a91537de8f0a65fb8ff82e3998253c118", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "eb8eda469635527a579107ced391d769fb7f2bab", "url": "https://github.com/line/armeria/commit/eb8eda469635527a579107ced391d769fb7f2bab", "message": "CancellationException", "committedDate": "2020-10-14T18:33:47Z", "type": "commit"}, {"oid": "52335981dba959f9dac1ec0e6a80a83973e316db", "url": "https://github.com/line/armeria/commit/52335981dba959f9dac1ec0e6a80a83973e316db", "message": "checkstyle", "committedDate": "2020-10-14T18:54:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAyNzk5OQ==", "url": "https://github.com/line/armeria/pull/3080#discussion_r506027999", "bodyText": "Thanks!", "author": "minwoox", "createdAt": "2020-10-16T03:37:00Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpResponseDecoder.java", "diffHunk": "@@ -375,28 +376,28 @@ private void cancelTimeoutOrLog(@Nullable Throwable cause,\n \n         void initTimeout() {\n             if (ctx instanceof DefaultClientRequestContext) {\n-                final TimeoutScheduler responseTimeoutScheduler =\n-                        ((DefaultClientRequestContext) ctx).responseTimeoutScheduler();\n-                responseTimeoutScheduler.init(ctx.eventLoop(), newTimeoutTask(),\n-                                      TimeUnit.MILLISECONDS.toNanos(responseTimeoutMillis));\n+                final CancellationScheduler responseCancellationScheduler =\n+                        ((DefaultClientRequestContext) ctx).responseCancellationScheduler();\n+                responseCancellationScheduler.init(ctx.eventLoop(), newCancellationTask(),\n+                                                   TimeUnit.MILLISECONDS.toNanos(responseTimeoutMillis),\n+                                                   ResponseTimeoutException.get());\n             }\n         }\n \n-        private TimeoutTask newTimeoutTask() {\n-            return new TimeoutTask() {\n+        private CancellationTask newCancellationTask() {\n+            return new CancellationTask() {\n                 @Override\n                 public boolean canSchedule() {\n                     return delegate.isOpen() && state != State.DONE;\n                 }\n \n                 @Override\n-                public void run() {\n-                    final ResponseTimeoutException cause = ResponseTimeoutException.get();\n+                public void run(Throwable cause) {\n+                    assert ctx != null;", "originalCommit": "52335981dba959f9dac1ec0e6a80a83973e316db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}