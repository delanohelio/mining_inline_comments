{"pr_number": 2686, "pr_title": "Support servlet API", "pr_createdAt": "2020-05-03T08:35:47Z", "pr_url": "https://github.com/line/armeria/pull/2686", "timeline": [{"oid": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "url": "https://github.com/line/armeria/commit/2a9d3d0095bc106151ad97fa1427680e13a362aa", "message": "Rename module servlet to servlet4", "committedDate": "2020-07-27T04:51:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI3NjE5NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419276195", "bodyText": "Because this class is not used, could you remove this?", "author": "minwoox", "createdAt": "2020-05-04T08:16:47Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/AbstractChannelHandler.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.util.internal.TypeParameterMatcher;\n+\n+/**\n+ *  An abstract netty ChannelHandler.\n+ */\n+public abstract class AbstractChannelHandler<I,O> extends ChannelDuplexHandler {", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI3Nzk4OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419277988", "bodyText": "This could be final.", "author": "minwoox", "createdAt": "2020-05-04T08:20:24Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private ServletHttpExchange servletHttpExchange;\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI3ODEzMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419278132", "bodyText": "It doesn't look nullable. Is it?", "author": "minwoox", "createdAt": "2020-05-04T08:20:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI3Nzk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI3ODYzMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419278631", "bodyText": "This must not be a field because of concurrency. How about just passing it when calling process method?", "author": "minwoox", "createdAt": "2020-05-04T08:21:43Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private ServletHttpExchange servletHttpExchange;", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI3OTIxOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419279218", "bodyText": "We use of for this purpose.\nServletHttpExchange.of(...)", "author": "minwoox", "createdAt": "2020-05-04T08:22:59Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private ServletHttpExchange servletHttpExchange;\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    /**\n+     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n+     */\n+    public DefaultServletService(ServletContextImpl servletContext) {\n+        this.servletContext = servletContext;\n+    }\n+\n+    /**\n+     * handles {@link HttpRequest} and forward to Servlet APIs.\n+     */\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n+        final HttpResponseWriter res = HttpResponse.streaming();\n+        req.aggregate().handle((aReq, cause) -> {\n+            servletHttpExchange = ServletHttpExchange.newInstance(", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4MDMyMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419280322", "bodyText": "We don't need to do the type-casting.", "author": "minwoox", "createdAt": "2020-05-04T08:25:02Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private ServletHttpExchange servletHttpExchange;\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    /**\n+     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n+     */\n+    public DefaultServletService(ServletContextImpl servletContext) {\n+        this.servletContext = servletContext;\n+    }\n+\n+    /**\n+     * handles {@link HttpRequest} and forward to Servlet APIs.\n+     */\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n+        final HttpResponseWriter res = HttpResponse.streaming();\n+        req.aggregate().handle((aReq, cause) -> {\n+            servletHttpExchange = ServletHttpExchange.newInstance(\n+                    servletContext, (DefaultServiceRequestContext) ctx, aReq);", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4MDY5OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419280698", "bodyText": "Let's handle a case where cause is not null.", "author": "minwoox", "createdAt": "2020-05-04T08:25:44Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private ServletHttpExchange servletHttpExchange;\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    /**\n+     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n+     */\n+    public DefaultServletService(ServletContextImpl servletContext) {\n+        this.servletContext = servletContext;\n+    }\n+\n+    /**\n+     * handles {@link HttpRequest} and forward to Servlet APIs.\n+     */\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n+        final HttpResponseWriter res = HttpResponse.streaming();\n+        req.aggregate().handle((aReq, cause) -> {", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4MjQ3Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419282473", "bodyText": "Shouldn't we return here if dispatcher is null", "author": "minwoox", "createdAt": "2020-05-04T08:29:11Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private ServletHttpExchange servletHttpExchange;\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    /**\n+     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n+     */\n+    public DefaultServletService(ServletContextImpl servletContext) {\n+        this.servletContext = servletContext;\n+    }\n+\n+    /**\n+     * handles {@link HttpRequest} and forward to Servlet APIs.\n+     */\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n+        final HttpResponseWriter res = HttpResponse.streaming();\n+        req.aggregate().handle((aReq, cause) -> {\n+            servletHttpExchange = ServletHttpExchange.newInstance(\n+                    servletContext, (DefaultServiceRequestContext) ctx, aReq);\n+            process(res);\n+            return null;\n+        });\n+        return res;\n+    }\n+\n+    private void process(HttpResponseWriter res) {\n+        final ServletHttpRequest httpServletRequest = servletHttpExchange.getRequest();\n+        final ServletHttpResponse httpServletResponse = servletHttpExchange.getResponse();\n+        try {\n+            final ServletRequestDispatcher dispatcher =\n+                    servletHttpExchange.getServletContext()\n+                                       .getRequestDispatcher(httpServletRequest.getRequestURI());\n+            if (dispatcher == null) {\n+                res.tryWrite(ResponseHeaders.of(HttpStatus.NOT_FOUND));", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgxMTEwMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419811101", "bodyText": "If dispatcher is null, I think we should return NOT_FOUND. I will add return; command here. Do you have another solution?", "author": "dominhhien", "createdAt": "2020-05-05T00:53:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4MjQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4MzIxNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419283217", "bodyText": "ctx is not used. Could you remove that?", "author": "minwoox", "createdAt": "2020-05-04T08:30:37Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;\n+    private boolean isHttpKeepAlive;\n+\n+    private ServletHttpExchange() {\n+    }\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n+                                                  DefaultServiceRequestContext context,\n+                                                  AggregatedHttpRequest request) {\n+        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n+        final ServletHttpExchange instance = new ServletHttpExchange();\n+        instance.servletContext = servletContext;\n+        instance.channelHandlerContext = context;\n+\n+        //Create a new servlet request object\n+        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n+        //Create a new servlet response object\n+        instance.response = ServletHttpResponse.newInstance(instance);\n+        return instance;\n+    }\n+\n+    /**\n+     * Whether the pipe is active.\n+     */\n+    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n+        return true;\n+    }\n+\n+    /**\n+     * Is http keep alive.\n+     */\n+    public boolean isHttpKeepAlive() {\n+        return isHttpKeepAlive;\n+    }\n+\n+    /**\n+     * Get http servlet request.\n+     */\n+    public ServletHttpRequest getRequest() {\n+        return request;\n+    }\n+\n+    /**\n+     * Get servlet context.\n+     */\n+    public ServletContextImpl getServletContext() {\n+        return servletContext;\n+    }\n+\n+    /**\n+     * Get http servlet response.\n+     */\n+    public ServletHttpResponse getResponse() {\n+        return response;\n+    }\n+\n+    /**\n+     * Get channel handler context.\n+     */\n+    public DefaultServiceRequestContext getChannelHandlerContext() {\n+        return channelHandlerContext;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return servletContext.getServerAddress();\n+    }\n+\n+    /**\n+     * Get local address.\n+     */\n+    public InetSocketAddress getLocalAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n+        if (socketAddress == null) {\n+            return null;\n+        }\n+        if (socketAddress instanceof InetSocketAddress) {\n+            return (InetSocketAddress) socketAddress;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get remote address.\n+     */\n+    public InetSocketAddress getRemoteAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.remoteAddress();\n+        if (socketAddress == null) {\n+            return null;\n+        }\n+        if (socketAddress instanceof InetSocketAddress) {\n+            return (InetSocketAddress) socketAddress;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Convert {@link HttpRequest} to {@link DefaultFullHttpRequest}.\n+     */\n+    private static DefaultFullHttpRequest parseHttpRequest(ServiceRequestContext ctx,", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4NTUwNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419285505", "bodyText": "This is not used.", "author": "minwoox", "createdAt": "2020-05-04T08:35:15Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4NjAzNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419286036", "bodyText": "How about passing and creating(if needed) all parameters so that we can make these all final?", "author": "minwoox", "createdAt": "2020-05-04T08:36:14Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4NjgzNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419286835", "bodyText": "I don't see any code calling this what is this for?", "author": "minwoox", "createdAt": "2020-05-04T08:37:48Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;\n+    private boolean isHttpKeepAlive;\n+\n+    private ServletHttpExchange() {\n+    }\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n+                                                  DefaultServiceRequestContext context,\n+                                                  AggregatedHttpRequest request) {\n+        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n+        final ServletHttpExchange instance = new ServletHttpExchange();\n+        instance.servletContext = servletContext;\n+        instance.channelHandlerContext = context;\n+\n+        //Create a new servlet request object\n+        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n+        //Create a new servlet response object\n+        instance.response = ServletHttpResponse.newInstance(instance);\n+        return instance;\n+    }\n+\n+    /**\n+     * Whether the pipe is active.\n+     */\n+    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4Njg5NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419286894", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-05-04T08:37:54Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;\n+    private boolean isHttpKeepAlive;\n+\n+    private ServletHttpExchange() {\n+    }\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n+                                                  DefaultServiceRequestContext context,\n+                                                  AggregatedHttpRequest request) {\n+        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n+        final ServletHttpExchange instance = new ServletHttpExchange();\n+        instance.servletContext = servletContext;\n+        instance.channelHandlerContext = context;\n+\n+        //Create a new servlet request object\n+        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n+        //Create a new servlet response object\n+        instance.response = ServletHttpResponse.newInstance(instance);\n+        return instance;\n+    }\n+\n+    /**\n+     * Whether the pipe is active.\n+     */\n+    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n+        return true;\n+    }\n+\n+    /**\n+     * Is http keep alive.\n+     */\n+    public boolean isHttpKeepAlive() {", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4Nzg1OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419287859", "bodyText": "It's never null, so we don't need this check", "author": "minwoox", "createdAt": "2020-05-04T08:39:43Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;\n+    private boolean isHttpKeepAlive;\n+\n+    private ServletHttpExchange() {\n+    }\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n+                                                  DefaultServiceRequestContext context,\n+                                                  AggregatedHttpRequest request) {\n+        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n+        final ServletHttpExchange instance = new ServletHttpExchange();\n+        instance.servletContext = servletContext;\n+        instance.channelHandlerContext = context;\n+\n+        //Create a new servlet request object\n+        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n+        //Create a new servlet response object\n+        instance.response = ServletHttpResponse.newInstance(instance);\n+        return instance;\n+    }\n+\n+    /**\n+     * Whether the pipe is active.\n+     */\n+    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n+        return true;\n+    }\n+\n+    /**\n+     * Is http keep alive.\n+     */\n+    public boolean isHttpKeepAlive() {\n+        return isHttpKeepAlive;\n+    }\n+\n+    /**\n+     * Get http servlet request.\n+     */\n+    public ServletHttpRequest getRequest() {\n+        return request;\n+    }\n+\n+    /**\n+     * Get servlet context.\n+     */\n+    public ServletContextImpl getServletContext() {\n+        return servletContext;\n+    }\n+\n+    /**\n+     * Get http servlet response.\n+     */\n+    public ServletHttpResponse getResponse() {\n+        return response;\n+    }\n+\n+    /**\n+     * Get channel handler context.\n+     */\n+    public DefaultServiceRequestContext getChannelHandlerContext() {\n+        return channelHandlerContext;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return servletContext.getServerAddress();\n+    }\n+\n+    /**\n+     * Get local address.\n+     */\n+    public InetSocketAddress getLocalAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n+        if (socketAddress == null) {", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4ODA3OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419288079", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-05-04T08:40:09Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;\n+    private boolean isHttpKeepAlive;\n+\n+    private ServletHttpExchange() {\n+    }\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n+                                                  DefaultServiceRequestContext context,\n+                                                  AggregatedHttpRequest request) {\n+        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n+        final ServletHttpExchange instance = new ServletHttpExchange();\n+        instance.servletContext = servletContext;\n+        instance.channelHandlerContext = context;\n+\n+        //Create a new servlet request object\n+        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n+        //Create a new servlet response object\n+        instance.response = ServletHttpResponse.newInstance(instance);\n+        return instance;\n+    }\n+\n+    /**\n+     * Whether the pipe is active.\n+     */\n+    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n+        return true;\n+    }\n+\n+    /**\n+     * Is http keep alive.\n+     */\n+    public boolean isHttpKeepAlive() {\n+        return isHttpKeepAlive;\n+    }\n+\n+    /**\n+     * Get http servlet request.\n+     */\n+    public ServletHttpRequest getRequest() {\n+        return request;\n+    }\n+\n+    /**\n+     * Get servlet context.\n+     */\n+    public ServletContextImpl getServletContext() {\n+        return servletContext;\n+    }\n+\n+    /**\n+     * Get http servlet response.\n+     */\n+    public ServletHttpResponse getResponse() {\n+        return response;\n+    }\n+\n+    /**\n+     * Get channel handler context.\n+     */\n+    public DefaultServiceRequestContext getChannelHandlerContext() {\n+        return channelHandlerContext;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return servletContext.getServerAddress();\n+    }\n+\n+    /**\n+     * Get local address.\n+     */\n+    public InetSocketAddress getLocalAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n+        if (socketAddress == null) {\n+            return null;\n+        }\n+        if (socketAddress instanceof InetSocketAddress) {\n+            return (InetSocketAddress) socketAddress;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get remote address.\n+     */\n+    public InetSocketAddress getRemoteAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.remoteAddress();\n+        if (socketAddress == null) {", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4OTA4Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419289083", "bodyText": "Is it always use HTTP/1.1?", "author": "minwoox", "createdAt": "2020-05-04T08:42:11Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;\n+    private boolean isHttpKeepAlive;\n+\n+    private ServletHttpExchange() {\n+    }\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n+                                                  DefaultServiceRequestContext context,\n+                                                  AggregatedHttpRequest request) {\n+        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n+        final ServletHttpExchange instance = new ServletHttpExchange();\n+        instance.servletContext = servletContext;\n+        instance.channelHandlerContext = context;\n+\n+        //Create a new servlet request object\n+        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n+        //Create a new servlet response object\n+        instance.response = ServletHttpResponse.newInstance(instance);\n+        return instance;\n+    }\n+\n+    /**\n+     * Whether the pipe is active.\n+     */\n+    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n+        return true;\n+    }\n+\n+    /**\n+     * Is http keep alive.\n+     */\n+    public boolean isHttpKeepAlive() {\n+        return isHttpKeepAlive;\n+    }\n+\n+    /**\n+     * Get http servlet request.\n+     */\n+    public ServletHttpRequest getRequest() {\n+        return request;\n+    }\n+\n+    /**\n+     * Get servlet context.\n+     */\n+    public ServletContextImpl getServletContext() {\n+        return servletContext;\n+    }\n+\n+    /**\n+     * Get http servlet response.\n+     */\n+    public ServletHttpResponse getResponse() {\n+        return response;\n+    }\n+\n+    /**\n+     * Get channel handler context.\n+     */\n+    public DefaultServiceRequestContext getChannelHandlerContext() {\n+        return channelHandlerContext;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return servletContext.getServerAddress();\n+    }\n+\n+    /**\n+     * Get local address.\n+     */\n+    public InetSocketAddress getLocalAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n+        if (socketAddress == null) {\n+            return null;\n+        }\n+        if (socketAddress instanceof InetSocketAddress) {\n+            return (InetSocketAddress) socketAddress;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get remote address.\n+     */\n+    public InetSocketAddress getRemoteAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.remoteAddress();\n+        if (socketAddress == null) {\n+            return null;\n+        }\n+        if (socketAddress instanceof InetSocketAddress) {\n+            return (InetSocketAddress) socketAddress;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Convert {@link HttpRequest} to {@link DefaultFullHttpRequest}.\n+     */\n+    private static DefaultFullHttpRequest parseHttpRequest(ServiceRequestContext ctx,\n+                                                          AggregatedHttpRequest request) {\n+        final ByteBuf content = Unpooled.wrappedBuffer(request.content().array());\n+        final DefaultFullHttpRequest fullHttpRequest = new DefaultFullHttpRequest(\n+                HttpVersion.HTTP_1_1, new HttpMethod(request.method().name()),", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyOTk0OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419329948", "bodyText": "No, but FullHttpRequest interface use HttpVersion which is not support all HTTP version, and we don't use this HttpVersion information. I set correct Armeria HTTP version to ServletAPI now.", "author": "dominhhien", "createdAt": "2020-05-04T10:00:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4OTA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5MTgxNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419291815", "bodyText": "I decided to keep io.netty.handler.codec.http.FullHttpRequest because I don't want to clone all parsing APIs and decoding APIs from Netty project. I reused these APIs. I implemented servlet OutputStream, servlet PrintWriter.\n\nWe have the corresponding parsing and decoding APIs. If we don't we can add the APIs. The Netty HttpRequest is already converted to Armeria HttpRequest before it gets here and changing it back is not reasonable. We should not use that.", "author": "minwoox", "createdAt": "2020-05-04T08:47:11Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;\n+    private boolean isHttpKeepAlive;\n+\n+    private ServletHttpExchange() {\n+    }\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n+                                                  DefaultServiceRequestContext context,\n+                                                  AggregatedHttpRequest request) {\n+        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n+        final ServletHttpExchange instance = new ServletHttpExchange();\n+        instance.servletContext = servletContext;\n+        instance.channelHandlerContext = context;\n+\n+        //Create a new servlet request object\n+        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n+        //Create a new servlet response object\n+        instance.response = ServletHttpResponse.newInstance(instance);\n+        return instance;\n+    }\n+\n+    /**\n+     * Whether the pipe is active.\n+     */\n+    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n+        return true;\n+    }\n+\n+    /**\n+     * Is http keep alive.\n+     */\n+    public boolean isHttpKeepAlive() {\n+        return isHttpKeepAlive;\n+    }\n+\n+    /**\n+     * Get http servlet request.\n+     */\n+    public ServletHttpRequest getRequest() {\n+        return request;\n+    }\n+\n+    /**\n+     * Get servlet context.\n+     */\n+    public ServletContextImpl getServletContext() {\n+        return servletContext;\n+    }\n+\n+    /**\n+     * Get http servlet response.\n+     */\n+    public ServletHttpResponse getResponse() {\n+        return response;\n+    }\n+\n+    /**\n+     * Get channel handler context.\n+     */\n+    public DefaultServiceRequestContext getChannelHandlerContext() {\n+        return channelHandlerContext;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return servletContext.getServerAddress();\n+    }\n+\n+    /**\n+     * Get local address.\n+     */\n+    public InetSocketAddress getLocalAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n+        if (socketAddress == null) {\n+            return null;\n+        }\n+        if (socketAddress instanceof InetSocketAddress) {\n+            return (InetSocketAddress) socketAddress;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get remote address.\n+     */\n+    public InetSocketAddress getRemoteAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.remoteAddress();\n+        if (socketAddress == null) {\n+            return null;\n+        }\n+        if (socketAddress instanceof InetSocketAddress) {\n+            return (InetSocketAddress) socketAddress;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Convert {@link HttpRequest} to {@link DefaultFullHttpRequest}.\n+     */\n+    private static DefaultFullHttpRequest parseHttpRequest(ServiceRequestContext ctx,\n+                                                          AggregatedHttpRequest request) {\n+        final ByteBuf content = Unpooled.wrappedBuffer(request.content().array());\n+        final DefaultFullHttpRequest fullHttpRequest = new DefaultFullHttpRequest(", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgxNjUwMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419816500", "bodyText": "I add new class ServletMultipartRequest here because Armeria HttpRequest is not support multipart. I will create another pull request to fix #253 Add HTTP multipart content support and refactor this code later.", "author": "dominhhien", "createdAt": "2020-05-05T01:15:08Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,1053 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.RequestDispatcher;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletRequestAttributeEvent;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.ServletSecurityElement;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.servlet.util.HttpHeaderConstants;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.StringUtil;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.CodecException;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.http.multipart.Attribute;\n+import io.netty.handler.codec.http.multipart.FileUpload;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.handler.codec.http.multipart.HttpPostMultipartRequestDecoder;\n+import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder;\n+import io.netty.handler.codec.http.multipart.HttpPostStandardRequestDecoder;\n+import io.netty.handler.codec.http.multipart.InterfaceHttpData;\n+import io.netty.handler.codec.http.multipart.InterfaceHttpPostRequestDecoder;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final Locale[] DEFAULT_LOCALS = {Locale.getDefault()};\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)};\n+\n+    private ServletHttpExchange servletHttpExchange;\n+    private String protocol;\n+    private String scheme;\n+    private String servletPath;\n+    private String queryString;\n+    private String pathInfo;\n+    private String requestURI;\n+    private String characterEncoding;\n+    private String sessionId;\n+    private SessionTrackingMode sessionIdSource;\n+    private MultipartConfigElement multipartConfigElement;\n+    private ServletSecurityElement servletSecurityElement;\n+    private boolean decodePathsFlag;\n+    private boolean decodeCookieFlag;\n+    private boolean decodeParameterByUrlFlag;\n+    private InterfaceHttpPostRequestDecoder postRequestDecoder;\n+    private boolean remoteSchemeFlag;\n+    private boolean usingInputStreamFlag;\n+    private BufferedReader reader;\n+    private AggregatedHttpRequest httpRequest;\n+    private ServletInputStreamWrapper inputStream = new ServletInputStreamWrapper();\n+    private Map<String,Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private LinkedMultiValueMap<String,String> parameterMap = new LinkedMultiValueMap<>(16);\n+    private Map<String,String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            final HashSet<Entry<String, String[]>> result = new HashSet<>(6);\n+            final Set<Entry<String, List<String>>> entries = parameterMap.entrySet();\n+            for (Entry<String,List<String>> entry : entries) {\n+                final List<String> value = entry.getValue();\n+                final String[] valueArr = value != null ? value.toArray(new String[value.size()]) : null;\n+                result.add(new SimpleImmutableEntry<>(entry.getKey(),valueArr));\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public String[] get(Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[value.size()]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            return parameterMap.containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    private List<Part> fileUploadList = new ArrayList<>();\n+    private Cookie[] cookies;\n+    private Locale[] locales;\n+    private Boolean asyncSupportedFlag;\n+    private ServletRequestDispatcher dispatcher;\n+\n+    protected ServletHttpRequest() {}\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpRequest of(ServletHttpExchange servletHttpExchange,\n+                                        AggregatedHttpRequest request) {\n+        final ServletHttpRequest instance = new ServletHttpRequest();\n+        instance.servletHttpExchange = servletHttpExchange;\n+        instance.httpRequest = request;\n+        instance.inputStream.wrap(Unpooled.wrappedBuffer(request.content().array()));\n+        instance.getParameterMap();\n+        instance.getCookies();\n+        instance.getLocale();\n+        instance.getProtocol();\n+        instance.getScheme();\n+        return instance;\n+    }\n+\n+    void setDispatcher(ServletRequestDispatcher dispatcher) {\n+        this.dispatcher = dispatcher;\n+    }\n+\n+    void setMultipartConfigElement(MultipartConfigElement multipartConfigElement) {\n+        this.multipartConfigElement = multipartConfigElement;\n+    }\n+\n+    void setServletSecurityElement(ServletSecurityElement servletSecurityElement) {\n+        this.servletSecurityElement = servletSecurityElement;\n+    }\n+\n+    void setAsyncSupportedFlag(Boolean asyncSupportedFlag) {\n+        this.asyncSupportedFlag = asyncSupportedFlag;\n+    }\n+\n+    /**\n+     * Get servlet http exchange.\n+     */\n+    public ServletHttpExchange getServletHttpExchange() {\n+        return servletHttpExchange;\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    public AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse request scheme.\n+     */\n+    private void decodeScheme() {\n+        scheme = httpRequest.scheme();\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private void decodeLocale() {\n+        final Locale[] locales;\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (headerValue == null) {\n+            locales = DEFAULT_LOCALS;\n+        } else {\n+            final String[] values = headerValue.split(\",\");\n+            final int length = values.length;\n+            locales = new Locale[length];\n+            for (int i = 0; i < length; i++) {\n+                final String value = values[i];\n+                final String[] valueSp = value.split(\";\");\n+                final Locale locale;\n+                if (valueSp.length > 0) {\n+                    locale = Locale.forLanguageTag(valueSp[0]);\n+                } else {\n+                    locale = Locale.forLanguageTag(value);\n+                }\n+                locales[i] = locale;\n+            }\n+        }\n+        this.locales = locales;\n+    }\n+\n+    /**\n+     * Parsing coding.\n+     */\n+    private void decodeCharacterEncoding() {\n+        String characterEncoding = ServletUtil.decodeCharacterEncoding(getContentType());\n+        if (characterEncoding == null) {\n+            characterEncoding = getServletContext().getRequestCharacterEncoding();\n+        }\n+       this.characterEncoding = characterEncoding;\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody(boolean bodyPartFlag) {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        final HttpDataFactory factory = getServletContext().getHttpDataFactory(charset);\n+        int discardThreshold = 0;\n+        if (multipartConfigElement != null) {\n+            factory.setMaxLimit(multipartConfigElement.getMaxFileSize());\n+            discardThreshold = multipartConfigElement.getFileSizeThreshold();\n+        }\n+\n+        final HttpRequest request = new ServletMultipartRequest(httpRequest);", "originalCommit": "54698fb02e529a7a51ceee92199eb76db6155006", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4NTYxNA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421185614", "bodyText": "Can remove @Nullable.", "author": "minwoox", "createdAt": "2020-05-07T01:26:14Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+\n+/**\n+ * A builder class which creates a new {@link ServletContextImpl} instance.\n+ */\n+public class ServletBuilder {\n+\n+    @Nullable", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4NTY0Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421185647", "bodyText": "nit: final", "author": "minwoox", "createdAt": "2020-05-07T01:26:20Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+\n+/**\n+ * A builder class which creates a new {@link ServletContextImpl} instance.\n+ */\n+public class ServletBuilder {\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4NTY3MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421185671", "bodyText": "nit: final", "author": "minwoox", "createdAt": "2020-05-07T01:26:27Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+\n+/**\n+ * A builder class which creates a new {@link ServletContextImpl} instance.\n+ */\n+public class ServletBuilder {\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    private ServerBuilder serverBuilder;", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4NjEwNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421186107", "bodyText": "requireNonNull(serverBuilder, \"serverBuilder\");", "author": "minwoox", "createdAt": "2020-05-07T01:28:01Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+\n+/**\n+ * A builder class which creates a new {@link ServletContextImpl} instance.\n+ */\n+public class ServletBuilder {\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    private ServerBuilder serverBuilder;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        servletContext = new ServletContextImpl();\n+        this.serverBuilder = serverBuilder;", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4NjQzNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421186435", "bodyText": "requireNonNull(path, \"path\");\nrequireNonNull(httpServlet, \"httpServlet\");", "author": "minwoox", "createdAt": "2020-05-07T01:29:12Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+\n+/**\n+ * A builder class which creates a new {@link ServletContextImpl} instance.\n+ */\n+public class ServletBuilder {\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    private ServerBuilder serverBuilder;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        servletContext = new ServletContextImpl();\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link DefaultServletService}.\n+     */\n+    public ServerBuilder build() {\n+        return serverBuilder;\n+    }\n+\n+    /**\n+     * Add a servlet of the {@link DefaultServletService}.\n+     */\n+    public ServletBuilder addServlet(String path, HttpServlet httpServlet) {", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4OTE3Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421189172", "bodyText": "Question: Is this class from Servlet spec? or did you implement this class just for convenience?", "author": "minwoox", "createdAt": "2020-05-07T01:38:49Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletEventListenerManager.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletRequestAttributeEvent;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestEvent;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+/**\n+ * Servlet global event listener.\n+ */\n+public class ServletEventListenerManager {", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQxMzA3MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421413070", "bodyText": "Yes, I implement this class just for convenience.", "author": "dominhhien", "createdAt": "2020-05-07T10:48:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4OTE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4OTE5Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421189192", "bodyText": "Question: Is this class from Servlet spec? or did you implement it just for convenience?", "author": "minwoox", "createdAt": "2020-05-07T01:38:54Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletEventListenerManager.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletRequestAttributeEvent;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestEvent;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+/**\n+ * Servlet global event listener.\n+ */\n+public class ServletEventListenerManager {", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4OTY1Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421189653", "bodyText": "Can remove javax.servlet.ServletRegistration because Dynamic extends it.", "author": "minwoox", "createdAt": "2020-05-07T01:40:33Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration\n+        implements javax.servlet.ServletRegistration, Dynamic {", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MDEwMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421190101", "bodyText": "Question: Does this have to be Dynamic? If all parameters are set when it's added, could be just ServletRegistration?", "author": "minwoox", "createdAt": "2020-05-07T01:42:20Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+\n+/**\n+ * A builder class which creates a new {@link ServletContextImpl} instance.\n+ */\n+public class ServletBuilder {\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    private ServerBuilder serverBuilder;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        servletContext = new ServletContextImpl();\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link DefaultServletService}.\n+     */\n+    public ServerBuilder build() {\n+        return serverBuilder;\n+    }\n+\n+    /**\n+     * Add a servlet of the {@link DefaultServletService}.\n+     */\n+    public ServletBuilder addServlet(String path, HttpServlet httpServlet) {\n+        final ServletRegistration.Dynamic sd = servletContext.addServlet(path, httpServlet);", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQyNTAwOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421425008", "bodyText": "This have to be Dynamic interface, because ServletRegistration interface don't include setLoadOnStartup() method and setAsyncSupported() method.", "author": "dominhhien", "createdAt": "2020-05-07T11:12:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MDEwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5MzYxNA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421893614", "bodyText": "Yes, but it seems like we don't set setAsyncSupported as true for now. Also setLoadOnStartup(1) doesn't seem much meaning.\nHow about just using ServletRegistration here and\nadding another method for async such as addAsyncServlet later?", "author": "minwoox", "createdAt": "2020-05-08T01:58:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MDEwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4MjY2Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r422482667", "bodyText": "Agree, Armeria has been async already. We don't need servlet async sound like that add more queue + executor thread pool. In this case servlet async make system more complicated and not good performance.", "author": "dominhhien", "createdAt": "2020-05-09T10:56:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MDEwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MDUxNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421190517", "bodyText": "Please add static final. Also we just use ServleteContextImpl.class.\nprivate static final Logger logger = LoggerFactory.getLogger(ServleteContextImpl.class);", "author": "minwoox", "createdAt": "2020-05-07T01:43:51Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.util.concurrent.FastThreadLocal;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class ServletContextImpl implements ServletContext {\n+    private Logger logger = LoggerFactory.getLogger(getClass());", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MDc2Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421190762", "bodyText": "Let's rename to DefaultServletContext.", "author": "minwoox", "createdAt": "2020-05-07T01:44:45Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.util.concurrent.FastThreadLocal;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class ServletContextImpl implements ServletContext {", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MTU3NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421191574", "bodyText": "Let's add these fields to ServletBuilder so that a user change the values.", "author": "minwoox", "createdAt": "2020-05-07T01:47:46Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.util.concurrent.FastThreadLocal;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class ServletContextImpl implements ServletContext {\n+    private Logger logger = LoggerFactory.getLogger(getClass());\n+    /**\n+     * Default: 20 minutes.\n+     */\n+    private int sessionTimeout = 1200;", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MTg2NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421191864", "bodyText": "After that. We can get all properties from the constructor and make all properties as final.", "author": "minwoox", "createdAt": "2020-05-07T01:48:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MTU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MjAzOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421192039", "bodyText": "this.classLoader = requireNonNull(classLoader, \"classLoader\");", "author": "minwoox", "createdAt": "2020-05-07T01:49:22Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.util.concurrent.FastThreadLocal;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class ServletContextImpl implements ServletContext {\n+    private Logger logger = LoggerFactory.getLogger(getClass());\n+    /**\n+     * Default: 20 minutes.\n+     */\n+    private int sessionTimeout = 1200;\n+    /**\n+     * The maximum number of bytes written to the outputstream.writer () method of the servlet each time it\n+     * is called is exceeded.\n+     */\n+    private int responseWriterChunkMaxHeapByteLength = 4096;\n+    /**\n+     * Minimum upload file length, in bytes (becomes temporary file storage if larger than 16KB).\n+     */\n+    private long uploadMinSize = 4096 * 16;\n+    private Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, ServletFilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private FastThreadLocal<Map<Charset, HttpDataFactory>> httpDataFactoryThreadLocal =\n+            new FastThreadLocal<Map<Charset, HttpDataFactory>>() {\n+        @Override\n+        protected Map<Charset, HttpDataFactory> initialValue() throws Exception {\n+            return new HashMap<>();\n+        }\n+    };\n+    private Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private ServletEventListenerManager servletEventListenerManager = new ServletEventListenerManager();\n+    private UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private UrlMapper<ServletFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+\n+    private ExecutorService asyncExecutorService;\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+\n+    private String contextPath;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private String servletContextName;\n+    private InetSocketAddress serverAddress;\n+    private ClassLoader classLoader;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletContextImpl() {\n+        classLoader = getClass().getClassLoader();\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletContextImpl(ClassLoader classLoader) {\n+        this.classLoader = classLoader == null ? getClass().getClassLoader() : classLoader;", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MjQ2Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421192466", "bodyText": "requireNonNull(absoluteUri, \"absoluteUri\");", "author": "minwoox", "createdAt": "2020-05-07T01:50:44Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.util.concurrent.FastThreadLocal;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class ServletContextImpl implements ServletContext {\n+    private Logger logger = LoggerFactory.getLogger(getClass());\n+    /**\n+     * Default: 20 minutes.\n+     */\n+    private int sessionTimeout = 1200;\n+    /**\n+     * The maximum number of bytes written to the outputstream.writer () method of the servlet each time it\n+     * is called is exceeded.\n+     */\n+    private int responseWriterChunkMaxHeapByteLength = 4096;\n+    /**\n+     * Minimum upload file length, in bytes (becomes temporary file storage if larger than 16KB).\n+     */\n+    private long uploadMinSize = 4096 * 16;\n+    private Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, ServletFilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private FastThreadLocal<Map<Charset, HttpDataFactory>> httpDataFactoryThreadLocal =\n+            new FastThreadLocal<Map<Charset, HttpDataFactory>>() {\n+        @Override\n+        protected Map<Charset, HttpDataFactory> initialValue() throws Exception {\n+            return new HashMap<>();\n+        }\n+    };\n+    private Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private ServletEventListenerManager servletEventListenerManager = new ServletEventListenerManager();\n+    private UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private UrlMapper<ServletFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+\n+    private ExecutorService asyncExecutorService;\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+\n+    private String contextPath;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private String servletContextName;\n+    private InetSocketAddress serverAddress;\n+    private ClassLoader classLoader;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletContextImpl() {\n+        classLoader = getClass().getClassLoader();\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletContextImpl(ClassLoader classLoader) {\n+        this.classLoader = classLoader == null ? getClass().getClassLoader() : classLoader;\n+    }\n+\n+    /**\n+     * Get servlet event listener manager.\n+     */\n+    public ServletEventListenerManager getServletEventListenerManager() {\n+        return servletEventListenerManager;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        return servletUrlMapper.getServletPath(absoluteUri);", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5ODY1MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421198651", "bodyText": "Please use requireNonNull through out this PR if the parameter is not annotated with @Nullable.", "author": "minwoox", "createdAt": "2020-05-07T02:13:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MjQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5Mzc3NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421193774", "bodyText": "checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout)", "author": "minwoox", "createdAt": "2020-05-07T01:55:06Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.util.concurrent.FastThreadLocal;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class ServletContextImpl implements ServletContext {\n+    private Logger logger = LoggerFactory.getLogger(getClass());\n+    /**\n+     * Default: 20 minutes.\n+     */\n+    private int sessionTimeout = 1200;\n+    /**\n+     * The maximum number of bytes written to the outputstream.writer () method of the servlet each time it\n+     * is called is exceeded.\n+     */\n+    private int responseWriterChunkMaxHeapByteLength = 4096;\n+    /**\n+     * Minimum upload file length, in bytes (becomes temporary file storage if larger than 16KB).\n+     */\n+    private long uploadMinSize = 4096 * 16;\n+    private Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, ServletFilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private FastThreadLocal<Map<Charset, HttpDataFactory>> httpDataFactoryThreadLocal =\n+            new FastThreadLocal<Map<Charset, HttpDataFactory>>() {\n+        @Override\n+        protected Map<Charset, HttpDataFactory> initialValue() throws Exception {\n+            return new HashMap<>();\n+        }\n+    };\n+    private Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private ServletEventListenerManager servletEventListenerManager = new ServletEventListenerManager();\n+    private UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private UrlMapper<ServletFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+\n+    private ExecutorService asyncExecutorService;\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+\n+    private String contextPath;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private String servletContextName;\n+    private InetSocketAddress serverAddress;\n+    private ClassLoader classLoader;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletContextImpl() {\n+        classLoader = getClass().getClassLoader();\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletContextImpl(ClassLoader classLoader) {\n+        this.classLoader = classLoader == null ? getClass().getClassLoader() : classLoader;\n+    }\n+\n+    /**\n+     * Get servlet event listener manager.\n+     */\n+    public ServletEventListenerManager getServletEventListenerManager() {\n+        return servletEventListenerManager;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        if (sessionTimeout <= 0) {", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5ODc5Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421198796", "bodyText": "Please validate the parameter through out this PR.", "author": "minwoox", "createdAt": "2020-05-07T02:14:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5Mzc3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5NTQwOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421195408", "bodyText": "Is there any reason to make ServletHttpExchange?\nWe have ServletContextImpl already, couldn't we just make ServletHttpRequest and ServletHttpResponse directly?", "author": "minwoox", "createdAt": "2020-05-07T02:01:13Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private final ServletContextImpl servletContext;\n+\n+    /**\n+     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n+     */\n+    public DefaultServletService(ServletContextImpl servletContext) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        this.servletContext = servletContext;\n+    }\n+\n+    /**\n+     * handles {@link HttpRequest} and forward to Servlet APIs.\n+     */\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n+        final HttpResponseWriter res = HttpResponse.streaming();\n+        req.aggregate().handle((aReq, cause) -> {\n+            if (cause != null) {\n+                logger.warn(\"{} Failed to aggregate a request:\", ctx, cause);\n+                if (res.tryWrite(ResponseHeaders.of(HttpStatus.INTERNAL_SERVER_ERROR))) {\n+                    res.close();\n+                }\n+                return null;\n+            }\n+            process(res, ServletHttpExchange.of(servletContext, ctx, aReq));", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMxNjkwMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421316902", "bodyText": "ServletHttpExchange like a HttpExchange https://docs.oracle.com/javase/8/docs/jre/api/net/httpserver/spec/com/sun/net/httpserver/HttpExchange.html in JDK HttpServer. ServletHttpExchange store protocol information, channel or reader/writer API. I think we should separate initialization class (ServletContextImpl) and communication class (ServletHttpExchange) . How do you think?", "author": "dominhhien", "createdAt": "2020-05-07T08:06:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5NTQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5NDgxNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421894817", "bodyText": "Yes, but it looks like all ServletHttpExchange doing is just calling getServletContext() which we already have.\nHow about introducing it later when we find that it really needs?", "author": "minwoox", "createdAt": "2020-05-08T02:02:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5NTQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjYwMzU3MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r422603571", "bodyText": "Agree, I will remove it.", "author": "dominhhien", "createdAt": "2020-05-10T07:46:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5NTQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5ODM0Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421198343", "bodyText": "If we add the ServletService one by one, https://github.com/line/armeria/pull/2686/files#diff-6b0e2525eb80747c141e9fb8daa2c3adR56, we don't need this dispatcher\nbecause Armeria server will handle the routing.", "author": "minwoox", "createdAt": "2020-05-07T02:12:33Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private final ServletContextImpl servletContext;\n+\n+    /**\n+     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n+     */\n+    public DefaultServletService(ServletContextImpl servletContext) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        this.servletContext = servletContext;\n+    }\n+\n+    /**\n+     * handles {@link HttpRequest} and forward to Servlet APIs.\n+     */\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n+        final HttpResponseWriter res = HttpResponse.streaming();\n+        req.aggregate().handle((aReq, cause) -> {\n+            if (cause != null) {\n+                logger.warn(\"{} Failed to aggregate a request:\", ctx, cause);\n+                if (res.tryWrite(ResponseHeaders.of(HttpStatus.INTERNAL_SERVER_ERROR))) {\n+                    res.close();\n+                }\n+                return null;\n+            }\n+            process(res, ServletHttpExchange.of(servletContext, ctx, aReq));\n+            return null;\n+        });\n+        return res;\n+    }\n+\n+    private void process(HttpResponseWriter res, ServletHttpExchange servletHttpExchange) {\n+        final ServletHttpRequest httpServletRequest = servletHttpExchange.getRequest();\n+        final ServletHttpResponse httpServletResponse = servletHttpExchange.getResponse();\n+        try {\n+            final ServletRequestDispatcher dispatcher =\n+                    servletHttpExchange.getServletContext()\n+                                       .getRequestDispatcher(httpServletRequest.getRequestURI());", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQxNTcyMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421415722", "bodyText": "Yes, we don't need routing here. But dispatcher help us insert filter class (interceptor). I think we should keep dispatcher here.", "author": "dominhhien", "createdAt": "2020-05-07T10:54:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5ODM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkwOTcxOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421909718", "bodyText": "@dominhhien Thanks for the explanation. Honestly, I'm not sure if we need this or not. If it's just only for the filter, we can implement our own logic for that. so that we can remove complicated UrlMapper and MimeMappings classes that Armeria server already handles.\nIs there any other usage for the RequestDiscpatcher except for the filter?", "author": "minwoox", "createdAt": "2020-05-08T03:02:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5ODM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkxMTE1Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421911157", "bodyText": "Also, is there any chance that a user needs to use RequestDispatcher?", "author": "minwoox", "createdAt": "2020-05-08T03:07:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5ODM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0MDAwOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r422440008", "bodyText": "I think we should keep RequestDispatcher interface because it is a part of Servlet API.", "author": "dominhhien", "createdAt": "2020-05-09T01:55:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5ODM0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNDE2NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r423504165", "bodyText": "There is no way to set these properties.\nHow about adding it to ServletBuilder?\nServletBuilder servletBuilder = ...\nservletBuilder.requestCharacterEncoding(...)\n...\nservletBuilder.build(); // DefaultServletContext is created at this point based on the properties set so far.", "author": "minwoox", "createdAt": "2020-05-12T06:59:30Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,622 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    /**\n+     * Default: 20 minutes.\n+     */\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, ServletFilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private final MimeMappings mimeMappings = new MimeMappings();\n+    private final ServletEventListenerManager servletEventListenerManager = new ServletEventListenerManager();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<ServletFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private ClassLoader classLoader = getClass().getClassLoader();\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;", "originalCommit": "df2377dcecf31a1b82bc4ebed6bb802065c38069", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2NDI5NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r423564294", "bodyText": "Yes, I know. But I'm not sure if we should support contextPath. If we support context path, all service URLs have to concat context path. Example if context path is (/app), service URL will be (/app/welcome, /app/home) instead of (/wecome, /home) . Should we support context path? How do you think?", "author": "dominhhien", "createdAt": "2020-05-12T08:42:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNDE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3MDgyNA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r423570824", "bodyText": "I think we will support context path later, context path is only useful if we want to deploy multiple apps on one armeria server.", "author": "dominhhien", "createdAt": "2020-05-12T08:52:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNDE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3ODU4NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r423578584", "bodyText": "If we decide to support contextPath. I will add setContextPath() method to ServletBuilder.", "author": "dominhhien", "createdAt": "2020-05-12T09:03:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNDE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3OTA4Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r423579087", "bodyText": "Should we support context path? How do you think?\n\nI don't think so. \ud83d\ude04 Please add setters that you think a user might want to customize.", "author": "minwoox", "createdAt": "2020-05-12T09:04:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNDE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYwNjE3MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r423606171", "bodyText": "Agree, I will add setters.", "author": "dominhhien", "createdAt": "2020-05-12T09:47:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNDE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA2MjIwNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r429062207", "bodyText": "Also could you add tests for the path we discussed using ServerExtenstion?\nFor example:\nWhen contextPath = \"\" and the servletes are added to the path \"/foo\", \"/foo/\" and \"\".\nWhen contextPath = \"/foo\" and the servletes are added to the path \"/bar\", \"/bar/\" and \"\".", "author": "minwoox", "createdAt": "2020-05-22T06:18:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNDE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTEwNDAzOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r429104038", "bodyText": "Agree, I will add tests code.", "author": "dominhhien", "createdAt": "2020-05-22T08:08:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNDE2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxODE4Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r423518187", "bodyText": "Because we are just handling sync servlet (we are going to handle the async servlets later) we must use blockingTaskExecutor.\nctx.blockingTaskExecutor().execute(() -> {\n    ...\n});\n// or we just can do it in handle.\nreq.aggregate().handleAsync((aReq, cause) -> {\n    ...\n}, ctx.blockingTaskExecutor());", "author": "minwoox", "createdAt": "2020-05-12T07:26:48Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private final DefaultServletContext servletContext;\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private ServiceRequestContext serviceRequestContext;\n+\n+    /**\n+     * Get http servlet request.\n+     */\n+    public ServletHttpRequest getRequest() {\n+        return request;\n+    }\n+\n+    /**\n+     * Get servlet context.\n+     */\n+    public DefaultServletContext getServletContext() {\n+        return servletContext;\n+    }\n+\n+    /**\n+     * Get http servlet response.\n+     */\n+    public ServletHttpResponse getResponse() {\n+        return response;\n+    }\n+\n+    /**\n+     * Get channel handler context.\n+     */\n+    public ServiceRequestContext getServiceRequestContext() {\n+        return serviceRequestContext;\n+    }\n+\n+    /**\n+     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n+     */\n+    public DefaultServletService(DefaultServletContext servletContext) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        this.servletContext = servletContext;\n+    }\n+\n+    /**\n+     * handles {@link HttpRequest} and forward to Servlet APIs.\n+     */\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(req, \"req\");\n+        serviceRequestContext = ctx;\n+        final HttpResponseWriter res = HttpResponse.streaming();\n+        req.aggregate().handle((aReq, cause) -> {\n+            if (cause != null) {\n+                logger.warn(\"{} Failed to aggregate a request:\", ctx, cause);\n+                if (res.tryWrite(ResponseHeaders.of(HttpStatus.INTERNAL_SERVER_ERROR))) {\n+                    res.close();\n+                }\n+                return null;\n+            }\n+            process(res, aReq);\n+            return null;\n+        });\n+        return res;\n+    }\n+\n+    private void process(HttpResponseWriter res, AggregatedHttpRequest req) {", "originalCommit": "df2377dcecf31a1b82bc4ebed6bb802065c38069", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxOTMwOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r423519308", "bodyText": "These three properties can be here. Please imagine a situation that this DefaultServletService handles multiple thousands requests.", "author": "minwoox", "createdAt": "2020-05-12T07:28:44Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private final DefaultServletContext servletContext;\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private ServiceRequestContext serviceRequestContext;", "originalCommit": "df2377dcecf31a1b82bc4ebed6bb802065c38069", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMjYxNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425522616", "bodyText": "Let's split this constructor into two:\npublic ServletBuilder(ServerBuilder serverBuilder) {\n    this(serverBuilder, \"\");\n}\n\npublic ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n    requireNonNull(serverBuilder, \"serverBuilder\");\n    requireNonNull(contextPath, \"contextPath\");\n    ...\n}", "author": "minwoox", "createdAt": "2020-05-15T01:51:53Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Objects;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, @Nullable String contextPath) {", "originalCommit": "eaab16d84518f0c5fbe702618287fcaaf8ad8a6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMjk2OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425522969", "bodyText": "Please note that the contextPath could be: /x/y/z\nSo we should do contextPath.charAt(contextPath.length() - 1) != '/'", "author": "minwoox", "createdAt": "2020-05-15T01:53:15Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Objects;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, @Nullable String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        if (Objects.isNull(contextPath)) {\n+            contextPath = \"\";\n+        }\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.charAt(0) == '/' && !contextPath.substring(1).contains(\"/\"),", "originalCommit": "eaab16d84518f0c5fbe702618287fcaaf8ad8a6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1Njk4MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425556981", "bodyText": "I think we can just add one DefaultServletService when ServletBuilder.build() is called.\nserverBuilder.serviceUnder(contextPath, new DefaultServletService(servletContext));\n\nBecause we use context.getRequestDispacher(path) in DefaultServletService to find the corresponding Servlet.", "author": "minwoox", "createdAt": "2020-05-15T04:16:39Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Objects;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, @Nullable String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        if (Objects.isNull(contextPath)) {\n+            contextPath = \"\";\n+        }\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.charAt(0) == '/' && !contextPath.substring(1).contains(\"/\"),\n+                          \"Context path have to start with / and contains only one /\", contextPath);\n+        }\n+        servletContext = new DefaultServletContext(contextPath);\n+        this.contextPath = contextPath;\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link ServerBuilder}.\n+     */\n+    public ServerBuilder build() {\n+        return serverBuilder;\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(httpServlet, \"httpServlet\");\n+        return addServlet(path, httpServlet);\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, String servletClass) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        return addServlet(path, servletClass);\n+    }\n+\n+    private ServletBuilder addServlet(String path, Object servlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!\"\".equals(contextPath)) {\n+            path = \"/\".equals(path) ? contextPath : contextPath + path;\n+        }\n+        ServletRegistration sd = null;\n+        if (servlet instanceof String) {\n+            sd = servletContext.addServlet(path, (String) servlet);\n+        } else {\n+            sd = servletContext.addServlet(path, (HttpServlet) servlet);\n+        }\n+        sd.addMapping(path);\n+        serverBuilder.service(path, new DefaultServletService(servletContext));", "originalCommit": "eaab16d84518f0c5fbe702618287fcaaf8ad8a6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYzNTk5MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425635991", "bodyText": "Probably not, because user can add servlet root path \"/\" or \"\" (It is also context path) :\nsb.servlet(\"/\", new HomeServlet())\nor\nsb.servlet(\"\", new HomeServlet())\nI think user should decide whether to implement servlet root path or not.", "author": "dominhhien", "createdAt": "2020-05-15T08:08:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1Njk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY1NDg3OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425654879", "bodyText": "sb.servlet(\"/\", new HomeServlet())\nor\nsb.servlet(\"\", new HomeServlet())\n\nWhat's the URL that a user connects to the servlet in those cases?", "author": "minwoox", "createdAt": "2020-05-15T08:43:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1Njk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY2NDIxNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425664216", "bodyText": "URL is http://host:port/contextPath,  contextPath is initialized in DefaultServletContext.\n\tnew DefaultServletContext(contextPath)\n\nServletBuilder.java\n    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n        requireNonNull(serverBuilder, \"serverBuilder\");\n        requireNonNull(contextPath, \"contextPath\");\n        if (!contextPath.isEmpty()) {\n            checkArgument(contextPath.charAt(0) == '/' &&\n                           contextPath.charAt(contextPath.length() - 1) != '/',\n                          \"Context path format is /x/y/z\", contextPath);\n        }\n        servletContext = new DefaultServletContext(contextPath);\n        this.contextPath = contextPath;\n        this.serverBuilder = serverBuilder;\n    }", "author": "dominhhien", "createdAt": "2020-05-15T09:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1Njk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY2ODQ4Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425668486", "bodyText": "What I meant was what's the difference between URLs when contextPath is \"/\" and \"\"?\nIsn't it http://host:port/ in both cases?", "author": "minwoox", "createdAt": "2020-05-15T09:08:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1Njk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4MjA2Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425682063", "bodyText": "Armeria server does not support empty service path (\"\"). But servlet support empty path. If we access http://host:port, server return http://host:port/ => Http response status is 307 (redirect) instead of 200(ok) because URL was changed. If we support both cases \"/\" and \"\", Http response status always be 200 (ok).", "author": "dominhhien", "createdAt": "2020-05-15T09:32:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1Njk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5MDUzNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425690535", "bodyText": "Armeria server not support empty service path (\"\")\n\nRight, Armeria does not support the empty path so a servlet on Armeria couldn't have empty path mapping. Isn't that right?\nI was thinking just adding / after contextPath when we call\nserverBuilder.serviceUnder(...); because the contextPath does not end with /\nso that we can just handle the servlets by just adding one DefaultServletService.\nWhen contextPath is /foo:\n\nif a user adds a servlet too /bar, then the url is http://host:port/foo/bar\n\nWhen contextPath is \"\":\n\nif a user adds a servlet too /baz, then the url is http://host:port/baz\nif a user adds a servlet too /, then the url is http://host:port/\n\nWhen contextPath is /:\n\nThis is an exception.\n\nWhat do you think?", "author": "minwoox", "createdAt": "2020-05-15T09:48:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1Njk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5ODIzMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425698233", "bodyText": "Yes, it's like you explained. I will fix this exception. Do you suggest another solution for this problem?", "author": "dominhhien", "createdAt": "2020-05-15T10:02:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1Njk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwMDk3MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425700970", "bodyText": "I think add available DefaultServletService is not perfect solution. It is very nice if default case return Not found with path / and users can add a customized servlet / when \ufffdthey need it. What do you think?", "author": "dominhhien", "createdAt": "2020-05-15T10:08:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1Njk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1NzE4MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425557180", "bodyText": "Question: Should we allow to add a servlet after the Server is started?", "author": "minwoox", "createdAt": "2020-05-15T04:17:33Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,570 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {\n+        requireNonNull(file, \"file\");\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.length() < 1) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n+        for (FilterRegistration registration : filterRegistrationMap.values()) {\n+            filterList.add(registration);\n+        }\n+        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n+\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n+        for (FilterRegistration registration : filterRegistrationMap.values()) {\n+            for (String servletName : registration.getServletNameMappings()) {\n+                if (servletName.equals(name)) {\n+                    filterList.add(registration);\n+                }\n+            }\n+        }\n+\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        final List<Servlet> list = new ArrayList<>();\n+        for (ServletRegistration registration : servletRegistrationMap.values()) {\n+            list.add(registration.getServlet());\n+        }\n+        return Collections.enumeration(list);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        final List<String> list = new ArrayList<>();\n+        for (ServletRegistration registration : servletRegistrationMap.values()) {\n+            list.add(registration.getName());\n+        }\n+        return Collections.enumeration(list);\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {", "originalCommit": "eaab16d84518f0c5fbe702618287fcaaf8ad8a6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1NzU5Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425557593", "bodyText": "Probably not until there's a demand for such feature? It'd be nice to keep the supported feature set to an essential extent.", "author": "trustin", "createdAt": "2020-05-15T04:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1NzE4MA=="}], "type": "inlineReview"}, {"oid": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "url": "https://github.com/line/armeria/commit/5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "message": "Fix servlet context path, prevent add servlet, filter after server is started", "committedDate": "2020-05-15T11:10:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxODU0NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427018545", "bodyText": "https://github.com/eclipse-ee4j/servlet-api/blob/master/spec/src/main/asciidoc/servlet-spec-body.adoc#35--request-path-elements\nI don't see any regulation that the path should not end with /.", "author": "minwoox", "createdAt": "2020-05-19T04:08:14Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+    private boolean rootServletAdded;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        this(serverBuilder, \"\");\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        requireNonNull(contextPath, \"contextPath\");\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.startsWith(\"/\") && contextPath.charAt(contextPath.length() - 1) != '/',\n+                          \"Context path format is /x/y/z\", contextPath);\n+        }\n+        servletContext = new DefaultServletContext(contextPath);\n+        this.contextPath = contextPath;\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link ServerBuilder}.\n+     */\n+    public ServerBuilder build() {\n+        final String path = contextPath.isEmpty() ? \"/\" : contextPath;\n+        final DefaultServletService servletService = new DefaultServletService(servletContext);\n+        serverBuilder.serviceUnder(path, servletService);\n+        if (rootServletAdded) {\n+            serverBuilder.service(path, servletService);\n+        } else {\n+            serverBuilder.service(path, (ctx, req) -> HttpResponse.of(HttpStatus.NOT_FOUND));\n+        }\n+        return serverBuilder;\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(httpServlet, \"httpServlet\");\n+        return addServlet(path, httpServlet);\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, String servletClass) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        return addServlet(path, servletClass);\n+    }\n+\n+    private ServletBuilder addServlet(String path, Object servlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (path.isEmpty()) {\n+            rootServletAdded = true;\n+        } else {\n+            checkArgument(path.startsWith(\"/\") && path.charAt(path.length() - 1) != '/',", "originalCommit": "99fc46d6d382b40c0d8e9221dacef8f235ebc0f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEzODU0NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427138545", "bodyText": "What do you expect? Should /home and /home/ maps to the same servlet or 2 different servlets?", "author": "dominhhien", "createdAt": "2020-05-19T08:53:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxODU0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4OTc5Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427189793", "bodyText": "How about auto removing / if there is / at last of path.", "author": "dominhhien", "createdAt": "2020-05-19T10:15:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxODU0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxNTAxNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427715016", "bodyText": "What other frameworks do in this case?", "author": "minwoox", "createdAt": "2020-05-20T03:01:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxODU0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc2MjA3Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427762073", "bodyText": "I test some site: facebook, google, confluence. I see both path return the same content. I think we can do that by maps both path to one servlet by ServletRegistration.", "author": "dominhhien", "createdAt": "2020-05-20T06:09:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxODU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxODg2OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427018869", "bodyText": "Can remove this line and just do\nserverBuilder.serviceUnder(contextPath + '/', servletService);\nbecause / is always appended if the path prefix does not end with /", "author": "minwoox", "createdAt": "2020-05-19T04:09:40Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+    private boolean rootServletAdded;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        this(serverBuilder, \"\");\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        requireNonNull(contextPath, \"contextPath\");\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.startsWith(\"/\") && contextPath.charAt(contextPath.length() - 1) != '/',\n+                          \"Context path format is /x/y/z\", contextPath);\n+        }\n+        servletContext = new DefaultServletContext(contextPath);\n+        this.contextPath = contextPath;\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link ServerBuilder}.\n+     */\n+    public ServerBuilder build() {\n+        final String path = contextPath.isEmpty() ? \"/\" : contextPath;", "originalCommit": "99fc46d6d382b40c0d8e9221dacef8f235ebc0f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE1OTkwNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427159905", "bodyText": "But I not only use path variable in serviceUnder() but also use it in service() method. I think we can keep this line.", "author": "dominhhien", "createdAt": "2020-05-19T09:26:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxODg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3MTU2NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427171564", "bodyText": "Ah, yes, forget about the comment. \ud83d\ude05", "author": "minwoox", "createdAt": "2020-05-19T09:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxODg2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxOTMxNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427019315", "bodyText": "context format can be /x/y, /x/y/z/foo or whatever so we should change this.\ncheckArgument(contextPath.charAt(0) == '/' && contextPath.charAt(contextPath.length() - 1) != '/',\n\"contextPath must start with / and must not end with /. contextPath: %s\", contextPath);", "author": "minwoox", "createdAt": "2020-05-19T04:11:28Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+    private boolean rootServletAdded;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        this(serverBuilder, \"\");\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        requireNonNull(contextPath, \"contextPath\");\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.startsWith(\"/\") && contextPath.charAt(contextPath.length() - 1) != '/',\n+                          \"Context path format is /x/y/z\", contextPath);", "originalCommit": "99fc46d6d382b40c0d8e9221dacef8f235ebc0f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyMDc2Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427020766", "bodyText": "Let's remove this method and just add the servlet from the above:\npublic ServletBuilder servlet(String path, HttpServlet httpServlet) {\n    requireNonNull(path, \"path\");\n    requireNonNull(httpServlet, \"httpServlet\");\n    validatePath(path);\n    servletContext.addServlet(path, httpServlet);\n    return this;\n}\n\nPlease note that I didn't do sd.addMapping(path); because the path can be added in ServletContext.", "author": "minwoox", "createdAt": "2020-05-19T04:18:16Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+    private boolean rootServletAdded;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        this(serverBuilder, \"\");\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        requireNonNull(contextPath, \"contextPath\");\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.startsWith(\"/\") && contextPath.charAt(contextPath.length() - 1) != '/',\n+                          \"Context path format is /x/y/z\", contextPath);\n+        }\n+        servletContext = new DefaultServletContext(contextPath);\n+        this.contextPath = contextPath;\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link ServerBuilder}.\n+     */\n+    public ServerBuilder build() {\n+        final String path = contextPath.isEmpty() ? \"/\" : contextPath;\n+        final DefaultServletService servletService = new DefaultServletService(servletContext);\n+        serverBuilder.serviceUnder(path, servletService);\n+        if (rootServletAdded) {\n+            serverBuilder.service(path, servletService);\n+        } else {\n+            serverBuilder.service(path, (ctx, req) -> HttpResponse.of(HttpStatus.NOT_FOUND));\n+        }\n+        return serverBuilder;\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(httpServlet, \"httpServlet\");\n+        return addServlet(path, httpServlet);\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, String servletClass) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        return addServlet(path, servletClass);\n+    }\n+\n+    private ServletBuilder addServlet(String path, Object servlet) {", "originalCommit": "99fc46d6d382b40c0d8e9221dacef8f235ebc0f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyMTI5MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427021291", "bodyText": "The value can be null, right?", "author": "minwoox", "createdAt": "2020-05-19T04:20:35Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {\n+        requireNonNull(file, \"file\");\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.length() < 1) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n+        for (FilterRegistration registration : filterRegistrationMap.values()) {\n+            filterList.add(registration);\n+        }\n+        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n+\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n+        for (FilterRegistration registration : filterRegistrationMap.values()) {\n+            for (String servletName : registration.getServletNameMappings()) {\n+                if (servletName.equals(name)) {\n+                    filterList.add(registration);\n+                }\n+            }\n+        }\n+\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        final List<Servlet> list = new ArrayList<>();\n+        for (ServletRegistration registration : servletRegistrationMap.values()) {\n+            list.add(registration.getServlet());\n+        }\n+        return Collections.enumeration(list);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        final List<String> list = new ArrayList<>();\n+        for (ServletRegistration registration : servletRegistrationMap.values()) {\n+            list.add(registration.getName());\n+        }\n+        return Collections.enumeration(list);\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");", "originalCommit": "99fc46d6d382b40c0d8e9221dacef8f235ebc0f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyMTY3MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427021671", "bodyText": "How about making a separate PR for filter related code?", "author": "minwoox", "createdAt": "2020-05-19T04:22:02Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+    private boolean rootServletAdded;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        this(serverBuilder, \"\");\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        requireNonNull(contextPath, \"contextPath\");\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.startsWith(\"/\") && contextPath.charAt(contextPath.length() - 1) != '/',\n+                          \"Context path format is /x/y/z\", contextPath);\n+        }\n+        servletContext = new DefaultServletContext(contextPath);\n+        this.contextPath = contextPath;\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link ServerBuilder}.\n+     */\n+    public ServerBuilder build() {\n+        final String path = contextPath.isEmpty() ? \"/\" : contextPath;\n+        final DefaultServletService servletService = new DefaultServletService(servletContext);\n+        serverBuilder.serviceUnder(path, servletService);\n+        if (rootServletAdded) {\n+            serverBuilder.service(path, servletService);\n+        } else {\n+            serverBuilder.service(path, (ctx, req) -> HttpResponse.of(HttpStatus.NOT_FOUND));\n+        }\n+        return serverBuilder;\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(httpServlet, \"httpServlet\");\n+        return addServlet(path, httpServlet);\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, String servletClass) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        return addServlet(path, servletClass);\n+    }\n+\n+    private ServletBuilder addServlet(String path, Object servlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (path.isEmpty()) {\n+            rootServletAdded = true;\n+        } else {\n+            checkArgument(path.startsWith(\"/\") && path.charAt(path.length() - 1) != '/',\n+                          \"Servlet path format is /x/y/z\", path);\n+        }\n+        path = contextPath + path;\n+        final ServletRegistration sd;\n+        if (servlet instanceof String) {\n+            sd = servletContext.addServlet(path, (String) servlet);\n+        } else {\n+            sd = servletContext.addServlet(path, (HttpServlet) servlet);\n+        }\n+        sd.addMapping(path);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the session timeout in minutes for this ServletContext.\n+     * @param sessionTimeout session timeout in minutes.\n+     */\n+    public ServletBuilder sessionTimeout(int sessionTimeout) {\n+        servletContext.setSessionTimeout(sessionTimeout);\n+        return this;\n+    }\n+\n+    /**\n+     * Set attribute value.\n+     */\n+    public ServletBuilder attribute(String key, @Nullable Object value) {\n+        requireNonNull(key, \"key\");\n+        servletContext.setAttribute(key, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Set init parameter.\n+     */\n+    public ServletBuilder initParameter(String key, @Nullable String value) {\n+        requireNonNull(key, \"key\");\n+        servletContext.setInitParameter(key, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Add filter.\n+     */\n+    public ServletBuilder filter(String filterName, Filter filter) {", "originalCommit": "99fc46d6d382b40c0d8e9221dacef8f235ebc0f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyMzQ5Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427023497", "bodyText": "Can remove this it not used.", "author": "minwoox", "createdAt": "2020-05-19T04:30:22Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxOTY4Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427219682", "bodyText": "Yes, It is not used but Servlet API exists getServletContextName() method. I think we should create contextName from contextPath converting.", "author": "dominhhien", "createdAt": "2020-05-19T11:11:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyMzQ5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyMzY1OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427023658", "bodyText": "if contextPath is /x/y/z, servletContextName will be xyz. Is this what you intended?", "author": "minwoox", "createdAt": "2020-05-19T04:30:57Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIyMDU3MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427220571", "bodyText": "Yes, but I think xyz is not pretty. I will change to x_y_z", "author": "dominhhien", "createdAt": "2020-05-19T11:12:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyMzY1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNDcwMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427024701", "bodyText": "We can set this when we call ServletBuilder.build().\nOf course, the name should be changed such as isInitailized?", "author": "minwoox", "createdAt": "2020-05-19T04:35:33Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNTU3MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427025570", "bodyText": "Let's remove this and setServerAddress.", "author": "minwoox", "createdAt": "2020-05-19T04:39:00Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNTgzOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427025838", "bodyText": "return serviceRequestContext.localAddress().toString();", "author": "minwoox", "createdAt": "2020-05-19T04:40:00Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,871 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.ServletSecurityElement;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.HttpHeaderConstants;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault()};\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)};\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private String protocol;\n+    private String scheme;\n+    private String servletPath;\n+    private String queryString;\n+    private String pathInfo;\n+    private String requestURI;\n+    private String characterEncoding;\n+    private SessionTrackingMode sessionIdSource;\n+    private MultipartConfigElement multipartConfigElement;\n+    private ServletSecurityElement servletSecurityElement;\n+    private boolean usingInputStreamFlag;\n+    private BufferedReader reader;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream = new DefaultServletInputStream();\n+    private final Map<String,Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private LinkedMultiValueMap<String,String> parameterMap = new LinkedMultiValueMap<>(16);\n+    private final Map<String,String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            final HashSet<Entry<String, String[]>> result = new HashSet<>(6);\n+            final Set<Entry<String, List<String>>> entries = parameterMap.entrySet();\n+            for (Entry<String,List<String>> entry : entries) {\n+                final List<String> value = entry.getValue();\n+                final String[] valueArr = value != null ? value.toArray(new String[value.size()]) : null;\n+                result.add(new SimpleImmutableEntry<>(entry.getKey(),valueArr));\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public String[] get(Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[value.size()]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    private List<Part> fileUploadList = new ArrayList<>();\n+    private Cookie[] cookies;\n+    private Locale[] locales;\n+    private Boolean asyncSupportedFlag;\n+    private ServletRequestDispatcher dispatcher;\n+\n+    protected ServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                                 DefaultServletContext servletContext,\n+                                 AggregatedHttpRequest request) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(request, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        httpRequest = request;\n+        inputStream.setContent(Unpooled.wrappedBuffer(request.content().array()));\n+        if (servletContext.getServerAddress() == null) {\n+            servletContext.setServerAddress(\n+                    serviceRequestContext.remoteAddress());\n+        }\n+        decodeUrlParameter();\n+        decodeBody();\n+        decodeCookie();\n+        decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        decodePaths();\n+    }\n+\n+    void setDispatcher(ServletRequestDispatcher dispatcher) {\n+        requireNonNull(dispatcher, \"dispatcher\");\n+        this.dispatcher = dispatcher;\n+    }\n+\n+    void setMultipartConfigElement(@Nullable MultipartConfigElement multipartConfigElement) {\n+        this.multipartConfigElement = multipartConfigElement;\n+    }\n+\n+    void setServletSecurityElement(@Nullable ServletSecurityElement servletSecurityElement) {\n+        this.servletSecurityElement = servletSecurityElement;\n+    }\n+\n+    void setAsyncSupportedFlag(boolean asyncSupportedFlag) {\n+        this.asyncSupportedFlag = asyncSupportedFlag;\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    public AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private void decodeLocale() {\n+        final Locale[] locales;\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (headerValue == null) {\n+            locales = DEFAULT_LOCALS;\n+        } else {\n+            final String[] values = headerValue.split(\",\");\n+            final int length = values.length;\n+            locales = new Locale[length];\n+            for (int i = 0; i < length; i++) {\n+                final String value = values[i];\n+                final String[] valueSp = value.split(\";\");\n+                final Locale locale;\n+                if (valueSp.length > 0) {\n+                    locale = Locale.forLanguageTag(valueSp[0]);\n+                } else {\n+                    locale = Locale.forLanguageTag(value);\n+                }\n+                locales[i] = locale;\n+            }\n+        }\n+        this.locales = locales;\n+    }\n+\n+    /**\n+     * Parsing coding.\n+     */\n+    private void decodeCharacterEncoding() {\n+        String characterEncoding = ServletUtil.decodeCharacterEncoding(getContentType());\n+        if (characterEncoding == null) {\n+            characterEncoding = getServletContext().getRequestCharacterEncoding();\n+        }\n+       this.characterEncoding = characterEncoding;\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpHeaderConstants.POST.equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            parameterMap = ServletUtil.decodeBody(\n+                    parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    private void decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (value != null && value.length() > 0) {\n+            final Collection<Cookie> nettyCookieSet = ServletUtil.decodeCookie(value);\n+            if (nettyCookieSet.size() > 0) {\n+                cookies = nettyCookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private void decodePaths() {\n+        String requestURI = httpRequest.path();\n+        final String queryString;\n+        final int queryInx = requestURI.indexOf('?');\n+        if (queryInx > -1) {\n+            queryString = requestURI.substring(queryInx + 1);\n+            requestURI = requestURI.substring(0, queryInx);\n+        } else {\n+            queryString = null;\n+        }\n+        if (requestURI.length() > 1 && requestURI.charAt(0) == '/' && requestURI.charAt(1) == '/') {\n+            requestURI = requestURI.substring(1);\n+        }\n+\n+        this.requestURI = requestURI;\n+        this.queryString = queryString;\n+    }\n+\n+    @Override\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) throws IllegalArgumentException {\n+        requireNonNull(name, \"name\");\n+        final String value = getHeader(name);\n+        if (value == null || \"\".equals(value)) {\n+            return -1;\n+        }\n+\n+        final DateFormat[] formats = FORMATS_TEMPLATE;\n+        Date date = null;\n+        for (int i = 0; (date == null) && (i < formats.length); i++) {\n+            try {\n+                date = formats[i].parse(value);\n+            } catch (ParseException e) {\n+                logger.info(\"Cannot parse \" + value + \" to date type\");\n+            }\n+        }\n+        if (date == null) {\n+            throw new IllegalArgumentException(value);\n+        }\n+        return date.getTime();\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = httpRequest.headers().get(name);\n+        return value == null ? null : String.valueOf(value);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        final Set nameSet = httpRequest.headers().names();\n+        return new Enumeration<String>() {\n+            private Iterator iterator = nameSet.iterator();\n+\n+            @Override\n+            public boolean hasMoreElements() {\n+                return iterator.hasNext();\n+            }\n+\n+            @Override\n+            public String nextElement() {\n+                return iterator.next().toString();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = HttpHeaderConstants.HTTP_PORT;\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((HttpHeaderConstants.HTTP.equals(scheme) && (port != HttpHeaderConstants.HTTP_PORT)) ||\n+            (HttpHeaderConstants.HTTPS.equals(scheme) && (port != HttpHeaderConstants.HTTPS_PORT))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        if (this.servletPath == null) {\n+            String servletPath = getServletContext().getServletPath(getRequestURI());\n+            final String contextPath = getServletContext().getContextPath();\n+            if (contextPath.length() > 0) {\n+                servletPath = servletPath.replaceFirst(contextPath,\"\");\n+            }\n+            this.servletPath = servletPath;\n+        }\n+        return this.servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        return null;\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        return null;\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        final Collection collection = httpRequest.headers().getAll(name);\n+        return new Enumeration<String>() {\n+            private Iterator iterator = collection.iterator();\n+\n+            @Override\n+            public boolean hasMoreElements() {\n+                return iterator.hasNext();\n+            }\n+\n+            @Override\n+            public String nextElement() {\n+                return iterator.next().toString();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (headerStringValue == null) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return getServletContext().getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        getRequestedSessionId();\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+                sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        getRequestedSessionId();\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        getRequestedSessionId();\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(getAttributeMap().keySet());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        if (characterEncoding == null) {\n+            decodeCharacterEncoding();\n+        }\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        requireNonNull(env, \"env\");\n+        characterEncoding = env;\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return Integer.parseInt(httpRequest.headers().get(HttpHeaderNames.CONTENT_LENGTH)\n+                .replace(\"[\", \"\").replace(\"]\", \"\"));\n+    }\n+\n+    @Override\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        usingInputStreamFlag = true;\n+        return inputStream;\n+    }\n+\n+    @Override\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        final String[] values = getParameterMap().get(name);\n+        if (values == null || values.length == 0) {\n+            return null;\n+        }\n+        return values[0];\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(getParameterMap().keySet());\n+    }\n+\n+    @Override\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        return getParameterMap().get(name);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return unmodifiableParameterMap;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        if (protocol == null) {\n+            protocol = serviceRequestContext.sessionProtocol().uriText();\n+        }\n+        return protocol;\n+    }\n+\n+    @Override\n+    public String getScheme() {\n+        if (scheme == null) {\n+            scheme = httpRequest.scheme();\n+        }\n+        return scheme;\n+    }\n+\n+    @Override\n+    public String getServerName() {\n+        final InetSocketAddress inetSocketAddress = serviceRequestContext.localAddress();\n+        if (inetSocketAddress != null) {\n+            return inetSocketAddress.getAddress().getHostAddress();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return Integer.parseInt(getHeader(\":authority\").split(\":\")[1]);\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        if (usingInputStreamFlag) {\n+            throw new IllegalStateException(\"getInputStream() has already been called for this request\");\n+        }\n+        if (reader == null) {\n+            synchronized (this) {\n+                if (reader == null) {\n+                    String charset = getCharacterEncoding();\n+                    if (charset == null) {\n+                        charset = getServletContext().getRequestCharacterEncoding();\n+                    }\n+                    reader = new BufferedReader(new InputStreamReader(getInputStream(),charset));\n+                }\n+            }\n+        }\n+        return reader;\n+    }\n+\n+    @Override\n+    public String getRemoteAddr() {\n+        final InetSocketAddress inetSocketAddress = serviceRequestContext.remoteAddress();\n+        if (inetSocketAddress == null) {\n+            return null;\n+        }\n+        final InetAddress inetAddress = inetSocketAddress.getAddress();\n+        if (inetAddress == null) {\n+            return null;\n+        }\n+        return inetAddress.getHostAddress();\n+    }\n+\n+    @Override\n+    public String getRemoteHost() {\n+        final InetSocketAddress inetSocketAddress = serviceRequestContext.remoteAddress();\n+        if (inetSocketAddress == null) {\n+            return null;\n+        }\n+        return inetSocketAddress.getHostName();\n+    }\n+\n+    @Override\n+    public int getRemotePort() {\n+        return getServerPort();\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name, \"name\");\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        getAttributeMap().put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        getAttributeMap().remove(name);\n+    }\n+\n+    @Override\n+    public Locale getLocale() {\n+        final Locale[] locales = this.locales;\n+        if (locales == null || locales.length == 0) {\n+            return null;\n+        }\n+        return locales[0];\n+    }\n+\n+    @Override\n+    public Enumeration<Locale> getLocales() {\n+        if (this.locales == null) {\n+            decodeLocale();\n+        }\n+        return new Enumeration<Locale>() {\n+            private int index;\n+            @Override\n+            public boolean hasMoreElements() {\n+                return index < locales.length;\n+            }\n+\n+            @Override\n+            public Locale nextElement() {\n+                final Locale locale = locales[index];\n+                index++;\n+                return locale;\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public boolean isSecure() {\n+        return HttpHeaderConstants.HTTPS.equals(getScheme());\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        return getServletContext().getRequestDispatcher(path);\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        requireNonNull(path, \"path\");\n+        return getServletContext().getRealPath(path);\n+    }\n+\n+    @Override\n+    public String getLocalName() {\n+        return getServletContext().getServerAddress().getHostName();\n+    }\n+\n+    @Override\n+    public String getLocalAddr() {\n+        return getServletContext().getServerAddress().getAddress().getHostAddress();", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNTg1OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427025859", "bodyText": "return serviceRequestContext.config().server().defaultHostname();", "author": "minwoox", "createdAt": "2020-05-19T04:40:03Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,871 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.ServletSecurityElement;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.HttpHeaderConstants;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault()};\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)};\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private String protocol;\n+    private String scheme;\n+    private String servletPath;\n+    private String queryString;\n+    private String pathInfo;\n+    private String requestURI;\n+    private String characterEncoding;\n+    private SessionTrackingMode sessionIdSource;\n+    private MultipartConfigElement multipartConfigElement;\n+    private ServletSecurityElement servletSecurityElement;\n+    private boolean usingInputStreamFlag;\n+    private BufferedReader reader;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream = new DefaultServletInputStream();\n+    private final Map<String,Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private LinkedMultiValueMap<String,String> parameterMap = new LinkedMultiValueMap<>(16);\n+    private final Map<String,String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            final HashSet<Entry<String, String[]>> result = new HashSet<>(6);\n+            final Set<Entry<String, List<String>>> entries = parameterMap.entrySet();\n+            for (Entry<String,List<String>> entry : entries) {\n+                final List<String> value = entry.getValue();\n+                final String[] valueArr = value != null ? value.toArray(new String[value.size()]) : null;\n+                result.add(new SimpleImmutableEntry<>(entry.getKey(),valueArr));\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public String[] get(Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[value.size()]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    private List<Part> fileUploadList = new ArrayList<>();\n+    private Cookie[] cookies;\n+    private Locale[] locales;\n+    private Boolean asyncSupportedFlag;\n+    private ServletRequestDispatcher dispatcher;\n+\n+    protected ServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                                 DefaultServletContext servletContext,\n+                                 AggregatedHttpRequest request) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(request, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        httpRequest = request;\n+        inputStream.setContent(Unpooled.wrappedBuffer(request.content().array()));\n+        if (servletContext.getServerAddress() == null) {\n+            servletContext.setServerAddress(\n+                    serviceRequestContext.remoteAddress());\n+        }\n+        decodeUrlParameter();\n+        decodeBody();\n+        decodeCookie();\n+        decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        decodePaths();\n+    }\n+\n+    void setDispatcher(ServletRequestDispatcher dispatcher) {\n+        requireNonNull(dispatcher, \"dispatcher\");\n+        this.dispatcher = dispatcher;\n+    }\n+\n+    void setMultipartConfigElement(@Nullable MultipartConfigElement multipartConfigElement) {\n+        this.multipartConfigElement = multipartConfigElement;\n+    }\n+\n+    void setServletSecurityElement(@Nullable ServletSecurityElement servletSecurityElement) {\n+        this.servletSecurityElement = servletSecurityElement;\n+    }\n+\n+    void setAsyncSupportedFlag(boolean asyncSupportedFlag) {\n+        this.asyncSupportedFlag = asyncSupportedFlag;\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    public AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private void decodeLocale() {\n+        final Locale[] locales;\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (headerValue == null) {\n+            locales = DEFAULT_LOCALS;\n+        } else {\n+            final String[] values = headerValue.split(\",\");\n+            final int length = values.length;\n+            locales = new Locale[length];\n+            for (int i = 0; i < length; i++) {\n+                final String value = values[i];\n+                final String[] valueSp = value.split(\";\");\n+                final Locale locale;\n+                if (valueSp.length > 0) {\n+                    locale = Locale.forLanguageTag(valueSp[0]);\n+                } else {\n+                    locale = Locale.forLanguageTag(value);\n+                }\n+                locales[i] = locale;\n+            }\n+        }\n+        this.locales = locales;\n+    }\n+\n+    /**\n+     * Parsing coding.\n+     */\n+    private void decodeCharacterEncoding() {\n+        String characterEncoding = ServletUtil.decodeCharacterEncoding(getContentType());\n+        if (characterEncoding == null) {\n+            characterEncoding = getServletContext().getRequestCharacterEncoding();\n+        }\n+       this.characterEncoding = characterEncoding;\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpHeaderConstants.POST.equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            parameterMap = ServletUtil.decodeBody(\n+                    parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    private void decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (value != null && value.length() > 0) {\n+            final Collection<Cookie> nettyCookieSet = ServletUtil.decodeCookie(value);\n+            if (nettyCookieSet.size() > 0) {\n+                cookies = nettyCookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private void decodePaths() {\n+        String requestURI = httpRequest.path();\n+        final String queryString;\n+        final int queryInx = requestURI.indexOf('?');\n+        if (queryInx > -1) {\n+            queryString = requestURI.substring(queryInx + 1);\n+            requestURI = requestURI.substring(0, queryInx);\n+        } else {\n+            queryString = null;\n+        }\n+        if (requestURI.length() > 1 && requestURI.charAt(0) == '/' && requestURI.charAt(1) == '/') {\n+            requestURI = requestURI.substring(1);\n+        }\n+\n+        this.requestURI = requestURI;\n+        this.queryString = queryString;\n+    }\n+\n+    @Override\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) throws IllegalArgumentException {\n+        requireNonNull(name, \"name\");\n+        final String value = getHeader(name);\n+        if (value == null || \"\".equals(value)) {\n+            return -1;\n+        }\n+\n+        final DateFormat[] formats = FORMATS_TEMPLATE;\n+        Date date = null;\n+        for (int i = 0; (date == null) && (i < formats.length); i++) {\n+            try {\n+                date = formats[i].parse(value);\n+            } catch (ParseException e) {\n+                logger.info(\"Cannot parse \" + value + \" to date type\");\n+            }\n+        }\n+        if (date == null) {\n+            throw new IllegalArgumentException(value);\n+        }\n+        return date.getTime();\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = httpRequest.headers().get(name);\n+        return value == null ? null : String.valueOf(value);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        final Set nameSet = httpRequest.headers().names();\n+        return new Enumeration<String>() {\n+            private Iterator iterator = nameSet.iterator();\n+\n+            @Override\n+            public boolean hasMoreElements() {\n+                return iterator.hasNext();\n+            }\n+\n+            @Override\n+            public String nextElement() {\n+                return iterator.next().toString();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = HttpHeaderConstants.HTTP_PORT;\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((HttpHeaderConstants.HTTP.equals(scheme) && (port != HttpHeaderConstants.HTTP_PORT)) ||\n+            (HttpHeaderConstants.HTTPS.equals(scheme) && (port != HttpHeaderConstants.HTTPS_PORT))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        if (this.servletPath == null) {\n+            String servletPath = getServletContext().getServletPath(getRequestURI());\n+            final String contextPath = getServletContext().getContextPath();\n+            if (contextPath.length() > 0) {\n+                servletPath = servletPath.replaceFirst(contextPath,\"\");\n+            }\n+            this.servletPath = servletPath;\n+        }\n+        return this.servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        return null;\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        return null;\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        final Collection collection = httpRequest.headers().getAll(name);\n+        return new Enumeration<String>() {\n+            private Iterator iterator = collection.iterator();\n+\n+            @Override\n+            public boolean hasMoreElements() {\n+                return iterator.hasNext();\n+            }\n+\n+            @Override\n+            public String nextElement() {\n+                return iterator.next().toString();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (headerStringValue == null) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return getServletContext().getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        getRequestedSessionId();\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+                sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        getRequestedSessionId();\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        getRequestedSessionId();\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(getAttributeMap().keySet());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        if (characterEncoding == null) {\n+            decodeCharacterEncoding();\n+        }\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        requireNonNull(env, \"env\");\n+        characterEncoding = env;\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return Integer.parseInt(httpRequest.headers().get(HttpHeaderNames.CONTENT_LENGTH)\n+                .replace(\"[\", \"\").replace(\"]\", \"\"));\n+    }\n+\n+    @Override\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        usingInputStreamFlag = true;\n+        return inputStream;\n+    }\n+\n+    @Override\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        final String[] values = getParameterMap().get(name);\n+        if (values == null || values.length == 0) {\n+            return null;\n+        }\n+        return values[0];\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(getParameterMap().keySet());\n+    }\n+\n+    @Override\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        return getParameterMap().get(name);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return unmodifiableParameterMap;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        if (protocol == null) {\n+            protocol = serviceRequestContext.sessionProtocol().uriText();\n+        }\n+        return protocol;\n+    }\n+\n+    @Override\n+    public String getScheme() {\n+        if (scheme == null) {\n+            scheme = httpRequest.scheme();\n+        }\n+        return scheme;\n+    }\n+\n+    @Override\n+    public String getServerName() {\n+        final InetSocketAddress inetSocketAddress = serviceRequestContext.localAddress();\n+        if (inetSocketAddress != null) {\n+            return inetSocketAddress.getAddress().getHostAddress();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return Integer.parseInt(getHeader(\":authority\").split(\":\")[1]);\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        if (usingInputStreamFlag) {\n+            throw new IllegalStateException(\"getInputStream() has already been called for this request\");\n+        }\n+        if (reader == null) {\n+            synchronized (this) {\n+                if (reader == null) {\n+                    String charset = getCharacterEncoding();\n+                    if (charset == null) {\n+                        charset = getServletContext().getRequestCharacterEncoding();\n+                    }\n+                    reader = new BufferedReader(new InputStreamReader(getInputStream(),charset));\n+                }\n+            }\n+        }\n+        return reader;\n+    }\n+\n+    @Override\n+    public String getRemoteAddr() {\n+        final InetSocketAddress inetSocketAddress = serviceRequestContext.remoteAddress();\n+        if (inetSocketAddress == null) {\n+            return null;\n+        }\n+        final InetAddress inetAddress = inetSocketAddress.getAddress();\n+        if (inetAddress == null) {\n+            return null;\n+        }\n+        return inetAddress.getHostAddress();\n+    }\n+\n+    @Override\n+    public String getRemoteHost() {\n+        final InetSocketAddress inetSocketAddress = serviceRequestContext.remoteAddress();\n+        if (inetSocketAddress == null) {\n+            return null;\n+        }\n+        return inetSocketAddress.getHostName();\n+    }\n+\n+    @Override\n+    public int getRemotePort() {\n+        return getServerPort();\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name, \"name\");\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        getAttributeMap().put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        getAttributeMap().remove(name);\n+    }\n+\n+    @Override\n+    public Locale getLocale() {\n+        final Locale[] locales = this.locales;\n+        if (locales == null || locales.length == 0) {\n+            return null;\n+        }\n+        return locales[0];\n+    }\n+\n+    @Override\n+    public Enumeration<Locale> getLocales() {\n+        if (this.locales == null) {\n+            decodeLocale();\n+        }\n+        return new Enumeration<Locale>() {\n+            private int index;\n+            @Override\n+            public boolean hasMoreElements() {\n+                return index < locales.length;\n+            }\n+\n+            @Override\n+            public Locale nextElement() {\n+                final Locale locale = locales[index];\n+                index++;\n+                return locale;\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public boolean isSecure() {\n+        return HttpHeaderConstants.HTTPS.equals(getScheme());\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        return getServletContext().getRequestDispatcher(path);\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        requireNonNull(path, \"path\");\n+        return getServletContext().getRealPath(path);\n+    }\n+\n+    @Override\n+    public String getLocalName() {\n+        return getServletContext().getServerAddress().getHostName();", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNjMxOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427026319", "bodyText": "What is the default value for sessionTimeout?", "author": "minwoox", "createdAt": "2020-05-19T04:42:05Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4NDI4NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427684284", "bodyText": "I will set default value = 20 minutes. I think we don't support servlet session now. I will separate another PR to do this.", "author": "dominhhien", "createdAt": "2020-05-20T01:03:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNjMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNjYxNA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427026614", "bodyText": "Seems like we don't support this yet. Let's throw UnsupportedOperationException, right now.", "author": "minwoox", "createdAt": "2020-05-19T04:43:19Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNjc4NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427026784", "bodyText": "Shouldn't we target for 4?", "author": "minwoox", "createdAt": "2020-05-19T04:44:02Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4NDc3NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427684774", "bodyText": "No, we implement servlet 4. I will change it to 4.", "author": "dominhhien", "createdAt": "2020-05-20T01:05:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNjc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNzU5NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427027595", "bodyText": "extension.isEmpty()", "author": "minwoox", "createdAt": "2020-05-19T04:47:11Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {\n+        requireNonNull(file, \"file\");\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.length() < 1) {", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNzY0MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427027641", "bodyText": "Should add @Nullable", "author": "minwoox", "createdAt": "2020-05-19T04:47:23Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyOTY4MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427029681", "bodyText": "Shouldn't we check if the file exists or not first?", "author": "minwoox", "createdAt": "2020-05-19T04:55:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNzY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4ODkyNA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427688924", "bodyText": "I think we shouldn't check file. Because method's target is get mime type (http content-type) from file extension instead of real file such as: .avi => video/x-msvideo . Web browser will open download popup, view pdf or play music base on mime type.", "author": "dominhhien", "createdAt": "2020-05-20T01:21:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNzY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNzg3Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427027877", "bodyText": "Let's add TODO", "author": "minwoox", "createdAt": "2020-05-19T04:48:20Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {\n+        requireNonNull(file, \"file\");\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.length() < 1) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5MTE5Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427691197", "bodyText": "I think we don't support resource (html, css, js) management now.", "author": "dominhhien", "createdAt": "2020-05-20T01:29:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNzg3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzMjQ1Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430832456", "bodyText": "Then, let's throw UnsupportedOperationException.\nAlso, could you check all other methods whether to throw UnsupportedOperationException, please?", "author": "minwoox", "createdAt": "2020-05-27T03:07:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNzg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyODE2Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427028163", "bodyText": "Could fix this by referring one of the ServletContext implementations in other frameworks?", "author": "minwoox", "createdAt": "2020-05-19T04:49:36Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {\n+        requireNonNull(file, \"file\");\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.length() < 1) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5MzM4MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427693380", "bodyText": "Yes, we can. I think we can do a simple resource management.\nWe need a resource directory on linux such as: /home/user/deploy/armeria_server/app/share .\nWhen web browser send URL end with .html | .css | .js | .jpg ....\nsuch as:\nhttp://host:port/app/index.html\ngetRealPath() will return file path:\n/home/user/deploy/armeria_server/app/share/index.html\nthen ServletHttpResponse will write FileOutputStream to web browser.", "author": "dominhhien", "createdAt": "2020-05-20T01:37:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyODE2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5ODQzMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427698433", "bodyText": "Also, we have some question:\n\nHow to read fast resource file, should cache resource file bytes on memory?\nHow to combine multi html file such as: template file + menu file + body file?\nShould we support Java server page standard (JSP)? My opinion is shouldn't, because it's very bulky\n\nI think we don't support resource management now. I will separate another PR to do this.", "author": "dominhhien", "createdAt": "2020-05-20T01:56:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyODE2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwMTU0Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427701542", "bodyText": "How to read fast resource file, should cache resource file bytes on memory?\n\nYes, we can cache the resources. Or we might use HttpFile but not sure it's going to work or not. Anyway, I think it's also deserved to have its own PR.\n\nHow to combine multi html file such as: template file + menu file + body file?\n\nI think we don't have to consider that right now.\n\nShould we support Java server page standard (JSP)? My opinion is shouldn't, because it's very bulky\n\nI respect your opinion. \ud83d\ude04\n\nI think we don't support resource management now. I will separate another PR to do this.\n\nYes, that's a good idea. Implementing servlet is really huge work. So let's break one by one. \ud83d\ude06", "author": "minwoox", "createdAt": "2020-05-20T02:08:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyODE2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NzIwMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427047200", "bodyText": "Let's remove filter related code right now.", "author": "minwoox", "createdAt": "2020-05-19T05:57:55Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {\n+        requireNonNull(file, \"file\");\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.length() < 1) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5ODcxMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427698711", "bodyText": "Agree, I got it !", "author": "dominhhien", "createdAt": "2020-05-20T01:57:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NzIwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzMzUwNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430833505", "bodyText": "So you don't want to make a separate PR for the filter?", "author": "minwoox", "createdAt": "2020-05-27T03:12:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NzIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODYxMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427058611", "bodyText": "We should make the list as immutable not just for getServlets(), but also for getServletNames(), getInitParameterNames(), getAttributeNames() etc.\nreturn Collections.enumeration(servletRegistrationMap.values()\n                                                     .stream()\n                                                     .map(ServletRegistration::getServlet)\n                                                     .collect(toImmutableList()));\n\nAlso, one thing we have to think about is that if the field is unmodifiable after DefaultServletContext is initialized, we can pass it when we create DefaultServletContext.\nFor example, initParamMap can't be changed after DefaultServiceContext is initialized.\nSo we can do something like:\nclass ServletBuilder {\n\n    // Introduce a new class \n    private final DefaultServletContextBuilder servletContextBuilder;\n\n    ServletBuilder(ServerBuilder serverBuiler, String contextPath) {\n        servletContextBuilder = new DefaultServletContextBuilder(contextPath);\n    }\n\n    public ServletBuilder initParameter(String key, @Nullable String value) {\n        requireNonNull(key, \"key\");\n        servletContextBuilder.setInitParameter(key, value);\n        return this;\n    }\n\n    public ServerBuilder build() {\n        new DefaultServletService(servletContextBuilder.build());\n        ...\n    }\n    ...\n}\n\nclass ServletContext {\n\n    ServletContext(String contextPath, Map<String, String> initParamMap ...) {\n        this.initParamMap = ImmutableMap.copyOf(initParamMap);\n        ...\n    }\n}", "author": "minwoox", "createdAt": "2020-05-19T06:29:15Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {\n+        requireNonNull(file, \"file\");\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.length() < 1) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n+        for (FilterRegistration registration : filterRegistrationMap.values()) {\n+            filterList.add(registration);\n+        }\n+        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n+\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n+        for (FilterRegistration registration : filterRegistrationMap.values()) {\n+            for (String servletName : registration.getServletNameMappings()) {\n+                if (servletName.equals(name)) {\n+                    filterList.add(registration);\n+                }\n+            }\n+        }\n+\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        final List<Servlet> list = new ArrayList<>();\n+        for (ServletRegistration registration : servletRegistrationMap.values()) {\n+            list.add(registration.getServlet());\n+        }\n+        return Collections.enumeration(list);", "originalCommit": "197d92c3d0161a57379a0ba6b4c3a25a08653781", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxODE0NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427718144", "bodyText": "We should make the list as immutable not just for getServlets(), but also for getServletNames(), getInitParameterNames(), getAttributeNames() etc.\n\nTotally agree!", "author": "dominhhien", "createdAt": "2020-05-20T03:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcyODAxOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427728019", "bodyText": "Also, one thing we have to think about is that if the field is unmodifiable after DefaultServletContext is initialized, we can pass it when we create DefaultServletContext.\nFor example, initParamMap can't be changed after DefaultServiceContext is initialized\n\nI will apply to ImmutableMap for initParamMap, other fields will keep. But I think we should use another method: \ufffdpack() instead of DefaultServletContext() constructor.\nThen we can call \ufffdpack() in ServletBuilder.build() to pack any field. Ofcourse, initParamMap is not final. How do you think?", "author": "dominhhien", "createdAt": "2020-05-20T04:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA2MDM1OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r429060358", "bodyText": "What's the \ufffdpack()? Could you elaborate more on this please?", "author": "minwoox", "createdAt": "2020-05-22T06:12:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTExMjUyMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r429112520", "bodyText": "pack() and unPack() method usually are used to encode, decode, complete header ... a object (example: ISO message) before send it. I think immutable and unImmutable may be like that.", "author": "dominhhien", "createdAt": "2020-05-22T08:26:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTExNDMwOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r429114309", "bodyText": "I understood your implementation by constructor but if we have many immutable fields, I think using constructor is difficult to implement.", "author": "dominhhien", "createdAt": "2020-05-22T08:30:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTExODUwMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r429118502", "bodyText": "Ok, I got it. Then, could you pack other properties too so that they are not set after initialized?", "author": "minwoox", "createdAt": "2020-05-22T08:39:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTEyMTAxNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r429121017", "bodyText": "Yes, I think so :) .", "author": "dominhhien", "createdAt": "2020-05-22T08:44:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTEyMTkzMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r429121931", "bodyText": "We should raise an exception in these methods if the context is initialized:\naddServlet, addJspFile, addFilter, setSessionTrackingModes, addListener,\ndeclareRoles, setSessionTimeout, setRequestCharacterEncoding, setResponseCharacterEncoding", "author": "minwoox", "createdAt": "2020-05-22T08:46:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE1MTcyNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r429151727", "bodyText": "Agree, I will throw exception if the context is initialized", "author": "dominhhien", "createdAt": "2020-05-22T09:49:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODYxMQ=="}], "type": "inlineReview"}, {"oid": "512a67108968aec63ea888349eba11bb2b47c691", "url": "https://github.com/line/armeria/commit/512a67108968aec63ea888349eba11bb2b47c691", "message": "Merge branch 'master' into master", "committedDate": "2020-05-21T08:02:27Z", "type": "forcePushed"}, {"oid": "512a67108968aec63ea888349eba11bb2b47c691", "url": "https://github.com/line/armeria/commit/512a67108968aec63ea888349eba11bb2b47c691", "message": "Merge branch 'master' into master", "committedDate": "2020-05-21T08:02:27Z", "type": "forcePushed"}, {"oid": "512a67108968aec63ea888349eba11bb2b47c691", "url": "https://github.com/line/armeria/commit/512a67108968aec63ea888349eba11bb2b47c691", "message": "Merge branch 'master' into master", "committedDate": "2020-05-21T08:02:27Z", "type": "forcePushed"}, {"oid": "512a67108968aec63ea888349eba11bb2b47c691", "url": "https://github.com/line/armeria/commit/512a67108968aec63ea888349eba11bb2b47c691", "message": "Merge branch 'master' into master", "committedDate": "2020-05-21T08:02:27Z", "type": "forcePushed"}, {"oid": "a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "url": "https://github.com/line/armeria/commit/a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "message": "Add immutable, servletPath / at last, and refactor", "committedDate": "2020-05-20T06:57:30Z", "type": "forcePushed"}, {"oid": "a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "url": "https://github.com/line/armeria/commit/a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "message": "Add immutable, servletPath / at last, and refactor", "committedDate": "2020-05-20T06:57:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgyNTU5Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430825592", "bodyText": "two spaces before =. Please use auto-formatting before you commit.", "author": "minwoox", "createdAt": "2020-05-27T02:39:06Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgyNzk5OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430827998", "bodyText": "This is checking the state not the argument.\nAlso, we can make a private method to use together.\n@Override\npublic void setSessionTimeout(int sessionTimeout) {\n    ensureUninitialized(\"sessionTimeout\");\n    checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n    this.sessionTimeout = sessionTimeout;\n}\n\nprivate void ensureUninitialized(String name) {\n    checkState(!initialized, \"Can't set %s after the servlet context is initialized.\", name);\n}\n\n// We can use ensureUninitialized() in all other setters too.", "author": "minwoox", "createdAt": "2020-05-27T02:49:08Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgyOTIzMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430829233", "bodyText": "Let's add @Nullable.\nCould you check all the methods and parameters if we forgot to add @Nullable, please?", "author": "minwoox", "createdAt": "2020-05-27T02:53:55Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzNDEwMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430834100", "bodyText": "If we pass the element and path when creating ServletRequestDispatcher, we can make the fields final and we don't need the setter.\nnew ServletRequestDispatcher(element, path);", "author": "minwoox", "createdAt": "2020-05-27T03:14:45Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzNDY2OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430834668", "bodyText": "Could you add test cases that cover this logic?", "author": "minwoox", "createdAt": "2020-05-27T03:17:19Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkzMjE1MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430932150", "bodyText": "Yes, I have already added test cases for this at class: ServletServiceTest line 269", "author": "dominhhien", "createdAt": "2020-05-27T08:06:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzNDY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkzNTY4NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430935685", "bodyText": "What I meant was all cases like \"\", \"/home\" and \"/home/\". \ud83d\ude04", "author": "minwoox", "createdAt": "2020-05-27T08:12:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzNDY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkzNjAyNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430936025", "bodyText": "Also I wonder what happened for \"\" and \"/\".", "author": "minwoox", "createdAt": "2020-05-27T08:13:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzNDY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAzODQ1OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r431038459", "bodyText": "I will add test case at class ServletContextPathTest and ServletEmptyContextPathTest . But I want to explain more about my code:\nAt addServlet() method: I removed / at last of servlet path before add to ServletRegistration.\nTherefore whether user choose \"/\" or \"\", servlet always maps to only path \"\"\nAt getNamedDispatcher() method: I removed / at last of servlet path too before get from ServletRegistration\nTherefore, whether user access URL path \"/\" or \"\", getNamedDispatcher() always return servlet maps to \"\".\n=> \"/\" and \"\" return the same servlet.", "author": "dominhhien", "createdAt": "2020-05-27T11:11:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzNDY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA2ODE3OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r431068178", "bodyText": "Ah I missed that. Thanks for the explanation. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-05-27T12:10:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzNDY2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzNzk5Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430837996", "bodyText": "A user might want to log use different level, so we should use the LogLevel and use it:\nprivate final LogLevel level;\n...\nlevel.log(logger, msg);", "author": "minwoox", "createdAt": "2020-05-27T03:31:46Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzOTQ2Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430839463", "bodyText": "indentation. This should be:\nServletUtil.getServerInfo()\n           .concat(\"(JDK \")\n           ...\nAlso we can just use + instead of concat. And, please use cache for this.\n@Nullable\nprivate String serverInfo;\n\n...\n@Override\npublic String getServerInfo() {\n    if (serverInfo != null) {\n        return serverInfo;\n    }\n    ...\n}\n```java", "author": "minwoox", "createdAt": "2020-05-27T03:38:36Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzOTc2NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430839764", "bodyText": "ensureUninitialized(\"initParameter\");", "author": "minwoox", "createdAt": "2020-05-27T03:40:07Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NTAzMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430845032", "bodyText": "Please address this #2686 (comment)", "author": "minwoox", "createdAt": "2020-05-27T04:04:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzOTc2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzOTkzMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430839933", "bodyText": "need a space after ,. Please use auto-formatting.", "author": "minwoox", "createdAt": "2020-05-27T03:40:54Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MDc1NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430840755", "bodyText": "I think we can raise an error instead logging.\nthrow new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e)", "author": "minwoox", "createdAt": "2020-05-27T03:44:38Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MTA2MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430841060", "bodyText": "ensureUninitialized(\"initParameter\");", "author": "minwoox", "createdAt": "2020-05-27T03:45:50Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NjQyOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430846429", "bodyText": "newInstance is deprecated.\nclazz.getDeclaredConstructor().newInstance()", "author": "minwoox", "createdAt": "2020-05-27T04:10:32Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NjU2Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430846562", "bodyText": "throw new RuntimeException(\"Failed to create a serlvet: \" + class.getSimpleName() +, e)", "author": "minwoox", "createdAt": "2020-05-27T04:11:16Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0Njg2MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430846861", "bodyText": "We should return an immutable map so that a user does not modify this.", "author": "minwoox", "createdAt": "2020-05-27T04:12:43Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0ODI2NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430848265", "bodyText": "We can just return sessionTrackingModeSet if we do\nprivate Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\nAlso we can do:\nprivate static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n        Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);", "author": "minwoox", "createdAt": "2020-05-27T04:19:53Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        try {\n+            requireNonNull(filterName, \"filterName\");\n+            requireNonNull(className, \"className\");\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n+        filterRegistrationMap.put(filterName,registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        if (sessionTrackingModeSet == null) {", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU0NDYwMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r431544601", "bodyText": "When defaultSessionTrackingModeSet is immutable and sessionTrackingModeSet = defaultSessionTrackingModeSet, I think sessionTrackingModeSet has never changed. We should keep defaultSessionTrackingModeSet is not immutable and convert sessionTrackingModeSet to immutable in pack() method.", "author": "dominhhien", "createdAt": "2020-05-28T02:16:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0ODI2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU0NjExMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r431546113", "bodyText": "When defaultSessionTrackingModeSet is immutable and sessionTrackingModeSet = defaultSessionTrackingModeSet, I think sessionTrackingModeSet has never changed.\n\nI mean we can set defaultSessionTrackingModeSet to sessionTrackingModeSet when the class is initialized:\npublic class DefaultServletContext {\n    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n        Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n\n    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n\n    ...\n\n    // A user can set sessionTrackingModeSet using the setter.\n    @Override\n    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n        ...\n    }\n}\nSorry about the misleading comment. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-05-28T02:22:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0ODI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0ODMyOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430848329", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-05-27T04:20:07Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        try {\n+            requireNonNull(filterName, \"filterName\");\n+            requireNonNull(className, \"className\");\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n+        filterRegistrationMap.put(filterName,registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        if (sessionTrackingModeSet == null) {\n+            return getDefaultSessionTrackingModes();\n+        }\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0ODM0OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430848348", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-05-27T04:20:13Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        try {\n+            requireNonNull(filterName, \"filterName\");\n+            requireNonNull(className, \"className\");\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n+        filterRegistrationMap.put(filterName,registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        if (sessionTrackingModeSet == null) {\n+            return getDefaultSessionTrackingModes();\n+        }\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create listener failed: \", e);", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0ODYxMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430848612", "bodyText": "We do not need this", "author": "minwoox", "createdAt": "2020-05-27T04:21:21Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        try {\n+            requireNonNull(filterName, \"filterName\");\n+            requireNonNull(className, \"className\");\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n+        filterRegistrationMap.put(filterName,registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        if (sessionTrackingModeSet == null) {\n+            return getDefaultSessionTrackingModes();\n+        }\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create listener failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public JspConfigDescriptor getJspConfigDescriptor() {\n+        return null;\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader() {\n+        return this.getClass().getClassLoader();", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0ODYzNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430848635", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-05-27T04:21:28Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        try {\n+            requireNonNull(filterName, \"filterName\");\n+            requireNonNull(className, \"className\");\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n+        filterRegistrationMap.put(filterName,registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        if (sessionTrackingModeSet == null) {\n+            return getDefaultSessionTrackingModes();\n+        }\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create listener failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public JspConfigDescriptor getJspConfigDescriptor() {\n+        return null;\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader() {\n+        return this.getClass().getClassLoader();\n+    }\n+\n+    @Override\n+    public void declareRoles(String... roleNames) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getVirtualServerName() {\n+        return ServletUtil.getServerInfo()\n+        .concat(\" (localhost\")", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0OTE5Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430849196", "bodyText": "We can just return requestCharacterEncoding if we do:\nprivate String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name()", "author": "minwoox", "createdAt": "2020-05-27T04:24:05Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        try {\n+            requireNonNull(filterName, \"filterName\");\n+            requireNonNull(className, \"className\");\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n+        filterRegistrationMap.put(filterName,registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        if (sessionTrackingModeSet == null) {\n+            return getDefaultSessionTrackingModes();\n+        }\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create listener failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public JspConfigDescriptor getJspConfigDescriptor() {\n+        return null;\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader() {\n+        return this.getClass().getClassLoader();\n+    }\n+\n+    @Override\n+    public void declareRoles(String... roleNames) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getVirtualServerName() {\n+        return ServletUtil.getServerInfo()\n+        .concat(\" (localhost\")\n+        .concat(\":\")\n+        .concat(SystemPropertyUtil.get(\"user.name\"))\n+        .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getRequestCharacterEncoding() {\n+        if (requestCharacterEncoding == null) {", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0OTI0Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430849242", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-05-27T04:24:17Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        try {\n+            requireNonNull(filterName, \"filterName\");\n+            requireNonNull(className, \"className\");\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n+        filterRegistrationMap.put(filterName,registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        if (sessionTrackingModeSet == null) {\n+            return getDefaultSessionTrackingModes();\n+        }\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create listener failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public JspConfigDescriptor getJspConfigDescriptor() {\n+        return null;\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader() {\n+        return this.getClass().getClassLoader();\n+    }\n+\n+    @Override\n+    public void declareRoles(String... roleNames) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getVirtualServerName() {\n+        return ServletUtil.getServerInfo()\n+        .concat(\" (localhost\")\n+        .concat(\":\")\n+        .concat(SystemPropertyUtil.get(\"user.name\"))\n+        .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getRequestCharacterEncoding() {\n+        if (requestCharacterEncoding == null) {\n+            return HttpConstants.DEFAULT_CHARSET.name();\n+        }\n+        return requestCharacterEncoding;\n+    }\n+\n+    @Override\n+    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n+        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n+        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n+        this.requestCharacterEncoding = requestCharacterEncoding;\n+    }\n+\n+    @Override\n+    public String getResponseCharacterEncoding() {\n+        if (responseCharacterEncoding == null) {", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "url": "https://github.com/line/armeria/commit/a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "message": "Add immutable, servletPath / at last, and refactor", "committedDate": "2020-05-20T06:57:30Z", "type": "forcePushed"}, {"oid": "a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "url": "https://github.com/line/armeria/commit/a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "message": "Add immutable, servletPath / at last, and refactor", "committedDate": "2020-05-20T06:57:30Z", "type": "forcePushed"}, {"oid": "a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "url": "https://github.com/line/armeria/commit/a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "message": "Add immutable, servletPath / at last, and refactor", "committedDate": "2020-05-20T06:57:30Z", "type": "forcePushed"}, {"oid": "a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "url": "https://github.com/line/armeria/commit/a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "message": "Add immutable, servletPath / at last, and refactor", "committedDate": "2020-05-20T06:57:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5OTk5MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432299991", "bodyText": "public class -> final class", "author": "minwoox", "createdAt": "2020-05-29T07:20:34Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMTA3NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432301075", "bodyText": "For tomcat, this value is 30 minutes by default. Could you tell me where you brought?", "author": "minwoox", "createdAt": "2020-05-29T07:22:54Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMzMzE2MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432333161", "bodyText": "I think 15, 20, 30 minutes is ok. I will change to 30.", "author": "dominhhien", "createdAt": "2020-05-29T08:27:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMTA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMTQ0Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432301447", "bodyText": "Please move this up right down to logger so that private static final fields are located together.", "author": "minwoox", "createdAt": "2020-05-29T07:23:39Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNDc3OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432304778", "bodyText": "Please use SystemInfo first to get the information.\nAlso, please leave a comment in the code if you copy any source from another repository.\n// Forked from https://github.com/a/b/c...", "author": "minwoox", "createdAt": "2020-05-29T07:30:46Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNDkxNA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432304914", "bodyText": "Can remove public.", "author": "minwoox", "createdAt": "2020-05-29T07:31:01Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNjI2OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432306269", "bodyText": "Constructor -> Creates a new instance.\nIf you find trouble writing Javadoc, please refer to other classes and copy the phrases.\nThat'll help the reviewers a lot. \ud83d\ude47\u200d\u2642\ufe0f", "author": "minwoox", "createdAt": "2020-05-29T07:33:58Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNjM1Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432306352", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-05-29T07:34:14Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNjg5OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432306898", "bodyText": "ditto can remove public.\nPlease remove the public modifier of the methods that didn't override in this class.", "author": "minwoox", "createdAt": "2020-05-29T07:35:26Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNzcxMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432307713", "bodyText": "Can just init(). (No need boolean initialized).", "author": "minwoox", "createdAt": "2020-05-29T07:37:10Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwODg5OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432308899", "bodyText": "This is not adding just setting because it replaces the previous MimeMappings set.\nWe can just rename this setMimeMappings.\n(We usually name the method without set such as mimeMappings. However, the interface is already using the setX, so let's follow it.)", "author": "minwoox", "createdAt": "2020-05-29T07:39:40Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwOTg3Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432309872", "bodyText": "We don't need this because element.getObject() is not Nullable.", "author": "minwoox", "createdAt": "2020-05-29T07:41:36Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxMDM0MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432310341", "bodyText": "We can just return without assigning the local variable.", "author": "minwoox", "createdAt": "2020-05-29T07:42:29Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxMDgxMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432310813", "bodyText": "Please annotated @Nullable if a method returns null.", "author": "minwoox", "createdAt": "2020-05-29T07:43:13Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxMTY1MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432311650", "bodyText": "There's no need to unpack this. Let's remove this method.", "author": "minwoox", "createdAt": "2020-05-29T07:44:57Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxMTkzMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432311933", "bodyText": "We should remove this method and move the logic inside init() method.", "author": "minwoox", "createdAt": "2020-05-29T07:45:30Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxMzYwMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432313601", "bodyText": "Let's return the immutable view of the set so that a user cannot arbitrary modify the set.\nCollections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));", "author": "minwoox", "createdAt": "2020-05-29T07:48:54Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNDIzNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432314237", "bodyText": "please add\n//noinspection unchecked", "author": "minwoox", "createdAt": "2020-05-29T07:50:09Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNTEyOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432315128", "bodyText": "We just can\nfinal ServletRegistration servletRegistration =\n    new ServletRegistration(servletName, servlet, this, servletUrlMapper);", "author": "minwoox", "createdAt": "2020-05-29T07:51:59Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNTcxOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432315719", "bodyText": "What happened if two different servlets are registered using one servletName?", "author": "minwoox", "createdAt": "2020-05-29T07:53:10Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyNjkyOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432326929", "bodyText": "I think latest added servlet is working, because servlet registration like a Map<path, servlet>.", "author": "dominhhien", "createdAt": "2020-05-29T08:15:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNTcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNjcxNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432316716", "bodyText": "Ditto. please remove uncheck cast warning", "author": "minwoox", "createdAt": "2020-05-29T07:55:06Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNzMwNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432317306", "bodyText": "ditto What happened if two different filters are registered using the same name?", "author": "minwoox", "createdAt": "2020-05-29T07:56:17Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, filterUrlMapper);\n+        filterRegistrationMap.put(filterName, registration);", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyNjcyNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432326725", "bodyText": "I think latest added filters is working, because filter registration like a Map<path, filter>.", "author": "dominhhien", "createdAt": "2020-05-29T08:14:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNzMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMzMTY5OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432331699", "bodyText": "Then, shouldn't we raise an exception in that case?\nThere should be no one who wants to just override the previously set filter.\nIf it happens, there's likely the chance the filter is misconfigured.", "author": "minwoox", "createdAt": "2020-05-29T08:24:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNzMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMzNzE3NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432337175", "bodyText": "But I think what happen if user want to override an existing filter? And why doesn't servlet API have removeServlet() method , removeFilter() method. Should we add these methods?", "author": "dominhhien", "createdAt": "2020-05-29T08:34:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNzMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM2NjQ0Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432366443", "bodyText": "Then let's keep as it is. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-05-29T09:29:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNzMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNzc0NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432317745", "bodyText": "We should check the name is empty or not.\nWe can use isNullOrEmpty.", "author": "minwoox", "createdAt": "2020-05-29T07:57:10Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxODM1Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432318353", "bodyText": "If the name is empty, we should throw an exception.\n* @throws IllegalArgumentException if <code>servletName</code> is null\n* or an empty String", "author": "minwoox", "createdAt": "2020-05-29T07:58:25Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyNDEzMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432324130", "bodyText": "I think servlet support empty name, it is root servlet.", "author": "dominhhien", "createdAt": "2020-05-29T08:09:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxODM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyNTU4NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432325585", "bodyText": "https://github.com/javaee/servlet-spec/blob/master/src/main/java/javax/servlet/ServletContext.java#L769\nPlease refer to the Javadoc.", "author": "minwoox", "createdAt": "2020-05-29T08:12:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxODM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxODk4OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432318989", "bodyText": "sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModes);", "author": "minwoox", "createdAt": "2020-05-29T07:59:40Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, filterUrlMapper);\n+        filterRegistrationMap.put(filterName, registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a filter: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        ensureUninitialized(\"setSessionTrackingModes\");\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        sessionTrackingModeSet = sessionTrackingModes;", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxOTkwNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432319907", "bodyText": "please just use + instead of concat as the IDE suggested.", "author": "minwoox", "createdAt": "2020-05-29T08:01:32Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, filterUrlMapper);\n+        filterRegistrationMap.put(filterName, registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a filter: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        ensureUninitialized(\"setSessionTrackingModes\");\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a listener: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public JspConfigDescriptor getJspConfigDescriptor() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader() {\n+        return getClass().getClassLoader();\n+    }\n+\n+    @Override\n+    public void declareRoles(String... roleNames) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getVirtualServerName() {\n+        return ServletUtil.getServerInfo()\n+                          .concat(\" (localhost\")", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMDE2Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432320167", "bodyText": "We should not just append null when SystemPropertyUtil.get(\"user.name\") is null.", "author": "minwoox", "createdAt": "2020-05-29T08:02:06Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, filterUrlMapper);\n+        filterRegistrationMap.put(filterName, registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a filter: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        ensureUninitialized(\"setSessionTrackingModes\");\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a listener: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public JspConfigDescriptor getJspConfigDescriptor() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader() {\n+        return getClass().getClassLoader();\n+    }\n+\n+    @Override\n+    public void declareRoles(String... roleNames) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getVirtualServerName() {\n+        return ServletUtil.getServerInfo()\n+                          .concat(\" (localhost\")\n+                          .concat(\":\")\n+                          .concat(SystemPropertyUtil.get(\"user.name\"))", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "aa96a87ae69c06c7263c85ffd6bd380dd5cac309", "url": "https://github.com/line/armeria/commit/aa96a87ae69c06c7263c85ffd6bd380dd5cac309", "message": "Update the project version to 0.99.4-SNAPSHOT", "committedDate": "2020-04-14T09:34:08Z", "type": "forcePushed"}, {"oid": "891afd85893d0037e20b6b463f10bd868ea64aa9", "url": "https://github.com/line/armeria/commit/891afd85893d0037e20b6b463f10bd868ea64aa9", "message": "Add servlet service and servlet context", "committedDate": "2020-05-30T15:33:31Z", "type": "commit"}, {"oid": "2d6daa7900aec1c0979c770627091cd2dc7cbf84", "url": "https://github.com/line/armeria/commit/2d6daa7900aec1c0979c770627091cd2dc7cbf84", "message": "Add servlet registration", "committedDate": "2020-05-30T15:35:15Z", "type": "commit"}, {"oid": "f3901c7b1d501836fdfef54d306e0538c2aabda5", "url": "https://github.com/line/armeria/commit/f3901c7b1d501836fdfef54d306e0538c2aabda5", "message": "Add filter registration", "committedDate": "2020-05-30T15:35:56Z", "type": "commit"}, {"oid": "86f784aaa9a6d816ba866ff077b0129488d38cf1", "url": "https://github.com/line/armeria/commit/86f784aaa9a6d816ba866ff077b0129488d38cf1", "message": "Add http header constants", "committedDate": "2020-05-30T15:36:30Z", "type": "commit"}, {"oid": "d6f44acb772037593f35a6c4904ed6217db98c85", "url": "https://github.com/line/armeria/commit/d6f44acb772037593f35a6c4904ed6217db98c85", "message": "Add multi value map for http header", "committedDate": "2020-05-30T15:38:04Z", "type": "commit"}, {"oid": "7a0aeba630fc8bd1cf6cf9373223cb5cf5ed1faa", "url": "https://github.com/line/armeria/commit/7a0aeba630fc8bd1cf6cf9373223cb5cf5ed1faa", "message": "Add mime mapping", "committedDate": "2020-05-30T15:38:29Z", "type": "commit"}, {"oid": "42fea96e1d37d19f69dbc2b5be7945398a85d227", "url": "https://github.com/line/armeria/commit/42fea96e1d37d19f69dbc2b5be7945398a85d227", "message": "Add package info", "committedDate": "2020-05-30T15:39:05Z", "type": "commit"}, {"oid": "a371fbcc69c998ca7d0fafc2f719a74c7a19107f", "url": "https://github.com/line/armeria/commit/a371fbcc69c998ca7d0fafc2f719a74c7a19107f", "message": "Add servlet util", "committedDate": "2020-05-30T15:39:36Z", "type": "commit"}, {"oid": "f36779f5469e7ee81b3bf518e417bac1c4d82184", "url": "https://github.com/line/armeria/commit/f36779f5469e7ee81b3bf518e417bac1c4d82184", "message": "Add string util", "committedDate": "2020-05-30T15:39:55Z", "type": "commit"}, {"oid": "efdb71dfc7616c73e624fbe0d6dcc4be56a77d01", "url": "https://github.com/line/armeria/commit/efdb71dfc7616c73e624fbe0d6dcc4be56a77d01", "message": "Add url mapper", "committedDate": "2020-05-30T15:40:14Z", "type": "commit"}, {"oid": "3599f5fa15fc3cc1670693f892f758c8c3b0dc49", "url": "https://github.com/line/armeria/commit/3599f5fa15fc3cc1670693f892f758c8c3b0dc49", "message": "Add default servlet input stream", "committedDate": "2020-05-30T15:40:38Z", "type": "commit"}, {"oid": "0cf936d20cff5de77151e68b5b7dac2c599d6f69", "url": "https://github.com/line/armeria/commit/0cf936d20cff5de77151e68b5b7dac2c599d6f69", "message": "Add default servlet output stream", "committedDate": "2020-05-30T15:41:01Z", "type": "commit"}, {"oid": "30971c4a0616ca2f84b89800a651a6fcc3200ab8", "url": "https://github.com/line/armeria/commit/30971c4a0616ca2f84b89800a651a6fcc3200ab8", "message": "Add servlet builder", "committedDate": "2020-05-30T15:42:11Z", "type": "commit"}, {"oid": "40e2b348ccd45a199902c0116ca90f7e26fd407f", "url": "https://github.com/line/armeria/commit/40e2b348ccd45a199902c0116ca90f7e26fd407f", "message": "Add servlet http request", "committedDate": "2020-05-30T15:42:29Z", "type": "commit"}, {"oid": "1be8fac1f6a25ae7c9929070e2eb7161dd387ca4", "url": "https://github.com/line/armeria/commit/1be8fac1f6a25ae7c9929070e2eb7161dd387ca4", "message": "Add servlet http response", "committedDate": "2020-05-30T15:42:53Z", "type": "commit"}, {"oid": "ab4051a3f126fd2261a72e97c15de823f566c0c6", "url": "https://github.com/line/armeria/commit/ab4051a3f126fd2261a72e97c15de823f566c0c6", "message": "Add servlet print writer", "committedDate": "2020-05-30T15:43:15Z", "type": "commit"}, {"oid": "e06eed7c534e79419592b013002fdd20436e8bfb", "url": "https://github.com/line/armeria/commit/e06eed7c534e79419592b013002fdd20436e8bfb", "message": "Add servlet request dispatcher", "committedDate": "2020-05-30T15:43:35Z", "type": "commit"}, {"oid": "7e580df0b5c205936a4300fe2810e0f42e9d6981", "url": "https://github.com/line/armeria/commit/7e580df0b5c205936a4300fe2810e0f42e9d6981", "message": "Add servlet service test cases", "committedDate": "2020-05-30T15:44:52Z", "type": "commit"}, {"oid": "61114dc7236136fa84094a3ff944a23d1f3e7686", "url": "https://github.com/line/armeria/commit/61114dc7236136fa84094a3ff944a23d1f3e7686", "message": "Add servlet context path test cases", "committedDate": "2020-05-30T15:45:29Z", "type": "commit"}, {"oid": "7265ab94ab9a4b3a75f7bf000a152368849f925f", "url": "https://github.com/line/armeria/commit/7265ab94ab9a4b3a75f7bf000a152368849f925f", "message": "Add empty context path test cases", "committedDate": "2020-05-30T15:45:58Z", "type": "commit"}, {"oid": "edbc50c7a39c65a2c694db6a0b406b026a6a0f97", "url": "https://github.com/line/armeria/commit/edbc50c7a39c65a2c694db6a0b406b026a6a0f97", "message": "Add example servlet project", "committedDate": "2020-05-30T15:46:49Z", "type": "commit"}, {"oid": "2c6bdd6a4af3f39307a12c0565d97e9da2f1b472", "url": "https://github.com/line/armeria/commit/2c6bdd6a4af3f39307a12c0565d97e9da2f1b472", "message": "Remove filter code, auto formating code", "committedDate": "2020-05-30T16:44:06Z", "type": "commit"}, {"oid": "479451c48b73830f25bf2e1cf758c18d2e811d5f", "url": "https://github.com/line/armeria/commit/479451c48b73830f25bf2e1cf758c18d2e811d5f", "message": "Remove http header constants", "committedDate": "2020-05-31T09:04:38Z", "type": "commit"}, {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "url": "https://github.com/line/armeria/commit/b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "message": "Set private access", "committedDate": "2020-05-31T12:00:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5NDAwMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433594001", "bodyText": "Because this class is package-private now, we can remove public modifier from the methods which is not overriding.", "author": "minwoox", "createdAt": "2020-06-02T02:58:23Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeout = 30; // unit: minutes\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void init() {", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5NTkzOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433595939", "bodyText": "Could be just \"servletName is empty\" in this case.", "author": "minwoox", "createdAt": "2020-06-02T03:07:37Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeout = 30; // unit: minutes\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void setMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        return new ServletRequestDispatcher(new ServletFilterChain(element.getObject()), path, element);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo();\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5NjQwNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433596405", "bodyText": "I think we can call this in the constructor of ServletRegistration.", "author": "minwoox", "createdAt": "2020-06-02T03:09:48Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeout = 30; // unit: minutes\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void setMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        return new ServletRequestDispatcher(new ServletFilterChain(element.getObject()), path, element);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo();\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(className, \"className\");\n+        try {\n+            //noinspection unchecked\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        servletName = servletName.trim();\n+        final ServletRegistration servletRegistration =\n+                new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        servletRegistration.addMapping(servletName);", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5NzQzMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433597433", "bodyText": "Could remove public?\nCould be final?\nDefaultServletRegistration because ServletRegistration is the name of the interface?", "author": "minwoox", "createdAt": "2020-06-02T03:14:35Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5ODMxNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433598315", "bodyText": "Should we pass the initMap to ServletRegistration?", "author": "minwoox", "createdAt": "2020-06-02T03:18:27Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeout = 30; // unit: minutes\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void setMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        return new ServletRequestDispatcher(new ServletFilterChain(element.getObject()), path, element);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo();\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(className, \"className\");\n+        try {\n+            //noinspection unchecked\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        servletName = servletName.trim();\n+        final ServletRegistration servletRegistration =\n+                new ServletRegistration(servletName, servlet, this, servletUrlMapper);", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5ODYyMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433598622", "bodyText": "Can remove ServletRegistration.this.", "author": "minwoox", "createdAt": "2020-06-02T03:20:01Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5ODY1Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433598656", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-06-02T03:20:08Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5ODgwOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433598809", "bodyText": "return initParameterMap.get(name);", "author": "minwoox", "createdAt": "2020-06-02T03:20:48Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5OTAwMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433599001", "bodyText": "When this method is used? If this is not used now, can we add this when we need?", "author": "minwoox", "createdAt": "2020-06-02T03:21:49Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get servlet security element.\n+     */\n+    @Nullable\n+    public ServletSecurityElement getServletSecurityElement() {", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5OTAyNA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433599024", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-06-02T03:21:54Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get servlet security element.\n+     */\n+    @Nullable\n+    public ServletSecurityElement getServletSecurityElement() {\n+        return servletSecurityElement;\n+    }\n+\n+    /**\n+     * Get multipart config element.\n+     */\n+    @Nullable\n+    public MultipartConfigElement getMultipartConfigElement() {", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5OTQ3MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433599470", "bodyText": "Can we remove this method and make this registration is initialized when it created?", "author": "minwoox", "createdAt": "2020-06-02T03:23:50Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get servlet security element.\n+     */\n+    @Nullable\n+    public ServletSecurityElement getServletSecurityElement() {\n+        return servletSecurityElement;\n+    }\n+\n+    /**\n+     * Get multipart config element.\n+     */\n+    @Nullable\n+    public MultipartConfigElement getMultipartConfigElement() {\n+        return multipartConfigElement;\n+    }\n+\n+    /**\n+     * Get servlet config.\n+     */\n+    public ServletConfig getServletConfig() {\n+        return servletConfig;\n+    }\n+\n+    /**\n+     * Get servlet.\n+     */\n+    public Servlet getServlet() {\n+        return servlet;\n+    }\n+\n+    /**\n+     * Is async supported.\n+     */\n+    public Boolean isAsyncSupported() {\n+        return asyncSupported;\n+    }\n+\n+    /**\n+     * Get load on startup.\n+     */\n+    public int getLoadOnStartup() {\n+        return loadOnStartup;\n+    }\n+\n+    /**\n+     * Is initialization servlet cas.\n+     */\n+    public boolean isInitServletCas(boolean expect, boolean update) {", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMDE4Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433600183", "bodyText": "It seems like we need to return the mappingSet that urlPatterns are added before.", "author": "minwoox", "createdAt": "2020-06-02T03:27:04Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get servlet security element.\n+     */\n+    @Nullable\n+    public ServletSecurityElement getServletSecurityElement() {\n+        return servletSecurityElement;\n+    }\n+\n+    /**\n+     * Get multipart config element.\n+     */\n+    @Nullable\n+    public MultipartConfigElement getMultipartConfigElement() {\n+        return multipartConfigElement;\n+    }\n+\n+    /**\n+     * Get servlet config.\n+     */\n+    public ServletConfig getServletConfig() {\n+        return servletConfig;\n+    }\n+\n+    /**\n+     * Get servlet.\n+     */\n+    public Servlet getServlet() {\n+        return servlet;\n+    }\n+\n+    /**\n+     * Is async supported.\n+     */\n+    public Boolean isAsyncSupported() {\n+        return asyncSupported;\n+    }\n+\n+    /**\n+     * Get load on startup.\n+     */\n+    public int getLoadOnStartup() {\n+        return loadOnStartup;\n+    }\n+\n+    /**\n+     * Is initialization servlet cas.\n+     */\n+    public boolean isInitServletCas(boolean expect, boolean update) {\n+        return initServlet.compareAndSet(expect, update);\n+    }\n+\n+    /**\n+     * Is initialization servlet.\n+     */\n+    public boolean isInitServlet() {\n+        return initServlet.get();\n+    }\n+\n+    @Override\n+    public Set<String> addMapping(String... urlPatterns) {\n+        requireNonNull(urlPatterns, \"urlPatterns\");\n+        mappingSet.addAll(Arrays.asList(urlPatterns));\n+        for (String pattern : urlPatterns) {\n+            urlMapper.addMapping(pattern, this, servletName);\n+        }\n+        return mappingSet;", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY5NjA1MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433696051", "bodyText": "yes, each servlet have one ServletRegistration to addMapping multiple urlPatterns to one servletName such as: urlPattern (\"/home\", \"/home/user\", \"/home/*\") map to servletName (\"home\").\nI think, mappingSet is returned to check which urlPatterns were mapped.", "author": "dominhhien", "createdAt": "2020-06-02T08:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMDE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMDQ3Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433600473", "bodyText": "Question: Don't we need to validate the value before assigning?", "author": "minwoox", "createdAt": "2020-06-02T03:28:22Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get servlet security element.\n+     */\n+    @Nullable\n+    public ServletSecurityElement getServletSecurityElement() {\n+        return servletSecurityElement;\n+    }\n+\n+    /**\n+     * Get multipart config element.\n+     */\n+    @Nullable\n+    public MultipartConfigElement getMultipartConfigElement() {\n+        return multipartConfigElement;\n+    }\n+\n+    /**\n+     * Get servlet config.\n+     */\n+    public ServletConfig getServletConfig() {\n+        return servletConfig;\n+    }\n+\n+    /**\n+     * Get servlet.\n+     */\n+    public Servlet getServlet() {\n+        return servlet;\n+    }\n+\n+    /**\n+     * Is async supported.\n+     */\n+    public Boolean isAsyncSupported() {\n+        return asyncSupported;\n+    }\n+\n+    /**\n+     * Get load on startup.\n+     */\n+    public int getLoadOnStartup() {\n+        return loadOnStartup;\n+    }\n+\n+    /**\n+     * Is initialization servlet cas.\n+     */\n+    public boolean isInitServletCas(boolean expect, boolean update) {\n+        return initServlet.compareAndSet(expect, update);\n+    }\n+\n+    /**\n+     * Is initialization servlet.\n+     */\n+    public boolean isInitServlet() {\n+        return initServlet.get();\n+    }\n+\n+    @Override\n+    public Set<String> addMapping(String... urlPatterns) {\n+        requireNonNull(urlPatterns, \"urlPatterns\");\n+        mappingSet.addAll(Arrays.asList(urlPatterns));\n+        for (String pattern : urlPatterns) {\n+            urlMapper.addMapping(pattern, this, servletName);\n+        }\n+        return mappingSet;\n+    }\n+\n+    @Override\n+    public Collection<String> getMappings() {\n+        return mappingSet;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getRunAsRole() {\n+        return roleName;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return servletName;\n+    }\n+\n+    @Override\n+    public String getClassName() {\n+        return servlet.getClass().getName();\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, String value) {\n+        throw new IllegalStateException(\"Can't set init parameter after ServletRegistration is initialized\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParameterMap.get(name);\n+    }\n+\n+    @Override\n+    public Set<String> setInitParameters(Map<String, String> initParameters) {\n+        throw new IllegalStateException(\"Can't set init parameters after ServletRegistration is initialized\");\n+    }\n+\n+    @Override\n+    public Map<String, String> getInitParameters() {\n+        return initParameterMap;\n+    }\n+\n+    @Override\n+    public void setLoadOnStartup(int loadOnStartup) {\n+        this.loadOnStartup = loadOnStartup;", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcwMDcyOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433700728", "bodyText": "I see method's document: loadOnStartup may be positive, negative and zero. Therefore, I don't validate this value.", "author": "dominhhien", "createdAt": "2020-06-02T08:17:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMDQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMDcxNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433600715", "bodyText": "ditto:\n* @return the (possibly empty) Set of URL patterns that were already\n* the exact target of a <code>security-constraint</code> that was\n* established via the portable deployment descriptor. This method\n* has no effect on the patterns included in the returned set", "author": "minwoox", "createdAt": "2020-06-02T03:29:35Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get servlet security element.\n+     */\n+    @Nullable\n+    public ServletSecurityElement getServletSecurityElement() {\n+        return servletSecurityElement;\n+    }\n+\n+    /**\n+     * Get multipart config element.\n+     */\n+    @Nullable\n+    public MultipartConfigElement getMultipartConfigElement() {\n+        return multipartConfigElement;\n+    }\n+\n+    /**\n+     * Get servlet config.\n+     */\n+    public ServletConfig getServletConfig() {\n+        return servletConfig;\n+    }\n+\n+    /**\n+     * Get servlet.\n+     */\n+    public Servlet getServlet() {\n+        return servlet;\n+    }\n+\n+    /**\n+     * Is async supported.\n+     */\n+    public Boolean isAsyncSupported() {\n+        return asyncSupported;\n+    }\n+\n+    /**\n+     * Get load on startup.\n+     */\n+    public int getLoadOnStartup() {\n+        return loadOnStartup;\n+    }\n+\n+    /**\n+     * Is initialization servlet cas.\n+     */\n+    public boolean isInitServletCas(boolean expect, boolean update) {\n+        return initServlet.compareAndSet(expect, update);\n+    }\n+\n+    /**\n+     * Is initialization servlet.\n+     */\n+    public boolean isInitServlet() {\n+        return initServlet.get();\n+    }\n+\n+    @Override\n+    public Set<String> addMapping(String... urlPatterns) {\n+        requireNonNull(urlPatterns, \"urlPatterns\");\n+        mappingSet.addAll(Arrays.asList(urlPatterns));\n+        for (String pattern : urlPatterns) {\n+            urlMapper.addMapping(pattern, this, servletName);\n+        }\n+        return mappingSet;\n+    }\n+\n+    @Override\n+    public Collection<String> getMappings() {\n+        return mappingSet;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getRunAsRole() {\n+        return roleName;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return servletName;\n+    }\n+\n+    @Override\n+    public String getClassName() {\n+        return servlet.getClass().getName();\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, String value) {\n+        throw new IllegalStateException(\"Can't set init parameter after ServletRegistration is initialized\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParameterMap.get(name);\n+    }\n+\n+    @Override\n+    public Set<String> setInitParameters(Map<String, String> initParameters) {\n+        throw new IllegalStateException(\"Can't set init parameters after ServletRegistration is initialized\");\n+    }\n+\n+    @Override\n+    public Map<String, String> getInitParameters() {\n+        return initParameterMap;\n+    }\n+\n+    @Override\n+    public void setLoadOnStartup(int loadOnStartup) {\n+        this.loadOnStartup = loadOnStartup;\n+    }\n+\n+    @Override\n+    public Set<String> setServletSecurity(ServletSecurityElement constraint) {\n+        requireNonNull(constraint, \"constraint\");\n+        servletSecurityElement = constraint;\n+        return new HashSet<>(servletSecurityElement.getMethodNames());", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzczODAxMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433738010", "bodyText": "I think returning HashSet<>(servletSecurityElement.getMethodNames()) for checking.", "author": "dominhhien", "createdAt": "2020-06-02T09:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMDcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMDg1Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433600853", "bodyText": "We can just do this in one line: this.roleName = requireNonNull(roleName, \"roleName\");", "author": "minwoox", "createdAt": "2020-06-02T03:30:11Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get servlet security element.\n+     */\n+    @Nullable\n+    public ServletSecurityElement getServletSecurityElement() {\n+        return servletSecurityElement;\n+    }\n+\n+    /**\n+     * Get multipart config element.\n+     */\n+    @Nullable\n+    public MultipartConfigElement getMultipartConfigElement() {\n+        return multipartConfigElement;\n+    }\n+\n+    /**\n+     * Get servlet config.\n+     */\n+    public ServletConfig getServletConfig() {\n+        return servletConfig;\n+    }\n+\n+    /**\n+     * Get servlet.\n+     */\n+    public Servlet getServlet() {\n+        return servlet;\n+    }\n+\n+    /**\n+     * Is async supported.\n+     */\n+    public Boolean isAsyncSupported() {\n+        return asyncSupported;\n+    }\n+\n+    /**\n+     * Get load on startup.\n+     */\n+    public int getLoadOnStartup() {\n+        return loadOnStartup;\n+    }\n+\n+    /**\n+     * Is initialization servlet cas.\n+     */\n+    public boolean isInitServletCas(boolean expect, boolean update) {\n+        return initServlet.compareAndSet(expect, update);\n+    }\n+\n+    /**\n+     * Is initialization servlet.\n+     */\n+    public boolean isInitServlet() {\n+        return initServlet.get();\n+    }\n+\n+    @Override\n+    public Set<String> addMapping(String... urlPatterns) {\n+        requireNonNull(urlPatterns, \"urlPatterns\");\n+        mappingSet.addAll(Arrays.asList(urlPatterns));\n+        for (String pattern : urlPatterns) {\n+            urlMapper.addMapping(pattern, this, servletName);\n+        }\n+        return mappingSet;\n+    }\n+\n+    @Override\n+    public Collection<String> getMappings() {\n+        return mappingSet;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getRunAsRole() {\n+        return roleName;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return servletName;\n+    }\n+\n+    @Override\n+    public String getClassName() {\n+        return servlet.getClass().getName();\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, String value) {\n+        throw new IllegalStateException(\"Can't set init parameter after ServletRegistration is initialized\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParameterMap.get(name);\n+    }\n+\n+    @Override\n+    public Set<String> setInitParameters(Map<String, String> initParameters) {\n+        throw new IllegalStateException(\"Can't set init parameters after ServletRegistration is initialized\");\n+    }\n+\n+    @Override\n+    public Map<String, String> getInitParameters() {\n+        return initParameterMap;\n+    }\n+\n+    @Override\n+    public void setLoadOnStartup(int loadOnStartup) {\n+        this.loadOnStartup = loadOnStartup;\n+    }\n+\n+    @Override\n+    public Set<String> setServletSecurity(ServletSecurityElement constraint) {\n+        requireNonNull(constraint, \"constraint\");\n+        servletSecurityElement = constraint;\n+        return new HashSet<>(servletSecurityElement.getMethodNames());\n+    }\n+\n+    @Override\n+    public void setMultipartConfig(MultipartConfigElement multipartConfig) {\n+        requireNonNull(multipartConfig, \"multipartConfig\");\n+        multipartConfigElement = multipartConfig;\n+    }\n+\n+    @Override\n+    public void setRunAsRole(String roleName) {\n+        requireNonNull(roleName, \"roleName\");\n+        this.roleName = roleName;", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMTUwMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433601503", "bodyText": "If the class is used only in the package we can make it as package-private.\nAlso, the methods are as well. We do not need the public modifier.\nCould you check all classes, please?", "author": "minwoox", "createdAt": "2020-06-02T03:33:30Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMjExMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433602113", "bodyText": "DefaultHttpServletRequest ?", "author": "minwoox", "createdAt": "2020-06-02T03:36:34Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,768 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMjM3Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433602377", "bodyText": "We can use HttpMethod.POST.toString() instead.", "author": "minwoox", "createdAt": "2020-06-02T03:38:00Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,768 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final int HTTPS_PORT = 443;\n+    private static final int HTTP_PORT = 80;\n+    private static final String HTTPS = \"https\";\n+    private static final String HTTP = \"http\";\n+    private static final String POST = \"POST\";", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMjU1Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433602556", "bodyText": "We can use SessionProtocol.HTTP.uriText() instead.", "author": "minwoox", "createdAt": "2020-06-02T03:38:53Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,768 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final int HTTPS_PORT = 443;\n+    private static final int HTTP_PORT = 80;\n+    private static final String HTTPS = \"https\";\n+    private static final String HTTP = \"http\";", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMjU3Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433602576", "bodyText": "We can use SessionProtocol.HTTPS.uriText() instead.", "author": "minwoox", "createdAt": "2020-06-02T03:39:00Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,768 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final int HTTPS_PORT = 443;\n+    private static final int HTTP_PORT = 80;\n+    private static final String HTTPS = \"https\";", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMjk4OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433602989", "bodyText": "We can use SessionProtocol.HTTP.defaultPort() instead.", "author": "minwoox", "createdAt": "2020-06-02T03:41:11Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,768 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final int HTTPS_PORT = 443;\n+    private static final int HTTP_PORT = 80;", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMzAxMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433603010", "bodyText": "We can use SessionProtocol.HTTPS.defaultPort() instead.", "author": "minwoox", "createdAt": "2020-06-02T03:41:17Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,768 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final int HTTPS_PORT = 443;", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwNDkzMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433604932", "bodyText": "Let's make this variable as final because we can extract this value when the ServletHttpRequest is initialized.\nfinal Charset charset = httpRequest.headers().contentType().charset();\nif (charset != null) {\n    ...\n} else {\n    ...\n}", "author": "minwoox", "createdAt": "2020-06-02T03:50:11Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,768 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final int HTTPS_PORT = 443;\n+    private static final int HTTP_PORT = 80;\n+    private static final String HTTPS = \"https\";\n+    private static final String HTTP = \"http\";\n+    private static final String POST = \"POST\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(ServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream = new DefaultServletInputStream();\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+\n+    private LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private List<Part> fileUploadList = new ArrayList<>();\n+    private Boolean asyncSupportedFlag = true;\n+\n+    @Nullable\n+    private String servletPath;\n+    @Nullable\n+    private String queryString;\n+    @Nullable\n+    private String pathInfo;\n+    @Nullable\n+    private String requestURI;\n+    @Nullable\n+    private String characterEncoding;", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwNTA1Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433605057", "bodyText": "Please consider all other fields if we can do the same approach. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-06-02T03:50:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwNDkzMg=="}], "type": "inlineReview"}, {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "url": "https://github.com/line/armeria/commit/b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "message": "Set private access", "committedDate": "2020-05-31T12:00:31Z", "type": "forcePushed"}, {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "url": "https://github.com/line/armeria/commit/b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "message": "Set private access", "committedDate": "2020-05-31T12:00:31Z", "type": "forcePushed"}, {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "message": "Set final classes and final fields", "committedDate": "2020-06-03T04:10:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyMzEwNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434323107", "bodyText": "The Javadoc says that this will return null if the header does not exist.\nLet's just return httpRequest.headers().get(name); and add @Nullable", "author": "minwoox", "createdAt": "2020-06-03T05:53:00Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,727 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String pathInfo;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final String queryString;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final String encoding = ServletUtil.decodeCharacterEncoding(getContentType());\n+        characterEncoding = encoding != null ? encoding : servletContext.getRequestCharacterEncoding();\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (headerValue.isEmpty()) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (!isNullOrEmpty(value)) {\n+            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n+            if (!cookieSet.isEmpty()) {\n+                return cookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeRequestURI() {\n+        final String path = httpRequest.path();\n+        int queryInx = path.indexOf('?');\n+        if (queryInx == -1) {\n+            queryInx = path.indexOf('#');\n+        }\n+        return queryInx > -1 ? path.substring(0, queryInx) : path;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = httpRequest.headers().get(name);", "originalCommit": "4e975863fba562297d53e30d67bbaee12c836d1e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNjk0Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434326942", "bodyText": "yes, each servlet have one ServletRegistration to addMapping multiple urlPatterns to one servletName such as: urlPattern (\"/home\", \"/home/user\", \"/home/*\") map to servletName (\"home\").\nI think, mappingSet is returned to check which urlPatterns were mapped.\n\nSo this shouldn't be:\nrequireNonNull(urlPatterns, \"urlPatterns\");\nfinal Set<String> current = ImmutableSet.copyOf(mappingSet);\nmappingSet.addAll(Arrays.asList(urlPatterns));\nfor (String pattern : urlPatterns) {\n    urlMapper.addMapping(pattern, this, servletName);\n}\nreturn current;\n?", "author": "minwoox", "createdAt": "2020-06-03T06:05:05Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+final class DefaultServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final UrlMapper<DefaultServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<DefaultServletRegistration> urlMapper,\n+                               Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return initParameterMap.get(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+        addMapping(servletName);\n+    }\n+\n+    /**\n+     * Get servlet config.\n+     */\n+    ServletConfig getServletConfig() {\n+        return servletConfig;\n+    }\n+\n+    /**\n+     * Get servlet.\n+     */\n+    Servlet getServlet() {\n+        return servlet;\n+    }\n+\n+    @Override\n+    public Set<String> addMapping(String... urlPatterns) {\n+        requireNonNull(urlPatterns, \"urlPatterns\");\n+        mappingSet.addAll(Arrays.asList(urlPatterns));\n+        for (String pattern : urlPatterns) {\n+            urlMapper.addMapping(pattern, this, servletName);\n+        }\n+        return mappingSet;", "originalCommit": "4e975863fba562297d53e30d67bbaee12c836d1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM3NDAxMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434374010", "bodyText": "I think, source code's logic is right. Because mappingSet only store urlPatterns of this servletRegistration and urlMapper store urlPatterns of all servletRegistration. I think we only need to add checkState() to return if ServletContext is initialized at here. How do you think?\ncheckState(!((DefaultServletContext) servletConfig.getServletContext()).isInitialized(),\n                   \"Can't add servlet mapping after the servlet context is initialized.\");", "author": "dominhhien", "createdAt": "2020-06-03T07:48:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNjk0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM4MjI2OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434382269", "bodyText": "Do you mean we should return current (mappingSet before add urlPatterns) instead of (mappingSet after add urlPattern)?", "author": "dominhhien", "createdAt": "2020-06-03T08:03:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNjk0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM4Mzg0MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434383841", "bodyText": "Ah, I misunderstand the Javadoc. Then, I'm wondering if we follow what Tomcat does: https://github.com/quickhack/tomcat/blob/master/src/main/java/org/apache/catalina/core/ApplicationServletRegistration.java#L166\n\ud83e\udd14", "author": "minwoox", "createdAt": "2020-06-03T08:06:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNjk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNzU3Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434327573", "bodyText": "Is there any chances that two thread access this map?", "author": "minwoox", "createdAt": "2020-06-03T06:07:03Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,727 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();", "originalCommit": "4e975863fba562297d53e30d67bbaee12c836d1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM1MzY2NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434353664", "bodyText": "I think two thread never access one this map instance because each httprequest run on one thread and create a parameterMap instance.", "author": "dominhhien", "createdAt": "2020-06-03T07:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNzU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNzg1OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434327859", "bodyText": "please remove this and just return ImmutableMap.copyOf(parameterMap) where it used.", "author": "minwoox", "createdAt": "2020-06-03T06:07:55Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,727 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String pathInfo;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final String queryString;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {", "originalCommit": "4e975863fba562297d53e30d67bbaee12c836d1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM1MTYzNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434351636", "bodyText": "I think unmodifiableParameterMap not only immutable of parameterMap but also convert parammeter value from String to String[]", "author": "dominhhien", "createdAt": "2020-06-03T07:06:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNzg1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1ODY2MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434958661", "bodyText": "Let's assign this value in the constructor and return it so that we don't have to parse every time it needs", "author": "minwoox", "createdAt": "2020-06-04T02:34:32Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (!isNullOrEmpty(value)) {\n+            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n+            if (!cookieSet.isEmpty()) {\n+                return cookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeRequestURI() {\n+        final String path = httpRequest.path();\n+        int queryInx = path.indexOf('?');\n+        if (queryInx == -1) {\n+            queryInx = path.indexOf('#');\n+        }\n+        return queryInx > -1 ? path.substring(0, queryInx) : path;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())", "originalCommit": "2afebf424f796fd96f5d5c188dbb668992eed379", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1ODgyNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434958825", "bodyText": "We should return -1 if the length is greater than Integer.MAX_VALUE", "author": "minwoox", "createdAt": "2020-06-04T02:35:06Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (!isNullOrEmpty(value)) {\n+            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n+            if (!cookieSet.isEmpty()) {\n+                return cookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeRequestURI() {\n+        final String path = httpRequest.path();\n+        int queryInx = path.indexOf('?');\n+        if (queryInx == -1) {\n+            queryInx = path.indexOf('#');\n+        }\n+        return queryInx > -1 ? path.substring(0, queryInx) : path;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();", "originalCommit": "2afebf424f796fd96f5d5c188dbb668992eed379", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1OTAxNA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434959014", "bodyText": "Let's just do HttpMethod.POST == httpRequest.method()", "author": "minwoox", "createdAt": "2020-06-04T02:35:54Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {", "originalCommit": "2afebf424f796fd96f5d5c188dbb668992eed379", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1OTQyOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434959429", "bodyText": "We should call this only when the content type is MediaType.FORM_DATA?", "author": "minwoox", "createdAt": "2020-06-04T02:37:39Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());", "originalCommit": "2afebf424f796fd96f5d5c188dbb668992eed379", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2MjQxNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434962417", "bodyText": "serviceRequestContext.path() does not contain the query", "author": "minwoox", "createdAt": "2020-06-04T02:49:59Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();", "originalCommit": "2afebf424f796fd96f5d5c188dbb668992eed379", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2NzE5Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434967197", "bodyText": "We have the logic for decoding cookies already. Let's use that:\nfinal String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\nif (cookieValue != null) {\n    final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n    this.cookies = cookies.stream().map(c -> {\n        final Cookie cookie = new Cookie(c.name(), c.value());\n        cookie.setDomain(c.domain());\n        cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n        cookie.setHttpOnly(c.isHttpOnly());\n        ... // more settings\n        return new Cookie(c.name(), c.value());\n    }).toArray(Cookie[]::new);\n} else {\n    this.cookies = COOKIES;\n}", "author": "minwoox", "createdAt": "2020-06-04T03:09:18Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();", "originalCommit": "2afebf424f796fd96f5d5c188dbb668992eed379", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2OTMxOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434969318", "bodyText": "Let's remove decodeUrlParameter and decodeBody.\nWe can use QueryParam for this purpose.\nFirst we need to move this logic to an internal public class to use together.\npackage com.linecorp.armeria.internal.server;\n\npublic final class QueryParamUtil {\n    ...\n}\nThen, we can use the method to parse assign to the field QueryParams queryParams.\nSo we can remove parameterMap and unmodifiableParameterMap.", "author": "minwoox", "createdAt": "2020-06-04T03:18:20Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();", "originalCommit": "2afebf424f796fd96f5d5c188dbb668992eed379", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2OTQyNA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434969424", "bodyText": "Then we can simple do queryParams.get(name);", "author": "minwoox", "createdAt": "2020-06-04T03:18:53Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (!isNullOrEmpty(value)) {\n+            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n+            if (!cookieSet.isEmpty()) {\n+                return cookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeRequestURI() {\n+        final String path = httpRequest.path();\n+        int queryInx = path.indexOf('?');\n+        if (queryInx == -1) {\n+            queryInx = path.indexOf('#');\n+        }\n+        return queryInx > -1 ? path.substring(0, queryInx) : path;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n+                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        final String[] values = getParameterMap().get(name);", "originalCommit": "2afebf424f796fd96f5d5c188dbb668992eed379", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2OTQ3Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434969472", "bodyText": "return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));", "author": "minwoox", "createdAt": "2020-06-04T03:19:05Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (!isNullOrEmpty(value)) {\n+            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n+            if (!cookieSet.isEmpty()) {\n+                return cookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeRequestURI() {\n+        final String path = httpRequest.path();\n+        int queryInx = path.indexOf('?');\n+        if (queryInx == -1) {\n+            queryInx = path.indexOf('#');\n+        }\n+        return queryInx > -1 ? path.substring(0, queryInx) : path;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n+                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        final String[] values = getParameterMap().get(name);\n+        if (values == null || values.length == 0) {\n+            return null;\n+        }\n+        return values[0];\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));", "originalCommit": "2afebf424f796fd96f5d5c188dbb668992eed379", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2OTUzNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434969537", "bodyText": "return queryParams.getAll(name).toArray(String[]::new);", "author": "minwoox", "createdAt": "2020-06-04T03:19:22Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (!isNullOrEmpty(value)) {\n+            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n+            if (!cookieSet.isEmpty()) {\n+                return cookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeRequestURI() {\n+        final String path = httpRequest.path();\n+        int queryInx = path.indexOf('?');\n+        if (queryInx == -1) {\n+            queryInx = path.indexOf('#');\n+        }\n+        return queryInx > -1 ? path.substring(0, queryInx) : path;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n+                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        final String[] values = getParameterMap().get(name);\n+        if (values == null || values.length == 0) {\n+            return null;\n+        }\n+        return values[0];\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        return getParameterMap().get(name);", "originalCommit": "2afebf424f796fd96f5d5c188dbb668992eed379", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2OTcwMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434969702", "bodyText": "We can build this using the queryParam. This will be expensive so we might create this one time in the constructor and reuse it.", "author": "minwoox", "createdAt": "2020-06-04T03:20:04Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (!isNullOrEmpty(value)) {\n+            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n+            if (!cookieSet.isEmpty()) {\n+                return cookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeRequestURI() {\n+        final String path = httpRequest.path();\n+        int queryInx = path.indexOf('?');\n+        if (queryInx == -1) {\n+            queryInx = path.indexOf('#');\n+        }\n+        return queryInx > -1 ? path.substring(0, queryInx) : path;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n+                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        final String[] values = getParameterMap().get(name);\n+        if (values == null || values.length == 0) {\n+            return null;\n+        }\n+        return values[0];\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        return getParameterMap().get(name);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return unmodifiableParameterMap;", "originalCommit": "2afebf424f796fd96f5d5c188dbb668992eed379", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "message": "Set final classes and final fields", "committedDate": "2020-06-03T04:10:42Z", "type": "forcePushed"}, {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "message": "Set final classes and final fields", "committedDate": "2020-06-03T04:10:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0MjIyNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435842227", "bodyText": "public abstract-> public final\nAnd we need to add a private constructor\nprivate QueryParamUtil() {}", "author": "minwoox", "createdAt": "2020-06-05T10:47:53Z", "path": "core/src/main/java/com/linecorp/armeria/internal/server/QueryParamUtil.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.nio.charset.StandardCharsets;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+\n+/**\n+ * Parse query parameters.\n+ */\n+public abstract class QueryParamUtil {", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0MzQ5NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435843495", "bodyText": "The reason that I wanted you to put this class in this package was that I wanted to have the parsing logic here only so that we can remove the duplicate code.\nIs there any reason that you cannot move queryParamsOf() in AnnotatedValueResolver?", "author": "minwoox", "createdAt": "2020-06-05T10:50:55Z", "path": "core/src/main/java/com/linecorp/armeria/internal/server/QueryParamUtil.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.nio.charset.StandardCharsets;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+\n+/**\n+ * Parse query parameters.\n+ */\n+public abstract class QueryParamUtil {\n+\n+    /**\n+     * Parse aggregated http request to query parameters.\n+     */\n+    public static QueryParams parse(AggregatedHttpRequest request) throws IOException {", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk4MTAzNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435981036", "bodyText": "I think, we cannot use AnnotatedValueResolver.queryParamOf() because I want to QueryParamUtil will support at future:\n\nparse parameters from url\nparse parameters from body\nparse upload files from multipart\n\nAnnotatedValueResolver.queryParamOf() doesn't support all these features.", "author": "dominhhien", "createdAt": "2020-06-05T15:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0MzQ5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxMjY0NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r436012645", "bodyText": "Thanks for the explanation. \ud83d\ude04\nI think AnnotatedValueResolver.queryParamsOf() can\n\nparse parameters from URL.\nparse parameters from body.\n\nBut it cannot\n\nparse upload files from multipart\n\nIt's because we do not provide multipart support on Armeria at the moment. However, once we support it, annotated services and Servlet will use the same logic to parse that. Which means that we have to put the logic in the same place.\nSo what I recommended is, could you just copy the code into the DefaultServletHttpRequest and use it? I will send a follow up PR that removes the duplicate code. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-06-05T15:54:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0MzQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0NzA5MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435847090", "bodyText": "x.split(\";\") happend twice.", "author": "minwoox", "createdAt": "2020-06-05T10:58:55Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0ODk4NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435848984", "bodyText": "It seems like the parsing locale logic is a little bit complex. We also have to consider quality as well.\nIf you want we can make a separate PR for this. If you want to include it in this PR, how about referring what other frameworks do? For example: https://github.com/apache/tomcat/blob/master/java/org/apache/catalina/connector/Request.java#L3329", "author": "minwoox", "createdAt": "2020-06-05T11:03:01Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNDAzMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r436224030", "bodyText": "I will create a separate PR for this later :)", "author": "dominhhien", "createdAt": "2020-06-06T01:18:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0ODk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1MDcxNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435850716", "bodyText": "Seems like we don't need these?\ngetProtocol();\ngetScheme();", "author": "minwoox", "createdAt": "2020-06-05T11:06:55Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4ODY4Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435888683", "bodyText": "We can remove queryString and just use serviceRequestContext.query().", "author": "minwoox", "createdAt": "2020-06-05T12:29:46Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4OTg3MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435889871", "bodyText": "We do not have to use replace which is a bit heavy computation because we know that the requestURI starts with the context path. So we can do:\nrequestURI.substring(servletContext.getContextPath().length());", "author": "minwoox", "createdAt": "2020-06-05T12:32:08Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5MzY5MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435893690", "bodyText": "This should be null when there's no path info.\nFrom the implementation this is always an empty string. Could you check this out by making unit tests please?", "author": "minwoox", "createdAt": "2020-06-05T12:39:42Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5Mzk4Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435893987", "bodyText": "Do not have to call requestURI.replaceFirst(getContextPath(), \"\") here again. We already did.", "author": "minwoox", "createdAt": "2020-06-05T12:40:12Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NjE5Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435896196", "bodyText": "I think we don't have to check this because queryParams does not have duplicate keys.\nAlso we can use immutable map builder from the first.\nfinal Builder<String, String[]> builder = ImmutableMap.builder();\nqueryParams.forEach(x -> builder.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0])));\nparameters = builder.build();", "author": "minwoox", "createdAt": "2020-06-05T12:44:25Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk5NzQyOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435997429", "bodyText": "queryParams have duplicate keys and failed at my test case\nURL = \"/home?test=1&array=abc&array=a%20bc#code=3\"\nTherefore I have to add check code.\n22:34:56.305 [armeria-common-blocking-tasks-1-1] ERROR c.l.a.s.s.DefaultServletService - Servlet process failed: \njava.lang.IllegalArgumentException: Multiple entries with same key: array=[Ljava.lang.String;@1afc24a0 and array=[Ljava.lang.String;@5ff5ccd4\n\tat com.google.common.collect.ImmutableMap.conflictException(ImmutableMap.java:216)", "author": "dominhhien", "createdAt": "2020-06-05T15:28:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NjE5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNTA1MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r436005051", "bodyText": "Ah, sorry about it. We should do:\nfinal Builder<String, String[]> builder = ImmutableMap.builder();\nfor (String name : queryParams.names()) {\n    builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n}\nparameters = builder.build();", "author": "minwoox", "createdAt": "2020-06-05T15:40:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NjE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NjY4NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435896685", "bodyText": "Please add @VisibleForTesting when the method is not private to use in tests.", "author": "minwoox", "createdAt": "2020-06-05T12:45:19Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NjkxMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435896912", "bodyText": "We can completely remove this method.", "author": "minwoox", "createdAt": "2020-06-05T12:45:45Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMTkzMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435901932", "bodyText": "We can use httpRequest.authority() instead of getServerName() and port.", "author": "minwoox", "createdAt": "2020-06-05T12:55:07Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parse query string.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMjg0Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435902843", "bodyText": "These two line can be merged into one.", "author": "minwoox", "createdAt": "2020-06-05T12:56:48Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parse query string.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMzc2Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435903767", "bodyText": "contentType can be null.\nWe should check it before call toString() on it.", "author": "minwoox", "createdAt": "2020-06-05T12:58:36Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parse query string.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return httpRequest.headers().contentType().toString();", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwNDU5Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435904593", "bodyText": "We should check if getInputStream() is called or not as we did it in getInputStream().", "author": "minwoox", "createdAt": "2020-06-05T13:00:01Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parse query string.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return httpRequest.headers().contentType().toString();\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name) == null) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getServerName() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return serviceRequestContext.config().server().activeLocalPort();\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        if (reader == null) {", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwNTQxNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435905416", "bodyText": "We can do serviceRequestContext.config().virtualHost().defaultHostname()\nand this is not nullable.", "author": "minwoox", "createdAt": "2020-06-05T13:01:24Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parse query string.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return httpRequest.headers().contentType().toString();\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name) == null) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getServerName() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwOTc1MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435909750", "bodyText": "Could just do serviceRequestContext.sessionProtocol().isTls()", "author": "minwoox", "createdAt": "2020-06-05T13:09:43Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parse query string.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return httpRequest.headers().contentType().toString();\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name) == null) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getServerName() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return serviceRequestContext.config().server().activeLocalPort();\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        if (reader == null) {\n+            synchronized (this) {\n+                if (reader == null) {\n+                    reader = new BufferedReader(\n+                            new InputStreamReader(getInputStream(), getCharacterEncoding()));\n+                }\n+            }\n+        }\n+        return reader;\n+    }\n+\n+    @Override\n+    public String getRemoteAddr() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n+    }\n+\n+    @Override\n+    public String getRemoteHost() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n+    }\n+\n+    @Override\n+    public int getRemotePort() {\n+        return getServerPort();\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name, \"name\");\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        getAttributeMap().put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        getAttributeMap().remove(name);\n+    }\n+\n+    @Override\n+    public Locale getLocale() {\n+        return locales[0];\n+    }\n+\n+    @Override\n+    public Enumeration<Locale> getLocales() {\n+        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public boolean isSecure() {\n+        return SessionProtocol.HTTPS.uriText().equals(getScheme());", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "message": "Set final classes and final fields", "committedDate": "2020-06-03T04:10:42Z", "type": "forcePushed"}, {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "message": "Set final classes and final fields", "committedDate": "2020-06-03T04:10:42Z", "type": "forcePushed"}, {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "message": "Set final classes and final fields", "committedDate": "2020-06-03T04:10:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzNTU5NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437835595", "bodyText": "I think this is not nullable.", "author": "minwoox", "createdAt": "2020-06-10T03:11:05Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,530 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.UrlMapper.Element;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final UrlMapper<DefaultServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<DefaultFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeout = 30; // unit: minutes\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, DefaultFilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    /**\n+     * Check servlet context is initialized.\n+     */\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    void setMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    @Nullable\n+    String getServletPath(String uri) {\n+        final Element element = servletUrlMapper.getMapping(StringUtil.normalizePath(uri));\n+        return element == null ? null : element.path.substring(contextPath.length());\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<DefaultServletRegistration> element =\n+                servletUrlMapper.getMapping(StringUtil.normalizePath(path));\n+        if (element == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(element.getObject()),\n+                                            element.pattern, element);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        name = StringUtil.normalizePath(name);\n+        final DefaultServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final DefaultServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(DefaultServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(DefaultServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ArmeriaHttpUtil.SERVER_HEADER +\n+               \" (JDK \" + SystemInfo.javaVersion() + \";\" + SystemInfo.osType().name() + \")\";\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName), \"servletName is empty)\", servletName);\n+        requireNonNull(className, \"className\");\n+        try {\n+            //noinspection unchecked\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(servlet, \"servlet\");\n+        servletName = StringUtil.normalizePath(servletName);\n+        final DefaultServletRegistration servletRegistration =\n+                new DefaultServletRegistration(servletName, servlet, this, servletUrlMapper, initParamMap);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    @Nullable\n+    public DefaultServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, DefaultServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public DefaultFilterRegistration addFilter(String filterName, String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public DefaultFilterRegistration addFilter(String filterName, Filter filter) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public DefaultFilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, DefaultFilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public JspConfigDescriptor getJspConfigDescriptor() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader() {\n+        return getClass().getClassLoader();\n+    }\n+\n+    @Override\n+    public void declareRoles(String... roleNames) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getVirtualServerName() {\n+        return ArmeriaHttpUtil.SERVER_HEADER +\n+               \" (JDK \" + SystemInfo.javaVersion() + \";\" + SystemInfo.osType().name() + \")\";\n+    }\n+\n+    @Override\n+    public String getRequestCharacterEncoding() {\n+        return requestCharacterEncoding;\n+    }\n+\n+    @Override\n+    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n+        ensureUninitialized(\"setRequestCharacterEncoding\");\n+        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n+        this.requestCharacterEncoding = requestCharacterEncoding;\n+    }\n+\n+    @Override\n+    public String getResponseCharacterEncoding() {\n+        return responseCharacterEncoding;\n+    }\n+\n+    @Override\n+    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n+        ensureUninitialized(\"setResponseCharacterEncoding\");\n+        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n+        this.responseCharacterEncoding = responseCharacterEncoding;\n+    }\n+\n+    @Override\n+    public Dynamic addJspFile(String jspName, String jspFile) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    private void ensureUninitialized(@Nullable String name) {", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzNjA5Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437836093", "bodyText": "Let's add @Nullable", "author": "minwoox", "createdAt": "2020-06-10T03:13:14Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private boolean useInputStream;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzNjkyMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437836920", "bodyText": "Let's just return getTime() right away because Date is Obsolete.", "author": "minwoox", "createdAt": "2020-06-10T03:16:37Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private boolean useInputStream;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzNzU0Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437837547", "bodyText": "This can log three times for just one header.\nHow about logging it after all parsing fails?", "author": "minwoox", "createdAt": "2020-06-10T03:19:34Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private boolean useInputStream;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzODA5MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437838091", "bodyText": "We might consider caching all this sort of heavy operation later. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-06-10T03:21:44Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private boolean useInputStream;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzODU1MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437838551", "bodyText": "queryParams.getAll(name).isEmpty()", "author": "minwoox", "createdAt": "2020-06-10T03:24:03Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private boolean useInputStream;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        return contentType == null ? null : contentType.toString();\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        useInputStream = true;\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name) == null) {", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzODc3MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437838770", "bodyText": "If useInputStream is true, I think we need to raise an exception.", "author": "minwoox", "createdAt": "2020-06-10T03:25:06Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private boolean useInputStream;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        return contentType == null ? null : contentType.toString();\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        useInputStream = true;\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name) == null) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    public String getServerName() {\n+        return serviceRequestContext.config().virtualHost().defaultHostname();\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return serviceRequestContext.config().server().activeLocalPort();\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        if (reader == null && !useInputStream) {", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzOTMxNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437839317", "bodyText": "We should return the remote port:\n((InetSocketAddress) serviceRequestContext.remoteAddress()).getPort()", "author": "minwoox", "createdAt": "2020-06-10T03:27:26Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private boolean useInputStream;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        return contentType == null ? null : contentType.toString();\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        useInputStream = true;\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name) == null) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    public String getServerName() {\n+        return serviceRequestContext.config().virtualHost().defaultHostname();\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return serviceRequestContext.config().server().activeLocalPort();\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        if (reader == null && !useInputStream) {\n+            synchronized (this) {\n+                if (reader == null) {\n+                    reader = new BufferedReader(\n+                            new InputStreamReader(inputStream, getCharacterEncoding()));\n+                }\n+            }\n+        }\n+        return reader;\n+    }\n+\n+    @Override\n+    public String getRemoteAddr() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n+    }\n+\n+    @Override\n+    public String getRemoteHost() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n+    }\n+\n+    @Override\n+    public int getRemotePort() {\n+        return getServerPort();", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0MTUyNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437841525", "bodyText": "We can just do headersBuilder.contentType(MediaType.HTML_UTF_8);", "author": "minwoox", "createdAt": "2020-06-10T03:37:37Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0MTY3Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437841673", "bodyText": "Shouldn't this be getResponseCharacterEncoding()?", "author": "minwoox", "createdAt": "2020-06-10T03:38:12Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0Mjk5OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437842998", "bodyText": "How about removing this method and add cookie every time addCookie() is called?", "author": "minwoox", "createdAt": "2020-06-10T03:44:26Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NDAwNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437844007", "bodyText": "This does nothing. Could you use PathAndQuery.encodeToPercents()?", "author": "minwoox", "createdAt": "2020-06-10T03:48:56Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkxMDE3OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437910179", "bodyText": "As Java doc said:\n     * Encodes the specified URL by including the session ID,\n     * or, if encoding is not needed, returns the URL unchanged.\n     * The implementation of this method includes the logic to\n     * determine whether the session ID needs to be encoded in the URL.\n\nTherefore I return the URL unchanged because we have not support servlet session yet.", "author": "dominhhien", "createdAt": "2020-06-10T07:20:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NDAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkxNDU4MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437914581", "bodyText": "But we call this from encodeRedirectURL().\nShouldn't we encode it?", "author": "minwoox", "createdAt": "2020-06-10T07:29:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NDAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyNjI1Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437926253", "bodyText": "Yes I think so. Tomcat's encodeUrl() also just return Url append &jsessionId=.... : https://github.com/apache/tomcat/blob/master/java/org/apache/catalina/connector/Response.java . If we don't support servlet session now, I think we just return Url unchanged.", "author": "dominhhien", "createdAt": "2020-06-10T07:46:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NDAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk0NzA0NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437947045", "bodyText": "Thanks for checking. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-06-10T08:21:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NDAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NTgyMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437845821", "bodyText": "Looks like we should set \"text/html\" as the content type.\nHow about making a new headers and send it?\nfinal ResponseHeaders headers =\n        ResponseHeaders.builder(sc).contentType(MediaType.HTML_UTF_8).build();\nif (responseWriter.tryWrite(headers)) {\n    if (msg != null) {\n        if (!responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n            return;\n        }\n    }\n    responseWriter.close();\n}", "author": "minwoox", "createdAt": "2020-06-10T03:56:53Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NjA5Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437846096", "bodyText": "Seems like we need to use 302.", "author": "minwoox", "createdAt": "2020-06-10T03:58:09Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NjEzOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437846139", "bodyText": "Can remove toString()", "author": "minwoox", "createdAt": "2020-06-10T03:58:20Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NjQyMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437846422", "bodyText": "Can do just set(name, value);", "author": "minwoox", "createdAt": "2020-06-10T03:59:31Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.setObject(name, value);", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NjU0Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437846543", "bodyText": "Can do just add(name, value);", "author": "minwoox", "createdAt": "2020-06-10T04:00:03Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.setObject(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.addObject(name, value);", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NjY1NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437846654", "bodyText": "setLong?", "author": "minwoox", "createdAt": "2020-06-10T04:00:29Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NjY4NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437846685", "bodyText": "addLong?", "author": "minwoox", "createdAt": "2020-06-10T04:00:37Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0Njk3OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437846978", "bodyText": "Could just call directly headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, contentType);\nSo we don't have to call toString", "author": "minwoox", "createdAt": "2020-06-10T04:01:48Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.setObject(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.addObject(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        setHeader(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NzY3Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437847677", "bodyText": "We can add @Nullable and return null. Javadoc says so.", "author": "minwoox", "createdAt": "2020-06-10T04:04:58Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.setObject(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.addObject(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        setHeader(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);\n+    }\n+\n+    @Override\n+    public String getContentType() {\n+        final String contentType = getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+        return contentType == null ? \"\" : contentType;", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0Nzk1NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437847955", "bodyText": "if (sm == null) {\n    headersBuilder.status(HttpStatus.valueOf(sc));\n} else {\n    headersBuilder.status(new HttpStatus(sc, sm));\n}", "author": "minwoox", "createdAt": "2020-06-10T04:06:16Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.setObject(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.addObject(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        setHeader(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);\n+    }\n+\n+    @Override\n+    public String getContentType() {\n+        final String contentType = getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+        return contentType == null ? \"\" : contentType;\n+    }\n+\n+    @Override\n+    public void setStatus(int sc) {\n+        headersBuilder.status(sc);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void setStatus(int sc, @Nullable String sm) {\n+        if (sm == null) {", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0ODk4Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437848982", "bodyText": "final MediaType mediaType = headersBuilder.contentType();\nif (mediaType != null && mediaType.charset() != null) {\n    return mediaType.charset().toString();\n} \nreturn defaultCharacterEncoding;", "author": "minwoox", "createdAt": "2020-06-10T04:10:46Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.setObject(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.addObject(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        setHeader(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);\n+    }\n+\n+    @Override\n+    public String getContentType() {\n+        final String contentType = getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+        return contentType == null ? \"\" : contentType;\n+    }\n+\n+    @Override\n+    public void setStatus(int sc) {\n+        headersBuilder.status(sc);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void setStatus(int sc, @Nullable String sm) {\n+        if (sm == null) {\n+            sm = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, sm));\n+    }\n+\n+    @Override\n+    public int getStatus() {\n+        return headersBuilder.status().code();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.get(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.getAll(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaderNames() {\n+        return headersBuilder.names().stream()\n+                             .map(AsciiString::toString).collect(ImmutableList.toImmutableList());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return getContentType().split(\";\")[1].trim();", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0OTQ1MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437849451", "bodyText": "final MediaType mediaType = headersBuilder.contentType();\nif (mediaType != null) {\n    headersBuilder.contentType(mediaType.withCharset(Charset.forName(charset)));\n}", "author": "minwoox", "createdAt": "2020-06-10T04:12:41Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.setObject(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.addObject(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        setHeader(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);\n+    }\n+\n+    @Override\n+    public String getContentType() {\n+        final String contentType = getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+        return contentType == null ? \"\" : contentType;\n+    }\n+\n+    @Override\n+    public void setStatus(int sc) {\n+        headersBuilder.status(sc);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void setStatus(int sc, @Nullable String sm) {\n+        if (sm == null) {\n+            sm = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, sm));\n+    }\n+\n+    @Override\n+    public int getStatus() {\n+        return headersBuilder.status().code();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.get(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.getAll(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaderNames() {\n+        return headersBuilder.names().stream()\n+                             .map(AsciiString::toString).collect(ImmutableList.toImmutableList());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return getContentType().split(\";\")[1].trim();\n+    }\n+\n+    @Override\n+    public DefaultServletOutputStream getOutputStream() throws IOException {\n+        return outputStream;\n+    }\n+\n+    @Override\n+    public PrintWriter getWriter() throws IOException {\n+        return writer;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String charset) {\n+        requireNonNull(charset, \"charset\");\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE,", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "message": "Set final classes and final fields", "committedDate": "2020-06-03T04:10:42Z", "type": "forcePushed"}, {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "message": "Set final classes and final fields", "committedDate": "2020-06-03T04:10:42Z", "type": "forcePushed"}, {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "message": "Set final classes and final fields", "committedDate": "2020-06-03T04:10:42Z", "type": "forcePushed"}, {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "message": "Set final classes and final fields", "committedDate": "2020-06-03T04:10:42Z", "type": "forcePushed"}, {"oid": "5091a50bbda625835e16f194fab4004b1b11659a", "url": "https://github.com/line/armeria/commit/5091a50bbda625835e16f194fab4004b1b11659a", "message": "Add QueryParams, add PathInfo tests", "committedDate": "2020-06-10T08:08:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMTg5OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437921899", "bodyText": "It seems like we don't override this method because it's implemented in ServletInputStream?", "author": "minwoox", "createdAt": "2020-06-10T07:40:31Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.ReadListener;\n+import javax.servlet.ServletInputStream;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+/**\n+ * The servlet input stream.\n+ */\n+final class DefaultServletInputStream extends ServletInputStream {\n+    private final ByteBuf source;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletInputStream(ByteBuf source) {\n+        requireNonNull(source, \"source\");\n+        this.source = source;\n+    }\n+\n+    @Override\n+    public int readLine(byte[] b, int off, int len) throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");", "originalCommit": "411299338b7890ed2174698df4430c1cfe74a3f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk2NTkxMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437965913", "bodyText": "No, because all request data parsed to servlet parameters. I think readLine() is only useful to read a large size upload data. We don't support this case now.", "author": "dominhhien", "createdAt": "2020-06-10T08:51:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMTg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk3MjgxMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437972812", "bodyText": "If we support read(), shouldn't we support readLine() as well?", "author": "minwoox", "createdAt": "2020-06-10T09:02:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMTg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk3NTY0Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437975642", "bodyText": "I think, we also shouldn't support read() now.", "author": "dominhhien", "createdAt": "2020-06-10T09:07:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMTg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk3Nzg1NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437977855", "bodyText": "Then, is it better to just not support in DefaultServletHttpRequest.getInputStream()?\nIs there any chance that content type of the request is not FORM_DATA so that the content is used directly by the user?", "author": "minwoox", "createdAt": "2020-06-10T09:10:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMTg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk4MzExNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437983115", "bodyText": "Is there any chance that content type of the request is not FORM_DATA so that the content is used directly by the user?\n\nI have thought about your question before. But I have not found a solution for this problem. Does Armeria provide an API return InputStream to User without aggregate operation?\n\nThen, is it better to just not support in DefaultServletHttpRequest.getInputStream()?\n\nYes, I think so.", "author": "dominhhien", "createdAt": "2020-06-10T09:20:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMTg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk4NTE4Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437985187", "bodyText": "But I have not found a solution for this problem.\n\nI might lose a context. \ud83d\ude04 What was the problem you are mentioning?\n\nYes, I think so.\n\nIf so, let's do it. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-06-10T09:23:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMTg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk5MTUwOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437991509", "bodyText": "I might lose a context. \ud83d\ude04 What was the problem you are mentioning?\n\nI mean: Input stream support read directly bytes data, then we can read each part of data. But if we aggregated request, I think all data bytes already read to bytes array. Therefore using Input stream is unnecessary.", "author": "dominhhien", "createdAt": "2020-06-10T09:33:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMTg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzMTYyNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437931627", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-06-10T07:56:06Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.ReadListener;\n+import javax.servlet.ServletInputStream;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+/**\n+ * The servlet input stream.\n+ */\n+final class DefaultServletInputStream extends ServletInputStream {\n+    private final ByteBuf source;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletInputStream(ByteBuf source) {\n+        requireNonNull(source, \"source\");\n+        this.source = source;\n+    }\n+\n+    @Override\n+    public int readLine(byte[] b, int off, int len) throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isFinished() {\n+        return source.readableBytes() == 0;\n+    }\n+\n+    @Override\n+    public boolean isReady() {\n+        return source.readableBytes() != 0;\n+    }\n+\n+    @Override\n+    public void setReadListener(ReadListener readListener) {\n+        requireNonNull(readListener, \"readListener\");\n+    }\n+\n+    @Override\n+    public long skip(long n) throws IOException {\n+        final long skipLen = Math.min(source.readableBytes(), n);\n+        source.skipBytes((int) skipLen);\n+        return skipLen;\n+    }\n+\n+    @Override\n+    public int available() throws IOException {\n+        return source.readableBytes();\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+    }\n+\n+    @Override\n+    public int read(byte[] bytes, int off, int len) throws IOException {", "originalCommit": "411299338b7890ed2174698df4430c1cfe74a3f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzMjMzMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437932331", "bodyText": "This doesn't do anthing?", "author": "minwoox", "createdAt": "2020-06-10T07:57:15Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.ReadListener;\n+import javax.servlet.ServletInputStream;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+/**\n+ * The servlet input stream.\n+ */\n+final class DefaultServletInputStream extends ServletInputStream {\n+    private final ByteBuf source;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletInputStream(ByteBuf source) {\n+        requireNonNull(source, \"source\");\n+        this.source = source;\n+    }\n+\n+    @Override\n+    public int readLine(byte[] b, int off, int len) throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isFinished() {\n+        return source.readableBytes() == 0;\n+    }\n+\n+    @Override\n+    public boolean isReady() {\n+        return source.readableBytes() != 0;\n+    }\n+\n+    @Override\n+    public void setReadListener(ReadListener readListener) {\n+        requireNonNull(readListener, \"readListener\");", "originalCommit": "411299338b7890ed2174698df4430c1cfe74a3f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNDY2MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437934660", "bodyText": "Could be source.isReadable()?", "author": "minwoox", "createdAt": "2020-06-10T08:01:15Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.ReadListener;\n+import javax.servlet.ServletInputStream;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+/**\n+ * The servlet input stream.\n+ */\n+final class DefaultServletInputStream extends ServletInputStream {\n+    private final ByteBuf source;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletInputStream(ByteBuf source) {\n+        requireNonNull(source, \"source\");\n+        this.source = source;\n+    }\n+\n+    @Override\n+    public int readLine(byte[] b, int off, int len) throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isFinished() {\n+        return source.readableBytes() == 0;\n+    }\n+\n+    @Override\n+    public boolean isReady() {\n+        return source.readableBytes() != 0;", "originalCommit": "411299338b7890ed2174698df4430c1cfe74a3f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNDgxMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437934811", "bodyText": "Could be !source.isReadable()?", "author": "minwoox", "createdAt": "2020-06-10T08:01:29Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.ReadListener;\n+import javax.servlet.ServletInputStream;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+/**\n+ * The servlet input stream.\n+ */\n+final class DefaultServletInputStream extends ServletInputStream {\n+    private final ByteBuf source;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletInputStream(ByteBuf source) {\n+        requireNonNull(source, \"source\");\n+        this.source = source;\n+    }\n+\n+    @Override\n+    public int readLine(byte[] b, int off, int len) throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isFinished() {\n+        return source.readableBytes() == 0;", "originalCommit": "411299338b7890ed2174698df4430c1cfe74a3f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNTY4Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437935686", "bodyText": "Could be response.getResponseWriter().isOpen()?", "author": "minwoox", "createdAt": "2020-06-10T08:03:05Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.WriteListener;\n+\n+import com.linecorp.armeria.common.HttpData;\n+\n+/**\n+ * Servlets output streams (wrapper classes) that control access to the flow.\n+ */\n+final class DefaultServletOutputStream extends ServletOutputStream {\n+    private final DefaultServletHttpResponse response;\n+\n+    DefaultServletOutputStream(DefaultServletHttpResponse response) {\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+    }\n+\n+    @Override\n+    public boolean isReady() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");", "originalCommit": "411299338b7890ed2174698df4430c1cfe74a3f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNTk1NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437935955", "bodyText": "Could be response.getResponseWriter().close();?", "author": "minwoox", "createdAt": "2020-06-10T08:03:34Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.WriteListener;\n+\n+import com.linecorp.armeria.common.HttpData;\n+\n+/**\n+ * Servlets output streams (wrapper classes) that control access to the flow.\n+ */\n+final class DefaultServletOutputStream extends ServletOutputStream {\n+    private final DefaultServletHttpResponse response;\n+\n+    DefaultServletOutputStream(DefaultServletHttpResponse response) {\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+    }\n+\n+    @Override\n+    public boolean isReady() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void setWriteListener(WriteListener listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+    }", "originalCommit": "411299338b7890ed2174698df4430c1cfe74a3f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNzcyMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437937722", "bodyText": "What happens to the second right? A user can do it?", "author": "minwoox", "createdAt": "2020-06-10T08:06:26Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.WriteListener;\n+\n+import com.linecorp.armeria.common.HttpData;\n+\n+/**\n+ * Servlets output streams (wrapper classes) that control access to the flow.\n+ */\n+final class DefaultServletOutputStream extends ServletOutputStream {\n+    private final DefaultServletHttpResponse response;\n+\n+    DefaultServletOutputStream(DefaultServletHttpResponse response) {\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+    }\n+\n+    @Override\n+    public boolean isReady() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void setWriteListener(WriteListener listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+    }\n+\n+    @Override\n+    public void flush() throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void write(int b) throws IOException {\n+        final byte[] bytes = new byte[1];\n+        bytes[0] = (byte) b;\n+        write(bytes);\n+    }\n+\n+    @Override\n+    public void write(byte[] b, int off, int len) throws IOException {\n+        requireNonNull(b, \"b\");\n+        checkArgument(off >= 0, \"off: %s (expected: >= 0)\", off);\n+        checkArgument(len >= 0, \"len: %s (expected: >= 0)\", len);\n+        response.write(HttpData.copyOf(Arrays.copyOfRange(b, off, len)));", "originalCommit": "411299338b7890ed2174698df4430c1cfe74a3f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAwNTU5Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r438005592", "bodyText": "Do you mean off >= 0 is right? Sorry, I think I haven't caught your question.", "author": "dominhhien", "createdAt": "2020-06-10T09:56:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNzcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAxOTQ0MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r438019441", "bodyText": "Let's say that if a user calls:\nDefaultServletOutputStream stream = ...\nstream.write(1);\nstream.write(2);\nThe first stream.write(1); call will close the response stream writer by calling response.getResponseWriter().close();\nSo 2 cannot be written. Isn't it?", "author": "minwoox", "createdAt": "2020-06-10T10:22:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNzcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAyODI0NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r438028245", "bodyText": "Yes, 2 can't be written, therefore If I want to write a download file I have to convert whole file to bytes array and convert byte arrays to HttpData. I think it use so much memory, not good. Do you have another solution to write each part of download file? Can I call tryWrite(HttpData) multiple time? Can I split download file to multiple HttpData.", "author": "dominhhien", "createdAt": "2020-06-10T10:40:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNzcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAzNDM1NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r438034355", "bodyText": "If we can't write multiple time, I think write(2) should be raise an exception. Ofcourse, we need a AtomicBoolean isWritten to check response have already written. What do you think?", "author": "dominhhien", "createdAt": "2020-06-10T10:52:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNzcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAzODE3OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r438038179", "bodyText": "I think we should allow users call write multiple time.\nHow about caching the written bytes and write it to the HttpResponseWriter when close() or flush() is called?", "author": "minwoox", "createdAt": "2020-06-10T11:00:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNzcyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk0MTg5MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437941890", "bodyText": "Is this not supported?", "author": "minwoox", "createdAt": "2020-06-10T08:13:20Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletPrintWriter.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.util.Formatter;\n+import java.util.Locale;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.HttpData;\n+\n+/**\n+ *  Printing flow.\n+ */\n+final class ServletPrintWriter extends PrintWriter {\n+    private final String lineSeparator = System.lineSeparator();\n+    private final DefaultServletHttpResponse response;\n+\n+    private boolean error;\n+\n+    ServletPrintWriter(DefaultServletHttpResponse response, OutputStream out) {\n+        super(out);\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+    }\n+\n+    @Override\n+    public void flush() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void close() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");", "originalCommit": "5091a50bbda625835e16f194fab4004b1b11659a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk0MjUwMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437942502", "bodyText": "ditto write can only happen once?", "author": "minwoox", "createdAt": "2020-06-10T08:14:21Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletPrintWriter.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.util.Formatter;\n+import java.util.Locale;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.HttpData;\n+\n+/**\n+ *  Printing flow.\n+ */\n+final class ServletPrintWriter extends PrintWriter {\n+    private final String lineSeparator = System.lineSeparator();\n+    private final DefaultServletHttpResponse response;\n+\n+    private boolean error;\n+\n+    ServletPrintWriter(DefaultServletHttpResponse response, OutputStream out) {\n+        super(out);\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+    }\n+\n+    @Override\n+    public void flush() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void close() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean checkError() {\n+        return error;\n+    }\n+\n+    @Override\n+    protected void setError() {\n+        error = true;\n+    }\n+\n+    @Override\n+    protected void clearError() {\n+        error = false;\n+    }\n+\n+    @Override\n+    public void write(int c) {\n+        write(String.valueOf(c));\n+    }\n+\n+    @Override\n+    public void write(char[] buf, int off, int len) {\n+        requireNonNull(buf, \"buf\");\n+        checkArgument(off >= 0, \"off: %s (expected: >= 0)\", off);\n+        checkArgument(len >= 0, \"len: %s (expected: >= 0)\", len);\n+        write(String.valueOf(buf, off, len));\n+    }\n+\n+    @Override\n+    public void write(char[] buf) {\n+        requireNonNull(buf, \"buf\");\n+        write(String.valueOf(buf));\n+    }\n+\n+    @Override\n+    public void write(String s, int off, int len) {\n+        requireNonNull(s, \"s\");\n+        checkArgument(off >= 0, \"off: %s (expected: >= 0)\", off);\n+        checkArgument(len >= 0, \"len: %s (expected: >= 0)\", len);\n+        final String writeStr;\n+        if (off == 0 && s.length() == len) {\n+            writeStr = s;\n+        } else {\n+            writeStr = s.substring(off, off + len);\n+        }\n+        response.write(HttpData.ofUtf8(writeStr));", "originalCommit": "5091a50bbda625835e16f194fab4004b1b11659a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAwMjM5MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r438002391", "bodyText": "Do you mean we should check state isWritten ?", "author": "dominhhien", "createdAt": "2020-06-10T09:51:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk0MjUwMg=="}], "type": "inlineReview"}, {"oid": "2ec6c88b5b42c7dcd1fa50ef46f042fadc8d1c12", "url": "https://github.com/line/armeria/commit/2ec6c88b5b42c7dcd1fa50ef46f042fadc8d1c12", "message": "Check already sent", "committedDate": "2020-06-10T10:57:43Z", "type": "commit"}, {"oid": "9bc785005f71847396060d5b461d0f552a374b08", "url": "https://github.com/line/armeria/commit/9bc785005f71847396060d5b461d0f552a374b08", "message": "Cache written bytes, write multiple time", "committedDate": "2020-06-11T01:07:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIyOTg4Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439229883", "bodyText": "We can do:\nfinal String dateHeader = getHeader(name);\nif (dateHeader == null) {\n    return -1;\n}\nfor (DateFormat x : FORMATS_TEMPLATE) {\n    try {\n        return x.parse(dateHeader).getTime();\n    } catch (Exception e) {\n        // ignored.\n    }\n}\nthrow new IllegalArgumentException(\"failed to parse a date header: \" + dateHeader);", "author": "minwoox", "createdAt": "2020-06-12T06:25:32Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    @Nullable\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        boolean error = false;\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(getHeader(name)).getTime();\n+            } catch (Exception e) {\n+                error = true;\n+            }\n+        }\n+        if (error) {\n+            logger.info(\"Can't parse \" + getHeader(name) + \" to date\");\n+        }\n+        return -1;", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzMTg3Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439231872", "bodyText": "We should not call the deprecated method. The deprecated isRequestedSessionIdFromUrl() should call this method.", "author": "minwoox", "createdAt": "2020-06-12T06:31:11Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    @Nullable\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        boolean error = false;\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(getHeader(name)).getTime();\n+            } catch (Exception e) {\n+                error = true;\n+            }\n+        }\n+        if (error) {\n+            logger.info(\"Can't parse \" + getHeader(name) + \" to date\");\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzMjIzMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439232233", "bodyText": "Shouldn't we return false at the moment because this method checks whether the requested session ID was conveyed to the server as part of the request URL?", "author": "minwoox", "createdAt": "2020-06-12T06:32:09Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    @Nullable\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        boolean error = false;\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(getHeader(name)).getTime();\n+            } catch (Exception e) {\n+                error = true;\n+            }\n+        }\n+        if (error) {\n+            logger.info(\"Can't parse \" + getHeader(name) + \" to date\");\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzMjg1MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439232851", "bodyText": "Can't we just call return parameters.get(name);?", "author": "minwoox", "createdAt": "2020-06-12T06:33:59Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    @Nullable\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        boolean error = false;\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(getHeader(name)).getTime();\n+            } catch (Exception e) {\n+                error = true;\n+            }\n+        }\n+        if (error) {\n+            logger.info(\"Can't parse \" + getHeader(name) + \" to date\");\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        return contentType == null ? null : contentType.toString();\n+    }\n+\n+    @Override\n+    public ServletInputStream getInputStream() throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name).isEmpty()) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNDgxOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439234818", "bodyText": "I think we can do:\nfinal InetSocketAddress socketAddress = serviceRequestContext.localAddress();\nreturn socketAddress.getPort();", "author": "minwoox", "createdAt": "2020-06-12T06:39:24Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    @Nullable\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        boolean error = false;\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(getHeader(name)).getTime();\n+            } catch (Exception e) {\n+                error = true;\n+            }\n+        }\n+        if (error) {\n+            logger.info(\"Can't parse \" + getHeader(name) + \" to date\");\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        return contentType == null ? null : contentType.toString();\n+    }\n+\n+    @Override\n+    public ServletInputStream getInputStream() throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name).isEmpty()) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    public String getServerName() {\n+        return serviceRequestContext.config().virtualHost().defaultHostname();\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return serviceRequestContext.config().server().activeLocalPort();", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNTEzMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439235132", "bodyText": "This is not supported at the moment.", "author": "minwoox", "createdAt": "2020-06-12T06:40:20Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    @Nullable\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        boolean error = false;\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(getHeader(name)).getTime();\n+            } catch (Exception e) {\n+                error = true;\n+            }\n+        }\n+        if (error) {\n+            logger.info(\"Can't parse \" + getHeader(name) + \" to date\");\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        return contentType == null ? null : contentType.toString();\n+    }\n+\n+    @Override\n+    public ServletInputStream getInputStream() throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name).isEmpty()) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    public String getServerName() {\n+        return serviceRequestContext.config().virtualHost().defaultHostname();\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return serviceRequestContext.config().server().activeLocalPort();\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRemoteAddr() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n+    }\n+\n+    @Override\n+    public String getRemoteHost() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n+    }\n+\n+    @Override\n+    public int getRemotePort() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getPort();\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name, \"name\");\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public Locale getLocale() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<Locale> getLocales() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isSecure() {\n+        return serviceRequestContext.sessionProtocol().isTls();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        return servletContext.getRequestDispatcher(path);\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getLocalName() {\n+        return serviceRequestContext.config().server().defaultHostname();\n+    }\n+\n+    @Override\n+    public String getLocalAddr() {\n+        return serviceRequestContext.localAddress().toString();\n+    }\n+\n+    @Override\n+    public int getLocalPort() {\n+        return getServerPort();\n+    }\n+\n+    @Override\n+    public DefaultServletContext getServletContext() {\n+        return servletContext;\n+    }\n+\n+    @Override\n+    public AsyncContext startAsync() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isAsyncStarted() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAsyncSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public AsyncContext getAsyncContext() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public DispatcherType getDispatcherType() {\n+        return DispatcherType.REQUEST;\n+    }\n+\n+    @Override\n+    public String getPathTranslated() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getAuthType() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRemoteUser() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isUserInRole(String role) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Principal getUserPrincipal() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void login(String username, String password) throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void logout() throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Collection<Part> getParts() throws IOException, ServletException {\n+        return fileUploadList;", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNTE2MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439235160", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-06-12T06:40:25Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    @Nullable\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        boolean error = false;\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(getHeader(name)).getTime();\n+            } catch (Exception e) {\n+                error = true;\n+            }\n+        }\n+        if (error) {\n+            logger.info(\"Can't parse \" + getHeader(name) + \" to date\");\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        return contentType == null ? null : contentType.toString();\n+    }\n+\n+    @Override\n+    public ServletInputStream getInputStream() throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name).isEmpty()) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    public String getServerName() {\n+        return serviceRequestContext.config().virtualHost().defaultHostname();\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return serviceRequestContext.config().server().activeLocalPort();\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRemoteAddr() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n+    }\n+\n+    @Override\n+    public String getRemoteHost() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n+    }\n+\n+    @Override\n+    public int getRemotePort() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getPort();\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name, \"name\");\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public Locale getLocale() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<Locale> getLocales() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isSecure() {\n+        return serviceRequestContext.sessionProtocol().isTls();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        return servletContext.getRequestDispatcher(path);\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getLocalName() {\n+        return serviceRequestContext.config().server().defaultHostname();\n+    }\n+\n+    @Override\n+    public String getLocalAddr() {\n+        return serviceRequestContext.localAddress().toString();\n+    }\n+\n+    @Override\n+    public int getLocalPort() {\n+        return getServerPort();\n+    }\n+\n+    @Override\n+    public DefaultServletContext getServletContext() {\n+        return servletContext;\n+    }\n+\n+    @Override\n+    public AsyncContext startAsync() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isAsyncStarted() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAsyncSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public AsyncContext getAsyncContext() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public DispatcherType getDispatcherType() {\n+        return DispatcherType.REQUEST;\n+    }\n+\n+    @Override\n+    public String getPathTranslated() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getAuthType() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRemoteUser() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isUserInRole(String role) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Principal getUserPrincipal() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void login(String username, String password) throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void logout() throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Collection<Part> getParts() throws IOException, ServletException {\n+        return fileUploadList;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Part getPart(String name) throws IOException, ServletException {\n+        requireNonNull(name, \"name\");\n+        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNTU3Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439235576", "bodyText": "Could you add an empty line here so that private static final stands alone?", "author": "minwoox", "createdAt": "2020-06-12T06:41:34Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private final List<String> cookies = new ArrayList<>();", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNzc5Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439237796", "bodyText": "I think the value can be negative. So we do not need this check.", "author": "minwoox", "createdAt": "2020-06-12T06:47:35Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private final List<String> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n+    private AtomicBoolean isWritten = new AtomicBoolean(false);\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.contentType(MediaType.HTML_UTF_8);\n+        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Write data to response writer.\n+     */\n+    void flush() {\n+        if (isWritten.compareAndSet(false, true)) {\n+            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n+                                                      .status(HttpStatus.OK).build())) {\n+                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n+                    responseWriter.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write {@link HttpData} to client.\n+     */\n+    void write(byte[] data) {\n+        requireNonNull(data, \"data\");\n+        try {\n+            content.write(data);\n+        } catch (IOException e) {\n+            logger.error(\"Write data failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        final String path = cookie.getPath() == null ? \"/\" : cookie.getPath();\n+        final CookieBuilder builder =\n+                com.linecorp.armeria.common.Cookie.builder(cookie.getName(), cookie.getValue())\n+                                                  .path(path)\n+                                                  .httpOnly(\n+                                                          cookie.isHttpOnly())\n+                                                  .secure(cookie.getSecure());\n+        if (cookie.getMaxAge() != -1) {\n+            builder.maxAge(cookie.getMaxAge());\n+        }\n+        if (!isNullOrEmpty(cookie.getDomain())) {\n+            builder.domain(cookie.getDomain());\n+        }\n+        cookies.add(builder.build().toSetCookieHeader());\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        final ResponseHeaders headers = ResponseHeaders.builder(sc).contentType(MediaType.HTML_UTF_8).build();\n+        if (responseWriter.tryWrite(headers)) {\n+            if (msg != null) {\n+                if (!responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                    return;\n+                }\n+            }\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.FOUND, HttpHeaderNames.LOCATION, location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setLong(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addLong(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.set(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.add(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNzgzMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439237831", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-06-12T06:47:40Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private final List<String> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n+    private AtomicBoolean isWritten = new AtomicBoolean(false);\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.contentType(MediaType.HTML_UTF_8);\n+        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Write data to response writer.\n+     */\n+    void flush() {\n+        if (isWritten.compareAndSet(false, true)) {\n+            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n+                                                      .status(HttpStatus.OK).build())) {\n+                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n+                    responseWriter.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write {@link HttpData} to client.\n+     */\n+    void write(byte[] data) {\n+        requireNonNull(data, \"data\");\n+        try {\n+            content.write(data);\n+        } catch (IOException e) {\n+            logger.error(\"Write data failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        final String path = cookie.getPath() == null ? \"/\" : cookie.getPath();\n+        final CookieBuilder builder =\n+                com.linecorp.armeria.common.Cookie.builder(cookie.getName(), cookie.getValue())\n+                                                  .path(path)\n+                                                  .httpOnly(\n+                                                          cookie.isHttpOnly())\n+                                                  .secure(cookie.getSecure());\n+        if (cookie.getMaxAge() != -1) {\n+            builder.maxAge(cookie.getMaxAge());\n+        }\n+        if (!isNullOrEmpty(cookie.getDomain())) {\n+            builder.domain(cookie.getDomain());\n+        }\n+        cookies.add(builder.build().toSetCookieHeader());\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        final ResponseHeaders headers = ResponseHeaders.builder(sc).contentType(MediaType.HTML_UTF_8).build();\n+        if (responseWriter.tryWrite(headers)) {\n+            if (msg != null) {\n+                if (!responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                    return;\n+                }\n+            }\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.FOUND, HttpHeaderNames.LOCATION, location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setLong(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addLong(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.set(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.add(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0MDI2Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439240262", "bodyText": "Shouldn't we check if getWriter() is called?", "author": "minwoox", "createdAt": "2020-06-12T06:54:32Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private final List<String> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n+    private AtomicBoolean isWritten = new AtomicBoolean(false);\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.contentType(MediaType.HTML_UTF_8);\n+        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Write data to response writer.\n+     */\n+    void flush() {\n+        if (isWritten.compareAndSet(false, true)) {\n+            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n+                                                      .status(HttpStatus.OK).build())) {\n+                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n+                    responseWriter.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write {@link HttpData} to client.\n+     */\n+    void write(byte[] data) {\n+        requireNonNull(data, \"data\");\n+        try {\n+            content.write(data);\n+        } catch (IOException e) {\n+            logger.error(\"Write data failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        final String path = cookie.getPath() == null ? \"/\" : cookie.getPath();\n+        final CookieBuilder builder =\n+                com.linecorp.armeria.common.Cookie.builder(cookie.getName(), cookie.getValue())\n+                                                  .path(path)\n+                                                  .httpOnly(\n+                                                          cookie.isHttpOnly())\n+                                                  .secure(cookie.getSecure());\n+        if (cookie.getMaxAge() != -1) {\n+            builder.maxAge(cookie.getMaxAge());\n+        }\n+        if (!isNullOrEmpty(cookie.getDomain())) {\n+            builder.domain(cookie.getDomain());\n+        }\n+        cookies.add(builder.build().toSetCookieHeader());\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        final ResponseHeaders headers = ResponseHeaders.builder(sc).contentType(MediaType.HTML_UTF_8).build();\n+        if (responseWriter.tryWrite(headers)) {\n+            if (msg != null) {\n+                if (!responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                    return;\n+                }\n+            }\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.FOUND, HttpHeaderNames.LOCATION, location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setLong(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addLong(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.set(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.add(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, contentType);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public void setStatus(int sc) {\n+        headersBuilder.status(sc);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void setStatus(int sc, @Nullable String sm) {\n+        if (sm == null) {\n+            headersBuilder.status(HttpStatus.valueOf(sc));\n+        } else {\n+            headersBuilder.status(new HttpStatus(sc, sm));\n+        }\n+    }\n+\n+    @Override\n+    public int getStatus() {\n+        return headersBuilder.status().code();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.get(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.getAll(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaderNames() {\n+        return headersBuilder.names().stream()\n+                             .map(AsciiString::toString).collect(ImmutableList.toImmutableList());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        final MediaType mediaType = headersBuilder.contentType();\n+        if (mediaType != null && mediaType.charset() != null) {\n+            return mediaType.charset().toString();\n+        }\n+        return ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    }\n+\n+    @Override\n+    public DefaultServletOutputStream getOutputStream() throws IOException {\n+        return outputStream;", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0MDQzMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439240430", "bodyText": "Shouldn't we check if getOutputStream() is called?", "author": "minwoox", "createdAt": "2020-06-12T06:54:57Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private final List<String> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n+    private AtomicBoolean isWritten = new AtomicBoolean(false);\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.contentType(MediaType.HTML_UTF_8);\n+        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Write data to response writer.\n+     */\n+    void flush() {\n+        if (isWritten.compareAndSet(false, true)) {\n+            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n+                                                      .status(HttpStatus.OK).build())) {\n+                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n+                    responseWriter.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write {@link HttpData} to client.\n+     */\n+    void write(byte[] data) {\n+        requireNonNull(data, \"data\");\n+        try {\n+            content.write(data);\n+        } catch (IOException e) {\n+            logger.error(\"Write data failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        final String path = cookie.getPath() == null ? \"/\" : cookie.getPath();\n+        final CookieBuilder builder =\n+                com.linecorp.armeria.common.Cookie.builder(cookie.getName(), cookie.getValue())\n+                                                  .path(path)\n+                                                  .httpOnly(\n+                                                          cookie.isHttpOnly())\n+                                                  .secure(cookie.getSecure());\n+        if (cookie.getMaxAge() != -1) {\n+            builder.maxAge(cookie.getMaxAge());\n+        }\n+        if (!isNullOrEmpty(cookie.getDomain())) {\n+            builder.domain(cookie.getDomain());\n+        }\n+        cookies.add(builder.build().toSetCookieHeader());\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        final ResponseHeaders headers = ResponseHeaders.builder(sc).contentType(MediaType.HTML_UTF_8).build();\n+        if (responseWriter.tryWrite(headers)) {\n+            if (msg != null) {\n+                if (!responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                    return;\n+                }\n+            }\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.FOUND, HttpHeaderNames.LOCATION, location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setLong(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addLong(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.set(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.add(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, contentType);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public void setStatus(int sc) {\n+        headersBuilder.status(sc);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void setStatus(int sc, @Nullable String sm) {\n+        if (sm == null) {\n+            headersBuilder.status(HttpStatus.valueOf(sc));\n+        } else {\n+            headersBuilder.status(new HttpStatus(sc, sm));\n+        }\n+    }\n+\n+    @Override\n+    public int getStatus() {\n+        return headersBuilder.status().code();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.get(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.getAll(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaderNames() {\n+        return headersBuilder.names().stream()\n+                             .map(AsciiString::toString).collect(ImmutableList.toImmutableList());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        final MediaType mediaType = headersBuilder.contentType();\n+        if (mediaType != null && mediaType.charset() != null) {\n+            return mediaType.charset().toString();\n+        }\n+        return ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    }\n+\n+    @Override\n+    public DefaultServletOutputStream getOutputStream() throws IOException {\n+        return outputStream;\n+    }\n+\n+    @Override\n+    public PrintWriter getWriter() throws IOException {\n+        return writer;", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0NTg4NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439245885", "bodyText": "Should return return servletContext.getResponseCharacterEncoding();", "author": "minwoox", "createdAt": "2020-06-12T07:09:03Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private final List<String> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n+    private AtomicBoolean isWritten = new AtomicBoolean(false);\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.contentType(MediaType.HTML_UTF_8);\n+        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Write data to response writer.\n+     */\n+    void flush() {\n+        if (isWritten.compareAndSet(false, true)) {\n+            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n+                                                      .status(HttpStatus.OK).build())) {\n+                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n+                    responseWriter.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write {@link HttpData} to client.\n+     */\n+    void write(byte[] data) {\n+        requireNonNull(data, \"data\");\n+        try {\n+            content.write(data);\n+        } catch (IOException e) {\n+            logger.error(\"Write data failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        final String path = cookie.getPath() == null ? \"/\" : cookie.getPath();\n+        final CookieBuilder builder =\n+                com.linecorp.armeria.common.Cookie.builder(cookie.getName(), cookie.getValue())\n+                                                  .path(path)\n+                                                  .httpOnly(\n+                                                          cookie.isHttpOnly())\n+                                                  .secure(cookie.getSecure());\n+        if (cookie.getMaxAge() != -1) {\n+            builder.maxAge(cookie.getMaxAge());\n+        }\n+        if (!isNullOrEmpty(cookie.getDomain())) {\n+            builder.domain(cookie.getDomain());\n+        }\n+        cookies.add(builder.build().toSetCookieHeader());\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        final ResponseHeaders headers = ResponseHeaders.builder(sc).contentType(MediaType.HTML_UTF_8).build();\n+        if (responseWriter.tryWrite(headers)) {\n+            if (msg != null) {\n+                if (!responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                    return;\n+                }\n+            }\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.FOUND, HttpHeaderNames.LOCATION, location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setLong(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addLong(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.set(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.add(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, contentType);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public void setStatus(int sc) {\n+        headersBuilder.status(sc);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void setStatus(int sc, @Nullable String sm) {\n+        if (sm == null) {\n+            headersBuilder.status(HttpStatus.valueOf(sc));\n+        } else {\n+            headersBuilder.status(new HttpStatus(sc, sm));\n+        }\n+    }\n+\n+    @Override\n+    public int getStatus() {\n+        return headersBuilder.status().code();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.get(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.getAll(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaderNames() {\n+        return headersBuilder.names().stream()\n+                             .map(AsciiString::toString).collect(ImmutableList.toImmutableList());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        final MediaType mediaType = headersBuilder.contentType();\n+        if (mediaType != null && mediaType.charset() != null) {\n+            return mediaType.charset().toString();\n+        }\n+        return ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0NzM2MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439247360", "bodyText": "throw new IllegalStateException(\"must set content type before setting a charset\")", "author": "minwoox", "createdAt": "2020-06-12T07:12:44Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private final List<String> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n+    private AtomicBoolean isWritten = new AtomicBoolean(false);\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.contentType(MediaType.HTML_UTF_8);\n+        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Write data to response writer.\n+     */\n+    void flush() {\n+        if (isWritten.compareAndSet(false, true)) {\n+            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n+                                                      .status(HttpStatus.OK).build())) {\n+                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n+                    responseWriter.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write {@link HttpData} to client.\n+     */\n+    void write(byte[] data) {\n+        requireNonNull(data, \"data\");\n+        try {\n+            content.write(data);\n+        } catch (IOException e) {\n+            logger.error(\"Write data failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        final String path = cookie.getPath() == null ? \"/\" : cookie.getPath();\n+        final CookieBuilder builder =\n+                com.linecorp.armeria.common.Cookie.builder(cookie.getName(), cookie.getValue())\n+                                                  .path(path)\n+                                                  .httpOnly(\n+                                                          cookie.isHttpOnly())\n+                                                  .secure(cookie.getSecure());\n+        if (cookie.getMaxAge() != -1) {\n+            builder.maxAge(cookie.getMaxAge());\n+        }\n+        if (!isNullOrEmpty(cookie.getDomain())) {\n+            builder.domain(cookie.getDomain());\n+        }\n+        cookies.add(builder.build().toSetCookieHeader());\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        final ResponseHeaders headers = ResponseHeaders.builder(sc).contentType(MediaType.HTML_UTF_8).build();\n+        if (responseWriter.tryWrite(headers)) {\n+            if (msg != null) {\n+                if (!responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                    return;\n+                }\n+            }\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.FOUND, HttpHeaderNames.LOCATION, location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setLong(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addLong(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.set(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.add(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, contentType);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public void setStatus(int sc) {\n+        headersBuilder.status(sc);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void setStatus(int sc, @Nullable String sm) {\n+        if (sm == null) {\n+            headersBuilder.status(HttpStatus.valueOf(sc));\n+        } else {\n+            headersBuilder.status(new HttpStatus(sc, sm));\n+        }\n+    }\n+\n+    @Override\n+    public int getStatus() {\n+        return headersBuilder.status().code();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.get(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.getAll(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaderNames() {\n+        return headersBuilder.names().stream()\n+                             .map(AsciiString::toString).collect(ImmutableList.toImmutableList());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        final MediaType mediaType = headersBuilder.contentType();\n+        if (mediaType != null && mediaType.charset() != null) {\n+            return mediaType.charset().toString();\n+        }\n+        return ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    }\n+\n+    @Override\n+    public DefaultServletOutputStream getOutputStream() throws IOException {\n+        return outputStream;\n+    }\n+\n+    @Override\n+    public PrintWriter getWriter() throws IOException {\n+        return writer;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String charset) {\n+        requireNonNull(charset, \"charset\");\n+        final MediaType mediaType = headersBuilder.contentType();\n+        if (mediaType != null) {\n+            headersBuilder.contentType(mediaType.withCharset(Charset.forName(charset)));\n+        }", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NjEyMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439256120", "bodyText": "How about using ByteBufs and storing them in an array?\nSo that we can write when close() is called?\nprivate final List<ByteBuf> byteBufs = new ArrayList<>();\n\n...\n\n@Override\npublic void close() throws IOException {\n    if (!byteBufs.isEmpty()) {\n        response.getResponseWriter().write(\n                HttpData.wrap(Unpooled.wrappedBuffer(byteBufs.toArray(new ByteBuf[0]))));\n        byteBufs.clear();\n    }\n}\n\n@Override\npublic void write(int b) throws IOException {\n    byteBufs.add(Unpooled.copyInt(b));\n}\n\n@Override\npublic void write(byte[] b, int off, int len) throws IOException {\n    byteBufs.add(Unpooled.copiedBuffer(b, off, len));\n}\n\n@Override\npublic void write(byte[] b) throws IOException {\n    byteBufs.add(Unpooled.copiedBuffer(b));\n}\nAlso, I think we can just ignore flush() call because we do not support streaming response in servlet.", "author": "minwoox", "createdAt": "2020-06-12T07:33:47Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.WriteListener;\n+\n+/**\n+ * Servlets output streams (wrapper classes) that control access to the flow.\n+ */\n+final class DefaultServletOutputStream extends ServletOutputStream {\n+    private final DefaultServletHttpResponse response;\n+\n+    DefaultServletOutputStream(DefaultServletHttpResponse response) {\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+    }\n+\n+    @Override\n+    public boolean isReady() {\n+        return response.getResponseWriter().isOpen();\n+    }\n+\n+    @Override\n+    public void setWriteListener(WriteListener listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        response.flush();\n+        response.getResponseWriter().close();\n+    }\n+\n+    @Override\n+    public void flush() throws IOException {\n+        response.flush();\n+    }\n+\n+    @Override\n+    public void write(int b) throws IOException {\n+        final byte[] bytes = new byte[1];\n+        bytes[0] = (byte) b;\n+        write(bytes);", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMzMTM2OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439331368", "bodyText": "I tried your solution but response always is failed with exception:\ncom.linecorp.armeria.common.stream.ClosedStreamException\n\tat com.linecorp.armeria.common.stream.ClosedStreamException.get(ClosedStreamException.java:37)\n\tat com.linecorp.armeria.common.stream.StreamWriter.write(StreamWriter.java:72)\n\tat com.linecorp.armeria.server.servlet.DefaultServletOutputStream.close(DefaultServletOutputStream.java:58)\n\tat com.linecorp.armeria.server.servlet.ServletServiceTest$HomeServlet.doDelete(ServletServiceTest.java:478)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:671)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:750)\n\tat com.linecorp.armeria.server.servlet.ServletFilterChain.doFilter(ServletFilterChain.java:61)\n\tat com.linecorp.armeria.server.servlet.ServletRequestDispatcher.dispatch(ServletRequestDispatcher.java:89)\n\tat com.linecorp.armeria.server.servlet.DefaultServletService.process(DefaultServletService.java:83)\n\tat com.linecorp.armeria.server.servlet.DefaultServletService.lambda$serve$0(DefaultServletService.java:67)\n\tat java.base/java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:930)\n\tat java.base/java.util.concurrent.CompletableFuture$UniHandle.tryFire(CompletableFuture.java:907)\n\tat java.base/java.util.concurrent.CompletableFuture$Completion.run(CompletableFuture.java:478)\n\tat com.linecorp.armeria.common.RequestContext.lambda$makeContextAware$3(RequestContext.java:379)\n\tat com.linecorp.armeria.internal.common.metric.TimedRunnable.run(TimedRunnable.java:63)\n\tat java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)\n\tat java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)\n\tat java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.base/java.lang.Thread.run(Thread.java:835)\n\nPlease help me check this.", "author": "dominhhien", "createdAt": "2020-06-12T10:12:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NjEyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM0NTQ0OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439345448", "bodyText": "I think use ByteArrayOutputStream is good as ByteBuf. Because both append bytes in memory very fast.", "author": "dominhhien", "createdAt": "2020-06-12T10:45:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NjEyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg5MTgzNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439891836", "bodyText": "I tried it in my local and it seems working well. \ud83e\udd14\nCould you paste your code or let me know what was the problem?", "author": "minwoox", "createdAt": "2020-06-15T01:29:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NjEyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkwNTA4Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439905082", "bodyText": "My code DefaultServletOutputStream.java :\nfinal class DefaultServletOutputStream extends ServletOutputStream {\n    private final DefaultServletHttpResponse response;\n    private final List<ByteBuf> byteBufs = new ArrayList<>();\n\n    DefaultServletOutputStream(DefaultServletHttpResponse response) {\n        requireNonNull(response, \"response\");\n        this.response = response;\n    }\n\n    @Override\n    public boolean isReady() {\n        return response.getResponseWriter().isOpen();\n    }\n\n    @Override\n    public void setWriteListener(WriteListener listener) {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (!byteBufs.isEmpty()) {\n            response.getResponseWriter().write(\n                    HttpData.wrap(Unpooled.wrappedBuffer(byteBufs.toArray(new ByteBuf[0]))));\n            byteBufs.clear();\n        }\n    }\n\n    @Override\n    public void flush() throws IOException {\n    }\n\n    @Override\n    public void write(int b) throws IOException {\n        byteBufs.add(Unpooled.copyInt(b));\n    }\n\n    @Override\n    public void write(byte[] b, int off, int len) throws IOException {\n        requireNonNull(b, \"b\");\n        checkArgument(off >= 0, \"off: %s (expected: >= 0)\", off);\n        checkArgument(len >= 0, \"len: %s (expected: >= 0)\", len);\n        byteBufs.add(Unpooled.copiedBuffer(b, off, len));\n    }\n\n    @Override\n    public void write(byte[] b) throws IOException {\n        requireNonNull(b, \"b\");\n        byteBufs.add(Unpooled.copiedBuffer(b));\n    }\n}\nServletServiceTest was failed at doDelete().", "author": "dominhhien", "createdAt": "2020-06-15T02:46:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NjEyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkwNjEzNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439906135", "bodyText": "I think doDelete() does not use DefaultServletOutputStream because it just calls response.sendError(HttpStatus.NOT_FOUND.code(), \"Not Found\"); right away. Did I miss something?", "author": "minwoox", "createdAt": "2020-06-15T02:52:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NjEyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkwNzE0Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439907142", "bodyText": "No, do you check doDelete() at inner class: ServletServiceTest.HomeServlet (ServletServiceTest.java line 477)", "author": "dominhhien", "createdAt": "2020-06-15T02:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NjEyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkxMzgyMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439913822", "bodyText": "Ah there's another HomeServlet in the class. Sorry about that I missed. (Perhaps we should rename it to something else to avoid confusion.)\nThe reason that it didn't work is that it tries to write the data first without writing headers. So I think we should fix that.\nIf we use ByteArrayOutputStream, we have to copy the byte array twice.\nBut if we use ByteBuf we can just copy the data only once. If we change to use the ByteBufAllocator from ServiceRequestContext later, we can even reduce to allocate additional byte arrays.\nSo I think it's better to use ByteBufs to hold the data. What do you think?", "author": "minwoox", "createdAt": "2020-06-15T03:31:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NjEyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkyMDkyNA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439920924", "bodyText": "The implementation will be a little tricky so just leave it as it is and fix it later. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-06-15T04:09:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NjEyMA=="}], "type": "inlineReview"}, {"oid": "06c030125256d45391f5c6cbaf4020a12ea0b9ac", "url": "https://github.com/line/armeria/commit/06c030125256d45391f5c6cbaf4020a12ea0b9ac", "message": "Check use output stream or writer", "committedDate": "2020-06-12T10:50:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkyMTQ1Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439921457", "bodyText": "Is there any reason that you overridden methods in this class?\nIt seems like we can just use the methods in PrintWriter?", "author": "minwoox", "createdAt": "2020-06-15T04:11:42Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletPrintWriter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.util.Formatter;\n+import java.util.Locale;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ *  Printing flow.\n+ */\n+final class ServletPrintWriter extends PrintWriter {\n+    private final String lineSeparator = System.lineSeparator();\n+    private final DefaultServletHttpResponse response;\n+\n+    private boolean error;\n+\n+    ServletPrintWriter(DefaultServletHttpResponse response, OutputStream out) {\n+        super(out);\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+    }\n+\n+    @Override\n+    public void flush() {\n+    }\n+\n+    @Override\n+    public void close() {\n+        response.close();\n+    }\n+\n+    @Override\n+    public boolean checkError() {\n+        return error;\n+    }\n+\n+    @Override\n+    protected void setError() {\n+        error = true;\n+    }\n+\n+    @Override\n+    protected void clearError() {\n+        error = false;\n+    }\n+\n+    @Override\n+    public void write(int c) {\n+        write(String.valueOf(c));\n+    }\n+\n+    @Override\n+    public void write(char[] buf, int off, int len) {", "originalCommit": "06c030125256d45391f5c6cbaf4020a12ea0b9ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkyNjk2MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439926961", "bodyText": "Method PrintWriter.write() may be call to OutputStream.write(). I will check all write methods If there is any method that doesn't need to override, i will remove code.", "author": "dominhhien", "createdAt": "2020-06-15T04:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkyMTQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3MzcwNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439973707", "bodyText": "The allToken is always * so we do not want to specify it.\nThe class StringUtil is a bit complex because it's for ANT mapping. How about just using Pattern for simplicity?\nWe can just consider three cases:\n\nThe path that ends with *. (e.g /foo/bar/*)\nImplicit mapping. (e.g *.bop)\nExact path matching.\n\nWe might revisit this to optimize later though.", "author": "minwoox", "createdAt": "2020-06-15T07:16:52Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/UrlMapper.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Url mapping\n+ * Mapping specification\n+ * In the web application deployment descriptor.\n+ */\n+final class UrlMapper<T> {\n+    private final boolean singlePattern;\n+    private final List<Element<T>> elementList = new ArrayList<>();\n+    private final StringUtil stringUtil = new StringUtil();\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    UrlMapper(boolean singlePattern) {\n+        this.singlePattern = singlePattern;\n+    }\n+\n+    /**\n+     * Add mapping.\n+     */\n+    void addMapping(String urlPattern, T object, String objectName) {\n+        requireNonNull(urlPattern, \"urlPattern\");\n+        requireNonNull(object, \"object\");\n+        requireNonNull(objectName, \"objectName\");\n+        if (elementList.stream()\n+                       .filter(x -> singlePattern && x.name.equals(objectName))\n+                       .findAny().orElse(null) != null) {\n+            throw new IllegalArgumentException(\"The [\" + objectName + \"] mapping exist!\");\n+        }\n+\n+        final Element element = elementList.stream()\n+                                           .filter(x -> x.pattern.equals(urlPattern))\n+                                           .findFirst().orElse(null);\n+        if (element != null) {\n+            element.name = objectName;\n+            element.object = object;\n+        } else {\n+            elementList.add(new Element<>(urlPattern, object, objectName));\n+        }\n+    }\n+\n+    /**\n+     * Gets a mapping object.\n+     */\n+    @Nullable\n+    Element<T> getMapping(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return elementList.stream()\n+                          .filter(x -> stringUtil.match(x.pattern, absoluteUri, \"*\"))", "originalCommit": "06c030125256d45391f5c6cbaf4020a12ea0b9ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3OTA1NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439979054", "bodyText": "Yes, I think so. We will revisit this to optimize later.", "author": "dominhhien", "createdAt": "2020-06-15T07:27:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3MzcwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk4Mzc0Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439983742", "bodyText": "What I meant is that I think we need to remove the StringUtil class and just use Pattern in this PR. And then We revisit this to optimize it. \ud83d\ude06", "author": "minwoox", "createdAt": "2020-06-15T07:37:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3MzcwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk5NzQwNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439997407", "bodyText": "Oh, I understand now :D. I will remove StringUtil.", "author": "dominhhien", "createdAt": "2020-06-15T08:03:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3MzcwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NjI4Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439976282", "bodyText": "We should not expose this setter because MimeMappings is a package-private class.\nHow about adding a method for adding mime mapping in this class:\npublic void addMimeMapping(String extension, String mimeType) {\n    ...\n}", "author": "minwoox", "createdAt": "2020-06-15T07:22:20Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.ServerBuilder;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+\n+    private boolean rootServletAdded;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        this(serverBuilder, \"\");\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        requireNonNull(contextPath, \"contextPath\");\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.charAt(0) == '/' && contextPath.charAt(contextPath.length() - 1) != '/',\n+                          \"contextPath must start with / and must not end with /. contextPath: %s\",\n+                          contextPath);\n+        }\n+        servletContext = new DefaultServletContext(contextPath);\n+        this.contextPath = contextPath;\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link ServerBuilder}.\n+     */\n+    public ServerBuilder build() {\n+        final String path = contextPath.isEmpty() ? \"/\" : contextPath;\n+        final DefaultServletService servletService = new DefaultServletService(servletContext);\n+        serverBuilder.serviceUnder(path, servletService);\n+        if (rootServletAdded) {\n+            serverBuilder.service(path, servletService);\n+        } else {\n+            serverBuilder.service(path, (ctx, req) -> HttpResponse.of(HttpStatus.NOT_FOUND));\n+        }\n+        servletContext.init();\n+        return serverBuilder;\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(httpServlet, \"httpServlet\");\n+        validatePath(path);\n+        servletContext.addServlet(contextPath + path, httpServlet);\n+        return this;\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, String servletClass) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        validatePath(path);\n+        servletContext.addServlet(contextPath + path, servletClass);\n+        return this;\n+    }\n+\n+    /**\n+     * Validate servlet path.\n+     */\n+    public void validatePath(String path) {\n+        if (path.isEmpty() || \"/\".equals(path)) {\n+            rootServletAdded = true;\n+        } else {\n+            checkArgument(path.charAt(0) == '/',\n+                          \"servletPath must start with /. servletPath: %s\",\n+                          path);\n+        }\n+    }\n+\n+    /**\n+     * Set attribute value.\n+     */\n+    public ServletBuilder attribute(String key, @Nullable Object value) {\n+        requireNonNull(key, \"key\");\n+        servletContext.setAttribute(key, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Set init parameter.\n+     */\n+    public ServletBuilder initParameter(String key, @Nullable String value) {\n+        requireNonNull(key, \"key\");\n+        servletContext.setInitParameter(key, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public ServletBuilder mimeMapping(MimeMappings mimeMappings) {", "originalCommit": "06c030125256d45391f5c6cbaf4020a12ea0b9ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA4OTgzNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r440089836", "bodyText": "But I think MimeMapping usually add a large extensions list (thousand of extensions). Therefore I want to separate another methods to add extension mapping instead of use ServletBuilder. What do you think?", "author": "dominhhien", "createdAt": "2020-06-15T10:47:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NjI4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUyMTE4Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r440521182", "bodyText": "Then we can add\naddMimeMappings(Map<String, String> mappings) {...}\nWhat do you think:", "author": "minwoox", "createdAt": "2020-06-16T00:38:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NjI4Mg=="}], "type": "inlineReview"}, {"oid": "bbfb666e1e951343b807c5aeb8bb8ac4ea86cc90", "url": "https://github.com/line/armeria/commit/bbfb666e1e951343b807c5aeb8bb8ac4ea86cc90", "message": "Remove StringUtil and ServletPrintWriter", "committedDate": "2020-06-15T11:09:27Z", "type": "commit"}, {"oid": "323f468dd12536b300d87e38f9beb5fae4f1c63f", "url": "https://github.com/line/armeria/commit/323f468dd12536b300d87e38f9beb5fae4f1c63f", "message": "Change setMimeMapping parameter type", "committedDate": "2020-06-16T05:06:12Z", "type": "commit"}, {"oid": "a098372f4657d629ac03734e205fb507b6736adb", "url": "https://github.com/line/armeria/commit/a098372f4657d629ac03734e205fb507b6736adb", "message": "Merge branch 'master' into pr-2686.20200619103717", "committedDate": "2020-06-19T01:37:26Z", "type": "commit"}, {"oid": "5823076cb36a800794484e4077e02b26c0da36e5", "url": "https://github.com/line/armeria/commit/5823076cb36a800794484e4077e02b26c0da36e5", "message": "Remove mimeMapping class", "committedDate": "2020-06-19T01:56:51Z", "type": "commit"}, {"oid": "82799785f19432ecafe9b04670987afc618ff70c", "url": "https://github.com/line/armeria/commit/82799785f19432ecafe9b04670987afc618ff70c", "message": "Remove DefaultFilterRegistration", "committedDate": "2020-06-19T02:26:07Z", "type": "commit"}, {"oid": "31c425d2478dd365ec98ebde765110aa7f25bdb3", "url": "https://github.com/line/armeria/commit/31c425d2478dd365ec98ebde765110aa7f25bdb3", "message": "Remove useless javadoc", "committedDate": "2020-06-19T02:30:35Z", "type": "commit"}, {"oid": "4bf310f36ab1ff451a9cb0b3c6e19362a1c4a476", "url": "https://github.com/line/armeria/commit/4bf310f36ab1ff451a9cb0b3c6e19362a1c4a476", "message": "Fix to use CompletableFuture", "committedDate": "2020-06-19T03:30:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYxNzQwOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r442617409", "bodyText": "@dominhhien What is singlePattern? Could you explain please?", "author": "minwoox", "createdAt": "2020-06-19T03:54:58Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/UrlMapper.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.regex.Pattern;\n+\n+import javax.annotation.Nullable;\n+\n+final class UrlMapper<T> {\n+    private final boolean singlePattern;\n+    private final List<Element<T>> elementList = new ArrayList<>();\n+\n+    UrlMapper(boolean singlePattern) {\n+        this.singlePattern = singlePattern;\n+    }\n+\n+    void addMapping(String urlPattern, T object, String objectName) {\n+        requireNonNull(urlPattern, \"urlPattern\");\n+        requireNonNull(object, \"object\");\n+        requireNonNull(objectName, \"objectName\");\n+        if (elementList.stream()\n+                       .filter(x -> singlePattern && x.name.equals(objectName))", "originalCommit": "4bf310f36ab1ff451a9cb0b3c6e19362a1c4a476", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYxOTcyOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r442619729", "bodyText": "If singlePattern = true, we couldn't override mapping (ServletRegistration).\nIf singlePattern = false, we could override mapping (FilterRegistration).\nRefer DefaultServletContext.java\n    private final UrlMapper<DefaultServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n    private final UrlMapper<DefaultFilterRegistration> filterUrlMapper = new UrlMapper<>(false);", "author": "dominhhien", "createdAt": "2020-06-19T04:05:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYxNzQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1NDU2Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r442654562", "bodyText": "Let me just remove it for now because it's always true. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-06-19T06:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYxNzQwOQ=="}], "type": "inlineReview"}, {"oid": "bf555513f7660a9439bda08539b4c286b67be545", "url": "https://github.com/line/armeria/commit/bf555513f7660a9439bda08539b4c286b67be545", "message": "Various fixes", "committedDate": "2020-06-22T09:20:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4NjEyNA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r443486124", "bodyText": "I think we should throw UnsupportedOperationException here. Let me fix this.", "author": "dominhhien", "createdAt": "2020-06-22T11:14:03Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final ServletUrlMapper servletUrlMapper = new ServletUrlMapper();\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeout = 30; // unit: minutes\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrations = new HashMap<>();\n+    private Map<String, String> mimeMappings = new HashMap<>();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrations = ImmutableMap.copyOf(servletRegistrations);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+        mimeMappings = ImmutableMap.copyOf(mimeMappings);\n+    }\n+\n+    void mimeMapping(String extension, String mimeType) {\n+        requireNonNull(extension, \"extension\");\n+        requireNonNull(mimeType, \"mimeType\");\n+        mimeMappings.put(extension, mimeType);\n+    }\n+\n+    void mimeMappings(Map<String, String> mappings) {\n+        mimeMappings.putAll(requireNonNull(mappings, \"mappings\"));\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final DefaultServletRegistration registration = servletUrlMapper.getMapping(path);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(registration), registration.getName());\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        final DefaultServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        // This method is deprecated and should return null.\n+        return null;\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ArmeriaHttpUtil.SERVER_HEADER +\n+               \" (JDK \" + SystemInfo.javaVersion() + ';' + SystemInfo.osType().name() + ')';\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    void addServlet(String servletName, String className, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, className);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    void addServlet(String servletName, HttpServlet httpServlet, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, httpServlet);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    void addServlet(String servletName, Class<? extends Servlet> servletClass, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, servletClass);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    private void addUrlPatterns(String servletName, @Nullable DefaultServletRegistration registration,\n+                                String... urlPatterns) {\n+        if (registration == null) {\n+            return;\n+        }\n+        final Set<String> conflicts = registration.addMapping(urlPatterns);\n+        if (!conflicts.isEmpty()) {\n+            servletRegistrations.remove(servletName);\n+            throw new IllegalArgumentException(conflicts + \" are mapped already in urlPatterns: \" +\n+                                               Arrays.toString(urlPatterns));\n+        }\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(className, \"className\");\n+        try {\n+            //noinspection unchecked\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName +\n+                                       \", className: \" + className, e);\n+        }\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(servlet, \"servlet\");\n+        if (servletRegistrations.containsKey(servletName)) {\n+            logger.warn(\"{} is registered already.\", servletName);\n+            return null;\n+        }\n+        final DefaultServletRegistration servletRegistration =\n+                new DefaultServletRegistration(servletName, servlet, this, servletUrlMapper, initParamMap);\n+        if (servletRegistrations.containsValue(servletRegistration)) {\n+            logger.warn(\"{} is registered already.\", servlet);\n+            return null;\n+        }\n+        servletRegistrations.put(servletName, servletRegistration);\n+        return servletRegistration;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName +\n+                                       \", servletClass: \" + servletClass, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new ServletException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    @Nullable\n+    public DefaultServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrations.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, DefaultServletRegistration> getServletRegistrations() {\n+        return servletRegistrations;\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, Filter filter) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Nullable\n+    @Override\n+    public FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return null;", "originalCommit": "bf555513f7660a9439bda08539b4c286b67be545", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4NjQ0OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r443486448", "bodyText": "I think we should throw UnsupportedOperationException here. Let me fix this.", "author": "dominhhien", "createdAt": "2020-06-22T11:14:43Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final ServletUrlMapper servletUrlMapper = new ServletUrlMapper();\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeout = 30; // unit: minutes\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrations = new HashMap<>();\n+    private Map<String, String> mimeMappings = new HashMap<>();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrations = ImmutableMap.copyOf(servletRegistrations);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+        mimeMappings = ImmutableMap.copyOf(mimeMappings);\n+    }\n+\n+    void mimeMapping(String extension, String mimeType) {\n+        requireNonNull(extension, \"extension\");\n+        requireNonNull(mimeType, \"mimeType\");\n+        mimeMappings.put(extension, mimeType);\n+    }\n+\n+    void mimeMappings(Map<String, String> mappings) {\n+        mimeMappings.putAll(requireNonNull(mappings, \"mappings\"));\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final DefaultServletRegistration registration = servletUrlMapper.getMapping(path);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(registration), registration.getName());\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        final DefaultServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        // This method is deprecated and should return null.\n+        return null;\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ArmeriaHttpUtil.SERVER_HEADER +\n+               \" (JDK \" + SystemInfo.javaVersion() + ';' + SystemInfo.osType().name() + ')';\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    void addServlet(String servletName, String className, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, className);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    void addServlet(String servletName, HttpServlet httpServlet, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, httpServlet);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    void addServlet(String servletName, Class<? extends Servlet> servletClass, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, servletClass);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    private void addUrlPatterns(String servletName, @Nullable DefaultServletRegistration registration,\n+                                String... urlPatterns) {\n+        if (registration == null) {\n+            return;\n+        }\n+        final Set<String> conflicts = registration.addMapping(urlPatterns);\n+        if (!conflicts.isEmpty()) {\n+            servletRegistrations.remove(servletName);\n+            throw new IllegalArgumentException(conflicts + \" are mapped already in urlPatterns: \" +\n+                                               Arrays.toString(urlPatterns));\n+        }\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(className, \"className\");\n+        try {\n+            //noinspection unchecked\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName +\n+                                       \", className: \" + className, e);\n+        }\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(servlet, \"servlet\");\n+        if (servletRegistrations.containsKey(servletName)) {\n+            logger.warn(\"{} is registered already.\", servletName);\n+            return null;\n+        }\n+        final DefaultServletRegistration servletRegistration =\n+                new DefaultServletRegistration(servletName, servlet, this, servletUrlMapper, initParamMap);\n+        if (servletRegistrations.containsValue(servletRegistration)) {\n+            logger.warn(\"{} is registered already.\", servlet);\n+            return null;\n+        }\n+        servletRegistrations.put(servletName, servletRegistration);\n+        return servletRegistration;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName +\n+                                       \", servletClass: \" + servletClass, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new ServletException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    @Nullable\n+    public DefaultServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrations.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, DefaultServletRegistration> getServletRegistrations() {\n+        return servletRegistrations;\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, Filter filter) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Nullable\n+    @Override\n+    public FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return null;\n+    }\n+\n+    @Override\n+    public Map<String, ? extends FilterRegistration> getFilterRegistrations() {\n+        return ImmutableMap.of();\n+    }", "originalCommit": "bf555513f7660a9439bda08539b4c286b67be545", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5MDc1MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r443490751", "bodyText": "I think\nrequestURI.substring(servletContext.getContextPath().length() + 1) = servletPath + pathInfo\n=> servletPath != requestURI.substring(servletContext.getContextPath().length() + 1)\nLet me fix this.", "author": "dominhhien", "createdAt": "2020-06-22T11:23:58Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -111,7 +107,7 @@\n         requestURI = serviceRequestContext.path();\n         queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n         cookies = decodeCookie();\n-        servletPath = servletContext.getServletPath(requestURI);\n+        servletPath = requestURI.substring(servletContext.getContextPath().length() + 1);", "originalCommit": "bf555513f7660a9439bda08539b4c286b67be545", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bf555513f7660a9439bda08539b4c286b67be545", "url": "https://github.com/line/armeria/commit/bf555513f7660a9439bda08539b4c286b67be545", "message": "Various fixes", "committedDate": "2020-06-22T09:20:40Z", "type": "forcePushed"}, {"oid": "13391fc73f02de293ac84a27377c76184192ed49", "url": "https://github.com/line/armeria/commit/13391fc73f02de293ac84a27377c76184192ed49", "message": "Fix decode servlet path and test case", "committedDate": "2020-06-24T15:42:16Z", "type": "commit"}, {"oid": "b445960fd75b05820cce7adb6bcb90e4ec93a367", "url": "https://github.com/line/armeria/commit/b445960fd75b05820cce7adb6bcb90e4ec93a367", "message": "Merge branch 'master' into pr-2686", "committedDate": "2020-07-07T11:48:52Z", "type": "commit"}, {"oid": "598e25baa3d9caaab5aca80a66ba284bb6a643d5", "url": "https://github.com/line/armeria/commit/598e25baa3d9caaab5aca80a66ba284bb6a643d5", "message": "Fix ServletRequestDispatcher to have servletPath and pathInfo", "committedDate": "2020-07-10T08:20:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxMTg0MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r453611841", "bodyText": "Validation on extension and mimeType?", "author": "trustin", "createdAt": "2020-07-13T12:26:05Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final ServletUrlMapper servletUrlMapper = new ServletUrlMapper();\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeoutMinutes = 30; // TODO add setters.\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrations = new HashMap<>();\n+    private Map<String, String> mimeMappings = new HashMap<>();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrations = ImmutableMap.copyOf(servletRegistrations);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+        mimeMappings = ImmutableMap.copyOf(mimeMappings);\n+    }\n+\n+    void mimeMapping(String extension, String mimeType) {\n+        requireNonNull(extension, \"extension\");\n+        requireNonNull(mimeType, \"mimeType\");\n+        mimeMappings.put(extension, mimeType);", "originalCommit": "598e25baa3d9caaab5aca80a66ba284bb6a643d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxMTk5Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r453611992", "bodyText": "The keys and values of mappings need validation.", "author": "trustin", "createdAt": "2020-07-13T12:26:23Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final ServletUrlMapper servletUrlMapper = new ServletUrlMapper();\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeoutMinutes = 30; // TODO add setters.\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrations = new HashMap<>();\n+    private Map<String, String> mimeMappings = new HashMap<>();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrations = ImmutableMap.copyOf(servletRegistrations);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+        mimeMappings = ImmutableMap.copyOf(mimeMappings);\n+    }\n+\n+    void mimeMapping(String extension, String mimeType) {\n+        requireNonNull(extension, \"extension\");\n+        requireNonNull(mimeType, \"mimeType\");\n+        mimeMappings.put(extension, mimeType);\n+    }\n+\n+    void mimeMappings(Map<String, String> mappings) {\n+        mimeMappings.putAll(requireNonNull(mappings, \"mappings\"));", "originalCommit": "598e25baa3d9caaab5aca80a66ba284bb6a643d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxMzYwNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r453613606", "bodyText": "IIRC, many many servlet implementations rely on these operations to load some resources such as templates and properties files, no?", "author": "trustin", "createdAt": "2020-07-13T12:29:25Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final ServletUrlMapper servletUrlMapper = new ServletUrlMapper();\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeoutMinutes = 30; // TODO add setters.\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrations = new HashMap<>();\n+    private Map<String, String> mimeMappings = new HashMap<>();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrations = ImmutableMap.copyOf(servletRegistrations);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+        mimeMappings = ImmutableMap.copyOf(mimeMappings);\n+    }\n+\n+    void mimeMapping(String extension, String mimeType) {\n+        requireNonNull(extension, \"extension\");\n+        requireNonNull(mimeType, \"mimeType\");\n+        mimeMappings.put(extension, mimeType);\n+    }\n+\n+    void mimeMappings(Map<String, String> mappings) {\n+        mimeMappings.putAll(requireNonNull(mappings, \"mappings\"));\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeoutMinutes;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException();\n+    }", "originalCommit": "598e25baa3d9caaab5aca80a66ba284bb6a643d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxNDM5Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r453614396", "bodyText": "Is is some sort of specification to return the Java version and OS name in this string?", "author": "trustin", "createdAt": "2020-07-13T12:30:49Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final ServletUrlMapper servletUrlMapper = new ServletUrlMapper();\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeoutMinutes = 30; // TODO add setters.\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrations = new HashMap<>();\n+    private Map<String, String> mimeMappings = new HashMap<>();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrations = ImmutableMap.copyOf(servletRegistrations);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+        mimeMappings = ImmutableMap.copyOf(mimeMappings);\n+    }\n+\n+    void mimeMapping(String extension, String mimeType) {\n+        requireNonNull(extension, \"extension\");\n+        requireNonNull(mimeType, \"mimeType\");\n+        mimeMappings.put(extension, mimeType);\n+    }\n+\n+    void mimeMappings(Map<String, String> mappings) {\n+        mimeMappings.putAll(requireNonNull(mappings, \"mappings\"));\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeoutMinutes;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final Pair<String, DefaultServletRegistration> pair = servletUrlMapper.getMapping(path);\n+        if (pair == null) {\n+            return null;\n+        }\n+\n+        // TODO Integrate this logic into servletUrlMapper.\n+        final String pathPattern = pair.getKey();\n+        final String servletPath;\n+        final String pathInfo;\n+        if (pathPattern.endsWith(\"/*\")) {\n+            // pathPattern: \"/lawn/*\"\n+            // path: \"/lawn/index.html\" then,\n+            // servletPath: \"/lawn\"\n+            // pathInfo: \"/index.html\"\n+            servletPath = pathPattern.substring(0, pathPattern.length() - 2);\n+            pathInfo = path.substring(servletPath.length());\n+        } else {\n+            // pathPattern starts with \"*.\" or exact path.\n+            servletPath = path;\n+            pathInfo = null;\n+        }\n+\n+        return new ServletRequestDispatcher(new ServletFilterChain(pair.getValue()), pair.getValue().getName(),\n+                                            servletPath, pathInfo);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        // This method is deprecated and should return null.\n+        return null;\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ArmeriaHttpUtil.SERVER_HEADER +\n+               \" (JDK \" + SystemInfo.javaVersion() + ';' + SystemInfo.osType().name() + ')';", "originalCommit": "598e25baa3d9caaab5aca80a66ba284bb6a643d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA0OTMyOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r454049328", "bodyText": "Yes, I refer from https://github.com/apache/tomcat/blob/master/java/jakarta/servlet/ServletContext.java java doc.\n    /**\n     * Returns the name and version of the servlet container on which the\n     * servlet is running.\n     * <p>\n     * The form of the returned string is\n     * <i>servername</i>/<i>versionnumber</i>. For example, the JavaServer Web\n     * Development Kit may return the string\n     * <code>JavaServer Web Dev Kit/1.0</code>.\n     * <p>\n     * The servlet container may return other optional information after the\n     * primary string in parentheses, for example,\n     * <code>JavaServer Web Dev Kit/1.0 (JDK 1.1.6; Windows NT 4.0 x86)</code>.\n     *\n     * @return a <code>String</code> containing at least the servlet container\n     *         name and version number\n     */", "author": "dominhhien", "createdAt": "2020-07-14T01:49:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxNDM5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxNTY4MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r453615680", "bodyText": "Servlet context listeners are also an important part of Servlet specification many frameworks rely on. Are we sure we do not want to implement this? That would mean it will not work for most code.", "author": "trustin", "createdAt": "2020-07-13T12:33:13Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final ServletUrlMapper servletUrlMapper = new ServletUrlMapper();\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeoutMinutes = 30; // TODO add setters.\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrations = new HashMap<>();\n+    private Map<String, String> mimeMappings = new HashMap<>();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrations = ImmutableMap.copyOf(servletRegistrations);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+        mimeMappings = ImmutableMap.copyOf(mimeMappings);\n+    }\n+\n+    void mimeMapping(String extension, String mimeType) {\n+        requireNonNull(extension, \"extension\");\n+        requireNonNull(mimeType, \"mimeType\");\n+        mimeMappings.put(extension, mimeType);\n+    }\n+\n+    void mimeMappings(Map<String, String> mappings) {\n+        mimeMappings.putAll(requireNonNull(mappings, \"mappings\"));\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeoutMinutes;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final Pair<String, DefaultServletRegistration> pair = servletUrlMapper.getMapping(path);\n+        if (pair == null) {\n+            return null;\n+        }\n+\n+        // TODO Integrate this logic into servletUrlMapper.\n+        final String pathPattern = pair.getKey();\n+        final String servletPath;\n+        final String pathInfo;\n+        if (pathPattern.endsWith(\"/*\")) {\n+            // pathPattern: \"/lawn/*\"\n+            // path: \"/lawn/index.html\" then,\n+            // servletPath: \"/lawn\"\n+            // pathInfo: \"/index.html\"\n+            servletPath = pathPattern.substring(0, pathPattern.length() - 2);\n+            pathInfo = path.substring(servletPath.length());\n+        } else {\n+            // pathPattern starts with \"*.\" or exact path.\n+            servletPath = path;\n+            pathInfo = null;\n+        }\n+\n+        return new ServletRequestDispatcher(new ServletFilterChain(pair.getValue()), pair.getValue().getName(),\n+                                            servletPath, pathInfo);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        // This method is deprecated and should return null.\n+        return null;\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ArmeriaHttpUtil.SERVER_HEADER +\n+               \" (JDK \" + SystemInfo.javaVersion() + ';' + SystemInfo.osType().name() + ')';\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    private void addUrlPatterns(String servletName, @Nullable DefaultServletRegistration registration,\n+                                String... urlPatterns) {\n+        if (registration == null) {\n+            return;\n+        }\n+        final Set<String> conflicts = registration.addMapping(urlPatterns);\n+        if (!conflicts.isEmpty()) {\n+            servletRegistrations.remove(servletName);\n+            throw new IllegalArgumentException(conflicts + \" are mapped already in urlPatterns: \" +\n+                                               Arrays.toString(urlPatterns));\n+        }\n+    }\n+\n+    void addServlet(String servletName, String className, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, className);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    void addServlet(String servletName, HttpServlet httpServlet, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, httpServlet);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    void addServlet(String servletName, Class<? extends Servlet> servletClass, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, servletClass);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(className, \"className\");\n+        try {\n+            //noinspection unchecked\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName +\n+                                       \", className: \" + className, e);\n+        }\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(servlet, \"servlet\");\n+        if (servletRegistrations.containsKey(servletName)) {\n+            logger.warn(\"{} is registered already.\", servletName);\n+            return null;\n+        }\n+        final DefaultServletRegistration servletRegistration =\n+                new DefaultServletRegistration(servletName, servlet, this, servletUrlMapper, initParamMap);\n+        if (servletRegistrations.containsValue(servletRegistration)) {\n+            logger.warn(\"{} is registered already.\", servlet);\n+            return null;\n+        }\n+        servletRegistrations.put(servletName, servletRegistration);\n+        return servletRegistration;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName +\n+                                       \", servletClass: \" + servletClass, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new ServletException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    @Nullable\n+    public DefaultServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrations.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, DefaultServletRegistration> getServletRegistrations() {\n+        return servletRegistrations;\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, String className) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, Filter filter) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Nullable\n+    @Override\n+    public FilterRegistration getFilterRegistration(String filterName) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Map<String, ? extends FilterRegistration> getFilterRegistrations() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        throw new UnsupportedOperationException();\n+    }", "originalCommit": "598e25baa3d9caaab5aca80a66ba284bb6a643d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxNjYzMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r453616633", "bodyText": "At least some sort of minimal session support should exist. It's not easy to find a Servlet application that does not rely on this feature.", "author": "trustin", "createdAt": "2020-07-13T12:35:04Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,567 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final String servletPath;\n+    @Nullable\n+    private final String pathInfo;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    @Nullable\n+    private final Cookie[] cookies;\n+    private final Map<String, String[]> parameters;\n+\n+    DefaultServletHttpRequest(DefaultServletContext servletContext,\n+                              ServiceRequestContext serviceRequestContext,\n+                              AggregatedHttpRequest httpRequest,\n+                              String servletPath,\n+                              @Nullable String pathInfo) {\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        this.servletPath = servletPath;\n+        this.pathInfo = pathInfo;\n+        requestURI = serviceRequestContext.path();\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String dateHeader = getHeader(name);\n+        if (dateHeader == null) {\n+            return -1;\n+        }\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(dateHeader).getTime();\n+            } catch (Exception e) {\n+                // ignored.\n+            }\n+        }\n+        throw new IllegalArgumentException(\"failed to parse a date header: \" + dateHeader);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException();\n+    }", "originalCommit": "598e25baa3d9caaab5aca80a66ba284bb6a643d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3ca62c43618d7e894500dcd37a4d60e5b68617ee", "url": "https://github.com/line/armeria/commit/3ca62c43618d7e894500dcd37a4d60e5b68617ee", "message": "Add MimeType validation, use Map.Entry instead of Pair", "committedDate": "2020-07-14T08:49:26Z", "type": "forcePushed"}, {"oid": "598e25baa3d9caaab5aca80a66ba284bb6a643d5", "url": "https://github.com/line/armeria/commit/598e25baa3d9caaab5aca80a66ba284bb6a643d5", "message": "Fix ServletRequestDispatcher to have servletPath and pathInfo", "committedDate": "2020-07-10T08:20:28Z", "type": "forcePushed"}, {"oid": "598e25baa3d9caaab5aca80a66ba284bb6a643d5", "url": "https://github.com/line/armeria/commit/598e25baa3d9caaab5aca80a66ba284bb6a643d5", "message": "Fix ServletRequestDispatcher to have servletPath and pathInfo", "committedDate": "2020-07-10T08:20:28Z", "type": "forcePushed"}, {"oid": "4e35fd9e69503351e45dcb30a621f2bc992b12a6", "url": "https://github.com/line/armeria/commit/4e35fd9e69503351e45dcb30a621f2bc992b12a6", "message": "Merge pull request #1 from line/master\n\nUpdate new source code", "committedDate": "2020-07-15T10:00:53Z", "type": "commit"}, {"oid": "4e35fd9e69503351e45dcb30a621f2bc992b12a6", "url": "https://github.com/line/armeria/commit/4e35fd9e69503351e45dcb30a621f2bc992b12a6", "message": "Merge pull request #1 from line/master\n\nUpdate new source code", "committedDate": "2020-07-15T10:00:53Z", "type": "forcePushed"}, {"oid": "4e35fd9e69503351e45dcb30a621f2bc992b12a6", "url": "https://github.com/line/armeria/commit/4e35fd9e69503351e45dcb30a621f2bc992b12a6", "message": "Merge pull request #1 from line/master\n\nUpdate new source code", "committedDate": "2020-07-15T10:00:53Z", "type": "forcePushed"}, {"oid": "ab174a4244a1a02201cda04c6a29bd1877681d69", "url": "https://github.com/line/armeria/commit/ab174a4244a1a02201cda04c6a29bd1877681d69", "message": "MimeType validation, Pair -> Map.Entry, servlet-container -> servlet-adapter", "committedDate": "2020-07-15T10:41:20Z", "type": "commit"}, {"oid": "ab174a4244a1a02201cda04c6a29bd1877681d69", "url": "https://github.com/line/armeria/commit/ab174a4244a1a02201cda04c6a29bd1877681d69", "message": "MimeType validation, Pair -> Map.Entry, servlet-container -> servlet-adapter", "committedDate": "2020-07-15T10:41:20Z", "type": "forcePushed"}]}