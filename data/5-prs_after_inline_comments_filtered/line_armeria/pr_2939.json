{"pr_number": 2939, "pr_title": "Add `when*TimingOut` and `when*TimedOut` to `{Service,Client}RequestContext`", "pr_createdAt": "2020-07-27T09:04:21Z", "pr_url": "https://github.com/line/armeria/pull/2939", "timeline": [{"oid": "8c738feef8741525fa1e367060fa478b9897f2af", "url": "https://github.com/line/armeria/commit/8c738feef8741525fa1e367060fa478b9897f2af", "message": "Add `whenTimingOut` and `whenTimedOut` to RequestContext\n\nMotivation:\n\nCurrently, it is hard to listen to the timeout event when a request is timed-out.\nUsers should use `set*TimeoutHandler()` or request log.\n`set*TimeoutHandler()` seems a hook, however, it replaces the default timeout task\nwith the specified handler. It must be used with great care. See #2937\n\nBy adding `whenTimingOut()` and `whenTimedOut()`,\n`set*TimeoutHandler()` could be easily migrated to one of them.\n\nModifications:\n\n- Add `whenTimingOut()` and `whenTimedOut()` to `RequestContext`\n- Fix grpc code to use `whenTimingOut()`\n- Deprecate `ServiceRequestContext.setRequestTimeoutHandler()`\n- Deprecate `ClientRequestContext.setResponseTimeoutHandler()`\n\nResult:\n\n- You can now listen to a request timeout event using `whenTimingOut()`, and `whenTimedOut()`.\n  ```java\n  ServiceRequestContext ctx = ...;\n  ctx.whenTimingOut().thenRun(() -> {\n      // Execute a hook right before the timeout.\n      // e.g. release some resources.\n      ...\n  });\n\n  ctx.whenTimedOut().thenRun(() -> {\n      // Execute a hook right after the timeout\n      // e.g. log some message.\n      ...\n  });\n  ```\n- Fixes #2937", "committedDate": "2020-07-27T08:57:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1MzA0Mw==", "url": "https://github.com/line/armeria/pull/2939#discussion_r460753043", "bodyText": "is about to get timed out?", "author": "trustin", "createdAt": "2020-07-27T09:10:56Z", "path": "core/src/main/java/com/linecorp/armeria/common/RequestContext.java", "diffHunk": "@@ -378,6 +378,19 @@\n      */\n     boolean isTimedOut();\n \n+    /**\n+     * Returns a {@link CompletableFuture} which is completed when {@link RequestContext} is timing-out.", "originalCommit": "8c738feef8741525fa1e367060fa478b9897f2af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1MzE5Mg==", "url": "https://github.com/line/armeria/pull/2939#discussion_r460753192", "bodyText": "has been timed out?", "author": "trustin", "createdAt": "2020-07-27T09:11:14Z", "path": "core/src/main/java/com/linecorp/armeria/common/RequestContext.java", "diffHunk": "@@ -378,6 +378,19 @@\n      */\n     boolean isTimedOut();\n \n+    /**\n+     * Returns a {@link CompletableFuture} which is completed when {@link RequestContext} is timing-out.\n+     */\n+    CompletableFuture<Void> whenTimingOut();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} which is completed when {@link RequestContext} is timed-out", "originalCommit": "8c738feef8741525fa1e367060fa478b9897f2af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1MzUyMw==", "url": "https://github.com/line/armeria/pull/2939#discussion_r460753523", "bodyText": "volatile and CAS", "author": "trustin", "createdAt": "2020-07-27T09:11:53Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultTimeoutController.java", "diffHunk": "@@ -49,9 +52,14 @@\n     private long firstExecutionTimeNanos;\n     private long lastExecutionTimeNanos;\n \n+    private State state = State.INIT;\n+\n     @Nullable\n     private ScheduledFuture<?> timeoutFuture;\n-    private State state = State.INIT;\n+    @Nullable\n+    private CompletableFuture<Void> whenTimingOut;\n+    @Nullable\n+    private CompletableFuture<Void> whenTimedOut;", "originalCommit": "8c738feef8741525fa1e367060fa478b9897f2af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1NTQzMw==", "url": "https://github.com/line/armeria/pull/2939#discussion_r460755433", "bodyText": "CAS on whenTimingOut? e.g.\nif (!whenTimingOutUpdater.compareAndSet(this, null, Unmodifiablefuture.completedFuture(null))) {\n    if (timeoutTask.canSchedule()) {\n       whenTimingOut.complete(null);\n    }\n}", "author": "trustin", "createdAt": "2020-07-27T09:15:03Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultTimeoutController.java", "diffHunk": "@@ -247,9 +271,27 @@ private void ensureInitialized() {\n \n     private void invokeTimeoutTask() {\n         if (timeoutTask != null) {\n+            if (whenTimingOut != null) {\n+                if (timeoutTask.canSchedule()) {\n+                    whenTimingOut.complete(null);\n+                }\n+            } else {\n+                whenTimingOut = UnmodifiableFuture.completedFuture(null);\n+            }", "originalCommit": "8c738feef8741525fa1e367060fa478b9897f2af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg4OTUxOA==", "url": "https://github.com/line/armeria/pull/2939#discussion_r460889518", "bodyText": "Fixed :-)", "author": "ikhoon", "createdAt": "2020-07-27T13:29:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1NTQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1NTU2Nw==", "url": "https://github.com/line/armeria/pull/2939#discussion_r460755567", "bodyText": "CAS", "author": "trustin", "createdAt": "2020-07-27T09:15:16Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultTimeoutController.java", "diffHunk": "@@ -247,9 +271,27 @@ private void ensureInitialized() {\n \n     private void invokeTimeoutTask() {\n         if (timeoutTask != null) {\n+            if (whenTimingOut != null) {\n+                if (timeoutTask.canSchedule()) {\n+                    whenTimingOut.complete(null);\n+                }\n+            } else {\n+                whenTimingOut = UnmodifiableFuture.completedFuture(null);\n+            }\n+\n             // Set TIMED_OUT flag first to prevent duplicate execution\n             state = State.TIMED_OUT;\n-            timeoutTask.run();\n+\n+            // The returned value of `canSchedule()` could be changed by the callbacks of `whenTimedOut`\n+            if (timeoutTask.canSchedule()) {\n+                timeoutTask.run();\n+            }\n+\n+            if (whenTimedOut != null) {\n+                whenTimedOut.complete(null);\n+            } else {\n+                whenTimedOut = UnmodifiableFuture.completedFuture(null);\n+            }", "originalCommit": "8c738feef8741525fa1e367060fa478b9897f2af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2MDQxNQ==", "url": "https://github.com/line/armeria/pull/2939#discussion_r460760415", "bodyText": "volatile and CAS please", "author": "trustin", "createdAt": "2020-07-27T09:23:34Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -39,6 +41,10 @@\n     private EventLoop eventLoop;\n     @Nullable\n     private TimeoutController timeoutController;\n+    @Nullable\n+    private CompletableFuture<Void> timingOutFuture;\n+    @Nullable\n+    private CompletableFuture<Void> timedOutFuture;", "originalCommit": "8c738feef8741525fa1e367060fa478b9897f2af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg5MDA5MQ==", "url": "https://github.com/line/armeria/pull/2939#discussion_r460890091", "bodyText": "As commented in #2939 (comment),\nsychronized block is used.", "author": "ikhoon", "createdAt": "2020-07-27T13:29:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2MDQxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2MTIzMQ==", "url": "https://github.com/line/armeria/pull/2939#discussion_r460761231", "bodyText": "Consider thread safety - what happens when one thread calls setTimeoutController() and another calls when*() methods above?", "author": "trustin", "createdAt": "2020-07-27T09:25:02Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -158,13 +164,54 @@ public boolean isTimedOut() {\n         return timeoutController.isTimedOut();\n     }\n \n+    public CompletableFuture<Void> whenTimingOut() {\n+        if (timeoutController == null) {\n+            if (timingOutFuture == null) {\n+                timingOutFuture = new CompletableFuture<>();\n+            }\n+            return UnmodifiableFuture.wrap(timingOutFuture);\n+        }\n+        if (timingOutFuture == null) {\n+            return timingOutFuture = UnmodifiableFuture.wrap(timeoutController.whenTimingOut());\n+        }\n+        if (timingOutFuture instanceof UnmodifiableFuture) {\n+            return timingOutFuture;\n+        }\n+\n+        return timingOutFuture = UnmodifiableFuture.wrap(timingOutFuture);\n+    }\n+\n+    public CompletableFuture<Void> whenTimedOut() {\n+        if (timeoutController == null) {\n+            if (timedOutFuture == null) {\n+                timedOutFuture = new CompletableFuture<>();\n+            }\n+            return UnmodifiableFuture.wrap(timedOutFuture);\n+        }\n+        if (timedOutFuture == null) {\n+            return timedOutFuture = UnmodifiableFuture.wrap(timeoutController.whenTimedOut());\n+        }\n+        if (timedOutFuture instanceof UnmodifiableFuture) {\n+            return timedOutFuture;\n+        }\n+\n+        return timedOutFuture = UnmodifiableFuture.wrap(timedOutFuture);\n+    }\n+\n     public void setTimeoutController(TimeoutController timeoutController, EventLoop eventLoop) {\n         requireNonNull(timeoutController, \"timeoutController\");\n         requireNonNull(eventLoop, \"eventLoop\");\n         checkState(this.timeoutController == null, \"timeoutController is set already.\");\n+\n+        if (timingOutFuture != null) {\n+            timeoutController.whenTimingOut().thenRun(() -> timingOutFuture.complete(null));\n+        }\n+        if (timedOutFuture != null) {\n+            timeoutController.whenTimedOut().thenRun(() -> timedOutFuture.complete(null));\n+        }", "originalCommit": "8c738feef8741525fa1e367060fa478b9897f2af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg4ODEyNQ==", "url": "https://github.com/line/armeria/pull/2939#discussion_r460888125", "bodyText": "I've tried to use CAS here, but it was hard. Because this callback has to work only if tim*OutFuture was allocated before this block.\nLet me use synchronized block.", "author": "ikhoon", "createdAt": "2020-07-27T13:26:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2MTIzMQ=="}], "type": "inlineReview"}, {"oid": "d667779751d7698ce986985ea0b431d62c446593", "url": "https://github.com/line/armeria/commit/d667779751d7698ce986985ea0b431d62c446593", "message": "Address comments by @trustin", "committedDate": "2020-07-27T13:27:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkyOTY5OA==", "url": "https://github.com/line/armeria/pull/2939#discussion_r460929698", "bodyText": "Too many volatile reads. Please optimize.\nShould we return an UnmodifiableFuture?\n\nHow about making UnmodifiableFuture non-final so we can extend it and call doComplete*(), so we do not have to create two future instances?", "author": "trustin", "createdAt": "2020-07-27T14:26:02Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultTimeoutController.java", "diffHunk": "@@ -236,6 +257,24 @@ public boolean isTimedOut() {\n         return state == State.TIMED_OUT;\n     }\n \n+    @Override\n+    public CompletableFuture<Void> whenTimingOut() {\n+        if (whenTimingOut != null) {\n+            return whenTimingOut;\n+        }\n+        whenTimingOutUpdater.compareAndSet(this, null, new CompletableFuture<>());\n+        return whenTimingOut;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> whenTimedOut() {\n+        if (whenTimedOut != null) {\n+            return whenTimedOut;\n+        }\n+        whenTimedOutUpdater.compareAndSet(this, null, new CompletableFuture<>());\n+        return whenTimedOut;\n+    }", "originalCommit": "d667779751d7698ce986985ea0b431d62c446593", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkzNDg2MQ==", "url": "https://github.com/line/armeria/pull/2939#discussion_r460934861", "bodyText": "could've been", "author": "trustin", "createdAt": "2020-07-27T14:32:43Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultTimeoutController.java", "diffHunk": "@@ -247,9 +286,23 @@ private void ensureInitialized() {\n \n     private void invokeTimeoutTask() {\n         if (timeoutTask != null) {\n+            if (!whenTimingOutUpdater.compareAndSet(this, null, UnmodifiableFuture.completedFuture(null))) {\n+                if (timeoutTask.canSchedule()) {\n+                    whenTimingOut.complete(null);\n+                }\n+            }\n+\n             // Set TIMED_OUT flag first to prevent duplicate execution\n             state = State.TIMED_OUT;\n-            timeoutTask.run();\n+\n+            // The returned value of `canSchedule()` could be changed by the callbacks of `whenTimedOut`", "originalCommit": "d667779751d7698ce986985ea0b431d62c446593", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAxNDAwMg==", "url": "https://github.com/line/armeria/pull/2939#discussion_r461014002", "bodyText": "whenTimingOut?", "author": "trustin", "createdAt": "2020-07-27T16:26:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkzNDg2MQ=="}], "type": "inlineReview"}, {"oid": "f3c7573c689f59ecb1727a54c7c12bb8e54f7dc6", "url": "https://github.com/line/armeria/commit/f3c7573c689f59ecb1727a54c7c12bb8e54f7dc6", "message": "Remove timeout controller", "committedDate": "2020-07-28T15:50:53Z", "type": "commit"}, {"oid": "cb4d700489df7cae255c1987989c8bb8d9592098", "url": "https://github.com/line/armeria/commit/cb4d700489df7cae255c1987989c8bb8d9592098", "message": "Checkstyle", "committedDate": "2020-07-28T16:19:31Z", "type": "commit"}, {"oid": "867d7cf808ecca0f67aa2b818f1f6812bb18f266", "url": "https://github.com/line/armeria/commit/867d7cf808ecca0f67aa2b818f1f6812bb18f266", "message": "Clean up", "committedDate": "2020-07-28T16:54:40Z", "type": "commit"}, {"oid": "112ae9bd397dc5efa993a0a66932acc55c6c0817", "url": "https://github.com/line/armeria/commit/112ae9bd397dc5efa993a0a66932acc55c6c0817", "message": "Fix flaky", "committedDate": "2020-07-28T17:32:09Z", "type": "commit"}, {"oid": "37fc1bca692a574abc07aa44462ce0418b423d81", "url": "https://github.com/line/armeria/commit/37fc1bca692a574abc07aa44462ce0418b423d81", "message": "Fix flaky 2", "committedDate": "2020-07-29T01:07:23Z", "type": "commit"}, {"oid": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653", "url": "https://github.com/line/armeria/commit/dbe310654d43a3a6ec16d6b769f3ac02bc7f6653", "message": "Remove assert", "committedDate": "2020-07-29T02:24:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNTcxNg==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462005716", "bodyText": "Merge two lines?", "author": "trustin", "createdAt": "2020-07-29T02:47:39Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientRequestContextBuilder.java", "diffHunk": "@@ -61,11 +61,14 @@ public void run() { /* no-op */ }\n     /**\n      * A timeout controller that has been timed-out.\n      */\n-    private static final DefaultTimeoutController noopTimedOutController =\n-            new DefaultTimeoutController(noopTimeoutTask, ImmediateEventExecutor.INSTANCE);\n+    private static final TimeoutScheduler noopTimedOutScheduler =\n+            new TimeoutScheduler(0);", "originalCommit": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNTkyOQ==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462005929", "bodyText": "Could be done without .execute()?", "author": "trustin", "createdAt": "2020-07-29T02:48:32Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientRequestContextBuilder.java", "diffHunk": "@@ -61,11 +61,14 @@ public void run() { /* no-op */ }\n     /**\n      * A timeout controller that has been timed-out.\n      */\n-    private static final DefaultTimeoutController noopTimedOutController =\n-            new DefaultTimeoutController(noopTimeoutTask, ImmediateEventExecutor.INSTANCE);\n+    private static final TimeoutScheduler noopTimedOutScheduler =\n+            new TimeoutScheduler(0);\n \n     static {\n-        noopTimedOutController.timeoutNow();\n+        ImmediateEventExecutor.INSTANCE.execute(() -> {\n+            noopTimedOutScheduler.init(ImmediateEventExecutor.INSTANCE, noopTimeoutTask, 0);\n+            noopTimedOutScheduler.timeoutNow();\n+        });", "originalCommit": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNjE1MQ==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462006151", "bodyText": "noopResponseTimeoutScheduler?", "author": "trustin", "createdAt": "2020-07-29T02:49:26Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientRequestContextBuilder.java", "diffHunk": "@@ -61,11 +61,14 @@ public void run() { /* no-op */ }\n     /**\n      * A timeout controller that has been timed-out.\n      */\n-    private static final DefaultTimeoutController noopTimedOutController =\n-            new DefaultTimeoutController(noopTimeoutTask, ImmediateEventExecutor.INSTANCE);\n+    private static final TimeoutScheduler noopTimedOutScheduler =", "originalCommit": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNjIwMA==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462006200", "bodyText": "responseTimeoutScheduler?", "author": "trustin", "createdAt": "2020-07-29T02:49:38Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientRequestContextBuilder.java", "diffHunk": "@@ -135,9 +130,27 @@ public ClientRequestContext build() {\n             endpoint = Endpoint.parse(authority());\n         }\n \n+        final TimeoutScheduler timeoutScheduler;", "originalCommit": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNjM5NA==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462006394", "bodyText": "responseTimeoutScheduler?", "author": "trustin", "createdAt": "2020-07-29T02:50:20Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -172,7 +173,7 @@ private DefaultClientRequestContext(\n             SessionProtocol sessionProtocol, RequestId id, HttpMethod method, String path,\n             @Nullable String query, @Nullable String fragment, ClientOptions options,\n             @Nullable HttpRequest req, @Nullable RpcRequest rpcReq,\n-            @Nullable ServiceRequestContext root,\n+            @Nullable ServiceRequestContext root, @Nullable TimeoutScheduler timeoutScheduler,", "originalCommit": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNjQxNw==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462006417", "bodyText": "responseTimeoutScheduler?", "author": "trustin", "createdAt": "2020-07-29T02:50:27Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -100,6 +98,7 @@\n     @Nullable\n     private final ServiceRequestContext root;\n \n+    private final ClientOptions options;\n     private final RequestLogBuilder log;\n     private final TimeoutScheduler timeoutScheduler;", "originalCommit": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNzAwOQ==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462007009", "bodyText": "How about removing this field and just checking if ctx is DefaultClientRequestContext when timeoutScheduler is accessed? (Because it's accessed just two times)", "author": "trustin", "createdAt": "2020-07-29T02:52:45Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpResponseDecoder.java", "diffHunk": "@@ -150,6 +150,9 @@ final boolean needsToDisconnectWhenFinished() {\n         private final DecodedHttpResponse delegate;\n         @Nullable\n         private final ClientRequestContext ctx;\n+        @Nullable\n+        private final TimeoutScheduler timeoutScheduler;", "originalCommit": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNzE1OQ==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462007159", "bodyText": "requestTimeoutScheduler?", "author": "trustin", "createdAt": "2020-07-29T02:53:24Z", "path": "core/src/main/java/com/linecorp/armeria/server/DefaultServiceRequestContext.java", "diffHunk": "@@ -136,14 +136,15 @@ public DefaultServiceRequestContext(\n             long requestStartTimeNanos, long requestStartTimeMicros) {\n \n         this(cfg, ch, meterRegistry, sessionProtocol, id, routingContext, routingResult, req,\n-             sslSession, proxiedAddresses, clientAddress, requestStartTimeNanos, requestStartTimeMicros,\n-             HttpHeaders.of(), HttpHeaders.of());\n+             sslSession, proxiedAddresses, clientAddress, /* timeoutScheduler */ null,\n+             requestStartTimeNanos, requestStartTimeMicros, HttpHeaders.of(), HttpHeaders.of());\n     }\n \n-    private DefaultServiceRequestContext(\n+    DefaultServiceRequestContext(\n             ServiceConfig cfg, Channel ch, MeterRegistry meterRegistry, SessionProtocol sessionProtocol,\n             RequestId id, RoutingContext routingContext, RoutingResult routingResult, HttpRequest req,\n             @Nullable SSLSession sslSession, ProxiedAddresses proxiedAddresses, InetAddress clientAddress,\n+            @Nullable TimeoutScheduler timeoutScheduler,", "originalCommit": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwODI4NA==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462008284", "bodyText": "noopRequestTimeoutScheduler", "author": "trustin", "createdAt": "2020-07-29T02:57:22Z", "path": "core/src/main/java/com/linecorp/armeria/server/ServiceRequestContextBuilder.java", "diffHunk": "@@ -78,11 +81,13 @@ public void run() { /* no-op */ }\n     /**\n      * A timeout controller that has been timed-out.\n      */\n-    private static final DefaultTimeoutController noopTimedOutController =\n-            new DefaultTimeoutController(noopTimeoutTask, ImmediateEventExecutor.INSTANCE);\n+    private static final TimeoutScheduler noopTimedOutScheduler = new TimeoutScheduler(0);", "originalCommit": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwODMzOA==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462008338", "bodyText": "requestTimeoutScheduler", "author": "trustin", "createdAt": "2020-07-29T02:57:34Z", "path": "core/src/main/java/com/linecorp/armeria/server/ServiceRequestContextBuilder.java", "diffHunk": "@@ -228,21 +233,31 @@ public ServiceRequestContext build() {\n         final InetAddress clientAddress = server.config().clientAddressMapper().apply(proxiedAddresses)\n                                                 .getAddress();\n \n-        final DefaultTimeoutController timeoutController;\n+        final TimeoutScheduler timeoutScheduler;", "originalCommit": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwODY1NA==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462008654", "bodyText": "Should we rename this class or merge into TimeoutSchedulerTest?", "author": "trustin", "createdAt": "2020-07-29T02:58:44Z", "path": "core/src/test/java/com/linecorp/armeria/internal/common/DefaultTimeoutControllerTest.java", "diffHunk": "@@ -18,58 +18,51 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.awaitility.Awaitility.await;\n \n import java.time.Duration;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n \n-import javax.annotation.Nullable;\n-\n-import org.junit.jupiter.api.BeforeEach;\n+import org.assertj.core.data.Offset;\n import org.junit.jupiter.api.Test;\n-\n-import com.google.common.util.concurrent.Uninterruptibles;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import com.linecorp.armeria.common.CommonPools;\n-import com.linecorp.armeria.internal.common.DefaultTimeoutController.State;\n-import com.linecorp.armeria.internal.common.DefaultTimeoutController.TimeoutTask;\n+import com.linecorp.armeria.common.util.TimeoutMode;\n+import com.linecorp.armeria.internal.common.TimeoutScheduler.State;\n+import com.linecorp.armeria.internal.common.TimeoutScheduler.TimeoutTask;\n+\n+import io.netty.util.concurrent.EventExecutor;\n \n class DefaultTimeoutControllerTest {", "originalCommit": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNDI5OA==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462014298", "bodyText": "Oops... \ud83d\ude31", "author": "ikhoon", "createdAt": "2020-07-29T03:20:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwODY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwOTEyOQ==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462009129", "bodyText": "Could return null by default and delete the old implementations?", "author": "trustin", "createdAt": "2020-07-29T03:00:18Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientRequestContext.java", "diffHunk": "@@ -426,7 +427,10 @@ default void setResponseTimeout(Duration responseTimeout) {\n      * Returns {@link Response} timeout handler which is executed when\n      * the {@link Response} is not completely received within the allowed {@link #responseTimeoutMillis()}\n      * or the default {@link ClientOptions#RESPONSE_TIMEOUT_MILLIS}.\n+     *\n+     * @deprecated Use {@link #whenResponseTimingOut()} or {@link #whenResponseTimedOut()}\n      */\n+    @Deprecated\n     @Nullable\n     Runnable responseTimeoutHandler();", "originalCommit": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNDQ4Mg==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462014482", "bodyText": "That sounds good!", "author": "ikhoon", "createdAt": "2020-07-29T03:21:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwOTEyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwOTMzOQ==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462009339", "bodyText": "Could delegate to whenResponseTimingOut().thenRun() and delete the old implementations?", "author": "trustin", "createdAt": "2020-07-29T03:00:58Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientRequestContext.java", "diffHunk": "@@ -443,9 +447,26 @@ default void setResponseTimeout(Duration responseTimeout) {\n      * });\n      * ...\n      * }</pre>\n+     *\n+     * @deprecated Use {@link #whenResponseTimingOut()} or {@link #whenResponseTimedOut()}\n      */\n+    @Deprecated\n     void setResponseTimeoutHandler(Runnable responseTimeoutHandler);", "originalCommit": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxMDIxOA==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462010218", "bodyText": "How about removing final so that a subclass can call this method?\nJavadoc", "author": "trustin", "createdAt": "2020-07-29T03:04:31Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/UnmodifiableFuture.java", "diffHunk": "@@ -113,7 +113,7 @@ public boolean complete(@Nullable T value) {\n         throw new UnsupportedOperationException();\n     }\n \n-    private void doComplete(@Nullable T value) {\n+    protected final void doComplete(@Nullable T value) {", "originalCommit": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxMDI0Mg==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462010242", "bodyText": "How about removing final so that a subclass can call this method?\nJavadoc", "author": "trustin", "createdAt": "2020-07-29T03:04:38Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/UnmodifiableFuture.java", "diffHunk": "@@ -125,7 +125,7 @@ public boolean completeExceptionally(Throwable ex) {\n         throw new UnsupportedOperationException();\n     }\n \n-    private void doCompleteExceptionally(Throwable cause) {\n+    protected final void doCompleteExceptionally(Throwable cause) {", "originalCommit": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAyMzAxNw==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462023017", "bodyText": "Should return here?\nAlso we can remove the second line in Javadoc?", "author": "minwoox", "createdAt": "2020-07-29T03:55:44Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -18,73 +18,194 @@\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n-import static java.util.Objects.requireNonNull;\n \n-import java.util.function.Consumer;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n import javax.annotation.Nullable;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.math.LongMath;\n \n import com.linecorp.armeria.common.util.TimeoutMode;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n \n import io.netty.channel.EventLoop;\n+import io.netty.util.concurrent.EventExecutor;\n \n public final class TimeoutScheduler {\n \n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, TimeoutFuture>\n+            whenTimingOutUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, TimeoutFuture.class, \"whenTimingOut\");\n+\n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, TimeoutFuture>\n+            whenTimedOutUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, TimeoutFuture.class, \"whenTimedOut\");\n+\n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, Runnable>\n+            pendingTimeoutTaskUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, Runnable.class, \"pendingTimeoutTask\");\n+\n+    private static final AtomicLongFieldUpdater<TimeoutScheduler> pendingTimeoutNanosUpdater =\n+            AtomicLongFieldUpdater.newUpdater(TimeoutScheduler.class, \"pendingTimeoutNanos\");\n+\n+    private static final TimeoutFuture COMPLETED_FUTURE;\n+\n+    static {\n+        COMPLETED_FUTURE = new TimeoutFuture();\n+        COMPLETED_FUTURE.doComplete();\n+    }\n+\n+    enum State {\n+        INIT,\n+        INACTIVE,\n+        SCHEDULED,\n+        TIMED_OUT\n+    }\n+\n     private long timeoutNanos;\n+    private long firstExecutionTimeNanos;\n+\n+    private State state = State.INIT;\n+\n+    @Nullable\n+    private TimeoutTask timeoutTask;\n+    @Nullable\n+    private ScheduledFuture<?> timeoutFuture;\n+    @Nullable\n+    private EventExecutor eventLoop;\n+\n+    // Updated via whenTimingOutUpdater\n     @Nullable\n-    private Consumer<TimeoutController> pendingTimeoutTask;\n+    private volatile TimeoutFuture whenTimingOut;\n+    // Updated via whenTimedOutUpdater\n     @Nullable\n-    private EventLoop eventLoop;\n+    private volatile TimeoutFuture whenTimedOut;\n+    // Updated via pendingTimeoutTaskUpdater\n     @Nullable\n-    private TimeoutController timeoutController;\n+    private volatile Runnable pendingTimeoutTask;\n+    // Updated via pendingTimeoutNanosUpdater\n+    @SuppressWarnings(\"FieldMayBeFinal\")\n+    private volatile long pendingTimeoutNanos;\n+\n+    private volatile boolean initialized;\n \n     public TimeoutScheduler(long timeoutNanos) {\n         this.timeoutNanos = timeoutNanos;\n+        pendingTimeoutNanos = timeoutNanos;\n+    }\n+\n+    /**\n+     * Initializes this {@link TimeoutScheduler}.\n+     * Note that this method should be called in the specified {@link EventLoop}\n+     * to initialize this scheduler synchronously\n+     */\n+    public void init(EventExecutor eventLoop, TimeoutTask timeoutTask, long initialTimeoutNanos) {\n+        if (!eventLoop.inEventLoop()) {\n+            eventLoop.execute(() -> init(eventLoop, timeoutTask, initialTimeoutNanos));", "originalCommit": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAyNDgxMw==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462024813", "bodyText": "Oops. It should return here.", "author": "ikhoon", "createdAt": "2020-07-29T04:02:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAyMzAxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAyMzM1OQ==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462023359", "bodyText": "when {@link ClientRequestContext} has been -> after {@link ClientRequestContext} is\nto clarify the difference with whenResponseTimingOut?", "author": "minwoox", "createdAt": "2020-07-29T03:57:05Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientRequestContext.java", "diffHunk": "@@ -443,9 +447,26 @@ default void setResponseTimeout(Duration responseTimeout) {\n      * });\n      * ...\n      * }</pre>\n+     *\n+     * @deprecated Use {@link #whenResponseTimingOut()} or {@link #whenResponseTimedOut()}\n      */\n+    @Deprecated\n     void setResponseTimeoutHandler(Runnable responseTimeoutHandler);\n \n+    /**\n+     * Returns a {@link CompletableFuture} which is completed when {@link ClientRequestContext} is about to\n+     * get timed out.\n+     */\n+    CompletableFuture<Void> whenResponseTimingOut();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} which is completed when {@link ClientRequestContext} has been", "originalCommit": "dbe310654d43a3a6ec16d6b769f3ac02bc7f6653", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAyNTc2NQ==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462025765", "bodyText": "That makes sense.", "author": "ikhoon", "createdAt": "2020-07-29T04:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAyMzM1OQ=="}], "type": "inlineReview"}, {"oid": "ed493ddd607793de60ccb6bcda70386b85c61079", "url": "https://github.com/line/armeria/commit/ed493ddd607793de60ccb6bcda70386b85c61079", "message": "Address comments by @trustin", "committedDate": "2020-07-29T03:59:24Z", "type": "commit"}, {"oid": "203d176794a8dfde91dd3529a923bb9daebad506", "url": "https://github.com/line/armeria/commit/203d176794a8dfde91dd3529a923bb9daebad506", "message": "Address comments by @minwoox", "committedDate": "2020-07-29T04:07:44Z", "type": "commit"}, {"oid": "1be0e6a0e1d4c167d348ba5bccf40caeac45bcae", "url": "https://github.com/line/armeria/commit/1be0e6a0e1d4c167d348ba5bccf40caeac45bcae", "message": "Clean up", "committedDate": "2020-07-29T04:26:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAyNTgxNg==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462025816", "bodyText": "final TimeoutFuture whenTimingOut = this.whenTimingOut;\nif (whenTimingOut != null) {\n    return whenTimingOut;\n}\nin order not to access the volatile field twice?", "author": "minwoox", "createdAt": "2020-07-29T04:06:51Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -97,93 +218,250 @@ private void extendTimeoutNanos(long adjustmentNanos) {\n             return;\n         }\n \n-        final long oldTimeoutNanos = timeoutNanos;\n-        timeoutNanos = LongMath.saturatedAdd(oldTimeoutNanos, adjustmentNanos);\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.extendTimeoutNanos(adjustmentNanos);\n+                unsafeExtendTimeoutNanos(adjustmentNanos);\n             } else {\n-                eventLoop.execute(() -> timeoutController.extendTimeoutNanos(adjustmentNanos));\n+                eventLoop.execute(() -> unsafeExtendTimeoutNanos(adjustmentNanos));\n             }\n         } else {\n-            addPendingTimeoutTask(controller -> controller.extendTimeoutNanos(adjustmentNanos));\n+            addPendingTimeoutNanos(adjustmentNanos);\n+            addPendingTimeoutTask(() -> unsafeExtendTimeoutNanos(adjustmentNanos));\n+        }\n+    }\n+\n+    private boolean unsafeExtendTimeoutNanos(long adjustmentNanos) {\n+        ensureInitialized();\n+        if (state != State.SCHEDULED || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n+        if (adjustmentNanos == 0) {\n+            return true;\n+        }\n+\n+        final long timeoutNanos = this.timeoutNanos;\n+        // Cancel the previously scheduled timeout, if exists.\n+        unsafeClearTimeout(true);\n+\n+        this.timeoutNanos = LongMath.saturatedAdd(timeoutNanos, adjustmentNanos);\n+\n+        if (timeoutNanos <= 0) {\n+            invokeTimeoutTask();\n+            return true;\n         }\n+\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask,\n+                                           LongMath.saturatedAdd(timeoutNanos, adjustmentNanos),\n+                                           TimeUnit.NANOSECONDS);\n+        return true;\n     }\n \n-    private void setTimeoutAfterNanos(long timeoutNanos) {\n+    private void setTimeoutNanosFromNow(long timeoutNanos) {\n         checkArgument(timeoutNanos > 0, \"timeoutNanos: %s (expected: > 0)\", timeoutNanos);\n \n-        long passedTimeNanos = 0;\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n-            final Long startTimeNanos = timeoutController.startTimeNanos();\n-            if (startTimeNanos != null) {\n-                passedTimeNanos = System.nanoTime() - startTimeNanos;\n-            }\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.resetTimeoutNanos(timeoutNanos);\n+                unsafeSetTimeoutNanosFromNow(timeoutNanos);\n             } else {\n-                eventLoop.execute(() -> timeoutController.resetTimeoutNanos(timeoutNanos));\n+                eventLoop.execute(() -> unsafeSetTimeoutNanosFromNow(timeoutNanos));\n             }\n         } else {\n             final long startTimeNanos = System.nanoTime();\n-            addPendingTimeoutTask(controller -> {\n+            setPendingTimeoutNanos(timeoutNanos);\n+            addPendingTimeoutTask(() -> {\n                 final long passedTimeNanos0 = System.nanoTime() - startTimeNanos;\n                 final long timeoutNanos0 = Math.max(1, timeoutNanos - passedTimeNanos0);\n-                controller.resetTimeoutNanos(timeoutNanos0);\n+                unsafeSetTimeoutNanosFromNow(timeoutNanos0);\n             });\n         }\n+    }\n \n-        this.timeoutNanos = LongMath.saturatedAdd(passedTimeNanos, timeoutNanos);\n+    private boolean unsafeSetTimeoutNanosFromNow(long newTimeoutNanos) {\n+        ensureInitialized();\n+        if (state == State.TIMED_OUT || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n+        // Cancel the previously scheduled timeout, if exists.\n+        unsafeClearTimeout(true);\n+\n+        final long passedTimeNanos = System.nanoTime() - firstExecutionTimeNanos;\n+        timeoutNanos = LongMath.saturatedAdd(newTimeoutNanos, passedTimeNanos);\n+\n+        if (newTimeoutNanos <= 0) {\n+            return true;\n+        }\n+\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutNanos, TimeUnit.NANOSECONDS);\n+        return true;\n     }\n \n     public void timeoutNow() {\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.timeoutNow();\n+                unsafeTimeoutNow();\n             } else {\n-                eventLoop.execute(timeoutController::timeoutNow);\n+                eventLoop.execute(this::unsafeTimeoutNow);\n             }\n         } else {\n-            addPendingTimeoutTask(TimeoutController::timeoutNow);\n+            addPendingTimeoutTask(this::unsafeTimeoutNow);\n         }\n     }\n \n-    public boolean isTimedOut() {\n-        if (timeoutController == null) {\n-            return false;\n+    private void unsafeTimeoutNow() {\n+        checkState(timeoutTask != null,\n+                   \"init(eventLoop, timeoutTask) is not called yet.\");\n+\n+        if (!timeoutTask.canSchedule()) {\n+            return;\n+        }\n+\n+        switch (state) {\n+            case TIMED_OUT:\n+                return;\n+            case INIT:\n+            case INACTIVE:\n+                invokeTimeoutTask();\n+                return;\n+            case SCHEDULED:\n+                if (unsafeClearTimeout(false)) {\n+                    invokeTimeoutTask();\n+                }\n+                return;\n+            default:\n+                throw new Error(); // Should not reach here.\n         }\n-        return timeoutController.isTimedOut();\n     }\n \n-    public void setTimeoutController(TimeoutController timeoutController, EventLoop eventLoop) {\n-        requireNonNull(timeoutController, \"timeoutController\");\n-        requireNonNull(eventLoop, \"eventLoop\");\n-        checkState(this.timeoutController == null, \"timeoutController is set already.\");\n-        this.timeoutController = timeoutController;\n-        this.eventLoop = eventLoop;\n+    private void addPendingTimeoutTask(Runnable pendingTimeoutTask) {\n+        if (!pendingTimeoutTaskUpdater.compareAndSet(this, null, pendingTimeoutTask)) {\n+            for (;;) {\n+                final Runnable pendingTask = this.pendingTimeoutTask;\n+                final Runnable newPendingTask = () -> {\n+                    pendingTask.run();\n+                    pendingTimeoutTask.run();\n+                };\n+                if (pendingTimeoutTaskUpdater.compareAndSet(this, pendingTask, newPendingTask)) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n \n-        final Consumer<TimeoutController> pendingTimeoutTask = this.pendingTimeoutTask;\n-        if (pendingTimeoutTask != null) {\n-            if (eventLoop.inEventLoop()) {\n-                pendingTimeoutTask.accept(timeoutController);\n-            } else {\n-                eventLoop.execute(() -> pendingTimeoutTask.accept(timeoutController));\n+    private void setPendingTimeoutNanos(long pendingTimeoutNanos) {\n+        for (;;) {\n+            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n+            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n+                                                         pendingTimeoutNanos)) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private void addPendingTimeoutNanos(long pendingTimeoutNanos) {\n+        for (;;) {\n+            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n+            final long newPendingTimeoutNanos =\n+                    LongMath.saturatedAdd(oldPendingTimeoutNanos, pendingTimeoutNanos);\n+            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n+                                                         newPendingTimeoutNanos)) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private void invokeTimeoutTask() {\n+        if (timeoutTask != null) {\n+            if (!whenTimingOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n+                if (timeoutTask.canSchedule()) {\n+                    whenTimingOut.doComplete();\n+                }\n+            }\n+\n+            // Set TIMED_OUT flag first to prevent duplicate execution\n+            state = State.TIMED_OUT;\n+\n+            // The returned value of `canSchedule()` could've been changed by the callbacks of `whenTimingOut`\n+            if (timeoutTask.canSchedule()) {\n+                timeoutTask.run();\n+            }\n+\n+            if (!whenTimedOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n+                whenTimedOut.doComplete();\n             }\n         }\n     }\n \n+    public boolean isTimedOut() {\n+        return state == State.TIMED_OUT;\n+    }\n+\n     public long timeoutNanos() {\n-        return timeoutNanos;\n+        return initialized ? timeoutNanos : pendingTimeoutNanos;\n     }\n \n-    private void addPendingTimeoutTask(Consumer<TimeoutController> pendingTimeoutTask) {\n-        if (this.pendingTimeoutTask == null) {\n-            this.pendingTimeoutTask = pendingTimeoutTask;\n-        } else {\n-            this.pendingTimeoutTask = this.pendingTimeoutTask.andThen(pendingTimeoutTask);\n+    public CompletableFuture<Void> whenTimingOut() {\n+        if (whenTimingOut != null) {", "originalCommit": "ed493ddd607793de60ccb6bcda70386b85c61079", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcyMzQzMA==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462723430", "bodyText": "Fixed :-)", "author": "ikhoon", "createdAt": "2020-07-30T04:11:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAyNTgxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAyNTg1MQ==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462025851", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-07-29T04:07:00Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -97,93 +218,250 @@ private void extendTimeoutNanos(long adjustmentNanos) {\n             return;\n         }\n \n-        final long oldTimeoutNanos = timeoutNanos;\n-        timeoutNanos = LongMath.saturatedAdd(oldTimeoutNanos, adjustmentNanos);\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.extendTimeoutNanos(adjustmentNanos);\n+                unsafeExtendTimeoutNanos(adjustmentNanos);\n             } else {\n-                eventLoop.execute(() -> timeoutController.extendTimeoutNanos(adjustmentNanos));\n+                eventLoop.execute(() -> unsafeExtendTimeoutNanos(adjustmentNanos));\n             }\n         } else {\n-            addPendingTimeoutTask(controller -> controller.extendTimeoutNanos(adjustmentNanos));\n+            addPendingTimeoutNanos(adjustmentNanos);\n+            addPendingTimeoutTask(() -> unsafeExtendTimeoutNanos(adjustmentNanos));\n+        }\n+    }\n+\n+    private boolean unsafeExtendTimeoutNanos(long adjustmentNanos) {\n+        ensureInitialized();\n+        if (state != State.SCHEDULED || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n+        if (adjustmentNanos == 0) {\n+            return true;\n+        }\n+\n+        final long timeoutNanos = this.timeoutNanos;\n+        // Cancel the previously scheduled timeout, if exists.\n+        unsafeClearTimeout(true);\n+\n+        this.timeoutNanos = LongMath.saturatedAdd(timeoutNanos, adjustmentNanos);\n+\n+        if (timeoutNanos <= 0) {\n+            invokeTimeoutTask();\n+            return true;\n         }\n+\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask,\n+                                           LongMath.saturatedAdd(timeoutNanos, adjustmentNanos),\n+                                           TimeUnit.NANOSECONDS);\n+        return true;\n     }\n \n-    private void setTimeoutAfterNanos(long timeoutNanos) {\n+    private void setTimeoutNanosFromNow(long timeoutNanos) {\n         checkArgument(timeoutNanos > 0, \"timeoutNanos: %s (expected: > 0)\", timeoutNanos);\n \n-        long passedTimeNanos = 0;\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n-            final Long startTimeNanos = timeoutController.startTimeNanos();\n-            if (startTimeNanos != null) {\n-                passedTimeNanos = System.nanoTime() - startTimeNanos;\n-            }\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.resetTimeoutNanos(timeoutNanos);\n+                unsafeSetTimeoutNanosFromNow(timeoutNanos);\n             } else {\n-                eventLoop.execute(() -> timeoutController.resetTimeoutNanos(timeoutNanos));\n+                eventLoop.execute(() -> unsafeSetTimeoutNanosFromNow(timeoutNanos));\n             }\n         } else {\n             final long startTimeNanos = System.nanoTime();\n-            addPendingTimeoutTask(controller -> {\n+            setPendingTimeoutNanos(timeoutNanos);\n+            addPendingTimeoutTask(() -> {\n                 final long passedTimeNanos0 = System.nanoTime() - startTimeNanos;\n                 final long timeoutNanos0 = Math.max(1, timeoutNanos - passedTimeNanos0);\n-                controller.resetTimeoutNanos(timeoutNanos0);\n+                unsafeSetTimeoutNanosFromNow(timeoutNanos0);\n             });\n         }\n+    }\n \n-        this.timeoutNanos = LongMath.saturatedAdd(passedTimeNanos, timeoutNanos);\n+    private boolean unsafeSetTimeoutNanosFromNow(long newTimeoutNanos) {\n+        ensureInitialized();\n+        if (state == State.TIMED_OUT || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n+        // Cancel the previously scheduled timeout, if exists.\n+        unsafeClearTimeout(true);\n+\n+        final long passedTimeNanos = System.nanoTime() - firstExecutionTimeNanos;\n+        timeoutNanos = LongMath.saturatedAdd(newTimeoutNanos, passedTimeNanos);\n+\n+        if (newTimeoutNanos <= 0) {\n+            return true;\n+        }\n+\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutNanos, TimeUnit.NANOSECONDS);\n+        return true;\n     }\n \n     public void timeoutNow() {\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.timeoutNow();\n+                unsafeTimeoutNow();\n             } else {\n-                eventLoop.execute(timeoutController::timeoutNow);\n+                eventLoop.execute(this::unsafeTimeoutNow);\n             }\n         } else {\n-            addPendingTimeoutTask(TimeoutController::timeoutNow);\n+            addPendingTimeoutTask(this::unsafeTimeoutNow);\n         }\n     }\n \n-    public boolean isTimedOut() {\n-        if (timeoutController == null) {\n-            return false;\n+    private void unsafeTimeoutNow() {\n+        checkState(timeoutTask != null,\n+                   \"init(eventLoop, timeoutTask) is not called yet.\");\n+\n+        if (!timeoutTask.canSchedule()) {\n+            return;\n+        }\n+\n+        switch (state) {\n+            case TIMED_OUT:\n+                return;\n+            case INIT:\n+            case INACTIVE:\n+                invokeTimeoutTask();\n+                return;\n+            case SCHEDULED:\n+                if (unsafeClearTimeout(false)) {\n+                    invokeTimeoutTask();\n+                }\n+                return;\n+            default:\n+                throw new Error(); // Should not reach here.\n         }\n-        return timeoutController.isTimedOut();\n     }\n \n-    public void setTimeoutController(TimeoutController timeoutController, EventLoop eventLoop) {\n-        requireNonNull(timeoutController, \"timeoutController\");\n-        requireNonNull(eventLoop, \"eventLoop\");\n-        checkState(this.timeoutController == null, \"timeoutController is set already.\");\n-        this.timeoutController = timeoutController;\n-        this.eventLoop = eventLoop;\n+    private void addPendingTimeoutTask(Runnable pendingTimeoutTask) {\n+        if (!pendingTimeoutTaskUpdater.compareAndSet(this, null, pendingTimeoutTask)) {\n+            for (;;) {\n+                final Runnable pendingTask = this.pendingTimeoutTask;\n+                final Runnable newPendingTask = () -> {\n+                    pendingTask.run();\n+                    pendingTimeoutTask.run();\n+                };\n+                if (pendingTimeoutTaskUpdater.compareAndSet(this, pendingTask, newPendingTask)) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n \n-        final Consumer<TimeoutController> pendingTimeoutTask = this.pendingTimeoutTask;\n-        if (pendingTimeoutTask != null) {\n-            if (eventLoop.inEventLoop()) {\n-                pendingTimeoutTask.accept(timeoutController);\n-            } else {\n-                eventLoop.execute(() -> pendingTimeoutTask.accept(timeoutController));\n+    private void setPendingTimeoutNanos(long pendingTimeoutNanos) {\n+        for (;;) {\n+            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n+            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n+                                                         pendingTimeoutNanos)) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private void addPendingTimeoutNanos(long pendingTimeoutNanos) {\n+        for (;;) {\n+            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n+            final long newPendingTimeoutNanos =\n+                    LongMath.saturatedAdd(oldPendingTimeoutNanos, pendingTimeoutNanos);\n+            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n+                                                         newPendingTimeoutNanos)) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private void invokeTimeoutTask() {\n+        if (timeoutTask != null) {\n+            if (!whenTimingOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n+                if (timeoutTask.canSchedule()) {\n+                    whenTimingOut.doComplete();\n+                }\n+            }\n+\n+            // Set TIMED_OUT flag first to prevent duplicate execution\n+            state = State.TIMED_OUT;\n+\n+            // The returned value of `canSchedule()` could've been changed by the callbacks of `whenTimingOut`\n+            if (timeoutTask.canSchedule()) {\n+                timeoutTask.run();\n+            }\n+\n+            if (!whenTimedOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n+                whenTimedOut.doComplete();\n             }\n         }\n     }\n \n+    public boolean isTimedOut() {\n+        return state == State.TIMED_OUT;\n+    }\n+\n     public long timeoutNanos() {\n-        return timeoutNanos;\n+        return initialized ? timeoutNanos : pendingTimeoutNanos;\n     }\n \n-    private void addPendingTimeoutTask(Consumer<TimeoutController> pendingTimeoutTask) {\n-        if (this.pendingTimeoutTask == null) {\n-            this.pendingTimeoutTask = pendingTimeoutTask;\n-        } else {\n-            this.pendingTimeoutTask = this.pendingTimeoutTask.andThen(pendingTimeoutTask);\n+    public CompletableFuture<Void> whenTimingOut() {\n+        if (whenTimingOut != null) {\n+            return whenTimingOut;\n+        }\n+        whenTimingOutUpdater.compareAndSet(this, null, new TimeoutFuture());\n+        return whenTimingOut;\n+    }\n+\n+    public CompletableFuture<Void> whenTimedOut() {\n+        if (whenTimedOut != null) {", "originalCommit": "ed493ddd607793de60ccb6bcda70386b85c61079", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAyNTk4Mw==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462025983", "bodyText": "nit: @Nullable?", "author": "minwoox", "createdAt": "2020-07-29T04:07:40Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -97,93 +218,250 @@ private void extendTimeoutNanos(long adjustmentNanos) {\n             return;\n         }\n \n-        final long oldTimeoutNanos = timeoutNanos;\n-        timeoutNanos = LongMath.saturatedAdd(oldTimeoutNanos, adjustmentNanos);\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.extendTimeoutNanos(adjustmentNanos);\n+                unsafeExtendTimeoutNanos(adjustmentNanos);\n             } else {\n-                eventLoop.execute(() -> timeoutController.extendTimeoutNanos(adjustmentNanos));\n+                eventLoop.execute(() -> unsafeExtendTimeoutNanos(adjustmentNanos));\n             }\n         } else {\n-            addPendingTimeoutTask(controller -> controller.extendTimeoutNanos(adjustmentNanos));\n+            addPendingTimeoutNanos(adjustmentNanos);\n+            addPendingTimeoutTask(() -> unsafeExtendTimeoutNanos(adjustmentNanos));\n+        }\n+    }\n+\n+    private boolean unsafeExtendTimeoutNanos(long adjustmentNanos) {\n+        ensureInitialized();\n+        if (state != State.SCHEDULED || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n+        if (adjustmentNanos == 0) {\n+            return true;\n+        }\n+\n+        final long timeoutNanos = this.timeoutNanos;\n+        // Cancel the previously scheduled timeout, if exists.\n+        unsafeClearTimeout(true);\n+\n+        this.timeoutNanos = LongMath.saturatedAdd(timeoutNanos, adjustmentNanos);\n+\n+        if (timeoutNanos <= 0) {\n+            invokeTimeoutTask();\n+            return true;\n         }\n+\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask,\n+                                           LongMath.saturatedAdd(timeoutNanos, adjustmentNanos),\n+                                           TimeUnit.NANOSECONDS);\n+        return true;\n     }\n \n-    private void setTimeoutAfterNanos(long timeoutNanos) {\n+    private void setTimeoutNanosFromNow(long timeoutNanos) {\n         checkArgument(timeoutNanos > 0, \"timeoutNanos: %s (expected: > 0)\", timeoutNanos);\n \n-        long passedTimeNanos = 0;\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n-            final Long startTimeNanos = timeoutController.startTimeNanos();\n-            if (startTimeNanos != null) {\n-                passedTimeNanos = System.nanoTime() - startTimeNanos;\n-            }\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.resetTimeoutNanos(timeoutNanos);\n+                unsafeSetTimeoutNanosFromNow(timeoutNanos);\n             } else {\n-                eventLoop.execute(() -> timeoutController.resetTimeoutNanos(timeoutNanos));\n+                eventLoop.execute(() -> unsafeSetTimeoutNanosFromNow(timeoutNanos));\n             }\n         } else {\n             final long startTimeNanos = System.nanoTime();\n-            addPendingTimeoutTask(controller -> {\n+            setPendingTimeoutNanos(timeoutNanos);\n+            addPendingTimeoutTask(() -> {\n                 final long passedTimeNanos0 = System.nanoTime() - startTimeNanos;\n                 final long timeoutNanos0 = Math.max(1, timeoutNanos - passedTimeNanos0);\n-                controller.resetTimeoutNanos(timeoutNanos0);\n+                unsafeSetTimeoutNanosFromNow(timeoutNanos0);\n             });\n         }\n+    }\n \n-        this.timeoutNanos = LongMath.saturatedAdd(passedTimeNanos, timeoutNanos);\n+    private boolean unsafeSetTimeoutNanosFromNow(long newTimeoutNanos) {\n+        ensureInitialized();\n+        if (state == State.TIMED_OUT || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n+        // Cancel the previously scheduled timeout, if exists.\n+        unsafeClearTimeout(true);\n+\n+        final long passedTimeNanos = System.nanoTime() - firstExecutionTimeNanos;\n+        timeoutNanos = LongMath.saturatedAdd(newTimeoutNanos, passedTimeNanos);\n+\n+        if (newTimeoutNanos <= 0) {\n+            return true;\n+        }\n+\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutNanos, TimeUnit.NANOSECONDS);\n+        return true;\n     }\n \n     public void timeoutNow() {\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.timeoutNow();\n+                unsafeTimeoutNow();\n             } else {\n-                eventLoop.execute(timeoutController::timeoutNow);\n+                eventLoop.execute(this::unsafeTimeoutNow);\n             }\n         } else {\n-            addPendingTimeoutTask(TimeoutController::timeoutNow);\n+            addPendingTimeoutTask(this::unsafeTimeoutNow);\n         }\n     }\n \n-    public boolean isTimedOut() {\n-        if (timeoutController == null) {\n-            return false;\n+    private void unsafeTimeoutNow() {\n+        checkState(timeoutTask != null,\n+                   \"init(eventLoop, timeoutTask) is not called yet.\");\n+\n+        if (!timeoutTask.canSchedule()) {\n+            return;\n+        }\n+\n+        switch (state) {\n+            case TIMED_OUT:\n+                return;\n+            case INIT:\n+            case INACTIVE:\n+                invokeTimeoutTask();\n+                return;\n+            case SCHEDULED:\n+                if (unsafeClearTimeout(false)) {\n+                    invokeTimeoutTask();\n+                }\n+                return;\n+            default:\n+                throw new Error(); // Should not reach here.\n         }\n-        return timeoutController.isTimedOut();\n     }\n \n-    public void setTimeoutController(TimeoutController timeoutController, EventLoop eventLoop) {\n-        requireNonNull(timeoutController, \"timeoutController\");\n-        requireNonNull(eventLoop, \"eventLoop\");\n-        checkState(this.timeoutController == null, \"timeoutController is set already.\");\n-        this.timeoutController = timeoutController;\n-        this.eventLoop = eventLoop;\n+    private void addPendingTimeoutTask(Runnable pendingTimeoutTask) {\n+        if (!pendingTimeoutTaskUpdater.compareAndSet(this, null, pendingTimeoutTask)) {\n+            for (;;) {\n+                final Runnable pendingTask = this.pendingTimeoutTask;\n+                final Runnable newPendingTask = () -> {\n+                    pendingTask.run();\n+                    pendingTimeoutTask.run();\n+                };\n+                if (pendingTimeoutTaskUpdater.compareAndSet(this, pendingTask, newPendingTask)) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n \n-        final Consumer<TimeoutController> pendingTimeoutTask = this.pendingTimeoutTask;\n-        if (pendingTimeoutTask != null) {\n-            if (eventLoop.inEventLoop()) {\n-                pendingTimeoutTask.accept(timeoutController);\n-            } else {\n-                eventLoop.execute(() -> pendingTimeoutTask.accept(timeoutController));\n+    private void setPendingTimeoutNanos(long pendingTimeoutNanos) {\n+        for (;;) {\n+            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n+            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n+                                                         pendingTimeoutNanos)) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private void addPendingTimeoutNanos(long pendingTimeoutNanos) {\n+        for (;;) {\n+            final long oldPendingTimeoutNanos = this.pendingTimeoutNanos;\n+            final long newPendingTimeoutNanos =\n+                    LongMath.saturatedAdd(oldPendingTimeoutNanos, pendingTimeoutNanos);\n+            if (pendingTimeoutNanosUpdater.compareAndSet(this, oldPendingTimeoutNanos,\n+                                                         newPendingTimeoutNanos)) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private void invokeTimeoutTask() {\n+        if (timeoutTask != null) {\n+            if (!whenTimingOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n+                if (timeoutTask.canSchedule()) {\n+                    whenTimingOut.doComplete();\n+                }\n+            }\n+\n+            // Set TIMED_OUT flag first to prevent duplicate execution\n+            state = State.TIMED_OUT;\n+\n+            // The returned value of `canSchedule()` could've been changed by the callbacks of `whenTimingOut`\n+            if (timeoutTask.canSchedule()) {\n+                timeoutTask.run();\n+            }\n+\n+            if (!whenTimedOutUpdater.compareAndSet(this, null, COMPLETED_FUTURE)) {\n+                whenTimedOut.doComplete();\n             }\n         }\n     }\n \n+    public boolean isTimedOut() {\n+        return state == State.TIMED_OUT;\n+    }\n+\n     public long timeoutNanos() {\n-        return timeoutNanos;\n+        return initialized ? timeoutNanos : pendingTimeoutNanos;\n     }\n \n-    private void addPendingTimeoutTask(Consumer<TimeoutController> pendingTimeoutTask) {\n-        if (this.pendingTimeoutTask == null) {\n-            this.pendingTimeoutTask = pendingTimeoutTask;\n-        } else {\n-            this.pendingTimeoutTask = this.pendingTimeoutTask.andThen(pendingTimeoutTask);\n+    public CompletableFuture<Void> whenTimingOut() {\n+        if (whenTimingOut != null) {\n+            return whenTimingOut;\n+        }\n+        whenTimingOutUpdater.compareAndSet(this, null, new TimeoutFuture());\n+        return whenTimingOut;\n+    }\n+\n+    public CompletableFuture<Void> whenTimedOut() {\n+        if (whenTimedOut != null) {\n+            return whenTimedOut;\n+        }\n+        whenTimedOutUpdater.compareAndSet(this, null, new TimeoutFuture());\n+        return whenTimedOut;\n+    }\n+\n+    private void ensureInitialized() {\n+        checkState(timeoutTask != null,\n+                   \"init(eventLoop, timeoutTask) is not called yet.\");\n+        if (state == State.INIT) {\n+            state = State.INACTIVE;\n+            firstExecutionTimeNanos = System.nanoTime();\n+        }\n+    }\n+\n+    public Long startTimeNanos() {", "originalCommit": "ed493ddd607793de60ccb6bcda70386b85c61079", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA5OTIyNA==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462099224", "bodyText": "This is init method. I think we don't have to call this.", "author": "minwoox", "createdAt": "2020-07-29T07:37:09Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -18,73 +18,192 @@\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n-import static java.util.Objects.requireNonNull;\n \n-import java.util.function.Consumer;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n import javax.annotation.Nullable;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.math.LongMath;\n \n import com.linecorp.armeria.common.util.TimeoutMode;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n \n-import io.netty.channel.EventLoop;\n+import io.netty.util.concurrent.EventExecutor;\n \n public final class TimeoutScheduler {\n \n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, TimeoutFuture>\n+            whenTimingOutUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, TimeoutFuture.class, \"whenTimingOut\");\n+\n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, TimeoutFuture>\n+            whenTimedOutUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, TimeoutFuture.class, \"whenTimedOut\");\n+\n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, Runnable>\n+            pendingTimeoutTaskUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, Runnable.class, \"pendingTimeoutTask\");\n+\n+    private static final AtomicLongFieldUpdater<TimeoutScheduler> pendingTimeoutNanosUpdater =\n+            AtomicLongFieldUpdater.newUpdater(TimeoutScheduler.class, \"pendingTimeoutNanos\");\n+\n+    private static final TimeoutFuture COMPLETED_FUTURE;\n+\n+    static {\n+        COMPLETED_FUTURE = new TimeoutFuture();\n+        COMPLETED_FUTURE.doComplete();\n+    }\n+\n+    enum State {\n+        INIT,\n+        INACTIVE,\n+        SCHEDULED,\n+        TIMED_OUT\n+    }\n+\n     private long timeoutNanos;\n+    private long firstExecutionTimeNanos;\n+\n+    private State state = State.INIT;\n+\n+    @Nullable\n+    private TimeoutTask timeoutTask;\n+    @Nullable\n+    private ScheduledFuture<?> timeoutFuture;\n+    @Nullable\n+    private EventExecutor eventLoop;\n+\n+    // Updated via whenTimingOutUpdater\n     @Nullable\n-    private Consumer<TimeoutController> pendingTimeoutTask;\n+    private volatile TimeoutFuture whenTimingOut;\n+    // Updated via whenTimedOutUpdater\n     @Nullable\n-    private EventLoop eventLoop;\n+    private volatile TimeoutFuture whenTimedOut;\n+    // Updated via pendingTimeoutTaskUpdater\n     @Nullable\n-    private TimeoutController timeoutController;\n+    private volatile Runnable pendingTimeoutTask;\n+    // Updated via pendingTimeoutNanosUpdater\n+    @SuppressWarnings(\"FieldMayBeFinal\")\n+    private volatile long pendingTimeoutNanos;\n+\n+    private volatile boolean initialized;\n \n     public TimeoutScheduler(long timeoutNanos) {\n         this.timeoutNanos = timeoutNanos;\n+        pendingTimeoutNanos = timeoutNanos;\n+    }\n+\n+    /**\n+     * Initializes this {@link TimeoutScheduler}.\n+     */\n+    public void init(EventExecutor eventLoop, TimeoutTask timeoutTask, long initialTimeoutNanos) {\n+        if (!eventLoop.inEventLoop()) {\n+            eventLoop.execute(() -> init(eventLoop, timeoutTask, initialTimeoutNanos));\n+            return;\n+        }\n+\n+        this.eventLoop = eventLoop;\n+        this.timeoutTask = timeoutTask;\n+        if (initialTimeoutNanos > 0) {\n+            timeoutNanos = initialTimeoutNanos;\n+        }\n+\n+        ensureInitialized();", "originalCommit": "1be0e6a0e1d4c167d348ba5bccf40caeac45bcae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2OTgxOQ==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462269819", "bodyText": "Yap, It is needed to clean up.", "author": "ikhoon", "createdAt": "2020-07-29T12:46:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA5OTIyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwMTc3Mg==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462101772", "bodyText": "nit: clearTimeout0? we normally use unsafe for other purposes.", "author": "minwoox", "createdAt": "2020-07-29T07:41:47Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -18,73 +18,192 @@\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n-import static java.util.Objects.requireNonNull;\n \n-import java.util.function.Consumer;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n import javax.annotation.Nullable;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.math.LongMath;\n \n import com.linecorp.armeria.common.util.TimeoutMode;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n \n-import io.netty.channel.EventLoop;\n+import io.netty.util.concurrent.EventExecutor;\n \n public final class TimeoutScheduler {\n \n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, TimeoutFuture>\n+            whenTimingOutUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, TimeoutFuture.class, \"whenTimingOut\");\n+\n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, TimeoutFuture>\n+            whenTimedOutUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, TimeoutFuture.class, \"whenTimedOut\");\n+\n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, Runnable>\n+            pendingTimeoutTaskUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, Runnable.class, \"pendingTimeoutTask\");\n+\n+    private static final AtomicLongFieldUpdater<TimeoutScheduler> pendingTimeoutNanosUpdater =\n+            AtomicLongFieldUpdater.newUpdater(TimeoutScheduler.class, \"pendingTimeoutNanos\");\n+\n+    private static final TimeoutFuture COMPLETED_FUTURE;\n+\n+    static {\n+        COMPLETED_FUTURE = new TimeoutFuture();\n+        COMPLETED_FUTURE.doComplete();\n+    }\n+\n+    enum State {\n+        INIT,\n+        INACTIVE,\n+        SCHEDULED,\n+        TIMED_OUT\n+    }\n+\n     private long timeoutNanos;\n+    private long firstExecutionTimeNanos;\n+\n+    private State state = State.INIT;\n+\n+    @Nullable\n+    private TimeoutTask timeoutTask;\n+    @Nullable\n+    private ScheduledFuture<?> timeoutFuture;\n+    @Nullable\n+    private EventExecutor eventLoop;\n+\n+    // Updated via whenTimingOutUpdater\n     @Nullable\n-    private Consumer<TimeoutController> pendingTimeoutTask;\n+    private volatile TimeoutFuture whenTimingOut;\n+    // Updated via whenTimedOutUpdater\n     @Nullable\n-    private EventLoop eventLoop;\n+    private volatile TimeoutFuture whenTimedOut;\n+    // Updated via pendingTimeoutTaskUpdater\n     @Nullable\n-    private TimeoutController timeoutController;\n+    private volatile Runnable pendingTimeoutTask;\n+    // Updated via pendingTimeoutNanosUpdater\n+    @SuppressWarnings(\"FieldMayBeFinal\")\n+    private volatile long pendingTimeoutNanos;\n+\n+    private volatile boolean initialized;\n \n     public TimeoutScheduler(long timeoutNanos) {\n         this.timeoutNanos = timeoutNanos;\n+        pendingTimeoutNanos = timeoutNanos;\n+    }\n+\n+    /**\n+     * Initializes this {@link TimeoutScheduler}.\n+     */\n+    public void init(EventExecutor eventLoop, TimeoutTask timeoutTask, long initialTimeoutNanos) {\n+        if (!eventLoop.inEventLoop()) {\n+            eventLoop.execute(() -> init(eventLoop, timeoutTask, initialTimeoutNanos));\n+            return;\n+        }\n+\n+        this.eventLoop = eventLoop;\n+        this.timeoutTask = timeoutTask;\n+        if (initialTimeoutNanos > 0) {\n+            timeoutNanos = initialTimeoutNanos;\n+        }\n+\n+        ensureInitialized();\n+        if (timeoutNanos != 0) {\n+            state = State.SCHEDULED;\n+            timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutNanos, TimeUnit.NANOSECONDS);\n+        }\n+\n+        Runnable pendingTimeoutTask;\n+        for (;;) {\n+            pendingTimeoutTask = this.pendingTimeoutTask;\n+            if (pendingTimeoutTaskUpdater.compareAndSet(this, pendingTimeoutTask, null)) {\n+                break;\n+            }\n+        }\n+\n+        if (pendingTimeoutTask != null) {\n+            pendingTimeoutTask.run();\n+        }\n+        initialized = true;\n+        final Runnable newlyAdded = this.pendingTimeoutTask;\n+        if (newlyAdded != null) {\n+            newlyAdded.run();\n+        }\n     }\n \n     public void clearTimeout() {\n+       clearTimeout(true);\n+    }\n+\n+    public void clearTimeout(boolean resetTimeout) {\n         if (timeoutNanos == 0) {\n             return;\n         }\n \n-        final TimeoutController timeoutController = this.timeoutController;\n-        timeoutNanos = 0;\n-        if (timeoutController != null) {\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.cancelTimeout();\n+                unsafeClearTimeout(resetTimeout);\n             } else {\n-                eventLoop.execute(timeoutController::cancelTimeout);\n+                eventLoop.execute(() -> unsafeClearTimeout(resetTimeout));\n             }\n         } else {\n-            addPendingTimeoutTask(TimeoutController::cancelTimeout);\n+            setPendingTimeoutNanos(0);\n+            addPendingTimeoutTask(() -> unsafeClearTimeout(resetTimeout));\n+        }\n+    }\n+\n+    private boolean unsafeClearTimeout(boolean resetTimeout) {", "originalCommit": "1be0e6a0e1d4c167d348ba5bccf40caeac45bcae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2OTI3NA==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462269274", "bodyText": "Armeria commonly uses unsafe for pooled objects. But I think we can use the name - unsafe, if a method should be used with caution.\nInitially, I use xxxTimeout0. But readability was not good. Because lots of timeout methods are mixed in this class. So I wanted to easily distinguish with other safe methods.", "author": "ikhoon", "createdAt": "2020-07-29T12:45:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwMTc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI3NzczMw==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462277733", "bodyText": "Then, what unsafe means here? I hardly figure out what the word is for. \ud83e\udd14", "author": "minwoox", "createdAt": "2020-07-29T12:58:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwMTc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY3OTc1MQ==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462679751", "bodyText": "I intended that the method is not thread safe. Should be called in an event loop. If unsafe makes you confused, let me remove the word from the method name. \ud83d\ude09", "author": "ikhoon", "createdAt": "2020-07-30T01:25:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwMTc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwNjgzMQ==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462106831", "bodyText": "Question: Do we need to check if initialized is set in this loop and act differently?", "author": "minwoox", "createdAt": "2020-07-29T07:51:07Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -97,93 +216,248 @@ private void extendTimeoutNanos(long adjustmentNanos) {\n             return;\n         }\n \n-        final long oldTimeoutNanos = timeoutNanos;\n-        timeoutNanos = LongMath.saturatedAdd(oldTimeoutNanos, adjustmentNanos);\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.extendTimeoutNanos(adjustmentNanos);\n+                unsafeExtendTimeoutNanos(adjustmentNanos);\n             } else {\n-                eventLoop.execute(() -> timeoutController.extendTimeoutNanos(adjustmentNanos));\n+                eventLoop.execute(() -> unsafeExtendTimeoutNanos(adjustmentNanos));\n             }\n         } else {\n-            addPendingTimeoutTask(controller -> controller.extendTimeoutNanos(adjustmentNanos));\n+            addPendingTimeoutNanos(adjustmentNanos);\n+            addPendingTimeoutTask(() -> unsafeExtendTimeoutNanos(adjustmentNanos));\n         }\n     }\n \n-    private void setTimeoutAfterNanos(long timeoutNanos) {\n+    private boolean unsafeExtendTimeoutNanos(long adjustmentNanos) {\n+        ensureInitialized();\n+        if (state != State.SCHEDULED || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n+        if (adjustmentNanos == 0) {\n+            return true;\n+        }\n+\n+        final long timeoutNanos = this.timeoutNanos;\n+        // Cancel the previously scheduled timeout, if exists.\n+        unsafeClearTimeout(true);\n+\n+        this.timeoutNanos = LongMath.saturatedAdd(timeoutNanos, adjustmentNanos);\n+\n+        if (timeoutNanos <= 0) {\n+            invokeTimeoutTask();\n+            return true;\n+        }\n+\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, this.timeoutNanos, TimeUnit.NANOSECONDS);\n+        return true;\n+    }\n+\n+    private void setTimeoutNanosFromNow(long timeoutNanos) {\n         checkArgument(timeoutNanos > 0, \"timeoutNanos: %s (expected: > 0)\", timeoutNanos);\n \n-        long passedTimeNanos = 0;\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n-            final Long startTimeNanos = timeoutController.startTimeNanos();\n-            if (startTimeNanos != null) {\n-                passedTimeNanos = System.nanoTime() - startTimeNanos;\n-            }\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.resetTimeoutNanos(timeoutNanos);\n+                unsafeSetTimeoutNanosFromNow(timeoutNanos);\n             } else {\n-                eventLoop.execute(() -> timeoutController.resetTimeoutNanos(timeoutNanos));\n+                eventLoop.execute(() -> unsafeSetTimeoutNanosFromNow(timeoutNanos));\n             }\n         } else {\n             final long startTimeNanos = System.nanoTime();\n-            addPendingTimeoutTask(controller -> {\n+            setPendingTimeoutNanos(timeoutNanos);\n+            addPendingTimeoutTask(() -> {\n                 final long passedTimeNanos0 = System.nanoTime() - startTimeNanos;\n                 final long timeoutNanos0 = Math.max(1, timeoutNanos - passedTimeNanos0);\n-                controller.resetTimeoutNanos(timeoutNanos0);\n+                unsafeSetTimeoutNanosFromNow(timeoutNanos0);\n             });\n         }\n+    }\n+\n+    private boolean unsafeSetTimeoutNanosFromNow(long newTimeoutNanos) {\n+        ensureInitialized();\n+        if (state == State.TIMED_OUT || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n+        // Cancel the previously scheduled timeout, if exists.\n+        unsafeClearTimeout(true);\n+\n+        final long passedTimeNanos = System.nanoTime() - firstExecutionTimeNanos;\n+        timeoutNanos = LongMath.saturatedAdd(newTimeoutNanos, passedTimeNanos);\n+\n+        if (newTimeoutNanos <= 0) {\n+            return true;\n+        }\n \n-        this.timeoutNanos = LongMath.saturatedAdd(passedTimeNanos, timeoutNanos);\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutNanos, TimeUnit.NANOSECONDS);\n+        return true;\n     }\n \n     public void timeoutNow() {\n-        final TimeoutController timeoutController = this.timeoutController;\n-        if (timeoutController != null) {\n+        if (initialized) {\n             if (eventLoop.inEventLoop()) {\n-                timeoutController.timeoutNow();\n+                unsafeTimeoutNow();\n             } else {\n-                eventLoop.execute(timeoutController::timeoutNow);\n+                eventLoop.execute(this::unsafeTimeoutNow);\n             }\n         } else {\n-            addPendingTimeoutTask(TimeoutController::timeoutNow);\n+            addPendingTimeoutTask(this::unsafeTimeoutNow);\n         }\n     }\n \n-    public boolean isTimedOut() {\n-        if (timeoutController == null) {\n-            return false;\n+    private void unsafeTimeoutNow() {\n+        checkState(timeoutTask != null,\n+                   \"init(eventLoop, timeoutTask) is not called yet.\");\n+\n+        if (!timeoutTask.canSchedule()) {\n+            return;\n+        }\n+\n+        switch (state) {\n+            case TIMED_OUT:\n+                return;\n+            case INIT:\n+            case INACTIVE:\n+                invokeTimeoutTask();\n+                return;\n+            case SCHEDULED:\n+                if (unsafeClearTimeout(false)) {\n+                    invokeTimeoutTask();\n+                }\n+                return;\n+            default:\n+                throw new Error(); // Should not reach here.\n         }\n-        return timeoutController.isTimedOut();\n     }\n \n-    public void setTimeoutController(TimeoutController timeoutController, EventLoop eventLoop) {\n-        requireNonNull(timeoutController, \"timeoutController\");\n-        requireNonNull(eventLoop, \"eventLoop\");\n-        checkState(this.timeoutController == null, \"timeoutController is set already.\");\n-        this.timeoutController = timeoutController;\n-        this.eventLoop = eventLoop;\n+    private void addPendingTimeoutTask(Runnable pendingTimeoutTask) {\n+        if (!pendingTimeoutTaskUpdater.compareAndSet(this, null, pendingTimeoutTask)) {\n+            for (;;) {\n+                final Runnable pendingTask = this.pendingTimeoutTask;", "originalCommit": "1be0e6a0e1d4c167d348ba5bccf40caeac45bcae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2MTQ2Mg==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462261462", "bodyText": "That's a good question. Let me check the initialized flag and execute pendingTimeoutTask with the eventLoop immediately.", "author": "ikhoon", "createdAt": "2020-07-29T12:31:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwNjgzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjExNDA4NA==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462114084", "bodyText": "Could you explain why we don't need this condition please?", "author": "minwoox", "createdAt": "2020-07-29T08:03:53Z", "path": "core/src/main/java/com/linecorp/armeria/server/HttpResponseSubscriber.java", "diffHunk": "@@ -414,15 +408,8 @@ public boolean canSchedule() {\n \n             @Override\n             public void run() {\n-                if (state != State.DONE) {", "originalCommit": "1be0e6a0e1d4c167d348ba5bccf40caeac45bcae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1ODY0OA==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462258648", "bodyText": "Because canSchedule() checks the condition already.\nTimeoutScheduler.invokeTimeoutTask() checks the returned value of canSchedule() before executing a timeout task.", "author": "ikhoon", "createdAt": "2020-07-29T12:26:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjExNDA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2MDA3MQ==", "url": "https://github.com/line/armeria/pull/2939#discussion_r462260071", "bodyText": "Then maybe better adding some assertion and comments?", "author": "trustin", "createdAt": "2020-07-29T12:28:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjExNDA4NA=="}], "type": "inlineReview"}, {"oid": "cb7c611512e8b059fb1a78be97ab75780d1e1db2", "url": "https://github.com/line/armeria/commit/cb7c611512e8b059fb1a78be97ab75780d1e1db2", "message": "Addres comments by @minwoox", "committedDate": "2020-07-29T13:13:35Z", "type": "commit"}, {"oid": "d7bc65991ff6dcadf903650d85df0f6c30336c8c", "url": "https://github.com/line/armeria/commit/d7bc65991ff6dcadf903650d85df0f6c30336c8c", "message": "Remove 'unsafe' and append '0'", "committedDate": "2020-07-30T02:32:24Z", "type": "commit"}, {"oid": "d05053564087db2255ec6dc94d48f01f76e8ddeb", "url": "https://github.com/line/armeria/commit/d05053564087db2255ec6dc94d48f01f76e8ddeb", "message": "Add more test for pendingTimeout", "committedDate": "2020-07-31T03:35:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwNDkyMw==", "url": "https://github.com/line/armeria/pull/2939#discussion_r463404923", "bodyText": "how about breaking the loop if pendingTimeoutTask is null before doing CAS?", "author": "minwoox", "createdAt": "2020-07-31T04:57:17Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -17,173 +17,465 @@\n package com.linecorp.armeria.internal.common;\n \n import static com.google.common.base.Preconditions.checkArgument;\n-import static com.google.common.base.Preconditions.checkState;\n-import static java.util.Objects.requireNonNull;\n \n-import java.util.function.Consumer;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n import javax.annotation.Nullable;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.math.LongMath;\n \n import com.linecorp.armeria.common.util.TimeoutMode;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n \n-import io.netty.channel.EventLoop;\n+import io.netty.util.concurrent.EventExecutor;\n \n public final class TimeoutScheduler {\n \n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, TimeoutFuture>\n+            whenTimingOutUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, TimeoutFuture.class, \"whenTimingOut\");\n+\n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, TimeoutFuture>\n+            whenTimedOutUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, TimeoutFuture.class, \"whenTimedOut\");\n+\n+    private static final AtomicReferenceFieldUpdater<TimeoutScheduler, Runnable>\n+            pendingTimeoutTaskUpdater = AtomicReferenceFieldUpdater.newUpdater(\n+            TimeoutScheduler.class, Runnable.class, \"pendingTimeoutTask\");\n+\n+    private static final AtomicLongFieldUpdater<TimeoutScheduler> pendingTimeoutNanosUpdater =\n+            AtomicLongFieldUpdater.newUpdater(TimeoutScheduler.class, \"pendingTimeoutNanos\");\n+\n+    private static final TimeoutFuture COMPLETED_FUTURE;\n+\n+    static {\n+        COMPLETED_FUTURE = new TimeoutFuture();\n+        COMPLETED_FUTURE.doComplete();\n+    }\n+\n+    enum State {\n+        INIT,\n+        INACTIVE,\n+        SCHEDULED,\n+        TIMED_OUT\n+    }\n+\n     private long timeoutNanos;\n+    private long firstExecutionTimeNanos;\n+\n+    private State state = State.INIT;\n+\n+    @Nullable\n+    private TimeoutTask timeoutTask;\n     @Nullable\n-    private Consumer<TimeoutController> pendingTimeoutTask;\n+    private ScheduledFuture<?> timeoutFuture;\n     @Nullable\n-    private EventLoop eventLoop;\n+    private EventExecutor eventLoop;\n+\n+    // Updated via whenTimingOutUpdater\n+    @Nullable\n+    private volatile TimeoutFuture whenTimingOut;\n+    // Updated via whenTimedOutUpdater\n     @Nullable\n-    private TimeoutController timeoutController;\n+    private volatile TimeoutFuture whenTimedOut;\n+    // Updated via pendingTimeoutTaskUpdater\n+    @Nullable\n+    private volatile Runnable pendingTimeoutTask;\n+    // Updated via pendingTimeoutNanosUpdater\n+    @SuppressWarnings(\"FieldMayBeFinal\")\n+    private volatile long pendingTimeoutNanos;\n+\n+    private volatile boolean initialized;\n \n     public TimeoutScheduler(long timeoutNanos) {\n         this.timeoutNanos = timeoutNanos;\n+        pendingTimeoutNanos = timeoutNanos;\n+    }\n+\n+    /**\n+     * Initializes this {@link TimeoutScheduler}.\n+     */\n+    public void init(EventExecutor eventLoop, TimeoutTask timeoutTask, long initialTimeoutNanos) {\n+        if (!eventLoop.inEventLoop()) {\n+            eventLoop.execute(() -> init(eventLoop, timeoutTask, initialTimeoutNanos));\n+            return;\n+        }\n+\n+        this.eventLoop = eventLoop;\n+        this.timeoutTask = timeoutTask;\n+        if (initialTimeoutNanos > 0) {\n+            timeoutNanos = initialTimeoutNanos;\n+        }\n+\n+        firstExecutionTimeNanos = System.nanoTime();\n+\n+        if (timeoutNanos != 0) {\n+            state = State.SCHEDULED;\n+            timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutNanos, TimeUnit.NANOSECONDS);\n+        } else {\n+            state = State.INACTIVE;\n+        }\n+\n+        Runnable pendingTimeoutTask;\n+        for (;;) {\n+            pendingTimeoutTask = this.pendingTimeoutTask;", "originalCommit": "d05053564087db2255ec6dc94d48f01f76e8ddeb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d0bcc1dc1aa4bf5e50eb3aae154c01f94a034706", "url": "https://github.com/line/armeria/commit/d0bcc1dc1aa4bf5e50eb3aae154c01f94a034706", "message": "Address comments by @minwoox", "committedDate": "2020-07-31T06:50:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ0MDI2OA==", "url": "https://github.com/line/armeria/pull/2939#discussion_r463440268", "bodyText": "isInitialized() ?", "author": "trustin", "createdAt": "2020-07-31T07:03:34Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/TimeoutScheduler.java", "diffHunk": "@@ -410,7 +405,11 @@ public boolean isTimedOut() {\n     }\n \n     public long timeoutNanos() {\n-        return initialized ? timeoutNanos : pendingTimeoutNanos;\n+        return initialized() ? timeoutNanos : pendingTimeoutNanos;\n+    }\n+\n+    private boolean initialized() {", "originalCommit": "d0bcc1dc1aa4bf5e50eb3aae154c01f94a034706", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ0MTM4Ng==", "url": "https://github.com/line/armeria/pull/2939#discussion_r463441386", "bodyText": "Fixed \ud83d\ude09", "author": "ikhoon", "createdAt": "2020-07-31T07:06:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ0MDI2OA=="}], "type": "inlineReview"}, {"oid": "3555fca59ba63c76c218e9ec14a9e6958d408ca1", "url": "https://github.com/line/armeria/commit/3555fca59ba63c76c218e9ec14a9e6958d408ca1", "message": "Rename to isInitialized", "committedDate": "2020-07-31T07:06:00Z", "type": "commit"}]}