{"pr_number": 2705, "pr_title": "Handle h1c retry failure correctly for proxy requests", "pr_createdAt": "2020-05-12T16:25:24Z", "pr_url": "https://github.com/line/armeria/pull/2705", "timeline": [{"oid": "8451cc3f055c6a589fd853113eb2be75cd33b0ec", "url": "https://github.com/line/armeria/commit/8451cc3f055c6a589fd853113eb2be75cd33b0ec", "message": "add a failing case", "committedDate": "2020-05-12T16:01:58Z", "type": "commit"}, {"oid": "17248a9653a8b1c466f5836af0b84b05e1ffe0fe", "url": "https://github.com/line/armeria/commit/17248a9653a8b1c466f5836af0b84b05e1ffe0fe", "message": "very naive fix", "committedDate": "2020-05-12T16:19:10Z", "type": "commit"}, {"oid": "c8a96fd14c00b536d85b2c24e13556f2662babae", "url": "https://github.com/line/armeria/commit/c8a96fd14c00b536d85b2c24e13556f2662babae", "message": "separate test for preface and upgrade\n\nrename to proxyDestinationAddress", "committedDate": "2020-05-13T11:54:38Z", "type": "commit"}, {"oid": "b3c909a76830b14eb0fd56a818ec084bf622b9e8", "url": "https://github.com/line/armeria/commit/b3c909a76830b14eb0fd56a818ec084bf622b9e8", "message": "checkstyle newline, nullable annotation, consistent casting", "committedDate": "2020-05-13T14:54:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgyMTc0OA==", "url": "https://github.com/line/armeria/pull/2705#discussion_r424821748", "bodyText": "This needs to be cleaned up.", "author": "trustin", "createdAt": "2020-05-14T01:32:38Z", "path": "core/src/test/java/com/linecorp/armeria/client/proxy/ProxyClientIntegrationTest.java", "diffHunk": "@@ -218,6 +241,75 @@ void testHttpProxyBasicCase() throws Exception {\n         assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);\n     }\n \n+    @Test\n+    void testHttpProxyUpgradeRequestFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (\"h2c\".equals(request.headers().get(HttpHeaderNames.UPGRADE))) {\n+                // reject http2 upgrade requests\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER,\n+                                                       headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(\"success\", US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address()))\n+                             .useHttp2Preface(false).build();", "originalCommit": "b3c909a76830b14eb0fd56a818ec084bf622b9e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgyMTgxNw==", "url": "https://github.com/line/armeria/pull/2705#discussion_r424821817", "bodyText": "Ditto - needs cleanup", "author": "trustin", "createdAt": "2020-05-14T01:32:52Z", "path": "core/src/test/java/com/linecorp/armeria/client/proxy/ProxyClientIntegrationTest.java", "diffHunk": "@@ -218,6 +241,75 @@ void testHttpProxyBasicCase() throws Exception {\n         assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);\n     }\n \n+    @Test\n+    void testHttpProxyUpgradeRequestFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (\"h2c\".equals(request.headers().get(HttpHeaderNames.UPGRADE))) {\n+                // reject http2 upgrade requests\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER,\n+                                                       headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(\"success\", US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address()))\n+                             .useHttp2Preface(false).build();\n+        final WebClient webClient = WebClient.builder(SessionProtocol.HTTP, http1Server.endpoint())\n+                                             .factory(clientFactory)\n+                                             .decorator(LoggingClient.newDecorator())\n+                                             .build();\n+        final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                webClient.get(PROXY_PATH).aggregate();\n+        final AggregatedHttpResponse response = responseFuture.join();\n+        assertThat(response.status()).isEqualByComparingTo(OK);\n+        assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);\n+    }\n+\n+    @Test\n+    void testHttpProxyPrefaceFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (HttpMethod.valueOf(\"PRI\").equals(request.method())) {\n+                // reject http2 preface\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(\n+                        HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER, headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(\"success\", US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address())).build();", "originalCommit": "b3c909a76830b14eb0fd56a818ec084bf622b9e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1OTAzMg==", "url": "https://github.com/line/armeria/pull/2705#discussion_r424859032", "bodyText": "Could use try-with-resources?", "author": "trustin", "createdAt": "2020-05-14T04:06:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgyMTgxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2MDQ5NA==", "url": "https://github.com/line/armeria/pull/2705#discussion_r424860494", "bodyText": "Never mind. All other test methods seem not to use it anyway.", "author": "trustin", "createdAt": "2020-05-14T04:12:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgyMTgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgyMjE3NA==", "url": "https://github.com/line/armeria/pull/2705#discussion_r424822174", "bodyText": "Could we also check if the client retried a CONNECT request, instead of GET? For example, you could send a response content that contains the request method instead of success above.", "author": "trustin", "createdAt": "2020-05-14T01:34:33Z", "path": "core/src/test/java/com/linecorp/armeria/client/proxy/ProxyClientIntegrationTest.java", "diffHunk": "@@ -218,6 +241,75 @@ void testHttpProxyBasicCase() throws Exception {\n         assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);\n     }\n \n+    @Test\n+    void testHttpProxyUpgradeRequestFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (\"h2c\".equals(request.headers().get(HttpHeaderNames.UPGRADE))) {\n+                // reject http2 upgrade requests\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER,\n+                                                       headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(\"success\", US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address()))\n+                             .useHttp2Preface(false).build();\n+        final WebClient webClient = WebClient.builder(SessionProtocol.HTTP, http1Server.endpoint())\n+                                             .factory(clientFactory)\n+                                             .decorator(LoggingClient.newDecorator())\n+                                             .build();\n+        final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                webClient.get(PROXY_PATH).aggregate();\n+        final AggregatedHttpResponse response = responseFuture.join();\n+        assertThat(response.status()).isEqualByComparingTo(OK);\n+        assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);", "originalCommit": "b3c909a76830b14eb0fd56a818ec084bf622b9e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgzODUwOA==", "url": "https://github.com/line/armeria/pull/2705#discussion_r424838508", "bodyText": "I've changed the test so that it returns the requested method which is GET.\nThis check should ensure CONNECT requests were not made directly to the backend server.\nI'm still brainstorming ways where we can ensure CONNECT was retried as you said.", "author": "jrhee17", "createdAt": "2020-05-14T02:39:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgyMjE3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg0MzU5NA==", "url": "https://github.com/line/armeria/pull/2705#discussion_r424843594", "bodyText": "Decided to go with the \"easy route\" and just add a counter for the number of successful proxy requests.", "author": "jrhee17", "createdAt": "2020-05-14T02:59:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgyMjE3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgyMjMwMg==", "url": "https://github.com/line/armeria/pull/2705#discussion_r424822302", "bodyText": "Ditto - needs to ensure CONNECT request was sent", "author": "trustin", "createdAt": "2020-05-14T01:34:56Z", "path": "core/src/test/java/com/linecorp/armeria/client/proxy/ProxyClientIntegrationTest.java", "diffHunk": "@@ -218,6 +241,75 @@ void testHttpProxyBasicCase() throws Exception {\n         assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);\n     }\n \n+    @Test\n+    void testHttpProxyUpgradeRequestFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (\"h2c\".equals(request.headers().get(HttpHeaderNames.UPGRADE))) {\n+                // reject http2 upgrade requests\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER,\n+                                                       headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(\"success\", US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address()))\n+                             .useHttp2Preface(false).build();\n+        final WebClient webClient = WebClient.builder(SessionProtocol.HTTP, http1Server.endpoint())\n+                                             .factory(clientFactory)\n+                                             .decorator(LoggingClient.newDecorator())\n+                                             .build();\n+        final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                webClient.get(PROXY_PATH).aggregate();\n+        final AggregatedHttpResponse response = responseFuture.join();\n+        assertThat(response.status()).isEqualByComparingTo(OK);\n+        assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);\n+    }\n+\n+    @Test\n+    void testHttpProxyPrefaceFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (HttpMethod.valueOf(\"PRI\").equals(request.method())) {\n+                // reject http2 preface\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(\n+                        HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER, headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(\"success\", US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address())).build();\n+        final WebClient webClient = WebClient.builder(SessionProtocol.HTTP, http1Server.endpoint())\n+                                             .factory(clientFactory)\n+                                             .decorator(LoggingClient.newDecorator())\n+                                             .build();\n+        final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                webClient.get(PROXY_PATH).aggregate();\n+        final AggregatedHttpResponse response = responseFuture.join();\n+        assertThat(response.status()).isEqualByComparingTo(OK);\n+        assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);", "originalCommit": "b3c909a76830b14eb0fd56a818ec084bf622b9e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5c83096f9b4b574d8b37d492369e359ba2b44130", "url": "https://github.com/line/armeria/commit/5c83096f9b4b574d8b37d492369e359ba2b44130", "message": "clean up clientFactories in test, more detailed test", "committedDate": "2020-05-14T02:35:30Z", "type": "commit"}, {"oid": "5c83096f9b4b574d8b37d492369e359ba2b44130", "url": "https://github.com/line/armeria/commit/5c83096f9b4b574d8b37d492369e359ba2b44130", "message": "clean up clientFactories in test, more detailed test", "committedDate": "2020-05-14T02:35:30Z", "type": "forcePushed"}, {"oid": "be10aed4312a2ccdae272a0b3434d773c607340e", "url": "https://github.com/line/armeria/commit/be10aed4312a2ccdae272a0b3434d773c607340e", "message": "test also check number of successful proxy requests", "committedDate": "2020-05-14T02:58:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1ODYwMg==", "url": "https://github.com/line/armeria/pull/2705#discussion_r424858602", "bodyText": "This needs Javadoc.", "author": "trustin", "createdAt": "2020-05-14T04:04:23Z", "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/NettyServerExtension.java", "diffHunk": "@@ -50,6 +51,10 @@ public final InetSocketAddress address() {\n         return (InetSocketAddress) channel.localAddress();\n     }\n \n+    public final Endpoint endpoint() {", "originalCommit": "be10aed4312a2ccdae272a0b3434d773c607340e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1OTcxNg==", "url": "https://github.com/line/armeria/pull/2705#discussion_r424859716", "bodyText": "Never mind - it's an internal class.", "author": "trustin", "createdAt": "2020-05-14T04:09:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1ODYwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1OTExOQ==", "url": "https://github.com/line/armeria/pull/2705#discussion_r424859119", "bodyText": "isEqualTo() ?", "author": "trustin", "createdAt": "2020-05-14T04:07:03Z", "path": "core/src/test/java/com/linecorp/armeria/client/proxy/ProxyClientIntegrationTest.java", "diffHunk": "@@ -216,6 +248,81 @@ void testHttpProxyBasicCase() throws Exception {\n         final AggregatedHttpResponse response = responseFuture.join();\n         assertThat(response.status()).isEqualByComparingTo(OK);\n         assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);\n+        assertThat(numSuccessfulProxyRequests).isEqualTo(1);\n+        clientFactory.close();\n+    }\n+\n+    @Test\n+    void testHttpProxyUpgradeRequestFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (\"h2c\".equals(request.headers().get(HttpHeaderNames.UPGRADE))) {\n+                // reject http2 upgrade requests\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER,\n+                                                       headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(request.method().name(), US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address()))\n+                             .useHttp2Preface(false).build();\n+        final WebClient webClient = WebClient.builder(SessionProtocol.HTTP, http1Server.endpoint())\n+                                             .factory(clientFactory)\n+                                             .decorator(LoggingClient.newDecorator())\n+                                             .build();\n+        final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                webClient.get(PROXY_PATH).aggregate();\n+        final AggregatedHttpResponse response = responseFuture.join();\n+        assertThat(response.status()).isEqualByComparingTo(OK);\n+        assertThat(response.contentUtf8()).isEqualTo(GET.name());\n+        assertThat(numSuccessfulProxyRequests).isEqualTo(2);\n+        clientFactory.close();\n+    }\n+\n+    @Test\n+    void testHttpProxyPrefaceFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (HttpMethod.valueOf(\"PRI\").equals(request.method())) {\n+                // reject http2 preface\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(\n+                        HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER, headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(request.method().name(), US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address())).build();\n+        final WebClient webClient = WebClient.builder(SessionProtocol.HTTP, http1Server.endpoint())\n+                                             .factory(clientFactory)\n+                                             .decorator(LoggingClient.newDecorator())\n+                                             .build();\n+        final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                webClient.get(PROXY_PATH).aggregate();\n+        final AggregatedHttpResponse response = responseFuture.join();\n+        assertThat(response.status()).isEqualByComparingTo(OK);", "originalCommit": "be10aed4312a2ccdae272a0b3434d773c607340e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1OTM5MA==", "url": "https://github.com/line/armeria/pull/2705#discussion_r424859390", "bodyText": "isEqualTo() will do.", "author": "trustin", "createdAt": "2020-05-14T04:07:59Z", "path": "core/src/test/java/com/linecorp/armeria/client/proxy/ProxyClientIntegrationTest.java", "diffHunk": "@@ -216,6 +248,81 @@ void testHttpProxyBasicCase() throws Exception {\n         final AggregatedHttpResponse response = responseFuture.join();\n         assertThat(response.status()).isEqualByComparingTo(OK);\n         assertThat(response.contentUtf8()).isEqualTo(SUCCESS_RESPONSE);\n+        assertThat(numSuccessfulProxyRequests).isEqualTo(1);\n+        clientFactory.close();\n+    }\n+\n+    @Test\n+    void testHttpProxyUpgradeRequestFailure() throws Exception {\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (!(msg instanceof FullHttpRequest)) {\n+                ctx.close();\n+            }\n+            final HttpRequest request = (HttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (\"h2c\".equals(request.headers().get(HttpHeaderNames.UPGRADE))) {\n+                // reject http2 upgrade requests\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(HTTP_1_1, NOT_IMPLEMENTED, EMPTY_BUFFER,\n+                                                       headers, EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.OK,\n+                                                       copiedBuffer(request.method().name(), US_ASCII));\n+            }\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder().proxyConfig(ProxyConfig.connect(httpProxyServer.address()))\n+                             .useHttp2Preface(false).build();\n+        final WebClient webClient = WebClient.builder(SessionProtocol.HTTP, http1Server.endpoint())\n+                                             .factory(clientFactory)\n+                                             .decorator(LoggingClient.newDecorator())\n+                                             .build();\n+        final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                webClient.get(PROXY_PATH).aggregate();\n+        final AggregatedHttpResponse response = responseFuture.join();\n+        assertThat(response.status()).isEqualByComparingTo(OK);", "originalCommit": "be10aed4312a2ccdae272a0b3434d773c607340e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "97dadca54e6eb1ebcfbc401f907bd704695487bf", "url": "https://github.com/line/armeria/commit/97dadca54e6eb1ebcfbc401f907bd704695487bf", "message": "Update ProxyClientIntegrationTest.java", "committedDate": "2020-05-14T04:11:03Z", "type": "commit"}]}