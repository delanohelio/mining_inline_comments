{"pr_number": 2845, "pr_title": "Asynchronous metadata access in `HttpFile` and `FileService`", "pr_createdAt": "2020-06-26T08:22:23Z", "pr_url": "https://github.com/line/armeria/pull/2845", "timeline": [{"oid": "c2a93cd29e37a30086952fdf5a7f799d1a10b3ce", "url": "https://github.com/line/armeria/commit/c2a93cd29e37a30086952fdf5a7f799d1a10b3ce", "message": "Asynchronous metadata access in `HttpFile` and `FileService`\n\nMotivation:\n\nReading a file metadata is not always a cheap operation and thus may\nblock. Classpath resources are even more vulnerable to metadata access\nbecause a `ClassLoader` may acquire a lock while reading the file\nmetadata from a JAR file.\n\nModifications:\n\n- Change the signatures of some methods in `HttpFile` and `HttpVfs` so\n  that metadata access can be done asynchronously.\n- Add `HttpFile.from(CompletionStage)` for easier asynchronous\n  composition.\n- Add non-blocking access methods to `AggregatedHttpFile` for potential\n  optimization in the future.\n- Add `AbstractBlockingHttpVfs` and make `{FileSystem,ClassPath}HttpVfs`\n  extend it.\n\nResult:\n\n- Fixes #1668\n- (Breaking) The API of `HttpFile` and `HttpVfs` have been changed.", "committedDate": "2020-06-26T08:15:44Z", "type": "commit"}, {"oid": "678a5a301dee43815b28bdb6ff03abb2785dd031", "url": "https://github.com/line/armeria/commit/678a5a301dee43815b28bdb6ff03abb2785dd031", "message": "Merge branch 'master' into fix_file_metadata_access", "committedDate": "2020-06-26T10:16:02Z", "type": "commit"}, {"oid": "f748dfddb39122b54945167622d94888de2bbca2", "url": "https://github.com/line/armeria/commit/f748dfddb39122b54945167622d94888de2bbca2", "message": "Merge branch 'master' into fix_file_metadata_access", "committedDate": "2020-06-30T01:55:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1NjUzNQ==", "url": "https://github.com/line/armeria/pull/2845#discussion_r446056535", "bodyText": "Thanks!", "author": "minwoox", "createdAt": "2020-06-26T08:54:23Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/DeferredStreamMessage.java", "diffHunk": "@@ -66,7 +66,7 @@\n             DeferredStreamMessage.class, Throwable.class, \"abortCause\");\n \n     @Nullable\n-    @SuppressWarnings(\"unused\") // Updated only via delegateUpdater\n+    @SuppressWarnings(\"unused\") // Updated only via upstreamUpdater", "originalCommit": "c2a93cd29e37a30086952fdf5a7f799d1a10b3ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2MDg5Mw==", "url": "https://github.com/line/armeria/pull/2845#discussion_r447360893", "bodyText": "nit: rnn for path and fileReadExecutor?", "author": "minwoox", "createdAt": "2020-06-30T01:53:22Z", "path": "core/src/main/java/com/linecorp/armeria/server/file/AbstractBlockingHttpVfs.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.file;\n+\n+import java.time.Clock;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.HttpHeaders;\n+\n+/**\n+ * A skeletal {@link HttpVfs} implementation for accessing file system with blocking I/O.\n+ * All its operations are executed in the given {@code fileReadExecutor} via the blocking I/O methods,\n+ * such as {@link #blockingGet(Executor, String, Clock, String, HttpHeaders)}.\n+ */\n+public abstract class AbstractBlockingHttpVfs extends AbstractHttpVfs {\n+\n+    private final boolean directoryListingSupported;\n+\n+    /**\n+     * Creates a new instance.\n+     *\n+     * @param directoryListingSupported whether this {@link HttpVfs} supports directory listing.\n+     *                                  If {@code false}, {@link #blockingCanList(Executor, String)} and\n+     *                                  {@link #blockingList(Executor, String)} will never be invoked.\n+     */\n+    protected AbstractBlockingHttpVfs(boolean directoryListingSupported) {\n+        this.directoryListingSupported = directoryListingSupported;\n+    }\n+\n+    /**\n+     * {@inheritDoc} This method invokes {@link #blockingGet(Executor, String, Clock, String, HttpHeaders)}\n+     * from the specified {@code fileReadExecutor}.\n+     */\n+    @Override\n+    public final HttpFile get(\n+            Executor fileReadExecutor, String path, Clock clock,\n+            @Nullable String contentEncoding, HttpHeaders additionalHeaders) {\n+\n+        return HttpFile.from(CompletableFuture.supplyAsync(\n+                () -> blockingGet(fileReadExecutor, path, clock, contentEncoding, additionalHeaders),\n+                fileReadExecutor));\n+    }\n+\n+    /**\n+     * Finds the file at the specified {@code path}.\n+     *\n+     * @param fileReadExecutor the {@link Executor} which will perform the read operations against the file\n+     * @param path an absolute path that starts with {@code '/'}, whose component separator is {@code '/'}\n+     * @param clock the {@link Clock} which provides the current date and time\n+     * @param contentEncoding the desired {@code 'content-encoding'} header value of the file.\n+     *                        {@code null} to omit the header.\n+     * @param additionalHeaders the additional HTTP headers to add to the returned {@link HttpFile}.\n+     *\n+     * @return the {@link HttpFile} at the specified {@code path}\n+     */\n+    protected abstract HttpFile blockingGet(Executor fileReadExecutor, String path, Clock clock,\n+                                            @Nullable String contentEncoding, HttpHeaders additionalHeaders);\n+\n+    /**\n+     * {@inheritDoc} This method invokes {@link #blockingCanList(Executor, String)} from the specified\n+     * {@code fileReadExecutor}.\n+     */\n+    @Override\n+    public final CompletableFuture<Boolean> canList(Executor fileReadExecutor, String path) {\n+        if (directoryListingSupported) {\n+            return CompletableFuture.supplyAsync(() -> blockingCanList(fileReadExecutor, path),\n+                                                 fileReadExecutor);\n+        } else {\n+            return super.canList(fileReadExecutor, path);\n+        }\n+    }\n+\n+    /**\n+     * Returns whether the file at the specified {@code path} is a listable directory. This method returns\n+     * {@code false} by default.\n+     *\n+     * @param fileReadExecutor the {@link Executor} which will perform the read operations against the file\n+     * @param path an absolute path that starts with {@code '/'}, whose component separator is {@code '/'}\n+     * @return {@code true} if the file is a listable directory. {@code false} if the directory does not exist\n+     *         or the file listing is not available.\n+     */\n+    protected boolean blockingCanList(Executor fileReadExecutor, String path) {\n+        return false;\n+    }\n+\n+    /**\n+     * {@inheritDoc} This method invokes {@link #blockingList(Executor, String)} from the specified\n+     * {@code fileReadExecutor}.\n+     */\n+    @Override\n+    public final CompletableFuture<List<String>> list(Executor fileReadExecutor, String path) {\n+        if (directoryListingSupported) {\n+            return CompletableFuture.supplyAsync(() -> blockingList(fileReadExecutor, path),\n+                                                 fileReadExecutor);", "originalCommit": "678a5a301dee43815b28bdb6ff03abb2785dd031", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM3NzA0Mg==", "url": "https://github.com/line/armeria/pull/2845#discussion_r447377042", "bodyText": "Added rnn in various places", "author": "trustin", "createdAt": "2020-06-30T02:52:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2MDg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2MjM2MA==", "url": "https://github.com/line/armeria/pull/2845#discussion_r447362360", "bodyText": "nit: can remove super.", "author": "minwoox", "createdAt": "2020-06-30T01:58:36Z", "path": "core/src/main/java/com/linecorp/armeria/server/file/HttpDataFile.java", "diffHunk": "@@ -75,13 +75,19 @@ public HttpFileAttributes readAttributes() {\n         return attrs;\n     }\n \n+    @Override\n+    public CompletableFuture<HttpFileAttributes> readAttributes(Executor fileReadExecutor) {\n+        return AggregatedHttpFile.super.readAttributes(fileReadExecutor);\n+    }\n+\n     @Override\n     public ResponseHeaders readHeaders() {\n-        try {\n-            return super.readHeaders();\n-        } catch (IOException e) {\n-            throw new Error(e); // Never reaches here.\n-        }\n+        return super.readHeaders(attrs);", "originalCommit": "f748dfddb39122b54945167622d94888de2bbca2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2Mzc2Mg==", "url": "https://github.com/line/armeria/pull/2845#discussion_r447363762", "bodyText": "Shouldn't this be }, fileReadExecutor);?\nAnd rnn for fileReadExecutor.", "author": "minwoox", "createdAt": "2020-06-30T02:03:30Z", "path": "core/src/main/java/com/linecorp/armeria/server/file/ClassPathHttpFile.java", "diffHunk": "@@ -54,14 +57,21 @@ protected String pathOrUri() {\n     }\n \n     @Override\n-    public HttpFileAttributes readAttributes() throws IOException {\n-        if (attrs == null) {\n-            final URLConnection conn = url.openConnection();\n-            final long length = conn.getContentLengthLong();\n-            final long lastModifiedMillis = conn.getLastModified();\n-            attrs = new HttpFileAttributes(length, lastModifiedMillis);\n+    public CompletableFuture<HttpFileAttributes> readAttributes(Executor fileReadExecutor) {\n+        if (attrsFuture != null) {\n+            return attrsFuture;\n         }\n-        return attrs;\n+\n+        return attrsFuture = CompletableFuture.supplyAsync(() -> {\n+            try {\n+                final URLConnection conn = url.openConnection();\n+                final long length = conn.getContentLengthLong();\n+                final long lastModifiedMillis = conn.getLastModified();\n+                return new HttpFileAttributes(length, lastModifiedMillis);\n+            } catch (IOException e) {\n+                return Exceptions.throwUnsafely(e);\n+            }\n+        });", "originalCommit": "f748dfddb39122b54945167622d94888de2bbca2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM3NzAwMA==", "url": "https://github.com/line/armeria/pull/2845#discussion_r447377000", "bodyText": "\ud83d\ude31", "author": "trustin", "createdAt": "2020-06-30T02:52:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2Mzc2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2NjMyNg==", "url": "https://github.com/line/armeria/pull/2845#discussion_r447366326", "bodyText": "nit: can remove this.", "author": "minwoox", "createdAt": "2020-06-30T02:12:24Z", "path": "core/src/main/java/com/linecorp/armeria/server/file/DeferredHttpFile.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.file;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.MoreObjects;\n+\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.util.Exceptions;\n+import com.linecorp.armeria.server.HttpService;\n+\n+import io.netty.buffer.ByteBufAllocator;\n+\n+final class DeferredHttpFile implements HttpFile {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DeferredHttpFile.class);\n+\n+    private static boolean warnedNullDelegate;\n+\n+    private final CompletableFuture<? extends HttpFile> stage;\n+    @Nullable\n+    private volatile HttpFile delegate;\n+\n+    DeferredHttpFile(CompletionStage<? extends HttpFile> stage) {\n+        this.stage = requireNonNull(stage, \"stage\").toCompletableFuture();\n+        if (this.stage.isDone() && !this.stage.isCompletedExceptionally()) {\n+            setDelegate(this.stage.getNow(null));\n+        }\n+    }\n+\n+    @Override\n+    public CompletableFuture<HttpFileAttributes> readAttributes(Executor fileReadExecutor) {\n+        final HttpFile delegate = this.delegate;\n+        if (delegate != null) {\n+            return delegate.readAttributes(fileReadExecutor);\n+        }\n+\n+        return stage.thenCompose(file -> {\n+            setDelegate(file);\n+            return file.readAttributes(fileReadExecutor);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<ResponseHeaders> readHeaders(Executor fileReadExecutor) {\n+        final HttpFile delegate = this.delegate;\n+        if (delegate != null) {\n+            return delegate.readHeaders(fileReadExecutor);\n+        }\n+\n+        return stage.thenCompose(file -> {\n+            setDelegate(file);\n+            return file.readHeaders(fileReadExecutor);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<HttpResponse> read(Executor fileReadExecutor, ByteBufAllocator alloc) {\n+        final HttpFile delegate = this.delegate;\n+        if (delegate != null) {\n+            return delegate.read(fileReadExecutor, alloc);\n+        }\n+\n+        return stage.thenCompose(file -> {\n+            setDelegate(file);\n+            return file.read(fileReadExecutor, alloc);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<AggregatedHttpFile> aggregate(Executor fileReadExecutor) {\n+        final HttpFile delegate = this.delegate;\n+        if (delegate != null) {\n+            return delegate.aggregate(fileReadExecutor);\n+        }\n+\n+        return stage.thenCompose(file -> {\n+            setDelegate(file);\n+            return file.aggregate(fileReadExecutor);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<AggregatedHttpFile> aggregateWithPooledObjects(Executor fileReadExecutor,\n+                                                                            ByteBufAllocator alloc) {\n+        final HttpFile delegate = this.delegate;\n+        if (delegate != null) {\n+            return delegate.aggregateWithPooledObjects(fileReadExecutor, alloc);\n+        }\n+\n+        return stage.thenCompose(file -> {\n+            setDelegate(file);\n+            return file.aggregateWithPooledObjects(fileReadExecutor, alloc);\n+        });\n+    }\n+\n+    @Override\n+    public HttpService asService() {\n+        final HttpFile delegate = this.delegate;\n+        if (delegate != null) {\n+            return delegate.asService();\n+        }\n+\n+        return (ctx, req) -> HttpResponse.from(stage.thenApply(file -> {\n+            setDelegate(file);\n+            try {\n+                return file.asService().serve(ctx, req);\n+            } catch (Exception e) {\n+                return Exceptions.throwUnsafely(e);\n+            }\n+        }));\n+    }\n+\n+    private void setDelegate(@Nullable HttpFile file) {\n+        if (file == null) {\n+            if (!warnedNullDelegate) {\n+                warnedNullDelegate = true;\n+                logger.warn(\"The delegate stage produced a null file; treating as a non-existent file.\");\n+            }\n+            file = HttpFile.nonExistent();\n+        }\n+        this.delegate = file;", "originalCommit": "f748dfddb39122b54945167622d94888de2bbca2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM3Njk4MA==", "url": "https://github.com/line/armeria/pull/2845#discussion_r447376980", "bodyText": "Renamed file to delegate", "author": "trustin", "createdAt": "2020-06-30T02:51:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2NjMyNg=="}], "type": "inlineReview"}, {"oid": "55f72c9532e9c2301d71ea0140c75552170651cc", "url": "https://github.com/line/armeria/commit/55f72c9532e9c2301d71ea0140c75552170651cc", "message": "Address the comments from @minwoox / Add more requireNonNulls", "committedDate": "2020-06-30T02:51:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM5MzY4MQ==", "url": "https://github.com/line/armeria/pull/2845#discussion_r447393681", "bodyText": "Isn't this directoryListingSupported?", "author": "minwoox", "createdAt": "2020-06-30T03:56:25Z", "path": "core/src/main/java/com/linecorp/armeria/server/file/AbstractBlockingHttpVfs.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.file;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Clock;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.HttpHeaders;\n+\n+/**\n+ * A skeletal {@link HttpVfs} implementation for accessing file system with blocking I/O.\n+ * All its operations are executed in the given {@code fileReadExecutor} via the blocking I/O methods,\n+ * such as {@link #blockingGet(Executor, String, Clock, String, HttpHeaders)}.\n+ */\n+public abstract class AbstractBlockingHttpVfs extends AbstractHttpVfs {\n+\n+    private final boolean directoryListingSupported;\n+\n+    /**\n+     * Creates a new instance.\n+     *\n+     * @param directoryListingSupported whether this {@link HttpVfs} supports directory listing.\n+     *                                  If {@code false}, {@link #blockingCanList(Executor, String)} and\n+     *                                  {@link #blockingList(Executor, String)} will never be invoked.\n+     */\n+    protected AbstractBlockingHttpVfs(boolean directoryListingSupported) {\n+        this.directoryListingSupported = directoryListingSupported;\n+    }\n+\n+    /**\n+     * {@inheritDoc} This method invokes {@link #blockingGet(Executor, String, Clock, String, HttpHeaders)}\n+     * from the specified {@code fileReadExecutor}.\n+     */\n+    @Override\n+    public final HttpFile get(\n+            Executor fileReadExecutor, String path, Clock clock,\n+            @Nullable String contentEncoding, HttpHeaders additionalHeaders) {\n+\n+        requireNonNull(fileReadExecutor, \"fileReadExecutor\");\n+        requireNonNull(path, \"path\");\n+        requireNonNull(clock, \"clock\");\n+        requireNonNull(additionalHeaders, \"additionalHeaders\");\n+\n+        return HttpFile.from(CompletableFuture.supplyAsync(\n+                () -> blockingGet(fileReadExecutor, path, clock, contentEncoding, additionalHeaders),\n+                fileReadExecutor));\n+    }\n+\n+    /**\n+     * Finds the file at the specified {@code path}.\n+     *\n+     * @param fileReadExecutor the {@link Executor} which will perform the read operations against the file\n+     * @param path an absolute path that starts with {@code '/'}, whose component separator is {@code '/'}\n+     * @param clock the {@link Clock} which provides the current date and time\n+     * @param contentEncoding the desired {@code 'content-encoding'} header value of the file.\n+     *                        {@code null} to omit the header.\n+     * @param additionalHeaders the additional HTTP headers to add to the returned {@link HttpFile}.\n+     *\n+     * @return the {@link HttpFile} at the specified {@code path}\n+     */\n+    protected abstract HttpFile blockingGet(Executor fileReadExecutor, String path, Clock clock,\n+                                            @Nullable String contentEncoding, HttpHeaders additionalHeaders);\n+\n+    /**\n+     * {@inheritDoc} This method invokes {@link #blockingCanList(Executor, String)} from the specified\n+     * {@code fileReadExecutor}.\n+     */\n+    @Override\n+    public final CompletableFuture<Boolean> canList(Executor fileReadExecutor, String path) {\n+        requireNonNull(fileReadExecutor, \"fileReadExecutor\");\n+        requireNonNull(path, \"path\");\n+\n+        if (directoryListingSupported) {\n+            return CompletableFuture.supplyAsync(() -> blockingCanList(fileReadExecutor, path),\n+                                                 fileReadExecutor);\n+        } else {\n+            return super.canList(fileReadExecutor, path);\n+        }\n+    }\n+\n+    /**\n+     * Returns whether the file at the specified {@code path} is a listable directory. This method returns\n+     * {@code false} by default.\n+     *\n+     * @param fileReadExecutor the {@link Executor} which will perform the read operations against the file\n+     * @param path an absolute path that starts with {@code '/'}, whose component separator is {@code '/'}\n+     * @return {@code true} if the file is a listable directory. {@code false} if the directory does not exist\n+     *         or the file listing is not available.\n+     */\n+    protected boolean blockingCanList(Executor fileReadExecutor, String path) {\n+        return false;", "originalCommit": "55f72c9532e9c2301d71ea0140c75552170651cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQwMzA3MA==", "url": "https://github.com/line/armeria/pull/2845#discussion_r447403070", "bodyText": "It has to return true only when the path exists and it is a directory. We can't return true here because only a subclass has such information.", "author": "trustin", "createdAt": "2020-06-30T04:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM5MzY4MQ=="}], "type": "inlineReview"}]}