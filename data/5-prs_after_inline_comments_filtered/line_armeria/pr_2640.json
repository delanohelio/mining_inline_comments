{"pr_number": 2640, "pr_title": "Create properties files based on Doc Comments for Rest APIs", "pr_createdAt": "2020-03-30T14:10:25Z", "pr_url": "https://github.com/line/armeria/pull/2640", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg5MjMyNA==", "url": "https://github.com/line/armeria/pull/2640#discussion_r403892324", "bodyText": "Perhaps we should name the file in a similar manner with the version properties files, i.e. META-INF/com.linecorp.armeria.docstrings.annotated.properties", "author": "trustin", "createdAt": "2020-04-06T07:50:05Z", "path": "core/src/main/java/com/linecorp/armeria/server/annotation/processor/DocumentationProcessor.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.annotation.processor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.tools.FileObject;\n+import javax.tools.StandardLocation;\n+\n+import com.linecorp.armeria.server.annotation.Description;\n+\n+/**\n+ * Processor that creates a properties file based on the JavaDoc/KDoc description of parameters for interfaces.\n+ * This file can be later used if the {@link Description} annotation does not exist for parameters or methods.\n+ */\n+@SupportedAnnotationTypes({\n+        \"com.linecorp.armeria.server.annotation.Post\",\n+        \"com.linecorp.armeria.server.annotation.Get\",\n+        \"com.linecorp.armeria.server.annotation.Put\",\n+        \"com.linecorp.armeria.server.annotation.Delete\",\n+        \"com.linecorp.armeria.server.annotation.Head\",\n+        \"com.linecorp.armeria.server.annotation.Options\",\n+        \"com.linecorp.armeria.server.annotation.Patch\",\n+})\n+public class DocumentationProcessor extends AbstractProcessor {\n+    private final Map<String, Properties> propertiesMap = new HashMap<>();\n+\n+    @Override\n+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+        if (annotations == null || annotations.isEmpty()) {\n+            return false;\n+        }\n+        annotations.forEach(annotation -> processAnnotation(annotation, roundEnv));\n+        propertiesMap.forEach((className, properties) -> {\n+            try {\n+                writeProperties(className, properties);\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        return false;\n+    }\n+\n+    private Properties readProperties(String className) throws IOException {\n+        if (propertiesMap.containsKey(className)) {\n+            return propertiesMap.get(className);\n+        }\n+        final FileObject resource = processingEnv\n+                .getFiler()\n+                .getResource(StandardLocation.CLASS_OUTPUT,\n+                             \"\",\n+                             getFileName(className));\n+        final Properties properties = new Properties();\n+        if (resource.getLastModified() == 0L) {\n+            // returns 0 if file does not exist\n+            propertiesMap.put(className, properties);\n+            return properties;\n+        }\n+        try (Reader reader = resource.openReader(false)) {\n+            properties.load(reader);\n+            return properties;\n+        }\n+    }\n+\n+    private void writeProperties(String className, Properties properties) throws IOException {\n+        if (properties.size() == 0) {\n+            return;\n+        }\n+        final FileObject resource = processingEnv.getFiler().createResource(\n+                StandardLocation.CLASS_OUTPUT,\n+                \"\",\n+                getFileName(className));\n+        try (Writer writer = resource.openWriter()) {\n+            properties.store(writer, \"Generated list of parameter description of REST interfaces.\");\n+        }\n+    }\n+\n+    private void processAnnotation(TypeElement annotationElement, RoundEnvironment roundEnv) {\n+        roundEnv.getElementsAnnotatedWith(annotationElement)\n+                .parallelStream()\n+                .filter(element -> element.getKind() == ElementKind.METHOD)\n+                // Element is always ExecutableElement because it is a method.\n+                .forEachOrdered(element -> {\n+                    try {\n+                        processMethod((ExecutableElement) element);\n+                    } catch (IOException e) {\n+                        e.printStackTrace();\n+                    }\n+                });\n+    }\n+\n+    private void processMethod(ExecutableElement method) throws IOException {\n+        final String className = ((TypeElement) method.getEnclosingElement()).getQualifiedName().toString();\n+        final Properties properties = readProperties(className);\n+        final String docComment = processingEnv.getElementUtils().getDocComment(method);\n+        if (docComment == null || !docComment.contains(\"@param\")) {\n+            return;\n+        }\n+        final List<List<String>> lines = Arrays.stream(docComment.split(\"\\\\R\"))\n+                                               .filter(line -> !line.trim().isEmpty())\n+                                               .map(line -> Arrays.stream(line.split(\"\\\\s\"))\n+                                                                  .filter(word -> !word.trim().isEmpty())\n+                                                                  .collect(toImmutableList()))\n+                                               .collect(toImmutableList());\n+        method.getParameters().forEach(param -> {\n+            final StringBuilder stringBuilder = new StringBuilder();\n+            JavaDocParserState state = JavaDocParserState.SEARCHING;\n+            for (List<String> line : lines) {\n+                final List<String> subLine;\n+                if ((line.size() < 3 ||\n+                     !\"@param\".equals(line.get(0)) ||\n+                     !param.getSimpleName().toString().equals(line.get(1))) &&\n+                    state == JavaDocParserState.SEARCHING) {\n+                    continue;\n+                } else if (state == JavaDocParserState.IN_DESCRIPTION &&\n+                           line.size() > 0 &&\n+                           \"@param\".equals(line.get(0))) {\n+                    break;\n+                } else if (state == JavaDocParserState.SEARCHING) {\n+                    subLine = line.subList(2, line.size());\n+                    state = JavaDocParserState.IN_DESCRIPTION;\n+                } else {\n+                    subLine = line;\n+                }\n+                for (String word : subLine) {\n+                    stringBuilder.append(word);\n+                    stringBuilder.append(' ');\n+                }\n+            }\n+            setProperty(properties, method, param, stringBuilder.toString().trim());\n+        });\n+    }\n+\n+    private void setProperty(Properties properties,\n+                             ExecutableElement method,\n+                             VariableElement parameter,\n+                             String description) {\n+        final String methodName = method.getSimpleName().toString();\n+        final String parameterName = parameter.getSimpleName().toString();\n+        properties.setProperty(methodName + \".\" + parameterName, description);\n+    }\n+\n+    /**\n+     * Creates the file name used in the rest api documentation properties files.\n+     * @param className The class name used for generating the file name.\n+     * @return The used file name.\n+     */\n+    public static String getFileName(String className) {\n+        return className + \"-generated-docs.properties\";", "originalCommit": "479cc487b4dca4fdc33d57026e665421e79df011", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg5MzM2OA==", "url": "https://github.com/line/armeria/pull/2640#discussion_r403893368", "bodyText": "We could also refrain from generating multiple .properties files but appending to an existing one, so it's easier to look for when scanning them.", "author": "trustin", "createdAt": "2020-04-06T07:52:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg5MjMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ3NjAwOQ==", "url": "https://github.com/line/armeria/pull/2640#discussion_r404476009", "bodyText": "Sadly, it is not possible to use the same file. The preprocessor has multiple rounds (java and kotlin, I believe) and you can open a file only once for writing, globally...\nhttps://bugs.openjdk.java.net/browse/JDK-6501983 (evaluated as not an error...)\nBut I will change the file name", "author": "hueneburg", "createdAt": "2020-04-07T00:59:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg5MjMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ3NzQxNA==", "url": "https://github.com/line/armeria/pull/2640#discussion_r404477414", "bodyText": "Also, the getFileName method is static and public which allows you to just feed the qualified class name into this method and you have the path for the resource loader in the doc service. I think it is pretty easy to get the file name...", "author": "hueneburg", "createdAt": "2020-04-07T01:04:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg5MjMyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzOTgzNQ==", "url": "https://github.com/line/armeria/pull/2640#discussion_r404539835", "bodyText": "I think we should move this to a separate artifact - some build systems will automatically run all annotation processors on classpath but it's probably better for this to be opt-in like spring boot configuration process", "author": "anuraaga", "createdAt": "2020-04-07T05:15:27Z", "path": "core/src/main/java/com/linecorp/armeria/server/annotation/processor/DocumentationProcessor.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.annotation.processor;", "originalCommit": "897b839bc4165a615547e0b2ebb425529f994207", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMzOTIwNg==", "url": "https://github.com/line/armeria/pull/2640#discussion_r407339206", "bodyText": "+1 - Let me wait for a follow-up commit.", "author": "trustin", "createdAt": "2020-04-13T06:28:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzOTgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY3NTg4OA==", "url": "https://github.com/line/armeria/pull/2640#discussion_r410675888", "bodyText": "I've moved it into its own project. I hope I didn't make any mistakes \ud83d\ude4f", "author": "hueneburg", "createdAt": "2020-04-18T09:45:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzOTgzNQ=="}], "type": "inlineReview"}, {"oid": "6ea61877ed795758eaa07f91b8d3c600c55e5885", "url": "https://github.com/line/armeria/commit/6ea61877ed795758eaa07f91b8d3c600c55e5885", "message": "Move preprocessor into extra project, Add description in examples", "committedDate": "2020-04-18T09:42:44Z", "type": "forcePushed"}, {"oid": "b26245a664c2115be389ece10701ce9c80f22847", "url": "https://github.com/line/armeria/commit/b26245a664c2115be389ece10701ce9c80f22847", "message": "Fix processor file", "committedDate": "2020-04-23T00:35:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2Njg5Mg==", "url": "https://github.com/line/armeria/pull/2640#discussion_r414266892", "bodyText": "I think we should either just stick to normal stream or have a flag to control whether this is parallel or not. Many builds have a lot of parallelism already managed by Gradle so having annotation processors also starting threads can be undesirable.", "author": "anuraaga", "createdAt": "2020-04-24T03:33:58Z", "path": "annotation-processor/src/main/java/com/linecorp/armeria/server/annotation/processor/DocumentationProcessor.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.annotation.processor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.tools.FileObject;\n+import javax.tools.StandardLocation;\n+\n+import com.linecorp.armeria.server.annotation.Description;\n+\n+/**\n+ * Processor that creates a properties file based on the JavaDoc/KDoc description of parameters for interfaces.\n+ * This file can be later used if the {@link Description} annotation does not exist for parameters or methods.\n+ */\n+@SupportedAnnotationTypes({\n+        \"com.linecorp.armeria.server.annotation.Post\",\n+        \"com.linecorp.armeria.server.annotation.Get\",\n+        \"com.linecorp.armeria.server.annotation.Put\",\n+        \"com.linecorp.armeria.server.annotation.Delete\",\n+        \"com.linecorp.armeria.server.annotation.Head\",\n+        \"com.linecorp.armeria.server.annotation.Options\",\n+        \"com.linecorp.armeria.server.annotation.Patch\",\n+})\n+public class DocumentationProcessor extends AbstractProcessor {\n+    private final Map<String, Properties> propertiesMap = new HashMap<>();\n+\n+    @Override\n+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+        if (annotations == null || annotations.isEmpty()) {\n+            return false;\n+        }\n+        annotations.forEach(annotation -> processAnnotation(annotation, roundEnv));\n+        propertiesMap.forEach((className, properties) -> {\n+            try {\n+                writeProperties(className, properties);\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        return false;\n+    }\n+\n+    private Properties readProperties(String className) throws IOException {\n+        if (propertiesMap.containsKey(className)) {\n+            return propertiesMap.get(className);\n+        }\n+        final FileObject resource = processingEnv\n+                .getFiler()\n+                .getResource(StandardLocation.CLASS_OUTPUT,\n+                             \"\",\n+                             getFileName(className));\n+        final Properties properties = new Properties();\n+        if (resource.getLastModified() == 0L) {\n+            // returns 0 if file does not exist\n+            propertiesMap.put(className, properties);\n+            return properties;\n+        }\n+        try (Reader reader = resource.openReader(false)) {\n+            properties.load(reader);\n+            return properties;\n+        }\n+    }\n+\n+    private void writeProperties(String className, Properties properties) throws IOException {\n+        if (properties.size() == 0) {\n+            return;\n+        }\n+        final FileObject resource = processingEnv.getFiler().createResource(\n+                StandardLocation.CLASS_OUTPUT,\n+                \"\",\n+                getFileName(className));\n+        try (Writer writer = resource.openWriter()) {\n+            properties.store(writer, \"Generated list of parameter description of REST interfaces.\");\n+        }\n+    }\n+\n+    private void processAnnotation(TypeElement annotationElement, RoundEnvironment roundEnv) {\n+        roundEnv.getElementsAnnotatedWith(annotationElement)\n+                .parallelStream()", "originalCommit": "b26245a664c2115be389ece10701ce9c80f22847", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwMzM0Mw==", "url": "https://github.com/line/armeria/pull/2640#discussion_r414303343", "bodyText": "+1 for stream()", "author": "trustin", "createdAt": "2020-04-24T05:28:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2Njg5Mg=="}], "type": "inlineReview"}, {"oid": "98d053178469912fb5283fb31c6730b5bb974c97", "url": "https://github.com/line/armeria/commit/98d053178469912fb5283fb31c6730b5bb974c97", "message": "Create properties files based on Doc Comments for Rest APIs", "committedDate": "2020-04-28T00:42:12Z", "type": "commit"}, {"oid": "c6671dce5a3b4790025431c206ddc4e7899c535a", "url": "https://github.com/line/armeria/commit/c6671dce5a3b4790025431c206ddc4e7899c535a", "message": "Clean up file name and files that are not needed", "committedDate": "2020-04-28T00:42:12Z", "type": "commit"}, {"oid": "f536618580a8d610fc15c8a1b9a2ab87efbbe4e7", "url": "https://github.com/line/armeria/commit/f536618580a8d610fc15c8a1b9a2ab87efbbe4e7", "message": "Move preprocessor into extra project, Add description in examples", "committedDate": "2020-04-28T00:42:12Z", "type": "commit"}, {"oid": "7712d873e3ff6005dc18ef05278f0b03797265ad", "url": "https://github.com/line/armeria/commit/7712d873e3ff6005dc18ef05278f0b03797265ad", "message": "Fix problems found", "committedDate": "2020-04-28T00:42:12Z", "type": "commit"}, {"oid": "31da3e02fa282e4d2a7f80a786413b830109127e", "url": "https://github.com/line/armeria/commit/31da3e02fa282e4d2a7f80a786413b830109127e", "message": "Rename package and add unit tests", "committedDate": "2020-04-28T00:42:12Z", "type": "commit"}, {"oid": "cebfdd49b5384e816d0ab447fcead78b89f21be8", "url": "https://github.com/line/armeria/commit/cebfdd49b5384e816d0ab447fcead78b89f21be8", "message": "Fix processor file", "committedDate": "2020-04-28T00:42:12Z", "type": "commit"}, {"oid": "7041f70424057d90ebd9ab800418d90d86c314e3", "url": "https://github.com/line/armeria/commit/7041f70424057d90ebd9ab800418d90d86c314e3", "message": "Apply review", "committedDate": "2020-04-28T00:42:12Z", "type": "commit"}, {"oid": "7041f70424057d90ebd9ab800418d90d86c314e3", "url": "https://github.com/line/armeria/commit/7041f70424057d90ebd9ab800418d90d86c314e3", "message": "Apply review", "committedDate": "2020-04-28T00:42:12Z", "type": "forcePushed"}, {"oid": "17144cc109528b1864fe6964e2f61cfc12169f82", "url": "https://github.com/line/armeria/commit/17144cc109528b1864fe6964e2f61cfc12169f82", "message": "Update DocumentationProcessorTest.java", "committedDate": "2020-04-29T10:01:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE5NTA4MA==", "url": "https://github.com/line/armeria/pull/2640#discussion_r419195080", "bodyText": "Let's add a logger and use it.\nForget about this. \ud83d\ude05", "author": "minwoox", "createdAt": "2020-05-04T02:44:18Z", "path": "annotation-processor/src/main/java/com/linecorp/armeria/server/annotation/processor/DocumentationProcessor.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.annotation.processor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.tools.FileObject;\n+import javax.tools.StandardLocation;\n+\n+import com.linecorp.armeria.server.annotation.Description;\n+\n+/**\n+ * Processor that creates a properties file based on the JavaDoc/KDoc description of parameters for interfaces.\n+ * This file can be later used if the {@link Description} annotation does not exist for parameters or methods.\n+ */\n+@SupportedAnnotationTypes({\n+        \"com.linecorp.armeria.server.annotation.Post\",\n+        \"com.linecorp.armeria.server.annotation.Get\",\n+        \"com.linecorp.armeria.server.annotation.Put\",\n+        \"com.linecorp.armeria.server.annotation.Delete\",\n+        \"com.linecorp.armeria.server.annotation.Head\",\n+        \"com.linecorp.armeria.server.annotation.Options\",\n+        \"com.linecorp.armeria.server.annotation.Patch\",\n+})\n+public class DocumentationProcessor extends AbstractProcessor {\n+    private final Map<String, Properties> propertiesMap = new HashMap<>();\n+\n+    @Override\n+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+        if (annotations == null || annotations.isEmpty()) {\n+            return false;\n+        }\n+        annotations.forEach(annotation -> processAnnotation(annotation, roundEnv));\n+        propertiesMap.forEach((className, properties) -> {\n+            try {\n+                writeProperties(className, properties);\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        return false;\n+    }\n+\n+    private Properties readProperties(String className) throws IOException {\n+        if (propertiesMap.containsKey(className)) {\n+            return propertiesMap.get(className);\n+        }\n+        final FileObject resource = processingEnv\n+                .getFiler()\n+                .getResource(StandardLocation.CLASS_OUTPUT,\n+                             \"\",\n+                             getFileName(className));\n+        final Properties properties = new Properties();\n+        if (resource.getLastModified() == 0L) {\n+            // returns 0 if file does not exist\n+            propertiesMap.put(className, properties);\n+            return properties;\n+        }\n+        try (Reader reader = resource.openReader(false)) {\n+            properties.load(reader);\n+            return properties;\n+        }\n+    }\n+\n+    private void writeProperties(String className, Properties properties) throws IOException {\n+        if (properties.size() == 0) {\n+            return;\n+        }\n+        final FileObject resource = processingEnv.getFiler().createResource(\n+                StandardLocation.CLASS_OUTPUT,\n+                \"\",\n+                getFileName(className));\n+        try (Writer writer = resource.openWriter()) {\n+            properties.store(writer, \"Generated list of parameter description of REST interfaces.\");\n+        }\n+    }\n+\n+    private void processAnnotation(TypeElement annotationElement, RoundEnvironment roundEnv) {\n+        roundEnv.getElementsAnnotatedWith(annotationElement)\n+                .stream()\n+                .filter(element -> element.getKind() == ElementKind.METHOD)\n+                // Element is always ExecutableElement because it is a method.\n+                .forEachOrdered(element -> {\n+                    try {\n+                        processMethod((ExecutableElement) element);\n+                    } catch (IOException e) {\n+                        e.printStackTrace();", "originalCommit": "17144cc109528b1864fe6964e2f61cfc12169f82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIxNzczOA==", "url": "https://github.com/line/armeria/pull/2640#discussion_r419217738", "bodyText": "nit: properties.isEmpty()", "author": "minwoox", "createdAt": "2020-05-04T05:20:58Z", "path": "annotation-processor/src/main/java/com/linecorp/armeria/server/annotation/processor/DocumentationProcessor.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.annotation.processor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.tools.FileObject;\n+import javax.tools.StandardLocation;\n+\n+import com.linecorp.armeria.server.annotation.Description;\n+\n+/**\n+ * Processor that creates a properties file based on the JavaDoc/KDoc description of parameters for interfaces.\n+ * This file can be later used if the {@link Description} annotation does not exist for parameters or methods.\n+ */\n+@SupportedAnnotationTypes({\n+        \"com.linecorp.armeria.server.annotation.Post\",\n+        \"com.linecorp.armeria.server.annotation.Get\",\n+        \"com.linecorp.armeria.server.annotation.Put\",\n+        \"com.linecorp.armeria.server.annotation.Delete\",\n+        \"com.linecorp.armeria.server.annotation.Head\",\n+        \"com.linecorp.armeria.server.annotation.Options\",\n+        \"com.linecorp.armeria.server.annotation.Patch\",\n+})\n+public class DocumentationProcessor extends AbstractProcessor {\n+    private final Map<String, Properties> propertiesMap = new HashMap<>();\n+\n+    @Override\n+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+        if (annotations == null || annotations.isEmpty()) {\n+            return false;\n+        }\n+        annotations.forEach(annotation -> processAnnotation(annotation, roundEnv));\n+        propertiesMap.forEach((className, properties) -> {\n+            try {\n+                writeProperties(className, properties);\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        return false;\n+    }\n+\n+    private Properties readProperties(String className) throws IOException {\n+        if (propertiesMap.containsKey(className)) {\n+            return propertiesMap.get(className);\n+        }\n+        final FileObject resource = processingEnv\n+                .getFiler()\n+                .getResource(StandardLocation.CLASS_OUTPUT,\n+                             \"\",\n+                             getFileName(className));\n+        final Properties properties = new Properties();\n+        if (resource.getLastModified() == 0L) {\n+            // returns 0 if file does not exist\n+            propertiesMap.put(className, properties);\n+            return properties;\n+        }\n+        try (Reader reader = resource.openReader(false)) {\n+            properties.load(reader);\n+            return properties;\n+        }\n+    }\n+\n+    private void writeProperties(String className, Properties properties) throws IOException {\n+        if (properties.size() == 0) {", "originalCommit": "17144cc109528b1864fe6964e2f61cfc12169f82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIxOTEyOA==", "url": "https://github.com/line/armeria/pull/2640#discussion_r419219128", "bodyText": "Could be a static method.", "author": "minwoox", "createdAt": "2020-05-04T05:28:43Z", "path": "annotation-processor/src/main/java/com/linecorp/armeria/server/annotation/processor/DocumentationProcessor.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.annotation.processor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.tools.FileObject;\n+import javax.tools.StandardLocation;\n+\n+import com.linecorp.armeria.server.annotation.Description;\n+\n+/**\n+ * Processor that creates a properties file based on the JavaDoc/KDoc description of parameters for interfaces.\n+ * This file can be later used if the {@link Description} annotation does not exist for parameters or methods.\n+ */\n+@SupportedAnnotationTypes({\n+        \"com.linecorp.armeria.server.annotation.Post\",\n+        \"com.linecorp.armeria.server.annotation.Get\",\n+        \"com.linecorp.armeria.server.annotation.Put\",\n+        \"com.linecorp.armeria.server.annotation.Delete\",\n+        \"com.linecorp.armeria.server.annotation.Head\",\n+        \"com.linecorp.armeria.server.annotation.Options\",\n+        \"com.linecorp.armeria.server.annotation.Patch\",\n+})\n+public class DocumentationProcessor extends AbstractProcessor {\n+    private final Map<String, Properties> propertiesMap = new HashMap<>();\n+\n+    @Override\n+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+        if (annotations == null || annotations.isEmpty()) {\n+            return false;\n+        }\n+        annotations.forEach(annotation -> processAnnotation(annotation, roundEnv));\n+        propertiesMap.forEach((className, properties) -> {\n+            try {\n+                writeProperties(className, properties);\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        return false;\n+    }\n+\n+    private Properties readProperties(String className) throws IOException {\n+        if (propertiesMap.containsKey(className)) {\n+            return propertiesMap.get(className);\n+        }\n+        final FileObject resource = processingEnv\n+                .getFiler()\n+                .getResource(StandardLocation.CLASS_OUTPUT,\n+                             \"\",\n+                             getFileName(className));\n+        final Properties properties = new Properties();\n+        if (resource.getLastModified() == 0L) {\n+            // returns 0 if file does not exist\n+            propertiesMap.put(className, properties);\n+            return properties;\n+        }\n+        try (Reader reader = resource.openReader(false)) {\n+            properties.load(reader);\n+            return properties;\n+        }\n+    }\n+\n+    private void writeProperties(String className, Properties properties) throws IOException {\n+        if (properties.size() == 0) {\n+            return;\n+        }\n+        final FileObject resource = processingEnv.getFiler().createResource(\n+                StandardLocation.CLASS_OUTPUT,\n+                \"\",\n+                getFileName(className));\n+        try (Writer writer = resource.openWriter()) {\n+            properties.store(writer, \"Generated list of parameter description of REST interfaces.\");\n+        }\n+    }\n+\n+    private void processAnnotation(TypeElement annotationElement, RoundEnvironment roundEnv) {\n+        roundEnv.getElementsAnnotatedWith(annotationElement)\n+                .stream()\n+                .filter(element -> element.getKind() == ElementKind.METHOD)\n+                // Element is always ExecutableElement because it is a method.\n+                .forEachOrdered(element -> {\n+                    try {\n+                        processMethod((ExecutableElement) element);\n+                    } catch (IOException e) {\n+                        e.printStackTrace();\n+                    }\n+                });\n+    }\n+\n+    private void processMethod(ExecutableElement method) throws IOException {\n+        final String className = ((TypeElement) method.getEnclosingElement()).getQualifiedName().toString();\n+        final Properties properties = readProperties(className);\n+        final String docComment = processingEnv.getElementUtils().getDocComment(method);\n+        if (docComment == null || !docComment.contains(\"@param\")) {\n+            return;\n+        }\n+        final List<List<String>> lines = Arrays.stream(docComment.split(\"\\\\R\"))\n+                                               .filter(line -> !line.trim().isEmpty())\n+                                               .map(line -> Arrays.stream(line.split(\"\\\\s\"))\n+                                                                  .filter(word -> !word.trim().isEmpty())\n+                                                                  .collect(toImmutableList()))\n+                                               .collect(toImmutableList());\n+        method.getParameters().forEach(param -> {\n+            final StringBuilder stringBuilder = new StringBuilder();\n+            JavaDocParserState state = JavaDocParserState.SEARCHING;\n+            for (List<String> line : lines) {\n+                final List<String> subLine;\n+                if ((line.size() < 3 ||\n+                     !\"@param\".equals(line.get(0)) ||\n+                     !param.getSimpleName().toString().equals(line.get(1))) &&\n+                    state == JavaDocParserState.SEARCHING) {\n+                    continue;\n+                } else if (state == JavaDocParserState.IN_DESCRIPTION &&\n+                           line.size() > 0 &&\n+                           \"@param\".equals(line.get(0))) {\n+                    break;\n+                } else if (state == JavaDocParserState.SEARCHING) {\n+                    subLine = line.subList(2, line.size());\n+                    state = JavaDocParserState.IN_DESCRIPTION;\n+                } else {\n+                    subLine = line;\n+                }\n+                for (String word : subLine) {\n+                    stringBuilder.append(word);\n+                    stringBuilder.append(' ');\n+                }\n+            }\n+            setProperty(properties, method, param, stringBuilder.toString().trim());\n+        });\n+    }\n+\n+    private void setProperty(Properties properties,", "originalCommit": "17144cc109528b1864fe6964e2f61cfc12169f82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIxOTE3MQ==", "url": "https://github.com/line/armeria/pull/2640#discussion_r419219171", "bodyText": "nit: \".\" -> '.'", "author": "minwoox", "createdAt": "2020-05-04T05:28:58Z", "path": "annotation-processor/src/main/java/com/linecorp/armeria/server/annotation/processor/DocumentationProcessor.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.annotation.processor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.tools.FileObject;\n+import javax.tools.StandardLocation;\n+\n+import com.linecorp.armeria.server.annotation.Description;\n+\n+/**\n+ * Processor that creates a properties file based on the JavaDoc/KDoc description of parameters for interfaces.\n+ * This file can be later used if the {@link Description} annotation does not exist for parameters or methods.\n+ */\n+@SupportedAnnotationTypes({\n+        \"com.linecorp.armeria.server.annotation.Post\",\n+        \"com.linecorp.armeria.server.annotation.Get\",\n+        \"com.linecorp.armeria.server.annotation.Put\",\n+        \"com.linecorp.armeria.server.annotation.Delete\",\n+        \"com.linecorp.armeria.server.annotation.Head\",\n+        \"com.linecorp.armeria.server.annotation.Options\",\n+        \"com.linecorp.armeria.server.annotation.Patch\",\n+})\n+public class DocumentationProcessor extends AbstractProcessor {\n+    private final Map<String, Properties> propertiesMap = new HashMap<>();\n+\n+    @Override\n+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+        if (annotations == null || annotations.isEmpty()) {\n+            return false;\n+        }\n+        annotations.forEach(annotation -> processAnnotation(annotation, roundEnv));\n+        propertiesMap.forEach((className, properties) -> {\n+            try {\n+                writeProperties(className, properties);\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        return false;\n+    }\n+\n+    private Properties readProperties(String className) throws IOException {\n+        if (propertiesMap.containsKey(className)) {\n+            return propertiesMap.get(className);\n+        }\n+        final FileObject resource = processingEnv\n+                .getFiler()\n+                .getResource(StandardLocation.CLASS_OUTPUT,\n+                             \"\",\n+                             getFileName(className));\n+        final Properties properties = new Properties();\n+        if (resource.getLastModified() == 0L) {\n+            // returns 0 if file does not exist\n+            propertiesMap.put(className, properties);\n+            return properties;\n+        }\n+        try (Reader reader = resource.openReader(false)) {\n+            properties.load(reader);\n+            return properties;\n+        }\n+    }\n+\n+    private void writeProperties(String className, Properties properties) throws IOException {\n+        if (properties.size() == 0) {\n+            return;\n+        }\n+        final FileObject resource = processingEnv.getFiler().createResource(\n+                StandardLocation.CLASS_OUTPUT,\n+                \"\",\n+                getFileName(className));\n+        try (Writer writer = resource.openWriter()) {\n+            properties.store(writer, \"Generated list of parameter description of REST interfaces.\");\n+        }\n+    }\n+\n+    private void processAnnotation(TypeElement annotationElement, RoundEnvironment roundEnv) {\n+        roundEnv.getElementsAnnotatedWith(annotationElement)\n+                .stream()\n+                .filter(element -> element.getKind() == ElementKind.METHOD)\n+                // Element is always ExecutableElement because it is a method.\n+                .forEachOrdered(element -> {\n+                    try {\n+                        processMethod((ExecutableElement) element);\n+                    } catch (IOException e) {\n+                        e.printStackTrace();\n+                    }\n+                });\n+    }\n+\n+    private void processMethod(ExecutableElement method) throws IOException {\n+        final String className = ((TypeElement) method.getEnclosingElement()).getQualifiedName().toString();\n+        final Properties properties = readProperties(className);\n+        final String docComment = processingEnv.getElementUtils().getDocComment(method);\n+        if (docComment == null || !docComment.contains(\"@param\")) {\n+            return;\n+        }\n+        final List<List<String>> lines = Arrays.stream(docComment.split(\"\\\\R\"))\n+                                               .filter(line -> !line.trim().isEmpty())\n+                                               .map(line -> Arrays.stream(line.split(\"\\\\s\"))\n+                                                                  .filter(word -> !word.trim().isEmpty())\n+                                                                  .collect(toImmutableList()))\n+                                               .collect(toImmutableList());\n+        method.getParameters().forEach(param -> {\n+            final StringBuilder stringBuilder = new StringBuilder();\n+            JavaDocParserState state = JavaDocParserState.SEARCHING;\n+            for (List<String> line : lines) {\n+                final List<String> subLine;\n+                if ((line.size() < 3 ||\n+                     !\"@param\".equals(line.get(0)) ||\n+                     !param.getSimpleName().toString().equals(line.get(1))) &&\n+                    state == JavaDocParserState.SEARCHING) {\n+                    continue;\n+                } else if (state == JavaDocParserState.IN_DESCRIPTION &&\n+                           line.size() > 0 &&\n+                           \"@param\".equals(line.get(0))) {\n+                    break;\n+                } else if (state == JavaDocParserState.SEARCHING) {\n+                    subLine = line.subList(2, line.size());\n+                    state = JavaDocParserState.IN_DESCRIPTION;\n+                } else {\n+                    subLine = line;\n+                }\n+                for (String word : subLine) {\n+                    stringBuilder.append(word);\n+                    stringBuilder.append(' ');\n+                }\n+            }\n+            setProperty(properties, method, param, stringBuilder.toString().trim());\n+        });\n+    }\n+\n+    private void setProperty(Properties properties,\n+                             ExecutableElement method,\n+                             VariableElement parameter,\n+                             String description) {\n+        final String methodName = method.getSimpleName().toString();\n+        final String parameterName = parameter.getSimpleName().toString();\n+        properties.setProperty(methodName + \".\" + parameterName, description);", "originalCommit": "17144cc109528b1864fe6964e2f61cfc12169f82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIxOTQ5Ng==", "url": "https://github.com/line/armeria/pull/2640#discussion_r419219496", "bodyText": "Let's use annotated services instead of RESTful services throughout this PR. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-05-04T05:30:53Z", "path": "annotation-processor/src/main/java/com/linecorp/armeria/server/annotation/processor/package-info.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+/**\n+ * Annotation processors for RESTful services.", "originalCommit": "17144cc109528b1864fe6964e2f61cfc12169f82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIyMDk3Mg==", "url": "https://github.com/line/armeria/pull/2640#discussion_r419220972", "bodyText": "Let's use properties.getProperty", "author": "minwoox", "createdAt": "2020-05-04T05:38:51Z", "path": "annotation-processor/src/test/java/com/linecorp/armeria/server/annotation/processor/DocumentationProcessorTest.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.annotation.processor;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assumptions.assumeThat;\n+\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Properties;\n+\n+import org.joor.CompileOptions;\n+import org.joor.Reflect;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import com.google.common.io.CharStreams;\n+\n+import com.linecorp.armeria.common.util.SystemInfo;\n+\n+public class DocumentationProcessorTest {\n+    private final DocumentationProcessor target = new DocumentationProcessor();\n+\n+    @BeforeAll\n+    public static void classSetup() {\n+        assumeThat(SystemInfo.javaVersion()).isGreaterThanOrEqualTo(13);\n+    }\n+\n+    @Test\n+    public void withJavaDoc() throws IOException {\n+        Reflect.compile(\n+                \"com.linecorp.armeria.WithJavaDoc\",\n+                loadFile(\"WithJavaDoc.java\"),\n+                new CompileOptions().processors(target)\n+        );\n+        testAndDeleteFile(\"com.linecorp.armeria.WithJavaDoc\");\n+    }\n+\n+    @Test\n+    public void noJavaDoc() throws IOException {\n+        Reflect.compile(\n+                \"com.linecorp.armeria.NoJavaDoc\",\n+                loadFile(\"NoJavaDoc.java\"),\n+                new CompileOptions().processors(target)\n+        );\n+        final String fileName = DocumentationProcessor.getFileName(\"com.linecorp.armeria.NoJavaDoc\");\n+        assertThat(Files.notExists(Paths.get(fileName))).isTrue();\n+    }\n+\n+    private void testAndDeleteFile(String fileName) throws IOException {\n+        final Path path = Paths.get(DocumentationProcessor.getFileName(fileName));\n+        assertThat(Files.exists(path)).isTrue();\n+        final Properties properties = new Properties();\n+        properties.load(Files.newInputStream(path));\n+        assertThat(properties.get(\"a.x\")).isEqualTo(\"The x variable in a\");", "originalCommit": "17144cc109528b1864fe6964e2f61cfc12169f82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIyMTAwNA==", "url": "https://github.com/line/armeria/pull/2640#discussion_r419221004", "bodyText": "Could be static", "author": "minwoox", "createdAt": "2020-05-04T05:38:57Z", "path": "annotation-processor/src/test/java/com/linecorp/armeria/server/annotation/processor/DocumentationProcessorTest.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.annotation.processor;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assumptions.assumeThat;\n+\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Properties;\n+\n+import org.joor.CompileOptions;\n+import org.joor.Reflect;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import com.google.common.io.CharStreams;\n+\n+import com.linecorp.armeria.common.util.SystemInfo;\n+\n+public class DocumentationProcessorTest {\n+    private final DocumentationProcessor target = new DocumentationProcessor();\n+\n+    @BeforeAll\n+    public static void classSetup() {\n+        assumeThat(SystemInfo.javaVersion()).isGreaterThanOrEqualTo(13);\n+    }\n+\n+    @Test\n+    public void withJavaDoc() throws IOException {\n+        Reflect.compile(\n+                \"com.linecorp.armeria.WithJavaDoc\",\n+                loadFile(\"WithJavaDoc.java\"),\n+                new CompileOptions().processors(target)\n+        );\n+        testAndDeleteFile(\"com.linecorp.armeria.WithJavaDoc\");\n+    }\n+\n+    @Test\n+    public void noJavaDoc() throws IOException {\n+        Reflect.compile(\n+                \"com.linecorp.armeria.NoJavaDoc\",\n+                loadFile(\"NoJavaDoc.java\"),\n+                new CompileOptions().processors(target)\n+        );\n+        final String fileName = DocumentationProcessor.getFileName(\"com.linecorp.armeria.NoJavaDoc\");\n+        assertThat(Files.notExists(Paths.get(fileName))).isTrue();\n+    }\n+\n+    private void testAndDeleteFile(String fileName) throws IOException {", "originalCommit": "17144cc109528b1864fe6964e2f61cfc12169f82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIyMzM5Mw==", "url": "https://github.com/line/armeria/pull/2640#discussion_r419223393", "bodyText": "How about using a Splitter so that we don't need this line?\nprivate static final Splitter splitter = Splitter.on(\"\\n\").trimResults();\n...\nfinal List<List<String>> lines = Streams.stream(splitter.split(docComment)).map(...)", "author": "minwoox", "createdAt": "2020-05-04T05:50:31Z", "path": "annotation-processor/src/main/java/com/linecorp/armeria/server/annotation/processor/DocumentationProcessor.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.annotation.processor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.tools.FileObject;\n+import javax.tools.StandardLocation;\n+\n+import com.linecorp.armeria.server.annotation.Description;\n+\n+/**\n+ * Processor that creates a properties file based on the JavaDoc/KDoc description of parameters for interfaces.\n+ * This file can be later used if the {@link Description} annotation does not exist for parameters or methods.\n+ */\n+@SupportedAnnotationTypes({\n+        \"com.linecorp.armeria.server.annotation.Post\",\n+        \"com.linecorp.armeria.server.annotation.Get\",\n+        \"com.linecorp.armeria.server.annotation.Put\",\n+        \"com.linecorp.armeria.server.annotation.Delete\",\n+        \"com.linecorp.armeria.server.annotation.Head\",\n+        \"com.linecorp.armeria.server.annotation.Options\",\n+        \"com.linecorp.armeria.server.annotation.Patch\",\n+})\n+public class DocumentationProcessor extends AbstractProcessor {\n+    private final Map<String, Properties> propertiesMap = new HashMap<>();\n+\n+    @Override\n+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+        if (annotations == null || annotations.isEmpty()) {\n+            return false;\n+        }\n+        annotations.forEach(annotation -> processAnnotation(annotation, roundEnv));\n+        propertiesMap.forEach((className, properties) -> {\n+            try {\n+                writeProperties(className, properties);\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        return false;\n+    }\n+\n+    private Properties readProperties(String className) throws IOException {\n+        if (propertiesMap.containsKey(className)) {\n+            return propertiesMap.get(className);\n+        }\n+        final FileObject resource = processingEnv\n+                .getFiler()\n+                .getResource(StandardLocation.CLASS_OUTPUT,\n+                             \"\",\n+                             getFileName(className));\n+        final Properties properties = new Properties();\n+        if (resource.getLastModified() == 0L) {\n+            // returns 0 if file does not exist\n+            propertiesMap.put(className, properties);\n+            return properties;\n+        }\n+        try (Reader reader = resource.openReader(false)) {\n+            properties.load(reader);\n+            return properties;\n+        }\n+    }\n+\n+    private void writeProperties(String className, Properties properties) throws IOException {\n+        if (properties.size() == 0) {\n+            return;\n+        }\n+        final FileObject resource = processingEnv.getFiler().createResource(\n+                StandardLocation.CLASS_OUTPUT,\n+                \"\",\n+                getFileName(className));\n+        try (Writer writer = resource.openWriter()) {\n+            properties.store(writer, \"Generated list of parameter description of REST interfaces.\");\n+        }\n+    }\n+\n+    private void processAnnotation(TypeElement annotationElement, RoundEnvironment roundEnv) {\n+        roundEnv.getElementsAnnotatedWith(annotationElement)\n+                .stream()\n+                .filter(element -> element.getKind() == ElementKind.METHOD)\n+                // Element is always ExecutableElement because it is a method.\n+                .forEachOrdered(element -> {\n+                    try {\n+                        processMethod((ExecutableElement) element);\n+                    } catch (IOException e) {\n+                        e.printStackTrace();\n+                    }\n+                });\n+    }\n+\n+    private void processMethod(ExecutableElement method) throws IOException {\n+        final String className = ((TypeElement) method.getEnclosingElement()).getQualifiedName().toString();\n+        final Properties properties = readProperties(className);\n+        final String docComment = processingEnv.getElementUtils().getDocComment(method);\n+        if (docComment == null || !docComment.contains(\"@param\")) {\n+            return;\n+        }\n+        final List<List<String>> lines = Arrays.stream(docComment.split(\"\\\\R\"))\n+                                               .filter(line -> !line.trim().isEmpty())", "originalCommit": "17144cc109528b1864fe6964e2f61cfc12169f82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIyMzQ4Ng==", "url": "https://github.com/line/armeria/pull/2640#discussion_r419223486", "bodyText": "Could it be just \\n? instead of \\\\R", "author": "minwoox", "createdAt": "2020-05-04T05:50:53Z", "path": "annotation-processor/src/main/java/com/linecorp/armeria/server/annotation/processor/DocumentationProcessor.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.annotation.processor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.tools.FileObject;\n+import javax.tools.StandardLocation;\n+\n+import com.linecorp.armeria.server.annotation.Description;\n+\n+/**\n+ * Processor that creates a properties file based on the JavaDoc/KDoc description of parameters for interfaces.\n+ * This file can be later used if the {@link Description} annotation does not exist for parameters or methods.\n+ */\n+@SupportedAnnotationTypes({\n+        \"com.linecorp.armeria.server.annotation.Post\",\n+        \"com.linecorp.armeria.server.annotation.Get\",\n+        \"com.linecorp.armeria.server.annotation.Put\",\n+        \"com.linecorp.armeria.server.annotation.Delete\",\n+        \"com.linecorp.armeria.server.annotation.Head\",\n+        \"com.linecorp.armeria.server.annotation.Options\",\n+        \"com.linecorp.armeria.server.annotation.Patch\",\n+})\n+public class DocumentationProcessor extends AbstractProcessor {\n+    private final Map<String, Properties> propertiesMap = new HashMap<>();\n+\n+    @Override\n+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+        if (annotations == null || annotations.isEmpty()) {\n+            return false;\n+        }\n+        annotations.forEach(annotation -> processAnnotation(annotation, roundEnv));\n+        propertiesMap.forEach((className, properties) -> {\n+            try {\n+                writeProperties(className, properties);\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        return false;\n+    }\n+\n+    private Properties readProperties(String className) throws IOException {\n+        if (propertiesMap.containsKey(className)) {\n+            return propertiesMap.get(className);\n+        }\n+        final FileObject resource = processingEnv\n+                .getFiler()\n+                .getResource(StandardLocation.CLASS_OUTPUT,\n+                             \"\",\n+                             getFileName(className));\n+        final Properties properties = new Properties();\n+        if (resource.getLastModified() == 0L) {\n+            // returns 0 if file does not exist\n+            propertiesMap.put(className, properties);\n+            return properties;\n+        }\n+        try (Reader reader = resource.openReader(false)) {\n+            properties.load(reader);\n+            return properties;\n+        }\n+    }\n+\n+    private void writeProperties(String className, Properties properties) throws IOException {\n+        if (properties.size() == 0) {\n+            return;\n+        }\n+        final FileObject resource = processingEnv.getFiler().createResource(\n+                StandardLocation.CLASS_OUTPUT,\n+                \"\",\n+                getFileName(className));\n+        try (Writer writer = resource.openWriter()) {\n+            properties.store(writer, \"Generated list of parameter description of REST interfaces.\");\n+        }\n+    }\n+\n+    private void processAnnotation(TypeElement annotationElement, RoundEnvironment roundEnv) {\n+        roundEnv.getElementsAnnotatedWith(annotationElement)\n+                .stream()\n+                .filter(element -> element.getKind() == ElementKind.METHOD)\n+                // Element is always ExecutableElement because it is a method.\n+                .forEachOrdered(element -> {\n+                    try {\n+                        processMethod((ExecutableElement) element);\n+                    } catch (IOException e) {\n+                        e.printStackTrace();\n+                    }\n+                });\n+    }\n+\n+    private void processMethod(ExecutableElement method) throws IOException {\n+        final String className = ((TypeElement) method.getEnclosingElement()).getQualifiedName().toString();\n+        final Properties properties = readProperties(className);\n+        final String docComment = processingEnv.getElementUtils().getDocComment(method);\n+        if (docComment == null || !docComment.contains(\"@param\")) {\n+            return;\n+        }\n+        final List<List<String>> lines = Arrays.stream(docComment.split(\"\\\\R\"))", "originalCommit": "17144cc109528b1864fe6964e2f61cfc12169f82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwNjc2MQ==", "url": "https://github.com/line/armeria/pull/2640#discussion_r419806761", "bodyText": "I'm not sure that works 100% of the time... for example windows and mac use \\r\\n and \\n\\r respectively for linebreaks. If I'd only used \\n, I'd have partial linebreaks leftover which could cause inconsistency in some programs (windows' notepad cannot handle \\n as a linebreak, for example)", "author": "hueneburg", "createdAt": "2020-05-05T00:36:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIyMzQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxNDI1Ng==", "url": "https://github.com/line/armeria/pull/2640#discussion_r420514256", "bodyText": "Ah, I didn't notice that \\R is for line break matcher. Thanks!", "author": "minwoox", "createdAt": "2020-05-06T02:31:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIyMzQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIyMzU2MA==", "url": "https://github.com/line/armeria/pull/2640#discussion_r419223560", "bodyText": "Could it be just  (space) instead of \\\\s?", "author": "minwoox", "createdAt": "2020-05-04T05:51:12Z", "path": "annotation-processor/src/main/java/com/linecorp/armeria/server/annotation/processor/DocumentationProcessor.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.annotation.processor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.tools.FileObject;\n+import javax.tools.StandardLocation;\n+\n+import com.linecorp.armeria.server.annotation.Description;\n+\n+/**\n+ * Processor that creates a properties file based on the JavaDoc/KDoc description of parameters for interfaces.\n+ * This file can be later used if the {@link Description} annotation does not exist for parameters or methods.\n+ */\n+@SupportedAnnotationTypes({\n+        \"com.linecorp.armeria.server.annotation.Post\",\n+        \"com.linecorp.armeria.server.annotation.Get\",\n+        \"com.linecorp.armeria.server.annotation.Put\",\n+        \"com.linecorp.armeria.server.annotation.Delete\",\n+        \"com.linecorp.armeria.server.annotation.Head\",\n+        \"com.linecorp.armeria.server.annotation.Options\",\n+        \"com.linecorp.armeria.server.annotation.Patch\",\n+})\n+public class DocumentationProcessor extends AbstractProcessor {\n+    private final Map<String, Properties> propertiesMap = new HashMap<>();\n+\n+    @Override\n+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+        if (annotations == null || annotations.isEmpty()) {\n+            return false;\n+        }\n+        annotations.forEach(annotation -> processAnnotation(annotation, roundEnv));\n+        propertiesMap.forEach((className, properties) -> {\n+            try {\n+                writeProperties(className, properties);\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        return false;\n+    }\n+\n+    private Properties readProperties(String className) throws IOException {\n+        if (propertiesMap.containsKey(className)) {\n+            return propertiesMap.get(className);\n+        }\n+        final FileObject resource = processingEnv\n+                .getFiler()\n+                .getResource(StandardLocation.CLASS_OUTPUT,\n+                             \"\",\n+                             getFileName(className));\n+        final Properties properties = new Properties();\n+        if (resource.getLastModified() == 0L) {\n+            // returns 0 if file does not exist\n+            propertiesMap.put(className, properties);\n+            return properties;\n+        }\n+        try (Reader reader = resource.openReader(false)) {\n+            properties.load(reader);\n+            return properties;\n+        }\n+    }\n+\n+    private void writeProperties(String className, Properties properties) throws IOException {\n+        if (properties.size() == 0) {\n+            return;\n+        }\n+        final FileObject resource = processingEnv.getFiler().createResource(\n+                StandardLocation.CLASS_OUTPUT,\n+                \"\",\n+                getFileName(className));\n+        try (Writer writer = resource.openWriter()) {\n+            properties.store(writer, \"Generated list of parameter description of REST interfaces.\");\n+        }\n+    }\n+\n+    private void processAnnotation(TypeElement annotationElement, RoundEnvironment roundEnv) {\n+        roundEnv.getElementsAnnotatedWith(annotationElement)\n+                .stream()\n+                .filter(element -> element.getKind() == ElementKind.METHOD)\n+                // Element is always ExecutableElement because it is a method.\n+                .forEachOrdered(element -> {\n+                    try {\n+                        processMethod((ExecutableElement) element);\n+                    } catch (IOException e) {\n+                        e.printStackTrace();\n+                    }\n+                });\n+    }\n+\n+    private void processMethod(ExecutableElement method) throws IOException {\n+        final String className = ((TypeElement) method.getEnclosingElement()).getQualifiedName().toString();\n+        final Properties properties = readProperties(className);\n+        final String docComment = processingEnv.getElementUtils().getDocComment(method);\n+        if (docComment == null || !docComment.contains(\"@param\")) {\n+            return;\n+        }\n+        final List<List<String>> lines = Arrays.stream(docComment.split(\"\\\\R\"))\n+                                               .filter(line -> !line.trim().isEmpty())\n+                                               .map(line -> Arrays.stream(line.split(\"\\\\s\"))", "originalCommit": "17144cc109528b1864fe6964e2f61cfc12169f82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwNzEwNQ==", "url": "https://github.com/line/armeria/pull/2640#discussion_r419807105", "bodyText": "I want to exclude any whitespaces, for example the full width \u3000 when you type with hiragana/katana input on mac. Also people might use \\t.", "author": "hueneburg", "createdAt": "2020-05-05T00:37:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIyMzU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIyMzgwMQ==", "url": "https://github.com/line/armeria/pull/2640#discussion_r419223801", "bodyText": "How about adding a case that the parameter description is on multiple lines?", "author": "minwoox", "createdAt": "2020-05-04T05:52:16Z", "path": "annotation-processor/src/test/resources/DocumentationProcessor/WithJavaDoc.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria;\n+\n+import com.linecorp.armeria.server.annotation.Delete;\n+import com.linecorp.armeria.server.annotation.Get;\n+import com.linecorp.armeria.server.annotation.Param;\n+import com.linecorp.armeria.server.annotation.Post;\n+import com.linecorp.armeria.server.annotation.Put;\n+\n+public class WithJavaDoc {\n+    /**\n+     * A method.\n+     * @param x The x variable in a", "originalCommit": "17144cc109528b1864fe6964e2f61cfc12169f82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1Nzk2OA==", "url": "https://github.com/line/armeria/pull/2640#discussion_r419257968", "bodyText": "This will not cover a Javadoc which a user adds another tags such as @returns, @throws to.\nIf use switch statement, we can simplify this a little bit.\n\nouter:\nfor (List<String> line : lines) {\n    switch (state) {\n        case SEARCHING:\n            final int size = line.size();\n            if (size < 3 ||\n                !\"@param\".equals(line.get(0)) ||\n                !param.getSimpleName().toString().equals(line.get(1))) {\n                break;\n            }\n            line = line.subList(2, size);\n            state = JavaDocParserState.IN_PARAM;\n        case IN_PARAM:\n            if (!line.isEmpty()) {\n                final String first = line.get(0);\n                // break loop if first is `@xxxxx`\n                if (!first.isEmpty() && first.charAt(0) == '@') {\n                    break outer;\n                }\n\n                for (String word : line) {\n                    stringBuilder.append(word);\n                    stringBuilder.append(' ');\n                }\n            }\n            break;\n        }\n}", "author": "ikhoon", "createdAt": "2020-05-04T07:37:41Z", "path": "annotation-processor/src/main/java/com/linecorp/armeria/server/annotation/processor/DocumentationProcessor.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.annotation.processor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.tools.FileObject;\n+import javax.tools.StandardLocation;\n+\n+import com.linecorp.armeria.server.annotation.Description;\n+\n+/**\n+ * Processor that creates a properties file based on the JavaDoc/KDoc description of parameters for interfaces.\n+ * This file can be later used if the {@link Description} annotation does not exist for parameters or methods.\n+ */\n+@SupportedAnnotationTypes({\n+        \"com.linecorp.armeria.server.annotation.Post\",\n+        \"com.linecorp.armeria.server.annotation.Get\",\n+        \"com.linecorp.armeria.server.annotation.Put\",\n+        \"com.linecorp.armeria.server.annotation.Delete\",\n+        \"com.linecorp.armeria.server.annotation.Head\",\n+        \"com.linecorp.armeria.server.annotation.Options\",\n+        \"com.linecorp.armeria.server.annotation.Patch\",\n+})\n+public class DocumentationProcessor extends AbstractProcessor {\n+    private final Map<String, Properties> propertiesMap = new HashMap<>();\n+\n+    @Override\n+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+        if (annotations == null || annotations.isEmpty()) {\n+            return false;\n+        }\n+        annotations.forEach(annotation -> processAnnotation(annotation, roundEnv));\n+        propertiesMap.forEach((className, properties) -> {\n+            try {\n+                writeProperties(className, properties);\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        return false;\n+    }\n+\n+    private Properties readProperties(String className) throws IOException {\n+        if (propertiesMap.containsKey(className)) {\n+            return propertiesMap.get(className);\n+        }\n+        final FileObject resource = processingEnv\n+                .getFiler()\n+                .getResource(StandardLocation.CLASS_OUTPUT,\n+                             \"\",\n+                             getFileName(className));\n+        final Properties properties = new Properties();\n+        if (resource.getLastModified() == 0L) {\n+            // returns 0 if file does not exist\n+            propertiesMap.put(className, properties);\n+            return properties;\n+        }\n+        try (Reader reader = resource.openReader(false)) {\n+            properties.load(reader);\n+            return properties;\n+        }\n+    }\n+\n+    private void writeProperties(String className, Properties properties) throws IOException {\n+        if (properties.size() == 0) {\n+            return;\n+        }\n+        final FileObject resource = processingEnv.getFiler().createResource(\n+                StandardLocation.CLASS_OUTPUT,\n+                \"\",\n+                getFileName(className));\n+        try (Writer writer = resource.openWriter()) {\n+            properties.store(writer, \"Generated list of parameter description of REST interfaces.\");\n+        }\n+    }\n+\n+    private void processAnnotation(TypeElement annotationElement, RoundEnvironment roundEnv) {\n+        roundEnv.getElementsAnnotatedWith(annotationElement)\n+                .stream()\n+                .filter(element -> element.getKind() == ElementKind.METHOD)\n+                // Element is always ExecutableElement because it is a method.\n+                .forEachOrdered(element -> {\n+                    try {\n+                        processMethod((ExecutableElement) element);\n+                    } catch (IOException e) {\n+                        e.printStackTrace();\n+                    }\n+                });\n+    }\n+\n+    private void processMethod(ExecutableElement method) throws IOException {\n+        final String className = ((TypeElement) method.getEnclosingElement()).getQualifiedName().toString();\n+        final Properties properties = readProperties(className);\n+        final String docComment = processingEnv.getElementUtils().getDocComment(method);\n+        if (docComment == null || !docComment.contains(\"@param\")) {\n+            return;\n+        }\n+        final List<List<String>> lines = Arrays.stream(docComment.split(\"\\\\R\"))\n+                                               .filter(line -> !line.trim().isEmpty())\n+                                               .map(line -> Arrays.stream(line.split(\"\\\\s\"))\n+                                                                  .filter(word -> !word.trim().isEmpty())\n+                                                                  .collect(toImmutableList()))\n+                                               .collect(toImmutableList());\n+        method.getParameters().forEach(param -> {\n+            final StringBuilder stringBuilder = new StringBuilder();\n+            JavaDocParserState state = JavaDocParserState.SEARCHING;\n+            for (List<String> line : lines) {\n+                final List<String> subLine;\n+                if ((line.size() < 3 ||\n+                     !\"@param\".equals(line.get(0)) ||\n+                     !param.getSimpleName().toString().equals(line.get(1))) &&\n+                    state == JavaDocParserState.SEARCHING) {\n+                    continue;\n+                } else if (state == JavaDocParserState.IN_DESCRIPTION &&\n+                           line.size() > 0 &&\n+                           \"@param\".equals(line.get(0))) {\n+                    break;\n+                } else if (state == JavaDocParserState.SEARCHING) {\n+                    subLine = line.subList(2, line.size());\n+                    state = JavaDocParserState.IN_DESCRIPTION;\n+                } else {\n+                    subLine = line;\n+                }\n+                for (String word : subLine) {\n+                    stringBuilder.append(word);\n+                    stringBuilder.append(' ');\n+                }\n+            }", "originalCommit": "17144cc109528b1864fe6964e2f61cfc12169f82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgxOTMzNg==", "url": "https://github.com/line/armeria/pull/2640#discussion_r419819336", "bodyText": "I disagree that 2 is simpler than my approach. I dislike the labeled break...\nI've added tests for @throws and @return and added handling for them...", "author": "hueneburg", "createdAt": "2020-05-05T01:26:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1Nzk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxOTEzMw==", "url": "https://github.com/line/armeria/pull/2640#discussion_r420519133", "bodyText": "I think simplicity is not a problem if it can produce the same result. (I misread your comment)\nIf you don't like the labeled break, that sounds good to me.", "author": "ikhoon", "createdAt": "2020-05-06T02:53:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1Nzk2OA=="}], "type": "inlineReview"}, {"oid": "9b1ef7aa7004043f96b6e0e4adac2ed1d6856af4", "url": "https://github.com/line/armeria/commit/9b1ef7aa7004043f96b6e0e4adac2ed1d6856af4", "message": "Apply reviews", "committedDate": "2020-05-05T01:26:41Z", "type": "commit"}, {"oid": "fd5901513e1c05599252e7299028a028715fec6b", "url": "https://github.com/line/armeria/commit/fd5901513e1c05599252e7299028a028715fec6b", "message": "Merge branch 'use-javadoc-for-parameter-description' of github.com:hueneburg/armeria into use-javadoc-for-parameter-description", "committedDate": "2020-05-05T01:27:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxOTgyMw==", "url": "https://github.com/line/armeria/pull/2640#discussion_r420519823", "bodyText": "Could you add a non-@param annotation such as @since before these lines?", "author": "ikhoon", "createdAt": "2020-05-06T02:56:53Z", "path": "annotation-processor/src/test/resources/DocumentationProcessor/WithJavaDoc.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria;\n+\n+import com.linecorp.armeria.server.annotation.Delete;\n+import com.linecorp.armeria.server.annotation.Get;\n+import com.linecorp.armeria.server.annotation.Param;\n+import com.linecorp.armeria.server.annotation.Post;\n+import com.linecorp.armeria.server.annotation.Put;\n+\n+public class WithJavaDoc {\n+    /**\n+     * A method.\n+     * @param x The x variable in a\n+     * @param y The y variable in a\n+     */\n+    @Post(\"/a\")\n+    public void a(@Param(\"x\") String x,\n+                  @Param(\"y\") String y) {\n+        System.out.println(x + y);\n+    }\n+\n+    /**\n+     * B method.\n+     * @param x The x variable in b\n+     * @param y The y variable in b\n+     */\n+    @Put(\"/b\")\n+    public void b(@Param(\"x\") String x,\n+                  @Param(\"y\") String y) {\n+        System.out.println(x + y);\n+    }\n+\n+    /**\n+     * C method.\n+     * @param x The x variable in c\n+     * @param y The y variable in c\n+     */\n+    @Delete(\"/c/{x}/{y}\")\n+    public void c(@Param(\"x\") String x,\n+                  @Param(\"y\") String y) {\n+        System.out.println(x + y);\n+    }\n+\n+    /**\n+     * D method.\n+     * @param x The x variable in d\n+     * @param y The y variable in d\n+     */\n+    @Get(\"/d/{x}/{y}\")\n+    public void d(@Param(\"x\") String x,\n+                  @Param(\"y\") String y) {\n+        System.out.println(x + y);\n+    }\n+\n+    /**\n+     * hasReturn method.\n+     * @param x The x variable in hasReturn\n+     * @return The number 1\n+     */\n+    @Get\n+    public int hasReturn(@Param(\"x\") String x) {\n+        System.out.println(x);\n+        return 1;\n+    }\n+\n+    /**\n+     * hasThrows method.\n+     * @param x The x variable in hasThrows\n+     * @throws IllegalArgumentException when x is empty", "originalCommit": "fd5901513e1c05599252e7299028a028715fec6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4MDg5MA==", "url": "https://github.com/line/armeria/pull/2640#discussion_r421180890", "bodyText": "done", "author": "hueneburg", "createdAt": "2020-05-07T01:09:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxOTgyMw=="}], "type": "inlineReview"}, {"oid": "4002061ba1bf8b2e531141ab0f83136a67bf4419", "url": "https://github.com/line/armeria/commit/4002061ba1bf8b2e531141ab0f83136a67bf4419", "message": "Add @since to method", "committedDate": "2020-05-06T23:37:48Z", "type": "commit"}, {"oid": "15f197d987fb3b00677150e229f757b02d468244", "url": "https://github.com/line/armeria/commit/15f197d987fb3b00677150e229f757b02d468244", "message": "Rename test files to hopefully not trigger test coverage to include them", "committedDate": "2020-05-07T01:14:59Z", "type": "commit"}, {"oid": "38f3d670d6cdac679aa23da6959c20edb21700ef", "url": "https://github.com/line/armeria/commit/38f3d670d6cdac679aa23da6959c20edb21700ef", "message": "Fix issue with parser", "committedDate": "2020-05-07T02:51:12Z", "type": "commit"}]}