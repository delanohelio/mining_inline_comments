{"pr_number": 3124, "pr_title": "Provide a way to encode and decode Protobuf in annotated services", "pr_createdAt": "2020-10-21T08:43:11Z", "pr_url": "https://github.com/line/armeria/pull/3124", "timeline": [{"oid": "5d90d83a767b8f92082a202bb74c8b034a6d3e4e", "url": "https://github.com/line/armeria/commit/5d90d83a767b8f92082a202bb74c8b034a6d3e4e", "message": "Provide a way to encode and decode Protobuf in annotated services\n\nMotivation:\n\nProtocol Buffers is an universal serialization protocol. The usage is not limit to gRPC.\nIt could be used an HTTP payload for REST API.\nIt is also useful when building an HTTP proxy server in front of a gRPC server.\n\nModifications:\n\n- Add ProtobufRequestConverterFunction that decodes Protocol Buffers or JSON body into Protobuf Message type\n- Add ProtobufResponseConverterFunction that encodes Protobuf Message(s) into Protocol Buffers or JSON body\n- These converters are applied only when the content type is:\n  - `application/protobuf`\n  - `application/json; charset=utf-8`\n  - Or subtype contains `protobuf` because there is no standard for protobuf content type.\n    See https://stackoverflow.com/questions/30505408/what-is-the-correct-protobuf-content-type\n\nResult:\n\n- You can now encode and decode Protobuf Message using annotated service automatically.\n- Closes #3088", "committedDate": "2020-10-21T08:37:06Z", "type": "commit"}, {"oid": "ca3b1573baae1bbc0d3e0f671b17cb4e1a483af6", "url": "https://github.com/line/armeria/commit/ca3b1573baae1bbc0d3e0f671b17cb4e1a483af6", "message": "checkstyle", "committedDate": "2020-10-21T08:47:14Z", "type": "commit"}, {"oid": "5577893a711a4c3e34ceb10a29cc9383b25beeb3", "url": "https://github.com/line/armeria/commit/5577893a711a4c3e34ceb10a29cc9383b25beeb3", "message": "Merge branch 'master' into protobuf-response-converter", "committedDate": "2020-10-23T07:29:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc0NjA1MQ==", "url": "https://github.com/line/armeria/pull/3124#discussion_r510746051", "bodyText": "I was just wondering how slower is Method.invoke(...) than MethodHandle.invoke(...).\nBenchmark                          Mode  Cnt         Score         Error  Units\nMethodCallBenchmark.directCall    thrpt    5  30697469.267 \u00b1 5620688.880  ops/s\nMethodCallBenchmark.method        thrpt    5  24412855.684 \u00b1 4318917.364  ops/s\nMethodCallBenchmark.methodHandle  thrpt    5  29439498.151 \u00b1 1840979.485  ops/s\n\nThere is 10% ~ 20% performance degression in Method.invoke(...). Let me change this with MethodHandle. :-)", "author": "ikhoon", "createdAt": "2020-10-23T09:11:03Z", "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.grpc;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.ParameterizedType;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, Method> methodCache = new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = jsonParser;\n+        this.extensionRegistry = extensionRegistry;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                 Class<?> expectedResultType,\n+                                 @Nullable ParameterizedType expectedParameterizedResultType) throws Exception {\n+\n+        final MediaType contentType = request.contentType();\n+        if (Message.class.isAssignableFrom(expectedResultType)) {\n+            final Message.Builder messageBuilder = getMessageBuilder(expectedResultType);\n+\n+            if (contentType == null ||\n+                contentType.subtype().contains(\"protobuf\") || contentType.is(MediaType.OCTET_STREAM)) {\n+                return messageBuilder.mergeFrom(request.content().array(), extensionRegistry).build();\n+            }\n+\n+            if (isJson(contentType)) {\n+                jsonParser.merge(request.contentUtf8(), messageBuilder);\n+                return messageBuilder.build();\n+            }\n+        }\n+\n+        if (isJson(contentType) && expectedParameterizedResultType != null) {\n+            final int collectionType;\n+            if (List.class.isAssignableFrom(expectedResultType)) {\n+                collectionType = 1;\n+            } else if (Set.class.isAssignableFrom(expectedResultType)) {\n+                collectionType = 2;\n+            } else {\n+                collectionType = 0;\n+            }\n+\n+            if (collectionType > 0) {\n+                final Class<?> typeArgument =\n+                        (Class<?>) expectedParameterizedResultType.getActualTypeArguments()[0];\n+                if (Message.class.isAssignableFrom(typeArgument)) {\n+                    final String content = request.content(contentType.charset(StandardCharsets.UTF_8));\n+\n+                    final JsonNode jsonNode = mapper.readTree(content);\n+                    if (jsonNode.isArray()) {\n+                        final ImmutableCollection.Builder<Message> builder;\n+                        if (collectionType == 1) {\n+                            builder = ImmutableList.builderWithExpectedSize(jsonNode.size());\n+                        } else {\n+                            builder = ImmutableSet.builderWithExpectedSize(jsonNode.size());\n+                        }\n+                        for (JsonNode node : jsonNode) {\n+                            final Message.Builder messageBuilder = getMessageBuilder(typeArgument);\n+                            jsonParser.merge(mapper.writeValueAsString(node), messageBuilder);\n+                            builder.add(messageBuilder.build());\n+                        }\n+\n+                        return builder.build();\n+                    }\n+                }\n+            }\n+        }\n+\n+        return RequestConverterFunction.fallthrough();\n+    }\n+\n+    private static boolean isJson(@Nullable MediaType contentType) {\n+        return contentType != null &&\n+               (contentType.is(MediaType.JSON) || contentType.subtype().endsWith(\"+json\"));\n+    }\n+\n+    private static Message.Builder getMessageBuilder(Class<?> clazz) throws Exception {\n+        Method method = methodCache.get(clazz);\n+        if (method == null) {\n+            method = clazz.getMethod(\"newBuilder\");\n+            methodCache.put(clazz, method);\n+        }\n+        return (Message.Builder) method.invoke(clazz);", "originalCommit": "ca3b1573baae1bbc0d3e0f671b17cb4e1a483af6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "07fca0ca316c4add5ae471b856ef5946580b9053", "url": "https://github.com/line/armeria/commit/07fca0ca316c4add5ae471b856ef5946580b9053", "message": "Use MethodHandle", "committedDate": "2020-10-23T09:58:33Z", "type": "commit"}, {"oid": "07fca0ca316c4add5ae471b856ef5946580b9053", "url": "https://github.com/line/armeria/commit/07fca0ca316c4add5ae471b856ef5946580b9053", "message": "Use MethodHandle", "committedDate": "2020-10-23T09:58:33Z", "type": "forcePushed"}, {"oid": "e5293368f380ca7d6550bdfa7852f2bad3e9297d", "url": "https://github.com/line/armeria/commit/e5293368f380ca7d6550bdfa7852f2bad3e9297d", "message": "Update error message", "committedDate": "2020-10-23T10:02:17Z", "type": "commit"}, {"oid": "ea9688bba5a4e9199702c84a732f6d312a1ea241", "url": "https://github.com/line/armeria/commit/ea9688bba5a4e9199702c84a732f6d312a1ea241", "message": "Clean up", "committedDate": "2020-10-23T10:09:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg4NzEzNQ==", "url": "https://github.com/line/armeria/pull/3124#discussion_r511887135", "bodyText": "We use SPI to find ResponseConverterFunction implementations.\nShouldn't we use the same approach for RequestConverterFunction?", "author": "minwoox", "createdAt": "2020-10-26T11:20:22Z", "path": "core/src/main/java/com/linecorp/armeria/internal/server/annotation/AnnotatedValueResolver.java", "diffHunk": "@@ -90,18 +90,43 @@\n final class AnnotatedValueResolver {\n     private static final Logger logger = LoggerFactory.getLogger(AnnotatedValueResolver.class);\n \n-    private static final List<RequestObjectResolver> defaultRequestConverters = ImmutableList.of(\n-            (resolverContext, expectedResultType, expectedParameterizedResultType, beanFactoryId) -> {\n-                final AnnotatedBeanFactory<?> factory = AnnotatedBeanFactoryRegistry.find(beanFactoryId);\n-                if (factory == null) {\n-                    return RequestConverterFunction.fallthrough();\n-                } else {\n-                    return factory.create(resolverContext);\n-                }\n-            },\n-            RequestObjectResolver.of(new JacksonRequestConverterFunction()),\n-            RequestObjectResolver.of(new StringRequestConverterFunction()),\n-            RequestObjectResolver.of(new ByteArrayRequestConverterFunction()));\n+    @Nullable\n+    private static final RequestConverterFunction protobufRequestConverterFunction;\n+\n+    static {\n+        RequestConverterFunction converterFunction;\n+        try {\n+            final Class<?> protobufConverterClass =\n+                    Class.forName(\"com.linecorp.armeria.server.grpc.ProtobufRequestConverterFunction\");", "originalCommit": "ea9688bba5a4e9199702c84a732f6d312a1ea241", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5NjAyMA==", "url": "https://github.com/line/armeria/pull/3124#discussion_r511896020", "bodyText": "That's a good suggestion. Let me add a SPI provider.", "author": "ikhoon", "createdAt": "2020-10-26T11:37:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg4NzEzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5MTM2OA==", "url": "https://github.com/line/armeria/pull/3124#discussion_r511891368", "bodyText": "Shouldn't we make a separate module so that the user doesn't have to bring gRPC dependencies to use this?", "author": "minwoox", "createdAt": "2020-10-26T11:28:32Z", "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.grpc;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {", "originalCommit": "ea9688bba5a4e9199702c84a732f6d312a1ea241", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5NjUwNQ==", "url": "https://github.com/line/armeria/pull/3124#discussion_r511896505", "bodyText": "I thought this feature would be interesting to some users who want to gRPC service and client already. Do we need armeria-protobuf? \ud83e\udd14", "author": "ikhoon", "createdAt": "2020-10-26T11:38:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5MTM2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5ODY1Ng==", "url": "https://github.com/line/armeria/pull/3124#discussion_r511898656", "bodyText": "I'm not sure. \ud83e\udd23  @anuraaga Do you have any suggestions?", "author": "minwoox", "createdAt": "2020-10-26T11:42:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5MTM2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQyODczMA==", "url": "https://github.com/line/armeria/pull/3124#discussion_r516428730", "bodyText": "Sorry for late reply - it does seem strange to have this in gRPC package since it seems to have nothing to do with gRPC. Perhaps core with compileOnly dependency on protobuf so it's next to the other annotated service functionality? not sure", "author": "anuraaga", "createdAt": "2020-11-03T04:59:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5MTM2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ4MDcwNQ==", "url": "https://github.com/line/armeria/pull/3124#discussion_r516480705", "bodyText": "Yeah, the code is too small to create a seperate module. Let me move this code to core and add @UnstableApi in case we need armeria-protobuf later.", "author": "ikhoon", "createdAt": "2020-11-03T08:04:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5MTM2OA=="}], "type": "inlineReview"}, {"oid": "315876939d7dcb885d0d878cc65fb3ce8c1645cf", "url": "https://github.com/line/armeria/commit/315876939d7dcb885d0d878cc65fb3ce8c1645cf", "message": "Add RequestConverterFunctionProvider", "committedDate": "2020-10-27T15:35:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4MzY5OA==", "url": "https://github.com/line/armeria/pull/3124#discussion_r515583698", "bodyText": "defaultRequestConverterFunctions and defaultRequestObjectResolvers?", "author": "trustin", "createdAt": "2020-11-01T06:50:01Z", "path": "core/src/main/java/com/linecorp/armeria/internal/server/annotation/AnnotatedValueResolver.java", "diffHunk": "@@ -90,18 +92,40 @@\n final class AnnotatedValueResolver {\n     private static final Logger logger = LoggerFactory.getLogger(AnnotatedValueResolver.class);\n \n-    private static final List<RequestObjectResolver> defaultRequestConverters = ImmutableList.of(\n-            (resolverContext, expectedResultType, expectedParameterizedResultType, beanFactoryId) -> {\n-                final AnnotatedBeanFactory<?> factory = AnnotatedBeanFactoryRegistry.find(beanFactoryId);\n-                if (factory == null) {\n-                    return RequestConverterFunction.fallthrough();\n-                } else {\n-                    return factory.create(resolverContext);\n-                }\n-            },\n-            RequestObjectResolver.of(new JacksonRequestConverterFunction()),\n-            RequestObjectResolver.of(new StringRequestConverterFunction()),\n-            RequestObjectResolver.of(new ByteArrayRequestConverterFunction()));\n+    private static final List<RequestConverterFunction> defaultRequestFunctions = ImmutableList.of(\n+            new JacksonRequestConverterFunction(),\n+            new StringRequestConverterFunction(),\n+            new ByteArrayRequestConverterFunction());\n+\n+    private static final List<RequestObjectResolver> defaultRequestConverters;", "originalCommit": "315876939d7dcb885d0d878cc65fb3ce8c1645cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4Mzg4MQ==", "url": "https://github.com/line/armeria/pull/3124#discussion_r515583881", "bodyText": "cannot -> failed to?", "author": "trustin", "createdAt": "2020-11-01T06:51:43Z", "path": "core/src/main/java/com/linecorp/armeria/internal/server/annotation/AnnotatedValueResolver.java", "diffHunk": "@@ -1423,4 +1463,34 @@ Object convert(ResolverContext resolverContext, Class<?> expectedResultType,\n             super(\"No parameters found from: \" + name);\n         }\n     }\n+\n+    private static final class CompositeRequestConverterFunction implements RequestConverterFunction {\n+\n+        private final List<RequestConverterFunction> functions;\n+\n+        private CompositeRequestConverterFunction(List<RequestConverterFunction> functions) {\n+            this.functions = functions;\n+        }\n+\n+        @Nullable\n+        @Override\n+        public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                     Class<?> expectedResultType,\n+                                     @Nullable ParameterizedType expectedParameterizedResultType)\n+                throws Exception {\n+            for (RequestConverterFunction function : functions) {\n+                try {\n+                    return function.convertRequest(ctx, request, expectedResultType,\n+                                                   expectedParameterizedResultType);\n+                } catch (FallthroughException ignore) {\n+                    // Do nothing.\n+                } catch (Exception e) {\n+                    throw new IllegalStateException(\n+                            \"Request converter \" + function.getClass().getName() +\n+                            \" cannot convert an \" + request + \" to a \" + expectedResultType, e);", "originalCommit": "315876939d7dcb885d0d878cc65fb3ce8c1645cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NDA5MQ==", "url": "https://github.com/line/armeria/pull/3124#discussion_r515584091", "bodyText": "Could you explain why we need to skip Protobuf messages here?", "author": "trustin", "createdAt": "2020-11-01T06:54:10Z", "path": "core/src/main/java/com/linecorp/armeria/server/annotation/JacksonRequestConverterFunction.java", "diffHunk": "@@ -106,6 +120,10 @@ public Object convertRequest(\n                 }\n             }\n \n+            if (isProtobufType(expectedResultType, expectedParameterizedResultType)) {\n+                return RequestConverterFunction.fallthrough();\n+            }", "originalCommit": "315876939d7dcb885d0d878cc65fb3ce8c1645cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwMzU3Mg==", "url": "https://github.com/line/armeria/pull/3124#discussion_r516403572", "bodyText": "Ah... We don't need to skip ProtoBuf message anymore.\nBefore implementing RequestConverterFunctionProvider, ProtobufRequestConverterFunction is registered after JacksonRequestConverterFunction.\nImmutableList.of(\n            new JacksonRequestConverterFunction(),\n            new ProtobufRequestConverterFunction(),\n            new StringRequestConverterFunction(),\n            new ByteArrayRequestConverterFunction());\nBut now, RequestConverterFunctionProviders have always higher priorities than defaultRequestConverterFunctions.", "author": "ikhoon", "createdAt": "2020-11-03T02:56:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NDA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTI1NA==", "url": "https://github.com/line/armeria/pull/3124#discussion_r515585254", "bodyText": "Would it be better using toInputStream() instead of array() so that HttpData does not create a backing array?", "author": "trustin", "createdAt": "2020-11-01T07:07:12Z", "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.grpc;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, MethodHandle> methodCache =\n+            new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private static final MethodHandle unknownMethodHandle;\n+\n+    static {\n+        final MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        final MethodType mt = methodType(void.class);\n+\n+        MethodHandle methodHandle;\n+        try {\n+            methodHandle = publicLookup.findConstructor(ProtobufRequestConverterFunction.class, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            methodHandle = null;\n+        }\n+        assert methodHandle != null;\n+        unknownMethodHandle = methodHandle;\n+    }\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+    private final ResultType resultType;\n+\n+    ProtobufRequestConverterFunction(ResultType resultType) {\n+        jsonParser = defaultJsonParser;\n+        extensionRegistry = ExtensionRegistry.getEmptyRegistry();\n+        this.resultType = resultType;\n+    }\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = jsonParser;\n+        this.extensionRegistry = extensionRegistry;\n+        resultType = ResultType.UNKNOWN;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                 Class<?> expectedResultType,\n+                                 @Nullable ParameterizedType expectedParameterizedResultType) throws Exception {\n+\n+        final MediaType contentType = request.contentType();\n+        if (resultType == ResultType.PROTOBUF ||\n+            (resultType == ResultType.UNKNOWN && Message.class.isAssignableFrom(expectedResultType))) {\n+            final Message.Builder messageBuilder = getMessageBuilder(expectedResultType);\n+\n+            if (contentType == null ||\n+                contentType.subtype().contains(\"protobuf\") || contentType.is(MediaType.OCTET_STREAM)) {\n+                return messageBuilder.mergeFrom(request.content().array(), extensionRegistry).build();", "originalCommit": "315876939d7dcb885d0d878cc65fb3ce8c1645cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTM0OQ==", "url": "https://github.com/line/armeria/pull/3124#discussion_r515585349", "bodyText": "Do we need to support map as well?", "author": "trustin", "createdAt": "2020-11-01T07:08:48Z", "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.grpc;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, MethodHandle> methodCache =\n+            new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private static final MethodHandle unknownMethodHandle;\n+\n+    static {\n+        final MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        final MethodType mt = methodType(void.class);\n+\n+        MethodHandle methodHandle;\n+        try {\n+            methodHandle = publicLookup.findConstructor(ProtobufRequestConverterFunction.class, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            methodHandle = null;\n+        }\n+        assert methodHandle != null;\n+        unknownMethodHandle = methodHandle;\n+    }\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+    private final ResultType resultType;\n+\n+    ProtobufRequestConverterFunction(ResultType resultType) {\n+        jsonParser = defaultJsonParser;\n+        extensionRegistry = ExtensionRegistry.getEmptyRegistry();\n+        this.resultType = resultType;\n+    }\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = jsonParser;\n+        this.extensionRegistry = extensionRegistry;\n+        resultType = ResultType.UNKNOWN;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                 Class<?> expectedResultType,\n+                                 @Nullable ParameterizedType expectedParameterizedResultType) throws Exception {\n+\n+        final MediaType contentType = request.contentType();\n+        if (resultType == ResultType.PROTOBUF ||\n+            (resultType == ResultType.UNKNOWN && Message.class.isAssignableFrom(expectedResultType))) {\n+            final Message.Builder messageBuilder = getMessageBuilder(expectedResultType);\n+\n+            if (contentType == null ||\n+                contentType.subtype().contains(\"protobuf\") || contentType.is(MediaType.OCTET_STREAM)) {\n+                return messageBuilder.mergeFrom(request.content().array(), extensionRegistry).build();\n+            }\n+\n+            if (isJson(contentType)) {\n+                jsonParser.merge(request.contentUtf8(), messageBuilder);\n+                return messageBuilder.build();\n+            }\n+        }\n+\n+        if (isJson(contentType) && expectedParameterizedResultType != null) {\n+            ResultType resultType = this.resultType;\n+            if (resultType == ResultType.UNKNOWN) {\n+                if (List.class.isAssignableFrom(expectedResultType)) {\n+                    resultType = ResultType.LIST_PROTOBUF;\n+                } else if (Set.class.isAssignableFrom(expectedResultType)) {\n+                    resultType = ResultType.SET_PROTOBUF;\n+                }\n+            }\n+\n+            if (resultType == ResultType.LIST_PROTOBUF || resultType == ResultType.SET_PROTOBUF) {\n+                final Class<?> typeArgument =\n+                        (Class<?>) expectedParameterizedResultType.getActualTypeArguments()[0];\n+                if (Message.class.isAssignableFrom(typeArgument)) {\n+                    final String content = request.content(contentType.charset(StandardCharsets.UTF_8));\n+\n+                    final JsonNode jsonNode = mapper.readTree(content);\n+                    if (jsonNode.isArray()) {\n+                        final ImmutableCollection.Builder<Message> builder;\n+                        if (resultType == ResultType.LIST_PROTOBUF) {\n+                            builder = ImmutableList.builderWithExpectedSize(jsonNode.size());\n+                        } else {\n+                            builder = ImmutableSet.builderWithExpectedSize(jsonNode.size());\n+                        }\n+                        for (JsonNode node : jsonNode) {\n+                            final Message.Builder messageBuilder = getMessageBuilder(typeArgument);\n+                            jsonParser.merge(mapper.writeValueAsString(node), messageBuilder);\n+                            builder.add(messageBuilder.build());\n+                        }\n+\n+                        return builder.build();\n+                    }\n+                }\n+            }\n+        }\n+\n+        return RequestConverterFunction.fallthrough();\n+    }\n+\n+    private static boolean isJson(@Nullable MediaType contentType) {\n+        return contentType != null &&\n+               (contentType.is(MediaType.JSON) || contentType.subtype().endsWith(\"+json\"));\n+    }\n+\n+    private static Message.Builder getMessageBuilder(Class<?> clazz) {\n+        final MethodHandle methodHandle = methodCache.computeIfAbsent(clazz, key -> {\n+            try {\n+                final Class<?> builderClass = Class.forName(key.getName() + \"$Builder\");\n+                final Lookup publicLookup = MethodHandles.publicLookup();\n+                return publicLookup.findStatic(key, \"newBuilder\", methodType(builderClass));\n+            } catch (NoSuchMethodException | IllegalAccessException | ClassNotFoundException ignored) {\n+                return unknownMethodHandle;\n+            }\n+        });\n+        if (methodHandle == unknownMethodHandle) {\n+            throw new IllegalStateException(\"Failed to find a static newBuilder() method from \" + clazz);\n+        }\n+        try {\n+            return (Message.Builder) methodHandle.invoke();\n+        } catch (Throwable throwable) {\n+            throw new IllegalStateException(\n+                    \"Failed to create an empty instance of \" + clazz + \" using newBuilder() method\", throwable);\n+        }\n+    }\n+\n+    enum ResultType {\n+        UNKNOWN,\n+        PROTOBUF,\n+        LIST_PROTOBUF,\n+        SET_PROTOBUF", "originalCommit": "315876939d7dcb885d0d878cc65fb3ce8c1645cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY4MDgzMg==", "url": "https://github.com/line/armeria/pull/3124#discussion_r516680832", "bodyText": "MAP_PROTOBUF is added for JSON format.", "author": "ikhoon", "createdAt": "2020-11-03T13:52:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTQ1Mg==", "url": "https://github.com/line/armeria/pull/3124#discussion_r515585452", "bodyText": "an -> a", "author": "trustin", "createdAt": "2020-11-01T07:09:48Z", "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ProtobufResponseConverterFunctionProvider.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2018 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.grpc;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.stream.Stream;\n+\n+import org.reactivestreams.Publisher;\n+\n+import com.google.protobuf.MessageLite;\n+\n+import com.linecorp.armeria.server.annotation.ExceptionHandlerFunction;\n+import com.linecorp.armeria.server.annotation.ResponseConverterFunction;\n+import com.linecorp.armeria.server.annotation.ResponseConverterFunctionProvider;\n+\n+/**\n+ * Provides an {@link ProtobufResponseConverterFunction} to annotated services.", "originalCommit": "315876939d7dcb885d0d878cc65fb3ce8c1645cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTU4MQ==", "url": "https://github.com/line/armeria/pull/3124#discussion_r515585581", "bodyText": "Could you also check other classes and add @UnstableApi if applicable?", "author": "trustin", "createdAt": "2020-11-01T07:11:16Z", "path": "core/src/main/java/com/linecorp/armeria/server/annotation/RequestConverterFunctionProvider.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2018 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.annotation;\n+\n+import java.lang.reflect.Type;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+\n+/**\n+ * A {@link RequestConverterFunction} provider interface which creates a new\n+ * {@link RequestConverterFunction} for converting an {@link AggregatedHttpRequest} to an object of\n+ * the given type.\n+ */\n+@UnstableApi", "originalCommit": "315876939d7dcb885d0d878cc65fb3ce8c1645cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "545a4421eaa826dd2f34b2ca8021c2dac00aab0a", "url": "https://github.com/line/armeria/commit/545a4421eaa826dd2f34b2ca8021c2dac00aab0a", "message": "Address comments by @minwoox and @trustin / Add 'armeria-protobuf' module", "committedDate": "2020-11-03T13:46:34Z", "type": "commit"}, {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713", "url": "https://github.com/line/armeria/commit/1a3aad6b3e5df0a578985812008dea9bc82de713", "message": "Typo", "committedDate": "2020-11-03T13:59:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU1NTg1Ng==", "url": "https://github.com/line/armeria/pull/3124#discussion_r518555856", "bodyText": "How about moving this class to another utility class with other CompositeXXXConverterFunction so that logics are put together?", "author": "minwoox", "createdAt": "2020-11-06T06:57:14Z", "path": "core/src/main/java/com/linecorp/armeria/internal/server/annotation/AnnotatedValueResolver.java", "diffHunk": "@@ -1423,4 +1463,34 @@ Object convert(ResolverContext resolverContext, Class<?> expectedResultType,\n             super(\"No parameters found from: \" + name);\n         }\n     }\n+\n+    private static final class CompositeRequestConverterFunction implements RequestConverterFunction {", "originalCommit": "1a3aad6b3e5df0a578985812008dea9bc82de713", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU1NjYyMw==", "url": "https://github.com/line/armeria/pull/3124#discussion_r518556623", "bodyText": "is either?", "author": "minwoox", "createdAt": "2020-11-06T06:59:40Z", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or", "originalCommit": "1a3aad6b3e5df0a578985812008dea9bc82de713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4MjQ4Mw==", "url": "https://github.com/line/armeria/pull/3124#discussion_r519582483", "bodyText": "either one of ... PROTOBUF and ... STREAM or the ...? (for disambiguation)", "author": "trustin", "createdAt": "2020-11-09T06:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU1NjYyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU1NzIzOA==", "url": "https://github.com/line/armeria/pull/3124#discussion_r518557238", "bodyText": "self-delimiting character?", "author": "minwoox", "createdAt": "2020-11-06T07:01:34Z", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.", "originalCommit": "1a3aad6b3e5df0a578985812008dea9bc82de713", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU1NzYwNQ==", "url": "https://github.com/line/armeria/pull/3124#discussion_r518557605", "bodyText": "How about telling the users that making another message which wraps the sequence of messages?", "author": "minwoox", "createdAt": "2020-11-06T07:02:50Z", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.", "originalCommit": "1a3aad6b3e5df0a578985812008dea9bc82de713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4MzA2MA==", "url": "https://github.com/line/armeria/pull/3124#discussion_r519583060", "bodyText": "Could we also reorganize this paragraph like this, so it's easier to understand:\n<h3>Conversion of multiple Protobuf messages</h3>\nA sequence of Protocol Buffer messages cannot be handled ...,\nbecause the Protocol Buffers specification does not have an ...\nHowever, ... supported when converting to JSON, ...", "author": "trustin", "createdAt": "2020-11-09T06:52:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU1NzYwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyMjA2Ng==", "url": "https://github.com/line/armeria/pull/3124#discussion_r518622066", "bodyText": "nit: how about making a private constructor and delegating setting?", "author": "minwoox", "createdAt": "2020-11-06T09:22:26Z", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+@UnstableApi\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, MethodHandle> methodCache =\n+            new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private static final MethodHandle unknownMethodHandle;\n+\n+    static {\n+        final MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        final MethodType mt = methodType(void.class);\n+\n+        MethodHandle methodHandle;\n+        try {\n+            methodHandle = publicLookup.findConstructor(ProtobufRequestConverterFunction.class, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            methodHandle = null;\n+        }\n+        assert methodHandle != null;\n+        unknownMethodHandle = methodHandle;\n+    }\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+    private final ResultType resultType;\n+\n+    ProtobufRequestConverterFunction(ResultType resultType) {\n+        jsonParser = defaultJsonParser;\n+        extensionRegistry = ExtensionRegistry.getEmptyRegistry();\n+        this.resultType = requireNonNull(resultType, \"resultType\");\n+    }\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = requireNonNull(jsonParser, \"jsonParser\");\n+        this.extensionRegistry = requireNonNull(extensionRegistry, \"extensionRegistry\");\n+        resultType = ResultType.UNKNOWN;", "originalCommit": "1a3aad6b3e5df0a578985812008dea9bc82de713", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyNjc0NA==", "url": "https://github.com/line/armeria/pull/3124#discussion_r518626744", "bodyText": "Shouldn't we use charset?\njsonParser.merge(request.content().toReader(contentType.charset(Charsets.UTF_8)), ...", "author": "minwoox", "createdAt": "2020-11-06T09:30:04Z", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+@UnstableApi\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, MethodHandle> methodCache =\n+            new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private static final MethodHandle unknownMethodHandle;\n+\n+    static {\n+        final MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        final MethodType mt = methodType(void.class);\n+\n+        MethodHandle methodHandle;\n+        try {\n+            methodHandle = publicLookup.findConstructor(ProtobufRequestConverterFunction.class, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            methodHandle = null;\n+        }\n+        assert methodHandle != null;\n+        unknownMethodHandle = methodHandle;\n+    }\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+    private final ResultType resultType;\n+\n+    ProtobufRequestConverterFunction(ResultType resultType) {\n+        jsonParser = defaultJsonParser;\n+        extensionRegistry = ExtensionRegistry.getEmptyRegistry();\n+        this.resultType = requireNonNull(resultType, \"resultType\");\n+    }\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = requireNonNull(jsonParser, \"jsonParser\");\n+        this.extensionRegistry = requireNonNull(extensionRegistry, \"extensionRegistry\");\n+        resultType = ResultType.UNKNOWN;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                 Class<?> expectedResultType,\n+                                 @Nullable ParameterizedType expectedParameterizedResultType) throws Exception {\n+\n+        final MediaType contentType = request.contentType();\n+        if (resultType == ResultType.PROTOBUF ||\n+            (resultType == ResultType.UNKNOWN && Message.class.isAssignableFrom(expectedResultType))) {\n+            final Message.Builder messageBuilder = getMessageBuilder(expectedResultType);\n+\n+            if (contentType == null ||\n+                contentType.subtype().contains(\"protobuf\") || contentType.is(MediaType.OCTET_STREAM)) {\n+                try (InputStream is = request.content().toInputStream()) {\n+                    return messageBuilder.mergeFrom(is, extensionRegistry).build();\n+                }\n+            }\n+\n+            if (isJson(contentType)) {\n+                jsonParser.merge(request.contentUtf8(), messageBuilder);", "originalCommit": "1a3aad6b3e5df0a578985812008dea9bc82de713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTYzMjA0NQ==", "url": "https://github.com/line/armeria/pull/3124#discussion_r519632045", "bodyText": "I thought UTF-8 is only used for JSON.\nJust out of curiosity, which is better toReader(Charset) or content(Charset) here?\nIf you are also curious, let me run a simple benchmark for it. \ud83d\ude09", "author": "ikhoon", "createdAt": "2020-11-09T08:35:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyNjc0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTYzNTM0OQ==", "url": "https://github.com/line/armeria/pull/3124#discussion_r519635349", "bodyText": "I think using the reader was more efficient but not 100% sure. \ud83d\ude04\nCould you run the benchmark if you don't mind?", "author": "minwoox", "createdAt": "2020-11-09T08:41:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyNjc0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY4MTEyOA==", "url": "https://github.com/line/armeria/pull/3124#discussion_r519681128", "bodyText": "There is no big difference among them. contentUtf8() is 3% ~ 4% faster. It seems that within tolerance.\nGrpcParseBenchmark.parseWithReader  thrpt    5  777.928 \u00b1 4.739  ops/s\nGrpcParseBenchmark.parseWithString  thrpt    5  806.419 \u00b1 8.637  ops/s\n\nThe benchmark code:\nstatic final String json = JsonFormat.printer().print(SEARCH_RESPONSE);\nstatic final HttpData httpData = HttpData.wrap(json.getBytes(StandardCharsets.UTF_8));\nstatic final Parser parser = JsonFormat.parser();\n\n@Benchmark\npublic SearchResponse parseWithString() throws InvalidProtocolBufferException {\n    final SearchResponse.Builder builder = SearchResponse.newBuilder();\n    parser.merge(httpData.toStringUtf8(), builder);\n    return builder.build();\n}\n\n@Benchmark\npublic SearchResponse parseWithReader() throws IOException {\n    final SearchResponse.Builder builder = SearchResponse.newBuilder();\n    parser.merge(httpData.toReader(StandardCharsets.UTF_8), builder);\n    return builder.build();\n}", "author": "ikhoon", "createdAt": "2020-11-09T09:54:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyNjc0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY4NDc1Mw==", "url": "https://github.com/line/armeria/pull/3124#discussion_r519684753", "bodyText": "Thanks for the test, yeah using contentUtf8 seems more efficient. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-11-09T09:59:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyNjc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYzNjEwNw==", "url": "https://github.com/line/armeria/pull/3124#discussion_r518636107", "bodyText": "So this is not working if the charset is not UTF_8, right?", "author": "minwoox", "createdAt": "2020-11-06T09:46:04Z", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.linecorp.armeria.internal.server.ResponseConversionUtil.aggregateFrom;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+\n+import com.google.common.collect.Streams;\n+import com.google.protobuf.MessageLite;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Printer;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.ResponseConverterFunction;\n+\n+/**\n+ * A {@link ResponseConverterFunction} which creates an {@link HttpResponse} with\n+ * {@code content-type: application/protobuf} or {@code content-type: application/json; charset=utf-8}.\n+ * If the returned object is instance of {@link MessageLite}, the object can be converted to\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/encoding\">Protocol Buffers</a> or\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/proto3#json\">JSON</a> format.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore if the returned object is instance of {@link Publisher}, {@link Stream} or {@link Iterable}\n+ * which produces {@link MessageLite}s, the object is only able to convert to\n+ * <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> format.\n+ *\n+ * <p>Note that this {@link ResponseConverterFunction} is applied to the annotated service by default,\n+ * so you don't have to set explicitly unless you want to use your own {@link Printer}.\n+ */\n+@UnstableApi\n+public final class ProtobufResponseConverterFunction implements ResponseConverterFunction {\n+\n+    private static final Printer defaultJsonPrinter = JsonFormat.printer();\n+\n+    private final Printer jsonPrinter;\n+\n+    /**\n+     * Creates an instance with the default {@link Printer}.\n+     */\n+    public ProtobufResponseConverterFunction() {\n+        this(defaultJsonPrinter);\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Printer}.\n+     */\n+    public ProtobufResponseConverterFunction(Printer jsonPrinter) {\n+        this.jsonPrinter = requireNonNull(jsonPrinter, \"jsonPrinter\");\n+    }\n+\n+    @Override\n+    public HttpResponse convertResponse(ServiceRequestContext ctx, ResponseHeaders headers,\n+                                        @Nullable Object result, HttpHeaders trailers) throws Exception {\n+        final MediaType mediaType = headers.contentType();\n+        if (result instanceof MessageLite) {\n+            if (mediaType != null) {\n+                if (mediaType.is(MediaType.JSON) || mediaType.subtype().endsWith(\"+json\")) {\n+                    final Charset charset = mediaType.charset(StandardCharsets.UTF_8);\n+                    if (charset.contains(StandardCharsets.UTF_8)) {", "originalCommit": "1a3aad6b3e5df0a578985812008dea9bc82de713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NTc0Nw==", "url": "https://github.com/line/armeria/pull/3124#discussion_r519585747", "bodyText": "Maybe we can support other encodings as well?", "author": "trustin", "createdAt": "2020-11-09T07:00:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYzNjEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0MTY0Mg==", "url": "https://github.com/line/armeria/pull/3124#discussion_r519541642", "bodyText": "Maybe check more strictly?", "author": "trustin", "createdAt": "2020-11-09T04:03:23Z", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.linecorp.armeria.internal.server.ResponseConversionUtil.aggregateFrom;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+\n+import com.google.common.collect.Streams;\n+import com.google.protobuf.MessageLite;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Printer;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.ResponseConverterFunction;\n+\n+/**\n+ * A {@link ResponseConverterFunction} which creates an {@link HttpResponse} with\n+ * {@code content-type: application/protobuf} or {@code content-type: application/json; charset=utf-8}.\n+ * If the returned object is instance of {@link MessageLite}, the object can be converted to\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/encoding\">Protocol Buffers</a> or\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/proto3#json\">JSON</a> format.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore if the returned object is instance of {@link Publisher}, {@link Stream} or {@link Iterable}\n+ * which produces {@link MessageLite}s, the object is only able to convert to\n+ * <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> format.\n+ *\n+ * <p>Note that this {@link ResponseConverterFunction} is applied to the annotated service by default,\n+ * so you don't have to set explicitly unless you want to use your own {@link Printer}.\n+ */\n+@UnstableApi\n+public final class ProtobufResponseConverterFunction implements ResponseConverterFunction {\n+\n+    private static final Printer defaultJsonPrinter = JsonFormat.printer();\n+\n+    private final Printer jsonPrinter;\n+\n+    /**\n+     * Creates an instance with the default {@link Printer}.\n+     */\n+    public ProtobufResponseConverterFunction() {\n+        this(defaultJsonPrinter);\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Printer}.\n+     */\n+    public ProtobufResponseConverterFunction(Printer jsonPrinter) {\n+        this.jsonPrinter = requireNonNull(jsonPrinter, \"jsonPrinter\");\n+    }\n+\n+    @Override\n+    public HttpResponse convertResponse(ServiceRequestContext ctx, ResponseHeaders headers,\n+                                        @Nullable Object result, HttpHeaders trailers) throws Exception {\n+        final MediaType mediaType = headers.contentType();\n+        if (result instanceof MessageLite) {\n+            if (mediaType != null) {\n+                if (mediaType.is(MediaType.JSON) || mediaType.subtype().endsWith(\"+json\")) {\n+                    final Charset charset = mediaType.charset(StandardCharsets.UTF_8);\n+                    if (charset.contains(StandardCharsets.UTF_8)) {\n+                        return HttpResponse.of(headers, toJsonHttpData(result), trailers);\n+                    }\n+                }\n+                return HttpResponse.of(headers, toProtobuf(result), trailers);\n+            }\n+\n+            return HttpResponse.of(headers.toBuilder().contentType(MediaType.PROTOBUF).build(),\n+                                   toProtobuf(result), trailers);\n+        }\n+\n+        if (mediaType != null) {\n+            final String subtype = mediaType.subtype();\n+            if (subtype.contains(\"protobuf\")) {", "originalCommit": "1a3aad6b3e5df0a578985812008dea9bc82de713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTczNzUxNQ==", "url": "https://github.com/line/armeria/pull/3124#discussion_r519737515", "bodyText": "The following two media types seem to be widely used.\n\napplication/x-protobuf by Spring\nhttps://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/converter/protobuf/ProtobufHttpMessageConverter.html\napplication/protobuf by Guava", "author": "ikhoon", "createdAt": "2020-11-09T11:26:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0MTY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0MTc3NA==", "url": "https://github.com/line/armeria/pull/3124#discussion_r519541774", "bodyText": "endsWith?\nMaybe we can support other encodings?", "author": "trustin", "createdAt": "2020-11-09T04:04:04Z", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.linecorp.armeria.internal.server.ResponseConversionUtil.aggregateFrom;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+\n+import com.google.common.collect.Streams;\n+import com.google.protobuf.MessageLite;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Printer;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.ResponseConverterFunction;\n+\n+/**\n+ * A {@link ResponseConverterFunction} which creates an {@link HttpResponse} with\n+ * {@code content-type: application/protobuf} or {@code content-type: application/json; charset=utf-8}.\n+ * If the returned object is instance of {@link MessageLite}, the object can be converted to\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/encoding\">Protocol Buffers</a> or\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/proto3#json\">JSON</a> format.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore if the returned object is instance of {@link Publisher}, {@link Stream} or {@link Iterable}\n+ * which produces {@link MessageLite}s, the object is only able to convert to\n+ * <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> format.\n+ *\n+ * <p>Note that this {@link ResponseConverterFunction} is applied to the annotated service by default,\n+ * so you don't have to set explicitly unless you want to use your own {@link Printer}.\n+ */\n+@UnstableApi\n+public final class ProtobufResponseConverterFunction implements ResponseConverterFunction {\n+\n+    private static final Printer defaultJsonPrinter = JsonFormat.printer();\n+\n+    private final Printer jsonPrinter;\n+\n+    /**\n+     * Creates an instance with the default {@link Printer}.\n+     */\n+    public ProtobufResponseConverterFunction() {\n+        this(defaultJsonPrinter);\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Printer}.\n+     */\n+    public ProtobufResponseConverterFunction(Printer jsonPrinter) {\n+        this.jsonPrinter = requireNonNull(jsonPrinter, \"jsonPrinter\");\n+    }\n+\n+    @Override\n+    public HttpResponse convertResponse(ServiceRequestContext ctx, ResponseHeaders headers,\n+                                        @Nullable Object result, HttpHeaders trailers) throws Exception {\n+        final MediaType mediaType = headers.contentType();\n+        if (result instanceof MessageLite) {\n+            if (mediaType != null) {\n+                if (mediaType.is(MediaType.JSON) || mediaType.subtype().endsWith(\"+json\")) {\n+                    final Charset charset = mediaType.charset(StandardCharsets.UTF_8);\n+                    if (charset.contains(StandardCharsets.UTF_8)) {\n+                        return HttpResponse.of(headers, toJsonHttpData(result), trailers);\n+                    }\n+                }\n+                return HttpResponse.of(headers, toProtobuf(result), trailers);\n+            }\n+\n+            return HttpResponse.of(headers.toBuilder().contentType(MediaType.PROTOBUF).build(),\n+                                   toProtobuf(result), trailers);\n+        }\n+\n+        if (mediaType != null) {\n+            final String subtype = mediaType.subtype();\n+            if (subtype.contains(\"protobuf\")) {\n+                checkArgument(result != null, \"a null value is not allowed for %s\", mediaType);\n+                final Charset charset = mediaType.charset(StandardCharsets.UTF_8);\n+                final boolean isJson = subtype.contains(\"+json\") && charset.contains(StandardCharsets.UTF_8);", "originalCommit": "1a3aad6b3e5df0a578985812008dea9bc82de713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA3MzYwMg==", "url": "https://github.com/line/armeria/pull/3124#discussion_r521073602", "bodyText": "Fixed", "author": "ikhoon", "createdAt": "2020-11-11T03:14:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0MTc3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4MzE5MA==", "url": "https://github.com/line/armeria/pull/3124#discussion_r519583190", "bodyText": "Comma after However", "author": "trustin", "createdAt": "2020-11-09T06:52:35Z", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body", "originalCommit": "1a3aad6b3e5df0a578985812008dea9bc82de713", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NDQ3OQ==", "url": "https://github.com/line/armeria/pull/3124#discussion_r519584479", "bodyText": "Maybe more readable by using switch-case?", "author": "trustin", "createdAt": "2020-11-09T06:56:46Z", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+@UnstableApi\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, MethodHandle> methodCache =\n+            new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private static final MethodHandle unknownMethodHandle;\n+\n+    static {\n+        final MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        final MethodType mt = methodType(void.class);\n+\n+        MethodHandle methodHandle;\n+        try {\n+            methodHandle = publicLookup.findConstructor(ProtobufRequestConverterFunction.class, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            methodHandle = null;\n+        }\n+        assert methodHandle != null;\n+        unknownMethodHandle = methodHandle;\n+    }\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+    private final ResultType resultType;\n+\n+    ProtobufRequestConverterFunction(ResultType resultType) {\n+        jsonParser = defaultJsonParser;\n+        extensionRegistry = ExtensionRegistry.getEmptyRegistry();\n+        this.resultType = requireNonNull(resultType, \"resultType\");\n+    }\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = requireNonNull(jsonParser, \"jsonParser\");\n+        this.extensionRegistry = requireNonNull(extensionRegistry, \"extensionRegistry\");\n+        resultType = ResultType.UNKNOWN;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                 Class<?> expectedResultType,\n+                                 @Nullable ParameterizedType expectedParameterizedResultType) throws Exception {\n+\n+        final MediaType contentType = request.contentType();\n+        if (resultType == ResultType.PROTOBUF ||\n+            (resultType == ResultType.UNKNOWN && Message.class.isAssignableFrom(expectedResultType))) {\n+            final Message.Builder messageBuilder = getMessageBuilder(expectedResultType);\n+\n+            if (contentType == null ||\n+                contentType.subtype().contains(\"protobuf\") || contentType.is(MediaType.OCTET_STREAM)) {\n+                try (InputStream is = request.content().toInputStream()) {\n+                    return messageBuilder.mergeFrom(is, extensionRegistry).build();\n+                }\n+            }\n+\n+            if (isJson(contentType)) {\n+                jsonParser.merge(request.contentUtf8(), messageBuilder);\n+                return messageBuilder.build();\n+            }\n+        }\n+\n+        if (isJson(contentType) && expectedParameterizedResultType != null) {\n+            ResultType resultType = this.resultType;\n+            if (resultType == ResultType.UNKNOWN) {\n+                resultType = toResultType(expectedParameterizedResultType);\n+            }\n+\n+            if (resultType != ResultType.UNKNOWN && resultType != ResultType.PROTOBUF) {\n+                final Type[] typeArguments = expectedParameterizedResultType.getActualTypeArguments();\n+                final String content = request.content(contentType.charset(StandardCharsets.UTF_8));\n+                final JsonNode jsonNode = mapper.readTree(content);\n+\n+                if (resultType == ResultType.LIST_PROTOBUF || resultType == ResultType.SET_PROTOBUF) {", "originalCommit": "1a3aad6b3e5df0a578985812008dea9bc82de713", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NDYyNg==", "url": "https://github.com/line/armeria/pull/3124#discussion_r519584626", "bodyText": "Consider returning early", "author": "trustin", "createdAt": "2020-11-09T06:57:08Z", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+@UnstableApi\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, MethodHandle> methodCache =\n+            new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private static final MethodHandle unknownMethodHandle;\n+\n+    static {\n+        final MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        final MethodType mt = methodType(void.class);\n+\n+        MethodHandle methodHandle;\n+        try {\n+            methodHandle = publicLookup.findConstructor(ProtobufRequestConverterFunction.class, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            methodHandle = null;\n+        }\n+        assert methodHandle != null;\n+        unknownMethodHandle = methodHandle;\n+    }\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+    private final ResultType resultType;\n+\n+    ProtobufRequestConverterFunction(ResultType resultType) {\n+        jsonParser = defaultJsonParser;\n+        extensionRegistry = ExtensionRegistry.getEmptyRegistry();\n+        this.resultType = requireNonNull(resultType, \"resultType\");\n+    }\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = requireNonNull(jsonParser, \"jsonParser\");\n+        this.extensionRegistry = requireNonNull(extensionRegistry, \"extensionRegistry\");\n+        resultType = ResultType.UNKNOWN;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                 Class<?> expectedResultType,\n+                                 @Nullable ParameterizedType expectedParameterizedResultType) throws Exception {\n+\n+        final MediaType contentType = request.contentType();\n+        if (resultType == ResultType.PROTOBUF ||\n+            (resultType == ResultType.UNKNOWN && Message.class.isAssignableFrom(expectedResultType))) {\n+            final Message.Builder messageBuilder = getMessageBuilder(expectedResultType);\n+\n+            if (contentType == null ||\n+                contentType.subtype().contains(\"protobuf\") || contentType.is(MediaType.OCTET_STREAM)) {\n+                try (InputStream is = request.content().toInputStream()) {\n+                    return messageBuilder.mergeFrom(is, extensionRegistry).build();\n+                }\n+            }\n+\n+            if (isJson(contentType)) {\n+                jsonParser.merge(request.contentUtf8(), messageBuilder);\n+                return messageBuilder.build();\n+            }\n+        }\n+\n+        if (isJson(contentType) && expectedParameterizedResultType != null) {", "originalCommit": "1a3aad6b3e5df0a578985812008dea9bc82de713", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NDkxMA==", "url": "https://github.com/line/armeria/pull/3124#discussion_r519584910", "bodyText": "Would this also support ScalaPB?", "author": "trustin", "createdAt": "2020-11-09T06:58:04Z", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+@UnstableApi\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, MethodHandle> methodCache =\n+            new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private static final MethodHandle unknownMethodHandle;\n+\n+    static {\n+        final MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        final MethodType mt = methodType(void.class);\n+\n+        MethodHandle methodHandle;\n+        try {\n+            methodHandle = publicLookup.findConstructor(ProtobufRequestConverterFunction.class, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            methodHandle = null;\n+        }\n+        assert methodHandle != null;\n+        unknownMethodHandle = methodHandle;\n+    }\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+    private final ResultType resultType;\n+\n+    ProtobufRequestConverterFunction(ResultType resultType) {\n+        jsonParser = defaultJsonParser;\n+        extensionRegistry = ExtensionRegistry.getEmptyRegistry();\n+        this.resultType = requireNonNull(resultType, \"resultType\");\n+    }\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = requireNonNull(jsonParser, \"jsonParser\");\n+        this.extensionRegistry = requireNonNull(extensionRegistry, \"extensionRegistry\");\n+        resultType = ResultType.UNKNOWN;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                 Class<?> expectedResultType,\n+                                 @Nullable ParameterizedType expectedParameterizedResultType) throws Exception {\n+\n+        final MediaType contentType = request.contentType();\n+        if (resultType == ResultType.PROTOBUF ||\n+            (resultType == ResultType.UNKNOWN && Message.class.isAssignableFrom(expectedResultType))) {\n+            final Message.Builder messageBuilder = getMessageBuilder(expectedResultType);\n+\n+            if (contentType == null ||\n+                contentType.subtype().contains(\"protobuf\") || contentType.is(MediaType.OCTET_STREAM)) {\n+                try (InputStream is = request.content().toInputStream()) {\n+                    return messageBuilder.mergeFrom(is, extensionRegistry).build();\n+                }\n+            }\n+\n+            if (isJson(contentType)) {\n+                jsonParser.merge(request.contentUtf8(), messageBuilder);\n+                return messageBuilder.build();\n+            }\n+        }\n+\n+        if (isJson(contentType) && expectedParameterizedResultType != null) {\n+            ResultType resultType = this.resultType;\n+            if (resultType == ResultType.UNKNOWN) {\n+                resultType = toResultType(expectedParameterizedResultType);\n+            }\n+\n+            if (resultType != ResultType.UNKNOWN && resultType != ResultType.PROTOBUF) {\n+                final Type[] typeArguments = expectedParameterizedResultType.getActualTypeArguments();\n+                final String content = request.content(contentType.charset(StandardCharsets.UTF_8));\n+                final JsonNode jsonNode = mapper.readTree(content);\n+\n+                if (resultType == ResultType.LIST_PROTOBUF || resultType == ResultType.SET_PROTOBUF) {\n+                    if (jsonNode.isArray()) {\n+                        final ImmutableCollection.Builder<Message> builder;\n+                        if (resultType == ResultType.LIST_PROTOBUF) {\n+                            builder = ImmutableList.builderWithExpectedSize(jsonNode.size());\n+                        } else {\n+                            builder = ImmutableSet.builderWithExpectedSize(jsonNode.size());\n+                        }\n+\n+                        for (JsonNode node : jsonNode) {\n+                            final Message.Builder msgBuilder = getMessageBuilder((Class<?>) typeArguments[0]);\n+                            jsonParser.merge(mapper.writeValueAsString(node), msgBuilder);\n+                            builder.add(msgBuilder.build());\n+                        }\n+                        return builder.build();\n+                    }\n+                } else if (resultType == ResultType.MAP_PROTOBUF) {\n+                     if (jsonNode.isObject()) {\n+                         final ImmutableMap.Builder<String, Message> builder =\n+                                 ImmutableMap.builderWithExpectedSize(jsonNode.size());\n+\n+                         for (final Iterator<Entry<String, JsonNode>> i = jsonNode.fields(); i.hasNext();) {\n+                             final Entry<String, JsonNode> e = i.next();\n+                             final Message.Builder msgBuilder = getMessageBuilder((Class<?>) typeArguments[1]);\n+                             jsonParser.merge(mapper.writeValueAsString(e.getValue()), msgBuilder);\n+                             builder.put(e.getKey(), msgBuilder.build());\n+                         }\n+                         return builder.build();\n+                     }\n+                }\n+            }\n+        }\n+\n+        return RequestConverterFunction.fallthrough();\n+    }\n+\n+    private static boolean isJson(@Nullable MediaType contentType) {\n+        return contentType != null &&\n+               (contentType.is(MediaType.JSON) || contentType.subtype().endsWith(\"+json\"));\n+    }\n+\n+    private static Message.Builder getMessageBuilder(Class<?> clazz) {", "originalCommit": "1a3aad6b3e5df0a578985812008dea9bc82de713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY0NjY4NA==", "url": "https://github.com/line/armeria/pull/3124#discussion_r519646684", "bodyText": "I don't think so. A message class generated by ScalaPB extends scalapb.GeneratedMessage.\nHowever it is possible by using another reflection API. Let me try it with optionalApi for ScalaPB.", "author": "ikhoon", "createdAt": "2020-11-09T09:00:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NDkxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA3NDM4Nw==", "url": "https://github.com/line/armeria/pull/3124#discussion_r521074387", "bodyText": "ScalaPB converters are added to armeria-scalapb module.\nf5ef663", "author": "ikhoon", "createdAt": "2020-11-11T03:15:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NDkxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk1ODI3MA==", "url": "https://github.com/line/armeria/pull/3124#discussion_r523958270", "bodyText": "Nice!", "author": "trustin", "createdAt": "2020-11-16T08:11:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NDkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NTA5MQ==", "url": "https://github.com/line/armeria/pull/3124#discussion_r519585091", "bodyText": "Message or MessageLite?", "author": "trustin", "createdAt": "2020-11-09T06:58:38Z", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunctionProvider.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import com.google.protobuf.Message;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunctionProvider;\n+import com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunction.ResultType;\n+\n+/**\n+ * Provides a {@link ProtobufRequestConverterFunction} to annotated services.\n+ */\n+@UnstableApi\n+public final class ProtobufRequestConverterFunctionProvider implements RequestConverterFunctionProvider {\n+\n+    @Override\n+    public RequestConverterFunction createRequestConverterFunction(Type requestType,\n+                                                                   RequestConverterFunction requestConverter) {\n+        final ResultType resultType = toResultType(requestType);\n+        if (resultType != ResultType.UNKNOWN) {\n+            return new ProtobufRequestConverterFunction(resultType);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static ResultType toResultType(Type type) {\n+        if (type instanceof Class) {\n+            if (isProtobufMessage((Class<?>) type)) {\n+                return ResultType.PROTOBUF;\n+            }\n+        }\n+\n+        if (type instanceof ParameterizedType) {\n+            final ParameterizedType parameterizedType = (ParameterizedType) type;\n+            final Class<?> rawType = (Class<?>) parameterizedType.getRawType();\n+            if (List.class.isAssignableFrom(rawType)) {\n+                final Class<?> typeArgument = (Class<?>) parameterizedType.getActualTypeArguments()[0];\n+                if (isProtobufMessage(typeArgument)) {\n+                    return ResultType.LIST_PROTOBUF;\n+                }\n+            } else if (Set.class.isAssignableFrom(rawType)) {\n+                final Class<?> typeArgument = (Class<?>) parameterizedType.getActualTypeArguments()[0];\n+                if (isProtobufMessage(typeArgument)) {\n+                    return ResultType.SET_PROTOBUF;\n+                }\n+            } else if (Map.class.isAssignableFrom(rawType)) {\n+                final Type[] typeArguments = parameterizedType.getActualTypeArguments();\n+                final Class<?> keyType = (Class<?>) typeArguments[0];\n+                if (!String.class.isAssignableFrom(keyType)) {\n+                    throw new IllegalStateException(\n+                            keyType + \" cannot be used for the key type of Map. \" +\n+                            \"(expected: Map<String, ?>)\");\n+                }\n+                if (isProtobufMessage((Class<?>) typeArguments[1])) {\n+                    return ResultType.MAP_PROTOBUF;\n+                }\n+            }\n+        }\n+        return ResultType.UNKNOWN;\n+    }\n+\n+    private static boolean isProtobufMessage(Class<?> clazz) {\n+        return Message.class.isAssignableFrom(clazz);", "originalCommit": "1a3aad6b3e5df0a578985812008dea9bc82de713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY1MTY4Ng==", "url": "https://github.com/line/armeria/pull/3124#discussion_r519651686", "bodyText": "Message class extends MessageLite. When building(deserializing) a message from protobuf, Message class is required to get Builder class. However, when serializing a message to protobuf,  MessageLite is enough.\nThis inconsistency is able to confuse users. Let me just use Message instead of MessageLite.", "author": "ikhoon", "createdAt": "2020-11-09T09:08:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NTA5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA5NjQ2Nw==", "url": "https://github.com/line/armeria/pull/3124#discussion_r521096467", "bodyText": "MessageLite is very rare in servers btw (though I remember an issue filed by someone that was actually using it don't remember the reasoning)", "author": "anuraaga", "createdAt": "2020-11-11T03:54:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NTA5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM1NzQ3NQ==", "url": "https://github.com/line/armeria/pull/3124#discussion_r521357475", "bodyText": "I remember an issue filed by someone that was actually using it don't remember the reasoning\n\nMaybe #3085? He said it was caused by wrong dependencies.", "author": "ikhoon", "createdAt": "2020-11-11T13:28:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NTA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NTQ2Mw==", "url": "https://github.com/line/armeria/pull/3124#discussion_r519585463", "bodyText": "Ditto - please add a heading and start from the conclusion.", "author": "trustin", "createdAt": "2020-11-09T06:59:45Z", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.linecorp.armeria.internal.server.ResponseConversionUtil.aggregateFrom;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+\n+import com.google.common.collect.Streams;\n+import com.google.protobuf.MessageLite;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Printer;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.ResponseConverterFunction;\n+\n+/**\n+ * A {@link ResponseConverterFunction} which creates an {@link HttpResponse} with\n+ * {@code content-type: application/protobuf} or {@code content-type: application/json; charset=utf-8}.\n+ * If the returned object is instance of {@link MessageLite}, the object can be converted to\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/encoding\">Protocol Buffers</a> or\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/proto3#json\">JSON</a> format.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore if the returned object is instance of {@link Publisher}, {@link Stream} or {@link Iterable}\n+ * which produces {@link MessageLite}s, the object is only able to convert to\n+ * <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> format.", "originalCommit": "1a3aad6b3e5df0a578985812008dea9bc82de713", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e9353b57933c6083d2c8f49b59aa16bc1f2f7b61", "url": "https://github.com/line/armeria/commit/e9353b57933c6083d2c8f49b59aa16bc1f2f7b61", "message": "Merge branch 'master' into protobuf-response-converter", "committedDate": "2020-11-09T09:33:40Z", "type": "commit"}, {"oid": "2030ba52ce6ced6424a0394a4ba3a525c093586a", "url": "https://github.com/line/armeria/commit/2030ba52ce6ced6424a0394a4ba3a525c093586a", "message": "Address comments by @minwoox and @trustin", "committedDate": "2020-11-09T14:01:05Z", "type": "commit"}, {"oid": "f5ef663b80f84a15d2d2ebebe0faf8e99927771d", "url": "https://github.com/line/armeria/commit/f5ef663b80f84a15d2d2ebebe0faf8e99927771d", "message": "Add request and response converter for ScalaPB", "committedDate": "2020-11-11T03:12:51Z", "type": "commit"}, {"oid": "9509056ea443e3e8a7cb8ac61cda1d72f88327e0", "url": "https://github.com/line/armeria/commit/9509056ea443e3e8a7cb8ac61cda1d72f88327e0", "message": "Fix shaded test error", "committedDate": "2020-11-11T06:49:59Z", "type": "commit"}, {"oid": "8359b18a469f876ab59511e1b6bb8d69293bc913", "url": "https://github.com/line/armeria/commit/8359b18a469f876ab59511e1b6bb8d69293bc913", "message": "Use defaultScalaVersions", "committedDate": "2020-11-16T02:53:26Z", "type": "commit"}, {"oid": "84c1a22063b1899e56832ef09feff138f59d1cef", "url": "https://github.com/line/armeria/commit/84c1a22063b1899e56832ef09feff138f59d1cef", "message": "Fix compile error with Scala 2.12", "committedDate": "2020-11-16T04:50:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk2MDA5OQ==", "url": "https://github.com/line/armeria/pull/3124#discussion_r523960099", "bodyText": "Could we move the inner classes to the top level? This parent class doesn't seem to do anything.", "author": "trustin", "createdAt": "2020-11-16T08:15:06Z", "path": "core/src/main/java/com/linecorp/armeria/internal/server/annotation/CompositeConverterFunctions.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.server.annotation;\n+\n+import java.lang.reflect.ParameterizedType;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.util.SafeCloseable;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.FallthroughException;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+import com.linecorp.armeria.server.annotation.ResponseConverterFunction;\n+\n+final class CompositeConverterFunctions {", "originalCommit": "84c1a22063b1899e56832ef09feff138f59d1cef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk2NDA4Nw==", "url": "https://github.com/line/armeria/pull/3124#discussion_r523964087", "bodyText": "the annotated service -> an annotated service?", "author": "trustin", "createdAt": "2020-11-16T08:22:53Z", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.linecorp.armeria.internal.server.ResponseConversionUtil.aggregateFrom;\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunction.isJson;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+\n+import com.google.common.collect.Streams;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.MessageLite;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Printer;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.ResponseConverterFunction;\n+\n+/**\n+ * A {@link ResponseConverterFunction} which creates an {@link HttpResponse} with\n+ * {@code content-type: application/protobuf} or {@code content-type: application/json; charset=utf-8}.\n+ * If the returned object is instance of {@link MessageLite}, the object can be converted to either\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/encoding\">Protocol Buffers</a> or\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/proto3#json\">JSON</a> format.\n+ *\n+ * <h3>Conversion of multiple Protobuf messages</h3>\n+ * A sequence of Protocol Buffer messages can not be handled by this {@link ResponseConverterFunction},\n+ * because Protocol Buffers wire format is not self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * However, {@link Publisher}, {@link Stream} and {@link Iterable} are supported when converting to\n+ * <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a>.\n+ *\n+ * <p>Note that this {@link ResponseConverterFunction} is applied to the annotated service by default,", "originalCommit": "84c1a22063b1899e56832ef09feff138f59d1cef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk2NDI3MA==", "url": "https://github.com/line/armeria/pull/3124#discussion_r523964270", "bodyText": "set -> specify this converter", "author": "trustin", "createdAt": "2020-11-16T08:23:15Z", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.linecorp.armeria.internal.server.ResponseConversionUtil.aggregateFrom;\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunction.isJson;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+\n+import com.google.common.collect.Streams;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.MessageLite;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Printer;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.ResponseConverterFunction;\n+\n+/**\n+ * A {@link ResponseConverterFunction} which creates an {@link HttpResponse} with\n+ * {@code content-type: application/protobuf} or {@code content-type: application/json; charset=utf-8}.\n+ * If the returned object is instance of {@link MessageLite}, the object can be converted to either\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/encoding\">Protocol Buffers</a> or\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/proto3#json\">JSON</a> format.\n+ *\n+ * <h3>Conversion of multiple Protobuf messages</h3>\n+ * A sequence of Protocol Buffer messages can not be handled by this {@link ResponseConverterFunction},\n+ * because Protocol Buffers wire format is not self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * However, {@link Publisher}, {@link Stream} and {@link Iterable} are supported when converting to\n+ * <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a>.\n+ *\n+ * <p>Note that this {@link ResponseConverterFunction} is applied to the annotated service by default,\n+ * so you don't have to set explicitly unless you want to use your own {@link Printer}.", "originalCommit": "84c1a22063b1899e56832ef09feff138f59d1cef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk2NTIyOQ==", "url": "https://github.com/line/armeria/pull/3124#discussion_r523965229", "bodyText": "a default -> the default?", "author": "trustin", "createdAt": "2020-11-16T08:25:06Z", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/package-info.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+/**\n+ * Provides a default {@link com.linecorp.armeria.server.annotation.ResponseConverterFunction}\n+ * which automatically converts a {@link com.google.protobuf.Message} into\n+ * an {@link com.linecorp.armeria.common.HttpResponse} and\n+ * a default {@link com.linecorp.armeria.server.annotation.RequestConverterFunction} which automatically\n+ * converts an {@link com.linecorp.armeria.common.AggregatedHttpRequest} into\n+ * a {@link com.google.protobuf.Message}.", "originalCommit": "84c1a22063b1899e56832ef09feff138f59d1cef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk2NTgwOA==", "url": "https://github.com/line/armeria/pull/3124#discussion_r523965808", "bodyText": "Should we also add @Consumes/ProducesProtobuf?", "author": "trustin", "createdAt": "2020-11-16T08:26:13Z", "path": "protobuf/src/test/java/com/linecorp/armeria/server/protobuf/ProtobufRequestAnnotatedServiceTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.util.JsonFormat;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.protobuf.testing.Messages.SimpleRequest;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.annotation.ConsumesJson;\n+import com.linecorp.armeria.server.annotation.Post;\n+import com.linecorp.armeria.testing.junit5.server.ServerExtension;\n+\n+class ProtobufRequestAnnotatedServiceTest {\n+\n+    @RegisterExtension\n+    static ServerExtension server = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.annotatedService(new GreetingService());\n+        }\n+    };\n+\n+    WebClient client;\n+\n+    @BeforeEach\n+    void setUp() {\n+        client = WebClient.of(server.httpUri());\n+    }\n+\n+    @Test\n+    void protobufRequest() throws InvalidProtocolBufferException {\n+        final SimpleRequest simpleRequest = SimpleRequest.newBuilder().setPayload(\"Armeria\").build();\n+        final AggregatedHttpResponse response =\n+                client.post(\"/default-content-type\", simpleRequest.toByteArray()).aggregate().join();\n+\n+        assertThat(response.contentUtf8()).isEqualTo(\"Hello, Armeria!\");\n+    }\n+\n+    @Test\n+    void jsonRequest() throws InvalidProtocolBufferException {\n+        final SimpleRequest simpleRequest = SimpleRequest.newBuilder().setPayload(\"Armeria\").build();\n+        final String json = JsonFormat.printer().print(simpleRequest);\n+        final HttpRequest request = HttpRequest.of(HttpMethod.POST, \"/json\", MediaType.JSON, json);\n+        final AggregatedHttpResponse response = client.execute(request).aggregate().join();\n+\n+        assertThat(response.contentUtf8()).isEqualTo(\"Hello, Armeria!\");\n+    }\n+\n+    @CsvSource({ \"/json+array\", \"/json+array2\" })\n+    @ParameterizedTest\n+    void jsonArrayRequest(String path) throws InvalidProtocolBufferException {\n+        final SimpleRequest simpleRequest1 = SimpleRequest.newBuilder().setSize(1).build();\n+        final SimpleRequest simpleRequest2 = SimpleRequest.newBuilder().setSize(2).build();\n+        final String json1 = JsonFormat.printer().print(simpleRequest1);\n+        final String json2 = JsonFormat.printer().print(simpleRequest2);\n+        final String jsonArray = ImmutableList.of(json1, json2).stream()\n+                                              .collect(Collectors.joining(\",\", \"[\", \"]\"));\n+        final HttpRequest request = HttpRequest.of(HttpMethod.POST, path, MediaType.JSON, jsonArray);\n+        final AggregatedHttpResponse response = client.execute(request).aggregate().join();\n+\n+        assertThat(response.contentUtf8()).isEqualTo(\"Sum: 3\");\n+    }\n+\n+    @Test\n+    void jsonObjectRequest() throws InvalidProtocolBufferException {\n+        final SimpleRequest simpleRequest1 = SimpleRequest.newBuilder().setSize(1).build();\n+        final SimpleRequest simpleRequest2 = SimpleRequest.newBuilder().setSize(2).build();\n+        final String json1 = JsonFormat.printer().print(simpleRequest1);\n+        final String json2 = JsonFormat.printer().print(simpleRequest2);\n+        final String jsonObject = \"{ \\\"json1\\\":\" + json1 +\n+                                  \", \\\"json2\\\":\" + json2 + '}';\n+\n+        final HttpRequest request = HttpRequest.of(HttpMethod.POST, \"/json+object\", MediaType.JSON, jsonObject);\n+        final AggregatedHttpResponse response = client.execute(request).aggregate().join();\n+\n+        assertThat(response.contentUtf8()).isEqualTo(\"OK\");\n+    }\n+\n+    private static class GreetingService {\n+        @Post(\"/default-content-type\")\n+        public String noContentType(SimpleRequest request) {\n+            return \"Hello, Armeria!\";\n+        }\n+\n+        @Post(\"/json\")\n+        @ConsumesJson", "originalCommit": "84c1a22063b1899e56832ef09feff138f59d1cef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c9c9f2e814377e556612f7dc1dc029f586759e2f", "url": "https://github.com/line/armeria/commit/c9c9f2e814377e556612f7dc1dc029f586759e2f", "message": "Remove scala multi version plugin and split project", "committedDate": "2020-11-16T13:00:36Z", "type": "commit"}, {"oid": "69064fde01ca637e4379dfa8f0cf4e736077727a", "url": "https://github.com/line/armeria/commit/69064fde01ca637e4379dfa8f0cf4e736077727a", "message": "Use 'api' for scalapb.json4s", "committedDate": "2020-11-16T13:04:53Z", "type": "commit"}, {"oid": "26459359769f59c6dd72e09dbd9dbaf0959cf3e3", "url": "https://github.com/line/armeria/commit/26459359769f59c6dd72e09dbd9dbaf0959cf3e3", "message": "Exclude from jacoco", "committedDate": "2020-11-16T14:56:37Z", "type": "commit"}, {"oid": "89b9220ef708cba01b8ba2e9eefc4fcf75cf637e", "url": "https://github.com/line/armeria/commit/89b9220ef708cba01b8ba2e9eefc4fcf75cf637e", "message": "Address comments by @trustin", "committedDate": "2020-11-16T16:52:52Z", "type": "commit"}, {"oid": "4f28b186f4d5ac6fbd48856d23a8e3981043abd2", "url": "https://github.com/line/armeria/commit/4f28b186f4d5ac6fbd48856d23a8e3981043abd2", "message": "Clean up", "committedDate": "2020-11-17T01:02:27Z", "type": "commit"}, {"oid": "3136e41fbac4eae6c3a579b0dba11534c5dc621d", "url": "https://github.com/line/armeria/commit/3136e41fbac4eae6c3a579b0dba11534c5dc621d", "message": "Clean up dependencies", "committedDate": "2020-11-17T02:30:20Z", "type": "commit"}, {"oid": "2218a318e04ff752b82fd17788aa1cc13b3516f0", "url": "https://github.com/line/armeria/commit/2218a318e04ff752b82fd17788aa1cc13b3516f0", "message": "Misc", "committedDate": "2020-11-17T05:45:54Z", "type": "commit"}, {"oid": "4e8efa0b45daa72cd881131e7a7a650e68040005", "url": "https://github.com/line/armeria/commit/4e8efa0b45daa72cd881131e7a7a650e68040005", "message": "checkstyle", "committedDate": "2020-11-18T03:54:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUzMTQxNw==", "url": "https://github.com/line/armeria/pull/3124#discussion_r526531417", "bodyText": "\u2753", "author": "minwoox", "createdAt": "2020-11-19T01:26:17Z", "path": "core/src/main/java/com/linecorp/armeria/server/annotation/RequestConverterFunctionProvider.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2018 LINE Corporation", "originalCommit": "4e8efa0b45daa72cd881131e7a7a650e68040005", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU2NjkzNw==", "url": "https://github.com/line/armeria/pull/3124#discussion_r526566937", "bodyText": "\ud83d\ude31", "author": "ikhoon", "createdAt": "2020-11-19T03:15:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUzMTQxNw=="}], "type": "inlineReview"}, {"oid": "e924fd0eeb233c9be8deb18a5fc28b49d5703309", "url": "https://github.com/line/armeria/commit/e924fd0eeb233c9be8deb18a5fc28b49d5703309", "message": "Address comments by @minwoox", "committedDate": "2020-11-19T03:35:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU3NjMwMg==", "url": "https://github.com/line/armeria/pull/3124#discussion_r526576302", "bodyText": "instance of -> a (or an instance of)", "author": "trustin", "createdAt": "2020-11-19T03:48:12Z", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.linecorp.armeria.internal.server.ResponseConversionUtil.aggregateFrom;\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunction.isJson;\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunction.isProtobuf;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+\n+import com.google.common.collect.Streams;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.MessageLite;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Printer;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.ResponseConverterFunction;\n+\n+/**\n+ * A {@link ResponseConverterFunction} which creates an {@link HttpResponse} with\n+ * {@code content-type: application/protobuf} or {@code content-type: application/json; charset=utf-8}.\n+ * If the returned object is instance of {@link MessageLite}, the object can be converted to either", "originalCommit": "e924fd0eeb233c9be8deb18a5fc28b49d5703309", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "11b4702a9ddc7b607e188eea98fee4ec67d09df9", "url": "https://github.com/line/armeria/commit/11b4702a9ddc7b607e188eea98fee4ec67d09df9", "message": "Address comments by @trustin / Fix Scaladoc indent", "committedDate": "2020-11-19T04:19:13Z", "type": "commit"}]}