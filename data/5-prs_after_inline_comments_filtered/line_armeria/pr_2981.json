{"pr_number": 2981, "pr_title": "Add HttpDeframer for decoding `HttpObject`s on top of Reactive Streams", "pr_createdAt": "2020-08-09T03:29:43Z", "pr_url": "https://github.com/line/armeria/pull/2981", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI4NDE5NQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r469284195", "bodyText": "so that the Queue does not grow up infinitely.\n\nMaybe too much information to users because users don't care about the underlying data structure?", "author": "trustin", "createdAt": "2020-08-12T14:04:07Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/HttpDataDeframer.java", "diffHunk": "@@ -0,0 +1,417 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.stream.DefaultStreamMessage;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A skeletal {@link Processor} implementation that decodes a stream of {@link HttpData}s to N objects.\n+ */\n+public abstract class HttpDataDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpData, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDataDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDataDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDataDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDataDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDataDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDataDeframer.class, \"subscribed\");\n+\n+    private final Queue<ByteBuf> queue;\n+    private final HttpDataReader reader;\n+    private final EventExecutor eventLoop;\n+    private final ByteBufAllocator alloc;\n+\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean isCancelled;\n+    private volatile int initialized;\n+    private volatile int subscribed;\n+\n+    /**\n+     * Returns a new {@link HttpDataDeframer} with the specified {@link EventExecutor} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    protected HttpDataDeframer(EventExecutor eventLoop, ByteBufAllocator alloc) {\n+        requireNonNull(eventLoop, \"eventLoop\");\n+        requireNonNull(alloc, \"alloc\");\n+        queue = new ArrayDeque<>();\n+        reader = new HttpDataReader();\n+        this.eventLoop = eventLoop;\n+        this.alloc = alloc;\n+    }\n+\n+    /**\n+     * Decodes a stream of {@link HttpData}s to N objects.\n+     * This method will be called whenever an {@link HttpData} is signaled from {@link Publisher}.\n+     *\n+     * <p>Note that The {@link HttpData}s which was fully consumed will be cleaned up automatically\n+     * so that the {@link Queue} does not grow up infinitely.", "originalCommit": "8cb8efed4e9edd1cc4b80fc3b28a54121772e916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI4NjQzOQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r469286439", "bodyText": "Slow path needs to be extracted into a separate method, so that the fast path part can be inlined. If you put both slow and fast path into a single method, it will never be inlined since it's too big.", "author": "trustin", "createdAt": "2020-08-12T14:07:28Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/HttpDataDeframer.java", "diffHunk": "@@ -0,0 +1,417 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.stream.DefaultStreamMessage;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A skeletal {@link Processor} implementation that decodes a stream of {@link HttpData}s to N objects.\n+ */\n+public abstract class HttpDataDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpData, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDataDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDataDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDataDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDataDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDataDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDataDeframer.class, \"subscribed\");\n+\n+    private final Queue<ByteBuf> queue;\n+    private final HttpDataReader reader;\n+    private final EventExecutor eventLoop;\n+    private final ByteBufAllocator alloc;\n+\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean isCancelled;\n+    private volatile int initialized;\n+    private volatile int subscribed;\n+\n+    /**\n+     * Returns a new {@link HttpDataDeframer} with the specified {@link EventExecutor} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    protected HttpDataDeframer(EventExecutor eventLoop, ByteBufAllocator alloc) {\n+        requireNonNull(eventLoop, \"eventLoop\");\n+        requireNonNull(alloc, \"alloc\");\n+        queue = new ArrayDeque<>();\n+        reader = new HttpDataReader();\n+        this.eventLoop = eventLoop;\n+        this.alloc = alloc;\n+    }\n+\n+    /**\n+     * Decodes a stream of {@link HttpData}s to N objects.\n+     * This method will be called whenever an {@link HttpData} is signaled from {@link Publisher}.\n+     *\n+     * <p>Note that The {@link HttpData}s which was fully consumed will be cleaned up automatically\n+     * so that the {@link Queue} does not grow up infinitely.\n+     * The {@code readerIndex} could be decreased after the cleanup process.\n+     */\n+    protected abstract List<T> process(HttpDataReader reader);\n+\n+    @Override\n+    public final void onSubscribe(Subscription subscription) {\n+        requireNonNull(subscription, \"subscription\");\n+        if (upstreamUpdater.compareAndSet(this, null, subscription)) {\n+            deferredInit();\n+        } else {\n+            subscription.cancel();\n+        }\n+    }\n+\n+    @Override\n+    public final void subscribe(Subscriber<? super T> subscriber) {\n+        super.subscribe(subscriber);\n+        if (subscribedUpdater.compareAndSet(this, 0, 1)) {\n+            deferredInit();\n+        }\n+    }\n+\n+    private void deferredInit() {\n+        if (upstream != null && subscribed != 0) {\n+            if (initializedUpdater.compareAndSet(this, 0, 1)) {\n+                upstream.request(1);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public final void onNext(HttpData data) {\n+        if (eventLoop.inEventLoop()) {\n+            onNext0(data);\n+        } else {\n+            eventLoop.execute(() -> onNext0(data));\n+        }\n+    }\n+\n+    private void onNext0(HttpData data) {\n+        try {\n+            queue.add(data.byteBuf());\n+            final List<T> decoded = process(reader);\n+\n+            if (decoded == null || decoded.isEmpty()) {\n+                upstream.request(1);\n+            } else {\n+                for (T item : decoded) {\n+                    write(item);\n+                }\n+                whenConsumed().thenRun(() -> upstream.request(1));\n+            }\n+            reader.discardReadBytes();\n+        } catch (Throwable ex) {\n+            Exceptions.throwIfFatal(ex);\n+            cancelAndCleanup();\n+            abort(ex);\n+        }\n+    }\n+\n+    private void cancelAndCleanup() {\n+        isCancelled = true;\n+        upstream.cancel();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public final void onError(Throwable cause) {\n+        requireNonNull(cause, \"cause\");\n+        if (isCancelled) {\n+            return;\n+        }\n+        cleanup();\n+        abort(cause);\n+    }\n+\n+    @Override\n+    public final void onComplete() {\n+        if (isCancelled) {\n+            return;\n+        }\n+        cleanup();\n+        close();\n+    }\n+\n+    private void cleanup() {\n+        if (!eventLoop.inEventLoop()) {\n+            eventLoop.execute(this::cleanup);\n+            return;\n+        }\n+\n+        for (ByteBuf buf : queue) {\n+            buf.release();\n+        }\n+        queue.clear();\n+    }\n+\n+    /**\n+     * A reader of a stream of {@link HttpData} which was delivered from the {@link Publisher}.\n+     * This class is NOT thread safe.\n+     */\n+    protected final class HttpDataReader {\n+\n+        HttpDataReader() {}\n+\n+        /**\n+         * Returns the total length of the {@link HttpData}s being buffered.\n+         */\n+        public int length() {\n+            if (queue.isEmpty()) {\n+                return 0;\n+            }\n+\n+            int length = 0;\n+            for (ByteBuf buf : queue) {\n+                length += buf.capacity();\n+            }\n+            return length;\n+        }\n+\n+        /**\n+         * Returns the number of readable bytes which is equal to {@code (length() - readerIndex()}.\n+         */\n+        public int readableBytes() {\n+            if (queue.isEmpty()) {\n+                return 0;\n+            }\n+\n+            int readableBytes = 0;\n+            for (ByteBuf buf : queue) {\n+                readableBytes += buf.readableBytes();\n+            }\n+            return readableBytes;\n+        }\n+\n+        /**\n+         * Returns the {@code readerIndex} of this {@link HttpDataReader}.\n+         * the {@code readerIndex} will be set to {@code 0} after {@link #discardReadBytes()} is called.\n+         */\n+        public int readerIndex() {\n+            if (queue.isEmpty()) {\n+                return 0;\n+            }\n+\n+            int value = 0;\n+            for (ByteBuf buf : queue) {\n+                final int readerIndex = buf.readerIndex();\n+                if (readerIndex > 0) {\n+                    value += readerIndex;\n+                } else {\n+                    break;\n+                }\n+            }\n+            return value;\n+        }\n+\n+        /**\n+         * Sets the {@code readerIndex} of this {@link HttpDataReader}.\n+         */\n+        public void readerIndex(int readerIndex) {\n+            int remained = readerIndex;\n+            for (ByteBuf buf : queue) {\n+                final int writerIndex = buf.writerIndex();\n+                if (writerIndex >= remained) {\n+                    buf.readerIndex(remained);\n+                    return;\n+                } else {\n+                    remained -= writerIndex;\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Returns a byte at the current {@code readerIndex} and increases the {@code readerIndex} by {@code 1}.\n+         */\n+        public byte readByte() {\n+            for (ByteBuf buf : queue) {\n+                if (!buf.isReadable()) {\n+                    continue;\n+                }\n+                return buf.readByte();\n+            }\n+            throw new IndexOutOfBoundsException(\"readerIndex: \" + readerIndex() +\n+                                                \" (expected: 0 <= readerIndex < length(\" + length() + \"))\");\n+        }\n+\n+        /**\n+         * Returns a unsigned byte at the current {@code readerIndex} and increases the {@code readerIndex}\n+         * by {@code 1}.\n+         */\n+        public short readUnsignedByte() {\n+            return (short) (readByte() & 0xFF);\n+        }\n+\n+        /**\n+         * Returns a 32-bit integer at the current {@code readerIndex} and increases the {@code readerIndex}\n+         * by {@code 4}.\n+         */\n+        public int readInt() {\n+            // fast path\n+            final ByteBuf firstBuf = queue.peek();\n+            if (firstBuf.readableBytes() >= 4) {\n+                return firstBuf.readInt();\n+            }\n+\n+            // slow path", "originalCommit": "8cb8efed4e9edd1cc4b80fc3b28a54121772e916", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzc0ODI0Ng==", "url": "https://github.com/line/armeria/pull/2981#discussion_r473748246", "bodyText": "It a good tip! \ud83d\udc4d", "author": "ikhoon", "createdAt": "2020-08-20T08:16:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI4NjQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI4NzE1NQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r469287155", "bodyText": "Perhaps better declaring a top-level reader interface and keeping a private implementation here?\nHow about HttpDeframerInput?", "author": "trustin", "createdAt": "2020-08-12T14:08:30Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/HttpDataDeframer.java", "diffHunk": "@@ -0,0 +1,417 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.stream.DefaultStreamMessage;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A skeletal {@link Processor} implementation that decodes a stream of {@link HttpData}s to N objects.\n+ */\n+public abstract class HttpDataDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpData, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDataDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDataDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDataDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDataDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDataDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDataDeframer.class, \"subscribed\");\n+\n+    private final Queue<ByteBuf> queue;\n+    private final HttpDataReader reader;\n+    private final EventExecutor eventLoop;\n+    private final ByteBufAllocator alloc;\n+\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean isCancelled;\n+    private volatile int initialized;\n+    private volatile int subscribed;\n+\n+    /**\n+     * Returns a new {@link HttpDataDeframer} with the specified {@link EventExecutor} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    protected HttpDataDeframer(EventExecutor eventLoop, ByteBufAllocator alloc) {\n+        requireNonNull(eventLoop, \"eventLoop\");\n+        requireNonNull(alloc, \"alloc\");\n+        queue = new ArrayDeque<>();\n+        reader = new HttpDataReader();\n+        this.eventLoop = eventLoop;\n+        this.alloc = alloc;\n+    }\n+\n+    /**\n+     * Decodes a stream of {@link HttpData}s to N objects.\n+     * This method will be called whenever an {@link HttpData} is signaled from {@link Publisher}.\n+     *\n+     * <p>Note that The {@link HttpData}s which was fully consumed will be cleaned up automatically\n+     * so that the {@link Queue} does not grow up infinitely.\n+     * The {@code readerIndex} could be decreased after the cleanup process.\n+     */\n+    protected abstract List<T> process(HttpDataReader reader);\n+\n+    @Override\n+    public final void onSubscribe(Subscription subscription) {\n+        requireNonNull(subscription, \"subscription\");\n+        if (upstreamUpdater.compareAndSet(this, null, subscription)) {\n+            deferredInit();\n+        } else {\n+            subscription.cancel();\n+        }\n+    }\n+\n+    @Override\n+    public final void subscribe(Subscriber<? super T> subscriber) {\n+        super.subscribe(subscriber);\n+        if (subscribedUpdater.compareAndSet(this, 0, 1)) {\n+            deferredInit();\n+        }\n+    }\n+\n+    private void deferredInit() {\n+        if (upstream != null && subscribed != 0) {\n+            if (initializedUpdater.compareAndSet(this, 0, 1)) {\n+                upstream.request(1);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public final void onNext(HttpData data) {\n+        if (eventLoop.inEventLoop()) {\n+            onNext0(data);\n+        } else {\n+            eventLoop.execute(() -> onNext0(data));\n+        }\n+    }\n+\n+    private void onNext0(HttpData data) {\n+        try {\n+            queue.add(data.byteBuf());\n+            final List<T> decoded = process(reader);\n+\n+            if (decoded == null || decoded.isEmpty()) {\n+                upstream.request(1);\n+            } else {\n+                for (T item : decoded) {\n+                    write(item);\n+                }\n+                whenConsumed().thenRun(() -> upstream.request(1));\n+            }\n+            reader.discardReadBytes();\n+        } catch (Throwable ex) {\n+            Exceptions.throwIfFatal(ex);\n+            cancelAndCleanup();\n+            abort(ex);\n+        }\n+    }\n+\n+    private void cancelAndCleanup() {\n+        isCancelled = true;\n+        upstream.cancel();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public final void onError(Throwable cause) {\n+        requireNonNull(cause, \"cause\");\n+        if (isCancelled) {\n+            return;\n+        }\n+        cleanup();\n+        abort(cause);\n+    }\n+\n+    @Override\n+    public final void onComplete() {\n+        if (isCancelled) {\n+            return;\n+        }\n+        cleanup();\n+        close();\n+    }\n+\n+    private void cleanup() {\n+        if (!eventLoop.inEventLoop()) {\n+            eventLoop.execute(this::cleanup);\n+            return;\n+        }\n+\n+        for (ByteBuf buf : queue) {\n+            buf.release();\n+        }\n+        queue.clear();\n+    }\n+\n+    /**\n+     * A reader of a stream of {@link HttpData} which was delivered from the {@link Publisher}.\n+     * This class is NOT thread safe.\n+     */\n+    protected final class HttpDataReader {", "originalCommit": "8cb8efed4e9edd1cc4b80fc3b28a54121772e916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI4ODQyMQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r469288421", "bodyText": "Could use queue.poll() that returns null when it's empty.", "author": "trustin", "createdAt": "2020-08-12T14:10:22Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/HttpDataDeframer.java", "diffHunk": "@@ -0,0 +1,417 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.stream.DefaultStreamMessage;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A skeletal {@link Processor} implementation that decodes a stream of {@link HttpData}s to N objects.\n+ */\n+public abstract class HttpDataDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpData, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDataDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDataDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDataDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDataDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDataDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDataDeframer.class, \"subscribed\");\n+\n+    private final Queue<ByteBuf> queue;\n+    private final HttpDataReader reader;\n+    private final EventExecutor eventLoop;\n+    private final ByteBufAllocator alloc;\n+\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean isCancelled;\n+    private volatile int initialized;\n+    private volatile int subscribed;\n+\n+    /**\n+     * Returns a new {@link HttpDataDeframer} with the specified {@link EventExecutor} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    protected HttpDataDeframer(EventExecutor eventLoop, ByteBufAllocator alloc) {\n+        requireNonNull(eventLoop, \"eventLoop\");\n+        requireNonNull(alloc, \"alloc\");\n+        queue = new ArrayDeque<>();\n+        reader = new HttpDataReader();\n+        this.eventLoop = eventLoop;\n+        this.alloc = alloc;\n+    }\n+\n+    /**\n+     * Decodes a stream of {@link HttpData}s to N objects.\n+     * This method will be called whenever an {@link HttpData} is signaled from {@link Publisher}.\n+     *\n+     * <p>Note that The {@link HttpData}s which was fully consumed will be cleaned up automatically\n+     * so that the {@link Queue} does not grow up infinitely.\n+     * The {@code readerIndex} could be decreased after the cleanup process.\n+     */\n+    protected abstract List<T> process(HttpDataReader reader);\n+\n+    @Override\n+    public final void onSubscribe(Subscription subscription) {\n+        requireNonNull(subscription, \"subscription\");\n+        if (upstreamUpdater.compareAndSet(this, null, subscription)) {\n+            deferredInit();\n+        } else {\n+            subscription.cancel();\n+        }\n+    }\n+\n+    @Override\n+    public final void subscribe(Subscriber<? super T> subscriber) {\n+        super.subscribe(subscriber);\n+        if (subscribedUpdater.compareAndSet(this, 0, 1)) {\n+            deferredInit();\n+        }\n+    }\n+\n+    private void deferredInit() {\n+        if (upstream != null && subscribed != 0) {\n+            if (initializedUpdater.compareAndSet(this, 0, 1)) {\n+                upstream.request(1);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public final void onNext(HttpData data) {\n+        if (eventLoop.inEventLoop()) {\n+            onNext0(data);\n+        } else {\n+            eventLoop.execute(() -> onNext0(data));\n+        }\n+    }\n+\n+    private void onNext0(HttpData data) {\n+        try {\n+            queue.add(data.byteBuf());\n+            final List<T> decoded = process(reader);\n+\n+            if (decoded == null || decoded.isEmpty()) {\n+                upstream.request(1);\n+            } else {\n+                for (T item : decoded) {\n+                    write(item);\n+                }\n+                whenConsumed().thenRun(() -> upstream.request(1));\n+            }\n+            reader.discardReadBytes();\n+        } catch (Throwable ex) {\n+            Exceptions.throwIfFatal(ex);\n+            cancelAndCleanup();\n+            abort(ex);\n+        }\n+    }\n+\n+    private void cancelAndCleanup() {\n+        isCancelled = true;\n+        upstream.cancel();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public final void onError(Throwable cause) {\n+        requireNonNull(cause, \"cause\");\n+        if (isCancelled) {\n+            return;\n+        }\n+        cleanup();\n+        abort(cause);\n+    }\n+\n+    @Override\n+    public final void onComplete() {\n+        if (isCancelled) {\n+            return;\n+        }\n+        cleanup();\n+        close();\n+    }\n+\n+    private void cleanup() {\n+        if (!eventLoop.inEventLoop()) {\n+            eventLoop.execute(this::cleanup);\n+            return;\n+        }\n+\n+        for (ByteBuf buf : queue) {\n+            buf.release();\n+        }\n+        queue.clear();\n+    }\n+\n+    /**\n+     * A reader of a stream of {@link HttpData} which was delivered from the {@link Publisher}.\n+     * This class is NOT thread safe.\n+     */\n+    protected final class HttpDataReader {\n+\n+        HttpDataReader() {}\n+\n+        /**\n+         * Returns the total length of the {@link HttpData}s being buffered.\n+         */\n+        public int length() {\n+            if (queue.isEmpty()) {\n+                return 0;\n+            }\n+\n+            int length = 0;\n+            for (ByteBuf buf : queue) {\n+                length += buf.capacity();\n+            }\n+            return length;\n+        }\n+\n+        /**\n+         * Returns the number of readable bytes which is equal to {@code (length() - readerIndex()}.\n+         */\n+        public int readableBytes() {\n+            if (queue.isEmpty()) {\n+                return 0;\n+            }\n+\n+            int readableBytes = 0;\n+            for (ByteBuf buf : queue) {\n+                readableBytes += buf.readableBytes();\n+            }\n+            return readableBytes;\n+        }\n+\n+        /**\n+         * Returns the {@code readerIndex} of this {@link HttpDataReader}.\n+         * the {@code readerIndex} will be set to {@code 0} after {@link #discardReadBytes()} is called.\n+         */\n+        public int readerIndex() {\n+            if (queue.isEmpty()) {\n+                return 0;\n+            }\n+\n+            int value = 0;\n+            for (ByteBuf buf : queue) {\n+                final int readerIndex = buf.readerIndex();\n+                if (readerIndex > 0) {\n+                    value += readerIndex;\n+                } else {\n+                    break;\n+                }\n+            }\n+            return value;\n+        }\n+\n+        /**\n+         * Sets the {@code readerIndex} of this {@link HttpDataReader}.\n+         */\n+        public void readerIndex(int readerIndex) {\n+            int remained = readerIndex;\n+            for (ByteBuf buf : queue) {\n+                final int writerIndex = buf.writerIndex();\n+                if (writerIndex >= remained) {\n+                    buf.readerIndex(remained);\n+                    return;\n+                } else {\n+                    remained -= writerIndex;\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Returns a byte at the current {@code readerIndex} and increases the {@code readerIndex} by {@code 1}.\n+         */\n+        public byte readByte() {\n+            for (ByteBuf buf : queue) {\n+                if (!buf.isReadable()) {\n+                    continue;\n+                }\n+                return buf.readByte();\n+            }\n+            throw new IndexOutOfBoundsException(\"readerIndex: \" + readerIndex() +\n+                                                \" (expected: 0 <= readerIndex < length(\" + length() + \"))\");\n+        }\n+\n+        /**\n+         * Returns a unsigned byte at the current {@code readerIndex} and increases the {@code readerIndex}\n+         * by {@code 1}.\n+         */\n+        public short readUnsignedByte() {\n+            return (short) (readByte() & 0xFF);\n+        }\n+\n+        /**\n+         * Returns a 32-bit integer at the current {@code readerIndex} and increases the {@code readerIndex}\n+         * by {@code 4}.\n+         */\n+        public int readInt() {\n+            // fast path\n+            final ByteBuf firstBuf = queue.peek();\n+            if (firstBuf.readableBytes() >= 4) {\n+                return firstBuf.readInt();\n+            }\n+\n+            // slow path\n+            int value = 0;\n+            int remained = 4;\n+            for (ByteBuf buf : queue) {\n+                if (!buf.isReadable()) {\n+                    continue;\n+                }\n+                final int readSize = Math.min(remained, buf.readableBytes());\n+                if (readSize == 4) {\n+                    return buf.readInt();\n+                }\n+\n+                value <<= 8 * readSize;\n+                switch (readSize) {\n+                    case 1:\n+                        value |= buf.readUnsignedByte();\n+                        break;\n+                    case 2:\n+                        value |= buf.readUnsignedShort();\n+                        break;\n+                    case 3:\n+                        value |= buf.readUnsignedMedium();\n+                        break;\n+                    default:\n+                        throw new Error(); // Should not reach here.\n+                }\n+                remained -= readSize;\n+                if (remained == 0) {\n+                    break;\n+                }\n+            }\n+\n+            if (remained == 0) {\n+                return value;\n+            } else {\n+                throw new IndexOutOfBoundsException(\n+                        \"readerIndex: \" + (readerIndex() - 4 + remained) +\n+                        \" (expected: 0 <= readerIndex + 4 <= length(\" + length() + \"))\");\n+            }\n+        }\n+\n+        /**\n+         * Returns a newly retained slice of this {@link ByteBuf} at the current {@code readerIndex}\n+         * and increases the {@code readerIndex} by the specified {@code length}.\n+         *\n+         * @throws IndexOutOfBoundsException if the specified {@code length} is greater than {@link #length()}\n+         */\n+        public ByteBuf readBytes(int length) {\n+            // fast path\n+            final ByteBuf firstBuf = queue.peek();\n+            if (firstBuf.readableBytes() >= length) {\n+                return firstBuf.readRetainedSlice(length);\n+            }\n+\n+            // slow path\n+            ByteBuf value = null;\n+            int remained = length;\n+            for (ByteBuf buf : queue) {\n+                if (!buf.isReadable()) {\n+                    continue;\n+                }\n+\n+                final int readSize = Math.min(remained, buf.readableBytes());\n+                if (readSize == length) {\n+                    return buf.readRetainedSlice(readSize);\n+                } else {\n+                    if (value == null) {\n+                        value = alloc.buffer(length);\n+                    }\n+                    value.writeBytes(buf, readSize);\n+                    remained -= readSize;\n+                    if (remained == 0) {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if (remained > 0) {\n+                ReferenceCountUtil.release(value);\n+                throw new IndexOutOfBoundsException(\n+                        \"readerIndex: \" + (readerIndex() - length + remained) +\n+                        \" (expected: 0 <= readerIndex + \" + length + \" <= length(\" + length() + \"))\");\n+            }\n+\n+            return value;\n+        }\n+\n+        /**\n+         * Returns a byte at the specified absolute {@code index} in this {@link HttpDataReader}.\n+         * This method does not modify {@code readerIndex} of this {@link HttpDataReader}.\n+         */\n+        public byte getByte(int index) {\n+            int remained = index;\n+            for (ByteBuf buf : queue) {\n+                final int length = buf.capacity();\n+                if (length == 0) {\n+                    continue;\n+                } else if (length >= remained) {\n+                    return buf.getByte(remained);\n+                } else {\n+                    remained -= length;\n+                }\n+            }\n+\n+            throw new IndexOutOfBoundsException(\n+                    \"index: \" + index + \" (expected: 0 <= index < length(\" + length() + \"))\");\n+        }\n+\n+        /**\n+         * Discards the {@link ByteBuf}s that has been fully consumed and is not readable anymore.\n+         */\n+        private void discardReadBytes() {\n+            for (;;) {\n+                final ByteBuf buf = queue.peek();\n+                if (buf != null && !buf.isReadable()) {\n+                    queue.remove().release();\n+                } else {\n+                    break;\n+                }", "originalCommit": "8cb8efed4e9edd1cc4b80fc3b28a54121772e916", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzc5MTg5Ng==", "url": "https://github.com/line/armeria/pull/2981#discussion_r473791896", "bodyText": "Let me use queue.peek() because the buf is only removed when it is not readable.", "author": "ikhoon", "createdAt": "2020-08-20T09:05:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI4ODQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI4OTQ2OA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r469289468", "bodyText": "Don't we need to take buf.{reader,writer}Index() into account unless we are sure all buffers in queue meets readerIndex == 0 && writerIndex == capacity?", "author": "trustin", "createdAt": "2020-08-12T14:11:54Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/HttpDataDeframer.java", "diffHunk": "@@ -0,0 +1,417 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.stream.DefaultStreamMessage;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A skeletal {@link Processor} implementation that decodes a stream of {@link HttpData}s to N objects.\n+ */\n+public abstract class HttpDataDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpData, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDataDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDataDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDataDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDataDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDataDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDataDeframer.class, \"subscribed\");\n+\n+    private final Queue<ByteBuf> queue;\n+    private final HttpDataReader reader;\n+    private final EventExecutor eventLoop;\n+    private final ByteBufAllocator alloc;\n+\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean isCancelled;\n+    private volatile int initialized;\n+    private volatile int subscribed;\n+\n+    /**\n+     * Returns a new {@link HttpDataDeframer} with the specified {@link EventExecutor} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    protected HttpDataDeframer(EventExecutor eventLoop, ByteBufAllocator alloc) {\n+        requireNonNull(eventLoop, \"eventLoop\");\n+        requireNonNull(alloc, \"alloc\");\n+        queue = new ArrayDeque<>();\n+        reader = new HttpDataReader();\n+        this.eventLoop = eventLoop;\n+        this.alloc = alloc;\n+    }\n+\n+    /**\n+     * Decodes a stream of {@link HttpData}s to N objects.\n+     * This method will be called whenever an {@link HttpData} is signaled from {@link Publisher}.\n+     *\n+     * <p>Note that The {@link HttpData}s which was fully consumed will be cleaned up automatically\n+     * so that the {@link Queue} does not grow up infinitely.\n+     * The {@code readerIndex} could be decreased after the cleanup process.\n+     */\n+    protected abstract List<T> process(HttpDataReader reader);\n+\n+    @Override\n+    public final void onSubscribe(Subscription subscription) {\n+        requireNonNull(subscription, \"subscription\");\n+        if (upstreamUpdater.compareAndSet(this, null, subscription)) {\n+            deferredInit();\n+        } else {\n+            subscription.cancel();\n+        }\n+    }\n+\n+    @Override\n+    public final void subscribe(Subscriber<? super T> subscriber) {\n+        super.subscribe(subscriber);\n+        if (subscribedUpdater.compareAndSet(this, 0, 1)) {\n+            deferredInit();\n+        }\n+    }\n+\n+    private void deferredInit() {\n+        if (upstream != null && subscribed != 0) {\n+            if (initializedUpdater.compareAndSet(this, 0, 1)) {\n+                upstream.request(1);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public final void onNext(HttpData data) {\n+        if (eventLoop.inEventLoop()) {\n+            onNext0(data);\n+        } else {\n+            eventLoop.execute(() -> onNext0(data));\n+        }\n+    }\n+\n+    private void onNext0(HttpData data) {\n+        try {\n+            queue.add(data.byteBuf());\n+            final List<T> decoded = process(reader);\n+\n+            if (decoded == null || decoded.isEmpty()) {\n+                upstream.request(1);\n+            } else {\n+                for (T item : decoded) {\n+                    write(item);\n+                }\n+                whenConsumed().thenRun(() -> upstream.request(1));\n+            }\n+            reader.discardReadBytes();\n+        } catch (Throwable ex) {\n+            Exceptions.throwIfFatal(ex);\n+            cancelAndCleanup();\n+            abort(ex);\n+        }\n+    }\n+\n+    private void cancelAndCleanup() {\n+        isCancelled = true;\n+        upstream.cancel();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public final void onError(Throwable cause) {\n+        requireNonNull(cause, \"cause\");\n+        if (isCancelled) {\n+            return;\n+        }\n+        cleanup();\n+        abort(cause);\n+    }\n+\n+    @Override\n+    public final void onComplete() {\n+        if (isCancelled) {\n+            return;\n+        }\n+        cleanup();\n+        close();\n+    }\n+\n+    private void cleanup() {\n+        if (!eventLoop.inEventLoop()) {\n+            eventLoop.execute(this::cleanup);\n+            return;\n+        }\n+\n+        for (ByteBuf buf : queue) {\n+            buf.release();\n+        }\n+        queue.clear();\n+    }\n+\n+    /**\n+     * A reader of a stream of {@link HttpData} which was delivered from the {@link Publisher}.\n+     * This class is NOT thread safe.\n+     */\n+    protected final class HttpDataReader {\n+\n+        HttpDataReader() {}\n+\n+        /**\n+         * Returns the total length of the {@link HttpData}s being buffered.\n+         */\n+        public int length() {\n+            if (queue.isEmpty()) {\n+                return 0;\n+            }\n+\n+            int length = 0;\n+            for (ByteBuf buf : queue) {\n+                length += buf.capacity();\n+            }\n+            return length;\n+        }\n+\n+        /**\n+         * Returns the number of readable bytes which is equal to {@code (length() - readerIndex()}.\n+         */\n+        public int readableBytes() {\n+            if (queue.isEmpty()) {\n+                return 0;\n+            }\n+\n+            int readableBytes = 0;\n+            for (ByteBuf buf : queue) {\n+                readableBytes += buf.readableBytes();\n+            }\n+            return readableBytes;\n+        }\n+\n+        /**\n+         * Returns the {@code readerIndex} of this {@link HttpDataReader}.\n+         * the {@code readerIndex} will be set to {@code 0} after {@link #discardReadBytes()} is called.\n+         */\n+        public int readerIndex() {\n+            if (queue.isEmpty()) {\n+                return 0;\n+            }\n+\n+            int value = 0;\n+            for (ByteBuf buf : queue) {\n+                final int readerIndex = buf.readerIndex();\n+                if (readerIndex > 0) {\n+                    value += readerIndex;\n+                } else {\n+                    break;\n+                }\n+            }\n+            return value;\n+        }\n+\n+        /**\n+         * Sets the {@code readerIndex} of this {@link HttpDataReader}.\n+         */\n+        public void readerIndex(int readerIndex) {\n+            int remained = readerIndex;\n+            for (ByteBuf buf : queue) {\n+                final int writerIndex = buf.writerIndex();\n+                if (writerIndex >= remained) {\n+                    buf.readerIndex(remained);\n+                    return;\n+                } else {\n+                    remained -= writerIndex;\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Returns a byte at the current {@code readerIndex} and increases the {@code readerIndex} by {@code 1}.\n+         */\n+        public byte readByte() {\n+            for (ByteBuf buf : queue) {\n+                if (!buf.isReadable()) {\n+                    continue;\n+                }\n+                return buf.readByte();\n+            }\n+            throw new IndexOutOfBoundsException(\"readerIndex: \" + readerIndex() +\n+                                                \" (expected: 0 <= readerIndex < length(\" + length() + \"))\");\n+        }\n+\n+        /**\n+         * Returns a unsigned byte at the current {@code readerIndex} and increases the {@code readerIndex}\n+         * by {@code 1}.\n+         */\n+        public short readUnsignedByte() {\n+            return (short) (readByte() & 0xFF);\n+        }\n+\n+        /**\n+         * Returns a 32-bit integer at the current {@code readerIndex} and increases the {@code readerIndex}\n+         * by {@code 4}.\n+         */\n+        public int readInt() {\n+            // fast path\n+            final ByteBuf firstBuf = queue.peek();\n+            if (firstBuf.readableBytes() >= 4) {\n+                return firstBuf.readInt();\n+            }\n+\n+            // slow path\n+            int value = 0;\n+            int remained = 4;\n+            for (ByteBuf buf : queue) {\n+                if (!buf.isReadable()) {\n+                    continue;\n+                }\n+                final int readSize = Math.min(remained, buf.readableBytes());\n+                if (readSize == 4) {\n+                    return buf.readInt();\n+                }\n+\n+                value <<= 8 * readSize;\n+                switch (readSize) {\n+                    case 1:\n+                        value |= buf.readUnsignedByte();\n+                        break;\n+                    case 2:\n+                        value |= buf.readUnsignedShort();\n+                        break;\n+                    case 3:\n+                        value |= buf.readUnsignedMedium();\n+                        break;\n+                    default:\n+                        throw new Error(); // Should not reach here.\n+                }\n+                remained -= readSize;\n+                if (remained == 0) {\n+                    break;\n+                }\n+            }\n+\n+            if (remained == 0) {\n+                return value;\n+            } else {\n+                throw new IndexOutOfBoundsException(\n+                        \"readerIndex: \" + (readerIndex() - 4 + remained) +\n+                        \" (expected: 0 <= readerIndex + 4 <= length(\" + length() + \"))\");\n+            }\n+        }\n+\n+        /**\n+         * Returns a newly retained slice of this {@link ByteBuf} at the current {@code readerIndex}\n+         * and increases the {@code readerIndex} by the specified {@code length}.\n+         *\n+         * @throws IndexOutOfBoundsException if the specified {@code length} is greater than {@link #length()}\n+         */\n+        public ByteBuf readBytes(int length) {\n+            // fast path\n+            final ByteBuf firstBuf = queue.peek();\n+            if (firstBuf.readableBytes() >= length) {\n+                return firstBuf.readRetainedSlice(length);\n+            }\n+\n+            // slow path\n+            ByteBuf value = null;\n+            int remained = length;\n+            for (ByteBuf buf : queue) {\n+                if (!buf.isReadable()) {\n+                    continue;\n+                }\n+\n+                final int readSize = Math.min(remained, buf.readableBytes());\n+                if (readSize == length) {\n+                    return buf.readRetainedSlice(readSize);\n+                } else {\n+                    if (value == null) {\n+                        value = alloc.buffer(length);\n+                    }\n+                    value.writeBytes(buf, readSize);\n+                    remained -= readSize;\n+                    if (remained == 0) {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if (remained > 0) {\n+                ReferenceCountUtil.release(value);\n+                throw new IndexOutOfBoundsException(\n+                        \"readerIndex: \" + (readerIndex() - length + remained) +\n+                        \" (expected: 0 <= readerIndex + \" + length + \" <= length(\" + length() + \"))\");\n+            }\n+\n+            return value;\n+        }\n+\n+        /**\n+         * Returns a byte at the specified absolute {@code index} in this {@link HttpDataReader}.\n+         * This method does not modify {@code readerIndex} of this {@link HttpDataReader}.\n+         */\n+        public byte getByte(int index) {\n+            int remained = index;\n+            for (ByteBuf buf : queue) {\n+                final int length = buf.capacity();\n+                if (length == 0) {\n+                    continue;\n+                } else if (length >= remained) {\n+                    return buf.getByte(remained);\n+                } else {\n+                    remained -= length;\n+                }", "originalCommit": "8cb8efed4e9edd1cc4b80fc3b28a54121772e916", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjE4Nzg3OQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r476187879", "bodyText": "This block is refactored. \ud83d\ude00", "author": "ikhoon", "createdAt": "2020-08-25T05:33:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI4OTQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI5MjQwNA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r469292404", "bodyText": "How about returning void and accepting an output parameter? e.g.\nprotected abstract void process(HttpDeframerInput in, HttpDeframerOutput<T> out);\n\npublic interface HttpDeframerOutput<T> {\n    void add(T e);\n}", "author": "trustin", "createdAt": "2020-08-12T14:15:49Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/HttpDataDeframer.java", "diffHunk": "@@ -0,0 +1,417 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.stream.DefaultStreamMessage;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A skeletal {@link Processor} implementation that decodes a stream of {@link HttpData}s to N objects.\n+ */\n+public abstract class HttpDataDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpData, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDataDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDataDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDataDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDataDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDataDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDataDeframer.class, \"subscribed\");\n+\n+    private final Queue<ByteBuf> queue;\n+    private final HttpDataReader reader;\n+    private final EventExecutor eventLoop;\n+    private final ByteBufAllocator alloc;\n+\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean isCancelled;\n+    private volatile int initialized;\n+    private volatile int subscribed;\n+\n+    /**\n+     * Returns a new {@link HttpDataDeframer} with the specified {@link EventExecutor} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    protected HttpDataDeframer(EventExecutor eventLoop, ByteBufAllocator alloc) {\n+        requireNonNull(eventLoop, \"eventLoop\");\n+        requireNonNull(alloc, \"alloc\");\n+        queue = new ArrayDeque<>();\n+        reader = new HttpDataReader();\n+        this.eventLoop = eventLoop;\n+        this.alloc = alloc;\n+    }\n+\n+    /**\n+     * Decodes a stream of {@link HttpData}s to N objects.\n+     * This method will be called whenever an {@link HttpData} is signaled from {@link Publisher}.\n+     *\n+     * <p>Note that The {@link HttpData}s which was fully consumed will be cleaned up automatically\n+     * so that the {@link Queue} does not grow up infinitely.\n+     * The {@code readerIndex} could be decreased after the cleanup process.\n+     */\n+    protected abstract List<T> process(HttpDataReader reader);", "originalCommit": "8cb8efed4e9edd1cc4b80fc3b28a54121772e916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI5NjIzNA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r469296234", "bodyText": "How about just HttpDeframer?\nWould this be more useful if it's a Processor<HttpObject, T>?\n\nCould HttpHeaders be handled by other protected callbacks? e.g. processInformationalHeaders, processHeaders(), processTrailers\nThis may remove the overhead of splitting a Publisher<HttpObject>.", "author": "trustin", "createdAt": "2020-08-12T14:21:06Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/HttpDataDeframer.java", "diffHunk": "@@ -0,0 +1,417 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.stream.DefaultStreamMessage;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A skeletal {@link Processor} implementation that decodes a stream of {@link HttpData}s to N objects.\n+ */\n+public abstract class HttpDataDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpData, T> {", "originalCommit": "8cb8efed4e9edd1cc4b80fc3b28a54121772e916", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgxMDQwMw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r473810403", "bodyText": "* Would this be more useful if it's a `Processor<HttpObject, T>`?\n  \n  * Could `HttpHeaders` be handled by other `protected` callbacks? e.g. `processInformationalHeaders`, `processHeaders()`, `processTrailers`\n  * This may remove the overhead of splitting a `Publisher<HttpObject>`.\n\n\nAdding protected callbacks looks nice! Let me take it.", "author": "ikhoon", "createdAt": "2020-08-20T09:27:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI5NjIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI5OTIyMw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r469299223", "bodyText": "Do we need get*() methods that do not move the readerIndex forward? Could you explain why?", "author": "trustin", "createdAt": "2020-08-12T14:25:09Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/HttpDataDeframer.java", "diffHunk": "@@ -0,0 +1,417 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.stream.DefaultStreamMessage;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A skeletal {@link Processor} implementation that decodes a stream of {@link HttpData}s to N objects.\n+ */\n+public abstract class HttpDataDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpData, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDataDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDataDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDataDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDataDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDataDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDataDeframer.class, \"subscribed\");\n+\n+    private final Queue<ByteBuf> queue;\n+    private final HttpDataReader reader;\n+    private final EventExecutor eventLoop;\n+    private final ByteBufAllocator alloc;\n+\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean isCancelled;\n+    private volatile int initialized;\n+    private volatile int subscribed;\n+\n+    /**\n+     * Returns a new {@link HttpDataDeframer} with the specified {@link EventExecutor} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    protected HttpDataDeframer(EventExecutor eventLoop, ByteBufAllocator alloc) {\n+        requireNonNull(eventLoop, \"eventLoop\");\n+        requireNonNull(alloc, \"alloc\");\n+        queue = new ArrayDeque<>();\n+        reader = new HttpDataReader();\n+        this.eventLoop = eventLoop;\n+        this.alloc = alloc;\n+    }\n+\n+    /**\n+     * Decodes a stream of {@link HttpData}s to N objects.\n+     * This method will be called whenever an {@link HttpData} is signaled from {@link Publisher}.\n+     *\n+     * <p>Note that The {@link HttpData}s which was fully consumed will be cleaned up automatically\n+     * so that the {@link Queue} does not grow up infinitely.\n+     * The {@code readerIndex} could be decreased after the cleanup process.\n+     */\n+    protected abstract List<T> process(HttpDataReader reader);\n+\n+    @Override\n+    public final void onSubscribe(Subscription subscription) {\n+        requireNonNull(subscription, \"subscription\");\n+        if (upstreamUpdater.compareAndSet(this, null, subscription)) {\n+            deferredInit();\n+        } else {\n+            subscription.cancel();\n+        }\n+    }\n+\n+    @Override\n+    public final void subscribe(Subscriber<? super T> subscriber) {\n+        super.subscribe(subscriber);\n+        if (subscribedUpdater.compareAndSet(this, 0, 1)) {\n+            deferredInit();\n+        }\n+    }\n+\n+    private void deferredInit() {\n+        if (upstream != null && subscribed != 0) {\n+            if (initializedUpdater.compareAndSet(this, 0, 1)) {\n+                upstream.request(1);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public final void onNext(HttpData data) {\n+        if (eventLoop.inEventLoop()) {\n+            onNext0(data);\n+        } else {\n+            eventLoop.execute(() -> onNext0(data));\n+        }\n+    }\n+\n+    private void onNext0(HttpData data) {\n+        try {\n+            queue.add(data.byteBuf());\n+            final List<T> decoded = process(reader);\n+\n+            if (decoded == null || decoded.isEmpty()) {\n+                upstream.request(1);\n+            } else {\n+                for (T item : decoded) {\n+                    write(item);\n+                }\n+                whenConsumed().thenRun(() -> upstream.request(1));\n+            }\n+            reader.discardReadBytes();\n+        } catch (Throwable ex) {\n+            Exceptions.throwIfFatal(ex);\n+            cancelAndCleanup();\n+            abort(ex);\n+        }\n+    }\n+\n+    private void cancelAndCleanup() {\n+        isCancelled = true;\n+        upstream.cancel();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public final void onError(Throwable cause) {\n+        requireNonNull(cause, \"cause\");\n+        if (isCancelled) {\n+            return;\n+        }\n+        cleanup();\n+        abort(cause);\n+    }\n+\n+    @Override\n+    public final void onComplete() {\n+        if (isCancelled) {\n+            return;\n+        }\n+        cleanup();\n+        close();\n+    }\n+\n+    private void cleanup() {\n+        if (!eventLoop.inEventLoop()) {\n+            eventLoop.execute(this::cleanup);\n+            return;\n+        }\n+\n+        for (ByteBuf buf : queue) {\n+            buf.release();\n+        }\n+        queue.clear();\n+    }\n+\n+    /**\n+     * A reader of a stream of {@link HttpData} which was delivered from the {@link Publisher}.\n+     * This class is NOT thread safe.\n+     */\n+    protected final class HttpDataReader {\n+\n+        HttpDataReader() {}\n+\n+        /**\n+         * Returns the total length of the {@link HttpData}s being buffered.\n+         */\n+        public int length() {\n+            if (queue.isEmpty()) {\n+                return 0;\n+            }\n+\n+            int length = 0;\n+            for (ByteBuf buf : queue) {\n+                length += buf.capacity();\n+            }\n+            return length;\n+        }\n+\n+        /**\n+         * Returns the number of readable bytes which is equal to {@code (length() - readerIndex()}.\n+         */\n+        public int readableBytes() {\n+            if (queue.isEmpty()) {\n+                return 0;\n+            }\n+\n+            int readableBytes = 0;\n+            for (ByteBuf buf : queue) {\n+                readableBytes += buf.readableBytes();\n+            }\n+            return readableBytes;\n+        }\n+\n+        /**\n+         * Returns the {@code readerIndex} of this {@link HttpDataReader}.\n+         * the {@code readerIndex} will be set to {@code 0} after {@link #discardReadBytes()} is called.\n+         */\n+        public int readerIndex() {\n+            if (queue.isEmpty()) {\n+                return 0;\n+            }\n+\n+            int value = 0;\n+            for (ByteBuf buf : queue) {\n+                final int readerIndex = buf.readerIndex();\n+                if (readerIndex > 0) {\n+                    value += readerIndex;\n+                } else {\n+                    break;\n+                }\n+            }\n+            return value;\n+        }\n+\n+        /**\n+         * Sets the {@code readerIndex} of this {@link HttpDataReader}.\n+         */\n+        public void readerIndex(int readerIndex) {\n+            int remained = readerIndex;\n+            for (ByteBuf buf : queue) {\n+                final int writerIndex = buf.writerIndex();\n+                if (writerIndex >= remained) {\n+                    buf.readerIndex(remained);\n+                    return;\n+                } else {\n+                    remained -= writerIndex;\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Returns a byte at the current {@code readerIndex} and increases the {@code readerIndex} by {@code 1}.\n+         */\n+        public byte readByte() {\n+            for (ByteBuf buf : queue) {\n+                if (!buf.isReadable()) {\n+                    continue;\n+                }\n+                return buf.readByte();\n+            }\n+            throw new IndexOutOfBoundsException(\"readerIndex: \" + readerIndex() +\n+                                                \" (expected: 0 <= readerIndex < length(\" + length() + \"))\");\n+        }\n+\n+        /**\n+         * Returns a unsigned byte at the current {@code readerIndex} and increases the {@code readerIndex}\n+         * by {@code 1}.\n+         */\n+        public short readUnsignedByte() {\n+            return (short) (readByte() & 0xFF);\n+        }\n+\n+        /**\n+         * Returns a 32-bit integer at the current {@code readerIndex} and increases the {@code readerIndex}\n+         * by {@code 4}.\n+         */\n+        public int readInt() {\n+            // fast path\n+            final ByteBuf firstBuf = queue.peek();\n+            if (firstBuf.readableBytes() >= 4) {\n+                return firstBuf.readInt();\n+            }\n+\n+            // slow path\n+            int value = 0;\n+            int remained = 4;\n+            for (ByteBuf buf : queue) {\n+                if (!buf.isReadable()) {\n+                    continue;\n+                }\n+                final int readSize = Math.min(remained, buf.readableBytes());\n+                if (readSize == 4) {\n+                    return buf.readInt();\n+                }\n+\n+                value <<= 8 * readSize;\n+                switch (readSize) {\n+                    case 1:\n+                        value |= buf.readUnsignedByte();\n+                        break;\n+                    case 2:\n+                        value |= buf.readUnsignedShort();\n+                        break;\n+                    case 3:\n+                        value |= buf.readUnsignedMedium();\n+                        break;\n+                    default:\n+                        throw new Error(); // Should not reach here.\n+                }\n+                remained -= readSize;\n+                if (remained == 0) {\n+                    break;\n+                }\n+            }\n+\n+            if (remained == 0) {\n+                return value;\n+            } else {\n+                throw new IndexOutOfBoundsException(\n+                        \"readerIndex: \" + (readerIndex() - 4 + remained) +\n+                        \" (expected: 0 <= readerIndex + 4 <= length(\" + length() + \"))\");\n+            }\n+        }\n+\n+        /**\n+         * Returns a newly retained slice of this {@link ByteBuf} at the current {@code readerIndex}\n+         * and increases the {@code readerIndex} by the specified {@code length}.\n+         *\n+         * @throws IndexOutOfBoundsException if the specified {@code length} is greater than {@link #length()}\n+         */\n+        public ByteBuf readBytes(int length) {\n+            // fast path\n+            final ByteBuf firstBuf = queue.peek();\n+            if (firstBuf.readableBytes() >= length) {\n+                return firstBuf.readRetainedSlice(length);\n+            }\n+\n+            // slow path\n+            ByteBuf value = null;\n+            int remained = length;\n+            for (ByteBuf buf : queue) {\n+                if (!buf.isReadable()) {\n+                    continue;\n+                }\n+\n+                final int readSize = Math.min(remained, buf.readableBytes());\n+                if (readSize == length) {\n+                    return buf.readRetainedSlice(readSize);\n+                } else {\n+                    if (value == null) {\n+                        value = alloc.buffer(length);\n+                    }\n+                    value.writeBytes(buf, readSize);\n+                    remained -= readSize;\n+                    if (remained == 0) {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if (remained > 0) {\n+                ReferenceCountUtil.release(value);\n+                throw new IndexOutOfBoundsException(\n+                        \"readerIndex: \" + (readerIndex() - length + remained) +\n+                        \" (expected: 0 <= readerIndex + \" + length + \" <= length(\" + length() + \"))\");\n+            }\n+\n+            return value;\n+        }\n+\n+        /**\n+         * Returns a byte at the specified absolute {@code index} in this {@link HttpDataReader}.\n+         * This method does not modify {@code readerIndex} of this {@link HttpDataReader}.\n+         */\n+        public byte getByte(int index) {", "originalCommit": "8cb8efed4e9edd1cc4b80fc3b28a54121772e916", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgwNDM3MA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r473804370", "bodyText": "This pattern is used to detect the boundary of a multipart.\nI thought this HttpDeframer could be used in MimeParser\nhttps://github.com/ikhoon/armeria/blob/c3683d21463b87b019912af794fa8708bd3d8ad0/core/src/main/java/com/linecorp/armeria/common/multipart/MimeParser.java#L338-L350", "author": "ikhoon", "createdAt": "2020-08-20T09:20:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI5OTIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1ODg5Ng==", "url": "https://github.com/line/armeria/pull/2981#discussion_r473958896", "bodyText": "By the way, the MimeParser logic is pretty complex. It would be better to use ByteBuf directly then HttpDeframerInput. Let me remove get*() methods from this.", "author": "ikhoon", "createdAt": "2020-08-20T13:14:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI5OTIyMw=="}], "type": "inlineReview"}, {"oid": "94dd1d11fd903e0010d2dd9a3465c901d38ec4fe", "url": "https://github.com/line/armeria/commit/94dd1d11fd903e0010d2dd9a3465c901d38ec4fe", "message": "Add HttpDataDeframer\n\nMotivation:\n\nBy adding a skeletal `Processor<HttpData, T>` implementation, we can easily get certain data\nthat is scattered across the data frame without individual queueing and assembling.\nAs a result, we can make `ArmeriaMessageDeframer` focus on decoding framed data to a gRPC message\nand remove resource management logic.\n\nModifications:\n\n- Add `HttpDataDeframer` and `HttpDataReader` for deframing a stream of `HttpData`\n- Migrate `ArmeriaMessageDeframer` and `HttpStreamReader` to use HttpDeframer\n\nResult:\n\n- Fixes #2925\n\nTODO:\n\n- Run benchmarks", "committedDate": "2020-08-25T05:14:22Z", "type": "commit"}, {"oid": "94dd1d11fd903e0010d2dd9a3465c901d38ec4fe", "url": "https://github.com/line/armeria/commit/94dd1d11fd903e0010d2dd9a3465c901d38ec4fe", "message": "Add HttpDataDeframer\n\nMotivation:\n\nBy adding a skeletal `Processor<HttpData, T>` implementation, we can easily get certain data\nthat is scattered across the data frame without individual queueing and assembling.\nAs a result, we can make `ArmeriaMessageDeframer` focus on decoding framed data to a gRPC message\nand remove resource management logic.\n\nModifications:\n\n- Add `HttpDataDeframer` and `HttpDataReader` for deframing a stream of `HttpData`\n- Migrate `ArmeriaMessageDeframer` and `HttpStreamReader` to use HttpDeframer\n\nResult:\n\n- Fixes #2925\n\nTODO:\n\n- Run benchmarks", "committedDate": "2020-08-25T05:14:22Z", "type": "forcePushed"}, {"oid": "94da918a7facc3b06e16604655cd69683d9d8707", "url": "https://github.com/line/armeria/commit/94da918a7facc3b06e16604655cd69683d9d8707", "message": "Clean up", "committedDate": "2020-08-25T05:27:26Z", "type": "commit"}, {"oid": "a1dee96702a8e8c77099b9d7f9ceae789c93eebc", "url": "https://github.com/line/armeria/commit/a1dee96702a8e8c77099b9d7f9ceae789c93eebc", "message": "Add validation", "committedDate": "2020-08-25T05:34:11Z", "type": "commit"}, {"oid": "051e6a584f381d5a32ee346926a9877296c4e3a5", "url": "https://github.com/line/armeria/commit/051e6a584f381d5a32ee346926a9877296c4e3a5", "message": "Add TCK for HttpStreamReader", "committedDate": "2020-08-26T06:56:07Z", "type": "commit"}, {"oid": "574ab90ee56a1170e2333173a6558ef11a793e9c", "url": "https://github.com/line/armeria/commit/574ab90ee56a1170e2333173a6558ef11a793e9c", "message": "Use directEventLoop for test", "committedDate": "2020-08-26T08:37:32Z", "type": "commit"}, {"oid": "2c9708baad1c205b28756e427a17fb7e3fb38d48", "url": "https://github.com/line/armeria/commit/2c9708baad1c205b28756e427a17fb7e3fb38d48", "message": "Report status when consumed", "committedDate": "2020-08-26T09:01:50Z", "type": "commit"}, {"oid": "8be0cc1b783d15dec2125a1115562c83851fa524", "url": "https://github.com/line/armeria/commit/8be0cc1b783d15dec2125a1115562c83851fa524", "message": "Fix leak in test", "committedDate": "2020-08-26T15:01:40Z", "type": "commit"}, {"oid": "2de01c19bcb09fd4636ddff74ab99b8d8d58b6bc", "url": "https://github.com/line/armeria/commit/2de01c19bcb09fd4636ddff74ab99b8d8d58b6bc", "message": "Fix indent and add guard", "committedDate": "2020-08-27T02:17:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk1MzQzMg==", "url": "https://github.com/line/armeria/pull/2981#discussion_r477953432", "bodyText": "We can move this into the above if statement and change the method parameter to use ResponseHeaders.\nprocessHeaders(ResponseHeaders in, HttpDeframerOutput<T> out)", "author": "minwoox", "createdAt": "2020-08-27T02:28:36Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A skeletal {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ */\n+@UnstableApi\n+public abstract class HttpDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpObject, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"subscribed\");\n+\n+    private final ByteBufDeframerInput input;\n+    private final EventExecutor eventLoop;\n+    private final ArrayDeque<T> outputQueue = new ArrayDeque<>();\n+\n+    private boolean sawLeadingHeaders;\n+\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean cancelled;\n+    private volatile int initialized;\n+    private volatile int subscribed;\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link EventExecutor} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    protected HttpDeframer(EventExecutor eventLoop, ByteBufAllocator alloc) {\n+        requireNonNull(eventLoop, \"eventLoop\");\n+        requireNonNull(alloc, \"alloc\");\n+        input = new ByteBufDeframerInput(alloc);\n+        this.eventLoop = eventLoop;\n+    }\n+\n+    /**\n+     * Converts the specified {@link HttpData} to {@link ByteBuf}.\n+     */\n+    protected ByteBuf convertToByteBuf(HttpData data) {\n+        return data.byteBuf();\n+    }\n+\n+    /**\n+     * Decodes a stream of {@link HttpData}s to N objects.\n+     * This method will be called whenever an {@link HttpData} is signaled from {@link Publisher}.\n+     */\n+    protected abstract void process(HttpDeframerInput in, HttpDeframerOutput<T> out);\n+\n+    private void process(HttpObject data) {\n+        if (data instanceof HttpHeaders) {\n+            final HttpHeaders headers = (HttpHeaders) data;\n+\n+            if (headers instanceof ResponseHeaders) {\n+                final ResponseHeaders responseHeaders = (ResponseHeaders) headers;\n+                if (responseHeaders.status().isInformational()) {\n+                    processInformationalHeaders(responseHeaders, outputQueue::addLast);\n+                    return;\n+                }\n+            }\n+\n+            if (!sawLeadingHeaders) {\n+                sawLeadingHeaders = true;\n+                processHeaders((HttpHeaders) data, outputQueue::addLast);", "originalCommit": "2de01c19bcb09fd4636ddff74ab99b8d8d58b6bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODAwNzQwNg==", "url": "https://github.com/line/armeria/pull/2981#discussion_r478007406", "bodyText": "HttpDeframer is used for both an HTTP request and response, so processHeaders should take HttpHeaders and handle it. \ud83d\ude09", "author": "ikhoon", "createdAt": "2020-08-27T03:07:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk1MzQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk2MDY3OA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r477960678", "bodyText": "How about putting Subscriber methods together?\n(i,e move this method down to onNext)", "author": "minwoox", "createdAt": "2020-08-27T02:33:48Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A skeletal {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ */\n+@UnstableApi\n+public abstract class HttpDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpObject, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"subscribed\");\n+\n+    private final ByteBufDeframerInput input;\n+    private final EventExecutor eventLoop;\n+    private final ArrayDeque<T> outputQueue = new ArrayDeque<>();\n+\n+    private boolean sawLeadingHeaders;\n+\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean cancelled;\n+    private volatile int initialized;\n+    private volatile int subscribed;\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link EventExecutor} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    protected HttpDeframer(EventExecutor eventLoop, ByteBufAllocator alloc) {\n+        requireNonNull(eventLoop, \"eventLoop\");\n+        requireNonNull(alloc, \"alloc\");\n+        input = new ByteBufDeframerInput(alloc);\n+        this.eventLoop = eventLoop;\n+    }\n+\n+    /**\n+     * Converts the specified {@link HttpData} to {@link ByteBuf}.\n+     */\n+    protected ByteBuf convertToByteBuf(HttpData data) {\n+        return data.byteBuf();\n+    }\n+\n+    /**\n+     * Decodes a stream of {@link HttpData}s to N objects.\n+     * This method will be called whenever an {@link HttpData} is signaled from {@link Publisher}.\n+     */\n+    protected abstract void process(HttpDeframerInput in, HttpDeframerOutput<T> out);\n+\n+    private void process(HttpObject data) {\n+        if (data instanceof HttpHeaders) {\n+            final HttpHeaders headers = (HttpHeaders) data;\n+\n+            if (headers instanceof ResponseHeaders) {\n+                final ResponseHeaders responseHeaders = (ResponseHeaders) headers;\n+                if (responseHeaders.status().isInformational()) {\n+                    processInformationalHeaders(responseHeaders, outputQueue::addLast);\n+                    return;\n+                }\n+            }\n+\n+            if (!sawLeadingHeaders) {\n+                sawLeadingHeaders = true;\n+                processHeaders((HttpHeaders) data, outputQueue::addLast);\n+            } else {\n+                processTrailers((HttpHeaders) data, outputQueue::addLast);\n+            }\n+            return;\n+        }\n+\n+        if (data instanceof HttpData) {\n+            input.add(convertToByteBuf((HttpData) data));\n+            process(input, outputQueue::addLast);\n+            input.discardReadBytes();\n+        }\n+    }\n+\n+    /**\n+     * Decodes an informational {@link ResponseHeaders} to N objects.\n+     */\n+    protected void processInformationalHeaders(ResponseHeaders in, HttpDeframerOutput<T> out) {}\n+\n+    /**\n+     * Decodes an non-informational {@link HttpHeaders} to N objects.\n+     */\n+    protected void processHeaders(HttpHeaders in, HttpDeframerOutput<T> out) {}\n+\n+    /**\n+     * Decodes a {@link HttpHeaders trailers} to N objects.\n+     */\n+    protected void processTrailers(HttpHeaders in, HttpDeframerOutput<T> out) {}\n+\n+    /**\n+     * Invoked when a {@link Throwable} is raised while deframing.\n+     */\n+    protected void processOnError(Throwable cause) {}\n+\n+    @Override\n+    public final void onSubscribe(Subscription subscription) {", "originalCommit": "2de01c19bcb09fd4636ddff74ab99b8d8d58b6bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk3MjMyMA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r477972320", "bodyText": "Let's assign upstream to a local variable so that we don't access the volatile field twice.", "author": "minwoox", "createdAt": "2020-08-27T02:42:01Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A skeletal {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ */\n+@UnstableApi\n+public abstract class HttpDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpObject, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"subscribed\");\n+\n+    private final ByteBufDeframerInput input;\n+    private final EventExecutor eventLoop;\n+    private final ArrayDeque<T> outputQueue = new ArrayDeque<>();\n+\n+    private boolean sawLeadingHeaders;\n+\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean cancelled;\n+    private volatile int initialized;\n+    private volatile int subscribed;\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link EventExecutor} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    protected HttpDeframer(EventExecutor eventLoop, ByteBufAllocator alloc) {\n+        requireNonNull(eventLoop, \"eventLoop\");\n+        requireNonNull(alloc, \"alloc\");\n+        input = new ByteBufDeframerInput(alloc);\n+        this.eventLoop = eventLoop;\n+    }\n+\n+    /**\n+     * Converts the specified {@link HttpData} to {@link ByteBuf}.\n+     */\n+    protected ByteBuf convertToByteBuf(HttpData data) {\n+        return data.byteBuf();\n+    }\n+\n+    /**\n+     * Decodes a stream of {@link HttpData}s to N objects.\n+     * This method will be called whenever an {@link HttpData} is signaled from {@link Publisher}.\n+     */\n+    protected abstract void process(HttpDeframerInput in, HttpDeframerOutput<T> out);\n+\n+    private void process(HttpObject data) {\n+        if (data instanceof HttpHeaders) {\n+            final HttpHeaders headers = (HttpHeaders) data;\n+\n+            if (headers instanceof ResponseHeaders) {\n+                final ResponseHeaders responseHeaders = (ResponseHeaders) headers;\n+                if (responseHeaders.status().isInformational()) {\n+                    processInformationalHeaders(responseHeaders, outputQueue::addLast);\n+                    return;\n+                }\n+            }\n+\n+            if (!sawLeadingHeaders) {\n+                sawLeadingHeaders = true;\n+                processHeaders((HttpHeaders) data, outputQueue::addLast);\n+            } else {\n+                processTrailers((HttpHeaders) data, outputQueue::addLast);\n+            }\n+            return;\n+        }\n+\n+        if (data instanceof HttpData) {\n+            input.add(convertToByteBuf((HttpData) data));\n+            process(input, outputQueue::addLast);\n+            input.discardReadBytes();\n+        }\n+    }\n+\n+    /**\n+     * Decodes an informational {@link ResponseHeaders} to N objects.\n+     */\n+    protected void processInformationalHeaders(ResponseHeaders in, HttpDeframerOutput<T> out) {}\n+\n+    /**\n+     * Decodes an non-informational {@link HttpHeaders} to N objects.\n+     */\n+    protected void processHeaders(HttpHeaders in, HttpDeframerOutput<T> out) {}\n+\n+    /**\n+     * Decodes a {@link HttpHeaders trailers} to N objects.\n+     */\n+    protected void processTrailers(HttpHeaders in, HttpDeframerOutput<T> out) {}\n+\n+    /**\n+     * Invoked when a {@link Throwable} is raised while deframing.\n+     */\n+    protected void processOnError(Throwable cause) {}\n+\n+    @Override\n+    public final void onSubscribe(Subscription subscription) {\n+        requireNonNull(subscription, \"subscription\");\n+        if (upstreamUpdater.compareAndSet(this, null, subscription)) {\n+            deferredInit();\n+        } else {\n+            subscription.cancel();\n+        }\n+    }\n+\n+    @Override\n+    final SubscriptionImpl subscribe(SubscriptionImpl subscription) {\n+        final SubscriptionImpl subscriptionImpl = super.subscribe(subscription);\n+        if (subscribedUpdater.compareAndSet(this, 0, 1)) {\n+            deferredInit();\n+        }\n+        return subscriptionImpl;\n+    }\n+\n+    private void deferredInit() {\n+        if (upstream != null && subscribed != 0) {", "originalCommit": "2de01c19bcb09fd4636ddff74ab99b8d8d58b6bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk3MjgzMw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r477972833", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-08-27T02:42:22Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A skeletal {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ */\n+@UnstableApi\n+public abstract class HttpDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpObject, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"subscribed\");\n+\n+    private final ByteBufDeframerInput input;\n+    private final EventExecutor eventLoop;\n+    private final ArrayDeque<T> outputQueue = new ArrayDeque<>();\n+\n+    private boolean sawLeadingHeaders;\n+\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean cancelled;\n+    private volatile int initialized;\n+    private volatile int subscribed;\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link EventExecutor} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    protected HttpDeframer(EventExecutor eventLoop, ByteBufAllocator alloc) {\n+        requireNonNull(eventLoop, \"eventLoop\");\n+        requireNonNull(alloc, \"alloc\");\n+        input = new ByteBufDeframerInput(alloc);\n+        this.eventLoop = eventLoop;\n+    }\n+\n+    /**\n+     * Converts the specified {@link HttpData} to {@link ByteBuf}.\n+     */\n+    protected ByteBuf convertToByteBuf(HttpData data) {\n+        return data.byteBuf();\n+    }\n+\n+    /**\n+     * Decodes a stream of {@link HttpData}s to N objects.\n+     * This method will be called whenever an {@link HttpData} is signaled from {@link Publisher}.\n+     */\n+    protected abstract void process(HttpDeframerInput in, HttpDeframerOutput<T> out);\n+\n+    private void process(HttpObject data) {\n+        if (data instanceof HttpHeaders) {\n+            final HttpHeaders headers = (HttpHeaders) data;\n+\n+            if (headers instanceof ResponseHeaders) {\n+                final ResponseHeaders responseHeaders = (ResponseHeaders) headers;\n+                if (responseHeaders.status().isInformational()) {\n+                    processInformationalHeaders(responseHeaders, outputQueue::addLast);\n+                    return;\n+                }\n+            }\n+\n+            if (!sawLeadingHeaders) {\n+                sawLeadingHeaders = true;\n+                processHeaders((HttpHeaders) data, outputQueue::addLast);\n+            } else {\n+                processTrailers((HttpHeaders) data, outputQueue::addLast);\n+            }\n+            return;\n+        }\n+\n+        if (data instanceof HttpData) {\n+            input.add(convertToByteBuf((HttpData) data));\n+            process(input, outputQueue::addLast);\n+            input.discardReadBytes();\n+        }\n+    }\n+\n+    /**\n+     * Decodes an informational {@link ResponseHeaders} to N objects.\n+     */\n+    protected void processInformationalHeaders(ResponseHeaders in, HttpDeframerOutput<T> out) {}\n+\n+    /**\n+     * Decodes an non-informational {@link HttpHeaders} to N objects.\n+     */\n+    protected void processHeaders(HttpHeaders in, HttpDeframerOutput<T> out) {}\n+\n+    /**\n+     * Decodes a {@link HttpHeaders trailers} to N objects.\n+     */\n+    protected void processTrailers(HttpHeaders in, HttpDeframerOutput<T> out) {}\n+\n+    /**\n+     * Invoked when a {@link Throwable} is raised while deframing.\n+     */\n+    protected void processOnError(Throwable cause) {}\n+\n+    @Override\n+    public final void onSubscribe(Subscription subscription) {\n+        requireNonNull(subscription, \"subscription\");\n+        if (upstreamUpdater.compareAndSet(this, null, subscription)) {\n+            deferredInit();\n+        } else {\n+            subscription.cancel();\n+        }\n+    }\n+\n+    @Override\n+    final SubscriptionImpl subscribe(SubscriptionImpl subscription) {\n+        final SubscriptionImpl subscriptionImpl = super.subscribe(subscription);\n+        if (subscribedUpdater.compareAndSet(this, 0, 1)) {\n+            deferredInit();\n+        }\n+        return subscriptionImpl;\n+    }\n+\n+    private void deferredInit() {\n+        if (upstream != null && subscribed != 0) {\n+            if (initializedUpdater.compareAndSet(this, 0, 1)) {\n+                if (demand() > 0) {\n+                    upstream.request(1);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    void request(long n) {\n+        if (initialized != 0 && outputQueue.isEmpty()) {\n+            upstream.request(1);\n+        }\n+        super.request(n);\n+    }\n+\n+    @Override\n+    void cancel() {\n+        cancelAndCleanup();\n+        super.cancel();\n+    }\n+\n+    @Override\n+    public final void onNext(HttpObject data) {\n+        if (eventLoop.inEventLoop()) {\n+            onNext0(data);\n+        } else {\n+            eventLoop.execute(() -> onNext0(data));\n+        }\n+    }\n+\n+    private void onNext0(HttpObject data) {\n+        try {\n+            process(data);\n+\n+            if (outputQueue.isEmpty()) {\n+                upstream.request(1);\n+            } else {\n+                for (;;) {\n+                    final T deframed = outputQueue.poll();\n+                    if (deframed != null) {\n+                        write(deframed);\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                whenConsumed().thenRun(() -> {\n+                    if (demand() > 0) {\n+                        upstream.request(1);\n+                    }\n+                });\n+            }\n+            input.discardReadBytes();\n+        } catch (Throwable ex) {\n+            Exceptions.throwIfFatal(ex);\n+            processOnError(ex);\n+            cancelAndCleanup();\n+            abort(ex);\n+        }\n+    }\n+\n+    private void cancelAndCleanup() {\n+        cancelled = true;\n+        if (upstream != null) {", "originalCommit": "2de01c19bcb09fd4636ddff74ab99b8d8d58b6bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk4MjI5Mw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r477982293", "bodyText": "demand is visible from the downstream subscription thread.\nHow we guarantee eventLoop is the same thread?\nShould we use the thread from the downstream SubscriptionImpl instead?", "author": "minwoox", "createdAt": "2020-08-27T02:49:21Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A skeletal {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ */\n+@UnstableApi\n+public abstract class HttpDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpObject, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"subscribed\");\n+\n+    private final ByteBufDeframerInput input;\n+    private final EventExecutor eventLoop;\n+    private final ArrayDeque<T> outputQueue = new ArrayDeque<>();\n+\n+    private boolean sawLeadingHeaders;\n+\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean cancelled;\n+    private volatile int initialized;\n+    private volatile int subscribed;\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link EventExecutor} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    protected HttpDeframer(EventExecutor eventLoop, ByteBufAllocator alloc) {\n+        requireNonNull(eventLoop, \"eventLoop\");\n+        requireNonNull(alloc, \"alloc\");\n+        input = new ByteBufDeframerInput(alloc);\n+        this.eventLoop = eventLoop;\n+    }\n+\n+    /**\n+     * Converts the specified {@link HttpData} to {@link ByteBuf}.\n+     */\n+    protected ByteBuf convertToByteBuf(HttpData data) {\n+        return data.byteBuf();\n+    }\n+\n+    /**\n+     * Decodes a stream of {@link HttpData}s to N objects.\n+     * This method will be called whenever an {@link HttpData} is signaled from {@link Publisher}.\n+     */\n+    protected abstract void process(HttpDeframerInput in, HttpDeframerOutput<T> out);\n+\n+    private void process(HttpObject data) {\n+        if (data instanceof HttpHeaders) {\n+            final HttpHeaders headers = (HttpHeaders) data;\n+\n+            if (headers instanceof ResponseHeaders) {\n+                final ResponseHeaders responseHeaders = (ResponseHeaders) headers;\n+                if (responseHeaders.status().isInformational()) {\n+                    processInformationalHeaders(responseHeaders, outputQueue::addLast);\n+                    return;\n+                }\n+            }\n+\n+            if (!sawLeadingHeaders) {\n+                sawLeadingHeaders = true;\n+                processHeaders((HttpHeaders) data, outputQueue::addLast);\n+            } else {\n+                processTrailers((HttpHeaders) data, outputQueue::addLast);\n+            }\n+            return;\n+        }\n+\n+        if (data instanceof HttpData) {\n+            input.add(convertToByteBuf((HttpData) data));\n+            process(input, outputQueue::addLast);\n+            input.discardReadBytes();\n+        }\n+    }\n+\n+    /**\n+     * Decodes an informational {@link ResponseHeaders} to N objects.\n+     */\n+    protected void processInformationalHeaders(ResponseHeaders in, HttpDeframerOutput<T> out) {}\n+\n+    /**\n+     * Decodes an non-informational {@link HttpHeaders} to N objects.\n+     */\n+    protected void processHeaders(HttpHeaders in, HttpDeframerOutput<T> out) {}\n+\n+    /**\n+     * Decodes a {@link HttpHeaders trailers} to N objects.\n+     */\n+    protected void processTrailers(HttpHeaders in, HttpDeframerOutput<T> out) {}\n+\n+    /**\n+     * Invoked when a {@link Throwable} is raised while deframing.\n+     */\n+    protected void processOnError(Throwable cause) {}\n+\n+    @Override\n+    public final void onSubscribe(Subscription subscription) {\n+        requireNonNull(subscription, \"subscription\");\n+        if (upstreamUpdater.compareAndSet(this, null, subscription)) {\n+            deferredInit();\n+        } else {\n+            subscription.cancel();\n+        }\n+    }\n+\n+    @Override\n+    final SubscriptionImpl subscribe(SubscriptionImpl subscription) {\n+        final SubscriptionImpl subscriptionImpl = super.subscribe(subscription);\n+        if (subscribedUpdater.compareAndSet(this, 0, 1)) {\n+            deferredInit();\n+        }\n+        return subscriptionImpl;\n+    }\n+\n+    private void deferredInit() {\n+        if (upstream != null && subscribed != 0) {\n+            if (initializedUpdater.compareAndSet(this, 0, 1)) {\n+                if (demand() > 0) {\n+                    upstream.request(1);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    void request(long n) {\n+        if (initialized != 0 && outputQueue.isEmpty()) {\n+            upstream.request(1);\n+        }\n+        super.request(n);\n+    }\n+\n+    @Override\n+    void cancel() {\n+        cancelAndCleanup();\n+        super.cancel();\n+    }\n+\n+    @Override\n+    public final void onNext(HttpObject data) {\n+        if (eventLoop.inEventLoop()) {\n+            onNext0(data);\n+        } else {\n+            eventLoop.execute(() -> onNext0(data));\n+        }\n+    }\n+\n+    private void onNext0(HttpObject data) {\n+        try {\n+            process(data);\n+\n+            if (outputQueue.isEmpty()) {\n+                upstream.request(1);\n+            } else {\n+                for (;;) {\n+                    final T deframed = outputQueue.poll();\n+                    if (deframed != null) {\n+                        write(deframed);\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                whenConsumed().thenRun(() -> {\n+                    if (demand() > 0) {", "originalCommit": "2de01c19bcb09fd4636ddff74ab99b8d8d58b6bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODA0MDcyNg==", "url": "https://github.com/line/armeria/pull/2981#discussion_r478040726", "bodyText": "How we guarantee eventLoop is the same thread?\nShould we use the thread from the downstream SubscriptionImpl instead?\n\nThat's a good point. The publisher is subscribed internally and only used the request-scoped thread. That means the eventLoop of HttpDeframer is the same as downstream's thread.\nAs a micro-optimization, I think it works safely.\nBy the way, if you think this assumption is hard-coded, I would fix it to use SubscriptionImpl's thread instead of injecting eventLoop from the constructor.", "author": "ikhoon", "createdAt": "2020-08-27T03:31:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk4MjI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODA0OTg1OA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r478049858", "bodyText": "If so, how about adding a logic that checks the two threads are the same?", "author": "minwoox", "createdAt": "2020-08-27T03:38:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk4MjI5Mw=="}], "type": "inlineReview"}, {"oid": "bf36a7e19fc889cf4e3fca3927be593b8bfbc497", "url": "https://github.com/line/armeria/commit/bf36a7e19fc889cf4e3fca3927be593b8bfbc497", "message": "Address comments from @minwoox", "committedDate": "2020-08-27T03:36:32Z", "type": "commit"}, {"oid": "7ab02ba8e0072cd8e9d69fc449724442a666d2ce", "url": "https://github.com/line/armeria/commit/7ab02ba8e0072cd8e9d69fc449724442a666d2ce", "message": "Remove blank line", "committedDate": "2020-08-27T03:39:28Z", "type": "commit"}, {"oid": "886dbac7525ec71be63d7715f2e77c5e4d735a07", "url": "https://github.com/line/armeria/commit/886dbac7525ec71be63d7715f2e77c5e4d735a07", "message": "Address comments by @minwoox, assert in the callback of 'whenComsumed'", "committedDate": "2020-08-27T04:15:44Z", "type": "commit"}, {"oid": "a0d3d4518122dc708ac4a6ca6a84716b063b87fd", "url": "https://github.com/line/armeria/commit/a0d3d4518122dc708ac4a6ca6a84716b063b87fd", "message": "Move assert to 'subscribe(SubscriptionImpl)'", "committedDate": "2020-08-27T04:59:46Z", "type": "commit"}, {"oid": "fb091d30f5ad3b189f185bc744911dc59c176634", "url": "https://github.com/line/armeria/commit/fb091d30f5ad3b189f185bc744911dc59c176634", "message": "Remove 'eventLoop' from the contructor of HttpDefarmer", "committedDate": "2020-08-27T05:25:41Z", "type": "commit"}, {"oid": "7f74b7ea0cf3fea2905148c58e1ed31adbd4f2b1", "url": "https://github.com/line/armeria/commit/7f74b7ea0cf3fea2905148c58e1ed31adbd4f2b1", "message": "Fix broken tests", "committedDate": "2020-08-27T07:41:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMjA4MA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r481512080", "bodyText": "Shoudn't we decrease the demand?", "author": "minwoox", "createdAt": "2020-09-02T00:49:29Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A skeletal {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ */\n+@UnstableApi\n+public abstract class HttpDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpObject, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"subscribed\");\n+\n+    private final ByteBufDeframerInput input;\n+    private final ArrayDeque<T> outputQueue = new ArrayDeque<>();\n+\n+    private boolean sawLeadingHeaders;\n+\n+    @Nullable\n+    private volatile EventExecutor eventLoop;\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean cancelled;\n+    private volatile int initialized;\n+    private volatile int subscribed;\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link EventExecutor} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    protected HttpDeframer(ByteBufAllocator alloc) {\n+        requireNonNull(alloc, \"alloc\");\n+        input = new ByteBufDeframerInput(alloc);\n+    }\n+\n+    /**\n+     * Converts the specified {@link HttpData} to {@link ByteBuf}.\n+     */\n+    protected ByteBuf convertToByteBuf(HttpData data) {\n+        return data.byteBuf();\n+    }\n+\n+    /**\n+     * Decodes a stream of {@link HttpData}s to N objects.\n+     * This method will be called whenever an {@link HttpData} is signaled from {@link Publisher}.\n+     */\n+    protected abstract void process(HttpDeframerInput in, HttpDeframerOutput<T> out);\n+\n+    private void process(HttpObject data) {\n+        if (data instanceof HttpHeaders) {\n+            final HttpHeaders headers = (HttpHeaders) data;\n+\n+            if (headers instanceof ResponseHeaders) {\n+                final ResponseHeaders responseHeaders = (ResponseHeaders) headers;\n+                if (responseHeaders.status().isInformational()) {\n+                    processInformationalHeaders(responseHeaders, outputQueue::addLast);\n+                    return;\n+                }\n+            }\n+\n+            if (!sawLeadingHeaders) {\n+                sawLeadingHeaders = true;\n+                processHeaders((HttpHeaders) data, outputQueue::addLast);\n+            } else {\n+                processTrailers((HttpHeaders) data, outputQueue::addLast);\n+            }\n+            return;\n+        }\n+\n+        if (data instanceof HttpData) {\n+            input.add(convertToByteBuf((HttpData) data));\n+            process(input, outputQueue::addLast);\n+            input.discardReadBytes();\n+        }\n+    }\n+\n+    /**\n+     * Decodes an informational {@link ResponseHeaders} to N objects.\n+     */\n+    protected void processInformationalHeaders(ResponseHeaders in, HttpDeframerOutput<T> out) {}\n+\n+    /**\n+     * Decodes an non-informational {@link HttpHeaders} to N objects.\n+     */\n+    protected void processHeaders(HttpHeaders in, HttpDeframerOutput<T> out) {}\n+\n+    /**\n+     * Decodes a {@link HttpHeaders trailers} to N objects.\n+     */\n+    protected void processTrailers(HttpHeaders in, HttpDeframerOutput<T> out) {}\n+\n+    /**\n+     * Invoked when a {@link Throwable} is raised while deframing.\n+     */\n+    protected void processOnError(Throwable cause) {}\n+\n+    @Override\n+    final SubscriptionImpl subscribe(SubscriptionImpl subscription) {\n+        final SubscriptionImpl subscriptionImpl = super.subscribe(subscription);\n+        if (subscribedUpdater.compareAndSet(this, 0, 1)) {\n+            eventLoop = subscription.executor();\n+            deferredInit();\n+        }\n+        return subscriptionImpl;\n+    }\n+\n+    private void deferredInit() {\n+        final Subscription upstream = this.upstream;\n+        if (upstream != null && subscribed != 0) {\n+            if (initializedUpdater.compareAndSet(this, 0, 1)) {\n+                if (demand() > 0) {\n+                    upstream.request(1);", "originalCommit": "7f74b7ea0cf3fea2905148c58e1ed31adbd4f2b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU1NDEyMw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r481554123", "bodyText": "The demand will be decreased when writing deframed data because this processor handles N to M conversion.\nhttps://github.com/line/armeriahttps://github.com/line/armeria/blob/fb091d30f5ad3b189f185bc744911dc59c176634/core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java#L206-L213", "author": "ikhoon", "createdAt": "2020-09-02T02:10:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMjA4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU1Njk4MQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r481556981", "bodyText": "Ah, thanks. I missed that. \ud83d\ude05", "author": "minwoox", "createdAt": "2020-09-02T02:15:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMjA4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg4OTcyOQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r513889729", "bodyText": "Could you leave a comment for this please?", "author": "minwoox", "createdAt": "2020-10-29T02:32:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMjA4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMjEzMA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r481512130", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-09-02T00:49:42Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A skeletal {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ */\n+@UnstableApi\n+public abstract class HttpDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpObject, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"subscribed\");\n+\n+    private final ByteBufDeframerInput input;\n+    private final ArrayDeque<T> outputQueue = new ArrayDeque<>();\n+\n+    private boolean sawLeadingHeaders;\n+\n+    @Nullable\n+    private volatile EventExecutor eventLoop;\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean cancelled;\n+    private volatile int initialized;\n+    private volatile int subscribed;\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link EventExecutor} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    protected HttpDeframer(ByteBufAllocator alloc) {\n+        requireNonNull(alloc, \"alloc\");\n+        input = new ByteBufDeframerInput(alloc);\n+    }\n+\n+    /**\n+     * Converts the specified {@link HttpData} to {@link ByteBuf}.\n+     */\n+    protected ByteBuf convertToByteBuf(HttpData data) {\n+        return data.byteBuf();\n+    }\n+\n+    /**\n+     * Decodes a stream of {@link HttpData}s to N objects.\n+     * This method will be called whenever an {@link HttpData} is signaled from {@link Publisher}.\n+     */\n+    protected abstract void process(HttpDeframerInput in, HttpDeframerOutput<T> out);\n+\n+    private void process(HttpObject data) {\n+        if (data instanceof HttpHeaders) {\n+            final HttpHeaders headers = (HttpHeaders) data;\n+\n+            if (headers instanceof ResponseHeaders) {\n+                final ResponseHeaders responseHeaders = (ResponseHeaders) headers;\n+                if (responseHeaders.status().isInformational()) {\n+                    processInformationalHeaders(responseHeaders, outputQueue::addLast);\n+                    return;\n+                }\n+            }\n+\n+            if (!sawLeadingHeaders) {\n+                sawLeadingHeaders = true;\n+                processHeaders((HttpHeaders) data, outputQueue::addLast);\n+            } else {\n+                processTrailers((HttpHeaders) data, outputQueue::addLast);\n+            }\n+            return;\n+        }\n+\n+        if (data instanceof HttpData) {\n+            input.add(convertToByteBuf((HttpData) data));\n+            process(input, outputQueue::addLast);\n+            input.discardReadBytes();\n+        }\n+    }\n+\n+    /**\n+     * Decodes an informational {@link ResponseHeaders} to N objects.\n+     */\n+    protected void processInformationalHeaders(ResponseHeaders in, HttpDeframerOutput<T> out) {}\n+\n+    /**\n+     * Decodes an non-informational {@link HttpHeaders} to N objects.\n+     */\n+    protected void processHeaders(HttpHeaders in, HttpDeframerOutput<T> out) {}\n+\n+    /**\n+     * Decodes a {@link HttpHeaders trailers} to N objects.\n+     */\n+    protected void processTrailers(HttpHeaders in, HttpDeframerOutput<T> out) {}\n+\n+    /**\n+     * Invoked when a {@link Throwable} is raised while deframing.\n+     */\n+    protected void processOnError(Throwable cause) {}\n+\n+    @Override\n+    final SubscriptionImpl subscribe(SubscriptionImpl subscription) {\n+        final SubscriptionImpl subscriptionImpl = super.subscribe(subscription);\n+        if (subscribedUpdater.compareAndSet(this, 0, 1)) {\n+            eventLoop = subscription.executor();\n+            deferredInit();\n+        }\n+        return subscriptionImpl;\n+    }\n+\n+    private void deferredInit() {\n+        final Subscription upstream = this.upstream;\n+        if (upstream != null && subscribed != 0) {\n+            if (initializedUpdater.compareAndSet(this, 0, 1)) {\n+                if (demand() > 0) {\n+                    upstream.request(1);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    void request(long n) {\n+        if (initialized != 0 && outputQueue.isEmpty()) {\n+            upstream.request(1);\n+        }\n+        super.request(n);\n+    }\n+\n+    @Override\n+    void cancel() {\n+        cancelAndCleanup();\n+        super.cancel();\n+    }\n+\n+    @Override\n+    public final void onSubscribe(Subscription subscription) {\n+        requireNonNull(subscription, \"subscription\");\n+        if (upstreamUpdater.compareAndSet(this, null, subscription)) {\n+            deferredInit();\n+        } else {\n+            subscription.cancel();\n+        }\n+    }\n+\n+    @Override\n+    public final void onNext(HttpObject data) {\n+        final EventExecutor eventLoop = this.eventLoop;\n+        if (eventLoop.inEventLoop()) {\n+            onNext0(data);\n+        } else {\n+            eventLoop.execute(() -> onNext0(data));\n+        }\n+    }\n+\n+    private void onNext0(HttpObject data) {\n+        try {\n+            process(data);\n+\n+            final Subscription upstream = this.upstream;\n+            if (outputQueue.isEmpty()) {\n+                upstream.request(1);\n+            } else {\n+                for (;;) {\n+                    final T deframed = outputQueue.poll();\n+                    if (deframed != null) {\n+                        write(deframed);\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                whenConsumed().thenRun(() -> {\n+                    if (demand() > 0) {\n+                        upstream.request(1);", "originalCommit": "7f74b7ea0cf3fea2905148c58e1ed31adbd4f2b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU1NDgyMg==", "url": "https://github.com/line/armeria/pull/2981#discussion_r481554822", "bodyText": "Commented at #2981 (comment) \ud83d\ude00", "author": "ikhoon", "createdAt": "2020-09-02T02:11:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMjEzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxOTI1NA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r481519254", "bodyText": "If we want to throw an exception and never use this instance, shouldn't we clear the queue in order not to leak the buffer? because there might be a change that HttpDeframer.cleanup() is not called?", "author": "minwoox", "createdAt": "2020-09-02T01:06:29Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/ByteBufDeframerInput.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.ReferenceCountUtil;\n+\n+final class ByteBufDeframerInput implements HttpDeframerInput {\n+\n+    private final ByteBufAllocator alloc;\n+    private final Queue<ByteBuf> queue;\n+\n+    ByteBufDeframerInput(ByteBufAllocator alloc) {\n+        this.alloc = alloc;\n+        queue = new ArrayDeque<>();\n+    }\n+\n+    void add(ByteBuf byteBuf) {\n+        queue.add(byteBuf);\n+    }\n+\n+    @Override\n+    public int readableBytes() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int readableBytes = 0;\n+        for (ByteBuf buf : queue) {\n+            readableBytes += buf.readableBytes();\n+        }\n+        return readableBytes;\n+    }\n+\n+    private int readerIndex() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int value = 0;\n+        for (ByteBuf buf : queue) {\n+            value += buf.readerIndex();\n+        }\n+        return value;\n+    }\n+\n+    private int writerIndex() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int value = 0;\n+        for (ByteBuf buf : queue) {\n+            value += buf.writerIndex();\n+        }\n+        return value;\n+    }\n+\n+    @Override\n+    public byte readByte() {\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+            return buf.readByte();\n+        }\n+        throw new IndexOutOfBoundsException(\n+                \"readerIndex: \" + readerIndex() +\n+                \" (expected: 0 <= readerIndex < writerIndex(\" + writerIndex() + \"))\");\n+    }\n+\n+    @Override\n+    public int readInt() {\n+        final ByteBuf firstBuf = queue.peek();\n+        if (firstBuf == null) {\n+            throw new IndexOutOfBoundsException(\n+                    \"readerIndex: \" + readerIndex() +\n+                    \" (expected: 0 <= readerIndex < writerIndex(\" + writerIndex() + \"))\");\n+        }\n+\n+        if (firstBuf.readableBytes() >= 4) {\n+            return firstBuf.readInt();\n+        }\n+\n+        return readIntSlow();\n+    }\n+\n+    private int readIntSlow() {\n+        int value = 0;\n+        int remained = 4;\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+            final int readSize = Math.min(remained, buf.readableBytes());\n+            if (readSize == 4) {\n+                return buf.readInt();\n+            }\n+\n+            value <<= 8 * readSize;\n+            switch (readSize) {\n+                case 1:\n+                    value |= buf.readUnsignedByte();\n+                    break;\n+                case 2:\n+                    value |= buf.readUnsignedShort();\n+                    break;\n+                case 3:\n+                    value |= buf.readUnsignedMedium();\n+                    break;\n+                default:\n+                    throw new Error(); // Should not reach here.\n+            }\n+            remained -= readSize;\n+            if (remained == 0) {\n+                break;\n+            }\n+        }\n+\n+        if (remained == 0) {\n+            return value;\n+        } else {\n+            throw new IndexOutOfBoundsException(", "originalCommit": "7f74b7ea0cf3fea2905148c58e1ed31adbd4f2b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU4MDk3Mg==", "url": "https://github.com/line/armeria/pull/2981#discussion_r481580972", "bodyText": "How about implementing AutoCloseable? That could be a good indicator that the HttpDeframerInput should be closed.", "author": "ikhoon", "createdAt": "2020-09-02T02:52:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxOTI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU5MDg3MQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r481590871", "bodyText": "That sounds good. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-09-02T03:08:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxOTI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUyMTU5Mg==", "url": "https://github.com/line/armeria/pull/2981#discussion_r481521592", "bodyText": "nit: has -> have, is -> are", "author": "minwoox", "createdAt": "2020-09-02T01:15:54Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/ByteBufDeframerInput.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.ReferenceCountUtil;\n+\n+final class ByteBufDeframerInput implements HttpDeframerInput {\n+\n+    private final ByteBufAllocator alloc;\n+    private final Queue<ByteBuf> queue;\n+\n+    ByteBufDeframerInput(ByteBufAllocator alloc) {\n+        this.alloc = alloc;\n+        queue = new ArrayDeque<>();\n+    }\n+\n+    void add(ByteBuf byteBuf) {\n+        queue.add(byteBuf);\n+    }\n+\n+    @Override\n+    public int readableBytes() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int readableBytes = 0;\n+        for (ByteBuf buf : queue) {\n+            readableBytes += buf.readableBytes();\n+        }\n+        return readableBytes;\n+    }\n+\n+    private int readerIndex() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int value = 0;\n+        for (ByteBuf buf : queue) {\n+            value += buf.readerIndex();\n+        }\n+        return value;\n+    }\n+\n+    private int writerIndex() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int value = 0;\n+        for (ByteBuf buf : queue) {\n+            value += buf.writerIndex();\n+        }\n+        return value;\n+    }\n+\n+    @Override\n+    public byte readByte() {\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+            return buf.readByte();\n+        }\n+        throw new IndexOutOfBoundsException(\n+                \"readerIndex: \" + readerIndex() +\n+                \" (expected: 0 <= readerIndex < writerIndex(\" + writerIndex() + \"))\");\n+    }\n+\n+    @Override\n+    public int readInt() {\n+        final ByteBuf firstBuf = queue.peek();\n+        if (firstBuf == null) {\n+            throw new IndexOutOfBoundsException(\n+                    \"readerIndex: \" + readerIndex() +\n+                    \" (expected: 0 <= readerIndex < writerIndex(\" + writerIndex() + \"))\");\n+        }\n+\n+        if (firstBuf.readableBytes() >= 4) {\n+            return firstBuf.readInt();\n+        }\n+\n+        return readIntSlow();\n+    }\n+\n+    private int readIntSlow() {\n+        int value = 0;\n+        int remained = 4;\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+            final int readSize = Math.min(remained, buf.readableBytes());\n+            if (readSize == 4) {\n+                return buf.readInt();\n+            }\n+\n+            value <<= 8 * readSize;\n+            switch (readSize) {\n+                case 1:\n+                    value |= buf.readUnsignedByte();\n+                    break;\n+                case 2:\n+                    value |= buf.readUnsignedShort();\n+                    break;\n+                case 3:\n+                    value |= buf.readUnsignedMedium();\n+                    break;\n+                default:\n+                    throw new Error(); // Should not reach here.\n+            }\n+            remained -= readSize;\n+            if (remained == 0) {\n+                break;\n+            }\n+        }\n+\n+        if (remained == 0) {\n+            return value;\n+        } else {\n+            throw new IndexOutOfBoundsException(\n+                    \"readerIndex: \" + (readerIndex() - 4 + remained) +\n+                    \" (expected: 0 < readerIndex + 4 <= writerIndex(\" + writerIndex() + \"))\");\n+        }\n+    }\n+\n+    @Override\n+    public ByteBuf readBytes(int length) {\n+        checkArgument(length > 0, \"length %s (expected: length > 0)\", length);\n+        final ByteBuf firstBuf = queue.peek();\n+        if (firstBuf == null) {\n+            throw new IndexOutOfBoundsException(\n+                    \"readerIndex: \" + readerIndex() +\n+                    \" (expected: 0 <= readerIndex < writerIndex(\" + writerIndex() + \"))\");\n+        }\n+\n+        if (firstBuf.readableBytes() >= length) {\n+            return firstBuf.readRetainedSlice(length);\n+        }\n+\n+        return readBytesSlow(length);\n+    }\n+\n+    private ByteBuf readBytesSlow(int length) {\n+        ByteBuf value = null;\n+        int remained = length;\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+\n+            final int readSize = Math.min(remained, buf.readableBytes());\n+            if (readSize == length) {\n+                return buf.readRetainedSlice(readSize);\n+            } else {\n+                if (value == null) {\n+                    value = alloc.buffer(length);\n+                }\n+                value.writeBytes(buf, readSize);\n+                remained -= readSize;\n+                if (remained == 0) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (remained > 0 || value == null) {\n+            ReferenceCountUtil.release(value);\n+            throw new IndexOutOfBoundsException(\n+                    \"readerIndex: \" + readerIndex() +\n+                    \" (expected: 0 < readerIndex + \" + length + \" <= writerIndex(\" + writerIndex() + \"))\");\n+        }\n+\n+        return value;\n+    }\n+\n+    /**\n+     * Discards the {@link ByteBuf}s that has been fully consumed and is not readable anymore.", "originalCommit": "7f74b7ea0cf3fea2905148c58e1ed31adbd4f2b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUyMTg4MA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r481521880", "bodyText": "Question: do you think it's worth releasing the buf as soon as it's consumed?", "author": "minwoox", "createdAt": "2020-09-02T01:16:59Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/ByteBufDeframerInput.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.ReferenceCountUtil;\n+\n+final class ByteBufDeframerInput implements HttpDeframerInput {\n+\n+    private final ByteBufAllocator alloc;\n+    private final Queue<ByteBuf> queue;\n+\n+    ByteBufDeframerInput(ByteBufAllocator alloc) {\n+        this.alloc = alloc;\n+        queue = new ArrayDeque<>();\n+    }\n+\n+    void add(ByteBuf byteBuf) {\n+        queue.add(byteBuf);\n+    }\n+\n+    @Override\n+    public int readableBytes() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int readableBytes = 0;\n+        for (ByteBuf buf : queue) {\n+            readableBytes += buf.readableBytes();\n+        }\n+        return readableBytes;\n+    }\n+\n+    private int readerIndex() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int value = 0;\n+        for (ByteBuf buf : queue) {\n+            value += buf.readerIndex();\n+        }\n+        return value;\n+    }\n+\n+    private int writerIndex() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int value = 0;\n+        for (ByteBuf buf : queue) {\n+            value += buf.writerIndex();\n+        }\n+        return value;\n+    }\n+\n+    @Override\n+    public byte readByte() {\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+            return buf.readByte();\n+        }\n+        throw new IndexOutOfBoundsException(\n+                \"readerIndex: \" + readerIndex() +\n+                \" (expected: 0 <= readerIndex < writerIndex(\" + writerIndex() + \"))\");\n+    }\n+\n+    @Override\n+    public int readInt() {\n+        final ByteBuf firstBuf = queue.peek();\n+        if (firstBuf == null) {\n+            throw new IndexOutOfBoundsException(\n+                    \"readerIndex: \" + readerIndex() +\n+                    \" (expected: 0 <= readerIndex < writerIndex(\" + writerIndex() + \"))\");\n+        }\n+\n+        if (firstBuf.readableBytes() >= 4) {\n+            return firstBuf.readInt();\n+        }\n+\n+        return readIntSlow();\n+    }\n+\n+    private int readIntSlow() {\n+        int value = 0;\n+        int remained = 4;\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+            final int readSize = Math.min(remained, buf.readableBytes());\n+            if (readSize == 4) {\n+                return buf.readInt();\n+            }\n+\n+            value <<= 8 * readSize;\n+            switch (readSize) {\n+                case 1:\n+                    value |= buf.readUnsignedByte();\n+                    break;\n+                case 2:\n+                    value |= buf.readUnsignedShort();\n+                    break;\n+                case 3:\n+                    value |= buf.readUnsignedMedium();\n+                    break;\n+                default:\n+                    throw new Error(); // Should not reach here.\n+            }\n+            remained -= readSize;\n+            if (remained == 0) {\n+                break;\n+            }\n+        }\n+\n+        if (remained == 0) {\n+            return value;\n+        } else {\n+            throw new IndexOutOfBoundsException(\n+                    \"readerIndex: \" + (readerIndex() - 4 + remained) +\n+                    \" (expected: 0 < readerIndex + 4 <= writerIndex(\" + writerIndex() + \"))\");\n+        }\n+    }\n+\n+    @Override\n+    public ByteBuf readBytes(int length) {\n+        checkArgument(length > 0, \"length %s (expected: length > 0)\", length);\n+        final ByteBuf firstBuf = queue.peek();\n+        if (firstBuf == null) {\n+            throw new IndexOutOfBoundsException(\n+                    \"readerIndex: \" + readerIndex() +\n+                    \" (expected: 0 <= readerIndex < writerIndex(\" + writerIndex() + \"))\");\n+        }\n+\n+        if (firstBuf.readableBytes() >= length) {\n+            return firstBuf.readRetainedSlice(length);\n+        }\n+\n+        return readBytesSlow(length);\n+    }\n+\n+    private ByteBuf readBytesSlow(int length) {\n+        ByteBuf value = null;\n+        int remained = length;\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+\n+            final int readSize = Math.min(remained, buf.readableBytes());\n+            if (readSize == length) {\n+                return buf.readRetainedSlice(readSize);\n+            } else {\n+                if (value == null) {\n+                    value = alloc.buffer(length);\n+                }\n+                value.writeBytes(buf, readSize);", "originalCommit": "7f74b7ea0cf3fea2905148c58e1ed31adbd4f2b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU2MjczOQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r481562739", "bodyText": "The consumed buf will be released right after process() is returned.\nI think it would be nice to release buf only one time then checking every time whenever buf is read.", "author": "ikhoon", "createdAt": "2020-09-02T02:24:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUyMTg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAyNTUxNA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504025514", "bodyText": "I'd prefer removing and releasing immediately, because otherwise we'll have to skip many empty buffers when the input is fragmented heavily. Not always very likely, but not too hard/complicated to implement..", "author": "trustin", "createdAt": "2020-10-13T15:01:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUyMTg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUyNjUwMA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r481526500", "bodyText": "Can we have test cases for N < M and N > M(if there already exists could you add a little comment or rename to recognize easily?)\nAlso, can we verify that the downstream subscriber actually gets what it demands by counting one by one in those test cases?", "author": "minwoox", "createdAt": "2020-09-02T01:26:51Z", "path": "core/src/test/java/com/linecorp/armeria/common/stream/HttpDeframerTest.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.UnpooledByteBufAllocator;\n+import reactor.core.publisher.Flux;\n+import reactor.test.StepVerifier;\n+\n+class HttpDeframerTest {\n+\n+    @Test\n+    void insufficientData() {", "originalCommit": "7f74b7ea0cf3fea2905148c58e1ed31adbd4f2b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU2NzQzNQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r481567435", "bodyText": "Can we have test cases for N < M and N > M(if there already exists could you add a little comment or rename to recognize easily?)\n\nIt was tested already. \ud83d\ude05 Let me clarify it.\n\nAlso, can we verify that the downstream subscriber actually gets what it demands by counting one by one in those test cases?\n\nThe backpressure would be covered by HttpStreamReaderTckTest.\n\n  \n    \n      armeria/grpc/src/test/java/com/linecorp/armeria/internal/common/grpc/HttpStreamReaderTckTest.java\n    \n    \n         Line 41\n      in\n      fb091d3\n    \n    \n    \n    \n\n        \n          \n           public class HttpStreamReaderTckTest extends PublisherVerification<DeframedMessage> { \n        \n    \n  \n\n\nHowever, it looks good to add verification for HttpDeframer itself.", "author": "ikhoon", "createdAt": "2020-09-02T02:31:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUyNjUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzODAxNQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r481538015", "bodyText": "Shouldn't we handle informational headers?", "author": "minwoox", "createdAt": "2020-09-02T01:44:52Z", "path": "grpc/src/main/java/com/linecorp/armeria/internal/common/grpc/HttpStreamReader.java", "diffHunk": "@@ -20,202 +20,105 @@\n \n import javax.annotation.Nullable;\n \n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n+import org.reactivestreams.Processor;\n \n-import com.google.common.annotations.VisibleForTesting;\n-\n-import com.linecorp.armeria.common.HttpData;\n import com.linecorp.armeria.common.HttpHeaderNames;\n import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.HttpObject;\n import com.linecorp.armeria.common.HttpStatus;\n import com.linecorp.armeria.common.grpc.protocol.ArmeriaMessageDeframer;\n+import com.linecorp.armeria.common.grpc.protocol.Decompressor;\n import com.linecorp.armeria.common.grpc.protocol.GrpcHeaderNames;\n-import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n+import com.linecorp.armeria.common.stream.HttpDeframerOutput;\n \n-import io.grpc.Decompressor;\n import io.grpc.DecompressorRegistry;\n import io.grpc.Status;\n+import io.netty.buffer.ByteBufAllocator;\n \n /**\n- * A {@link Subscriber} to read HTTP messages and pass to gRPC business logic.\n+ * A {@link Processor} to read HTTP messages and pass to gRPC business logic.\n  */\n-public final class HttpStreamReader implements Subscriber<HttpObject> {\n+public final class HttpStreamReader extends ArmeriaMessageDeframer {\n \n     private final DecompressorRegistry decompressorRegistry;\n     private final TransportStatusListener transportStatusListener;\n \n-    @VisibleForTesting\n-    public final ArmeriaMessageDeframer deframer;\n-\n-    @Nullable\n-    private Subscription subscription;\n-\n-    private int deferredInitialMessageRequest;\n-\n-    private volatile boolean cancelled;\n-\n-    private boolean sawLeadingHeaders;\n-\n     public HttpStreamReader(DecompressorRegistry decompressorRegistry,\n-                            ArmeriaMessageDeframer deframer,\n-                            TransportStatusListener transportStatusListener) {\n+                            TransportStatusListener transportStatusListener,\n+                            ByteBufAllocator alloc, int maxMessageSizeBytes, boolean decodeBase64) {\n+        super(alloc, maxMessageSizeBytes, decodeBase64);\n         this.decompressorRegistry = requireNonNull(decompressorRegistry, \"decompressorRegistry\");\n-        this.deframer = requireNonNull(deframer, \"deframer\");\n         this.transportStatusListener = requireNonNull(transportStatusListener, \"transportStatusListener\");\n     }\n \n-    // Must be called from the IO thread.\n-    public void request(int numMessages) {\n-        if (subscription == null) {\n-            deferredInitialMessageRequest += numMessages;\n-            return;\n-        }\n-        deframer.request(numMessages);\n-        requestHttpFrame();\n-    }\n-\n-    // Must be called from the IO thread.\n     @Override\n-    public void onSubscribe(Subscription subscription) {\n-        this.subscription = subscription;\n-        if (cancelled) {\n-            subscription.cancel();\n+    protected void processHeaders(HttpHeaders headers, HttpDeframerOutput<DeframedMessage> out) {\n+        // Only clients will see headers from a stream. It doesn't hurt to share this logic between server\n+        // and client though as everything else is identical.\n+        final String statusText = headers.get(HttpHeaderNames.STATUS);\n+        if (statusText == null) {\n+            // Not allowed to have empty leading headers, kill the stream hard.\n+            transportStatusListener.transportReportStatus(\n+                    Status.INTERNAL.withDescription(\"Missing HTTP status code\"));\n             return;\n         }\n-        if (deferredInitialMessageRequest > 0) {\n-            request(deferredInitialMessageRequest);\n-        }\n-    }\n \n-    @Override\n-    public void onNext(HttpObject obj) {\n-        if (cancelled) {\n+        final HttpStatus status = HttpStatus.valueOf(statusText);\n+        if (!status.equals(HttpStatus.OK)) {", "originalCommit": "7f74b7ea0cf3fea2905148c58e1ed31adbd4f2b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU2OTUyMA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r481569520", "bodyText": "Informational headers is not handled by processHeaders().\nIt is handled by processInformationalHeaders(). HttpStreamReader does not override the default behavior that ignores informational headers.\n\n  \n    \n      armeria/core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java\n    \n    \n         Line 126\n      in\n      fb091d3\n    \n    \n    \n    \n\n        \n          \n           protected void processInformationalHeaders(ResponseHeaders in, HttpDeframerOutput<T> out) {}", "author": "ikhoon", "createdAt": "2020-09-02T02:34:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzODAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU0MDE3MQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r481540171", "bodyText": "It's a bit weird that aborting with CancelledSubscriptionException.\nHow about just aborting?", "author": "minwoox", "createdAt": "2020-09-02T01:48:18Z", "path": "grpc/src/main/java/com/linecorp/armeria/internal/common/grpc/HttpStreamReader.java", "diffHunk": "@@ -20,202 +20,105 @@\n \n import javax.annotation.Nullable;\n \n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n+import org.reactivestreams.Processor;\n \n-import com.google.common.annotations.VisibleForTesting;\n-\n-import com.linecorp.armeria.common.HttpData;\n import com.linecorp.armeria.common.HttpHeaderNames;\n import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.HttpObject;\n import com.linecorp.armeria.common.HttpStatus;\n import com.linecorp.armeria.common.grpc.protocol.ArmeriaMessageDeframer;\n+import com.linecorp.armeria.common.grpc.protocol.Decompressor;\n import com.linecorp.armeria.common.grpc.protocol.GrpcHeaderNames;\n-import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n+import com.linecorp.armeria.common.stream.HttpDeframerOutput;\n \n-import io.grpc.Decompressor;\n import io.grpc.DecompressorRegistry;\n import io.grpc.Status;\n+import io.netty.buffer.ByteBufAllocator;\n \n /**\n- * A {@link Subscriber} to read HTTP messages and pass to gRPC business logic.\n+ * A {@link Processor} to read HTTP messages and pass to gRPC business logic.\n  */\n-public final class HttpStreamReader implements Subscriber<HttpObject> {\n+public final class HttpStreamReader extends ArmeriaMessageDeframer {\n \n     private final DecompressorRegistry decompressorRegistry;\n     private final TransportStatusListener transportStatusListener;\n \n-    @VisibleForTesting\n-    public final ArmeriaMessageDeframer deframer;\n-\n-    @Nullable\n-    private Subscription subscription;\n-\n-    private int deferredInitialMessageRequest;\n-\n-    private volatile boolean cancelled;\n-\n-    private boolean sawLeadingHeaders;\n-\n     public HttpStreamReader(DecompressorRegistry decompressorRegistry,\n-                            ArmeriaMessageDeframer deframer,\n-                            TransportStatusListener transportStatusListener) {\n+                            TransportStatusListener transportStatusListener,\n+                            ByteBufAllocator alloc, int maxMessageSizeBytes, boolean decodeBase64) {\n+        super(alloc, maxMessageSizeBytes, decodeBase64);\n         this.decompressorRegistry = requireNonNull(decompressorRegistry, \"decompressorRegistry\");\n-        this.deframer = requireNonNull(deframer, \"deframer\");\n         this.transportStatusListener = requireNonNull(transportStatusListener, \"transportStatusListener\");\n     }\n \n-    // Must be called from the IO thread.\n-    public void request(int numMessages) {\n-        if (subscription == null) {\n-            deferredInitialMessageRequest += numMessages;\n-            return;\n-        }\n-        deframer.request(numMessages);\n-        requestHttpFrame();\n-    }\n-\n-    // Must be called from the IO thread.\n     @Override\n-    public void onSubscribe(Subscription subscription) {\n-        this.subscription = subscription;\n-        if (cancelled) {\n-            subscription.cancel();\n+    protected void processHeaders(HttpHeaders headers, HttpDeframerOutput<DeframedMessage> out) {\n+        // Only clients will see headers from a stream. It doesn't hurt to share this logic between server\n+        // and client though as everything else is identical.\n+        final String statusText = headers.get(HttpHeaderNames.STATUS);\n+        if (statusText == null) {\n+            // Not allowed to have empty leading headers, kill the stream hard.\n+            transportStatusListener.transportReportStatus(\n+                    Status.INTERNAL.withDescription(\"Missing HTTP status code\"));\n             return;\n         }\n-        if (deferredInitialMessageRequest > 0) {\n-            request(deferredInitialMessageRequest);\n-        }\n-    }\n \n-    @Override\n-    public void onNext(HttpObject obj) {\n-        if (cancelled) {\n+        final HttpStatus status = HttpStatus.valueOf(statusText);\n+        if (!status.equals(HttpStatus.OK)) {\n+            transportStatusListener.transportReportStatus(\n+                    GrpcStatus.httpStatusToGrpcStatus(status.code()));\n             return;\n         }\n-        if (obj instanceof HttpHeaders) {\n-            // Only clients will see headers from a stream. It doesn't hurt to share this logic between server\n-            // and client though as everything else is identical.\n-            final HttpHeaders headers = (HttpHeaders) obj;\n-\n-            if (!sawLeadingHeaders) {\n-                final String statusText = headers.get(HttpHeaderNames.STATUS);\n-                if (statusText == null) {\n-                    // Not allowed to have empty leading headers, kill the stream hard.\n-                    transportStatusListener.transportReportStatus(\n-                            Status.INTERNAL.withDescription(\"Missing HTTP status code\"));\n-                    return;\n-                }\n-\n-                if (ArmeriaHttpUtil.isInformational(statusText)) {\n-                    // Skip informational headers.\n-                    return;\n-                }\n-\n-                sawLeadingHeaders = true;\n-\n-                final HttpStatus status = HttpStatus.valueOf(statusText);\n-                if (!status.equals(HttpStatus.OK)) {\n-                    transportStatusListener.transportReportStatus(\n-                            GrpcStatus.httpStatusToGrpcStatus(status.code()));\n-                    return;\n-                }\n-            }\n \n-            final String grpcStatus = headers.get(GrpcHeaderNames.GRPC_STATUS);\n-            if (grpcStatus != null) {\n-                if (deframer.isClosed()) {\n-                    GrpcStatus.reportStatus(headers, this, transportStatusListener);\n-                } else {\n-                    // A gRPC client could not receive messages fully yet.\n-                    // Let ArmeriaClientCall be closed when the gRPC client has been consumed all messages.\n-                    deframer.whenClosed().thenRun(() -> {\n-                        GrpcStatus.reportStatus(headers, this, transportStatusListener);\n-                    });\n-                    deframer.closeWhenComplete();\n-                }\n-            }\n+        final String grpcStatus = headers.get(GrpcHeaderNames.GRPC_STATUS);\n+        if (grpcStatus != null) {\n+            // A gRPC client could not receive messages fully yet.\n+            // Let ArmeriaClientCall be closed when the gRPC client has been consumed all messages.\n+            whenComplete().thenRun(() -> {\n+                GrpcStatus.reportStatus(headers, this, transportStatusListener);\n+            });\n+        }\n \n-            // Headers without grpc-status are the leading headers of a non-failing response, prepare to receive\n-            // messages.\n-            final String grpcEncoding = headers.get(GrpcHeaderNames.GRPC_ENCODING);\n-            if (grpcEncoding != null) {\n-                final Decompressor decompressor = decompressorRegistry.lookupDecompressor(grpcEncoding);\n-                if (decompressor == null) {\n-                    transportStatusListener.transportReportStatus(Status.INTERNAL.withDescription(\n-                            \"Can't find decompressor for \" + grpcEncoding));\n-                    return;\n-                }\n-                try {\n-                    deframer.decompressor(ForwardingDecompressor.forGrpc(decompressor));\n-                } catch (Throwable t) {\n-                    transportStatusListener.transportReportStatus(GrpcStatus.fromThrowable(t));\n-                    return;\n-                }\n+        // Headers without grpc-status are the leading headers of a non-failing response, prepare to receive\n+        // messages.\n+        final String grpcEncoding = headers.get(GrpcHeaderNames.GRPC_ENCODING);\n+        if (grpcEncoding != null) {\n+            final io.grpc.Decompressor decompressor = decompressorRegistry.lookupDecompressor(grpcEncoding);\n+            if (decompressor == null) {\n+                transportStatusListener.transportReportStatus(Status.INTERNAL.withDescription(\n+                        \"Can't find decompressor for \" + grpcEncoding));\n+                return;\n             }\n-            requestHttpFrame();\n-            return;\n-        }\n-        final HttpData data = (HttpData) obj;\n-        try {\n-            deframer.deframe(data, false);\n-        } catch (Throwable cause) {\n             try {\n-                transportStatusListener.transportReportStatus(GrpcStatus.fromThrowable(cause));\n-                return;\n-            } finally {\n-                deframer.close();\n+                decompressor(ForwardingDecompressor.forGrpc(decompressor));\n+            } catch (Throwable t) {\n+                transportStatusListener.transportReportStatus(GrpcStatus.fromThrowable(t));\n             }\n         }\n-        requestHttpFrame();\n     }\n \n     @Override\n-    public void onError(Throwable cause) {\n-        if (cancelled) {\n-            return;\n+    protected void processTrailers(HttpHeaders headers, HttpDeframerOutput<DeframedMessage> out) {\n+        final String grpcStatus = headers.get(GrpcHeaderNames.GRPC_STATUS);\n+        if (grpcStatus != null) {\n+            whenConsumed().thenRun(() -> GrpcStatus.reportStatus(headers, this, transportStatusListener));\n         }\n-        transportStatusListener.transportReportStatus(GrpcStatus.fromThrowable(cause));\n     }\n \n     @Override\n-    public void onComplete() {\n-        if (cancelled) {\n-            return;\n-        }\n-        closeDeframer();\n+    protected void processOnError(Throwable cause) {\n+        transportStatusListener.transportReportStatus(GrpcStatus.fromThrowable(cause));\n     }\n \n+    /**\n+     * Cancel this stream and prevents further subscription.\n+     */\n     public void cancel() {\n-        cancelled = true;\n-        if (subscription != null) {\n-            subscription.cancel();\n-        }\n-        if (!deframer.isClosed()) {\n-            deframer.close();\n-        }\n-    }\n-\n-    void closeDeframer() {\n-        // closeDeframer() could be called when deframer.isClosing() due to a race condition like the following:\n-        //\n-        // 1) HttpStreamReader received all data from publisher and added them to unprocessed of deframer.\n-        // 2) A gRPC client does not request next messages yet, so deframer still has unprocessedBytes and\n-        //    is not stalled.\n-        // 3) HttpStreamReader receives onCompleted signal and closes deframer.\n-        // 4) A gRPC client requests a message and the received message contains trailers,\n-        //    so ArmeriaClientCall tries to close deframer.\n-        if (!deframer.isClosing() && !deframer.isClosed()) {\n-            deframer.deframe(HttpData.empty(), true);\n-            deframer.closeWhenComplete();\n-        }\n+       abort(CancelledSubscriptionException.get());", "originalCommit": "7f74b7ea0cf3fea2905148c58e1ed31adbd4f2b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU3MTA0Mw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r481571043", "bodyText": "This was my considering point. If it is no harm to call abort() without CancelledSubscriptionException, let me address it.", "author": "ikhoon", "createdAt": "2020-09-02T02:36:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU0MDE3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU0NjQ0OQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r481546449", "bodyText": "can remove this", "author": "minwoox", "createdAt": "2020-09-02T01:58:04Z", "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ArmeriaServerCall.java", "diffHunk": "@@ -352,64 +360,77 @@ public synchronized void setCompression(String compressorName) {\n     }\n \n     @Override\n-    public void messageRead(DeframedMessage message) {\n-\n-        final I request;\n-        final ByteBuf buf = message.buf();\n+    public void onSubscribe(Subscription subscription) {\n+        requireNonNull(subscription, \"subscription\");\n+        // 'subscribe()' only happens in the constructor of ArmeriaServerCall.\n+        upstream = subscription;\n+        if (pendingRequests > 0) {\n+            upstream.request(pendingRequests);\n+            pendingRequests = 0;\n+        }\n+    }\n \n-        boolean success = false;\n+    @Override\n+    public void onNext(DeframedMessage message) {\n         try {\n-            // Special case for unary calls.\n-            if (messageReceived && method.getType() == MethodType.UNARY) {\n-                closeListener(Status.INTERNAL.withDescription(\n-                        \"More than one request messages for unary call or server streaming call\"));\n-                return;\n-            }\n-            messageReceived = true;\n+            final I request;\n+            final ByteBuf buf = message.buf();\n+\n+            boolean success = false;\n+            try {\n+                // Special case for unary calls.\n+                if (messageReceived && method.getType() == MethodType.UNARY) {\n+                    closeListener(Status.INTERNAL.withDescription(\n+                            \"More than one request messages for unary call or server streaming call\"));\n+                    return;\n+                }\n+                messageReceived = true;\n \n-            if (isCancelled()) {\n-                return;\n-            }\n-            success = true;\n-        } finally {\n-            if (buf != null && !success) {\n-                buf.release();\n+                if (isCancelled()) {\n+                    return;\n+                }\n+                success = true;\n+            } finally {\n+                if (buf != null && !success) {\n+                    buf.release();\n+                }\n             }\n-        }\n \n-        final boolean grpcWebText = GrpcSerializationFormats.isGrpcWebText(serializationFormat);\n+            final boolean grpcWebText = GrpcSerializationFormats.isGrpcWebText(serializationFormat);\n \n-        try {\n             request = marshaller.deserializeRequest(message, grpcWebText);\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n \n-        if (!ctx.log().isAvailable(RequestLogProperty.REQUEST_CONTENT)) {\n-            ctx.logBuilder().requestContent(GrpcLogUtil.rpcRequest(method, request), null);\n-        }\n+            if (!ctx.log().isAvailable(RequestLogProperty.REQUEST_CONTENT)) {\n+                ctx.logBuilder().requestContent(GrpcLogUtil.rpcRequest(method, request), null);\n+            }\n \n-        if (unsafeWrapRequestBuffers && buf != null && !grpcWebText) {\n-            GrpcUnsafeBufferUtil.storeBuffer(buf, request, ctx);\n-        }\n+            if (unsafeWrapRequestBuffers && buf != null && !grpcWebText) {\n+                GrpcUnsafeBufferUtil.storeBuffer(buf, request, ctx);\n+            }\n \n-        if (blockingExecutor != null) {\n-            blockingExecutor.execute(() -> invokeOnMessage(request));\n-        } else {\n-            invokeOnMessage(request);\n+            if (blockingExecutor != null) {\n+                blockingExecutor.execute(() -> invokeOnMessage(request));\n+            } else {\n+                invokeOnMessage(request);\n+            }\n+        } catch (Throwable e) {\n+            upstream.cancel();\n+            close(GrpcStatus.fromThrowable(e), new Metadata());\n+            return;", "originalCommit": "7f74b7ea0cf3fea2905148c58e1ed31adbd4f2b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU3MTU0Nw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r481571547", "bodyText": "Oops... \ud83d\ude05", "author": "ikhoon", "createdAt": "2020-09-02T02:37:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU0NjQ0OQ=="}], "type": "inlineReview"}, {"oid": "94ba79f6bdfd34af46f3cd5162a5d50f84ff2edf", "url": "https://github.com/line/armeria/commit/94ba79f6bdfd34af46f3cd5162a5d50f84ff2edf", "message": "Address comments by @minwoox", "committedDate": "2020-09-02T03:29:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwOTMwMQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r484209301", "bodyText": "Probably better poll()-ing so you don't have to call clear() later?", "author": "trustin", "createdAt": "2020-09-07T06:33:09Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/ByteBufDeframerInput.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.ReferenceCountUtil;\n+\n+final class ByteBufDeframerInput implements HttpDeframerInput {\n+\n+    private final ByteBufAllocator alloc;\n+    private final Queue<ByteBuf> queue;\n+\n+    ByteBufDeframerInput(ByteBufAllocator alloc) {\n+        this.alloc = alloc;\n+        queue = new ArrayDeque<>();\n+    }\n+\n+    void add(ByteBuf byteBuf) {\n+        queue.add(byteBuf);\n+    }\n+\n+    @Override\n+    public int readableBytes() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int readableBytes = 0;\n+        for (ByteBuf buf : queue) {\n+            readableBytes += buf.readableBytes();\n+        }\n+        return readableBytes;\n+    }\n+\n+    private int readerIndex() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int value = 0;\n+        for (ByteBuf buf : queue) {\n+            value += buf.readerIndex();\n+        }\n+        return value;\n+    }\n+\n+    private int writerIndex() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int value = 0;\n+        for (ByteBuf buf : queue) {\n+            value += buf.writerIndex();\n+        }\n+        return value;\n+    }\n+\n+    @Override\n+    public byte readByte() {\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+            return buf.readByte();\n+        }\n+        throw new IndexOutOfBoundsException(\n+                \"readerIndex: \" + readerIndex() +\n+                \" (expected: 0 <= readerIndex < writerIndex(\" + writerIndex() + \"))\");\n+    }\n+\n+    @Override\n+    public int readInt() {\n+        final ByteBuf firstBuf = queue.peek();\n+        if (firstBuf == null) {\n+            throw new IndexOutOfBoundsException(\n+                    \"readerIndex: \" + readerIndex() +\n+                    \" (expected: 0 <= readerIndex < writerIndex(\" + writerIndex() + \"))\");\n+        }\n+\n+        if (firstBuf.readableBytes() >= 4) {\n+            return firstBuf.readInt();\n+        }\n+\n+        return readIntSlow();\n+    }\n+\n+    private int readIntSlow() {\n+        int value = 0;\n+        int remained = 4;\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+            final int readSize = Math.min(remained, buf.readableBytes());\n+            if (readSize == 4) {\n+                return buf.readInt();\n+            }\n+\n+            value <<= 8 * readSize;\n+            switch (readSize) {\n+                case 1:\n+                    value |= buf.readUnsignedByte();\n+                    break;\n+                case 2:\n+                    value |= buf.readUnsignedShort();\n+                    break;\n+                case 3:\n+                    value |= buf.readUnsignedMedium();\n+                    break;\n+                default:\n+                    throw new Error(); // Should not reach here.\n+            }\n+            remained -= readSize;\n+            if (remained == 0) {\n+                break;\n+            }\n+        }\n+\n+        if (remained == 0) {\n+            return value;\n+        } else {\n+            throw new IndexOutOfBoundsException(\n+                    \"readerIndex: \" + (readerIndex() - 4 + remained) +\n+                    \" (expected: 0 < readerIndex + 4 <= writerIndex(\" + writerIndex() + \"))\");\n+        }\n+    }\n+\n+    @Override\n+    public ByteBuf readBytes(int length) {\n+        checkArgument(length > 0, \"length %s (expected: length > 0)\", length);\n+        final ByteBuf firstBuf = queue.peek();\n+        if (firstBuf == null) {\n+            throw new IndexOutOfBoundsException(\n+                    \"readerIndex: \" + readerIndex() +\n+                    \" (expected: 0 <= readerIndex < writerIndex(\" + writerIndex() + \"))\");\n+        }\n+\n+        if (firstBuf.readableBytes() >= length) {\n+            return firstBuf.readRetainedSlice(length);\n+        }\n+\n+        return readBytesSlow(length);\n+    }\n+\n+    private ByteBuf readBytesSlow(int length) {\n+        ByteBuf value = null;\n+        int remained = length;\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+\n+            final int readSize = Math.min(remained, buf.readableBytes());\n+            if (readSize == length) {\n+                return buf.readRetainedSlice(readSize);\n+            } else {\n+                if (value == null) {\n+                    value = alloc.buffer(length);\n+                }\n+                value.writeBytes(buf, readSize);\n+                remained -= readSize;\n+                if (remained == 0) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (remained > 0 || value == null) {\n+            ReferenceCountUtil.release(value);\n+            throw new IndexOutOfBoundsException(\n+                    \"readerIndex: \" + readerIndex() +\n+                    \" (expected: 0 < readerIndex + \" + length + \" <= writerIndex(\" + writerIndex() + \"))\");\n+        }\n+\n+        return value;\n+    }\n+\n+    /**\n+     * Discards the {@link ByteBuf}s that have been fully consumed and are not readable anymore.\n+     */\n+    void discardReadBytes() {\n+        for (;;) {\n+            final ByteBuf buf = queue.peek();\n+            if (buf != null && !buf.isReadable()) {\n+                queue.remove().release();\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        for (ByteBuf buf : queue) {\n+            buf.release();\n+        }\n+        queue.clear();\n+    }", "originalCommit": "94ba79f6bdfd34af46f3cd5162a5d50f84ff2edf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIxMDQ1Mw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r484210453", "bodyText": "How these two methods calculate reader/writerIndex is not correct in my opinion. Actually, there's no notion of reader/writer index from the caller's perspective because it's an HttpDeframerInput, not a ByteBuf.", "author": "trustin", "createdAt": "2020-09-07T06:36:17Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/ByteBufDeframerInput.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.ReferenceCountUtil;\n+\n+final class ByteBufDeframerInput implements HttpDeframerInput {\n+\n+    private final ByteBufAllocator alloc;\n+    private final Queue<ByteBuf> queue;\n+\n+    ByteBufDeframerInput(ByteBufAllocator alloc) {\n+        this.alloc = alloc;\n+        queue = new ArrayDeque<>();\n+    }\n+\n+    void add(ByteBuf byteBuf) {\n+        queue.add(byteBuf);\n+    }\n+\n+    @Override\n+    public int readableBytes() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int readableBytes = 0;\n+        for (ByteBuf buf : queue) {\n+            readableBytes += buf.readableBytes();\n+        }\n+        return readableBytes;\n+    }\n+\n+    private int readerIndex() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int value = 0;\n+        for (ByteBuf buf : queue) {\n+            value += buf.readerIndex();\n+        }\n+        return value;\n+    }\n+\n+    private int writerIndex() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int value = 0;\n+        for (ByteBuf buf : queue) {\n+            value += buf.writerIndex();\n+        }\n+        return value;\n+    }", "originalCommit": "94ba79f6bdfd34af46f3cd5162a5d50f84ff2edf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIxMDg3NA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r484210874", "bodyText": "Could return an exception of other type than IOOBE with a better message like 'end of deframer input'.", "author": "trustin", "createdAt": "2020-09-07T06:37:27Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/ByteBufDeframerInput.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.ReferenceCountUtil;\n+\n+final class ByteBufDeframerInput implements HttpDeframerInput {\n+\n+    private final ByteBufAllocator alloc;\n+    private final Queue<ByteBuf> queue;\n+\n+    ByteBufDeframerInput(ByteBufAllocator alloc) {\n+        this.alloc = alloc;\n+        queue = new ArrayDeque<>();\n+    }\n+\n+    void add(ByteBuf byteBuf) {\n+        queue.add(byteBuf);\n+    }\n+\n+    @Override\n+    public int readableBytes() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int readableBytes = 0;\n+        for (ByteBuf buf : queue) {\n+            readableBytes += buf.readableBytes();\n+        }\n+        return readableBytes;\n+    }\n+\n+    private int readerIndex() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int value = 0;\n+        for (ByteBuf buf : queue) {\n+            value += buf.readerIndex();\n+        }\n+        return value;\n+    }\n+\n+    private int writerIndex() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int value = 0;\n+        for (ByteBuf buf : queue) {\n+            value += buf.writerIndex();\n+        }\n+        return value;\n+    }\n+\n+    @Override\n+    public byte readByte() {\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+            return buf.readByte();\n+        }\n+        throw new IndexOutOfBoundsException(\n+                \"readerIndex: \" + readerIndex() +\n+                \" (expected: 0 <= readerIndex < writerIndex(\" + writerIndex() + \"))\");", "originalCommit": "94ba79f6bdfd34af46f3cd5162a5d50f84ff2edf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIxMDkwOQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r484210909", "bodyText": "Ditto", "author": "trustin", "createdAt": "2020-09-07T06:37:34Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/ByteBufDeframerInput.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.ReferenceCountUtil;\n+\n+final class ByteBufDeframerInput implements HttpDeframerInput {\n+\n+    private final ByteBufAllocator alloc;\n+    private final Queue<ByteBuf> queue;\n+\n+    ByteBufDeframerInput(ByteBufAllocator alloc) {\n+        this.alloc = alloc;\n+        queue = new ArrayDeque<>();\n+    }\n+\n+    void add(ByteBuf byteBuf) {\n+        queue.add(byteBuf);\n+    }\n+\n+    @Override\n+    public int readableBytes() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int readableBytes = 0;\n+        for (ByteBuf buf : queue) {\n+            readableBytes += buf.readableBytes();\n+        }\n+        return readableBytes;\n+    }\n+\n+    private int readerIndex() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int value = 0;\n+        for (ByteBuf buf : queue) {\n+            value += buf.readerIndex();\n+        }\n+        return value;\n+    }\n+\n+    private int writerIndex() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int value = 0;\n+        for (ByteBuf buf : queue) {\n+            value += buf.writerIndex();\n+        }\n+        return value;\n+    }\n+\n+    @Override\n+    public byte readByte() {\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+            return buf.readByte();\n+        }\n+        throw new IndexOutOfBoundsException(\n+                \"readerIndex: \" + readerIndex() +\n+                \" (expected: 0 <= readerIndex < writerIndex(\" + writerIndex() + \"))\");\n+    }\n+\n+    @Override\n+    public int readInt() {\n+        final ByteBuf firstBuf = queue.peek();\n+        if (firstBuf == null) {\n+            throw new IndexOutOfBoundsException(\n+                    \"readerIndex: \" + readerIndex() +\n+                    \" (expected: 0 <= readerIndex < writerIndex(\" + writerIndex() + \"))\");", "originalCommit": "94ba79f6bdfd34af46f3cd5162a5d50f84ff2edf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIxMTAzOQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r484211039", "bodyText": "Ditto", "author": "trustin", "createdAt": "2020-09-07T06:37:55Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/ByteBufDeframerInput.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.ReferenceCountUtil;\n+\n+final class ByteBufDeframerInput implements HttpDeframerInput {\n+\n+    private final ByteBufAllocator alloc;\n+    private final Queue<ByteBuf> queue;\n+\n+    ByteBufDeframerInput(ByteBufAllocator alloc) {\n+        this.alloc = alloc;\n+        queue = new ArrayDeque<>();\n+    }\n+\n+    void add(ByteBuf byteBuf) {\n+        queue.add(byteBuf);\n+    }\n+\n+    @Override\n+    public int readableBytes() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int readableBytes = 0;\n+        for (ByteBuf buf : queue) {\n+            readableBytes += buf.readableBytes();\n+        }\n+        return readableBytes;\n+    }\n+\n+    private int readerIndex() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int value = 0;\n+        for (ByteBuf buf : queue) {\n+            value += buf.readerIndex();\n+        }\n+        return value;\n+    }\n+\n+    private int writerIndex() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int value = 0;\n+        for (ByteBuf buf : queue) {\n+            value += buf.writerIndex();\n+        }\n+        return value;\n+    }\n+\n+    @Override\n+    public byte readByte() {\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+            return buf.readByte();\n+        }\n+        throw new IndexOutOfBoundsException(\n+                \"readerIndex: \" + readerIndex() +\n+                \" (expected: 0 <= readerIndex < writerIndex(\" + writerIndex() + \"))\");\n+    }\n+\n+    @Override\n+    public int readInt() {\n+        final ByteBuf firstBuf = queue.peek();\n+        if (firstBuf == null) {\n+            throw new IndexOutOfBoundsException(\n+                    \"readerIndex: \" + readerIndex() +\n+                    \" (expected: 0 <= readerIndex < writerIndex(\" + writerIndex() + \"))\");\n+        }\n+\n+        if (firstBuf.readableBytes() >= 4) {\n+            return firstBuf.readInt();\n+        }\n+\n+        return readIntSlow();\n+    }\n+\n+    private int readIntSlow() {\n+        int value = 0;\n+        int remained = 4;\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+            final int readSize = Math.min(remained, buf.readableBytes());\n+            if (readSize == 4) {\n+                return buf.readInt();\n+            }\n+\n+            value <<= 8 * readSize;\n+            switch (readSize) {\n+                case 1:\n+                    value |= buf.readUnsignedByte();\n+                    break;\n+                case 2:\n+                    value |= buf.readUnsignedShort();\n+                    break;\n+                case 3:\n+                    value |= buf.readUnsignedMedium();\n+                    break;\n+                default:\n+                    throw new Error(); // Should not reach here.\n+            }\n+            remained -= readSize;\n+            if (remained == 0) {\n+                break;\n+            }\n+        }\n+\n+        if (remained == 0) {\n+            return value;\n+        } else {\n+            throw new IndexOutOfBoundsException(\n+                    \"readerIndex: \" + (readerIndex() - 4 + remained) +\n+                    \" (expected: 0 < readerIndex + 4 <= writerIndex(\" + writerIndex() + \"))\");", "originalCommit": "94ba79f6bdfd34af46f3cd5162a5d50f84ff2edf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIxMTA4OQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r484211089", "bodyText": "Ditto", "author": "trustin", "createdAt": "2020-09-07T06:38:04Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/ByteBufDeframerInput.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.ReferenceCountUtil;\n+\n+final class ByteBufDeframerInput implements HttpDeframerInput {\n+\n+    private final ByteBufAllocator alloc;\n+    private final Queue<ByteBuf> queue;\n+\n+    ByteBufDeframerInput(ByteBufAllocator alloc) {\n+        this.alloc = alloc;\n+        queue = new ArrayDeque<>();\n+    }\n+\n+    void add(ByteBuf byteBuf) {\n+        queue.add(byteBuf);\n+    }\n+\n+    @Override\n+    public int readableBytes() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int readableBytes = 0;\n+        for (ByteBuf buf : queue) {\n+            readableBytes += buf.readableBytes();\n+        }\n+        return readableBytes;\n+    }\n+\n+    private int readerIndex() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int value = 0;\n+        for (ByteBuf buf : queue) {\n+            value += buf.readerIndex();\n+        }\n+        return value;\n+    }\n+\n+    private int writerIndex() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int value = 0;\n+        for (ByteBuf buf : queue) {\n+            value += buf.writerIndex();\n+        }\n+        return value;\n+    }\n+\n+    @Override\n+    public byte readByte() {\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+            return buf.readByte();\n+        }\n+        throw new IndexOutOfBoundsException(\n+                \"readerIndex: \" + readerIndex() +\n+                \" (expected: 0 <= readerIndex < writerIndex(\" + writerIndex() + \"))\");\n+    }\n+\n+    @Override\n+    public int readInt() {\n+        final ByteBuf firstBuf = queue.peek();\n+        if (firstBuf == null) {\n+            throw new IndexOutOfBoundsException(\n+                    \"readerIndex: \" + readerIndex() +\n+                    \" (expected: 0 <= readerIndex < writerIndex(\" + writerIndex() + \"))\");\n+        }\n+\n+        if (firstBuf.readableBytes() >= 4) {\n+            return firstBuf.readInt();\n+        }\n+\n+        return readIntSlow();\n+    }\n+\n+    private int readIntSlow() {\n+        int value = 0;\n+        int remained = 4;\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+            final int readSize = Math.min(remained, buf.readableBytes());\n+            if (readSize == 4) {\n+                return buf.readInt();\n+            }\n+\n+            value <<= 8 * readSize;\n+            switch (readSize) {\n+                case 1:\n+                    value |= buf.readUnsignedByte();\n+                    break;\n+                case 2:\n+                    value |= buf.readUnsignedShort();\n+                    break;\n+                case 3:\n+                    value |= buf.readUnsignedMedium();\n+                    break;\n+                default:\n+                    throw new Error(); // Should not reach here.\n+            }\n+            remained -= readSize;\n+            if (remained == 0) {\n+                break;\n+            }\n+        }\n+\n+        if (remained == 0) {\n+            return value;\n+        } else {\n+            throw new IndexOutOfBoundsException(\n+                    \"readerIndex: \" + (readerIndex() - 4 + remained) +\n+                    \" (expected: 0 < readerIndex + 4 <= writerIndex(\" + writerIndex() + \"))\");\n+        }\n+    }\n+\n+    @Override\n+    public ByteBuf readBytes(int length) {\n+        checkArgument(length > 0, \"length %s (expected: length > 0)\", length);\n+        final ByteBuf firstBuf = queue.peek();\n+        if (firstBuf == null) {\n+            throw new IndexOutOfBoundsException(\n+                    \"readerIndex: \" + readerIndex() +\n+                    \" (expected: 0 <= readerIndex < writerIndex(\" + writerIndex() + \"))\");", "originalCommit": "94ba79f6bdfd34af46f3cd5162a5d50f84ff2edf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIxMTE0NA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r484211144", "bodyText": "Ditto", "author": "trustin", "createdAt": "2020-09-07T06:38:14Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/ByteBufDeframerInput.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.ReferenceCountUtil;\n+\n+final class ByteBufDeframerInput implements HttpDeframerInput {\n+\n+    private final ByteBufAllocator alloc;\n+    private final Queue<ByteBuf> queue;\n+\n+    ByteBufDeframerInput(ByteBufAllocator alloc) {\n+        this.alloc = alloc;\n+        queue = new ArrayDeque<>();\n+    }\n+\n+    void add(ByteBuf byteBuf) {\n+        queue.add(byteBuf);\n+    }\n+\n+    @Override\n+    public int readableBytes() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int readableBytes = 0;\n+        for (ByteBuf buf : queue) {\n+            readableBytes += buf.readableBytes();\n+        }\n+        return readableBytes;\n+    }\n+\n+    private int readerIndex() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int value = 0;\n+        for (ByteBuf buf : queue) {\n+            value += buf.readerIndex();\n+        }\n+        return value;\n+    }\n+\n+    private int writerIndex() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int value = 0;\n+        for (ByteBuf buf : queue) {\n+            value += buf.writerIndex();\n+        }\n+        return value;\n+    }\n+\n+    @Override\n+    public byte readByte() {\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+            return buf.readByte();\n+        }\n+        throw new IndexOutOfBoundsException(\n+                \"readerIndex: \" + readerIndex() +\n+                \" (expected: 0 <= readerIndex < writerIndex(\" + writerIndex() + \"))\");\n+    }\n+\n+    @Override\n+    public int readInt() {\n+        final ByteBuf firstBuf = queue.peek();\n+        if (firstBuf == null) {\n+            throw new IndexOutOfBoundsException(\n+                    \"readerIndex: \" + readerIndex() +\n+                    \" (expected: 0 <= readerIndex < writerIndex(\" + writerIndex() + \"))\");\n+        }\n+\n+        if (firstBuf.readableBytes() >= 4) {\n+            return firstBuf.readInt();\n+        }\n+\n+        return readIntSlow();\n+    }\n+\n+    private int readIntSlow() {\n+        int value = 0;\n+        int remained = 4;\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+            final int readSize = Math.min(remained, buf.readableBytes());\n+            if (readSize == 4) {\n+                return buf.readInt();\n+            }\n+\n+            value <<= 8 * readSize;\n+            switch (readSize) {\n+                case 1:\n+                    value |= buf.readUnsignedByte();\n+                    break;\n+                case 2:\n+                    value |= buf.readUnsignedShort();\n+                    break;\n+                case 3:\n+                    value |= buf.readUnsignedMedium();\n+                    break;\n+                default:\n+                    throw new Error(); // Should not reach here.\n+            }\n+            remained -= readSize;\n+            if (remained == 0) {\n+                break;\n+            }\n+        }\n+\n+        if (remained == 0) {\n+            return value;\n+        } else {\n+            throw new IndexOutOfBoundsException(\n+                    \"readerIndex: \" + (readerIndex() - 4 + remained) +\n+                    \" (expected: 0 < readerIndex + 4 <= writerIndex(\" + writerIndex() + \"))\");\n+        }\n+    }\n+\n+    @Override\n+    public ByteBuf readBytes(int length) {\n+        checkArgument(length > 0, \"length %s (expected: length > 0)\", length);\n+        final ByteBuf firstBuf = queue.peek();\n+        if (firstBuf == null) {\n+            throw new IndexOutOfBoundsException(\n+                    \"readerIndex: \" + readerIndex() +\n+                    \" (expected: 0 <= readerIndex < writerIndex(\" + writerIndex() + \"))\");\n+        }\n+\n+        if (firstBuf.readableBytes() >= length) {\n+            return firstBuf.readRetainedSlice(length);\n+        }\n+\n+        return readBytesSlow(length);\n+    }\n+\n+    private ByteBuf readBytesSlow(int length) {\n+        ByteBuf value = null;\n+        int remained = length;\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+\n+            final int readSize = Math.min(remained, buf.readableBytes());\n+            if (readSize == length) {\n+                return buf.readRetainedSlice(readSize);\n+            } else {\n+                if (value == null) {\n+                    value = alloc.buffer(length);\n+                }\n+                value.writeBytes(buf, readSize);\n+                remained -= readSize;\n+                if (remained == 0) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (remained > 0 || value == null) {\n+            ReferenceCountUtil.release(value);\n+            throw new IndexOutOfBoundsException(\n+                    \"readerIndex: \" + readerIndex() +\n+                    \" (expected: 0 < readerIndex + \" + length + \" <= writerIndex(\" + writerIndex() + \"))\");", "originalCommit": "94ba79f6bdfd34af46f3cd5162a5d50f84ff2edf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIxMTUxMw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r484211513", "bodyText": "Question: Is this meant to be overridden?", "author": "trustin", "createdAt": "2020-09-07T06:39:17Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A skeletal {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ */\n+@UnstableApi\n+public abstract class HttpDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpObject, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"subscribed\");\n+\n+    private final ByteBufDeframerInput input;\n+    private final ArrayDeque<T> outputQueue = new ArrayDeque<>();\n+\n+    private boolean sawLeadingHeaders;\n+\n+    @Nullable\n+    private volatile EventExecutor eventLoop;\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean cancelled;\n+    private volatile int initialized;\n+    private volatile int subscribed;\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link EventExecutor} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    protected HttpDeframer(ByteBufAllocator alloc) {\n+        requireNonNull(alloc, \"alloc\");\n+        input = new ByteBufDeframerInput(alloc);\n+    }\n+\n+    /**\n+     * Converts the specified {@link HttpData} to {@link ByteBuf}.\n+     */\n+    protected ByteBuf convertToByteBuf(HttpData data) {\n+        return data.byteBuf();\n+    }", "originalCommit": "94ba79f6bdfd34af46f3cd5162a5d50f84ff2edf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYzNTc2Ng==", "url": "https://github.com/line/armeria/pull/2981#discussion_r484635766", "bodyText": "Before adding the ByteBuf to HttpDeframerInput, a Base64 encoded ByteBuf needs to be decoded.\n\n  \n    \n      armeria/grpc-protocol/src/main/java/com/linecorp/armeria/common/grpc/protocol/ArmeriaMessageDeframer.java\n    \n    \n        Lines 215 to 222\n      in\n      fb091d3\n    \n    \n    \n    \n\n        \n          \n           @Override \n        \n\n        \n          \n           protected final ByteBuf convertToByteBuf(HttpData data) { \n        \n\n        \n          \n               if (base64Decoder != null) { \n        \n\n        \n          \n                   return base64Decoder.decode(data.byteBuf()); \n        \n\n        \n          \n               }  else { \n        \n\n        \n          \n                   return data.byteBuf(); \n        \n\n        \n          \n               } \n        \n\n        \n          \n           }", "author": "ikhoon", "createdAt": "2020-09-08T03:53:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIxMTUxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIxMjEwNg==", "url": "https://github.com/line/armeria/pull/2981#discussion_r484212106", "bodyText": "Should we prefer composition over inheritance? e.g. add a dedicated interface that provides these protected methods?", "author": "trustin", "createdAt": "2020-09-07T06:40:52Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A skeletal {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ */\n+@UnstableApi\n+public abstract class HttpDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpObject, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"subscribed\");\n+\n+    private final ByteBufDeframerInput input;\n+    private final ArrayDeque<T> outputQueue = new ArrayDeque<>();\n+\n+    private boolean sawLeadingHeaders;\n+\n+    @Nullable\n+    private volatile EventExecutor eventLoop;\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean cancelled;\n+    private volatile int initialized;\n+    private volatile int subscribed;\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link EventExecutor} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    protected HttpDeframer(ByteBufAllocator alloc) {\n+        requireNonNull(alloc, \"alloc\");\n+        input = new ByteBufDeframerInput(alloc);\n+    }\n+\n+    /**\n+     * Converts the specified {@link HttpData} to {@link ByteBuf}.\n+     */\n+    protected ByteBuf convertToByteBuf(HttpData data) {\n+        return data.byteBuf();\n+    }\n+\n+    /**\n+     * Decodes a stream of {@link HttpData}s to N objects.\n+     * This method will be called whenever an {@link HttpData} is signaled from {@link Publisher}.\n+     */\n+    protected abstract void process(HttpDeframerInput in, HttpDeframerOutput<T> out);\n+\n+    private void process(HttpObject data) {\n+        if (data instanceof HttpHeaders) {\n+            final HttpHeaders headers = (HttpHeaders) data;\n+\n+            if (headers instanceof ResponseHeaders) {\n+                final ResponseHeaders responseHeaders = (ResponseHeaders) headers;\n+                if (responseHeaders.status().isInformational()) {\n+                    processInformationalHeaders(responseHeaders, outputQueue::addLast);\n+                    return;\n+                }\n+            }\n+\n+            if (!sawLeadingHeaders) {\n+                sawLeadingHeaders = true;\n+                processHeaders((HttpHeaders) data, outputQueue::addLast);\n+            } else {\n+                processTrailers((HttpHeaders) data, outputQueue::addLast);\n+            }\n+            return;\n+        }\n+\n+        if (data instanceof HttpData) {\n+            input.add(convertToByteBuf((HttpData) data));\n+            process(input, outputQueue::addLast);\n+            input.discardReadBytes();\n+        }\n+    }\n+\n+    /**\n+     * Decodes an informational {@link ResponseHeaders} to N objects.\n+     */\n+    protected void processInformationalHeaders(ResponseHeaders in, HttpDeframerOutput<T> out) {}", "originalCommit": "94ba79f6bdfd34af46f3cd5162a5d50f84ff2edf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3387184aeaa0d5bdbc2aeaeb34279a79975dfa91", "url": "https://github.com/line/armeria/commit/3387184aeaa0d5bdbc2aeaeb34279a79975dfa91", "message": "Address comments by @trustin / Introduce HttpDeframerHandler", "committedDate": "2020-09-08T14:55:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3OTA0Nw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r485279047", "bodyText": "Not skeletal anymore.\nHow about adding a simple example?", "author": "trustin", "createdAt": "2020-09-09T01:12:37Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -43,7 +43,7 @@\n  * A skeletal {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.", "originalCommit": "3387184aeaa0d5bdbc2aeaeb34279a79975dfa91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dbfeda1132544f058b7c2b55b6d9de08560e10ed", "url": "https://github.com/line/armeria/commit/dbfeda1132544f058b7c2b55b6d9de08560e10ed", "message": "Address comments by @trustin / Add a simple example to Javadoc", "committedDate": "2020-09-09T07:36:01Z", "type": "commit"}, {"oid": "f6bf03cd4b85b2b32a65c781224eaa41eed0cfe4", "url": "https://github.com/line/armeria/commit/f6bf03cd4b85b2b32a65c781224eaa41eed0cfe4", "message": "Remove cruft", "committedDate": "2020-09-09T08:32:43Z", "type": "commit"}, {"oid": "8ef5e3bd2fde3e2740e392331c7b7c24f0dd562f", "url": "https://github.com/line/armeria/commit/8ef5e3bd2fde3e2740e392331c7b7c24f0dd562f", "message": "Merge branch 'master' into httpdata-processor", "committedDate": "2020-09-09T15:22:41Z", "type": "commit"}, {"oid": "9924a2ed2be691f01744daf1afa453d43004aeeb", "url": "https://github.com/line/armeria/commit/9924a2ed2be691f01744daf1afa453d43004aeeb", "message": "Fix flaky test", "committedDate": "2020-09-10T04:12:34Z", "type": "commit"}, {"oid": "87662c2c9daf7b38ebaf084cd6234eebe7d2c2e2", "url": "https://github.com/line/armeria/commit/87662c2c9daf7b38ebaf084cd6234eebe7d2c2e2", "message": "Merge branch 'master' into httpdata-processor", "committedDate": "2020-10-07T03:49:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAxNDg4MQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504014881", "bodyText": "remaining?", "author": "trustin", "createdAt": "2020-10-13T14:48:11Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/ByteBufDeframerInput.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.ReferenceCountUtil;\n+\n+final class ByteBufDeframerInput implements HttpDeframerInput {\n+\n+    private final ByteBufAllocator alloc;\n+    private final Queue<ByteBuf> queue;\n+\n+    ByteBufDeframerInput(ByteBufAllocator alloc) {\n+        this.alloc = alloc;\n+        queue = new ArrayDeque<>();\n+    }\n+\n+    void add(ByteBuf byteBuf) {\n+        queue.add(byteBuf);\n+    }\n+\n+    @Override\n+    public int readableBytes() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int readableBytes = 0;\n+        for (ByteBuf buf : queue) {\n+            readableBytes += buf.readableBytes();\n+        }\n+        return readableBytes;\n+    }\n+\n+    @Override\n+    public byte readByte() {\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+            return buf.readByte();\n+        }\n+        throw newEndOfInputException();\n+    }\n+\n+    @Override\n+    public int readInt() {\n+        final ByteBuf firstBuf = queue.peek();\n+        if (firstBuf == null) {\n+            throw newEndOfInputException();\n+        }\n+\n+        if (firstBuf.readableBytes() >= 4) {\n+            return firstBuf.readInt();\n+        }\n+\n+        return readIntSlow();\n+    }\n+\n+    private int readIntSlow() {\n+        int value = 0;\n+        int remained = 4;", "originalCommit": "87662c2c9daf7b38ebaf084cd6234eebe7d2c2e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAyMDk5Ng==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504020996", "bodyText": "How about just removing and returning the firstBuf as is if readableBytes == length?", "author": "trustin", "createdAt": "2020-10-13T14:55:57Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/ByteBufDeframerInput.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.ReferenceCountUtil;\n+\n+final class ByteBufDeframerInput implements HttpDeframerInput {\n+\n+    private final ByteBufAllocator alloc;\n+    private final Queue<ByteBuf> queue;\n+\n+    ByteBufDeframerInput(ByteBufAllocator alloc) {\n+        this.alloc = alloc;\n+        queue = new ArrayDeque<>();\n+    }\n+\n+    void add(ByteBuf byteBuf) {\n+        queue.add(byteBuf);\n+    }\n+\n+    @Override\n+    public int readableBytes() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int readableBytes = 0;\n+        for (ByteBuf buf : queue) {\n+            readableBytes += buf.readableBytes();\n+        }\n+        return readableBytes;\n+    }\n+\n+    @Override\n+    public byte readByte() {\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+            return buf.readByte();\n+        }\n+        throw newEndOfInputException();\n+    }\n+\n+    @Override\n+    public int readInt() {\n+        final ByteBuf firstBuf = queue.peek();\n+        if (firstBuf == null) {\n+            throw newEndOfInputException();\n+        }\n+\n+        if (firstBuf.readableBytes() >= 4) {\n+            return firstBuf.readInt();\n+        }\n+\n+        return readIntSlow();\n+    }\n+\n+    private int readIntSlow() {\n+        int value = 0;\n+        int remained = 4;\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+            final int readSize = Math.min(remained, buf.readableBytes());\n+            if (readSize == 4) {\n+                return buf.readInt();\n+            }\n+\n+            value <<= 8 * readSize;\n+            switch (readSize) {\n+                case 1:\n+                    value |= buf.readUnsignedByte();\n+                    break;\n+                case 2:\n+                    value |= buf.readUnsignedShort();\n+                    break;\n+                case 3:\n+                    value |= buf.readUnsignedMedium();\n+                    break;\n+                default:\n+                    throw new Error(); // Should not reach here.\n+            }\n+            remained -= readSize;\n+            if (remained == 0) {\n+                break;\n+            }\n+        }\n+\n+        if (remained == 0) {\n+            return value;\n+        } else {\n+            throw newEndOfInputException();\n+        }\n+    }\n+\n+    @Override\n+    public ByteBuf readBytes(int length) {\n+        checkArgument(length > 0, \"length %s (expected: length > 0)\", length);\n+        final ByteBuf firstBuf = queue.peek();\n+        if (firstBuf == null) {\n+            throw newEndOfInputException();\n+        }\n+\n+        if (firstBuf.readableBytes() >= length) {\n+            return firstBuf.readRetainedSlice(length);", "originalCommit": "87662c2c9daf7b38ebaf084cd6234eebe7d2c2e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAyNjQ4MA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504026480", "bodyText": "Ditto - could remove and return", "author": "trustin", "createdAt": "2020-10-13T15:02:50Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/ByteBufDeframerInput.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.ReferenceCountUtil;\n+\n+final class ByteBufDeframerInput implements HttpDeframerInput {\n+\n+    private final ByteBufAllocator alloc;\n+    private final Queue<ByteBuf> queue;\n+\n+    ByteBufDeframerInput(ByteBufAllocator alloc) {\n+        this.alloc = alloc;\n+        queue = new ArrayDeque<>();\n+    }\n+\n+    void add(ByteBuf byteBuf) {\n+        queue.add(byteBuf);\n+    }\n+\n+    @Override\n+    public int readableBytes() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int readableBytes = 0;\n+        for (ByteBuf buf : queue) {\n+            readableBytes += buf.readableBytes();\n+        }\n+        return readableBytes;\n+    }\n+\n+    @Override\n+    public byte readByte() {\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+            return buf.readByte();\n+        }\n+        throw newEndOfInputException();\n+    }\n+\n+    @Override\n+    public int readInt() {\n+        final ByteBuf firstBuf = queue.peek();\n+        if (firstBuf == null) {\n+            throw newEndOfInputException();\n+        }\n+\n+        if (firstBuf.readableBytes() >= 4) {\n+            return firstBuf.readInt();\n+        }\n+\n+        return readIntSlow();\n+    }\n+\n+    private int readIntSlow() {\n+        int value = 0;\n+        int remained = 4;\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+            final int readSize = Math.min(remained, buf.readableBytes());\n+            if (readSize == 4) {\n+                return buf.readInt();\n+            }\n+\n+            value <<= 8 * readSize;\n+            switch (readSize) {\n+                case 1:\n+                    value |= buf.readUnsignedByte();\n+                    break;\n+                case 2:\n+                    value |= buf.readUnsignedShort();\n+                    break;\n+                case 3:\n+                    value |= buf.readUnsignedMedium();\n+                    break;\n+                default:\n+                    throw new Error(); // Should not reach here.\n+            }\n+            remained -= readSize;\n+            if (remained == 0) {\n+                break;\n+            }\n+        }\n+\n+        if (remained == 0) {\n+            return value;\n+        } else {\n+            throw newEndOfInputException();\n+        }\n+    }\n+\n+    @Override\n+    public ByteBuf readBytes(int length) {\n+        checkArgument(length > 0, \"length %s (expected: length > 0)\", length);\n+        final ByteBuf firstBuf = queue.peek();\n+        if (firstBuf == null) {\n+            throw newEndOfInputException();\n+        }\n+\n+        if (firstBuf.readableBytes() >= length) {\n+            return firstBuf.readRetainedSlice(length);\n+        }\n+\n+        return readBytesSlow(length);\n+    }\n+\n+    private ByteBuf readBytesSlow(int length) {\n+        ByteBuf value = null;\n+        int remained = length;\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+\n+            final int readSize = Math.min(remained, buf.readableBytes());\n+            if (readSize == length) {\n+                return buf.readRetainedSlice(readSize);", "originalCommit": "87662c2c9daf7b38ebaf084cd6234eebe7d2c2e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAyNzQ0NQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504027445", "bodyText": "Could ignore an empty buffer", "author": "trustin", "createdAt": "2020-10-13T15:04:07Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/ByteBufDeframerInput.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.ReferenceCountUtil;\n+\n+final class ByteBufDeframerInput implements HttpDeframerInput {\n+\n+    private final ByteBufAllocator alloc;\n+    private final Queue<ByteBuf> queue;\n+\n+    ByteBufDeframerInput(ByteBufAllocator alloc) {\n+        this.alloc = alloc;\n+        queue = new ArrayDeque<>();\n+    }\n+\n+    void add(ByteBuf byteBuf) {\n+        queue.add(byteBuf);", "originalCommit": "87662c2c9daf7b38ebaf084cd6234eebe7d2c2e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAyOTA2Nw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504029067", "bodyText": "Follow the below steps to deframe HTTP payloads using ... ?", "author": "trustin", "createdAt": "2020-10-13T15:06:03Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ *\n+ * <p>To deframe HTTP payload using {@link HttpDeframer}, you can follow the steps below.", "originalCommit": "87662c2c9daf7b38ebaf084cd6234eebe7d2c2e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAyOTUyMw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504029523", "bodyText": "remaining", "author": "trustin", "createdAt": "2020-10-13T15:06:37Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ *\n+ * <p>To deframe HTTP payload using {@link HttpDeframer}, you can follow the steps below.\n+ * <ol>\n+ *   <li>Implement your deframing logic in {@link HttpDeframerHandler}.\n+ *       <pre>{@code\n+ *       > class FixedLengthDecoder implements HttpDeframerHandler<String> {\n+ *       >     private final int length;\n+ *\n+ *       >     FixedLengthDecoder(int length) {\n+ *       >         this.length = length;\n+ *       >     }\n+ *\n+ *       >     @Override\n+ *       >     public void process(HttpDeframerInput in, HttpDeframerOutput<String> out) {\n+ *       >         int remained = in.readableBytes();", "originalCommit": "87662c2c9daf7b38ebaf084cd6234eebe7d2c2e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAzMDM2OA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504030368", "bodyText": "do-while?", "author": "trustin", "createdAt": "2020-10-13T15:07:44Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ *\n+ * <p>To deframe HTTP payload using {@link HttpDeframer}, you can follow the steps below.\n+ * <ol>\n+ *   <li>Implement your deframing logic in {@link HttpDeframerHandler}.\n+ *       <pre>{@code\n+ *       > class FixedLengthDecoder implements HttpDeframerHandler<String> {\n+ *       >     private final int length;\n+ *\n+ *       >     FixedLengthDecoder(int length) {\n+ *       >         this.length = length;\n+ *       >     }\n+ *\n+ *       >     @Override\n+ *       >     public void process(HttpDeframerInput in, HttpDeframerOutput<String> out) {\n+ *       >         int remained = in.readableBytes();\n+ *       >         if (remained < length) {\n+ *       >             // The input is not enough to process. Waiting for more data.\n+ *       >             return;\n+ *       >         }\n+ *\n+ *       >         while (remained >= length) {", "originalCommit": "87662c2c9daf7b38ebaf084cd6234eebe7d2c2e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDY0ODY0Mw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504648643", "bodyText": "I think we can remove the while-loop here. \ud83d\ude05\nDon't care. I haven't seen this code in a while. \ud83e\udd23", "author": "ikhoon", "createdAt": "2020-10-14T12:49:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAzMDM2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAzNTc4OQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504035789", "bodyText": "How about making outputQueue implement the output interface, so we don't have to create a new instance of anonymous class?", "author": "trustin", "createdAt": "2020-10-13T15:14:47Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ *\n+ * <p>To deframe HTTP payload using {@link HttpDeframer}, you can follow the steps below.\n+ * <ol>\n+ *   <li>Implement your deframing logic in {@link HttpDeframerHandler}.\n+ *       <pre>{@code\n+ *       > class FixedLengthDecoder implements HttpDeframerHandler<String> {\n+ *       >     private final int length;\n+ *\n+ *       >     FixedLengthDecoder(int length) {\n+ *       >         this.length = length;\n+ *       >     }\n+ *\n+ *       >     @Override\n+ *       >     public void process(HttpDeframerInput in, HttpDeframerOutput<String> out) {\n+ *       >         int remained = in.readableBytes();\n+ *       >         if (remained < length) {\n+ *       >             // The input is not enough to process. Waiting for more data.\n+ *       >             return;\n+ *       >         }\n+ *\n+ *       >         while (remained >= length) {\n+ *       >             // Read data from 'HttpDeframerInput' and\n+ *       >             // write the processed result to 'HttpDeframerOutput'.\n+ *       >             ByteBuf buf = in.readBytes(length);\n+ *       >             out.add(buf.toString(StandardCharsets.UTF_8));\n+ *       >             // Should release the returned 'ByteBuf'\n+ *       >             buf.release();\n+ *       >             remained -= length;\n+ *       >         }\n+ *       >     }\n+ *       > }\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Create an {@link HttpDeframer} with the {@link HttpDeframerHandler} instance.\n+ *       <pre>{@code\n+ *       FixedLengthDecoder decoder = new FixedLengthDecoder(11);\n+ *       HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to a {@link HttpRequest} using the {@link HttpDeframer}.\n+ *       <pre>{@code\n+ *       HttpRequest request = ...;\n+ *       request.subscribe(deframer);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to the {@link Publisher} of the deframed data and connect to your business logic.\n+ *       <pre>{@code\n+ *       import reactor.core.publisher.Flux;\n+ *       Flux.from(deframer).map(...); // Consume and manipulate the deframed data.\n+ *       }</pre>\n+ *   </li>\n+ * </ol>\n+ */\n+@UnstableApi\n+public final class HttpDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpObject, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"subscribed\");\n+\n+    private final ArrayDeque<T> outputQueue = new ArrayDeque<>();\n+    private final HttpDeframerHandler<T> handler;\n+    private final ByteBufDeframerInput input;\n+    private final Function<? super HttpData, ? extends ByteBuf> byteBufConverter;\n+\n+    private boolean sawLeadingHeaders;\n+\n+    @Nullable\n+    private volatile EventExecutor eventLoop;\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean cancelled;\n+    private volatile int initialized;\n+    private volatile int subscribed;\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc) {\n+        this(handler, alloc, HttpData::byteBuf);\n+    }\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler},\n+     * {@link ByteBufAllocator} and {@code byteBufConverter}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc,\n+                        Function<? super HttpData, ? extends ByteBuf> byteBufConverter) {\n+        this.handler = requireNonNull(handler, \"handler\");\n+        input = new ByteBufDeframerInput(requireNonNull(alloc, \"alloc\"));\n+        this.byteBufConverter = requireNonNull(byteBufConverter, \"byteBufConverter\");\n+    }\n+\n+    private void process(HttpObject data) {\n+        if (data instanceof HttpHeaders) {\n+            final HttpHeaders headers = (HttpHeaders) data;\n+\n+            if (headers instanceof ResponseHeaders) {\n+                final ResponseHeaders responseHeaders = (ResponseHeaders) headers;\n+                if (responseHeaders.status().isInformational()) {\n+                    handler.processInformationalHeaders(responseHeaders, outputQueue::addLast);", "originalCommit": "87662c2c9daf7b38ebaf084cd6234eebe7d2c2e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwMzU0NQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504803545", "bodyText": "As suggested in the #2981 (comment),\nI used write() method to append the output to the queue.", "author": "ikhoon", "createdAt": "2020-10-14T16:12:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAzNTc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAzNzk3MA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504037970", "bodyText": ".apply() returned null.?", "author": "trustin", "createdAt": "2020-10-13T15:17:39Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ *\n+ * <p>To deframe HTTP payload using {@link HttpDeframer}, you can follow the steps below.\n+ * <ol>\n+ *   <li>Implement your deframing logic in {@link HttpDeframerHandler}.\n+ *       <pre>{@code\n+ *       > class FixedLengthDecoder implements HttpDeframerHandler<String> {\n+ *       >     private final int length;\n+ *\n+ *       >     FixedLengthDecoder(int length) {\n+ *       >         this.length = length;\n+ *       >     }\n+ *\n+ *       >     @Override\n+ *       >     public void process(HttpDeframerInput in, HttpDeframerOutput<String> out) {\n+ *       >         int remained = in.readableBytes();\n+ *       >         if (remained < length) {\n+ *       >             // The input is not enough to process. Waiting for more data.\n+ *       >             return;\n+ *       >         }\n+ *\n+ *       >         while (remained >= length) {\n+ *       >             // Read data from 'HttpDeframerInput' and\n+ *       >             // write the processed result to 'HttpDeframerOutput'.\n+ *       >             ByteBuf buf = in.readBytes(length);\n+ *       >             out.add(buf.toString(StandardCharsets.UTF_8));\n+ *       >             // Should release the returned 'ByteBuf'\n+ *       >             buf.release();\n+ *       >             remained -= length;\n+ *       >         }\n+ *       >     }\n+ *       > }\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Create an {@link HttpDeframer} with the {@link HttpDeframerHandler} instance.\n+ *       <pre>{@code\n+ *       FixedLengthDecoder decoder = new FixedLengthDecoder(11);\n+ *       HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to a {@link HttpRequest} using the {@link HttpDeframer}.\n+ *       <pre>{@code\n+ *       HttpRequest request = ...;\n+ *       request.subscribe(deframer);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to the {@link Publisher} of the deframed data and connect to your business logic.\n+ *       <pre>{@code\n+ *       import reactor.core.publisher.Flux;\n+ *       Flux.from(deframer).map(...); // Consume and manipulate the deframed data.\n+ *       }</pre>\n+ *   </li>\n+ * </ol>\n+ */\n+@UnstableApi\n+public final class HttpDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpObject, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"subscribed\");\n+\n+    private final ArrayDeque<T> outputQueue = new ArrayDeque<>();\n+    private final HttpDeframerHandler<T> handler;\n+    private final ByteBufDeframerInput input;\n+    private final Function<? super HttpData, ? extends ByteBuf> byteBufConverter;\n+\n+    private boolean sawLeadingHeaders;\n+\n+    @Nullable\n+    private volatile EventExecutor eventLoop;\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean cancelled;\n+    private volatile int initialized;\n+    private volatile int subscribed;\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc) {\n+        this(handler, alloc, HttpData::byteBuf);\n+    }\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler},\n+     * {@link ByteBufAllocator} and {@code byteBufConverter}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc,\n+                        Function<? super HttpData, ? extends ByteBuf> byteBufConverter) {\n+        this.handler = requireNonNull(handler, \"handler\");\n+        input = new ByteBufDeframerInput(requireNonNull(alloc, \"alloc\"));\n+        this.byteBufConverter = requireNonNull(byteBufConverter, \"byteBufConverter\");\n+    }\n+\n+    private void process(HttpObject data) {\n+        if (data instanceof HttpHeaders) {\n+            final HttpHeaders headers = (HttpHeaders) data;\n+\n+            if (headers instanceof ResponseHeaders) {\n+                final ResponseHeaders responseHeaders = (ResponseHeaders) headers;\n+                if (responseHeaders.status().isInformational()) {\n+                    handler.processInformationalHeaders(responseHeaders, outputQueue::addLast);\n+                    return;\n+                }\n+            }\n+\n+            if (!sawLeadingHeaders) {\n+                sawLeadingHeaders = true;\n+                handler.processHeaders((HttpHeaders) data, outputQueue::addLast);\n+            } else {\n+                handler.processTrailers((HttpHeaders) data, outputQueue::addLast);\n+            }\n+            return;\n+        }\n+\n+        if (data instanceof HttpData) {\n+            final ByteBuf byteBuf = byteBufConverter.apply((HttpData) data);\n+            requireNonNull(byteBuf, \"byteBufConverter returned null\");", "originalCommit": "87662c2c9daf7b38ebaf084cd6234eebe7d2c2e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA0OTAwMA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504049000", "bodyText": "How about adding throws Exception to all methods in this interface for user convenience?", "author": "trustin", "createdAt": "2020-10-13T15:30:03Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframerHandler.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import org.reactivestreams.Publisher;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+\n+/**\n+ * An {@link HttpDeframerHandler} that decodes a stream of {@link HttpObject}s to N objects.\n+ *\n+ * @param <T> the result type of being deframed\n+ */\n+public interface HttpDeframerHandler<T> {\n+\n+    /**\n+     * Decodes a stream of {@link HttpData}s to N objects.\n+     * This method will be called whenever an {@link HttpData} is signaled from {@link Publisher}.\n+     */\n+    void process(HttpDeframerInput in, HttpDeframerOutput<T> out);", "originalCommit": "87662c2c9daf7b38ebaf084cd6234eebe7d2c2e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwODkxOQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504808919", "bodyText": "throws Exception was added to all methods except processOnError(Throwable cause) because I thought it does not make sense to raise an exception on an error handler.\nOr we can do like the following style.\ntry {\n    process(data);\n    ...\n} catch (Throwable ex) {\n    Exceptions.throwIfFatal(ex);\n    try {\n        handler.processOnError(ex);\n    } catch (Throwable ex1) {\n        Exceptions.throwIfFatal(ex1);\n        ex = new CompositeException(ex1, ex);\n    }\n    cancelAndCleanup();\n    abort(ex);\n}", "author": "ikhoon", "createdAt": "2020-10-14T16:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA0OTAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEwNDgwMQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r506104801", "bodyText": "Or we can do like the following style.\n\nSGTM", "author": "trustin", "createdAt": "2020-10-16T07:03:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA0OTAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1MDAyNg==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504050026", "bodyText": "The Javadoc of this class needs to be updated so it doesn't mention readerIndex at all.", "author": "trustin", "createdAt": "2020-10-13T15:31:17Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframerInput.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.util.SafeCloseable;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+/**\n+ * An input of {@link HttpDeframer} which is used to read a stream of {@link HttpData}.\n+ */\n+public interface HttpDeframerInput extends SafeCloseable {\n+\n+    /**\n+     * Returns the number of readable bytes.\n+     */\n+    int readableBytes();\n+\n+    /**\n+     * Returns a byte at the current {@code readerIndex} and increases the {@code readerIndex} by {@code 1}.", "originalCommit": "87662c2c9daf7b38ebaf084cd6234eebe7d2c2e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1NDI2MQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504054261", "bodyText": "Would it be possible to write the output to the stream directly, instead of using an extra queue? As you know, DefaultStreamMessage has a backing queue already, so you can just call write() on output.add().", "author": "trustin", "createdAt": "2020-10-13T15:36:27Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ *\n+ * <p>To deframe HTTP payload using {@link HttpDeframer}, you can follow the steps below.\n+ * <ol>\n+ *   <li>Implement your deframing logic in {@link HttpDeframerHandler}.\n+ *       <pre>{@code\n+ *       > class FixedLengthDecoder implements HttpDeframerHandler<String> {\n+ *       >     private final int length;\n+ *\n+ *       >     FixedLengthDecoder(int length) {\n+ *       >         this.length = length;\n+ *       >     }\n+ *\n+ *       >     @Override\n+ *       >     public void process(HttpDeframerInput in, HttpDeframerOutput<String> out) {\n+ *       >         int remained = in.readableBytes();\n+ *       >         if (remained < length) {\n+ *       >             // The input is not enough to process. Waiting for more data.\n+ *       >             return;\n+ *       >         }\n+ *\n+ *       >         while (remained >= length) {\n+ *       >             // Read data from 'HttpDeframerInput' and\n+ *       >             // write the processed result to 'HttpDeframerOutput'.\n+ *       >             ByteBuf buf = in.readBytes(length);\n+ *       >             out.add(buf.toString(StandardCharsets.UTF_8));\n+ *       >             // Should release the returned 'ByteBuf'\n+ *       >             buf.release();\n+ *       >             remained -= length;\n+ *       >         }\n+ *       >     }\n+ *       > }\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Create an {@link HttpDeframer} with the {@link HttpDeframerHandler} instance.\n+ *       <pre>{@code\n+ *       FixedLengthDecoder decoder = new FixedLengthDecoder(11);\n+ *       HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to a {@link HttpRequest} using the {@link HttpDeframer}.\n+ *       <pre>{@code\n+ *       HttpRequest request = ...;\n+ *       request.subscribe(deframer);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to the {@link Publisher} of the deframed data and connect to your business logic.\n+ *       <pre>{@code\n+ *       import reactor.core.publisher.Flux;\n+ *       Flux.from(deframer).map(...); // Consume and manipulate the deframed data.\n+ *       }</pre>\n+ *   </li>\n+ * </ol>\n+ */\n+@UnstableApi\n+public final class HttpDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpObject, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"subscribed\");\n+\n+    private final ArrayDeque<T> outputQueue = new ArrayDeque<>();", "originalCommit": "87662c2c9daf7b38ebaf084cd6234eebe7d2c2e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDY3OTYyNQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504679625", "bodyText": "Nice suggestion! That is a brilliant idea.", "author": "ikhoon", "createdAt": "2020-10-14T13:32:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1NDI2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1NjAyNQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504056025", "bodyText": "Could you add assertions for buffer reference counts?", "author": "trustin", "createdAt": "2020-10-13T15:38:47Z", "path": "core/src/test/java/com/linecorp/armeria/common/stream/ByteBufDeframerInputTest.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.buffer.UnpooledByteBufAllocator;\n+\n+class ByteBufDeframerInputTest {", "originalCommit": "87662c2c9daf7b38ebaf084cd6234eebe7d2c2e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1NjYxNg==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504056616", "bodyText": "Ditto - please make sure there's no leak by checking reference counts.", "author": "trustin", "createdAt": "2020-10-13T15:39:35Z", "path": "core/src/test/java/com/linecorp/armeria/common/stream/HttpDeframerTest.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.junit.jupiter.api.Test;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import reactor.core.publisher.Flux;\n+import reactor.test.StepVerifier;\n+\n+class HttpDeframerTest {", "originalCommit": "87662c2c9daf7b38ebaf084cd6234eebe7d2c2e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA2MTA5MA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504061090", "bodyText": "Could specify two different functions for each case (with/without base64)", "author": "trustin", "createdAt": "2020-10-13T15:45:35Z", "path": "grpc-protocol/src/main/java/com/linecorp/armeria/common/grpc/protocol/ArmeriaMessageDeframer.java", "diffHunk": "@@ -102,351 +94,78 @@\n     // Valid type is always positive.\n     private static final int UNINITIALIED_TYPE = -1;\n \n-    /**\n-     * A deframed message. For uncompressed messages, we have the entire buffer available and return it\n-     * as is in {@code buf} to optimize parsing. For compressed messages, we will parse incrementally\n-     * and thus return a {@link InputStream} in {@code stream}.\n-     */\n-    @UnstableApi\n-    public static final class DeframedMessage {\n-        private final int type;\n-\n-        @Nullable\n-        private final ByteBuf buf;\n-        @Nullable\n-        private final InputStream stream;\n-\n-        /**\n-         * Creates a new instance with the specified {@link ByteBuf} and {@code type}.\n-         */\n-        @VisibleForTesting\n-        public DeframedMessage(ByteBuf buf, int type) {\n-            this(requireNonNull(buf, \"buf\"), null, type);\n-        }\n-\n-        /**\n-         * Creates a new instance with the specified {@link InputStream} and {@code type}.\n-         */\n-        @VisibleForTesting\n-        public DeframedMessage(InputStream stream, int type) {\n-            this(null, requireNonNull(stream, \"stream\"), type);\n-        }\n-\n-        private DeframedMessage(@Nullable ByteBuf buf, @Nullable InputStream stream, int type) {\n-            this.buf = buf;\n-            this.stream = stream;\n-            this.type = type;\n-        }\n-\n-        /**\n-         * Returns the {@link ByteBuf}.\n-         *\n-         * @return the {@link ByteBuf}, or {@code null} if not created with\n-         *         {@link #DeframedMessage(ByteBuf, int)}.\n-         */\n-        @Nullable\n-        public ByteBuf buf() {\n-            return buf;\n-        }\n-\n-        /**\n-         * Returns the {@link InputStream}.\n-         *\n-         * @return the {@link InputStream}, or {@code null} if not created with\n-         *         {@link #DeframedMessage(InputStream, int)}.\n-         */\n-        @Nullable\n-        public InputStream stream() {\n-            return stream;\n-        }\n-\n-        /**\n-         * Returns the type.\n-         */\n-        public int type() {\n-            return type;\n-        }\n-\n-        @Override\n-        public boolean equals(@Nullable Object o) {\n-            if (this == o) {\n-                return true;\n-            }\n-            if (!(o instanceof DeframedMessage)) {\n-                return false;\n-            }\n-\n-            final DeframedMessage that = (DeframedMessage) o;\n-\n-            return type == that.type && Objects.equals(buf, that.buf) && Objects.equals(stream, that.stream);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(buf, stream);\n-        }\n-    }\n-\n-    /**\n-     * A listener of deframing events.\n-     */\n-    @UnstableApi\n-    public interface Listener {\n-\n-        /**\n-         * Called to deliver the next complete message. Either {@code message.buf} or {@code message.stream}\n-         * will be non-null. {@code message.buf} must be released, or {@code message.stream} must be closed by\n-         * the callee.\n-         */\n-        void messageRead(DeframedMessage message);\n-\n-        /**\n-         * Called when the stream is complete and all messages have been successfully delivered.\n-         */\n-        void endOfStream();\n-    }\n-\n-    private final Listener listener;\n     private final int maxMessageSizeBytes;\n-    private final ByteBufAllocator alloc;\n-    @Nullable\n-    private final Base64Decoder base64Decoder;\n \n     private int currentType = UNINITIALIED_TYPE;\n-\n     private int requiredLength = HEADER_LENGTH;\n-    @Nullable\n-    private Decompressor decompressor;\n-\n-    @Nullable\n-    private CloseFuture whenClosed;\n-    private boolean endOfStream;\n-    private boolean closeWhenComplete;\n+    private boolean startedDeframing;\n \n     @Nullable\n-    private Queue<ByteBuf> unprocessed;\n-    private int unprocessedBytes;\n-\n-    private long pendingDeliveries;\n-    private boolean inDelivery;\n-    private boolean startedDeframing;\n+    private Decompressor decompressor;\n \n     /**\n      * Construct an {@link ArmeriaMessageDeframer} for reading messages out of a gRPC request or response.\n      */\n-    public ArmeriaMessageDeframer(Listener listener,\n-                                  int maxMessageSizeBytes,\n-                                  ByteBufAllocator alloc, boolean decodeBase64) {\n-        this.listener = requireNonNull(listener, \"listener\");\n+    public ArmeriaMessageDeframer(int maxMessageSizeBytes) {\n         this.maxMessageSizeBytes = maxMessageSizeBytes > 0 ? maxMessageSizeBytes : Integer.MAX_VALUE;\n-        this.alloc = requireNonNull(alloc, \"alloc\");\n-        unprocessed = new ArrayDeque<>();\n-        if (decodeBase64) {\n-            base64Decoder = new Base64Decoder(alloc);\n-        } else {\n-            base64Decoder = null;\n-        }\n-    }\n-\n-    /**\n-     * Requests up to the given number of messages from the call to be delivered to\n-     * {@link Listener#messageRead(DeframedMessage)}. No additional messages will be delivered.\n-     *\n-     * <p>If {@link #close()} has been called, this method will have no effect.\n-     *\n-     * @param numMessages the requested number of messages to be delivered to the listener.\n-     */\n-    public void request(int numMessages) {\n-        checkArgument(numMessages > 0, \"numMessages must be > 0\");\n-        if (isClosed()) {\n-            return;\n-        }\n-        pendingDeliveries += numMessages;\n-        deliver();\n     }\n \n     /**\n-     * Indicates whether delivery is currently stalled, pending receipt of more data. This means\n-     * that no additional data can be delivered to the application.\n+     * Returns a newly-created {@link HttpDeframer} using this {@link HttpDeframerHandler}.\n      */\n-    public boolean isStalled() {\n-        return !hasRequiredBytes();\n+    public final HttpDeframer<DeframedMessage> newHttpDeframer(ByteBufAllocator alloc) {\n+        return newHttpDeframer(alloc, false);\n     }\n \n     /**\n-     * Adds the given data to this deframer and attempts delivery to the listener.\n-     *\n-     * @param data the raw data read from the remote endpoint. Must be non-null.\n-     * @param endOfStream if {@code true}, indicates that {@code data} is the end of the stream from\n-     *        the remote endpoint.  End of stream should not be used in the event of a transport\n-     *        error, such as a stream reset.\n-     * @throws IllegalStateException if {@link #close()} has been called previously or if\n-     *         this method has previously been called with {@code endOfStream=true}.\n+     * Returns a newly-created {@link HttpDeframer} using this {@link HttpDeframerHandler}.\n+     * If {@code decodeBase64} is set to true, a base64-encoded {@link ByteBuf} is decoded before deframing.\n      */\n-    public void deframe(HttpData data, boolean endOfStream) {\n-        requireNonNull(data, \"data\");\n-        checkNotClosed();\n-        checkState(!this.endOfStream, \"Past end of stream\");\n-\n-        startedDeframing = true;\n-\n-        final int dataLength = data.length();\n-        if (dataLength != 0) {\n-            final ByteBuf buf;\n-            assert unprocessed != null;\n+    public final HttpDeframer<DeframedMessage> newHttpDeframer(ByteBufAllocator alloc, boolean decodeBase64) {\n+        final Base64Decoder base64Decoder;\n+        if (decodeBase64) {\n+            base64Decoder = new Base64Decoder(alloc);\n+        } else {\n+            base64Decoder = null;\n+        }\n+        return new HttpDeframer<>(this, alloc, data -> {", "originalCommit": "87662c2c9daf7b38ebaf084cd6234eebe7d2c2e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA2MTUyMQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504061521", "bodyText": "Missing Z", "author": "trustin", "createdAt": "2020-10-13T15:46:09Z", "path": "grpc-protocol/src/main/java/com/linecorp/armeria/common/grpc/protocol/ArmeriaMessageDeframer.java", "diffHunk": "@@ -102,351 +94,78 @@\n     // Valid type is always positive.\n     private static final int UNINITIALIED_TYPE = -1;\n \n-    /**\n-     * A deframed message. For uncompressed messages, we have the entire buffer available and return it\n-     * as is in {@code buf} to optimize parsing. For compressed messages, we will parse incrementally\n-     * and thus return a {@link InputStream} in {@code stream}.\n-     */\n-    @UnstableApi\n-    public static final class DeframedMessage {\n-        private final int type;\n-\n-        @Nullable\n-        private final ByteBuf buf;\n-        @Nullable\n-        private final InputStream stream;\n-\n-        /**\n-         * Creates a new instance with the specified {@link ByteBuf} and {@code type}.\n-         */\n-        @VisibleForTesting\n-        public DeframedMessage(ByteBuf buf, int type) {\n-            this(requireNonNull(buf, \"buf\"), null, type);\n-        }\n-\n-        /**\n-         * Creates a new instance with the specified {@link InputStream} and {@code type}.\n-         */\n-        @VisibleForTesting\n-        public DeframedMessage(InputStream stream, int type) {\n-            this(null, requireNonNull(stream, \"stream\"), type);\n-        }\n-\n-        private DeframedMessage(@Nullable ByteBuf buf, @Nullable InputStream stream, int type) {\n-            this.buf = buf;\n-            this.stream = stream;\n-            this.type = type;\n-        }\n-\n-        /**\n-         * Returns the {@link ByteBuf}.\n-         *\n-         * @return the {@link ByteBuf}, or {@code null} if not created with\n-         *         {@link #DeframedMessage(ByteBuf, int)}.\n-         */\n-        @Nullable\n-        public ByteBuf buf() {\n-            return buf;\n-        }\n-\n-        /**\n-         * Returns the {@link InputStream}.\n-         *\n-         * @return the {@link InputStream}, or {@code null} if not created with\n-         *         {@link #DeframedMessage(InputStream, int)}.\n-         */\n-        @Nullable\n-        public InputStream stream() {\n-            return stream;\n-        }\n-\n-        /**\n-         * Returns the type.\n-         */\n-        public int type() {\n-            return type;\n-        }\n-\n-        @Override\n-        public boolean equals(@Nullable Object o) {\n-            if (this == o) {\n-                return true;\n-            }\n-            if (!(o instanceof DeframedMessage)) {\n-                return false;\n-            }\n-\n-            final DeframedMessage that = (DeframedMessage) o;\n-\n-            return type == that.type && Objects.equals(buf, that.buf) && Objects.equals(stream, that.stream);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(buf, stream);\n-        }\n-    }\n-\n-    /**\n-     * A listener of deframing events.\n-     */\n-    @UnstableApi\n-    public interface Listener {\n-\n-        /**\n-         * Called to deliver the next complete message. Either {@code message.buf} or {@code message.stream}\n-         * will be non-null. {@code message.buf} must be released, or {@code message.stream} must be closed by\n-         * the callee.\n-         */\n-        void messageRead(DeframedMessage message);\n-\n-        /**\n-         * Called when the stream is complete and all messages have been successfully delivered.\n-         */\n-        void endOfStream();\n-    }\n-\n-    private final Listener listener;\n     private final int maxMessageSizeBytes;\n-    private final ByteBufAllocator alloc;\n-    @Nullable\n-    private final Base64Decoder base64Decoder;\n \n     private int currentType = UNINITIALIED_TYPE;\n-\n     private int requiredLength = HEADER_LENGTH;\n-    @Nullable\n-    private Decompressor decompressor;\n-\n-    @Nullable\n-    private CloseFuture whenClosed;\n-    private boolean endOfStream;\n-    private boolean closeWhenComplete;\n+    private boolean startedDeframing;\n \n     @Nullable\n-    private Queue<ByteBuf> unprocessed;\n-    private int unprocessedBytes;\n-\n-    private long pendingDeliveries;\n-    private boolean inDelivery;\n-    private boolean startedDeframing;\n+    private Decompressor decompressor;\n \n     /**\n      * Construct an {@link ArmeriaMessageDeframer} for reading messages out of a gRPC request or response.\n      */\n-    public ArmeriaMessageDeframer(Listener listener,\n-                                  int maxMessageSizeBytes,\n-                                  ByteBufAllocator alloc, boolean decodeBase64) {\n-        this.listener = requireNonNull(listener, \"listener\");\n+    public ArmeriaMessageDeframer(int maxMessageSizeBytes) {\n         this.maxMessageSizeBytes = maxMessageSizeBytes > 0 ? maxMessageSizeBytes : Integer.MAX_VALUE;\n-        this.alloc = requireNonNull(alloc, \"alloc\");\n-        unprocessed = new ArrayDeque<>();\n-        if (decodeBase64) {\n-            base64Decoder = new Base64Decoder(alloc);\n-        } else {\n-            base64Decoder = null;\n-        }\n-    }\n-\n-    /**\n-     * Requests up to the given number of messages from the call to be delivered to\n-     * {@link Listener#messageRead(DeframedMessage)}. No additional messages will be delivered.\n-     *\n-     * <p>If {@link #close()} has been called, this method will have no effect.\n-     *\n-     * @param numMessages the requested number of messages to be delivered to the listener.\n-     */\n-    public void request(int numMessages) {\n-        checkArgument(numMessages > 0, \"numMessages must be > 0\");\n-        if (isClosed()) {\n-            return;\n-        }\n-        pendingDeliveries += numMessages;\n-        deliver();\n     }\n \n     /**\n-     * Indicates whether delivery is currently stalled, pending receipt of more data. This means\n-     * that no additional data can be delivered to the application.\n+     * Returns a newly-created {@link HttpDeframer} using this {@link HttpDeframerHandler}.\n      */\n-    public boolean isStalled() {\n-        return !hasRequiredBytes();\n+    public final HttpDeframer<DeframedMessage> newHttpDeframer(ByteBufAllocator alloc) {\n+        return newHttpDeframer(alloc, false);\n     }\n \n     /**\n-     * Adds the given data to this deframer and attempts delivery to the listener.\n-     *\n-     * @param data the raw data read from the remote endpoint. Must be non-null.\n-     * @param endOfStream if {@code true}, indicates that {@code data} is the end of the stream from\n-     *        the remote endpoint.  End of stream should not be used in the event of a transport\n-     *        error, such as a stream reset.\n-     * @throws IllegalStateException if {@link #close()} has been called previously or if\n-     *         this method has previously been called with {@code endOfStream=true}.\n+     * Returns a newly-created {@link HttpDeframer} using this {@link HttpDeframerHandler}.\n+     * If {@code decodeBase64} is set to true, a base64-encoded {@link ByteBuf} is decoded before deframing.\n      */\n-    public void deframe(HttpData data, boolean endOfStream) {\n-        requireNonNull(data, \"data\");\n-        checkNotClosed();\n-        checkState(!this.endOfStream, \"Past end of stream\");\n-\n-        startedDeframing = true;\n-\n-        final int dataLength = data.length();\n-        if (dataLength != 0) {\n-            final ByteBuf buf;\n-            assert unprocessed != null;\n+    public final HttpDeframer<DeframedMessage> newHttpDeframer(ByteBufAllocator alloc, boolean decodeBase64) {\n+        final Base64Decoder base64Decoder;\n+        if (decodeBase64) {\n+            base64Decoder = new Base64Decoder(alloc);\n+        } else {\n+            base64Decoder = null;\n+        }\n+        return new HttpDeframer<>(this, alloc, data -> {\n             if (base64Decoder != null) {\n-                buf = base64Decoder.decode(data.byteBuf());\n+                return base64Decoder.decode(data.byteBuf());\n             } else {\n-                buf = data.byteBuf();\n+                return data.byteBuf();\n             }\n-            unprocessed.add(buf);\n-            unprocessedBytes += buf.readableBytes();\n-        }\n-\n-        // Indicate that all of the data for this stream has been received.\n-        this.endOfStream = endOfStream;\n-        deliver();\n-    }\n-\n-    /**\n-     * Requests closing this deframer when any messages currently queued have been requested and delivered.\n-     */\n-    public void closeWhenComplete() {\n-        if (isClosed()) {\n-            return;\n-        }\n-\n-        if (isStalled()) {\n-            close();\n-        } else {\n-            closeWhenComplete = true;\n-        }\n+        });\n     }\n \n-    /**\n-     * Closes this deframer and frees any resources. After this method is called, additional\n-     * calls will have no effect.\n-     */\n     @Override\n-    public void close() {\n-        if (unprocessed != null) {\n-            try {\n-                unprocessed.forEach(ByteBuf::release);\n-            } finally {\n-                unprocessed = null;\n-            }\n-\n-            if (endOfStream) {\n-                listener.endOfStream();\n-            }\n-        }\n-\n-        if (whenClosed == null) {\n-            whenClosed = CLOSED_FUTURE;\n-        } else {\n-            whenClosed.doComplete();\n-        }\n-    }\n-\n-    /**\n-     * Returns a {@link CompletableFuture} which will be completed when this deframer has been closed.\n-     */\n-    public CompletableFuture<Void> whenClosed() {\n-        if (whenClosed == null) {\n-            whenClosed = new CloseFuture();\n-        }\n-        return whenClosed;\n-    }\n-\n-    /**\n-     * Indicates whether or not this deframer is closing.\n-     */\n-    public boolean isClosing() {\n-        return closeWhenComplete;\n-    }\n-\n-    /**\n-     * Indicates whether or not this deframer has been closed.\n-     */\n-    public boolean isClosed() {\n-        return unprocessed == null;\n-    }\n-\n-    /**\n-     * Sets the {@link Decompressor} for this deframer.\n-     */\n-    public ArmeriaMessageDeframer decompressor(@Nullable Decompressor decompressor) {\n-        checkState(!startedDeframing, \"Deframing has already started, cannot change decompressor mid-stream.\");\n-        this.decompressor = decompressor;\n-        return this;\n-    }\n-\n-    /**\n-     * Throws if this deframer has already been closed.\n-     */\n-    private void checkNotClosed() {\n-        checkState(!isClosed(), \"MessageDeframer is already closed\");\n-    }\n-\n-    /**\n-     * Reads and delivers as many messages to the listener as possible.\n-     */\n-    private void deliver() {\n-        // We can have reentrancy here when using a direct executor, triggered by calls to\n-        // request more messages. This is safe as we simply loop until pendingDelivers = 0\n-        if (inDelivery) {\n-            return;\n-        }\n-        inDelivery = true;\n-        try {\n-            // Process the uncompressed bytes.\n-            while (pendingDeliveries > 0 && hasRequiredBytes()) {\n-                if (currentType == UNINITIALIED_TYPE) {\n-                    readHeader();\n-                } else {\n-                    // Read the body and deliver the message.\n-                    readBody();\n-\n-                    // Since we've delivered a message, decrement the number of pending\n-                    // deliveries remaining.\n-                    pendingDeliveries--;\n-                }\n-            }\n-\n-            /*\n-             * We are stalled when there are no more bytes to process. This allows delivering errors as\n-             * soon as the buffered input has been consumed, independent of whether the application\n-             * has requested another message.  At this point in the function, either all frames have been\n-             * delivered, or unprocessed is empty.  If there is a partial message, it will be inside next\n-             * frame and not in unprocessed.  If there is extra data but no pending deliveries, it will\n-             * be in unprocessed.\n-             */\n-            if (closeWhenComplete && isStalled()) {\n-                close();\n+    public void process(HttpDeframerInput in, HttpDeframerOutput<DeframedMessage> out) {\n+        startedDeframing = true;\n+        int readableBytes = in.readableBytes();\n+        while (readableBytes >= requiredLength) {\n+            final int length = requiredLength;\n+            if (currentType == UNINITIALIED_TYPE) {", "originalCommit": "87662c2c9daf7b38ebaf084cd6234eebe7d2c2e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwOTQxNw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504809417", "bodyText": "Z? \ud83e\udd14", "author": "ikhoon", "createdAt": "2020-10-14T16:21:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA2MTUyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEwMzkyOQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r506103929", "bodyText": "UNINITIALIZED_TYPE", "author": "trustin", "createdAt": "2020-10-16T07:01:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA2MTUyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc4NzAyMQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r506787021", "bodyText": "Oops... \ud83d\ude05", "author": "ikhoon", "createdAt": "2020-10-17T03:13:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA2MTUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA2NjM5Nw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504066397", "bodyText": "This doesn't read well. It doesn't make sense to create a deframer from a deframer.", "author": "trustin", "createdAt": "2020-10-13T15:52:56Z", "path": "grpc-protocol/src/main/java/com/linecorp/armeria/server/grpc/protocol/AbstractUnsafeUnaryGrpcService.java", "diffHunk": "@@ -100,29 +105,40 @@ protected final HttpResponse doPost(ServiceRequestContext ctx, HttpRequest req)\n         return HttpResponse.from(responseFuture);\n     }\n \n-    private static CompletableFuture<ByteBuf> deframeMessage(HttpData framed, ByteBufAllocator alloc) {\n+    private static CompletableFuture<ByteBuf> deframeMessage(HttpData framed,\n+                                                             EventLoop eventLoop,\n+                                                             ByteBufAllocator alloc) {\n         final CompletableFuture<ByteBuf> deframed = new CompletableFuture<>();\n-        try (ArmeriaMessageDeframer deframer = new ArmeriaMessageDeframer(\n-                new Listener() {\n-                    @Override\n-                    public void messageRead(DeframedMessage message) {\n-                        // Compression not supported.\n-                        assert message.buf() != null;\n-                        deframed.complete(message.buf());\n-                    }\n-\n-                    @Override\n-                    public void endOfStream() {\n-                        if (!deframed.isDone()) {\n-                            deframed.complete(Unpooled.EMPTY_BUFFER);\n-                        }\n-                    }\n-                },\n-                Integer.MAX_VALUE,\n-                alloc, false)) {\n-            deframer.request(1);\n-            deframer.deframe(framed, true);\n-        }\n+        final HttpDeframer<DeframedMessage> deframer =\n+                new ArmeriaMessageDeframer(Integer.MAX_VALUE).newHttpDeframer(alloc);", "originalCommit": "87662c2c9daf7b38ebaf084cd6234eebe7d2c2e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMDQ3Mw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504810473", "bodyText": "Removed newHttpDeframer() method from the ArmeriaMessageDeframer and\nRenamed ArmeriaMessageDeframer to ArmeriaMessageDeframerHandler for clarification.", "author": "ikhoon", "createdAt": "2020-10-14T16:23:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA2NjM5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA2ODQyMw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504068423", "bodyText": "Could extract a part of this method to avoid calling inEventLoop() unnecessarily", "author": "trustin", "createdAt": "2020-10-13T15:55:31Z", "path": "grpc/src/main/java/com/linecorp/armeria/internal/client/grpc/ArmeriaClientCall.java", "diffHunk": "@@ -213,16 +217,26 @@ public void start(Listener<O> responseListener, Metadata metadata) {\n                                                                     .withDescription(cause.getMessage())\n                                                                     .asRuntimeException()));\n \n+        final HttpStreamDeframer streamDeframer =\n+                new HttpStreamDeframer(decompressorRegistry, this, maxInboundMessageSizeBytes);\n+        responseReader = streamDeframer.newHttpDeframer(ctx.alloc(), grpcWebText);\n+        streamDeframer.setDeframer(responseReader);\n+        responseReader.subscribe(this, ctx.eventLoop());\n+\n         res.subscribe(responseReader, ctx.eventLoop(), SubscriptionOption.WITH_POOLED_OBJECTS);\n         responseListener.onReady();\n     }\n \n     @Override\n     public void request(int numMessages) {\n         if (ctx.eventLoop().inEventLoop()) {\n-            responseReader.request(numMessages);\n+            if (upstream == null) {\n+                pendingRequests += numMessages;\n+            } else {\n+                upstream.request(numMessages);\n+            }\n         } else {\n-            ctx.eventLoop().execute(() -> responseReader.request(numMessages));\n+            ctx.eventLoop().execute(() -> request(numMessages));", "originalCommit": "87662c2c9daf7b38ebaf084cd6234eebe7d2c2e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA3MTIzNA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r504071234", "bodyText": "handle(). Don't forget whenComplete() is slow in Java 8", "author": "trustin", "createdAt": "2020-10-13T15:59:10Z", "path": "grpc/src/main/java/com/linecorp/armeria/internal/common/grpc/HttpStreamDeframer.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.grpc;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.grpc.protocol.ArmeriaMessageDeframer;\n+import com.linecorp.armeria.common.grpc.protocol.Decompressor;\n+import com.linecorp.armeria.common.grpc.protocol.GrpcHeaderNames;\n+import com.linecorp.armeria.common.stream.HttpDeframer;\n+import com.linecorp.armeria.common.stream.HttpDeframerOutput;\n+\n+import io.grpc.DecompressorRegistry;\n+import io.grpc.Status;\n+\n+public final class HttpStreamDeframer extends ArmeriaMessageDeframer {\n+\n+    private final DecompressorRegistry decompressorRegistry;\n+    private final TransportStatusListener transportStatusListener;\n+\n+    @Nullable\n+    private HttpDeframer<DeframedMessage> deframer;\n+\n+    public HttpStreamDeframer(DecompressorRegistry decompressorRegistry,\n+                              TransportStatusListener transportStatusListener,\n+                              int maxMessageSizeBytes) {\n+        super(maxMessageSizeBytes);\n+        this.decompressorRegistry = requireNonNull(decompressorRegistry, \"decompressorRegistry\");\n+        this.transportStatusListener = requireNonNull(transportStatusListener, \"transportStatusListener\");\n+    }\n+\n+    /**\n+     * Sets the specified {@link HttpDeframer}.\n+     * Note that the deframer should be set before processing the first {@link HttpObject}.\n+     */\n+    public void setDeframer(HttpDeframer<DeframedMessage> deframer) {\n+        requireNonNull(deframer, \"deframer\");\n+        checkState(this.deframer == null, \"deframer is already set\");\n+        this.deframer = deframer;\n+    }\n+\n+    @Override\n+    public void processHeaders(HttpHeaders headers, HttpDeframerOutput<DeframedMessage> out) {\n+        // Only clients will see headers from a stream. It doesn't hurt to share this logic between server\n+        // and client though as everything else is identical.\n+        final String statusText = headers.get(HttpHeaderNames.STATUS);\n+        if (statusText == null) {\n+            // Not allowed to have empty leading headers, kill the stream hard.\n+            transportStatusListener.transportReportStatus(\n+                    Status.INTERNAL.withDescription(\"Missing HTTP status code\"));\n+            return;\n+        }\n+\n+        final HttpStatus status = HttpStatus.valueOf(statusText);\n+        if (!status.equals(HttpStatus.OK)) {\n+            transportStatusListener.transportReportStatus(\n+                    GrpcStatus.httpStatusToGrpcStatus(status.code()));\n+            return;\n+        }\n+\n+        final String grpcStatus = headers.get(GrpcHeaderNames.GRPC_STATUS);\n+        if (grpcStatus != null) {\n+            assert deframer != null;\n+            // A gRPC client could not receive messages fully yet.\n+            // Let ArmeriaClientCall be closed when the gRPC client has been consumed all messages.\n+            deframer.whenComplete().whenComplete((unused1, unused2) -> {", "originalCommit": "87662c2c9daf7b38ebaf084cd6234eebe7d2c2e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fc9712e0d29aa0b6362f239fe61f01311ab0e1d3", "url": "https://github.com/line/armeria/commit/fc9712e0d29aa0b6362f239fe61f01311ab0e1d3", "message": "Address comments by @trustin", "committedDate": "2020-10-14T15:49:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEwNTQ4OA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r506105488", "bodyText": "Must release when empty.", "author": "trustin", "createdAt": "2020-10-16T07:04:31Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/ByteBufDeframerInput.java", "diffHunk": "@@ -36,7 +37,9 @@\n     }\n \n     void add(ByteBuf byteBuf) {\n-        queue.add(byteBuf);\n+        if (byteBuf.isReadable()) {\n+            queue.add(byteBuf);\n+        }", "originalCommit": "fc9712e0d29aa0b6362f239fe61f01311ab0e1d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEwNjY3Mw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r506106673", "bodyText": "You could move this line before the if (!buf.readable()) above, and change the if statement to if (readableBytes == 0)", "author": "trustin", "createdAt": "2020-10-16T07:06:03Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/ByteBufDeframerInput.java", "diffHunk": "@@ -133,28 +140,43 @@ public ByteBuf readBytes(int length) {\n \n     private ByteBuf readBytesSlow(int length) {\n         ByteBuf value = null;\n-        int remained = length;\n-        for (ByteBuf buf : queue) {\n+        int remaining = length;\n+        for (final Iterator<ByteBuf> it = queue.iterator(); it.hasNext();) {\n+            final ByteBuf buf = it.next();\n             if (!buf.isReadable()) {\n+                it.remove();\n+                buf.release();\n                 continue;\n             }\n \n-            final int readSize = Math.min(remained, buf.readableBytes());\n-            if (readSize == length) {\n-                return buf.readRetainedSlice(readSize);\n-            } else {\n-                if (value == null) {\n-                    value = alloc.buffer(length);\n+            final int readableBytes = buf.readableBytes();", "originalCommit": "fc9712e0d29aa0b6362f239fe61f01311ab0e1d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc4NzQ5Ng==", "url": "https://github.com/line/armeria/pull/2981#discussion_r506787496", "bodyText": "I cleaned up ByteBufDeframerInput a bit to immediately remove a ByteBuf from queue  when it can no longer be read.", "author": "ikhoon", "createdAt": "2020-10-17T03:20:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEwNjY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEwNzUwMA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r506107500", "bodyText": "We don't need this at all if we never add an empty buffer and always remove an empty buffer as soon as it's consumed. Just an assertion will do, e.g. assert readableBytes > 0 : buf", "author": "trustin", "createdAt": "2020-10-16T07:07:12Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/ByteBufDeframerInput.java", "diffHunk": "@@ -133,28 +140,43 @@ public ByteBuf readBytes(int length) {\n \n     private ByteBuf readBytesSlow(int length) {\n         ByteBuf value = null;\n-        int remained = length;\n-        for (ByteBuf buf : queue) {\n+        int remaining = length;\n+        for (final Iterator<ByteBuf> it = queue.iterator(); it.hasNext();) {\n+            final ByteBuf buf = it.next();\n             if (!buf.isReadable()) {\n+                it.remove();\n+                buf.release();\n                 continue;\n             }", "originalCommit": "fc9712e0d29aa0b6362f239fe61f01311ab0e1d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEwODY5Mw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r506108693", "bodyText": "Could just return value here?", "author": "trustin", "createdAt": "2020-10-16T07:09:05Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/ByteBufDeframerInput.java", "diffHunk": "@@ -133,28 +140,43 @@ public ByteBuf readBytes(int length) {\n \n     private ByteBuf readBytesSlow(int length) {\n         ByteBuf value = null;\n-        int remained = length;\n-        for (ByteBuf buf : queue) {\n+        int remaining = length;\n+        for (final Iterator<ByteBuf> it = queue.iterator(); it.hasNext();) {\n+            final ByteBuf buf = it.next();\n             if (!buf.isReadable()) {\n+                it.remove();\n+                buf.release();\n                 continue;\n             }\n \n-            final int readSize = Math.min(remained, buf.readableBytes());\n-            if (readSize == length) {\n-                return buf.readRetainedSlice(readSize);\n-            } else {\n-                if (value == null) {\n-                    value = alloc.buffer(length);\n+            final int readableBytes = buf.readableBytes();\n+            if (value == null) {\n+                if (readableBytes == length) {\n+                    it.remove();\n+                    return buf;\n                 }\n-                value.writeBytes(buf, readSize);\n-                remained -= readSize;\n-                if (remained == 0) {\n-                    break;\n+\n+                if (readableBytes > length) {\n+                    return buf.readRetainedSlice(length);\n                 }\n+\n+                value = alloc.buffer(length);\n+            }\n+\n+            final int readSize = Math.min(remaining, readableBytes);\n+            value.writeBytes(buf, readSize);\n+            if (readableBytes == readSize) {\n+                it.remove();\n+                buf.release();\n+            }\n+\n+            remaining -= readSize;\n+            if (remaining == 0) {\n+                break;", "originalCommit": "fc9712e0d29aa0b6362f239fe61f01311ab0e1d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjExMTA0OQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r506111049", "bodyText": "We are sure remaining > 0 here, and thus this could be simplified into:\nReferenceCountUtilk.release(value);\nthrow newEndOfInputException();", "author": "trustin", "createdAt": "2020-10-16T07:13:00Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/ByteBufDeframerInput.java", "diffHunk": "@@ -133,28 +140,43 @@ public ByteBuf readBytes(int length) {\n \n     private ByteBuf readBytesSlow(int length) {\n         ByteBuf value = null;\n-        int remained = length;\n-        for (ByteBuf buf : queue) {\n+        int remaining = length;\n+        for (final Iterator<ByteBuf> it = queue.iterator(); it.hasNext();) {\n+            final ByteBuf buf = it.next();\n             if (!buf.isReadable()) {\n+                it.remove();\n+                buf.release();\n                 continue;\n             }\n \n-            final int readSize = Math.min(remained, buf.readableBytes());\n-            if (readSize == length) {\n-                return buf.readRetainedSlice(readSize);\n-            } else {\n-                if (value == null) {\n-                    value = alloc.buffer(length);\n+            final int readableBytes = buf.readableBytes();\n+            if (value == null) {\n+                if (readableBytes == length) {\n+                    it.remove();\n+                    return buf;\n                 }\n-                value.writeBytes(buf, readSize);\n-                remained -= readSize;\n-                if (remained == 0) {\n-                    break;\n+\n+                if (readableBytes > length) {\n+                    return buf.readRetainedSlice(length);\n                 }\n+\n+                value = alloc.buffer(length);\n+            }\n+\n+            final int readSize = Math.min(remaining, readableBytes);\n+            value.writeBytes(buf, readSize);\n+            if (readableBytes == readSize) {\n+                it.remove();\n+                buf.release();\n+            }\n+\n+            remaining -= readSize;\n+            if (remaining == 0) {\n+                break;\n             }\n         }\n \n-        if (remained > 0 || value == null) {\n+        if (remaining > 0 || value == null) {\n             ReferenceCountUtil.release(value);\n             throw newEndOfInputException();\n         }", "originalCommit": "fc9712e0d29aa0b6362f239fe61f01311ab0e1d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjExMzI3Nw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r506113277", "bodyText": "Returns -> Reads ?", "author": "trustin", "createdAt": "2020-10-16T07:16:31Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframerInput.java", "diffHunk": "@@ -32,27 +32,24 @@\n     int readableBytes();\n \n     /**\n-     * Returns a byte at the current {@code readerIndex} and increases the {@code readerIndex} by {@code 1}.\n+     * Returns a byte from the readable bytes.", "originalCommit": "fc9712e0d29aa0b6362f239fe61f01311ab0e1d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc4NzUxNw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r506787517", "bodyText": "Fixed. :-)", "author": "ikhoon", "createdAt": "2020-10-17T03:20:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjExMzI3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjExMzg3MQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r506113871", "bodyText": "Is this still needed?", "author": "trustin", "createdAt": "2020-10-16T07:17:37Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/ByteBufDeframerInput.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.ArrayDeque;\n+import java.util.Iterator;\n+import java.util.Queue;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.ReferenceCountUtil;\n+\n+final class ByteBufDeframerInput implements HttpDeframerInput {\n+\n+    private final ByteBufAllocator alloc;\n+    private final Queue<ByteBuf> queue;\n+\n+    ByteBufDeframerInput(ByteBufAllocator alloc) {\n+        this.alloc = alloc;\n+        queue = new ArrayDeque<>();\n+    }\n+\n+    void add(ByteBuf byteBuf) {\n+        if (byteBuf.isReadable()) {\n+            queue.add(byteBuf);\n+        }\n+    }\n+\n+    @Override\n+    public int readableBytes() {\n+        if (queue.isEmpty()) {\n+            return 0;\n+        }\n+\n+        int readableBytes = 0;\n+        for (ByteBuf buf : queue) {\n+            readableBytes += buf.readableBytes();\n+        }\n+        return readableBytes;\n+    }\n+\n+    @Override\n+    public byte readByte() {\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+            return buf.readByte();\n+        }\n+        throw newEndOfInputException();\n+    }\n+\n+    @Override\n+    public int readInt() {\n+        final ByteBuf firstBuf = queue.peek();\n+        if (firstBuf == null) {\n+            throw newEndOfInputException();\n+        }\n+\n+        if (firstBuf.readableBytes() >= 4) {\n+            return firstBuf.readInt();\n+        }\n+\n+        return readIntSlow();\n+    }\n+\n+    private int readIntSlow() {\n+        int value = 0;\n+        int remaining = 4;\n+        for (ByteBuf buf : queue) {\n+            if (!buf.isReadable()) {\n+                continue;\n+            }\n+            final int readSize = Math.min(remaining, buf.readableBytes());\n+            if (readSize == 4) {\n+                return buf.readInt();\n+            }\n+\n+            value <<= 8 * readSize;\n+            switch (readSize) {\n+                case 1:\n+                    value |= buf.readUnsignedByte();\n+                    break;\n+                case 2:\n+                    value |= buf.readUnsignedShort();\n+                    break;\n+                case 3:\n+                    value |= buf.readUnsignedMedium();\n+                    break;\n+                default:\n+                    throw new Error(); // Should not reach here.\n+            }\n+            remaining -= readSize;\n+            if (remaining == 0) {\n+                break;\n+            }\n+        }\n+\n+        if (remaining == 0) {\n+            return value;\n+        } else {\n+            throw newEndOfInputException();\n+        }\n+    }\n+\n+    @Override\n+    public ByteBuf readBytes(int length) {\n+        checkArgument(length > 0, \"length %s (expected: length > 0)\", length);\n+        final ByteBuf firstBuf = queue.peek();\n+        if (firstBuf == null) {\n+            throw newEndOfInputException();\n+        }\n+\n+        final int readableBytes = firstBuf.readableBytes();\n+        if (readableBytes == length) {\n+            return queue.remove();\n+        }\n+        if (readableBytes > length) {\n+            return firstBuf.readRetainedSlice(length);\n+        }\n+\n+        return readBytesSlow(length);\n+    }\n+\n+    private ByteBuf readBytesSlow(int length) {\n+        ByteBuf value = null;\n+        int remaining = length;\n+        for (final Iterator<ByteBuf> it = queue.iterator(); it.hasNext();) {\n+            final ByteBuf buf = it.next();\n+            if (!buf.isReadable()) {\n+                it.remove();\n+                buf.release();\n+                continue;\n+            }\n+\n+            final int readableBytes = buf.readableBytes();\n+            if (value == null) {\n+                if (readableBytes == length) {\n+                    it.remove();\n+                    return buf;\n+                }\n+\n+                if (readableBytes > length) {\n+                    return buf.readRetainedSlice(length);\n+                }\n+\n+                value = alloc.buffer(length);\n+            }\n+\n+            final int readSize = Math.min(remaining, readableBytes);\n+            value.writeBytes(buf, readSize);\n+            if (readableBytes == readSize) {\n+                it.remove();\n+                buf.release();\n+            }\n+\n+            remaining -= readSize;\n+            if (remaining == 0) {\n+                break;\n+            }\n+        }\n+\n+        if (remaining > 0 || value == null) {\n+            ReferenceCountUtil.release(value);\n+            throw newEndOfInputException();\n+        }\n+\n+        return value;\n+    }\n+\n+    /**\n+     * Discards the {@link ByteBuf}s that have been fully consumed and are not readable anymore.\n+     */\n+    void discardReadBytes() {\n+        for (;;) {\n+            final ByteBuf buf = queue.peek();\n+            if (buf != null && !buf.isReadable()) {\n+                queue.remove().release();\n+            } else {\n+                break;\n+            }\n+        }\n+    }", "originalCommit": "fc9712e0d29aa0b6362f239fe61f01311ab0e1d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc4NzU5MQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r506787591", "bodyText": "discardReadBytes() was removed after fixing readInt() and readByte() together.", "author": "ikhoon", "createdAt": "2020-10-17T03:21:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjExMzg3MQ=="}], "type": "inlineReview"}, {"oid": "6e75efcd85cda257e491c422d319864f09027608", "url": "https://github.com/line/armeria/commit/6e75efcd85cda257e491c422d319864f09027608", "message": "Address comments by @trustin / Clean up ByteBufDeframerInput", "committedDate": "2020-10-17T03:15:27Z", "type": "commit"}, {"oid": "cb41fde99a389ec475ea76269c55c2cb276302a7", "url": "https://github.com/line/armeria/commit/cb41fde99a389ec475ea76269c55c2cb276302a7", "message": "Cruft", "committedDate": "2020-10-17T03:32:52Z", "type": "commit"}, {"oid": "903aba25da82e20859c12b292fc75ccdf2a1822d", "url": "https://github.com/line/armeria/commit/903aba25da82e20859c12b292fc75ccdf2a1822d", "message": "Merge branch 'master' into httpdata-processor", "committedDate": "2020-10-17T03:40:52Z", "type": "commit"}, {"oid": "c8f7d5fca29d52c767d4082c47a856bbe28ce975", "url": "https://github.com/line/armeria/commit/c8f7d5fca29d52c767d4082c47a856bbe28ce975", "message": "checkstyle", "committedDate": "2020-10-27T07:40:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg3ODUyNg==", "url": "https://github.com/line/armeria/pull/2981#discussion_r513878526", "bodyText": "an unsigned?", "author": "minwoox", "createdAt": "2020-10-29T02:08:49Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframerInput.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.util.SafeCloseable;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+/**\n+ * An input of {@link HttpDeframer} which is used to read a stream of {@link HttpData}.\n+ */\n+public interface HttpDeframerInput extends SafeCloseable {\n+\n+    /**\n+     * Returns the number of readable bytes.\n+     */\n+    int readableBytes();\n+\n+    /**\n+     * Reads a byte from the readable bytes.\n+     */\n+    byte readByte();\n+\n+    /**\n+     * Reads a unsigned byte from the readable bytes.", "originalCommit": "c8f7d5fca29d52c767d4082c47a856bbe28ce975", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg4MjY0NQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r513882645", "bodyText": "How about just doing:\nif (subscriptionImpl == subscription) {\n    eventLoop = subscription.executor();\n    deferredInit();\n}\nand remove subscribedUpdater?", "author": "minwoox", "createdAt": "2020-10-29T02:17:32Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ *\n+ * <p>Follow the below steps to deframe HTTP payload using {@link HttpDeframer}.\n+ * <ol>\n+ *   <li>Implement your deframing logic in {@link HttpDeframerHandler}.\n+ *       <pre>{@code\n+ *       > class FixedLengthDecoder implements HttpDeframerHandler<String> {\n+ *       >     private final int length;\n+ *\n+ *       >     FixedLengthDecoder(int length) {\n+ *       >         this.length = length;\n+ *       >     }\n+ *\n+ *       >     @Override\n+ *       >     public void process(HttpDeframerInput in, HttpDeframerOutput<String> out) {\n+ *       >         int remaining = in.readableBytes();\n+ *       >         if (remaining < length) {\n+ *       >             // The input is not enough to process. Waiting for more data.\n+ *       >             return;\n+ *       >         }\n+ *\n+ *       >         do {\n+ *       >             // Read data from 'HttpDeframerInput' and\n+ *       >             // write the processed result to 'HttpDeframerOutput'.\n+ *       >             ByteBuf buf = in.readBytes(length);\n+ *       >             out.add(buf.toString(StandardCharsets.UTF_8));\n+ *       >             // Should release the returned 'ByteBuf'\n+ *       >             buf.release();\n+ *       >             remaining -= length;\n+ *       >         } while (remaining >= length);\n+ *       >     }\n+ *       > }\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Create an {@link HttpDeframer} with the {@link HttpDeframerHandler} instance.\n+ *       <pre>{@code\n+ *       FixedLengthDecoder decoder = new FixedLengthDecoder(11);\n+ *       HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to a {@link HttpRequest} using the {@link HttpDeframer}.\n+ *       <pre>{@code\n+ *       HttpRequest request = ...;\n+ *       request.subscribe(deframer);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to the {@link Publisher} of the deframed data and connect to your business logic.\n+ *       <pre>{@code\n+ *       import reactor.core.publisher.Flux;\n+ *       Flux.from(deframer).map(...); // Consume and manipulate the deframed data.\n+ *       }</pre>\n+ *   </li>\n+ * </ol>\n+ */\n+@UnstableApi\n+public final class HttpDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpObject, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"subscribed\");\n+\n+    private final HttpDeframerHandler<T> handler;\n+    private final ByteBufDeframerInput input;\n+    private final Function<? super HttpData, ? extends ByteBuf> byteBufConverter;\n+\n+    private boolean sawLeadingHeaders;\n+\n+    @Nullable\n+    private volatile EventExecutor eventLoop;\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean cancelled;\n+    private volatile int initialized;\n+    private volatile int subscribed;\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc) {\n+        this(handler, alloc, HttpData::byteBuf);\n+    }\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler},\n+     * {@link ByteBufAllocator} and {@code byteBufConverter}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc,\n+                        Function<? super HttpData, ? extends ByteBuf> byteBufConverter) {\n+        this.handler = requireNonNull(handler, \"handler\");\n+        input = new ByteBufDeframerInput(requireNonNull(alloc, \"alloc\"));\n+        this.byteBufConverter = requireNonNull(byteBufConverter, \"byteBufConverter\");\n+    }\n+\n+    private void process(HttpObject data) throws Exception {\n+        if (data instanceof HttpHeaders) {\n+            final HttpHeaders headers = (HttpHeaders) data;\n+\n+            if (headers instanceof ResponseHeaders) {\n+                final ResponseHeaders responseHeaders = (ResponseHeaders) headers;\n+                if (responseHeaders.status().isInformational()) {\n+                    handler.processInformationalHeaders(responseHeaders, this::write);\n+                    return;\n+                }\n+            }\n+\n+            if (!sawLeadingHeaders) {\n+                sawLeadingHeaders = true;\n+                handler.processHeaders((HttpHeaders) data, this::write);\n+            } else {\n+                handler.processTrailers((HttpHeaders) data, this::write);\n+            }\n+            return;\n+        }\n+\n+        if (data instanceof HttpData) {\n+            final ByteBuf byteBuf = byteBufConverter.apply((HttpData) data);\n+            requireNonNull(byteBuf, \"byteBufConverter.apply() returned null\");\n+            input.add(byteBuf);\n+            handler.process(input, this::write);\n+        }\n+    }\n+\n+    @Override\n+    SubscriptionImpl subscribe(SubscriptionImpl subscription) {\n+        final SubscriptionImpl subscriptionImpl = super.subscribe(subscription);\n+        if (subscribedUpdater.compareAndSet(this, 0, 1)) {", "originalCommit": "c8f7d5fca29d52c767d4082c47a856bbe28ce975", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDcwNzI5OA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r514707298", "bodyText": "That sounds good.", "author": "ikhoon", "createdAt": "2020-10-30T02:12:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg4MjY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg4Mzk1Nw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r513883957", "bodyText": "then we might do:\nif (upstream != null && eventLoop != null) {...}", "author": "minwoox", "createdAt": "2020-10-29T02:20:12Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ *\n+ * <p>Follow the below steps to deframe HTTP payload using {@link HttpDeframer}.\n+ * <ol>\n+ *   <li>Implement your deframing logic in {@link HttpDeframerHandler}.\n+ *       <pre>{@code\n+ *       > class FixedLengthDecoder implements HttpDeframerHandler<String> {\n+ *       >     private final int length;\n+ *\n+ *       >     FixedLengthDecoder(int length) {\n+ *       >         this.length = length;\n+ *       >     }\n+ *\n+ *       >     @Override\n+ *       >     public void process(HttpDeframerInput in, HttpDeframerOutput<String> out) {\n+ *       >         int remaining = in.readableBytes();\n+ *       >         if (remaining < length) {\n+ *       >             // The input is not enough to process. Waiting for more data.\n+ *       >             return;\n+ *       >         }\n+ *\n+ *       >         do {\n+ *       >             // Read data from 'HttpDeframerInput' and\n+ *       >             // write the processed result to 'HttpDeframerOutput'.\n+ *       >             ByteBuf buf = in.readBytes(length);\n+ *       >             out.add(buf.toString(StandardCharsets.UTF_8));\n+ *       >             // Should release the returned 'ByteBuf'\n+ *       >             buf.release();\n+ *       >             remaining -= length;\n+ *       >         } while (remaining >= length);\n+ *       >     }\n+ *       > }\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Create an {@link HttpDeframer} with the {@link HttpDeframerHandler} instance.\n+ *       <pre>{@code\n+ *       FixedLengthDecoder decoder = new FixedLengthDecoder(11);\n+ *       HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to a {@link HttpRequest} using the {@link HttpDeframer}.\n+ *       <pre>{@code\n+ *       HttpRequest request = ...;\n+ *       request.subscribe(deframer);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to the {@link Publisher} of the deframed data and connect to your business logic.\n+ *       <pre>{@code\n+ *       import reactor.core.publisher.Flux;\n+ *       Flux.from(deframer).map(...); // Consume and manipulate the deframed data.\n+ *       }</pre>\n+ *   </li>\n+ * </ol>\n+ */\n+@UnstableApi\n+public final class HttpDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpObject, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"subscribed\");\n+\n+    private final HttpDeframerHandler<T> handler;\n+    private final ByteBufDeframerInput input;\n+    private final Function<? super HttpData, ? extends ByteBuf> byteBufConverter;\n+\n+    private boolean sawLeadingHeaders;\n+\n+    @Nullable\n+    private volatile EventExecutor eventLoop;\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean cancelled;\n+    private volatile int initialized;\n+    private volatile int subscribed;\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc) {\n+        this(handler, alloc, HttpData::byteBuf);\n+    }\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler},\n+     * {@link ByteBufAllocator} and {@code byteBufConverter}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc,\n+                        Function<? super HttpData, ? extends ByteBuf> byteBufConverter) {\n+        this.handler = requireNonNull(handler, \"handler\");\n+        input = new ByteBufDeframerInput(requireNonNull(alloc, \"alloc\"));\n+        this.byteBufConverter = requireNonNull(byteBufConverter, \"byteBufConverter\");\n+    }\n+\n+    private void process(HttpObject data) throws Exception {\n+        if (data instanceof HttpHeaders) {\n+            final HttpHeaders headers = (HttpHeaders) data;\n+\n+            if (headers instanceof ResponseHeaders) {\n+                final ResponseHeaders responseHeaders = (ResponseHeaders) headers;\n+                if (responseHeaders.status().isInformational()) {\n+                    handler.processInformationalHeaders(responseHeaders, this::write);\n+                    return;\n+                }\n+            }\n+\n+            if (!sawLeadingHeaders) {\n+                sawLeadingHeaders = true;\n+                handler.processHeaders((HttpHeaders) data, this::write);\n+            } else {\n+                handler.processTrailers((HttpHeaders) data, this::write);\n+            }\n+            return;\n+        }\n+\n+        if (data instanceof HttpData) {\n+            final ByteBuf byteBuf = byteBufConverter.apply((HttpData) data);\n+            requireNonNull(byteBuf, \"byteBufConverter.apply() returned null\");\n+            input.add(byteBuf);\n+            handler.process(input, this::write);\n+        }\n+    }\n+\n+    @Override\n+    SubscriptionImpl subscribe(SubscriptionImpl subscription) {\n+        final SubscriptionImpl subscriptionImpl = super.subscribe(subscription);\n+        if (subscribedUpdater.compareAndSet(this, 0, 1)) {\n+            eventLoop = subscription.executor();\n+            deferredInit();\n+        }\n+        return subscriptionImpl;\n+    }\n+\n+    private void deferredInit() {\n+        final Subscription upstream = this.upstream;\n+        if (upstream != null && subscribed != 0) {", "originalCommit": "c8f7d5fca29d52c767d4082c47a856bbe28ce975", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg5MTg3Nw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r513891877", "bodyText": "Shouldn't we do this at the end of this block?", "author": "minwoox", "createdAt": "2020-10-29T02:37:32Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ *\n+ * <p>Follow the below steps to deframe HTTP payload using {@link HttpDeframer}.\n+ * <ol>\n+ *   <li>Implement your deframing logic in {@link HttpDeframerHandler}.\n+ *       <pre>{@code\n+ *       > class FixedLengthDecoder implements HttpDeframerHandler<String> {\n+ *       >     private final int length;\n+ *\n+ *       >     FixedLengthDecoder(int length) {\n+ *       >         this.length = length;\n+ *       >     }\n+ *\n+ *       >     @Override\n+ *       >     public void process(HttpDeframerInput in, HttpDeframerOutput<String> out) {\n+ *       >         int remaining = in.readableBytes();\n+ *       >         if (remaining < length) {\n+ *       >             // The input is not enough to process. Waiting for more data.\n+ *       >             return;\n+ *       >         }\n+ *\n+ *       >         do {\n+ *       >             // Read data from 'HttpDeframerInput' and\n+ *       >             // write the processed result to 'HttpDeframerOutput'.\n+ *       >             ByteBuf buf = in.readBytes(length);\n+ *       >             out.add(buf.toString(StandardCharsets.UTF_8));\n+ *       >             // Should release the returned 'ByteBuf'\n+ *       >             buf.release();\n+ *       >             remaining -= length;\n+ *       >         } while (remaining >= length);\n+ *       >     }\n+ *       > }\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Create an {@link HttpDeframer} with the {@link HttpDeframerHandler} instance.\n+ *       <pre>{@code\n+ *       FixedLengthDecoder decoder = new FixedLengthDecoder(11);\n+ *       HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to a {@link HttpRequest} using the {@link HttpDeframer}.\n+ *       <pre>{@code\n+ *       HttpRequest request = ...;\n+ *       request.subscribe(deframer);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to the {@link Publisher} of the deframed data and connect to your business logic.\n+ *       <pre>{@code\n+ *       import reactor.core.publisher.Flux;\n+ *       Flux.from(deframer).map(...); // Consume and manipulate the deframed data.\n+ *       }</pre>\n+ *   </li>\n+ * </ol>\n+ */\n+@UnstableApi\n+public final class HttpDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpObject, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"subscribed\");\n+\n+    private final HttpDeframerHandler<T> handler;\n+    private final ByteBufDeframerInput input;\n+    private final Function<? super HttpData, ? extends ByteBuf> byteBufConverter;\n+\n+    private boolean sawLeadingHeaders;\n+\n+    @Nullable\n+    private volatile EventExecutor eventLoop;\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean cancelled;\n+    private volatile int initialized;\n+    private volatile int subscribed;\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc) {\n+        this(handler, alloc, HttpData::byteBuf);\n+    }\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler},\n+     * {@link ByteBufAllocator} and {@code byteBufConverter}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc,\n+                        Function<? super HttpData, ? extends ByteBuf> byteBufConverter) {\n+        this.handler = requireNonNull(handler, \"handler\");\n+        input = new ByteBufDeframerInput(requireNonNull(alloc, \"alloc\"));\n+        this.byteBufConverter = requireNonNull(byteBufConverter, \"byteBufConverter\");\n+    }\n+\n+    private void process(HttpObject data) throws Exception {\n+        if (data instanceof HttpHeaders) {\n+            final HttpHeaders headers = (HttpHeaders) data;\n+\n+            if (headers instanceof ResponseHeaders) {\n+                final ResponseHeaders responseHeaders = (ResponseHeaders) headers;\n+                if (responseHeaders.status().isInformational()) {\n+                    handler.processInformationalHeaders(responseHeaders, this::write);\n+                    return;\n+                }\n+            }\n+\n+            if (!sawLeadingHeaders) {\n+                sawLeadingHeaders = true;\n+                handler.processHeaders((HttpHeaders) data, this::write);\n+            } else {\n+                handler.processTrailers((HttpHeaders) data, this::write);\n+            }\n+            return;\n+        }\n+\n+        if (data instanceof HttpData) {\n+            final ByteBuf byteBuf = byteBufConverter.apply((HttpData) data);\n+            requireNonNull(byteBuf, \"byteBufConverter.apply() returned null\");\n+            input.add(byteBuf);\n+            handler.process(input, this::write);\n+        }\n+    }\n+\n+    @Override\n+    SubscriptionImpl subscribe(SubscriptionImpl subscription) {\n+        final SubscriptionImpl subscriptionImpl = super.subscribe(subscription);\n+        if (subscribedUpdater.compareAndSet(this, 0, 1)) {\n+            eventLoop = subscription.executor();\n+            deferredInit();\n+        }\n+        return subscriptionImpl;\n+    }\n+\n+    private void deferredInit() {\n+        final Subscription upstream = this.upstream;\n+        if (upstream != null && subscribed != 0) {\n+            if (initializedUpdater.compareAndSet(this, 0, 1)) {\n+                if (demand() > 0) {\n+                    upstream.request(1);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    void request(long n) {\n+        if (initialized != 0 && demand() == 0) {\n+            upstream.request(1);\n+        }\n+        super.request(n);\n+    }\n+\n+    @Override\n+    void cancel() {\n+        cancelAndCleanup();\n+        super.cancel();\n+    }\n+\n+    @Override\n+    public void onSubscribe(Subscription subscription) {\n+        requireNonNull(subscription, \"subscription\");\n+        if (upstreamUpdater.compareAndSet(this, null, subscription)) {\n+            deferredInit();\n+        } else {\n+            subscription.cancel();\n+        }\n+    }\n+\n+    @Override\n+    public void onNext(HttpObject data) {\n+        final EventExecutor eventLoop = this.eventLoop;\n+        if (eventLoop.inEventLoop()) {\n+            onNext0(data);\n+        } else {\n+            eventLoop.execute(() -> onNext0(data));\n+        }\n+    }\n+\n+    private void onNext0(HttpObject data) {\n+        try {\n+            process(data);\n+\n+            whenConsumed().thenRun(() -> {\n+                if (demand() > 0) {\n+                    upstream.request(1);\n+                }\n+            });\n+        } catch (Throwable ex) {\n+            Exceptions.throwIfFatal(ex);", "originalCommit": "c8f7d5fca29d52c767d4082c47a856bbe28ce975", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg5MjgxMg==", "url": "https://github.com/line/armeria/pull/2981#discussion_r513892812", "bodyText": "onError can be called before downstream subscribes which means eventLoop is null, right?", "author": "minwoox", "createdAt": "2020-10-29T02:39:13Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ *\n+ * <p>Follow the below steps to deframe HTTP payload using {@link HttpDeframer}.\n+ * <ol>\n+ *   <li>Implement your deframing logic in {@link HttpDeframerHandler}.\n+ *       <pre>{@code\n+ *       > class FixedLengthDecoder implements HttpDeframerHandler<String> {\n+ *       >     private final int length;\n+ *\n+ *       >     FixedLengthDecoder(int length) {\n+ *       >         this.length = length;\n+ *       >     }\n+ *\n+ *       >     @Override\n+ *       >     public void process(HttpDeframerInput in, HttpDeframerOutput<String> out) {\n+ *       >         int remaining = in.readableBytes();\n+ *       >         if (remaining < length) {\n+ *       >             // The input is not enough to process. Waiting for more data.\n+ *       >             return;\n+ *       >         }\n+ *\n+ *       >         do {\n+ *       >             // Read data from 'HttpDeframerInput' and\n+ *       >             // write the processed result to 'HttpDeframerOutput'.\n+ *       >             ByteBuf buf = in.readBytes(length);\n+ *       >             out.add(buf.toString(StandardCharsets.UTF_8));\n+ *       >             // Should release the returned 'ByteBuf'\n+ *       >             buf.release();\n+ *       >             remaining -= length;\n+ *       >         } while (remaining >= length);\n+ *       >     }\n+ *       > }\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Create an {@link HttpDeframer} with the {@link HttpDeframerHandler} instance.\n+ *       <pre>{@code\n+ *       FixedLengthDecoder decoder = new FixedLengthDecoder(11);\n+ *       HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to a {@link HttpRequest} using the {@link HttpDeframer}.\n+ *       <pre>{@code\n+ *       HttpRequest request = ...;\n+ *       request.subscribe(deframer);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to the {@link Publisher} of the deframed data and connect to your business logic.\n+ *       <pre>{@code\n+ *       import reactor.core.publisher.Flux;\n+ *       Flux.from(deframer).map(...); // Consume and manipulate the deframed data.\n+ *       }</pre>\n+ *   </li>\n+ * </ol>\n+ */\n+@UnstableApi\n+public final class HttpDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpObject, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"subscribed\");\n+\n+    private final HttpDeframerHandler<T> handler;\n+    private final ByteBufDeframerInput input;\n+    private final Function<? super HttpData, ? extends ByteBuf> byteBufConverter;\n+\n+    private boolean sawLeadingHeaders;\n+\n+    @Nullable\n+    private volatile EventExecutor eventLoop;\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean cancelled;\n+    private volatile int initialized;\n+    private volatile int subscribed;\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc) {\n+        this(handler, alloc, HttpData::byteBuf);\n+    }\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler},\n+     * {@link ByteBufAllocator} and {@code byteBufConverter}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc,\n+                        Function<? super HttpData, ? extends ByteBuf> byteBufConverter) {\n+        this.handler = requireNonNull(handler, \"handler\");\n+        input = new ByteBufDeframerInput(requireNonNull(alloc, \"alloc\"));\n+        this.byteBufConverter = requireNonNull(byteBufConverter, \"byteBufConverter\");\n+    }\n+\n+    private void process(HttpObject data) throws Exception {\n+        if (data instanceof HttpHeaders) {\n+            final HttpHeaders headers = (HttpHeaders) data;\n+\n+            if (headers instanceof ResponseHeaders) {\n+                final ResponseHeaders responseHeaders = (ResponseHeaders) headers;\n+                if (responseHeaders.status().isInformational()) {\n+                    handler.processInformationalHeaders(responseHeaders, this::write);\n+                    return;\n+                }\n+            }\n+\n+            if (!sawLeadingHeaders) {\n+                sawLeadingHeaders = true;\n+                handler.processHeaders((HttpHeaders) data, this::write);\n+            } else {\n+                handler.processTrailers((HttpHeaders) data, this::write);\n+            }\n+            return;\n+        }\n+\n+        if (data instanceof HttpData) {\n+            final ByteBuf byteBuf = byteBufConverter.apply((HttpData) data);\n+            requireNonNull(byteBuf, \"byteBufConverter.apply() returned null\");\n+            input.add(byteBuf);\n+            handler.process(input, this::write);\n+        }\n+    }\n+\n+    @Override\n+    SubscriptionImpl subscribe(SubscriptionImpl subscription) {\n+        final SubscriptionImpl subscriptionImpl = super.subscribe(subscription);\n+        if (subscribedUpdater.compareAndSet(this, 0, 1)) {\n+            eventLoop = subscription.executor();\n+            deferredInit();\n+        }\n+        return subscriptionImpl;\n+    }\n+\n+    private void deferredInit() {\n+        final Subscription upstream = this.upstream;\n+        if (upstream != null && subscribed != 0) {\n+            if (initializedUpdater.compareAndSet(this, 0, 1)) {\n+                if (demand() > 0) {\n+                    upstream.request(1);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    void request(long n) {\n+        if (initialized != 0 && demand() == 0) {\n+            upstream.request(1);\n+        }\n+        super.request(n);\n+    }\n+\n+    @Override\n+    void cancel() {\n+        cancelAndCleanup();\n+        super.cancel();\n+    }\n+\n+    @Override\n+    public void onSubscribe(Subscription subscription) {\n+        requireNonNull(subscription, \"subscription\");\n+        if (upstreamUpdater.compareAndSet(this, null, subscription)) {\n+            deferredInit();\n+        } else {\n+            subscription.cancel();\n+        }\n+    }\n+\n+    @Override\n+    public void onNext(HttpObject data) {\n+        final EventExecutor eventLoop = this.eventLoop;\n+        if (eventLoop.inEventLoop()) {\n+            onNext0(data);\n+        } else {\n+            eventLoop.execute(() -> onNext0(data));\n+        }\n+    }\n+\n+    private void onNext0(HttpObject data) {\n+        try {\n+            process(data);\n+\n+            whenConsumed().thenRun(() -> {\n+                if (demand() > 0) {\n+                    upstream.request(1);\n+                }\n+            });\n+        } catch (Throwable ex) {\n+            Exceptions.throwIfFatal(ex);\n+            handler.processOnError(ex);\n+            cancelAndCleanup();\n+            abort(ex);\n+        }\n+    }\n+\n+    private void cancelAndCleanup() {\n+        cancelled = true;\n+        final Subscription upstream = this.upstream;\n+        if (upstream != null) {\n+            upstream.cancel();\n+        }\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void onError(Throwable cause) {\n+        requireNonNull(cause, \"cause\");\n+        if (cancelled) {\n+            return;\n+        }\n+        final EventExecutor eventLoop = this.eventLoop;\n+        if (!eventLoop.inEventLoop()) {", "originalCommit": "c8f7d5fca29d52c767d4082c47a856bbe28ce975", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDcyNTgyOA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r514725828", "bodyText": "Oh, that's a good point. Let me check null for eventLoop.", "author": "ikhoon", "createdAt": "2020-10-30T02:32:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg5MjgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg5MzAzNA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r513893034", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-10-29T02:39:35Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ *\n+ * <p>Follow the below steps to deframe HTTP payload using {@link HttpDeframer}.\n+ * <ol>\n+ *   <li>Implement your deframing logic in {@link HttpDeframerHandler}.\n+ *       <pre>{@code\n+ *       > class FixedLengthDecoder implements HttpDeframerHandler<String> {\n+ *       >     private final int length;\n+ *\n+ *       >     FixedLengthDecoder(int length) {\n+ *       >         this.length = length;\n+ *       >     }\n+ *\n+ *       >     @Override\n+ *       >     public void process(HttpDeframerInput in, HttpDeframerOutput<String> out) {\n+ *       >         int remaining = in.readableBytes();\n+ *       >         if (remaining < length) {\n+ *       >             // The input is not enough to process. Waiting for more data.\n+ *       >             return;\n+ *       >         }\n+ *\n+ *       >         do {\n+ *       >             // Read data from 'HttpDeframerInput' and\n+ *       >             // write the processed result to 'HttpDeframerOutput'.\n+ *       >             ByteBuf buf = in.readBytes(length);\n+ *       >             out.add(buf.toString(StandardCharsets.UTF_8));\n+ *       >             // Should release the returned 'ByteBuf'\n+ *       >             buf.release();\n+ *       >             remaining -= length;\n+ *       >         } while (remaining >= length);\n+ *       >     }\n+ *       > }\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Create an {@link HttpDeframer} with the {@link HttpDeframerHandler} instance.\n+ *       <pre>{@code\n+ *       FixedLengthDecoder decoder = new FixedLengthDecoder(11);\n+ *       HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to a {@link HttpRequest} using the {@link HttpDeframer}.\n+ *       <pre>{@code\n+ *       HttpRequest request = ...;\n+ *       request.subscribe(deframer);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to the {@link Publisher} of the deframed data and connect to your business logic.\n+ *       <pre>{@code\n+ *       import reactor.core.publisher.Flux;\n+ *       Flux.from(deframer).map(...); // Consume and manipulate the deframed data.\n+ *       }</pre>\n+ *   </li>\n+ * </ol>\n+ */\n+@UnstableApi\n+public final class HttpDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpObject, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"subscribed\");\n+\n+    private final HttpDeframerHandler<T> handler;\n+    private final ByteBufDeframerInput input;\n+    private final Function<? super HttpData, ? extends ByteBuf> byteBufConverter;\n+\n+    private boolean sawLeadingHeaders;\n+\n+    @Nullable\n+    private volatile EventExecutor eventLoop;\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean cancelled;\n+    private volatile int initialized;\n+    private volatile int subscribed;\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc) {\n+        this(handler, alloc, HttpData::byteBuf);\n+    }\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler},\n+     * {@link ByteBufAllocator} and {@code byteBufConverter}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc,\n+                        Function<? super HttpData, ? extends ByteBuf> byteBufConverter) {\n+        this.handler = requireNonNull(handler, \"handler\");\n+        input = new ByteBufDeframerInput(requireNonNull(alloc, \"alloc\"));\n+        this.byteBufConverter = requireNonNull(byteBufConverter, \"byteBufConverter\");\n+    }\n+\n+    private void process(HttpObject data) throws Exception {\n+        if (data instanceof HttpHeaders) {\n+            final HttpHeaders headers = (HttpHeaders) data;\n+\n+            if (headers instanceof ResponseHeaders) {\n+                final ResponseHeaders responseHeaders = (ResponseHeaders) headers;\n+                if (responseHeaders.status().isInformational()) {\n+                    handler.processInformationalHeaders(responseHeaders, this::write);\n+                    return;\n+                }\n+            }\n+\n+            if (!sawLeadingHeaders) {\n+                sawLeadingHeaders = true;\n+                handler.processHeaders((HttpHeaders) data, this::write);\n+            } else {\n+                handler.processTrailers((HttpHeaders) data, this::write);\n+            }\n+            return;\n+        }\n+\n+        if (data instanceof HttpData) {\n+            final ByteBuf byteBuf = byteBufConverter.apply((HttpData) data);\n+            requireNonNull(byteBuf, \"byteBufConverter.apply() returned null\");\n+            input.add(byteBuf);\n+            handler.process(input, this::write);\n+        }\n+    }\n+\n+    @Override\n+    SubscriptionImpl subscribe(SubscriptionImpl subscription) {\n+        final SubscriptionImpl subscriptionImpl = super.subscribe(subscription);\n+        if (subscribedUpdater.compareAndSet(this, 0, 1)) {\n+            eventLoop = subscription.executor();\n+            deferredInit();\n+        }\n+        return subscriptionImpl;\n+    }\n+\n+    private void deferredInit() {\n+        final Subscription upstream = this.upstream;\n+        if (upstream != null && subscribed != 0) {\n+            if (initializedUpdater.compareAndSet(this, 0, 1)) {\n+                if (demand() > 0) {\n+                    upstream.request(1);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    void request(long n) {\n+        if (initialized != 0 && demand() == 0) {\n+            upstream.request(1);\n+        }\n+        super.request(n);\n+    }\n+\n+    @Override\n+    void cancel() {\n+        cancelAndCleanup();\n+        super.cancel();\n+    }\n+\n+    @Override\n+    public void onSubscribe(Subscription subscription) {\n+        requireNonNull(subscription, \"subscription\");\n+        if (upstreamUpdater.compareAndSet(this, null, subscription)) {\n+            deferredInit();\n+        } else {\n+            subscription.cancel();\n+        }\n+    }\n+\n+    @Override\n+    public void onNext(HttpObject data) {\n+        final EventExecutor eventLoop = this.eventLoop;\n+        if (eventLoop.inEventLoop()) {\n+            onNext0(data);\n+        } else {\n+            eventLoop.execute(() -> onNext0(data));\n+        }\n+    }\n+\n+    private void onNext0(HttpObject data) {\n+        try {\n+            process(data);\n+\n+            whenConsumed().thenRun(() -> {\n+                if (demand() > 0) {\n+                    upstream.request(1);\n+                }\n+            });\n+        } catch (Throwable ex) {\n+            Exceptions.throwIfFatal(ex);\n+            handler.processOnError(ex);\n+            cancelAndCleanup();\n+            abort(ex);\n+        }\n+    }\n+\n+    private void cancelAndCleanup() {\n+        cancelled = true;\n+        final Subscription upstream = this.upstream;\n+        if (upstream != null) {\n+            upstream.cancel();\n+        }\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void onError(Throwable cause) {\n+        requireNonNull(cause, \"cause\");\n+        if (cancelled) {\n+            return;\n+        }\n+        final EventExecutor eventLoop = this.eventLoop;\n+        if (!eventLoop.inEventLoop()) {\n+            eventLoop.execute(() -> onError(cause));\n+            return;\n+        }\n+\n+        if (!(cause instanceof AbortedStreamException)) {\n+            handler.processOnError(cause);\n+        }\n+\n+        abort(cause);\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        if (cancelled) {\n+            return;\n+        }\n+\n+        final EventExecutor eventLoop = this.eventLoop;\n+        if (!eventLoop.inEventLoop()) {", "originalCommit": "c8f7d5fca29d52c767d4082c47a856bbe28ce975", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg5MzkwOA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r513893908", "bodyText": "a non?", "author": "minwoox", "createdAt": "2020-10-29T02:41:08Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframerHandler.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import org.reactivestreams.Publisher;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+\n+/**\n+ * An {@link HttpDeframerHandler} that decodes a stream of {@link HttpObject}s to N objects.\n+ *\n+ * @param <T> the result type of being deframed\n+ */\n+public interface HttpDeframerHandler<T> {\n+\n+    /**\n+     * Decodes a stream of {@link HttpData}s to N objects.\n+     * This method will be called whenever an {@link HttpData} is signaled from {@link Publisher}.\n+     */\n+    void process(HttpDeframerInput in, HttpDeframerOutput<T> out) throws Exception;\n+\n+    /**\n+     * Decodes an informational {@link ResponseHeaders} to N objects.\n+     */\n+    default void processInformationalHeaders(ResponseHeaders in, HttpDeframerOutput<T> out) throws Exception {}\n+\n+    /**\n+     * Decodes an non-informational {@link HttpHeaders} to N objects.", "originalCommit": "c8f7d5fca29d52c767d4082c47a856bbe28ce975", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg5OTMxMw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r513899313", "bodyText": "Perhaps, it's time to make this DeframedMessage a standalone class because it's also used a lot in other classes?", "author": "minwoox", "createdAt": "2020-10-29T02:51:49Z", "path": "grpc-protocol/src/main/java/com/linecorp/armeria/common/grpc/protocol/ArmeriaMessageDeframerHandler.java", "diffHunk": "@@ -83,24 +79,128 @@\n  * a {@link ByteBuf} to optimize message parsing.\n  */\n @UnstableApi\n-public class ArmeriaMessageDeframer implements AutoCloseable {\n+public class ArmeriaMessageDeframerHandler implements HttpDeframerHandler<DeframedMessage> {\n \n     public static final int NO_MAX_INBOUND_MESSAGE_SIZE = -1;\n \n-    private static final CloseFuture CLOSED_FUTURE;\n-\n-    static {\n-        CLOSED_FUTURE = new CloseFuture();\n-        CLOSED_FUTURE.doComplete();\n-    }\n-\n-    private static final String DEBUG_STRING = ArmeriaMessageDeframer.class.getName();\n+    private static final String DEBUG_STRING = ArmeriaMessageDeframerHandler.class.getName();\n \n     private static final int HEADER_LENGTH = 5;\n     private static final int COMPRESSED_FLAG_MASK = 1;\n     private static final int RESERVED_MASK = 0x7E;\n     // Valid type is always positive.\n-    private static final int UNINITIALIED_TYPE = -1;\n+    private static final int UNINITIALIZED_TYPE = -1;\n+\n+    private final int maxMessageSizeBytes;\n+\n+    private int currentType = UNINITIALIZED_TYPE;\n+    private int requiredLength = HEADER_LENGTH;\n+    private boolean startedDeframing;\n+\n+    @Nullable\n+    private Decompressor decompressor;\n+\n+    /**\n+     * Construct an {@link ArmeriaMessageDeframerHandler} for reading messages out of a gRPC request or\n+     * response.\n+     */\n+    public ArmeriaMessageDeframerHandler(int maxMessageSizeBytes) {\n+        this.maxMessageSizeBytes = maxMessageSizeBytes > 0 ? maxMessageSizeBytes : Integer.MAX_VALUE;\n+    }\n+\n+    @Override\n+    public void process(HttpDeframerInput in, HttpDeframerOutput<DeframedMessage> out) throws Exception {\n+        startedDeframing = true;\n+        int readableBytes = in.readableBytes();\n+        while (readableBytes >= requiredLength) {\n+            final int length = requiredLength;\n+            if (currentType == UNINITIALIZED_TYPE) {\n+                readHeader(in);\n+            } else {\n+                out.add(readBody(in));\n+            }\n+            readableBytes -= length;\n+        }\n+    }\n+\n+    /**\n+     * Processes the gRPC compression header which is composed of the compression flag and the outer\n+     * frame length.\n+     */\n+    private void readHeader(HttpDeframerInput in) {\n+        final int type = in.readUnsignedByte();\n+        if ((type & RESERVED_MASK) != 0) {\n+            throw new ArmeriaStatusException(\n+                    StatusCodes.INTERNAL,\n+                    DEBUG_STRING + \": Frame header malformed: reserved bits not zero\");\n+        }\n+\n+        // Update the required length to include the length of the frame.\n+        requiredLength = in.readInt();\n+        if (requiredLength < 0 || requiredLength > maxMessageSizeBytes) {\n+            throw new ArmeriaStatusException(\n+                    StatusCodes.RESOURCE_EXHAUSTED,\n+                    String.format(\"%s: Frame size %d exceeds maximum: %d. \",\n+                                  DEBUG_STRING, requiredLength,\n+                                  maxMessageSizeBytes));\n+        }\n+\n+        // Store type and continue reading the frame body.\n+        currentType = type;\n+    }\n+\n+    /**\n+     * Processes the body of the gRPC compression frame. A single compression frame may contain\n+     * several gRPC messages within it.\n+     */\n+    private DeframedMessage readBody(HttpDeframerInput in) {\n+        final ByteBuf buf;\n+        if (requiredLength == 0) {\n+            buf = Unpooled.EMPTY_BUFFER;\n+        } else {\n+            buf = in.readBytes(requiredLength);\n+        }\n+        final boolean isCompressed = (currentType & COMPRESSED_FLAG_MASK) != 0;\n+        final DeframedMessage msg = isCompressed ? getCompressedBody(buf) : getUncompressedBody(buf);\n+        // Done with this frame, begin processing the next header.\n+        currentType = UNINITIALIZED_TYPE;\n+        requiredLength = HEADER_LENGTH;\n+        return msg;\n+    }\n+\n+    private DeframedMessage getUncompressedBody(ByteBuf buf) {\n+        return new DeframedMessage(buf, currentType);\n+    }\n+\n+    private DeframedMessage getCompressedBody(ByteBuf buf) {\n+        if (decompressor == null) {\n+            buf.release();\n+            throw new ArmeriaStatusException(\n+                    StatusCodes.INTERNAL,\n+                    DEBUG_STRING + \": Can't decode compressed frame as compression not configured.\");\n+        }\n+\n+        try {\n+            // Enforce the maxMessageSizeBytes limit on the returned stream.\n+            final InputStream unlimitedStream =\n+                    decompressor.decompress(new ByteBufInputStream(buf, true));\n+            return new DeframedMessage(\n+                    new SizeEnforcingInputStream(unlimitedStream, maxMessageSizeBytes, DEBUG_STRING),\n+                    currentType);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * Sets the {@link Decompressor} for this deframer.\n+     */\n+    public ArmeriaMessageDeframerHandler decompressor(@Nullable Decompressor decompressor) {\n+        checkState(!startedDeframing,\n+                   \"Deframing has already started, cannot change decompressor mid-stream.\");\n+        this.decompressor = decompressor;\n+        return this;\n+    }\n \n     /**\n      * A deframed message. For uncompressed messages, we have the entire buffer available and return it", "originalCommit": "c8f7d5fca29d52c767d4082c47a856bbe28ce975", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkwODY1Mg==", "url": "https://github.com/line/armeria/pull/2981#discussion_r513908652", "bodyText": "If we set withEndOfStream to the body, trailers will not be sent.", "author": "minwoox", "createdAt": "2020-10-29T03:12:19Z", "path": "grpc-protocol/src/main/java/com/linecorp/armeria/client/grpc/protocol/UnaryGrpcClient.java", "diffHunk": "@@ -159,32 +162,48 @@ public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) {\n \n                            final CompletableFuture<HttpResponse> responseFuture = new CompletableFuture<>();\n \n-                           try (ArmeriaMessageDeframer deframer = new ArmeriaMessageDeframer(new Listener() {\n-                               @Override\n-                               public void messageRead(DeframedMessage unframed) {\n-                                   final ByteBuf buf = unframed.buf();\n-                                   // Compression not supported.\n-                                   assert buf != null;\n-                                   responseFuture.complete(HttpResponse.of(\n-                                           msg.headers(),\n-                                           HttpData.wrap(buf).withEndOfStream(),\n-                                           msg.trailers()));\n-                               }\n-\n-                               @Override\n-                               public void endOfStream() {\n-                                   if (!responseFuture.isDone()) {\n-                                       responseFuture.complete(HttpResponse.of(msg.headers(),\n-                                                                               HttpData.empty(),\n-                                                                               msg.trailers()));\n-                                   }\n-                               }\n-                           }, Integer.MAX_VALUE, ctx.alloc(), false)) {\n-                               deframer.request(1);\n-                               deframer.deframe(msg.content(), true);\n-                           }\n+                           final ArmeriaMessageDeframerHandler handler =\n+                                   new ArmeriaMessageDeframerHandler(Integer.MAX_VALUE);\n+                           final HttpDeframer<DeframedMessage> deframer =\n+                                   new HttpDeframer<>(handler, ctx.alloc());\n+\n+                           StreamMessage.of(msg.content()).subscribe(deframer, ctx.eventLoop());\n+                           deframer.subscribe(singleSubscriber(msg, responseFuture), ctx.eventLoop());\n                            return responseFuture;\n                        }), ctx.eventLoop());\n         }\n+\n+        private static Subscriber<DeframedMessage> singleSubscriber(\n+                AggregatedHttpResponse msg, CompletableFuture<HttpResponse> responseFuture) {\n+\n+            return new Subscriber<DeframedMessage>() {\n+                @Override\n+                public void onSubscribe(Subscription s) {\n+                    s.request(1);\n+                }\n+\n+                @Override\n+                public void onNext(DeframedMessage unframed) {\n+                    final ByteBuf buf = unframed.buf();\n+                    // Compression not supported.\n+                    assert buf != null;\n+                    responseFuture.complete(HttpResponse.of(msg.headers(), HttpData.wrap(buf).withEndOfStream(),\n+                                                            msg.trailers()));", "originalCommit": "c8f7d5fca29d52c767d4082c47a856bbe28ce975", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDc1OTg3NA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r514759874", "bodyText": "I see. Let me add a test case and fix it.", "author": "ikhoon", "createdAt": "2020-10-30T03:08:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkwODY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk0MDM3Nw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r514940377", "bodyText": "This is an HttpResponse so I guess trailers will be delivered to a client even if withEndOfStream is set. However, I agree that it is better to remove withEndOfStream to avoid an additional allocation.", "author": "ikhoon", "createdAt": "2020-10-30T08:33:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkwODY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA3MDY2OQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r515070669", "bodyText": "https://github.com/line/armeria/blob/master/core/src/main/java/com/linecorp/armeria/server/HttpResponseSubscriber.java#L213\nDoesn't this line call subscription.cancel() so the trailers is not sent?", "author": "minwoox", "createdAt": "2020-10-30T12:43:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkwODY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA3MTMxNA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r515071314", "bodyText": "Ah, this is the client-side. \ud83d\ude05", "author": "minwoox", "createdAt": "2020-10-30T12:44:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkwODY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkyMTQzOA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r513921438", "bodyText": "How about just calling close?", "author": "minwoox", "createdAt": "2020-10-29T03:33:57Z", "path": "grpc/src/main/java/com/linecorp/armeria/internal/client/grpc/ArmeriaClientCall.java", "diffHunk": "@@ -420,7 +456,9 @@ private void close(Status status, Metadata metadata) {\n         } else {\n             req.abort(status.asRuntimeException(metadata));\n         }\n-        responseReader.cancel();\n+        if (responseReader != null) {\n+            responseReader.abort();", "originalCommit": "c8f7d5fca29d52c767d4082c47a856bbe28ce975", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkyMTg1OA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r513921858", "bodyText": "question: where is this logic moved?", "author": "minwoox", "createdAt": "2020-10-29T03:34:36Z", "path": "grpc/src/main/java/com/linecorp/armeria/internal/client/grpc/ArmeriaClientCall.java", "diffHunk": "@@ -195,16 +204,9 @@ public void start(Listener<O> responseListener, Metadata metadata) {\n                 close(status, new Metadata());\n             } else {\n                 ctx.setResponseTimeout(TimeoutMode.SET_FROM_NOW, Duration.ofNanos(remainingNanos));\n-                ctx.whenResponseCancelling().thenAccept(cause -> {", "originalCommit": "c8f7d5fca29d52c767d4082c47a856bbe28ce975", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDc5OTI4OA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r514799288", "bodyText": "The TimeoutException will be propragated to HttpStreamDeframerHandler.processOnError(Throwable) via publisher-subscriber chains. And the exception will be converted to DEADLINE_EXCEEDED status by GrpcStatus.fromThrowable().\nhttps://github.com/line/armeria/pull/2981/files#diff-c2e9a6ba40a5a8ccd62caf83de8f01a6b4ac1b305cc47b2bb07a3eb1c5f3b2c4R122-R124", "author": "ikhoon", "createdAt": "2020-10-30T03:49:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkyMTg1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA3MjIwMA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r515072200", "bodyText": "Thanks for the explanation. \ud83d\ude4f", "author": "minwoox", "createdAt": "2020-10-30T12:46:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkyMTg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkyNjg0Ng==", "url": "https://github.com/line/armeria/pull/2981#discussion_r513926846", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-10-29T03:42:39Z", "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ArmeriaServerCall.java", "diffHunk": "@@ -520,7 +553,7 @@ private void invokeOnCancel() {\n \n     private void setClientStreamClosed() {\n         if (!clientStreamClosed) {\n-            messageReader().cancel();\n+            messageDeframer().abort();", "originalCommit": "c8f7d5fca29d52c767d4082c47a856bbe28ce975", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkyODgwNw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r513928807", "bodyText": "nit: ByteBuf? ByteBuffer is the JDK library.", "author": "minwoox", "createdAt": "2020-10-29T03:45:00Z", "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/UnframedGrpcService.java", "diffHunk": "@@ -273,31 +277,47 @@ private static void deframeAndRespond(\n             }\n         }\n \n-        try (ArmeriaMessageDeframer deframer = new ArmeriaMessageDeframer(\n-                new Listener() {\n-                    @Override\n-                    public void messageRead(DeframedMessage message) {\n-                        // We know that we don't support compression, so this is always a ByteBuffer.\n-                        final HttpData unframedContent = HttpData.wrap(message.buf()).withEndOfStream();\n-                        unframedHeaders.setInt(HttpHeaderNames.CONTENT_LENGTH, unframedContent.length());\n-                        res.complete(HttpResponse.of(unframedHeaders.build(), unframedContent));\n-                    }\n-\n-                    @Override\n-                    public void endOfStream() {\n-                        if (!res.isDone()) {\n-                            // If 'ResponseObserver.onCompleted()' is called without calling 'onNext()',\n-                            // this callback would be invoked but 'messageRead' callback wouldn't.\n-                            res.complete(HttpResponse.of(unframedHeaders.build()));\n-                        }\n-                    }\n-                },\n+        final ArmeriaMessageDeframerHandler handler = new ArmeriaMessageDeframerHandler(\n                 // Max outbound message size is handled by the GrpcService, so we don't need to set it here.\n-                Integer.MAX_VALUE,\n-                ctx.alloc(), false)) {\n-            deframer.request(1);\n-            deframer.deframe(grpcResponse.content(), true);\n-        }\n+                Integer.MAX_VALUE);\n+        final HttpDeframer<DeframedMessage> deframer = new HttpDeframer<>(handler, ctx.alloc());\n+        StreamMessage.of(grpcResponse.content()).subscribe(deframer, ctx.eventLoop());\n+        deframer.subscribe(singleSubscriber(unframedHeaders, res), ctx.eventLoop());\n+    }\n+\n+    private static Subscriber<DeframedMessage> singleSubscriber(ResponseHeadersBuilder unframedHeaders,\n+                                                                CompletableFuture<HttpResponse> res) {\n+        return new Subscriber<DeframedMessage>() {\n+\n+            @Override\n+            public void onSubscribe(Subscription subscription) {\n+                subscription.request(1);\n+            }\n+\n+            @Override\n+            public void onNext(DeframedMessage message) {\n+                // We know that we don't support compression, so this is always a ByteBuffer.", "originalCommit": "c8f7d5fca29d52c767d4082c47a856bbe28ce975", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDc2NTk0MA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r514765940", "bodyText": "It should be ByteBuf. \ud83d\ude05", "author": "ikhoon", "createdAt": "2020-10-30T03:15:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkyODgwNw=="}], "type": "inlineReview"}, {"oid": "11d16ea77433af5eaf213de31d93e5d2b7822b26", "url": "https://github.com/line/armeria/commit/11d16ea77433af5eaf213de31d93e5d2b7822b26", "message": "Address comments by @minwoox", "committedDate": "2020-10-30T08:51:19Z", "type": "commit"}, {"oid": "857c98d0f32711cb337aaa842182fc5117ebd080", "url": "https://github.com/line/armeria/commit/857c98d0f32711cb337aaa842182fc5117ebd080", "message": "Merge branch 'httpdata-processor' of github.com:ikhoon/armeria into httpdata-processor", "committedDate": "2020-11-06T07:00:56Z", "type": "commit"}, {"oid": "0c59dfde6c092ebc8c799aa184d2d7031a7e71f4", "url": "https://github.com/line/armeria/commit/0c59dfde6c092ebc8c799aa184d2d7031a7e71f4", "message": "Update comment", "committedDate": "2020-11-06T07:03:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU3NjI0NQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r519576245", "bodyText": "Could be a singleton?", "author": "trustin", "createdAt": "2020-11-09T06:29:02Z", "path": "grpc/src/main/java/com/linecorp/armeria/internal/client/grpc/GrpcWebTrailersExtractor.java", "diffHunk": "@@ -141,40 +113,93 @@ protected HttpObject filter(HttpObject obj) {\n                                 DecompressorRegistry.getDefaultInstance().lookupDecompressor(grpcEncoding);\n                         if (decompressor == null) {\n                             // Can't find decompressor.\n-                            deframer.close();\n+                            publisher.close();\n                             return obj;\n                         }\n-                        deframer.decompressor(ForwardingDecompressor.forGrpc(decompressor));\n+                        handler.decompressor(ForwardingDecompressor.forGrpc(decompressor));\n                     }\n-                    deframer.request(Integer.MAX_VALUE);\n                     return obj;\n                 }\n \n-                if (obj instanceof HttpData && !deframer.isClosed()) {\n+                if (obj instanceof HttpData && !publisher.isComplete()) {\n                     final HttpData httpData = (HttpData) obj;\n                     final HttpData wrapped = HttpData.wrap(\n                             httpData.byteBuf(ByteBufAccessMode.RETAINED_DUPLICATE));\n-                    deframer.deframe(wrapped, wrapped.isEndOfStream());\n+                    final boolean ignored = publisher.tryWrite(wrapped);\n                 }\n                 return obj;\n             }\n \n             @Override\n             protected void beforeComplete(Subscriber<? super HttpObject> subscriber) {\n-                deframer.close();\n+                publisher.close();\n             }\n \n             @Override\n             protected Throwable beforeError(Subscriber<? super HttpObject> subscriber, Throwable cause) {\n-                deframer.close();\n+                publisher.close();\n                 return cause;\n             }\n         };\n         filteredHttpResponse.whenComplete().handle((unused, unused2) -> {\n             // To make sure the deframer is closed even when the response is cancelled.\n-            deframer.close();\n+            publisher.close();\n             return null;\n         });\n         return filteredHttpResponse;\n     }\n+\n+    private static Subscriber<DeframedMessage> trailersSubscriber(ClientRequestContext ctx) {\n+        return new Subscriber<DeframedMessage>() {", "originalCommit": "0c59dfde6c092ebc8c799aa184d2d7031a7e71f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4MzUxNg==", "url": "https://github.com/line/armeria/pull/2981#discussion_r519583516", "bodyText": "Unfortunately, not. This anonymous Subscriber needs to access ClientRequestContext.\nLet me introduce TrailersSubscriber class for readability.", "author": "ikhoon", "createdAt": "2020-11-09T06:53:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU3NjI0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzg2MTIyMg==", "url": "https://github.com/line/armeria/pull/2981#discussion_r523861222", "bodyText": "Ah, OK.", "author": "trustin", "createdAt": "2020-11-16T02:16:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU3NjI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU3NjI4NQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r519576285", "bodyText": "Is this backpressure-safe?", "author": "trustin", "createdAt": "2020-11-09T06:29:11Z", "path": "grpc/src/main/java/com/linecorp/armeria/internal/client/grpc/GrpcWebTrailersExtractor.java", "diffHunk": "@@ -141,40 +113,93 @@ protected HttpObject filter(HttpObject obj) {\n                                 DecompressorRegistry.getDefaultInstance().lookupDecompressor(grpcEncoding);\n                         if (decompressor == null) {\n                             // Can't find decompressor.\n-                            deframer.close();\n+                            publisher.close();\n                             return obj;\n                         }\n-                        deframer.decompressor(ForwardingDecompressor.forGrpc(decompressor));\n+                        handler.decompressor(ForwardingDecompressor.forGrpc(decompressor));\n                     }\n-                    deframer.request(Integer.MAX_VALUE);\n                     return obj;\n                 }\n \n-                if (obj instanceof HttpData && !deframer.isClosed()) {\n+                if (obj instanceof HttpData && !publisher.isComplete()) {\n                     final HttpData httpData = (HttpData) obj;\n                     final HttpData wrapped = HttpData.wrap(\n                             httpData.byteBuf(ByteBufAccessMode.RETAINED_DUPLICATE));\n-                    deframer.deframe(wrapped, wrapped.isEndOfStream());\n+                    final boolean ignored = publisher.tryWrite(wrapped);\n                 }\n                 return obj;\n             }\n \n             @Override\n             protected void beforeComplete(Subscriber<? super HttpObject> subscriber) {\n-                deframer.close();\n+                publisher.close();\n             }\n \n             @Override\n             protected Throwable beforeError(Subscriber<? super HttpObject> subscriber, Throwable cause) {\n-                deframer.close();\n+                publisher.close();\n                 return cause;\n             }\n         };\n         filteredHttpResponse.whenComplete().handle((unused, unused2) -> {\n             // To make sure the deframer is closed even when the response is cancelled.\n-            deframer.close();\n+            publisher.close();\n             return null;\n         });\n         return filteredHttpResponse;\n     }\n+\n+    private static Subscriber<DeframedMessage> trailersSubscriber(ClientRequestContext ctx) {\n+        return new Subscriber<DeframedMessage>() {\n+            @Override\n+            public void onSubscribe(Subscription s) {\n+                s.request(Long.MAX_VALUE);", "originalCommit": "0c59dfde6c092ebc8c799aa184d2d7031a7e71f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4MDY2NQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r519580665", "bodyText": "Looks like this doesn't have any backpressure issue. Could you add some comments about why we will not have a backpressure problem even if we do this here?", "author": "trustin", "createdAt": "2020-11-09T06:44:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU3NjI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4Mzc5MQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r519583791", "bodyText": "The backpressure is controlled by HttpDeframe. I will leave a comment for that.", "author": "ikhoon", "createdAt": "2020-11-09T06:54:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU3NjI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU1OTI4Ng==", "url": "https://github.com/line/armeria/pull/2981#discussion_r519559286", "bodyText": "nit: a -> an", "author": "minwoox", "createdAt": "2020-11-09T05:24:34Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ *\n+ * <p>Follow the below steps to deframe HTTP payload using {@link HttpDeframer}.\n+ * <ol>\n+ *   <li>Implement your deframing logic in {@link HttpDeframerHandler}.\n+ *       <pre>{@code\n+ *       > class FixedLengthDecoder implements HttpDeframerHandler<String> {\n+ *       >     private final int length;\n+ *\n+ *       >     FixedLengthDecoder(int length) {\n+ *       >         this.length = length;\n+ *       >     }\n+ *\n+ *       >     @Override\n+ *       >     public void process(HttpDeframerInput in, HttpDeframerOutput<String> out) {\n+ *       >         int remaining = in.readableBytes();\n+ *       >         if (remaining < length) {\n+ *       >             // The input is not enough to process. Waiting for more data.\n+ *       >             return;\n+ *       >         }\n+ *\n+ *       >         do {\n+ *       >             // Read data from 'HttpDeframerInput' and\n+ *       >             // write the processed result to 'HttpDeframerOutput'.\n+ *       >             ByteBuf buf = in.readBytes(length);\n+ *       >             out.add(buf.toString(StandardCharsets.UTF_8));\n+ *       >             // Should release the returned 'ByteBuf'\n+ *       >             buf.release();\n+ *       >             remaining -= length;\n+ *       >         } while (remaining >= length);\n+ *       >     }\n+ *       > }\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Create an {@link HttpDeframer} with the {@link HttpDeframerHandler} instance.\n+ *       <pre>{@code\n+ *       FixedLengthDecoder decoder = new FixedLengthDecoder(11);\n+ *       HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to a {@link HttpRequest} using the {@link HttpDeframer}.", "originalCommit": "0c59dfde6c092ebc8c799aa184d2d7031a7e71f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU2MTEwOA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r519561108", "bodyText": "Could you leave a comment where the demand is decreased?", "author": "minwoox", "createdAt": "2020-11-09T05:31:44Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ *\n+ * <p>Follow the below steps to deframe HTTP payload using {@link HttpDeframer}.\n+ * <ol>\n+ *   <li>Implement your deframing logic in {@link HttpDeframerHandler}.\n+ *       <pre>{@code\n+ *       > class FixedLengthDecoder implements HttpDeframerHandler<String> {\n+ *       >     private final int length;\n+ *\n+ *       >     FixedLengthDecoder(int length) {\n+ *       >         this.length = length;\n+ *       >     }\n+ *\n+ *       >     @Override\n+ *       >     public void process(HttpDeframerInput in, HttpDeframerOutput<String> out) {\n+ *       >         int remaining = in.readableBytes();\n+ *       >         if (remaining < length) {\n+ *       >             // The input is not enough to process. Waiting for more data.\n+ *       >             return;\n+ *       >         }\n+ *\n+ *       >         do {\n+ *       >             // Read data from 'HttpDeframerInput' and\n+ *       >             // write the processed result to 'HttpDeframerOutput'.\n+ *       >             ByteBuf buf = in.readBytes(length);\n+ *       >             out.add(buf.toString(StandardCharsets.UTF_8));\n+ *       >             // Should release the returned 'ByteBuf'\n+ *       >             buf.release();\n+ *       >             remaining -= length;\n+ *       >         } while (remaining >= length);\n+ *       >     }\n+ *       > }\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Create an {@link HttpDeframer} with the {@link HttpDeframerHandler} instance.\n+ *       <pre>{@code\n+ *       FixedLengthDecoder decoder = new FixedLengthDecoder(11);\n+ *       HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to a {@link HttpRequest} using the {@link HttpDeframer}.\n+ *       <pre>{@code\n+ *       HttpRequest request = ...;\n+ *       request.subscribe(deframer);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to the {@link Publisher} of the deframed data and connect to your business logic.\n+ *       <pre>{@code\n+ *       import reactor.core.publisher.Flux;\n+ *       Flux.from(deframer).map(...); // Consume and manipulate the deframed data.\n+ *       }</pre>\n+ *   </li>\n+ * </ol>\n+ */\n+@UnstableApi\n+public final class HttpDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpObject, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"initialized\");\n+\n+    private final HttpDeframerHandler<T> handler;\n+    private final ByteBufDeframerInput input;\n+    private final Function<? super HttpData, ? extends ByteBuf> byteBufConverter;\n+\n+    private boolean sawLeadingHeaders;\n+\n+    @Nullable\n+    private volatile EventExecutor eventLoop;\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean cancelled;\n+    private volatile int initialized;\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc) {\n+        this(handler, alloc, HttpData::byteBuf);\n+    }\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler},\n+     * {@link ByteBufAllocator} and {@code byteBufConverter}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc,\n+                        Function<? super HttpData, ? extends ByteBuf> byteBufConverter) {\n+        this.handler = requireNonNull(handler, \"handler\");\n+        input = new ByteBufDeframerInput(requireNonNull(alloc, \"alloc\"));\n+        this.byteBufConverter = requireNonNull(byteBufConverter, \"byteBufConverter\");\n+    }\n+\n+    private void process(HttpObject data) throws Exception {\n+        if (data instanceof HttpHeaders) {\n+            final HttpHeaders headers = (HttpHeaders) data;\n+\n+            if (headers instanceof ResponseHeaders) {\n+                final ResponseHeaders responseHeaders = (ResponseHeaders) headers;\n+                if (responseHeaders.status().isInformational()) {\n+                    handler.processInformationalHeaders(responseHeaders, this::write);\n+                    return;\n+                }\n+            }\n+\n+            if (!sawLeadingHeaders) {\n+                sawLeadingHeaders = true;\n+                handler.processHeaders((HttpHeaders) data, this::write);\n+            } else {\n+                handler.processTrailers((HttpHeaders) data, this::write);\n+            }\n+            return;\n+        }\n+\n+        if (data instanceof HttpData) {\n+            final ByteBuf byteBuf = byteBufConverter.apply((HttpData) data);\n+            requireNonNull(byteBuf, \"byteBufConverter.apply() returned null\");\n+            input.add(byteBuf);\n+            handler.process(input, this::write);\n+        }\n+    }\n+\n+    @Override\n+    SubscriptionImpl subscribe(SubscriptionImpl subscription) {\n+        final SubscriptionImpl subscriptionImpl = super.subscribe(subscription);\n+        if (subscriptionImpl == subscription) {\n+            eventLoop = subscription.executor();\n+            deferredInit();\n+        }\n+        return subscriptionImpl;\n+    }\n+\n+    private void deferredInit() {\n+        final Subscription upstream = this.upstream;\n+        if (upstream != null && eventLoop != null) {\n+            if (initializedUpdater.compareAndSet(this, 0, 1)) {\n+                if (demand() > 0) {\n+                    upstream.request(1);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    void request(long n) {\n+        if (initialized != 0 && demand() == 0) {\n+            upstream.request(1);\n+        }\n+        super.request(n);\n+    }\n+\n+    @Override\n+    void cancel() {\n+        cancelAndCleanup();\n+        super.cancel();\n+    }\n+\n+    @Override\n+    public void onSubscribe(Subscription subscription) {\n+        requireNonNull(subscription, \"subscription\");\n+        if (upstreamUpdater.compareAndSet(this, null, subscription)) {\n+            deferredInit();\n+        } else {\n+            subscription.cancel();\n+        }\n+    }\n+\n+    @Override\n+    public void onNext(HttpObject data) {\n+        final EventExecutor eventLoop = this.eventLoop;\n+        if (eventLoop.inEventLoop()) {\n+            onNext0(data);\n+        } else {\n+            eventLoop.execute(() -> onNext0(data));\n+        }\n+    }\n+\n+    private void onNext0(HttpObject data) {\n+        try {\n+            process(data);\n+\n+            whenConsumed().thenRun(() -> {\n+                if (demand() > 0) {\n+                    upstream.request(1);", "originalCommit": "0c59dfde6c092ebc8c799aa184d2d7031a7e71f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NzcwOA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r519587708", "bodyText": "shouldn't we do if (cancelled) {...}, here?", "author": "minwoox", "createdAt": "2020-11-09T07:06:29Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ *\n+ * <p>Follow the below steps to deframe HTTP payload using {@link HttpDeframer}.\n+ * <ol>\n+ *   <li>Implement your deframing logic in {@link HttpDeframerHandler}.\n+ *       <pre>{@code\n+ *       > class FixedLengthDecoder implements HttpDeframerHandler<String> {\n+ *       >     private final int length;\n+ *\n+ *       >     FixedLengthDecoder(int length) {\n+ *       >         this.length = length;\n+ *       >     }\n+ *\n+ *       >     @Override\n+ *       >     public void process(HttpDeframerInput in, HttpDeframerOutput<String> out) {\n+ *       >         int remaining = in.readableBytes();\n+ *       >         if (remaining < length) {\n+ *       >             // The input is not enough to process. Waiting for more data.\n+ *       >             return;\n+ *       >         }\n+ *\n+ *       >         do {\n+ *       >             // Read data from 'HttpDeframerInput' and\n+ *       >             // write the processed result to 'HttpDeframerOutput'.\n+ *       >             ByteBuf buf = in.readBytes(length);\n+ *       >             out.add(buf.toString(StandardCharsets.UTF_8));\n+ *       >             // Should release the returned 'ByteBuf'\n+ *       >             buf.release();\n+ *       >             remaining -= length;\n+ *       >         } while (remaining >= length);\n+ *       >     }\n+ *       > }\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Create an {@link HttpDeframer} with the {@link HttpDeframerHandler} instance.\n+ *       <pre>{@code\n+ *       FixedLengthDecoder decoder = new FixedLengthDecoder(11);\n+ *       HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to a {@link HttpRequest} using the {@link HttpDeframer}.\n+ *       <pre>{@code\n+ *       HttpRequest request = ...;\n+ *       request.subscribe(deframer);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to the {@link Publisher} of the deframed data and connect to your business logic.\n+ *       <pre>{@code\n+ *       import reactor.core.publisher.Flux;\n+ *       Flux.from(deframer).map(...); // Consume and manipulate the deframed data.\n+ *       }</pre>\n+ *   </li>\n+ * </ol>\n+ */\n+@UnstableApi\n+public final class HttpDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpObject, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"initialized\");\n+\n+    private final HttpDeframerHandler<T> handler;\n+    private final ByteBufDeframerInput input;\n+    private final Function<? super HttpData, ? extends ByteBuf> byteBufConverter;\n+\n+    private boolean sawLeadingHeaders;\n+\n+    @Nullable\n+    private volatile EventExecutor eventLoop;\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean cancelled;\n+    private volatile int initialized;\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc) {\n+        this(handler, alloc, HttpData::byteBuf);\n+    }\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler},\n+     * {@link ByteBufAllocator} and {@code byteBufConverter}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc,\n+                        Function<? super HttpData, ? extends ByteBuf> byteBufConverter) {\n+        this.handler = requireNonNull(handler, \"handler\");\n+        input = new ByteBufDeframerInput(requireNonNull(alloc, \"alloc\"));\n+        this.byteBufConverter = requireNonNull(byteBufConverter, \"byteBufConverter\");\n+    }\n+\n+    private void process(HttpObject data) throws Exception {\n+        if (data instanceof HttpHeaders) {\n+            final HttpHeaders headers = (HttpHeaders) data;\n+\n+            if (headers instanceof ResponseHeaders) {\n+                final ResponseHeaders responseHeaders = (ResponseHeaders) headers;\n+                if (responseHeaders.status().isInformational()) {\n+                    handler.processInformationalHeaders(responseHeaders, this::write);\n+                    return;\n+                }\n+            }\n+\n+            if (!sawLeadingHeaders) {\n+                sawLeadingHeaders = true;\n+                handler.processHeaders((HttpHeaders) data, this::write);\n+            } else {\n+                handler.processTrailers((HttpHeaders) data, this::write);\n+            }\n+            return;\n+        }\n+\n+        if (data instanceof HttpData) {\n+            final ByteBuf byteBuf = byteBufConverter.apply((HttpData) data);\n+            requireNonNull(byteBuf, \"byteBufConverter.apply() returned null\");\n+            input.add(byteBuf);\n+            handler.process(input, this::write);\n+        }\n+    }\n+\n+    @Override\n+    SubscriptionImpl subscribe(SubscriptionImpl subscription) {\n+        final SubscriptionImpl subscriptionImpl = super.subscribe(subscription);\n+        if (subscriptionImpl == subscription) {\n+            eventLoop = subscription.executor();\n+            deferredInit();\n+        }\n+        return subscriptionImpl;\n+    }\n+\n+    private void deferredInit() {\n+        final Subscription upstream = this.upstream;\n+        if (upstream != null && eventLoop != null) {\n+            if (initializedUpdater.compareAndSet(this, 0, 1)) {\n+                if (demand() > 0) {", "originalCommit": "0c59dfde6c092ebc8c799aa184d2d7031a7e71f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MTQ4NA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r519591484", "bodyText": "Can't we just remove the 277~ 280? because it the eventLoop is null cleanup and close() is called by another thread anyway?", "author": "minwoox", "createdAt": "2020-11-09T07:15:39Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ *\n+ * <p>Follow the below steps to deframe HTTP payload using {@link HttpDeframer}.\n+ * <ol>\n+ *   <li>Implement your deframing logic in {@link HttpDeframerHandler}.\n+ *       <pre>{@code\n+ *       > class FixedLengthDecoder implements HttpDeframerHandler<String> {\n+ *       >     private final int length;\n+ *\n+ *       >     FixedLengthDecoder(int length) {\n+ *       >         this.length = length;\n+ *       >     }\n+ *\n+ *       >     @Override\n+ *       >     public void process(HttpDeframerInput in, HttpDeframerOutput<String> out) {\n+ *       >         int remaining = in.readableBytes();\n+ *       >         if (remaining < length) {\n+ *       >             // The input is not enough to process. Waiting for more data.\n+ *       >             return;\n+ *       >         }\n+ *\n+ *       >         do {\n+ *       >             // Read data from 'HttpDeframerInput' and\n+ *       >             // write the processed result to 'HttpDeframerOutput'.\n+ *       >             ByteBuf buf = in.readBytes(length);\n+ *       >             out.add(buf.toString(StandardCharsets.UTF_8));\n+ *       >             // Should release the returned 'ByteBuf'\n+ *       >             buf.release();\n+ *       >             remaining -= length;\n+ *       >         } while (remaining >= length);\n+ *       >     }\n+ *       > }\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Create an {@link HttpDeframer} with the {@link HttpDeframerHandler} instance.\n+ *       <pre>{@code\n+ *       FixedLengthDecoder decoder = new FixedLengthDecoder(11);\n+ *       HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to a {@link HttpRequest} using the {@link HttpDeframer}.\n+ *       <pre>{@code\n+ *       HttpRequest request = ...;\n+ *       request.subscribe(deframer);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to the {@link Publisher} of the deframed data and connect to your business logic.\n+ *       <pre>{@code\n+ *       import reactor.core.publisher.Flux;\n+ *       Flux.from(deframer).map(...); // Consume and manipulate the deframed data.\n+ *       }</pre>\n+ *   </li>\n+ * </ol>\n+ */\n+@UnstableApi\n+public final class HttpDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpObject, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"initialized\");\n+\n+    private final HttpDeframerHandler<T> handler;\n+    private final ByteBufDeframerInput input;\n+    private final Function<? super HttpData, ? extends ByteBuf> byteBufConverter;\n+\n+    private boolean sawLeadingHeaders;\n+\n+    @Nullable\n+    private volatile EventExecutor eventLoop;\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile boolean cancelled;\n+    private volatile int initialized;\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc) {\n+        this(handler, alloc, HttpData::byteBuf);\n+    }\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler},\n+     * {@link ByteBufAllocator} and {@code byteBufConverter}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc,\n+                        Function<? super HttpData, ? extends ByteBuf> byteBufConverter) {\n+        this.handler = requireNonNull(handler, \"handler\");\n+        input = new ByteBufDeframerInput(requireNonNull(alloc, \"alloc\"));\n+        this.byteBufConverter = requireNonNull(byteBufConverter, \"byteBufConverter\");\n+    }\n+\n+    private void process(HttpObject data) throws Exception {\n+        if (data instanceof HttpHeaders) {\n+            final HttpHeaders headers = (HttpHeaders) data;\n+\n+            if (headers instanceof ResponseHeaders) {\n+                final ResponseHeaders responseHeaders = (ResponseHeaders) headers;\n+                if (responseHeaders.status().isInformational()) {\n+                    handler.processInformationalHeaders(responseHeaders, this::write);\n+                    return;\n+                }\n+            }\n+\n+            if (!sawLeadingHeaders) {\n+                sawLeadingHeaders = true;\n+                handler.processHeaders((HttpHeaders) data, this::write);\n+            } else {\n+                handler.processTrailers((HttpHeaders) data, this::write);\n+            }\n+            return;\n+        }\n+\n+        if (data instanceof HttpData) {\n+            final ByteBuf byteBuf = byteBufConverter.apply((HttpData) data);\n+            requireNonNull(byteBuf, \"byteBufConverter.apply() returned null\");\n+            input.add(byteBuf);\n+            handler.process(input, this::write);\n+        }\n+    }\n+\n+    @Override\n+    SubscriptionImpl subscribe(SubscriptionImpl subscription) {\n+        final SubscriptionImpl subscriptionImpl = super.subscribe(subscription);\n+        if (subscriptionImpl == subscription) {\n+            eventLoop = subscription.executor();\n+            deferredInit();\n+        }\n+        return subscriptionImpl;\n+    }\n+\n+    private void deferredInit() {\n+        final Subscription upstream = this.upstream;\n+        if (upstream != null && eventLoop != null) {\n+            if (initializedUpdater.compareAndSet(this, 0, 1)) {\n+                if (demand() > 0) {\n+                    upstream.request(1);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    void request(long n) {\n+        if (initialized != 0 && demand() == 0) {\n+            upstream.request(1);\n+        }\n+        super.request(n);\n+    }\n+\n+    @Override\n+    void cancel() {\n+        cancelAndCleanup();\n+        super.cancel();\n+    }\n+\n+    @Override\n+    public void onSubscribe(Subscription subscription) {\n+        requireNonNull(subscription, \"subscription\");\n+        if (upstreamUpdater.compareAndSet(this, null, subscription)) {\n+            deferredInit();\n+        } else {\n+            subscription.cancel();\n+        }\n+    }\n+\n+    @Override\n+    public void onNext(HttpObject data) {\n+        final EventExecutor eventLoop = this.eventLoop;\n+        if (eventLoop.inEventLoop()) {\n+            onNext0(data);\n+        } else {\n+            eventLoop.execute(() -> onNext0(data));\n+        }\n+    }\n+\n+    private void onNext0(HttpObject data) {\n+        try {\n+            process(data);\n+\n+            whenConsumed().thenRun(() -> {\n+                if (demand() > 0) {\n+                    upstream.request(1);\n+                }\n+            });\n+        } catch (Throwable ex) {\n+            handler.processOnError(ex);\n+            cancelAndCleanup();\n+            abort(ex);\n+            Exceptions.throwIfFatal(ex);\n+        }\n+    }\n+\n+    private void cancelAndCleanup() {\n+        cancelled = true;\n+        final Subscription upstream = this.upstream;\n+        if (upstream != null) {\n+            upstream.cancel();\n+        }\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void onError(Throwable cause) {\n+        requireNonNull(cause, \"cause\");\n+        if (cancelled) {\n+            return;\n+        }\n+        final EventExecutor eventLoop = this.eventLoop;\n+        if (eventLoop != null && !eventLoop.inEventLoop()) {\n+            eventLoop.execute(() -> onError(cause));\n+            return;\n+        }\n+\n+        if (!(cause instanceof AbortedStreamException)) {\n+            handler.processOnError(cause);\n+        }\n+\n+        abort(cause);\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        if (cancelled) {\n+            return;\n+        }\n+\n+        final EventExecutor eventLoop = this.eventLoop;\n+        if (eventLoop != null && !eventLoop.inEventLoop()) {\n+            eventLoop.execute(this::onComplete);\n+            return;\n+        }", "originalCommit": "0c59dfde6c092ebc8c799aa184d2d7031a7e71f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzkxNTM4Mw==", "url": "https://github.com/line/armeria/pull/2981#discussion_r523915383", "bodyText": "That's a good point. cleanup is not a thread safe. I think we need a volatile flag such as cleaned.", "author": "ikhoon", "createdAt": "2020-11-16T06:06:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MTQ4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MjQ0Ng==", "url": "https://github.com/line/armeria/pull/2981#discussion_r519592446", "bodyText": "2020? \ud83d\ude0e", "author": "minwoox", "createdAt": "2020-11-09T07:17:07Z", "path": "grpc-protocol/src/main/java/com/linecorp/armeria/common/grpc/protocol/ArmeriaMessageDeframerHandler.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2019 LINE Corporation", "originalCommit": "0c59dfde6c092ebc8c799aa184d2d7031a7e71f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MzU5NA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r519593594", "bodyText": "nit: a -> an", "author": "minwoox", "createdAt": "2020-11-09T07:18:45Z", "path": "grpc-protocol/src/main/java/com/linecorp/armeria/common/grpc/protocol/DeframedMessage.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.grpc.protocol;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.util.Objects;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+/**\n+ * A deframed message. For uncompressed messages, we have the entire buffer available and return it\n+ * as is in {@code buf} to optimize parsing. For compressed messages, we will parse incrementally\n+ * and thus return a {@link InputStream} in {@code stream}.", "originalCommit": "0c59dfde6c092ebc8c799aa184d2d7031a7e71f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5NTk5NQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r519595995", "bodyText": "2020? \ud83d\ude0e", "author": "minwoox", "createdAt": "2020-11-09T07:22:08Z", "path": "grpc/src/test/java/com/linecorp/armeria/common/grpc/protocol/ArmeriaMessageDeframerHandlerTest.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Copyright 2019 LINE Corporation", "originalCommit": "0c59dfde6c092ebc8c799aa184d2d7031a7e71f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5NjE3NA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r519596174", "bodyText": "\ud83e\udd14", "author": "minwoox", "createdAt": "2020-11-09T07:22:25Z", "path": "grpc/src/test/java/com/linecorp/armeria/internal/common/grpc/HttpStreamDeframerTest.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2017 LINE Corporation", "originalCommit": "0c59dfde6c092ebc8c799aa184d2d7031a7e71f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzkwMjU5MA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r523902590", "bodyText": "Ah, The file name has been changed. \ud83d\ude05", "author": "ikhoon", "createdAt": "2020-11-16T05:10:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5NjE3NA=="}], "type": "inlineReview"}, {"oid": "3c2f1ba11f2ce3539d597bb74f9daf4f681c8b4d", "url": "https://github.com/line/armeria/commit/3c2f1ba11f2ce3539d597bb74f9daf4f681c8b4d", "message": "--wip-- [skip ci]", "committedDate": "2020-11-16T09:19:24Z", "type": "commit"}, {"oid": "bfc80a5f09d1a643865e07c5c0dd2bc9f0a9061a", "url": "https://github.com/line/armeria/commit/bfc80a5f09d1a643865e07c5c0dd2bc9f0a9061a", "message": "Address comments by @trustin and @minwoox", "committedDate": "2020-11-16T11:42:34Z", "type": "commit"}, {"oid": "cf49a3a8e446145225d4d6f2b9687f274619226c", "url": "https://github.com/line/armeria/commit/cf49a3a8e446145225d4d6f2b9687f274619226c", "message": "Fix broken test", "committedDate": "2020-11-16T16:05:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU2NDM3NA==", "url": "https://github.com/line/armeria/pull/2981#discussion_r526564374", "bodyText": "Shouldn't we do this before final EventExecutor eventLoop = this.eventLoop; so that this cause is not swallowed?", "author": "minwoox", "createdAt": "2020-11-19T03:11:34Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ *\n+ * <p>Follow the below steps to deframe HTTP payload using {@link HttpDeframer}.\n+ * <ol>\n+ *   <li>Implement your deframing logic in {@link HttpDeframerHandler}.\n+ *       <pre>{@code\n+ *       > class FixedLengthDecoder implements HttpDeframerHandler<String> {\n+ *       >     private final int length;\n+ *\n+ *       >     FixedLengthDecoder(int length) {\n+ *       >         this.length = length;\n+ *       >     }\n+ *\n+ *       >     @Override\n+ *       >     public void process(HttpDeframerInput in, HttpDeframerOutput<String> out) {\n+ *       >         int remaining = in.readableBytes();\n+ *       >         if (remaining < length) {\n+ *       >             // The input is not enough to process. Waiting for more data.\n+ *       >             return;\n+ *       >         }\n+ *\n+ *       >         do {\n+ *       >             // Read data from 'HttpDeframerInput' and\n+ *       >             // write the processed result to 'HttpDeframerOutput'.\n+ *       >             ByteBuf buf = in.readBytes(length);\n+ *       >             out.add(buf.toString(StandardCharsets.UTF_8));\n+ *       >             // Should release the returned 'ByteBuf'\n+ *       >             buf.release();\n+ *       >             remaining -= length;\n+ *       >         } while (remaining >= length);\n+ *       >     }\n+ *       > }\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Create an {@link HttpDeframer} with the {@link HttpDeframerHandler} instance.\n+ *       <pre>{@code\n+ *       FixedLengthDecoder decoder = new FixedLengthDecoder(11);\n+ *       HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to an {@link HttpRequest} using the {@link HttpDeframer}.\n+ *       <pre>{@code\n+ *       HttpRequest request = ...;\n+ *       request.subscribe(deframer);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to the {@link Publisher} of the deframed data and connect to your business logic.\n+ *       <pre>{@code\n+ *       import reactor.core.publisher.Flux;\n+ *       Flux.from(deframer).map(...); // Consume and manipulate the deframed data.\n+ *       }</pre>\n+ *   </li>\n+ * </ol>\n+ */\n+@UnstableApi\n+public final class HttpDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpObject, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"initialized\");\n+\n+    private final HttpDeframerHandler<T> handler;\n+    private final ByteBufDeframerInput input;\n+    private final Function<? super HttpData, ? extends ByteBuf> byteBufConverter;\n+\n+    private boolean sawLeadingHeaders;\n+\n+    @Nullable\n+    private volatile EventExecutor eventLoop;\n+    @Nullable\n+    private volatile Subscription upstream;\n+    @Nullable\n+    private volatile Throwable cause;\n+    private volatile boolean cancelled;\n+    private volatile boolean completing;\n+    private volatile int initialized;\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc) {\n+        this(handler, alloc, HttpData::byteBuf);\n+    }\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler},\n+     * {@link ByteBufAllocator} and {@code byteBufConverter}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc,\n+                        Function<? super HttpData, ? extends ByteBuf> byteBufConverter) {\n+        this.handler = requireNonNull(handler, \"handler\");\n+        input = new ByteBufDeframerInput(requireNonNull(alloc, \"alloc\"));\n+        this.byteBufConverter = requireNonNull(byteBufConverter, \"byteBufConverter\");\n+    }\n+\n+    private void process(HttpObject data) throws Exception {\n+        if (data instanceof HttpHeaders) {\n+            final HttpHeaders headers = (HttpHeaders) data;\n+\n+            if (headers instanceof ResponseHeaders) {\n+                final ResponseHeaders responseHeaders = (ResponseHeaders) headers;\n+                if (responseHeaders.status().isInformational()) {\n+                    handler.processInformationalHeaders(responseHeaders, this::write);\n+                    return;\n+                }\n+            }\n+\n+            if (!sawLeadingHeaders) {\n+                sawLeadingHeaders = true;\n+                handler.processHeaders((HttpHeaders) data, this::write);\n+            } else {\n+                handler.processTrailers((HttpHeaders) data, this::write);\n+            }\n+            return;\n+        }\n+\n+        if (data instanceof HttpData) {\n+            final ByteBuf byteBuf = byteBufConverter.apply((HttpData) data);\n+            requireNonNull(byteBuf, \"byteBufConverter.apply() returned null\");\n+            input.add(byteBuf);\n+            handler.process(input, this::write);\n+        }\n+    }\n+\n+    @Override\n+    SubscriptionImpl subscribe(SubscriptionImpl subscription) {\n+        final SubscriptionImpl subscriptionImpl = super.subscribe(subscription);\n+        if (subscriptionImpl == subscription) {\n+            final EventExecutor eventLoop = subscription.executor();\n+            this.eventLoop = eventLoop;\n+            deferredInit(eventLoop);\n+        }\n+        return subscriptionImpl;\n+    }\n+\n+    private void deferredInit(@Nullable EventExecutor eventLoop) {\n+        final Subscription upstream = this.upstream;\n+\n+        if (upstream != null && eventLoop != null) {\n+            if (initializedUpdater.compareAndSet(this, 0, 1)) {\n+                if (cancelled) {\n+                    upstream.cancel();\n+                    return;\n+                }\n+\n+                final Throwable cause = this.cause;\n+                if (cause != null) {\n+                    if (eventLoop.inEventLoop()) {\n+                        onError0(cause);\n+                    } else {\n+                        eventLoop.execute(() -> onError0(cause));\n+                    }\n+                    return;\n+                }\n+\n+                if (completing) {\n+                    if (eventLoop.inEventLoop()) {\n+                        onComplete0();\n+                    } else {\n+                        eventLoop.execute(this::onComplete0);\n+                    }\n+                    return;\n+                }\n+\n+                if (demand() > 0) {\n+                    // The 'demand' will be decreased by 'DefaultStreamMessage.notifySubscriberWithElements()'\n+                    upstream.request(1);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    void request(long n) {\n+        if (initialized != 0 && demand() == 0) {\n+            upstream.request(1);\n+        }\n+        super.request(n);\n+    }\n+\n+    @Override\n+    void cancel() {\n+        cancelAndCleanup();\n+        super.cancel();\n+    }\n+\n+    @Override\n+    public void onSubscribe(Subscription subscription) {\n+        requireNonNull(subscription, \"subscription\");\n+        if (upstreamUpdater.compareAndSet(this, null, subscription)) {\n+            deferredInit(this.eventLoop);\n+        } else {\n+            subscription.cancel();\n+        }\n+    }\n+\n+    @Override\n+    public void onNext(HttpObject data) {\n+        final EventExecutor eventLoop = this.eventLoop;\n+        if (eventLoop.inEventLoop()) {\n+            onNext0(data);\n+        } else {\n+            eventLoop.execute(() -> onNext0(data));\n+        }\n+    }\n+\n+    private void onNext0(HttpObject data) {\n+        try {\n+            process(data);\n+\n+            whenConsumed().thenRun(() -> {\n+                if (demand() > 0) {\n+                    // The `demand` will be decreased by 'DefaultStreamMessage.notifySubscriberWithElements()'\n+                    upstream.request(1);\n+                }\n+            });\n+        } catch (Throwable ex) {\n+            handler.processOnError(ex);\n+            cancelAndCleanup();\n+            abort(ex);\n+            Exceptions.throwIfFatal(ex);\n+        }\n+    }\n+\n+    private void cancelAndCleanup() {\n+        cancelled = true;\n+        final Subscription upstream = this.upstream;\n+        if (upstream != null) {\n+            upstream.cancel();\n+        }\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void onError(Throwable cause) {\n+        requireNonNull(cause, \"cause\");\n+        if (cancelled) {\n+            return;\n+        }\n+\n+        final EventExecutor eventLoop = this.eventLoop;\n+        if (eventLoop == null) {\n+            this.cause = cause;", "originalCommit": "cf49a3a8e446145225d4d6f2b9687f274619226c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU3NTMyMg==", "url": "https://github.com/line/armeria/pull/2981#discussion_r526575322", "bodyText": "Oh. That's a good suggestion. \ud83d\udc4d", "author": "ikhoon", "createdAt": "2020-11-19T03:44:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU2NDM3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU2NDk0NQ==", "url": "https://github.com/line/armeria/pull/2981#discussion_r526564945", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-11-19T03:12:10Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/HttpDeframer.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A {@link Processor} implementation that decodes a stream of {@link HttpObject}s to N objects.\n+ *\n+ * <p>Follow the below steps to deframe HTTP payload using {@link HttpDeframer}.\n+ * <ol>\n+ *   <li>Implement your deframing logic in {@link HttpDeframerHandler}.\n+ *       <pre>{@code\n+ *       > class FixedLengthDecoder implements HttpDeframerHandler<String> {\n+ *       >     private final int length;\n+ *\n+ *       >     FixedLengthDecoder(int length) {\n+ *       >         this.length = length;\n+ *       >     }\n+ *\n+ *       >     @Override\n+ *       >     public void process(HttpDeframerInput in, HttpDeframerOutput<String> out) {\n+ *       >         int remaining = in.readableBytes();\n+ *       >         if (remaining < length) {\n+ *       >             // The input is not enough to process. Waiting for more data.\n+ *       >             return;\n+ *       >         }\n+ *\n+ *       >         do {\n+ *       >             // Read data from 'HttpDeframerInput' and\n+ *       >             // write the processed result to 'HttpDeframerOutput'.\n+ *       >             ByteBuf buf = in.readBytes(length);\n+ *       >             out.add(buf.toString(StandardCharsets.UTF_8));\n+ *       >             // Should release the returned 'ByteBuf'\n+ *       >             buf.release();\n+ *       >             remaining -= length;\n+ *       >         } while (remaining >= length);\n+ *       >     }\n+ *       > }\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Create an {@link HttpDeframer} with the {@link HttpDeframerHandler} instance.\n+ *       <pre>{@code\n+ *       FixedLengthDecoder decoder = new FixedLengthDecoder(11);\n+ *       HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to an {@link HttpRequest} using the {@link HttpDeframer}.\n+ *       <pre>{@code\n+ *       HttpRequest request = ...;\n+ *       request.subscribe(deframer);\n+ *       }</pre>\n+ *   </li>\n+ *   <li>Subscribe to the {@link Publisher} of the deframed data and connect to your business logic.\n+ *       <pre>{@code\n+ *       import reactor.core.publisher.Flux;\n+ *       Flux.from(deframer).map(...); // Consume and manipulate the deframed data.\n+ *       }</pre>\n+ *   </li>\n+ * </ol>\n+ */\n+@UnstableApi\n+public final class HttpDeframer<T> extends DefaultStreamMessage<T> implements Processor<HttpObject, T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<HttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(HttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<HttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(HttpDeframer.class, \"initialized\");\n+\n+    private final HttpDeframerHandler<T> handler;\n+    private final ByteBufDeframerInput input;\n+    private final Function<? super HttpData, ? extends ByteBuf> byteBufConverter;\n+\n+    private boolean sawLeadingHeaders;\n+\n+    @Nullable\n+    private volatile EventExecutor eventLoop;\n+    @Nullable\n+    private volatile Subscription upstream;\n+    @Nullable\n+    private volatile Throwable cause;\n+    private volatile boolean cancelled;\n+    private volatile boolean completing;\n+    private volatile int initialized;\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler} and\n+     * {@link ByteBufAllocator}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc) {\n+        this(handler, alloc, HttpData::byteBuf);\n+    }\n+\n+    /**\n+     * Returns a new {@link HttpDeframer} with the specified {@link HttpDeframerHandler},\n+     * {@link ByteBufAllocator} and {@code byteBufConverter}.\n+     */\n+    public HttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc,\n+                        Function<? super HttpData, ? extends ByteBuf> byteBufConverter) {\n+        this.handler = requireNonNull(handler, \"handler\");\n+        input = new ByteBufDeframerInput(requireNonNull(alloc, \"alloc\"));\n+        this.byteBufConverter = requireNonNull(byteBufConverter, \"byteBufConverter\");\n+    }\n+\n+    private void process(HttpObject data) throws Exception {\n+        if (data instanceof HttpHeaders) {\n+            final HttpHeaders headers = (HttpHeaders) data;\n+\n+            if (headers instanceof ResponseHeaders) {\n+                final ResponseHeaders responseHeaders = (ResponseHeaders) headers;\n+                if (responseHeaders.status().isInformational()) {\n+                    handler.processInformationalHeaders(responseHeaders, this::write);\n+                    return;\n+                }\n+            }\n+\n+            if (!sawLeadingHeaders) {\n+                sawLeadingHeaders = true;\n+                handler.processHeaders((HttpHeaders) data, this::write);\n+            } else {\n+                handler.processTrailers((HttpHeaders) data, this::write);\n+            }\n+            return;\n+        }\n+\n+        if (data instanceof HttpData) {\n+            final ByteBuf byteBuf = byteBufConverter.apply((HttpData) data);\n+            requireNonNull(byteBuf, \"byteBufConverter.apply() returned null\");\n+            input.add(byteBuf);\n+            handler.process(input, this::write);\n+        }\n+    }\n+\n+    @Override\n+    SubscriptionImpl subscribe(SubscriptionImpl subscription) {\n+        final SubscriptionImpl subscriptionImpl = super.subscribe(subscription);\n+        if (subscriptionImpl == subscription) {\n+            final EventExecutor eventLoop = subscription.executor();\n+            this.eventLoop = eventLoop;\n+            deferredInit(eventLoop);\n+        }\n+        return subscriptionImpl;\n+    }\n+\n+    private void deferredInit(@Nullable EventExecutor eventLoop) {\n+        final Subscription upstream = this.upstream;\n+\n+        if (upstream != null && eventLoop != null) {\n+            if (initializedUpdater.compareAndSet(this, 0, 1)) {\n+                if (cancelled) {\n+                    upstream.cancel();\n+                    return;\n+                }\n+\n+                final Throwable cause = this.cause;\n+                if (cause != null) {\n+                    if (eventLoop.inEventLoop()) {\n+                        onError0(cause);\n+                    } else {\n+                        eventLoop.execute(() -> onError0(cause));\n+                    }\n+                    return;\n+                }\n+\n+                if (completing) {\n+                    if (eventLoop.inEventLoop()) {\n+                        onComplete0();\n+                    } else {\n+                        eventLoop.execute(this::onComplete0);\n+                    }\n+                    return;\n+                }\n+\n+                if (demand() > 0) {\n+                    // The 'demand' will be decreased by 'DefaultStreamMessage.notifySubscriberWithElements()'\n+                    upstream.request(1);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    void request(long n) {\n+        if (initialized != 0 && demand() == 0) {\n+            upstream.request(1);\n+        }\n+        super.request(n);\n+    }\n+\n+    @Override\n+    void cancel() {\n+        cancelAndCleanup();\n+        super.cancel();\n+    }\n+\n+    @Override\n+    public void onSubscribe(Subscription subscription) {\n+        requireNonNull(subscription, \"subscription\");\n+        if (upstreamUpdater.compareAndSet(this, null, subscription)) {\n+            deferredInit(this.eventLoop);\n+        } else {\n+            subscription.cancel();\n+        }\n+    }\n+\n+    @Override\n+    public void onNext(HttpObject data) {\n+        final EventExecutor eventLoop = this.eventLoop;\n+        if (eventLoop.inEventLoop()) {\n+            onNext0(data);\n+        } else {\n+            eventLoop.execute(() -> onNext0(data));\n+        }\n+    }\n+\n+    private void onNext0(HttpObject data) {\n+        try {\n+            process(data);\n+\n+            whenConsumed().thenRun(() -> {\n+                if (demand() > 0) {\n+                    // The `demand` will be decreased by 'DefaultStreamMessage.notifySubscriberWithElements()'\n+                    upstream.request(1);\n+                }\n+            });\n+        } catch (Throwable ex) {\n+            handler.processOnError(ex);\n+            cancelAndCleanup();\n+            abort(ex);\n+            Exceptions.throwIfFatal(ex);\n+        }\n+    }\n+\n+    private void cancelAndCleanup() {\n+        cancelled = true;\n+        final Subscription upstream = this.upstream;\n+        if (upstream != null) {\n+            upstream.cancel();\n+        }\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void onError(Throwable cause) {\n+        requireNonNull(cause, \"cause\");\n+        if (cancelled) {\n+            return;\n+        }\n+\n+        final EventExecutor eventLoop = this.eventLoop;\n+        if (eventLoop == null) {\n+            this.cause = cause;\n+        } else {\n+            if (eventLoop.inEventLoop()) {\n+                onError0(cause);\n+            } else {\n+                eventLoop.execute(() -> onError0(cause));\n+            }\n+        }\n+    }\n+\n+    private void onError0(Throwable cause) {\n+        if (!(cause instanceof AbortedStreamException)) {\n+            handler.processOnError(cause);\n+        }\n+\n+        abort(cause);\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        if (cancelled) {\n+            return;\n+        }\n+\n+        final EventExecutor eventLoop = this.eventLoop;\n+        if (eventLoop == null) {\n+            completing = true;", "originalCommit": "cf49a3a8e446145225d4d6f2b9687f274619226c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6fb78c92d5825521a870ca0c6a99fcb5596a9bb4", "url": "https://github.com/line/armeria/commit/6fb78c92d5825521a870ca0c6a99fcb5596a9bb4", "message": "Address comments by @minwoox", "committedDate": "2020-11-19T03:44:52Z", "type": "commit"}, {"oid": "79ba9a9d462cb93ea772e7cef4c722894ecae5c1", "url": "https://github.com/line/armeria/commit/79ba9a9d462cb93ea772e7cef4c722894ecae5c1", "message": "Clean up", "committedDate": "2020-11-19T03:46:59Z", "type": "commit"}, {"oid": "95fdd48aa10f1ffb41277c6d3c324aae5fb9ad7e", "url": "https://github.com/line/armeria/commit/95fdd48aa10f1ffb41277c6d3c324aae5fb9ad7e", "message": "Remove cruft", "committedDate": "2020-11-19T09:57:59Z", "type": "commit"}]}