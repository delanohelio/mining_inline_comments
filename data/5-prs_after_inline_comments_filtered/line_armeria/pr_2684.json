{"pr_number": 2684, "pr_title": "Support `@LocalArmeriaPort`, `@LocalArmeriaPorts`", "pr_createdAt": "2020-05-01T11:24:39Z", "pr_url": "https://github.com/line/armeria/pull/2684", "timeline": [{"oid": "34b94cf0005e364477c467aba22ff3741df71631", "url": "https://github.com/line/armeria/commit/34b94cf0005e364477c467aba22ff3741df71631", "message": "Support `@LocalArmeriaPort`, `@LocalArmeriaPorts`", "committedDate": "2020-05-01T11:18:22Z", "type": "commit"}, {"oid": "5d92bec583a438fcea722a6d2d63c6dbf5d75447", "url": "https://github.com/line/armeria/commit/5d92bec583a438fcea722a6d2d63c6dbf5d75447", "message": "Fix test / Add comment", "committedDate": "2020-05-01T11:28:51Z", "type": "commit"}, {"oid": "113132d0ca69d2efdabc086087be250b8d23606b", "url": "https://github.com/line/armeria/commit/113132d0ca69d2efdabc086087be250b8d23606b", "message": "Fix `ArmeriaBeanPostProcessor` by`: it: spring: boot-tomcat8.5`", "committedDate": "2020-05-01T12:17:36Z", "type": "commit"}, {"oid": "d1f25a8db20819727766a04bf7696ffff780ad5b", "url": "https://github.com/line/armeria/commit/d1f25a8db20819727766a04bf7696ffff780ad5b", "message": "Fix `ArmeriaSpringBoot1BeanPostProcessor` / Fix copy file", "committedDate": "2020-05-03T14:31:08Z", "type": "commit"}, {"oid": "48f3f6db7661223a3b89adb34124ac916789e089", "url": "https://github.com/line/armeria/commit/48f3f6db7661223a3b89adb34124ac916789e089", "message": "Fix build.gradle", "committedDate": "2020-05-03T15:22:11Z", "type": "commit"}, {"oid": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5", "url": "https://github.com/line/armeria/commit/75ea69194b6f6bc8c34aae9d494d97d905d3eaa5", "message": "Fix build.gradle", "committedDate": "2020-05-03T15:51:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0NDk2NQ==", "url": "https://github.com/line/armeria/pull/2684#discussion_r419244965", "bodyText": "If a user does not specify a value,", "author": "minwoox", "createdAt": "2020-05-04T07:06:11Z", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/LocalArmeriaPort.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import java.lang.annotation.Documented;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Specifies an active local port of an Armeria server.\n+ */\n+@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE })\n+@Retention(RetentionPolicy.RUNTIME)\n+@Documented\n+public @interface LocalArmeriaPort {\n+\n+    /**\n+     * Specifies the {@link SessionProtocol} to get the port from the {@link Server}.\n+     * If a user specify a default value, {@link Server#activeLocalPort()} is used.", "originalCommit": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1MDAzOQ==", "url": "https://github.com/line/armeria/pull/2684#discussion_r419950039", "bodyText": "Fixed 568291b", "author": "heowc", "createdAt": "2020-05-05T08:39:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0NDk2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0ODYwNQ==", "url": "https://github.com/line/armeria/pull/2684#discussion_r419248605", "bodyText": "We don't need this because the class definition says so?", "author": "minwoox", "createdAt": "2020-05-04T07:16:04Z", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.core.Ordered;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * {@link BeanPostProcessor} implementation that autowires annotated fields, setter methods, and arbitrary\n+ * config methods. Such members to be injected are detected through annotations:\n+ * by default, {@link LocalArmeriaPort} and {@link LocalArmeriaPorts} annotations.\n+ *\n+ * <p>This class was created by referring to classes implementing", "originalCommit": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1MDIzMQ==", "url": "https://github.com/line/armeria/pull/2684#discussion_r419950231", "bodyText": "Removed 568291b", "author": "heowc", "createdAt": "2020-05-05T08:39:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0ODYwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0OTIwMA==", "url": "https://github.com/line/armeria/pull/2684#discussion_r419249200", "bodyText": "Could you leave a comment what -2 is for?", "author": "minwoox", "createdAt": "2020-05-04T07:17:33Z", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.core.Ordered;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * {@link BeanPostProcessor} implementation that autowires annotated fields, setter methods, and arbitrary\n+ * config methods. Such members to be injected are detected through annotations:\n+ * by default, {@link LocalArmeriaPort} and {@link LocalArmeriaPorts} annotations.\n+ *\n+ * <p>This class was created by referring to classes implementing\n+ * Spring's {@link InstantiationAwareBeanPostProcessor}.\n+ */\n+public final class ArmeriaBeanPostProcessor implements InstantiationAwareBeanPostProcessor, Ordered {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final BeanFactory beanFactory;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return Ordered.LOWEST_PRECEDENCE - 2;", "originalCommit": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg4NzY5MA==", "url": "https://github.com/line/armeria/pull/2684#discussion_r419887690", "bodyText": "There is no special meaning for order. It just fits the same as AutowiredAnnotationBeanPostProcessor.\nIf I think we don't need an order, it doesn't seem like a way to specify it. What do you think?", "author": "heowc", "createdAt": "2020-05-05T06:25:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0OTIwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMjgxNA==", "url": "https://github.com/line/armeria/pull/2684#discussion_r420512814", "bodyText": "Could you add an in-code comment that explains this? Not a Github comment", "author": "trustin", "createdAt": "2020-05-06T02:25:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0OTIwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0OTQ0NA==", "url": "https://github.com/line/armeria/pull/2684#discussion_r420549444", "bodyText": "What do you think about not implementing Ordered? When I looked at some BeanPostProcessor implementations, I saw no implementation.", "author": "heowc", "createdAt": "2020-05-06T05:15:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0OTIwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU1MjU2Nw==", "url": "https://github.com/line/armeria/pull/2684#discussion_r420552567", "bodyText": "What do you think about not implementing Ordered?\n\n+1. If we need to, I think we can implement it later.", "author": "minwoox", "createdAt": "2020-05-06T05:28:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0OTIwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY1MTc0NQ==", "url": "https://github.com/line/armeria/pull/2684#discussion_r420651745", "bodyText": "Removed. be30ae3", "author": "heowc", "createdAt": "2020-05-06T09:17:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0OTIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1MDM3OQ==", "url": "https://github.com/line/armeria/pull/2684#discussion_r419250379", "bodyText": "Let's use isNullOrEmpty from Guava.", "author": "minwoox", "createdAt": "2020-05-04T07:20:17Z", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.core.Ordered;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * {@link BeanPostProcessor} implementation that autowires annotated fields, setter methods, and arbitrary\n+ * config methods. Such members to be injected are detected through annotations:\n+ * by default, {@link LocalArmeriaPort} and {@link LocalArmeriaPorts} annotations.\n+ *\n+ * <p>This class was created by referring to classes implementing\n+ * Spring's {@link InstantiationAwareBeanPostProcessor}.\n+ */\n+public final class ArmeriaBeanPostProcessor implements InstantiationAwareBeanPostProcessor, Ordered {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final BeanFactory beanFactory;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return Ordered.LOWEST_PRECEDENCE - 2;\n+    }\n+\n+    /**\n+     * Post-processes the given property values before the factory apply them to the given bean.\n+     */\n+    @Override\n+    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n+        final InjectionMetadata metadata = findLocalArmeriaPortMetadata(beanName, bean.getClass(), pvs);\n+        try {\n+            metadata.inject(bean, beanName, pvs);\n+        } catch (Throwable ex) {\n+            throw new BeanCreationException(beanName, \"Injection of resource dependencies failed\", ex);\n+        }\n+        return pvs;\n+    }\n+\n+    private InjectionMetadata findLocalArmeriaPortMetadata(\n+            String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {\n+        final String cacheKey = StringUtils.hasLength(beanName) ? beanName : clazz.getName();", "originalCommit": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1MDMxNA==", "url": "https://github.com/line/armeria/pull/2684#discussion_r419950314", "bodyText": "Fixed 568291b", "author": "heowc", "createdAt": "2020-05-05T08:40:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1MDM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1MzQ5Nw==", "url": "https://github.com/line/armeria/pull/2684#discussion_r419253497", "bodyText": "This is a field so I think we need to use a singular sentence.\n\"LocalArmeriaPort annotation is not supported on the static field: \" + field.getName()", "author": "minwoox", "createdAt": "2020-05-04T07:27:41Z", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.core.Ordered;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * {@link BeanPostProcessor} implementation that autowires annotated fields, setter methods, and arbitrary\n+ * config methods. Such members to be injected are detected through annotations:\n+ * by default, {@link LocalArmeriaPort} and {@link LocalArmeriaPorts} annotations.\n+ *\n+ * <p>This class was created by referring to classes implementing\n+ * Spring's {@link InstantiationAwareBeanPostProcessor}.\n+ */\n+public final class ArmeriaBeanPostProcessor implements InstantiationAwareBeanPostProcessor, Ordered {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final BeanFactory beanFactory;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return Ordered.LOWEST_PRECEDENCE - 2;\n+    }\n+\n+    /**\n+     * Post-processes the given property values before the factory apply them to the given bean.\n+     */\n+    @Override\n+    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n+        final InjectionMetadata metadata = findLocalArmeriaPortMetadata(beanName, bean.getClass(), pvs);\n+        try {\n+            metadata.inject(bean, beanName, pvs);\n+        } catch (Throwable ex) {\n+            throw new BeanCreationException(beanName, \"Injection of resource dependencies failed\", ex);\n+        }\n+        return pvs;\n+    }\n+\n+    private InjectionMetadata findLocalArmeriaPortMetadata(\n+            String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {\n+        final String cacheKey = StringUtils.hasLength(beanName) ? beanName : clazz.getName();\n+        InjectionMetadata metadata = injectionMetadataCache.get(cacheKey);\n+        if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+            synchronized (injectionMetadataCache) {\n+                metadata = injectionMetadataCache.get(cacheKey);\n+                if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+                    if (metadata != null) {\n+                        metadata.clear(pvs);\n+                    }\n+                    metadata = buildLocalArmeriaPortMetadata(clazz);\n+                    injectionMetadataCache.put(cacheKey, metadata);\n+                }\n+            }\n+        }\n+        return metadata;\n+    }\n+\n+    private InjectionMetadata buildLocalArmeriaPortMetadata(Class<?> clazz) {\n+        final List<InjectedElement> elements = new ArrayList<>();\n+        Class<?> targetClass = clazz;\n+\n+        do {\n+            final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();\n+\n+            ReflectionUtils.doWithLocalFields(targetClass, field -> {\n+                if (field.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotations are not supported on static fields\");", "originalCommit": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1MDM2Mw==", "url": "https://github.com/line/armeria/pull/2684#discussion_r419950363", "bodyText": "Fixed 568291b", "author": "heowc", "createdAt": "2020-05-05T08:40:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1MzQ5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1Mzk0OA==", "url": "https://github.com/line/armeria/pull/2684#discussion_r419253948", "bodyText": "Seems like we don't use this for ElementType.PARAMETER?", "author": "minwoox", "createdAt": "2020-05-04T07:28:51Z", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/LocalArmeriaPort.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import java.lang.annotation.Documented;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Specifies an active local port of an Armeria server.\n+ */\n+@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE })", "originalCommit": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1NTU4MQ==", "url": "https://github.com/line/armeria/pull/2684#discussion_r419255581", "bodyText": "nit: a -> an", "author": "minwoox", "createdAt": "2020-05-04T07:32:27Z", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessorConfiguration.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Spring Boot {@link Configuration} that provides Armeria integration.\n+ */\n+@Configuration\n+@ConditionalOnBean(Server.class)\n+@ConditionalOnClass(ArmeriaBeanPostProcessor.class)\n+public class ArmeriaBeanPostProcessorConfiguration {\n+\n+    /**\n+     * Create a {@link ArmeriaBeanPostProcessor} bean.", "originalCommit": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1MDQyOQ==", "url": "https://github.com/line/armeria/pull/2684#discussion_r419950429", "bodyText": "Fixed 568291b", "author": "heowc", "createdAt": "2020-05-05T08:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1NTU4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1NzE5NA==", "url": "https://github.com/line/armeria/pull/2684#discussion_r419257194", "bodyText": "Isn't it fail if it throws an exception?", "author": "minwoox", "createdAt": "2020-05-04T07:35:55Z", "path": "spring/boot-autoconfigure/src/test/java/com/linecorp/armeria/spring/LocalArmeriaPortsTest.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.ActiveProfiles;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.spring.LocalArmeriaPortTest.TestConfiguration;\n+\n+/**\n+ * Tests for {@link LocalArmeriaPorts}.\n+ */\n+@RunWith(SpringRunner.class)\n+@SpringBootTest(classes = TestConfiguration.class)\n+@ActiveProfiles({ \"local\", \"autoConfTest\" })\n+@DirtiesContext\n+public class LocalArmeriaPortsTest {\n+\n+    @SpringBootApplication\n+    @Import(ArmeriaOkServiceConfiguration.class)\n+    static class TestConfiguration {\n+    }\n+\n+    @LocalArmeriaPorts\n+    private List<Integer> ports;\n+\n+    @Inject\n+    private Server server;\n+\n+    private String newUrl(String scheme, Integer port) {\n+        return scheme + \"://127.0.0.1:\" + port;\n+    }\n+\n+    @Test\n+    public void testPortConfiguration() throws Exception {\n+        final Collection<ServerPort> serverPorts = server.activePorts().values();\n+        assertThat(serverPorts).size().isEqualTo(ports.size());\n+        serverPorts.stream()\n+                   .map(sp -> sp.localAddress().getPort())\n+                   .forEach(port -> assertThat(ports).contains(port));\n+    }\n+\n+    @Test\n+    public void testHttpServiceRegistrationBean() {\n+        ports.forEach(port -> {\n+            try {\n+                final WebClient client = WebClient.of(newUrl(\"h1c\", port));\n+\n+                final HttpResponse response = client.get(\"/ok\");\n+\n+                final AggregatedHttpResponse res = response.aggregate().get();\n+                assertThat(res.status()).isEqualTo(HttpStatus.OK);\n+                assertThat(res.contentUtf8()).isEqualTo(\"ok\");\n+            } catch (Exception e) {\n+                // Ignored", "originalCommit": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5MzkxMg==", "url": "https://github.com/line/armeria/pull/2684#discussion_r419293912", "bodyText": "You don't need to catch an exception if iterate ports with:\nfor (port in ports) {\n    ...\n}", "author": "ikhoon", "createdAt": "2020-05-04T08:50:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1NzE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1NzU4Mg==", "url": "https://github.com/line/armeria/pull/2684#discussion_r419257582", "bodyText": "Not sure if it's simple or not, but how about adding a test case where this annotation is used on method?", "author": "minwoox", "createdAt": "2020-05-04T07:36:46Z", "path": "spring/boot-autoconfigure/src/test/java/com/linecorp/armeria/spring/LocalArmeriaPortTest.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.ActiveProfiles;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.spring.LocalArmeriaPortTest.TestConfiguration;\n+\n+/**\n+ * Tests for {@link LocalArmeriaPort}.\n+ */\n+@RunWith(SpringRunner.class)\n+@SpringBootTest(classes = TestConfiguration.class)\n+@ActiveProfiles({ \"local\", \"autoConfTest\" })\n+@DirtiesContext\n+public class LocalArmeriaPortTest {\n+\n+    @SpringBootApplication\n+    @Import(ArmeriaOkServiceConfiguration.class)\n+    static class TestConfiguration {\n+    }\n+\n+    @Inject\n+    private Server server;\n+\n+    @LocalArmeriaPort", "originalCommit": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1MTQ2NA==", "url": "https://github.com/line/armeria/pull/2684#discussion_r419951464", "bodyText": "Fixed 568291b.\nAnd I also wrote additional tests for https. \ud83d\ude09", "author": "heowc", "createdAt": "2020-05-05T08:42:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1NzU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI2MDc1OQ==", "url": "https://github.com/line/armeria/pull/2684#discussion_r419260759", "bodyText": "How about adding a module for common so that we can put duplicate logic in it? @trustin, @ikhoon", "author": "minwoox", "createdAt": "2020-05-04T07:44:12Z", "path": "spring/boot1-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaSpringBoot1BeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.core.Ordered;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * {@link BeanPostProcessor} implementation that autowires annotated fields, setter methods, and arbitrary\n+ * config methods. Such members to be injected are detected through annotations:\n+ * by default, {@link LocalArmeriaPort} and {@link LocalArmeriaPorts} annotations.\n+ *\n+ * <p>This class was created by referring to classes implementing\n+ * Spring's {@link InstantiationAwareBeanPostProcessor}.\n+ */\n+public class ArmeriaSpringBoot1BeanPostProcessor implements InstantiationAwareBeanPostProcessor, Ordered {", "originalCommit": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5MjQ4MA==", "url": "https://github.com/line/armeria/pull/2684#discussion_r419892480", "bodyText": "I agree. I think that will reduce unnecessary work such as copying files. \ud83d\ude04", "author": "heowc", "createdAt": "2020-05-05T06:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI2MDc1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5MDUwMA==", "url": "https://github.com/line/armeria/pull/2684#discussion_r419290500", "bodyText": "The meaning of SessionProtocol.NONE and usage are different.\nSessionProtocol.NONE does not represent a session protocol, is only used to get any local port using Server.activeLocalPort().\nWhat happen when a server is built with SessionProtocol.NONE?\nServer.builder()\n      .port(8080, SessionProtocol.NONE)\n      ...\nI think this is useful for building test cases. If then, how about making SessionProtocol.HTTP default?", "author": "ikhoon", "createdAt": "2020-05-04T08:44:48Z", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/LocalArmeriaPort.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import java.lang.annotation.Documented;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Specifies an active local port of an Armeria server.\n+ */\n+@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE })\n+@Retention(RetentionPolicy.RUNTIME)\n+@Documented\n+public @interface LocalArmeriaPort {\n+\n+    /**\n+     * Specifies the {@link SessionProtocol} to get the port from the {@link Server}.\n+     * If a user specify a default value, {@link Server#activeLocalPort()} is used.\n+     */\n+    SessionProtocol value() default SessionProtocol.NONE;", "originalCommit": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NjM2OQ==", "url": "https://github.com/line/armeria/pull/2684#discussion_r419896369", "bodyText": "Good idea! \ud83d\udc4d", "author": "heowc", "createdAt": "2020-05-05T06:47:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5MDUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE2NzEyMQ==", "url": "https://github.com/line/armeria/pull/2684#discussion_r420167121", "bodyText": "Fixed 98f2e75", "author": "heowc", "createdAt": "2020-05-05T14:46:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5MDUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyNTk0Ng==", "url": "https://github.com/line/armeria/pull/2684#discussion_r419325946", "bodyText": "Could we reuse this instance?", "author": "ikhoon", "createdAt": "2020-05-04T09:53:04Z", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.core.Ordered;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * {@link BeanPostProcessor} implementation that autowires annotated fields, setter methods, and arbitrary\n+ * config methods. Such members to be injected are detected through annotations:\n+ * by default, {@link LocalArmeriaPort} and {@link LocalArmeriaPorts} annotations.\n+ *\n+ * <p>This class was created by referring to classes implementing\n+ * Spring's {@link InstantiationAwareBeanPostProcessor}.\n+ */\n+public final class ArmeriaBeanPostProcessor implements InstantiationAwareBeanPostProcessor, Ordered {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final BeanFactory beanFactory;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return Ordered.LOWEST_PRECEDENCE - 2;\n+    }\n+\n+    /**\n+     * Post-processes the given property values before the factory apply them to the given bean.\n+     */\n+    @Override\n+    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n+        final InjectionMetadata metadata = findLocalArmeriaPortMetadata(beanName, bean.getClass(), pvs);\n+        try {\n+            metadata.inject(bean, beanName, pvs);\n+        } catch (Throwable ex) {\n+            throw new BeanCreationException(beanName, \"Injection of resource dependencies failed\", ex);\n+        }\n+        return pvs;\n+    }\n+\n+    private InjectionMetadata findLocalArmeriaPortMetadata(\n+            String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {\n+        final String cacheKey = StringUtils.hasLength(beanName) ? beanName : clazz.getName();\n+        InjectionMetadata metadata = injectionMetadataCache.get(cacheKey);\n+        if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+            synchronized (injectionMetadataCache) {\n+                metadata = injectionMetadataCache.get(cacheKey);\n+                if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+                    if (metadata != null) {\n+                        metadata.clear(pvs);\n+                    }\n+                    metadata = buildLocalArmeriaPortMetadata(clazz);\n+                    injectionMetadataCache.put(cacheKey, metadata);\n+                }\n+            }\n+        }\n+        return metadata;\n+    }\n+\n+    private InjectionMetadata buildLocalArmeriaPortMetadata(Class<?> clazz) {\n+        final List<InjectedElement> elements = new ArrayList<>();\n+        Class<?> targetClass = clazz;\n+\n+        do {\n+            final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();\n+\n+            ReflectionUtils.doWithLocalFields(targetClass, field -> {\n+                if (field.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotations are not supported on static fields\");\n+                    }\n+                    currElements.add(new LocalArmeriaPortElement(field, field, null));\n+                } else if (field.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotations are not supported on static fields\");\n+                    }\n+                    currElements.add(new LocalArmeriaPortsElement(field, null));\n+                }\n+            });\n+\n+            ReflectionUtils.doWithLocalMethods(targetClass, method -> {\n+                final Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\n+                if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {\n+                    return;\n+                }\n+                if (bridgedMethod.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotations are not supported on static methods\");\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortElement(method, bridgedMethod, pd));\n+                } else if (bridgedMethod.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotations are not supported on static methods\");\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortsElement(method, pd));\n+                }\n+            });\n+\n+            elements.addAll(0, currElements);\n+            targetClass = targetClass.getSuperclass();\n+        }\n+        while (targetClass != null && targetClass != Object.class);\n+\n+        return new InjectionMetadata(clazz, elements);\n+    }\n+\n+    /**\n+     * Class representing injection information about an annotated field\n+     * or setter method, supporting the {@link LocalArmeriaPort}.\n+     */\n+    private final class LocalArmeriaPortElement extends InjectionMetadata.InjectedElement {\n+\n+        private final int port;\n+\n+        private LocalArmeriaPortElement(Member member, AnnotatedElement ae, @Nullable PropertyDescriptor pd) {\n+            super(member, pd);\n+            final LocalArmeriaPort localArmeriaPort = ae.getAnnotation(LocalArmeriaPort.class);\n+            final SessionProtocol protocol = localArmeriaPort.value();\n+            final Server server = beanFactory.getBean(Server.class);", "originalCommit": "75ea69194b6f6bc8c34aae9d494d97d905d3eaa5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NTY0Mw==", "url": "https://github.com/line/armeria/pull/2684#discussion_r419895643", "bodyText": "Let's find a way to reuse it. In addition, it would be good to add a value toMap.", "author": "heowc", "createdAt": "2020-05-05T06:45:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyNTk0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE2NzAzOQ==", "url": "https://github.com/line/armeria/pull/2684#discussion_r420167039", "bodyText": "Fixed 98f2e75", "author": "heowc", "createdAt": "2020-05-05T14:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyNTk0Ng=="}], "type": "inlineReview"}, {"oid": "568291b2d18da3840817a52fdf588e5471f07cee", "url": "https://github.com/line/armeria/commit/568291b2d18da3840817a52fdf588e5471f07cee", "message": "Address comments by @minwoox", "committedDate": "2020-05-05T08:38:42Z", "type": "commit"}, {"oid": "98f2e7593b361b722f82189791bfc63abb40a719", "url": "https://github.com/line/armeria/commit/98f2e7593b361b722f82189791bfc63abb40a719", "message": "Address comments by @ikhoon", "committedDate": "2020-05-05T14:45:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzUxOA==", "url": "https://github.com/line/armeria/pull/2684#discussion_r420513518", "bodyText": "on the -> on a ?", "author": "trustin", "createdAt": "2020-05-06T02:28:34Z", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/AbstractArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.util.CollectionUtils;\n+import org.springframework.util.ReflectionUtils;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Abstract class for implementing ArmeriaBeanPostProcessor of boot-autoconfigure module\n+ * and ArmeriaSpringBoot1BeanPostProcessor of boot1-autoconfigure module.\n+ */\n+abstract class AbstractArmeriaBeanPostProcessor {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final Map<SessionProtocol, Integer> portCache =\n+            new ConcurrentHashMap<>(SessionProtocol.values().length);\n+\n+    private final List<Integer> portsCache = new CopyOnWriteArrayList<>();\n+\n+    private final BeanFactory beanFactory;\n+\n+    @Nullable\n+    private Server server;\n+\n+    AbstractArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    protected InjectionMetadata findLocalArmeriaPortMetadata(\n+            String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {\n+        final String cacheKey = Strings.isNullOrEmpty(beanName) ? beanName : clazz.getName();\n+        InjectionMetadata metadata = injectionMetadataCache.get(cacheKey);\n+        if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+            synchronized (injectionMetadataCache) {\n+                metadata = injectionMetadataCache.get(cacheKey);\n+                if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+                    if (metadata != null) {\n+                        metadata.clear(pvs);\n+                    }\n+                    metadata = buildLocalArmeriaPortMetadata(clazz);\n+                    injectionMetadataCache.put(cacheKey, metadata);\n+                }\n+            }\n+        }\n+        return metadata;\n+    }\n+\n+    private InjectionMetadata buildLocalArmeriaPortMetadata(Class<?> clazz) {\n+        final List<InjectedElement> elements = new ArrayList<>();\n+        Class<?> targetClass = clazz;\n+\n+        do {\n+            final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();\n+\n+            ReflectionUtils.doWithLocalFields(targetClass, field -> {\n+                if (field.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotation is not supported on the static field: \" +\n+                                field.getName());\n+                    }\n+                    currElements.add(new LocalArmeriaPortElement(field, field, null));\n+                } else if (field.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotation is not supported on the static field: \" +", "originalCommit": "98f2e7593b361b722f82189791bfc63abb40a719", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0OTU0NA==", "url": "https://github.com/line/armeria/pull/2684#discussion_r420549544", "bodyText": "Fixed 44dfcbd", "author": "heowc", "createdAt": "2020-05-06T05:15:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzgxMA==", "url": "https://github.com/line/armeria/pull/2684#discussion_r420513810", "bodyText": "on the static field -> on a static method", "author": "trustin", "createdAt": "2020-05-06T02:29:43Z", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/AbstractArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.util.CollectionUtils;\n+import org.springframework.util.ReflectionUtils;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Abstract class for implementing ArmeriaBeanPostProcessor of boot-autoconfigure module\n+ * and ArmeriaSpringBoot1BeanPostProcessor of boot1-autoconfigure module.\n+ */\n+abstract class AbstractArmeriaBeanPostProcessor {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final Map<SessionProtocol, Integer> portCache =\n+            new ConcurrentHashMap<>(SessionProtocol.values().length);\n+\n+    private final List<Integer> portsCache = new CopyOnWriteArrayList<>();\n+\n+    private final BeanFactory beanFactory;\n+\n+    @Nullable\n+    private Server server;\n+\n+    AbstractArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    protected InjectionMetadata findLocalArmeriaPortMetadata(\n+            String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {\n+        final String cacheKey = Strings.isNullOrEmpty(beanName) ? beanName : clazz.getName();\n+        InjectionMetadata metadata = injectionMetadataCache.get(cacheKey);\n+        if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+            synchronized (injectionMetadataCache) {\n+                metadata = injectionMetadataCache.get(cacheKey);\n+                if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+                    if (metadata != null) {\n+                        metadata.clear(pvs);\n+                    }\n+                    metadata = buildLocalArmeriaPortMetadata(clazz);\n+                    injectionMetadataCache.put(cacheKey, metadata);\n+                }\n+            }\n+        }\n+        return metadata;\n+    }\n+\n+    private InjectionMetadata buildLocalArmeriaPortMetadata(Class<?> clazz) {\n+        final List<InjectedElement> elements = new ArrayList<>();\n+        Class<?> targetClass = clazz;\n+\n+        do {\n+            final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();\n+\n+            ReflectionUtils.doWithLocalFields(targetClass, field -> {\n+                if (field.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotation is not supported on the static field: \" +\n+                                field.getName());\n+                    }\n+                    currElements.add(new LocalArmeriaPortElement(field, field, null));\n+                } else if (field.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotation is not supported on the static field: \" +\n+                                field.getName());\n+                    }\n+                    currElements.add(new LocalArmeriaPortsElement(field, null));\n+                }\n+            });\n+\n+            ReflectionUtils.doWithLocalMethods(targetClass, method -> {\n+                final Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\n+                if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {\n+                    return;\n+                }\n+                if (bridgedMethod.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotation is not supported on the static field: \" +\n+                                method.getName());\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortElement(method, bridgedMethod, pd));\n+                } else if (bridgedMethod.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotation is not supported on the static field: \" +", "originalCommit": "98f2e7593b361b722f82189791bfc63abb40a719", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0ODM5Nw==", "url": "https://github.com/line/armeria/pull/2684#discussion_r420548397", "bodyText": "Oops... it's my mistake.", "author": "heowc", "createdAt": "2020-05-06T05:11:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzgxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0OTUwOA==", "url": "https://github.com/line/armeria/pull/2684#discussion_r420549508", "bodyText": "Fixed 44dfcbd", "author": "heowc", "createdAt": "2020-05-06T05:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzgxMA=="}], "type": "inlineReview"}, {"oid": "44dfcbd148d0e95d165400058b87de945ceea269", "url": "https://github.com/line/armeria/commit/44dfcbd148d0e95d165400058b87de945ceea269", "message": "Address comments by @trustin", "committedDate": "2020-05-06T05:11:56Z", "type": "commit"}, {"oid": "be30ae3ec38daac76252803045fc97fda2c4e4ed", "url": "https://github.com/line/armeria/commit/be30ae3ec38daac76252803045fc97fda2c4e4ed", "message": "Remove `Ordered`", "committedDate": "2020-05-06T09:16:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg3NTg0NQ==", "url": "https://github.com/line/armeria/pull/2684#discussion_r421875845", "bodyText": "nit: a -> an", "author": "minwoox", "createdAt": "2020-05-08T00:53:25Z", "path": "spring/boot1-autoconfigure/src/main/java/com/linecorp/armeria/spring/ArmeriaSpringBoot1BeanPostProcessorConfiguration.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.spring;\n+\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Spring Boot {@link Configuration} that provides Armeria integration.\n+ */\n+@Configuration\n+@ConditionalOnBean(Server.class)\n+public class ArmeriaSpringBoot1BeanPostProcessorConfiguration {\n+\n+    /**\n+     * Create a {@link ArmeriaSpringBoot1BeanPostProcessor} bean.", "originalCommit": "be30ae3ec38daac76252803045fc97fda2c4e4ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5MDg5NA==", "url": "https://github.com/line/armeria/pull/2684#discussion_r421890894", "bodyText": "Fixed 27bf859", "author": "heowc", "createdAt": "2020-05-08T01:48:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg3NTg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg4MjA5Mg==", "url": "https://github.com/line/armeria/pull/2684#discussion_r421882092", "bodyText": "Could it be just portsCache.isEmpty?", "author": "minwoox", "createdAt": "2020-05-08T01:15:48Z", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/AbstractArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.util.CollectionUtils;\n+import org.springframework.util.ReflectionUtils;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Abstract class for implementing ArmeriaBeanPostProcessor of boot-autoconfigure module\n+ * and ArmeriaSpringBoot1BeanPostProcessor of boot1-autoconfigure module.\n+ */\n+abstract class AbstractArmeriaBeanPostProcessor {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final Map<SessionProtocol, Integer> portCache =\n+            new ConcurrentHashMap<>(SessionProtocol.values().length);\n+\n+    private final List<Integer> portsCache = new CopyOnWriteArrayList<>();\n+\n+    private final BeanFactory beanFactory;\n+\n+    @Nullable\n+    private Server server;\n+\n+    AbstractArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    protected InjectionMetadata findLocalArmeriaPortMetadata(\n+            String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {\n+        final String cacheKey = Strings.isNullOrEmpty(beanName) ? beanName : clazz.getName();\n+        InjectionMetadata metadata = injectionMetadataCache.get(cacheKey);\n+        if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+            synchronized (injectionMetadataCache) {\n+                metadata = injectionMetadataCache.get(cacheKey);\n+                if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+                    if (metadata != null) {\n+                        metadata.clear(pvs);\n+                    }\n+                    metadata = buildLocalArmeriaPortMetadata(clazz);\n+                    injectionMetadataCache.put(cacheKey, metadata);\n+                }\n+            }\n+        }\n+        return metadata;\n+    }\n+\n+    private InjectionMetadata buildLocalArmeriaPortMetadata(Class<?> clazz) {\n+        final List<InjectedElement> elements = new ArrayList<>();\n+        Class<?> targetClass = clazz;\n+\n+        do {\n+            final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();\n+\n+            ReflectionUtils.doWithLocalFields(targetClass, field -> {\n+                if (field.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotation is not supported on a static field: \" +\n+                                field.getName());\n+                    }\n+                    currElements.add(new LocalArmeriaPortElement(field, field, null));\n+                } else if (field.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotation is not supported on a static field: \" +\n+                                field.getName());\n+                    }\n+                    currElements.add(new LocalArmeriaPortsElement(field, null));\n+                }\n+            });\n+\n+            ReflectionUtils.doWithLocalMethods(targetClass, method -> {\n+                final Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\n+                if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {\n+                    return;\n+                }\n+                if (bridgedMethod.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotation is not supported on a static method: \" +\n+                                method.getName());\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortElement(method, bridgedMethod, pd));\n+                } else if (bridgedMethod.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotation is not supported on a static method: \" +\n+                                method.getName());\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortsElement(method, pd));\n+                }\n+            });\n+\n+            elements.addAll(0, currElements);\n+            targetClass = targetClass.getSuperclass();\n+        }\n+        while (targetClass != null && targetClass != Object.class);\n+\n+        return new InjectionMetadata(clazz, elements);\n+    }\n+\n+    private void serServer(Server server) {\n+        this.server = requireNonNull(server, \"server\");\n+    }\n+\n+    @Nullable\n+    private Server getServer() {\n+        return server;\n+    }\n+\n+    /**\n+     * Class representing injection information about an annotated field\n+     * or setter method, supporting the {@link LocalArmeriaPort}.\n+     */\n+    private final class LocalArmeriaPortElement extends InjectionMetadata.InjectedElement {\n+\n+        private final int port;\n+\n+        private LocalArmeriaPortElement(Member member, AnnotatedElement ae, @Nullable PropertyDescriptor pd) {\n+            super(member, pd);\n+            final LocalArmeriaPort localArmeriaPort = ae.getAnnotation(LocalArmeriaPort.class);\n+            final SessionProtocol protocol = localArmeriaPort.value();\n+            Server server = getServer();\n+            if (server == null) {\n+                server = beanFactory.getBean(Server.class);\n+                serServer(server);\n+            }\n+\n+            Integer port = portCache.get(protocol);\n+            if (port == null) {\n+                port = server.activeLocalPort(protocol);\n+                portCache.put(protocol, port);\n+            }\n+            this.port = port;\n+        }\n+\n+        /**\n+         * Resolve the object against the application context.\n+         */\n+        @Override\n+        protected Object getResourceToInject(Object target, @Nullable String requestingBeanName) {\n+            return port;\n+        }\n+    }\n+\n+    /**\n+     * Class representing injection information about an annotated field\n+     * or setter method, supporting the {@link LocalArmeriaPorts}.\n+     */\n+    private final class LocalArmeriaPortsElement extends InjectionMetadata.InjectedElement {\n+\n+        private final List<Integer> ports;\n+\n+        private LocalArmeriaPortsElement(Member member, @Nullable PropertyDescriptor pd) {\n+            super(member, pd);\n+            Server server = getServer();\n+            if (server == null) {\n+                server = beanFactory.getBean(Server.class);\n+                serServer(server);\n+            }\n+\n+            final Builder<Integer> ports = ImmutableList.builder();\n+            if (CollectionUtils.isEmpty(portsCache)) {", "originalCommit": "be30ae3ec38daac76252803045fc97fda2c4e4ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5MDkwOQ==", "url": "https://github.com/line/armeria/pull/2684#discussion_r421890909", "bodyText": "Fixed 27bf859", "author": "heowc", "createdAt": "2020-05-08T01:48:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg4MjA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg4MjEzMg==", "url": "https://github.com/line/armeria/pull/2684#discussion_r421882132", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-05-08T01:15:54Z", "path": "spring/boot-autoconfigure/src/main/java/com/linecorp/armeria/spring/AbstractArmeriaBeanPostProcessor.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import javax.annotation.Nullable;\n+\n+import org.springframework.beans.BeanUtils;\n+import org.springframework.beans.PropertyValues;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.annotation.InjectionMetadata;\n+import org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement;\n+import org.springframework.core.BridgeMethodResolver;\n+import org.springframework.util.CollectionUtils;\n+import org.springframework.util.ReflectionUtils;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+\n+/**\n+ * Abstract class for implementing ArmeriaBeanPostProcessor of boot-autoconfigure module\n+ * and ArmeriaSpringBoot1BeanPostProcessor of boot1-autoconfigure module.\n+ */\n+abstract class AbstractArmeriaBeanPostProcessor {\n+\n+    private final Map<String, InjectionMetadata> injectionMetadataCache = new ConcurrentHashMap<>(256);\n+\n+    private final Map<SessionProtocol, Integer> portCache =\n+            new ConcurrentHashMap<>(SessionProtocol.values().length);\n+\n+    private final List<Integer> portsCache = new CopyOnWriteArrayList<>();\n+\n+    private final BeanFactory beanFactory;\n+\n+    @Nullable\n+    private Server server;\n+\n+    AbstractArmeriaBeanPostProcessor(BeanFactory beanFactory) {\n+        this.beanFactory = requireNonNull(beanFactory, \"beanFactory\");\n+    }\n+\n+    protected InjectionMetadata findLocalArmeriaPortMetadata(\n+            String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {\n+        final String cacheKey = Strings.isNullOrEmpty(beanName) ? beanName : clazz.getName();\n+        InjectionMetadata metadata = injectionMetadataCache.get(cacheKey);\n+        if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+            synchronized (injectionMetadataCache) {\n+                metadata = injectionMetadataCache.get(cacheKey);\n+                if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n+                    if (metadata != null) {\n+                        metadata.clear(pvs);\n+                    }\n+                    metadata = buildLocalArmeriaPortMetadata(clazz);\n+                    injectionMetadataCache.put(cacheKey, metadata);\n+                }\n+            }\n+        }\n+        return metadata;\n+    }\n+\n+    private InjectionMetadata buildLocalArmeriaPortMetadata(Class<?> clazz) {\n+        final List<InjectedElement> elements = new ArrayList<>();\n+        Class<?> targetClass = clazz;\n+\n+        do {\n+            final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();\n+\n+            ReflectionUtils.doWithLocalFields(targetClass, field -> {\n+                if (field.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotation is not supported on a static field: \" +\n+                                field.getName());\n+                    }\n+                    currElements.add(new LocalArmeriaPortElement(field, field, null));\n+                } else if (field.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(field.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotation is not supported on a static field: \" +\n+                                field.getName());\n+                    }\n+                    currElements.add(new LocalArmeriaPortsElement(field, null));\n+                }\n+            });\n+\n+            ReflectionUtils.doWithLocalMethods(targetClass, method -> {\n+                final Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\n+                if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {\n+                    return;\n+                }\n+                if (bridgedMethod.isAnnotationPresent(LocalArmeriaPort.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPort annotation is not supported on a static method: \" +\n+                                method.getName());\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortElement(method, bridgedMethod, pd));\n+                } else if (bridgedMethod.isAnnotationPresent(LocalArmeriaPorts.class)) {\n+                    if (Modifier.isStatic(method.getModifiers())) {\n+                        throw new IllegalStateException(\n+                                \"LocalArmeriaPorts annotation is not supported on a static method: \" +\n+                                method.getName());\n+                    }\n+                    final PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n+                    currElements.add(new LocalArmeriaPortsElement(method, pd));\n+                }\n+            });\n+\n+            elements.addAll(0, currElements);\n+            targetClass = targetClass.getSuperclass();\n+        }\n+        while (targetClass != null && targetClass != Object.class);\n+\n+        return new InjectionMetadata(clazz, elements);\n+    }\n+\n+    private void serServer(Server server) {\n+        this.server = requireNonNull(server, \"server\");\n+    }\n+\n+    @Nullable\n+    private Server getServer() {\n+        return server;\n+    }\n+\n+    /**\n+     * Class representing injection information about an annotated field\n+     * or setter method, supporting the {@link LocalArmeriaPort}.\n+     */\n+    private final class LocalArmeriaPortElement extends InjectionMetadata.InjectedElement {\n+\n+        private final int port;\n+\n+        private LocalArmeriaPortElement(Member member, AnnotatedElement ae, @Nullable PropertyDescriptor pd) {\n+            super(member, pd);\n+            final LocalArmeriaPort localArmeriaPort = ae.getAnnotation(LocalArmeriaPort.class);\n+            final SessionProtocol protocol = localArmeriaPort.value();\n+            Server server = getServer();\n+            if (server == null) {\n+                server = beanFactory.getBean(Server.class);\n+                serServer(server);\n+            }\n+\n+            Integer port = portCache.get(protocol);\n+            if (port == null) {\n+                port = server.activeLocalPort(protocol);\n+                portCache.put(protocol, port);\n+            }\n+            this.port = port;\n+        }\n+\n+        /**\n+         * Resolve the object against the application context.\n+         */\n+        @Override\n+        protected Object getResourceToInject(Object target, @Nullable String requestingBeanName) {\n+            return port;\n+        }\n+    }\n+\n+    /**\n+     * Class representing injection information about an annotated field\n+     * or setter method, supporting the {@link LocalArmeriaPorts}.\n+     */\n+    private final class LocalArmeriaPortsElement extends InjectionMetadata.InjectedElement {\n+\n+        private final List<Integer> ports;\n+\n+        private LocalArmeriaPortsElement(Member member, @Nullable PropertyDescriptor pd) {\n+            super(member, pd);\n+            Server server = getServer();\n+            if (server == null) {\n+                server = beanFactory.getBean(Server.class);\n+                serServer(server);\n+            }\n+\n+            final Builder<Integer> ports = ImmutableList.builder();\n+            if (CollectionUtils.isEmpty(portsCache)) {\n+                synchronized (portsCache) {\n+                    if (CollectionUtils.isEmpty(portsCache)) {", "originalCommit": "be30ae3ec38daac76252803045fc97fda2c4e4ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5MDkyMg==", "url": "https://github.com/line/armeria/pull/2684#discussion_r421890922", "bodyText": "Fixed 27bf859", "author": "heowc", "createdAt": "2020-05-08T01:48:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg4MjEzMg=="}], "type": "inlineReview"}, {"oid": "27bf859aac7ccfac2eda5a34324f945e41b32351", "url": "https://github.com/line/armeria/commit/27bf859aac7ccfac2eda5a34324f945e41b32351", "message": "Address comments by @minwoox", "committedDate": "2020-05-08T01:47:58Z", "type": "commit"}, {"oid": "b52132ec8dbd6fee299a8b51e00aa740bc2ff09d", "url": "https://github.com/line/armeria/commit/b52132ec8dbd6fee299a8b51e00aa740bc2ff09d", "message": "Merge branch 'master' into suport_localarmeriaports", "committedDate": "2020-05-09T07:32:32Z", "type": "commit"}]}