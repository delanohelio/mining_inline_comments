{"pr_number": 2701, "pr_title": "Support Eureka service discovery", "pr_createdAt": "2020-05-11T13:51:34Z", "pr_url": "https://github.com/line/armeria/pull/2701", "timeline": [{"oid": "0241e2075f6c5f6ef7ee49443e4a2a2072ebf0a6", "url": "https://github.com/line/armeria/commit/0241e2075f6c5f6ef7ee49443e4a2a2072ebf0a6", "message": "Support Eureka service discovery\nMotivation:\nIt will be nice if a user can easily do the service discovery using Eureka.\n\nModifications:\n- Add `EurekEndointGroup` and `EurekaUpdatingListerner`.\n\nResult:\n- You can now use Eureka for service discovery with Ameria server and client.\n\nTo-do:\n- Support Eureka service discovery using a property file so that Spring users can easily migrate.\n- Add document.", "committedDate": "2020-05-11T13:51:13Z", "type": "commit"}, {"oid": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "url": "https://github.com/line/armeria/commit/e1d86e7bd8c552ecae204805938154c69c7f5b47", "message": "Fix javadoc and add license", "committedDate": "2020-05-12T03:58:23Z", "type": "commit"}, {"oid": "d5d24441f103a0998e3afef22e39bcce8d26dd36", "url": "https://github.com/line/armeria/commit/d5d24441f103a0998e3afef22e39bcce8d26dd36", "message": "Add test case", "committedDate": "2020-05-12T06:48:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5NzM1MQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423497351", "bodyText": "You need to respect content.length().", "author": "trustin", "createdAt": "2020-05-12T06:44:39Z", "path": "eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.eureka;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.WebClientBuilder;\n+import com.linecorp.armeria.client.endpoint.DynamicEndpointGroup;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaTypeNames;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n+import com.linecorp.armeria.internal.common.eureka.Application;\n+import com.linecorp.armeria.internal.common.eureka.Applications;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.eureka.EurekaUpdatingListener;\n+\n+import io.netty.channel.EventLoop;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A Eureka-based {@link EndpointGroup} implementation. This {@link EndpointGroup} retrieves the list of\n+ * {@link Endpoint}s from a Eureka registry.\n+ *\n+ * @see EurekaUpdatingListener\n+ */\n+public final class EurekaEndpointGroup extends DynamicEndpointGroup {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaEndpointGroup.class);\n+\n+    private static final ObjectMapper mapper =\n+            new ObjectMapper().enable(DeserializationFeature.UNWRAP_ROOT_VALUE)\n+                              .setSerializationInclusion(Include.NON_NULL);\n+\n+    private static final Predicate<InstanceInfo> allInstances = instanceInfo -> true;\n+\n+    private static final String APPS = \"/apps\";\n+    private static final String VIPS = \"/vips/\";\n+    private static final String SVIPS = \"/svips/\";\n+    private static final String INSTANCES = \"/instances/\";\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(String eurekaUri) {\n+        return of(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri).build();\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(String eurekaUri) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri);\n+    }\n+\n+    private final long registryFetchIntervalSeconds;\n+\n+    private final RequestHeaders requestHeaders;\n+    private final Function<byte[], List<Endpoint>> responseConverter;\n+    private final WebClient webClient;\n+    @Nullable\n+    private volatile ScheduledFuture<?> scheduledFuture;\n+    private volatile boolean closed;\n+\n+    EurekaEndpointGroup(URI eurekaUri, long registryFetchIntervalSeconds, @Nullable String appName,\n+                        @Nullable String instanceId, @Nullable String vipAddress,\n+                        @Nullable String secureVipAddress, @Nullable List<String> regions,\n+                        @Nullable Consumer<WebClientBuilder> customizer) {\n+        this.registryFetchIntervalSeconds = registryFetchIntervalSeconds;\n+\n+        final RequestHeadersBuilder headersBuilder = RequestHeaders.builder();\n+        headersBuilder.method(HttpMethod.GET);\n+        headersBuilder.add(HttpHeaderNames.ACCEPT, MediaTypeNames.JSON_UTF_8);\n+        responseConverter = responseConverter(headersBuilder, appName, instanceId,\n+                                              vipAddress, secureVipAddress, regions);\n+        requestHeaders = headersBuilder.build();\n+\n+        final WebClientBuilder webClientBuilder = WebClient.builder(eurekaUri);\n+        if (customizer != null) {\n+            customizer.accept(webClientBuilder);\n+        }\n+        webClient = webClientBuilder.build();\n+        webClient.options().factory().whenClosed().thenRun(this::closeAsync);\n+        fetchRegistry();\n+    }\n+\n+    private void fetchRegistry() {\n+        final HttpResponse response;\n+        final ClientRequestContext ctx;\n+        try (ClientRequestContextCaptor captor = Clients.newContextCaptor()) {\n+            response = webClient.execute(requestHeaders);\n+            ctx = captor.get();\n+        }\n+\n+        final EventLoop eventLoop = ctx.eventLoop();\n+        response.aggregateWithPooledObjects(eventLoop, ctx.alloc()).handle((aggregatedRes, cause) -> {\n+            try {\n+                if (closed) {\n+                    return null;\n+                }\n+                if (cause != null) {\n+                    logger.warn(\"Unexpected exception while fetching the registry from: {}.\" +\n+                                \" (requestHeaders: {})\", webClient.uri(), requestHeaders, cause);\n+                } else {\n+                    final HttpStatus status = aggregatedRes.status();\n+                    if (!status.isSuccess()) {\n+                        logger.warn(\"Unexpected response from: {}. (status: {}, content: {}, \" +\n+                                    \"requestHeaders: {})\", webClient.uri(), status,\n+                                    aggregatedRes.contentUtf8(), requestHeaders);\n+                    } else {\n+                        final HttpData content = aggregatedRes.content();\n+                        try {\n+                            final List<Endpoint> endpoints = responseConverter.apply(content.array());", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYyNDM2MQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423624361", "bodyText": "As we had a chat, content.array() has the regulation in which the length of the returned byte[] should be equal to the content.length().", "author": "minwoox", "createdAt": "2020-05-12T10:19:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5NzM1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5NzQ4Mg==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423497482", "bodyText": "Probably an overkill to use with pooled objects?", "author": "trustin", "createdAt": "2020-05-12T06:44:58Z", "path": "eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.eureka;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.WebClientBuilder;\n+import com.linecorp.armeria.client.endpoint.DynamicEndpointGroup;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaTypeNames;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n+import com.linecorp.armeria.internal.common.eureka.Application;\n+import com.linecorp.armeria.internal.common.eureka.Applications;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.eureka.EurekaUpdatingListener;\n+\n+import io.netty.channel.EventLoop;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A Eureka-based {@link EndpointGroup} implementation. This {@link EndpointGroup} retrieves the list of\n+ * {@link Endpoint}s from a Eureka registry.\n+ *\n+ * @see EurekaUpdatingListener\n+ */\n+public final class EurekaEndpointGroup extends DynamicEndpointGroup {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaEndpointGroup.class);\n+\n+    private static final ObjectMapper mapper =\n+            new ObjectMapper().enable(DeserializationFeature.UNWRAP_ROOT_VALUE)\n+                              .setSerializationInclusion(Include.NON_NULL);\n+\n+    private static final Predicate<InstanceInfo> allInstances = instanceInfo -> true;\n+\n+    private static final String APPS = \"/apps\";\n+    private static final String VIPS = \"/vips/\";\n+    private static final String SVIPS = \"/svips/\";\n+    private static final String INSTANCES = \"/instances/\";\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(String eurekaUri) {\n+        return of(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri).build();\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(String eurekaUri) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri);\n+    }\n+\n+    private final long registryFetchIntervalSeconds;\n+\n+    private final RequestHeaders requestHeaders;\n+    private final Function<byte[], List<Endpoint>> responseConverter;\n+    private final WebClient webClient;\n+    @Nullable\n+    private volatile ScheduledFuture<?> scheduledFuture;\n+    private volatile boolean closed;\n+\n+    EurekaEndpointGroup(URI eurekaUri, long registryFetchIntervalSeconds, @Nullable String appName,\n+                        @Nullable String instanceId, @Nullable String vipAddress,\n+                        @Nullable String secureVipAddress, @Nullable List<String> regions,\n+                        @Nullable Consumer<WebClientBuilder> customizer) {\n+        this.registryFetchIntervalSeconds = registryFetchIntervalSeconds;\n+\n+        final RequestHeadersBuilder headersBuilder = RequestHeaders.builder();\n+        headersBuilder.method(HttpMethod.GET);\n+        headersBuilder.add(HttpHeaderNames.ACCEPT, MediaTypeNames.JSON_UTF_8);\n+        responseConverter = responseConverter(headersBuilder, appName, instanceId,\n+                                              vipAddress, secureVipAddress, regions);\n+        requestHeaders = headersBuilder.build();\n+\n+        final WebClientBuilder webClientBuilder = WebClient.builder(eurekaUri);\n+        if (customizer != null) {\n+            customizer.accept(webClientBuilder);\n+        }\n+        webClient = webClientBuilder.build();\n+        webClient.options().factory().whenClosed().thenRun(this::closeAsync);\n+        fetchRegistry();\n+    }\n+\n+    private void fetchRegistry() {\n+        final HttpResponse response;\n+        final ClientRequestContext ctx;\n+        try (ClientRequestContextCaptor captor = Clients.newContextCaptor()) {\n+            response = webClient.execute(requestHeaders);\n+            ctx = captor.get();\n+        }\n+\n+        final EventLoop eventLoop = ctx.eventLoop();\n+        response.aggregateWithPooledObjects(eventLoop, ctx.alloc()).handle((aggregatedRes, cause) -> {", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzNDkwMw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423534903", "bodyText": "Others two clients would be overkill, but this one has pretty much a lot of content.\nIsn't it better to use alloc instead of creating byte array in this case? This is not a streaming response. so the byte buffer will be released soon. \ud83e\udd14", "author": "minwoox", "createdAt": "2020-05-12T07:55:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5NzQ4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1NTc1Ng==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423555756", "bodyText": "I see. No problem then. \ud83d\udc4d", "author": "trustin", "createdAt": "2020-05-12T08:29:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5NzQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5NzcxOQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423497719", "bodyText": "parsing a response", "author": "trustin", "createdAt": "2020-05-12T06:45:29Z", "path": "eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.eureka;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.WebClientBuilder;\n+import com.linecorp.armeria.client.endpoint.DynamicEndpointGroup;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaTypeNames;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n+import com.linecorp.armeria.internal.common.eureka.Application;\n+import com.linecorp.armeria.internal.common.eureka.Applications;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.eureka.EurekaUpdatingListener;\n+\n+import io.netty.channel.EventLoop;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A Eureka-based {@link EndpointGroup} implementation. This {@link EndpointGroup} retrieves the list of\n+ * {@link Endpoint}s from a Eureka registry.\n+ *\n+ * @see EurekaUpdatingListener\n+ */\n+public final class EurekaEndpointGroup extends DynamicEndpointGroup {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaEndpointGroup.class);\n+\n+    private static final ObjectMapper mapper =\n+            new ObjectMapper().enable(DeserializationFeature.UNWRAP_ROOT_VALUE)\n+                              .setSerializationInclusion(Include.NON_NULL);\n+\n+    private static final Predicate<InstanceInfo> allInstances = instanceInfo -> true;\n+\n+    private static final String APPS = \"/apps\";\n+    private static final String VIPS = \"/vips/\";\n+    private static final String SVIPS = \"/svips/\";\n+    private static final String INSTANCES = \"/instances/\";\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(String eurekaUri) {\n+        return of(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri).build();\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(String eurekaUri) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri);\n+    }\n+\n+    private final long registryFetchIntervalSeconds;\n+\n+    private final RequestHeaders requestHeaders;\n+    private final Function<byte[], List<Endpoint>> responseConverter;\n+    private final WebClient webClient;\n+    @Nullable\n+    private volatile ScheduledFuture<?> scheduledFuture;\n+    private volatile boolean closed;\n+\n+    EurekaEndpointGroup(URI eurekaUri, long registryFetchIntervalSeconds, @Nullable String appName,\n+                        @Nullable String instanceId, @Nullable String vipAddress,\n+                        @Nullable String secureVipAddress, @Nullable List<String> regions,\n+                        @Nullable Consumer<WebClientBuilder> customizer) {\n+        this.registryFetchIntervalSeconds = registryFetchIntervalSeconds;\n+\n+        final RequestHeadersBuilder headersBuilder = RequestHeaders.builder();\n+        headersBuilder.method(HttpMethod.GET);\n+        headersBuilder.add(HttpHeaderNames.ACCEPT, MediaTypeNames.JSON_UTF_8);\n+        responseConverter = responseConverter(headersBuilder, appName, instanceId,\n+                                              vipAddress, secureVipAddress, regions);\n+        requestHeaders = headersBuilder.build();\n+\n+        final WebClientBuilder webClientBuilder = WebClient.builder(eurekaUri);\n+        if (customizer != null) {\n+            customizer.accept(webClientBuilder);\n+        }\n+        webClient = webClientBuilder.build();\n+        webClient.options().factory().whenClosed().thenRun(this::closeAsync);\n+        fetchRegistry();\n+    }\n+\n+    private void fetchRegistry() {\n+        final HttpResponse response;\n+        final ClientRequestContext ctx;\n+        try (ClientRequestContextCaptor captor = Clients.newContextCaptor()) {\n+            response = webClient.execute(requestHeaders);\n+            ctx = captor.get();\n+        }\n+\n+        final EventLoop eventLoop = ctx.eventLoop();\n+        response.aggregateWithPooledObjects(eventLoop, ctx.alloc()).handle((aggregatedRes, cause) -> {\n+            try {\n+                if (closed) {\n+                    return null;\n+                }\n+                if (cause != null) {\n+                    logger.warn(\"Unexpected exception while fetching the registry from: {}.\" +\n+                                \" (requestHeaders: {})\", webClient.uri(), requestHeaders, cause);\n+                } else {\n+                    final HttpStatus status = aggregatedRes.status();\n+                    if (!status.isSuccess()) {\n+                        logger.warn(\"Unexpected response from: {}. (status: {}, content: {}, \" +\n+                                    \"requestHeaders: {})\", webClient.uri(), status,\n+                                    aggregatedRes.contentUtf8(), requestHeaders);\n+                    } else {\n+                        final HttpData content = aggregatedRes.content();\n+                        try {\n+                            final List<Endpoint> endpoints = responseConverter.apply(content.array());\n+                            setEndpoints(endpoints);\n+                        } catch (Exception e) {\n+                            logger.warn(\"Unexpected exception while parsing response from: {}. \" +", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzNTc0Ng==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423535746", "bodyText": "Thanks!", "author": "minwoox", "createdAt": "2020-05-12T07:57:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5NzcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5OTI2Mg==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423499262", "bodyText": "Would it make sense to extend AbstractClientOptionsBuilder instead of exposing customizer(), like we did for ArmeriaRetrofitBuilder?", "author": "trustin", "createdAt": "2020-05-12T06:49:00Z", "path": "eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroupBuilder.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.eureka;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.URI;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.WebClientBuilder;\n+\n+/**\n+ * Builds a {@link EurekaEndpointGroup}.\n+ */\n+public final class EurekaEndpointGroupBuilder {", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0NzMxOA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423547318", "bodyText": "That's a good idea!", "author": "minwoox", "createdAt": "2020-05-12T08:16:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5OTI2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5OTgzMQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423499831", "bodyText": "Is there any chance this could be an arbitrary string?", "author": "trustin", "createdAt": "2020-05-12T06:50:15Z", "path": "eureka/src/main/java/com/linecorp/armeria/common/eureka/DataCenterName.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.eureka;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The data center names.\n+ */\n+public enum DataCenterName {\n+    Netflix,\n+    Amazon,\n+    MyOwn;", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzNzExMw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423537113", "bodyText": "I just followed the code. https://github.com/Netflix/eureka/blob/master/eureka-client/src/main/java/com/netflix/appinfo/DataCenterInfo.java#L35\nDo you think it's better to let a user just uses an arbitrary string?\ud83e\udd14", "author": "minwoox", "createdAt": "2020-05-12T07:59:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5OTgzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1NTUwMw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423555503", "bodyText": "I'd prefer allowing an arbitrary string because:\n\neven AWS has multiple DCs\nthere are more cloud providers than AWS nowadays.", "author": "trustin", "createdAt": "2020-05-12T08:29:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5OTgzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3MTYxNQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423571615", "bodyText": "Sounds good. Let me just use a String. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-05-12T08:53:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5OTgzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTAwNA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423501004", "bodyText": "This could be removed?", "author": "trustin", "createdAt": "2020-05-12T06:52:55Z", "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTI0MA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423501240", "bodyText": "This could be removed?\nderegisters", "author": "trustin", "createdAt": "2020-05-12T06:53:27Z", "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, This {@link EurekaUpdatingListener} deregister the", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzNzc3OQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423537779", "bodyText": "Thanks fixed. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-05-12T08:00:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTQ1Mg==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423501452", "bodyText": "a cancellation request?", "author": "trustin", "createdAt": "2020-05-12T06:53:59Z", "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, This {@link EurekaUpdatingListener} deregister the\n+ * {@link Server} from Eureka by sending the cancel request.", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTgxOA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423501818", "bodyText": "What's an instance ID? Is it possible to use the current hostname, IP address or some hashed value of them as the default instance ID?", "author": "trustin", "createdAt": "2020-05-12T06:54:46Z", "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, This {@link EurekaUpdatingListener} deregister the\n+ * {@link Server} from Eureka by sending the cancel request.\n+ */\n+public final class EurekaUpdatingListener extends ServerListenerAdapter {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaUpdatingListener.class);\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(String eurekaUri, String instanceId) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")), instanceId);", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzODQzNw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423538437", "bodyText": "instanceID is the unique id associated with the instance. In AWS cloud, instanceID is the instance id of the instance and in other data centers, it is the hostname of the instance.\nSo I guess we can just use the hostname when it's not specified. Thanks!", "author": "minwoox", "createdAt": "2020-05-12T08:01:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTgxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1NDEwMA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423554100", "bodyText": "Sounds good. Should we move the instanceId parameter to the builder API?", "author": "trustin", "createdAt": "2020-05-12T08:27:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTgxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2ODc4NA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423568784", "bodyText": "Should we move the instanceId parameter to the builder API?\n\nYes, I'm working on it. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-05-12T08:49:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTk1Nw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423501957", "bodyText": "Ditto - overkill?", "author": "trustin", "createdAt": "2020-05-12T06:55:01Z", "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, This {@link EurekaUpdatingListener} deregister the\n+ * {@link Server} from Eureka by sending the cancel request.\n+ */\n+public final class EurekaUpdatingListener extends ServerListenerAdapter {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaUpdatingListener.class);\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(String eurekaUri, String instanceId) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")), instanceId);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(URI eurekaUri, String instanceId) {\n+        return new EurekaUpdatingListenerBuilder(eurekaUri, instanceId);\n+    }\n+\n+    private final EurekaWebClient client;\n+    private final InstanceInfo instanceInfo;\n+    @Nullable\n+    private volatile ScheduledFuture<?> heartBeatFuture;\n+\n+    @Nullable\n+    private volatile String appName; // Set when serverStarted is called.\n+    private volatile boolean closed;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    EurekaUpdatingListener(EurekaWebClient client, InstanceInfo instanceInfo) {\n+        this.client = client;\n+        this.instanceInfo = instanceInfo;\n+    }\n+\n+    @Override\n+    public void serverStarted(Server server) throws Exception {\n+        final InstanceInfo newInfo = fillAndCreateNewInfo(instanceInfo, server);\n+\n+        try (ClientRequestContextCaptor contextCaptor = Clients.newContextCaptor()) {\n+            final HttpResponse response = client.register(newInfo);\n+            final ClientRequestContext ctx = contextCaptor.get();\n+            response.aggregateWithPooledObjects(ctx.eventLoop(), ctx.alloc()).handle((res, cause) -> {", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzODUyMw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423538523", "bodyText": "Yeah. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-05-12T08:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMjcyNw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423502727", "bodyText": "Would !...isSuccess() work here?", "author": "trustin", "createdAt": "2020-05-12T06:56:36Z", "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, This {@link EurekaUpdatingListener} deregister the\n+ * {@link Server} from Eureka by sending the cancel request.\n+ */\n+public final class EurekaUpdatingListener extends ServerListenerAdapter {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaUpdatingListener.class);\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(String eurekaUri, String instanceId) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")), instanceId);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(URI eurekaUri, String instanceId) {\n+        return new EurekaUpdatingListenerBuilder(eurekaUri, instanceId);\n+    }\n+\n+    private final EurekaWebClient client;\n+    private final InstanceInfo instanceInfo;\n+    @Nullable\n+    private volatile ScheduledFuture<?> heartBeatFuture;\n+\n+    @Nullable\n+    private volatile String appName; // Set when serverStarted is called.\n+    private volatile boolean closed;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    EurekaUpdatingListener(EurekaWebClient client, InstanceInfo instanceInfo) {\n+        this.client = client;\n+        this.instanceInfo = instanceInfo;\n+    }\n+\n+    @Override\n+    public void serverStarted(Server server) throws Exception {\n+        final InstanceInfo newInfo = fillAndCreateNewInfo(instanceInfo, server);\n+\n+        try (ClientRequestContextCaptor contextCaptor = Clients.newContextCaptor()) {\n+            final HttpResponse response = client.register(newInfo);\n+            final ClientRequestContext ctx = contextCaptor.get();\n+            response.aggregateWithPooledObjects(ctx.eventLoop(), ctx.alloc()).handle((res, cause) -> {\n+                if (closed) {\n+                    return null;\n+                }\n+                try {\n+                    if (cause != null) {\n+                        logger.warn(\"Failed to register {} to Eureka: {}\",\n+                                    newInfo.getHostName(), client.uri(), cause);\n+                        return null;\n+                    }\n+                    final ResponseHeaders headers = res.headers();\n+                    if (headers.status() != HttpStatus.NO_CONTENT) {", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0MDIzMg==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423540232", "bodyText": "Have thought about it, but I guess I wanted to be as specific as I could.\nNot strong on this, though. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-05-12T08:04:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMjcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1MzQxMw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423553413", "bodyText": "OK!", "author": "trustin", "createdAt": "2020-05-12T08:26:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMjcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMzE4Nw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423503187", "bodyText": "Curious if we need to renew the lease a little bit sooner than specified to avoid timing issues. Thoughts?", "author": "trustin", "createdAt": "2020-05-12T06:57:29Z", "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, This {@link EurekaUpdatingListener} deregister the\n+ * {@link Server} from Eureka by sending the cancel request.\n+ */\n+public final class EurekaUpdatingListener extends ServerListenerAdapter {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaUpdatingListener.class);\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(String eurekaUri, String instanceId) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")), instanceId);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(URI eurekaUri, String instanceId) {\n+        return new EurekaUpdatingListenerBuilder(eurekaUri, instanceId);\n+    }\n+\n+    private final EurekaWebClient client;\n+    private final InstanceInfo instanceInfo;\n+    @Nullable\n+    private volatile ScheduledFuture<?> heartBeatFuture;\n+\n+    @Nullable\n+    private volatile String appName; // Set when serverStarted is called.\n+    private volatile boolean closed;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    EurekaUpdatingListener(EurekaWebClient client, InstanceInfo instanceInfo) {\n+        this.client = client;\n+        this.instanceInfo = instanceInfo;\n+    }\n+\n+    @Override\n+    public void serverStarted(Server server) throws Exception {\n+        final InstanceInfo newInfo = fillAndCreateNewInfo(instanceInfo, server);\n+\n+        try (ClientRequestContextCaptor contextCaptor = Clients.newContextCaptor()) {\n+            final HttpResponse response = client.register(newInfo);\n+            final ClientRequestContext ctx = contextCaptor.get();\n+            response.aggregateWithPooledObjects(ctx.eventLoop(), ctx.alloc()).handle((res, cause) -> {\n+                if (closed) {\n+                    return null;\n+                }\n+                try {\n+                    if (cause != null) {\n+                        logger.warn(\"Failed to register {} to Eureka: {}\",\n+                                    newInfo.getHostName(), client.uri(), cause);\n+                        return null;\n+                    }\n+                    final ResponseHeaders headers = res.headers();\n+                    if (headers.status() != HttpStatus.NO_CONTENT) {\n+                        logger.warn(\"Failed to register {} to Eureka: {}. (status: {}, content: {})\",\n+                                    newInfo.getHostName(), client.uri(), headers.status(), res.contentUtf8());\n+                    }\n+                    logger.info(\"Registered {} to Eureka: {}\", newInfo.getHostName(), client.uri());\n+                    scheduleHeartBeat(ctx, newInfo);\n+                    return null;\n+                } finally {\n+                    ReferenceCountUtil.release(res.content());\n+                }\n+            });\n+        }\n+    }\n+\n+    private void scheduleHeartBeat(ClientRequestContext ctx, InstanceInfo newInfo) {\n+        heartBeatFuture = ctx.eventLoop().schedule(new HeartBeatTask(ctx, newInfo),\n+                                                   newInfo.getLeaseInfo().getRenewalIntervalInSecs(),", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0Mjg3Mw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423542873", "bodyText": "If a user uses default values (Eureka does not recommend to change the value), the renewal interval is 30 seconds and if Eureka does not see this heart beat in 90 seconds, the registry is removed. Also Eureka client does not have that logic. So I guess it's okay?", "author": "minwoox", "createdAt": "2020-05-12T08:09:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMzE4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1MzY3Nw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423553677", "bodyText": "I see. Then it's handled by the Eureka server. No problem.", "author": "trustin", "createdAt": "2020-05-12T08:26:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMzE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNDU2MQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423504561", "bodyText": "Ditto - overkill", "author": "trustin", "createdAt": "2020-05-12T07:00:18Z", "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, This {@link EurekaUpdatingListener} deregister the\n+ * {@link Server} from Eureka by sending the cancel request.\n+ */\n+public final class EurekaUpdatingListener extends ServerListenerAdapter {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaUpdatingListener.class);\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(String eurekaUri, String instanceId) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")), instanceId);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(URI eurekaUri, String instanceId) {\n+        return new EurekaUpdatingListenerBuilder(eurekaUri, instanceId);\n+    }\n+\n+    private final EurekaWebClient client;\n+    private final InstanceInfo instanceInfo;\n+    @Nullable\n+    private volatile ScheduledFuture<?> heartBeatFuture;\n+\n+    @Nullable\n+    private volatile String appName; // Set when serverStarted is called.\n+    private volatile boolean closed;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    EurekaUpdatingListener(EurekaWebClient client, InstanceInfo instanceInfo) {\n+        this.client = client;\n+        this.instanceInfo = instanceInfo;\n+    }\n+\n+    @Override\n+    public void serverStarted(Server server) throws Exception {\n+        final InstanceInfo newInfo = fillAndCreateNewInfo(instanceInfo, server);\n+\n+        try (ClientRequestContextCaptor contextCaptor = Clients.newContextCaptor()) {\n+            final HttpResponse response = client.register(newInfo);\n+            final ClientRequestContext ctx = contextCaptor.get();\n+            response.aggregateWithPooledObjects(ctx.eventLoop(), ctx.alloc()).handle((res, cause) -> {\n+                if (closed) {\n+                    return null;\n+                }\n+                try {\n+                    if (cause != null) {\n+                        logger.warn(\"Failed to register {} to Eureka: {}\",\n+                                    newInfo.getHostName(), client.uri(), cause);\n+                        return null;\n+                    }\n+                    final ResponseHeaders headers = res.headers();\n+                    if (headers.status() != HttpStatus.NO_CONTENT) {\n+                        logger.warn(\"Failed to register {} to Eureka: {}. (status: {}, content: {})\",\n+                                    newInfo.getHostName(), client.uri(), headers.status(), res.contentUtf8());\n+                    }\n+                    logger.info(\"Registered {} to Eureka: {}\", newInfo.getHostName(), client.uri());\n+                    scheduleHeartBeat(ctx, newInfo);\n+                    return null;\n+                } finally {\n+                    ReferenceCountUtil.release(res.content());\n+                }\n+            });\n+        }\n+    }\n+\n+    private void scheduleHeartBeat(ClientRequestContext ctx, InstanceInfo newInfo) {\n+        heartBeatFuture = ctx.eventLoop().schedule(new HeartBeatTask(ctx, newInfo),\n+                                                   newInfo.getLeaseInfo().getRenewalIntervalInSecs(),\n+                                                   TimeUnit.SECONDS);\n+    }\n+\n+    private InstanceInfo fillAndCreateNewInfo(InstanceInfo oldInfo, Server server) {\n+        final String defaultHostname = server.defaultHostname();\n+        final String hostName = oldInfo.getHostName() != null ? oldInfo.getHostName() : defaultHostname;\n+        appName = oldInfo.getAppName() != null ? oldInfo.getAppName() : defaultHostname;\n+\n+        final Inet4Address defaultInet4Address = SystemInfo.defaultNonLoopbackIpV4Address();\n+        final String defaultIpAddr = defaultInet4Address != null ? defaultInet4Address.getHostAddress()\n+                                                                 : null;\n+        final String ipAddr = oldInfo.getIpAddr() != null ? oldInfo.getIpAddr() : defaultIpAddr;\n+        final PortWrapper oldPortWrapper = oldInfo.getPort();\n+        final PortWrapper portWrapper = portWrapper(server, oldPortWrapper, SessionProtocol.HTTP);\n+        final PortWrapper oldSecurePortWrapper = oldInfo.getSecurePort();\n+        final PortWrapper securePortWrapper = portWrapper(server, oldSecurePortWrapper, SessionProtocol.HTTPS);\n+\n+        final String vipAddress = vipAddress(oldInfo.getVipAddress(), hostName, portWrapper);\n+        final String secureVipAddress = vipAddress(oldInfo.getSecureVipAddress(), hostName, securePortWrapper);\n+\n+        final Optional<ServiceConfig> healthCheckService =\n+                server.serviceConfigs()\n+                      .stream()\n+                      .filter(cfg -> cfg.service().as(HealthCheckService.class) != null)\n+                      .findFirst();\n+\n+        final String hostnameOrIpAddr;\n+        if (oldInfo.getHostName() != null) {\n+            hostnameOrIpAddr = oldInfo.getHostName();\n+        } else if (ipAddr != null) {\n+            hostnameOrIpAddr = ipAddr;\n+        } else {\n+            hostnameOrIpAddr = hostName;\n+        }\n+        final String healthCheckUrl = healthCheckUrl(hostnameOrIpAddr, oldInfo.getHealthCheckUrl(), portWrapper,\n+                                                     healthCheckService, SessionProtocol.HTTP);\n+        final String secureHealthCheckUrl =\n+                healthCheckUrl(hostnameOrIpAddr, oldInfo.getSecureHealthCheckUrl(), securePortWrapper,\n+                               healthCheckService, SessionProtocol.HTTPS);\n+\n+        return new InstanceInfo(oldInfo.getInstanceId(), appName, oldInfo.getAppGroupName(), hostName, ipAddr,\n+                                vipAddress, secureVipAddress, portWrapper, securePortWrapper, InstanceStatus.UP,\n+                                oldInfo.getHomePageUrl(), oldInfo.getStatusPageUrl(), healthCheckUrl,\n+                                secureHealthCheckUrl, oldInfo.getDataCenterInfo(),\n+                                oldInfo.getLeaseInfo(), oldInfo.getMetadata());\n+    }\n+\n+    private static PortWrapper portWrapper(Server server, PortWrapper oldPortWrapper,\n+                                           SessionProtocol protocol) {\n+        if (oldPortWrapper.isEnabled()) {\n+            for (ServerPort serverPort : server.activePorts().values()) {\n+                if (serverPort.hasProtocol(protocol) &&\n+                    serverPort.localAddress().getPort() == oldPortWrapper.getPort()) {\n+                    return oldPortWrapper;\n+                }\n+            }\n+            logger.warn(\"The port number: {} (expected one of activePorts: {})\",\n+                        oldPortWrapper.getPort(), server.activePorts());\n+        }\n+\n+        final ServerPort serverPort = server.activePort(protocol);\n+        if (serverPort == null) {\n+            return disabledPort;\n+        }\n+        return new PortWrapper(true, serverPort.localAddress().getPort());\n+    }\n+\n+    @Nullable\n+    private static String vipAddress(@Nullable String vipAddress, String hostName, PortWrapper portWrapper) {\n+        if (!portWrapper.isEnabled()) {\n+            return null;\n+        }\n+        return vipAddress != null ? vipAddress : hostName + ':' + portWrapper.getPort();\n+    }\n+\n+    @Nullable\n+    private static String healthCheckUrl(String hostnameOrIpAddr, @Nullable String oldHealthCheckUrl,\n+                                         PortWrapper portWrapper,\n+                                         Optional<ServiceConfig> healthCheckService,\n+                                         SessionProtocol sessionProtocol) {\n+        if (oldHealthCheckUrl != null) {\n+            return oldHealthCheckUrl;\n+        }\n+        if (!portWrapper.isEnabled() || !healthCheckService.isPresent()) {\n+            return null;\n+        }\n+        final ServiceConfig healthCheckServiceConfig = healthCheckService.get();\n+        final Route route = healthCheckServiceConfig.route();\n+        if (route.pathType() != RoutePathType.EXACT && route.pathType() != RoutePathType.PREFIX) {\n+            return null;\n+        }\n+\n+        return sessionProtocol.uriText() + \"://\" + hostnameOrIpAddr + ':' + portWrapper.getPort() +\n+               route.paths().get(0);\n+    }\n+\n+    @Override\n+    public void serverStopping(Server server) throws Exception {\n+        closed = true;\n+        final ScheduledFuture<?> heartBeatFuture = this.heartBeatFuture;\n+        if (heartBeatFuture != null) {\n+            heartBeatFuture.cancel(false);\n+        }\n+        final String appName = this.appName;\n+        if (appName != null) {\n+            client.cancel(appName, instanceInfo.getInstanceId()).aggregate().handle((res, cause) -> {\n+                if (cause != null) {\n+                    logger.warn(\"Failed to deregister from Eureka: {}\", client.uri(), cause);\n+                } else if (!res.status().isSuccess()) {\n+                    logger.warn(\"Failed to deregister from Eureka: {} (status: {}, content: {})\",\n+                                client.uri(), res.status(), res.contentUtf8());\n+                }\n+                return null;\n+            });\n+        }\n+    }\n+\n+    private class HeartBeatTask implements Runnable {\n+\n+        private final ClientRequestContext ctx;\n+        private final InstanceInfo instanceInfo;\n+\n+        HeartBeatTask(ClientRequestContext ctx, InstanceInfo instanceInfo) {\n+            this.ctx = ctx;\n+            this.instanceInfo = instanceInfo;\n+        }\n+\n+        @Override\n+        public void run() {\n+            final String appName = instanceInfo.getAppName();\n+            assert appName != null;\n+            client.sendHeartBeat(appName, instanceInfo.getInstanceId(), instanceInfo, null)\n+                  .aggregateWithPooledObjects(ctx.eventLoop(), ctx.alloc())", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "url": "https://github.com/line/armeria/commit/c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "message": "Address the comments by @trustin", "committedDate": "2020-05-12T10:17:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2NTY4MA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423665680", "bodyText": "Could replace with String.join(\",\", regions)?", "author": "ikhoon", "createdAt": "2020-05-12T11:38:57Z", "path": "eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/EurekaWebClient.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common.eureka;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.URI;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.google.common.collect.Iterables;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.MediaTypeNames;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+\n+/**\n+ * A Eureka {@link WebClient} which communicates to the\n+ * <a href=\"https://github.com/Netflix/eureka/wiki/Eureka-REST-operations\">Eureka registry</a>.\n+ */\n+public final class EurekaWebClient {\n+\n+    private static final String APPS = \"/apps/\";\n+    private static final String VIPS = \"/vips/\";\n+    private static final String SVIPS = \"/svips/\";\n+    private static final String INSTANCES = \"/instances/\";\n+\n+    private final WebClient webClient;\n+    private final ObjectMapper mapper = new ObjectMapper().enable(SerializationFeature.WRAP_ROOT_VALUE)\n+                                                          .setSerializationInclusion(Include.NON_NULL);\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public EurekaWebClient(WebClient webClient) {\n+        this.webClient = requireNonNull(webClient, \"webClient\");\n+    }\n+\n+    /**\n+     * Returns the {@link URI} of the Eureka registry.\n+     */\n+    public URI uri() {\n+        return webClient.uri();\n+    }\n+\n+    /**\n+     * Registers the specified {@link InstanceInfo} to the Eureka registry.\n+     */\n+    public HttpResponse register(InstanceInfo info) {\n+        requireNonNull(info, \"info\");\n+        final String path = APPS + info.getAppName();\n+        final RequestHeaders headers = RequestHeaders.builder(HttpMethod.POST, path)\n+                                                     .contentType(MediaType.JSON)\n+                                                     .build();\n+        try {\n+            return webClient.execute(headers, mapper.writeValueAsBytes(info));\n+        } catch (JsonProcessingException e) {\n+            return HttpResponse.ofFailure(e);\n+        }\n+    }\n+\n+    /**\n+     * Sends the heart beat to the Eureka registry.\n+     */\n+    public HttpResponse sendHeartBeat(String appName, String instanceId, InstanceInfo instanceInfo,\n+                                      @Nullable InstanceStatus overriddenStatus) {\n+        requireNonNull(appName, \"appName\");\n+        requireNonNull(instanceId, \"instanceId\");\n+        requireNonNull(instanceInfo, \"instanceInfo\");\n+        final String path = APPS + appName + '/' + instanceId;\n+        final QueryParamsBuilder queryBuilder =\n+                QueryParams.builder()\n+                           .add(\"status\", instanceInfo.getStatus().toString())\n+                           .addLong(\"lastDirtyTimestamp\", instanceInfo.getLastDirtyTimestamp());\n+        if (overriddenStatus != null) {\n+            queryBuilder.add(\"overriddenstatus\", overriddenStatus.toString());\n+        }\n+        final RequestHeaders headers =\n+                RequestHeaders.builder(HttpMethod.PUT, path + '?' + queryBuilder.toQueryString())\n+                              .add(HttpHeaderNames.ACCEPT, MediaTypeNames.JSON)\n+                              .build();\n+        return webClient.execute(headers);\n+    }\n+\n+    /**\n+     * Deregisters the specified {@code instanceId} in {@code appName} from the Eureka registry.\n+     */\n+    public HttpResponse cancel(String appName, String instanceId) {\n+        requireNonNull(appName, \"appName\");\n+        requireNonNull(instanceId, \"instanceId\");\n+        final String path = APPS + appName + '/' + instanceId;\n+        return webClient.delete(path);\n+    }\n+\n+    /**\n+     * Retrieves the registry information whose regions are the specified {@code regions} from the Eureka.\n+     */\n+    public HttpResponse getApplications(Iterable<String> regions) {\n+        return getApplications(APPS, requireNonNull(regions, \"regions\"));\n+    }\n+\n+    private HttpResponse getApplications(String path, Iterable<String> regions) {\n+        if (!Iterables.isEmpty(regions)) {\n+            final StringJoiner joiner = new StringJoiner(\",\");\n+            regions.forEach(joiner::add);", "originalCommit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzNTA1Mw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424135053", "bodyText": "Fixed. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-05-13T02:16:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2NTY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2ODI3NA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423668274", "bodyText": "I'd prefer deregister as this method name so that we can make consistency with register(InstanceInfo info).", "author": "ikhoon", "createdAt": "2020-05-12T11:44:06Z", "path": "eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/EurekaWebClient.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common.eureka;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.URI;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.google.common.collect.Iterables;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.MediaTypeNames;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+\n+/**\n+ * A Eureka {@link WebClient} which communicates to the\n+ * <a href=\"https://github.com/Netflix/eureka/wiki/Eureka-REST-operations\">Eureka registry</a>.\n+ */\n+public final class EurekaWebClient {\n+\n+    private static final String APPS = \"/apps/\";\n+    private static final String VIPS = \"/vips/\";\n+    private static final String SVIPS = \"/svips/\";\n+    private static final String INSTANCES = \"/instances/\";\n+\n+    private final WebClient webClient;\n+    private final ObjectMapper mapper = new ObjectMapper().enable(SerializationFeature.WRAP_ROOT_VALUE)\n+                                                          .setSerializationInclusion(Include.NON_NULL);\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public EurekaWebClient(WebClient webClient) {\n+        this.webClient = requireNonNull(webClient, \"webClient\");\n+    }\n+\n+    /**\n+     * Returns the {@link URI} of the Eureka registry.\n+     */\n+    public URI uri() {\n+        return webClient.uri();\n+    }\n+\n+    /**\n+     * Registers the specified {@link InstanceInfo} to the Eureka registry.\n+     */\n+    public HttpResponse register(InstanceInfo info) {\n+        requireNonNull(info, \"info\");\n+        final String path = APPS + info.getAppName();\n+        final RequestHeaders headers = RequestHeaders.builder(HttpMethod.POST, path)\n+                                                     .contentType(MediaType.JSON)\n+                                                     .build();\n+        try {\n+            return webClient.execute(headers, mapper.writeValueAsBytes(info));\n+        } catch (JsonProcessingException e) {\n+            return HttpResponse.ofFailure(e);\n+        }\n+    }\n+\n+    /**\n+     * Sends the heart beat to the Eureka registry.\n+     */\n+    public HttpResponse sendHeartBeat(String appName, String instanceId, InstanceInfo instanceInfo,\n+                                      @Nullable InstanceStatus overriddenStatus) {\n+        requireNonNull(appName, \"appName\");\n+        requireNonNull(instanceId, \"instanceId\");\n+        requireNonNull(instanceInfo, \"instanceInfo\");\n+        final String path = APPS + appName + '/' + instanceId;\n+        final QueryParamsBuilder queryBuilder =\n+                QueryParams.builder()\n+                           .add(\"status\", instanceInfo.getStatus().toString())\n+                           .addLong(\"lastDirtyTimestamp\", instanceInfo.getLastDirtyTimestamp());\n+        if (overriddenStatus != null) {\n+            queryBuilder.add(\"overriddenstatus\", overriddenStatus.toString());\n+        }\n+        final RequestHeaders headers =\n+                RequestHeaders.builder(HttpMethod.PUT, path + '?' + queryBuilder.toQueryString())\n+                              .add(HttpHeaderNames.ACCEPT, MediaTypeNames.JSON)\n+                              .build();\n+        return webClient.execute(headers);\n+    }\n+\n+    /**\n+     * Deregisters the specified {@code instanceId} in {@code appName} from the Eureka registry.\n+     */\n+    public HttpResponse cancel(String appName, String instanceId) {", "originalCommit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzNDU2Mw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424134563", "bodyText": "I used what they are using.\nhttps://github.com/Netflix/eureka/wiki/Understanding-eureka-client-server-communication#cancel\nhttps://github.com/Netflix/eureka/blob/master/eureka-client/src/main/java/com/netflix/discovery/shared/transport/EurekaHttpClient.java#L17", "author": "minwoox", "createdAt": "2020-05-13T02:14:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2ODI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0ODA4NA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424148084", "bodyText": "I see, then leave it as it is.", "author": "ikhoon", "createdAt": "2020-05-13T03:09:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2ODI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3MDI5OA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423670298", "bodyText": "Could be static?", "author": "ikhoon", "createdAt": "2020-05-12T11:47:54Z", "path": "eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/EurekaWebClient.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common.eureka;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.URI;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.google.common.collect.Iterables;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.MediaTypeNames;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+\n+/**\n+ * A Eureka {@link WebClient} which communicates to the\n+ * <a href=\"https://github.com/Netflix/eureka/wiki/Eureka-REST-operations\">Eureka registry</a>.\n+ */\n+public final class EurekaWebClient {\n+\n+    private static final String APPS = \"/apps/\";\n+    private static final String VIPS = \"/vips/\";\n+    private static final String SVIPS = \"/svips/\";\n+    private static final String INSTANCES = \"/instances/\";\n+\n+    private final WebClient webClient;\n+    private final ObjectMapper mapper = new ObjectMapper().enable(SerializationFeature.WRAP_ROOT_VALUE)\n+                                                          .setSerializationInclusion(Include.NON_NULL);", "originalCommit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzMzgxNQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424133815", "bodyText": "Oops, thanks!", "author": "minwoox", "createdAt": "2020-05-13T02:11:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3MDI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3NTUwMA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423675500", "bodyText": "Wow, TMI. \ud83d\ude4a", "author": "ikhoon", "createdAt": "2020-05-12T11:57:49Z", "path": "eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/InstanceInfo.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common.eureka;\n+\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonRootName;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;\n+import com.google.common.base.Objects;\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * An instance information.\n+ */\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@JsonRootName(\"instance\")\n+public final class InstanceInfo {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(InstanceInfo.class);\n+\n+    private final String instanceId;\n+\n+    @Nullable\n+    private final String hostName;\n+    @Nullable\n+    private final String appName;\n+    @Nullable\n+    private final String appGroupName;\n+    @Nullable\n+    private final String ipAddr;\n+    @Nullable\n+    private final String vipAddress;\n+    @Nullable\n+    private final String secureVipAddress;\n+\n+    private final PortWrapper port;\n+    private final PortWrapper securePort;\n+    private final InstanceStatus status;\n+\n+    @Nullable\n+    private final String homePageUrl;\n+    @Nullable\n+    private final String statusPageUrl;\n+    @Nullable\n+    private final String healthCheckUrl;\n+    @Nullable\n+    private final String secureHealthCheckUrl;\n+    private final DataCenterInfo dataCenterInfo;\n+    private final LeaseInfo leaseInfo;\n+    private final Map<String, String> metadata;\n+\n+    private final long lastUpdatedTimestamp;\n+    private final long lastDirtyTimestamp;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public InstanceInfo(@Nullable@JsonProperty(\"instanceId\") String instanceId,\n+                        @Nullable @JsonProperty(\"app\") String appName,\n+                        @Nullable @JsonProperty(\"appGroupName\") String appGroupName,\n+                        @Nullable @JsonProperty(\"hostName\") String hostName,\n+                        @Nullable @JsonProperty(\"ipAddr\") String ipAddr,\n+                        @Nullable @JsonProperty(\"vipAddress\") String vipAddress,\n+                        @Nullable @JsonProperty(\"secureVipAddress\") String secureVipAddress,\n+                        @JsonProperty(\"port\") PortWrapper port,\n+                        @JsonProperty(\"securePort\") PortWrapper securePort,\n+                        @JsonProperty(\"status\") InstanceStatus status,\n+                        @Nullable @JsonProperty(\"homePageUrl\") String homePageUrl,\n+                        @Nullable @JsonProperty(\"statusPageUrl\") String statusPageUrl,\n+                        @Nullable @JsonProperty(\"healthCheckUrl\") String healthCheckUrl,\n+                        @Nullable @JsonProperty(\"secureHealthCheckUrl\") String secureHealthCheckUrl,\n+                        @JsonProperty(\"dataCenterInfo\") DataCenterInfo dataCenterInfo,\n+                        @JsonProperty(\"leaseInfo\") LeaseInfo leaseInfo,\n+                        @Nullable @JsonProperty(\"metadata\") Map<String, String> metadata) {", "originalCommit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3ODU4Nw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423678587", "bodyText": "Do we need this information?  What do you think of ignoring this field from the JSON response?", "author": "ikhoon", "createdAt": "2020-05-12T12:03:39Z", "path": "eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/InstanceInfo.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common.eureka;\n+\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonRootName;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;\n+import com.google.common.base.Objects;\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * An instance information.\n+ */\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@JsonRootName(\"instance\")\n+public final class InstanceInfo {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(InstanceInfo.class);\n+\n+    private final String instanceId;\n+\n+    @Nullable\n+    private final String hostName;\n+    @Nullable\n+    private final String appName;\n+    @Nullable\n+    private final String appGroupName;\n+    @Nullable\n+    private final String ipAddr;\n+    @Nullable\n+    private final String vipAddress;\n+    @Nullable\n+    private final String secureVipAddress;\n+\n+    private final PortWrapper port;\n+    private final PortWrapper securePort;\n+    private final InstanceStatus status;\n+\n+    @Nullable\n+    private final String homePageUrl;\n+    @Nullable\n+    private final String statusPageUrl;\n+    @Nullable\n+    private final String healthCheckUrl;\n+    @Nullable\n+    private final String secureHealthCheckUrl;\n+    private final DataCenterInfo dataCenterInfo;\n+    private final LeaseInfo leaseInfo;\n+    private final Map<String, String> metadata;\n+\n+    private final long lastUpdatedTimestamp;\n+    private final long lastDirtyTimestamp;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public InstanceInfo(@Nullable@JsonProperty(\"instanceId\") String instanceId,\n+                        @Nullable @JsonProperty(\"app\") String appName,\n+                        @Nullable @JsonProperty(\"appGroupName\") String appGroupName,\n+                        @Nullable @JsonProperty(\"hostName\") String hostName,\n+                        @Nullable @JsonProperty(\"ipAddr\") String ipAddr,\n+                        @Nullable @JsonProperty(\"vipAddress\") String vipAddress,\n+                        @Nullable @JsonProperty(\"secureVipAddress\") String secureVipAddress,\n+                        @JsonProperty(\"port\") PortWrapper port,\n+                        @JsonProperty(\"securePort\") PortWrapper securePort,\n+                        @JsonProperty(\"status\") InstanceStatus status,\n+                        @Nullable @JsonProperty(\"homePageUrl\") String homePageUrl,\n+                        @Nullable @JsonProperty(\"statusPageUrl\") String statusPageUrl,\n+                        @Nullable @JsonProperty(\"healthCheckUrl\") String healthCheckUrl,\n+                        @Nullable @JsonProperty(\"secureHealthCheckUrl\") String secureHealthCheckUrl,\n+                        @JsonProperty(\"dataCenterInfo\") DataCenterInfo dataCenterInfo,\n+                        @JsonProperty(\"leaseInfo\") LeaseInfo leaseInfo,\n+                        @Nullable @JsonProperty(\"metadata\") Map<String, String> metadata) {\n+        this.instanceId = instanceId;\n+        this.hostName = hostName;\n+        this.appName = appName;\n+        this.appGroupName = appGroupName;\n+        this.ipAddr = ipAddr;\n+        this.vipAddress = vipAddress;\n+        this.secureVipAddress = secureVipAddress;\n+        this.port = requireNonNull(port, \"port\");\n+        this.securePort = requireNonNull(securePort, \"securePort\");\n+        this.status = requireNonNull(status, \"status\");\n+        this.homePageUrl = homePageUrl;\n+        this.statusPageUrl = statusPageUrl;\n+        this.healthCheckUrl = healthCheckUrl;\n+        this.secureHealthCheckUrl = secureHealthCheckUrl;\n+        this.dataCenterInfo = dataCenterInfo;\n+        this.leaseInfo = requireNonNull(leaseInfo, \"leaseInfo\");\n+        if (metadata != null) {\n+            this.metadata = metadata;\n+        } else {\n+            this.metadata = ImmutableMap.of();\n+        }\n+\n+        lastUpdatedTimestamp = System.currentTimeMillis();\n+        lastDirtyTimestamp = lastUpdatedTimestamp;\n+    }\n+\n+    /**\n+     * Returns the ID of this instance.\n+     */\n+    @Nullable\n+    public String getInstanceId() {\n+        return instanceId;\n+    }\n+\n+    /**\n+     * Return the name of the application which this instance belongs to.\n+     */\n+    @Nullable\n+    @JsonProperty(\"app\")\n+    public String getAppName() {\n+        return appName;\n+    }\n+\n+    /**\n+     * Return the group name of the application which this instance belongs to.\n+     */\n+    @Nullable\n+    public String getAppGroupName() {\n+        return appGroupName;\n+    }\n+\n+    /**\n+     * Return the hostname of this instance.\n+     */\n+    @Nullable\n+    public String getHostName() {\n+        return hostName;\n+    }\n+\n+    /**\n+     * Returns the IP address of this instance.\n+     */\n+    @Nullable\n+    public String getIpAddr() {\n+        return ipAddr;\n+    }\n+\n+    /**\n+     * Returns the VIP address of this instance.\n+     */\n+    @Nullable\n+    public String getVipAddress() {\n+        return vipAddress;\n+    }\n+\n+    /**\n+     * Returns the secure VIP address of this instance.\n+     */\n+    @Nullable\n+    public String getSecureVipAddress() {\n+        return secureVipAddress;\n+    }\n+\n+    /**\n+     * Returns the {@link PortWrapper} of this instance.\n+     */\n+    public PortWrapper getPort() {\n+        return port;\n+    }\n+\n+    /**\n+     * Returns the secure {@link PortWrapper} of this instance.\n+     */\n+    public PortWrapper getSecurePort() {\n+        return securePort;\n+    }\n+\n+    /**\n+     * Returns the {@link InstanceStatus} of this instance.\n+     */\n+    public InstanceStatus getStatus() {\n+        return status;\n+    }\n+\n+    /**\n+     * Returns the home page URL of this instance.\n+     */\n+    @Nullable\n+    public String getHomePageUrl() {\n+        return homePageUrl;\n+    }", "originalCommit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzNjQ3Ng==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424136476", "bodyText": "The clients who are using other implementation (not EurekaEndpointGroup) might need this information.", "author": "minwoox", "createdAt": "2020-05-13T02:22:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3ODU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5ODY5MA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423698690", "bodyText": "Question: Don't we need to take multiple eureka URIs? From the HA spec of eureka, a client should attempt to connect other eureka servers if a eureka is sitting idle.\nhttps://blog.asarkar.org/technical/netflix-eureka/#high-availability-ha", "author": "ikhoon", "createdAt": "2020-05-12T12:38:14Z", "path": "eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroupBuilder.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.eureka;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.URI;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.AbstractClientOptionsBuilder;\n+import com.linecorp.armeria.client.ClientFactory;\n+import com.linecorp.armeria.client.ClientOption;\n+import com.linecorp.armeria.client.ClientOptionValue;\n+import com.linecorp.armeria.client.ClientOptions;\n+import com.linecorp.armeria.client.DecoratingHttpClientFunction;\n+import com.linecorp.armeria.client.DecoratingRpcClientFunction;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.HttpClient;\n+import com.linecorp.armeria.client.RpcClient;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.WebClientBuilder;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.common.RequestId;\n+import com.linecorp.armeria.common.auth.BasicToken;\n+import com.linecorp.armeria.common.auth.OAuth1aToken;\n+import com.linecorp.armeria.common.auth.OAuth2Token;\n+\n+/**\n+ * Builds a {@link EurekaEndpointGroup}.\n+ */\n+public final class EurekaEndpointGroupBuilder extends AbstractClientOptionsBuilder {\n+\n+    private static final long DEFAULT_REGISTRY_FETCH_INTERVAL_SECONDS = 30;\n+\n+    private final URI eurekaUri;\n+\n+    @Nullable\n+    private String appName;\n+\n+    @Nullable\n+    private String instanceId;\n+\n+    @Nullable\n+    private String vipAddress;\n+\n+    @Nullable\n+    private String secureVipAddress;\n+\n+    private long registryFetchIntervalSeconds = DEFAULT_REGISTRY_FETCH_INTERVAL_SECONDS;\n+\n+    @Nullable\n+    private List<String> regions;\n+    @Nullable\n+    private Consumer<WebClientBuilder> customizer;\n+\n+    EurekaEndpointGroupBuilder(URI eurekaUri) {", "originalCommit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0MDE4NA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424140184", "bodyText": "That's a good idea. How about adding a constructor that takes an EndpointGroup?", "author": "minwoox", "createdAt": "2020-05-13T02:36:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5ODY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0NzYxOQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424147619", "bodyText": "SGTM :-)", "author": "ikhoon", "createdAt": "2020-05-13T03:07:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5ODY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzMDU5MQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424130591", "bodyText": "Case sensitive or insensitive?", "author": "trustin", "createdAt": "2020-05-13T01:59:25Z", "path": "eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/DataCenterInfoSerializer.java", "diffHunk": "@@ -37,12 +35,12 @@\n     public void serialize(DataCenterInfo value, JsonGenerator gen, SerializerProvider provider)\n             throws IOException {\n         gen.writeStartObject();\n-        if (value.getName() == DataCenterName.Amazon) {\n+        if (\"Amazon\".equalsIgnoreCase(value.getName())) {", "originalCommit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzNzU4OA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424137588", "bodyText": "I just followed their logic. https://github.com/Netflix/eureka/blob/master/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java#L497\n\ud83e\udd14", "author": "minwoox", "createdAt": "2020-05-13T02:26:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzMDU5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0OTIxNQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424149215", "bodyText": "It looks like JSON format in Eureka has a backward compatibility issue.\nNetflix/eureka#1051", "author": "ikhoon", "createdAt": "2020-05-13T03:14:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzMDU5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1MDAwMg==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424150002", "bodyText": "Yes, they have that a lot. For the overriddenstatus you gave the link, if we use the camel case the test suite fails. https://github.com/Netflix/eureka/blob/master/eureka-test-utils/src/main/java/com/netflix/discovery/shared/transport/SimpleEurekaHttpServer.java#L174", "author": "minwoox", "createdAt": "2020-05-13T03:17:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzMDU5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzMDcxNQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424130715", "bodyText": "Missing space before @", "author": "trustin", "createdAt": "2020-05-13T01:59:51Z", "path": "eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/InstanceInfo.java", "diffHunk": "@@ -79,7 +79,7 @@\n     /**\n      * Creates a new instance.\n      */\n-    public InstanceInfo(@JsonProperty(\"instanceId\") String instanceId,\n+    public InstanceInfo(@Nullable@JsonProperty(\"instanceId\") String instanceId,", "originalCommit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzNzczMA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424137730", "bodyText": "OOps. \ud83d\ude05", "author": "minwoox", "createdAt": "2020-05-13T02:26:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzMDcxNQ=="}], "type": "inlineReview"}, {"oid": "161f7636495c4b4cb832403e14d5998dfc4e7674", "url": "https://github.com/line/armeria/commit/161f7636495c4b4cb832403e14d5998dfc4e7674", "message": "Address comments by @trustin and @ikhoon", "committedDate": "2020-05-13T04:06:30Z", "type": "commit"}, {"oid": "244d88f37e48ffa51b0f4e7eee9b386e1e2ca521", "url": "https://github.com/line/armeria/commit/244d88f37e48ffa51b0f4e7eee9b386e1e2ca521", "message": "Returns non local port first", "committedDate": "2020-05-13T04:18:39Z", "type": "commit"}, {"oid": "269360b72da27d34a632f4b26b2ae3b8de0efe7a", "url": "https://github.com/line/armeria/commit/269360b72da27d34a632f4b26b2ae3b8de0efe7a", "message": "Fix import", "committedDate": "2020-05-13T05:52:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4NzkxMQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424187911", "bodyText": "Should we add a variant that does not require path and make path here non-null?", "author": "trustin", "createdAt": "2020-05-13T05:53:41Z", "path": "eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.eureka;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.endpoint.DynamicEndpointGroup;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaTypeNames;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.common.eureka.Application;\n+import com.linecorp.armeria.internal.common.eureka.Applications;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.eureka.EurekaUpdatingListener;\n+import com.linecorp.armeria.server.eureka.EurekaUpdatingListenerBuilder;\n+\n+import io.netty.channel.EventLoop;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A Eureka-based {@link EndpointGroup} implementation. This {@link EndpointGroup} retrieves the list of\n+ * {@link Endpoint}s from a Eureka registry.\n+ *\n+ * @see EurekaUpdatingListener\n+ */\n+public final class EurekaEndpointGroup extends DynamicEndpointGroup {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaEndpointGroup.class);\n+\n+    private static final ObjectMapper mapper =\n+            new ObjectMapper().enable(DeserializationFeature.UNWRAP_ROOT_VALUE)\n+                              .setSerializationInclusion(Include.NON_NULL);\n+\n+    private static final Predicate<InstanceInfo> allInstances = instanceInfo -> true;\n+\n+    private static final String APPS = \"/apps\";\n+    private static final String VIPS = \"/vips/\";\n+    private static final String SVIPS = \"/svips/\";\n+    private static final String INSTANCES = \"/instances/\";\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(String eurekaUri) {\n+        return of(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri).build();\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(String eurekaUri) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@link SessionProtocol},\n+     * {@link EndpointGroup} and path.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(\n+            SessionProtocol sessionProtocol, EndpointGroup endpointGroup, @Nullable String path) {", "originalCommit": "244d88f37e48ffa51b0f4e7eee9b386e1e2ca521", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE5MTI1MQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424191251", "bodyText": "I was just worried about having too much static method. \ud83d\ude04 Let me add the one.", "author": "minwoox", "createdAt": "2020-05-13T06:03:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4NzkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4ODA1OA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424188058", "bodyText": "How about adding some comment about priority?", "author": "trustin", "createdAt": "2020-05-13T05:54:13Z", "path": "core/src/main/java/com/linecorp/armeria/server/Server.java", "diffHunk": "@@ -180,9 +179,36 @@ public String defaultHostname() {\n      */\n     @Nullable\n     public ServerPort activePort() {\n+        return activePort0(null);\n+    }\n+\n+    /**\n+     * Returns the primary {@link ServerPort} which serves the given {@link SessionProtocol}\n+     * that this {@link Server} is listening to.\n+     *\n+     * @return the primary {@link ServerPort}, or {@code null} if there is no active port available for\n+     *         the given {@link SessionProtocol}.\n+     */\n+    @Nullable\n+    public ServerPort activePort(SessionProtocol protocol) {\n+        return activePort0(requireNonNull(protocol, \"protocol\"));\n+    }\n+\n+    @Nullable\n+    private ServerPort activePort0(@Nullable SessionProtocol protocol) {\n         synchronized (activePorts) {\n-            return Iterables.getFirst(activePorts.values(), null);\n+            for (ServerPort serverPort : activePorts.values()) {\n+                if (!isLocalPort(serverPort, protocol)) {", "originalCommit": "269360b72da27d34a632f4b26b2ae3b8de0efe7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1MzY2Nw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424253667", "bodyText": "Added!", "author": "minwoox", "createdAt": "2020-05-13T08:13:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4ODA1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE5MDA3Mg==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424190072", "bodyText": "Please handle the case of IPv6 address.", "author": "trustin", "createdAt": "2020-05-13T06:00:16Z", "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.server.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.channel.EventLoop;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka.\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, {@link EurekaUpdatingListener} deregisters the\n+ * {@link Server} from Eureka by sending a cancellation request.\n+ */\n+public final class EurekaUpdatingListener extends ServerListenerAdapter {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaUpdatingListener.class);\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(String eurekaUri) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(URI eurekaUri) {\n+        return new EurekaUpdatingListenerBuilder(eurekaUri);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@link SessionProtocol},\n+     * {@link EndpointGroup} and path.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(\n+            SessionProtocol sessionProtocol, EndpointGroup endpointGroup, @Nullable String path) {\n+        return new EurekaUpdatingListenerBuilder(sessionProtocol, endpointGroup, path);\n+    }\n+\n+    private final EurekaWebClient client;\n+    private final InstanceInfo instanceInfo;\n+    @Nullable\n+    private volatile ScheduledFuture<?> heartBeatFuture;\n+\n+    @Nullable\n+    private volatile String appName; // Set when serverStarted is called.\n+    private volatile boolean closed;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    EurekaUpdatingListener(EurekaWebClient client, InstanceInfo instanceInfo) {\n+        this.client = client;\n+        this.instanceInfo = instanceInfo;\n+    }\n+\n+    @Override\n+    public void serverStarted(Server server) throws Exception {\n+        final InstanceInfo newInfo = fillAndCreateNewInfo(instanceInfo, server);\n+\n+        try (ClientRequestContextCaptor contextCaptor = Clients.newContextCaptor()) {\n+            final HttpResponse response = client.register(newInfo);\n+            final ClientRequestContext ctx = contextCaptor.get();\n+            response.aggregate().handle((res, cause) -> {\n+                if (closed) {\n+                    return null;\n+                }\n+                if (cause != null) {\n+                    logger.warn(\"Failed to register {} to Eureka: {}\",\n+                                newInfo.getHostName(), client.uri(), cause);\n+                    return null;\n+                }\n+                final ResponseHeaders headers = res.headers();\n+                if (headers.status() != HttpStatus.NO_CONTENT) {\n+                    logger.warn(\"Failed to register {} to Eureka: {}. (status: {}, content: {})\",\n+                                newInfo.getHostName(), client.uri(), headers.status(), res.contentUtf8());\n+                } else {\n+                    logger.info(\"Registered {} to Eureka: {}\", newInfo.getHostName(), client.uri());\n+                    scheduleHeartBeat(ctx.eventLoop(), newInfo);\n+                }\n+                return null;\n+            });\n+        }\n+    }\n+\n+    private void scheduleHeartBeat(EventLoop eventLoop, InstanceInfo newInfo) {\n+        heartBeatFuture = eventLoop.schedule(new HeartBeatTask(eventLoop, newInfo),\n+                                             newInfo.getLeaseInfo().getRenewalIntervalInSecs(),\n+                                             TimeUnit.SECONDS);\n+    }\n+\n+    private InstanceInfo fillAndCreateNewInfo(InstanceInfo oldInfo, Server server) {\n+        final String defaultHostname = server.defaultHostname();\n+        final String hostName = oldInfo.getHostName() != null ? oldInfo.getHostName() : defaultHostname;\n+        appName = oldInfo.getAppName() != null ? oldInfo.getAppName() : hostName;\n+        final String instanceId = oldInfo.getInstanceId() != null ? oldInfo.getInstanceId() : hostName;\n+\n+        final Inet4Address defaultInet4Address = SystemInfo.defaultNonLoopbackIpV4Address();\n+        final String defaultIpAddr = defaultInet4Address != null ? defaultInet4Address.getHostAddress()\n+                                                                 : null;\n+        final String ipAddr = oldInfo.getIpAddr() != null ? oldInfo.getIpAddr() : defaultIpAddr;\n+        final PortWrapper oldPortWrapper = oldInfo.getPort();\n+        final PortWrapper portWrapper = portWrapper(server, oldPortWrapper, SessionProtocol.HTTP);\n+        final PortWrapper oldSecurePortWrapper = oldInfo.getSecurePort();\n+        final PortWrapper securePortWrapper = portWrapper(server, oldSecurePortWrapper, SessionProtocol.HTTPS);\n+\n+        final String vipAddress = vipAddress(oldInfo.getVipAddress(), hostName, portWrapper);\n+        final String secureVipAddress = vipAddress(oldInfo.getSecureVipAddress(), hostName, securePortWrapper);\n+\n+        final Optional<ServiceConfig> healthCheckService =\n+                server.serviceConfigs()\n+                      .stream()\n+                      .filter(cfg -> cfg.service().as(HealthCheckService.class) != null)\n+                      .findFirst();\n+\n+        final String hostnameOrIpAddr;\n+        if (oldInfo.getHostName() != null) {\n+            hostnameOrIpAddr = oldInfo.getHostName();\n+        } else if (ipAddr != null) {\n+            hostnameOrIpAddr = ipAddr;\n+        } else {\n+            hostnameOrIpAddr = hostName;\n+        }\n+        final String healthCheckUrl = healthCheckUrl(hostnameOrIpAddr, oldInfo.getHealthCheckUrl(), portWrapper,\n+                                                     healthCheckService, SessionProtocol.HTTP);\n+        final String secureHealthCheckUrl =\n+                healthCheckUrl(hostnameOrIpAddr, oldInfo.getSecureHealthCheckUrl(), securePortWrapper,\n+                               healthCheckService, SessionProtocol.HTTPS);\n+\n+        return new InstanceInfo(instanceId, appName, oldInfo.getAppGroupName(), hostName, ipAddr,\n+                                vipAddress, secureVipAddress, portWrapper, securePortWrapper, InstanceStatus.UP,\n+                                oldInfo.getHomePageUrl(), oldInfo.getStatusPageUrl(), healthCheckUrl,\n+                                secureHealthCheckUrl, oldInfo.getDataCenterInfo(),\n+                                oldInfo.getLeaseInfo(), oldInfo.getMetadata());\n+    }\n+\n+    private static PortWrapper portWrapper(Server server, PortWrapper oldPortWrapper,\n+                                           SessionProtocol protocol) {\n+        if (oldPortWrapper.isEnabled()) {\n+            for (ServerPort serverPort : server.activePorts().values()) {\n+                if (serverPort.hasProtocol(protocol) &&\n+                    serverPort.localAddress().getPort() == oldPortWrapper.getPort()) {\n+                    return oldPortWrapper;\n+                }\n+            }\n+            logger.warn(\"The port number: {} (expected one of activePorts: {})\",\n+                        oldPortWrapper.getPort(), server.activePorts());\n+        }\n+\n+        final ServerPort serverPort = server.activePort(protocol);\n+        if (serverPort == null) {\n+            return disabledPort;\n+        }\n+        return new PortWrapper(true, serverPort.localAddress().getPort());\n+    }\n+\n+    @Nullable\n+    private static String vipAddress(@Nullable String vipAddress, String hostName, PortWrapper portWrapper) {\n+        if (!portWrapper.isEnabled()) {\n+            return null;\n+        }\n+        return vipAddress != null ? vipAddress : hostName + ':' + portWrapper.getPort();\n+    }\n+\n+    @Nullable\n+    private static String healthCheckUrl(String hostnameOrIpAddr, @Nullable String oldHealthCheckUrl,\n+                                         PortWrapper portWrapper,\n+                                         Optional<ServiceConfig> healthCheckService,\n+                                         SessionProtocol sessionProtocol) {\n+        if (oldHealthCheckUrl != null) {\n+            return oldHealthCheckUrl;\n+        }\n+        if (!portWrapper.isEnabled() || !healthCheckService.isPresent()) {\n+            return null;\n+        }\n+        final ServiceConfig healthCheckServiceConfig = healthCheckService.get();\n+        final Route route = healthCheckServiceConfig.route();\n+        if (route.pathType() != RoutePathType.EXACT && route.pathType() != RoutePathType.PREFIX) {\n+            return null;\n+        }\n+\n+        return sessionProtocol.uriText() + \"://\" + hostnameOrIpAddr + ':' + portWrapper.getPort() +", "originalCommit": "269360b72da27d34a632f4b26b2ae3b8de0efe7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1MzYxOQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424253619", "bodyText": "Oops, didn't know about it. Thanks!", "author": "minwoox", "createdAt": "2020-05-13T08:13:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE5MDA3Mg=="}], "type": "inlineReview"}, {"oid": "a715a618147a77fab8b7f9aecff8f20b0a9dda69", "url": "https://github.com/line/armeria/commit/a715a618147a77fab8b7f9aecff8f20b0a9dda69", "message": "Address the comment by @trustin", "committedDate": "2020-05-13T08:12:54Z", "type": "commit"}, {"oid": "2ff3bbbdcac6d17e4317669bccbdc71fc4b79b2c", "url": "https://github.com/line/armeria/commit/2ff3bbbdcac6d17e4317669bccbdc71fc4b79b2c", "message": "Merge branch 'master' into eureka", "committedDate": "2020-05-13T08:17:00Z", "type": "commit"}, {"oid": "523facbfe131a28f9ad250ad402e012fcce0baad", "url": "https://github.com/line/armeria/commit/523facbfe131a28f9ad250ad402e012fcce0baad", "message": "Add publish tag", "committedDate": "2020-05-13T08:28:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI3NjA1Ng==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424276056", "bodyText": "Don't we need to retry to other eureka servers? Or, does it happen in EurekaWebClient?", "author": "ikhoon", "createdAt": "2020-05-13T08:48:58Z", "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.server.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.channel.EventLoop;\n+import io.netty.util.NetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka.\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, {@link EurekaUpdatingListener} deregisters the\n+ * {@link Server} from Eureka by sending a cancellation request.\n+ */\n+public final class EurekaUpdatingListener extends ServerListenerAdapter {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaUpdatingListener.class);\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(String eurekaUri) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(URI eurekaUri) {\n+        return new EurekaUpdatingListenerBuilder(eurekaUri);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@link SessionProtocol}\n+     * and {@link EndpointGroup}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(\n+            SessionProtocol sessionProtocol, EndpointGroup endpointGroup) {\n+        return new EurekaUpdatingListenerBuilder(sessionProtocol, endpointGroup, null);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@link SessionProtocol},\n+     * {@link EndpointGroup} and path.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(\n+            SessionProtocol sessionProtocol, EndpointGroup endpointGroup, String path) {\n+        return new EurekaUpdatingListenerBuilder(sessionProtocol, endpointGroup, requireNonNull(path, \"path\"));\n+    }\n+\n+    private final EurekaWebClient client;\n+    private final InstanceInfo instanceInfo;\n+    @Nullable\n+    private volatile ScheduledFuture<?> heartBeatFuture;\n+\n+    @Nullable\n+    private volatile String appName; // Set when serverStarted is called.\n+    private volatile boolean closed;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    EurekaUpdatingListener(EurekaWebClient client, InstanceInfo instanceInfo) {\n+        this.client = client;\n+        this.instanceInfo = instanceInfo;\n+    }\n+\n+    @Override\n+    public void serverStarted(Server server) throws Exception {\n+        final InstanceInfo newInfo = fillAndCreateNewInfo(instanceInfo, server);\n+\n+        try (ClientRequestContextCaptor contextCaptor = Clients.newContextCaptor()) {\n+            final HttpResponse response = client.register(newInfo);\n+            final ClientRequestContext ctx = contextCaptor.get();\n+            response.aggregate().handle((res, cause) -> {\n+                if (closed) {\n+                    return null;\n+                }\n+                if (cause != null) {\n+                    logger.warn(\"Failed to register {} to Eureka: {}\",\n+                                newInfo.getHostName(), client.uri(), cause);\n+                    return null;\n+                }\n+                final ResponseHeaders headers = res.headers();\n+                if (headers.status() != HttpStatus.NO_CONTENT) {\n+                    logger.warn(\"Failed to register {} to Eureka: {}. (status: {}, content: {})\",\n+                                newInfo.getHostName(), client.uri(), headers.status(), res.contentUtf8());", "originalCommit": "523facbfe131a28f9ad250ad402e012fcce0baad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyMzE5NA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424423194", "bodyText": "Add RetryingClient if the user didn't specify one. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-05-13T13:09:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI3NjA1Ng=="}], "type": "inlineReview"}, {"oid": "d38ecc0c64c652a7d202e19d7e483df2a3105a2c", "url": "https://github.com/line/armeria/commit/d38ecc0c64c652a7d202e19d7e483df2a3105a2c", "message": "Add retryingClient if not specified", "committedDate": "2020-05-13T13:08:44Z", "type": "commit"}, {"oid": "baf699cd8956f2dc9cc02238264c559ddbf8879f", "url": "https://github.com/line/armeria/commit/baf699cd8956f2dc9cc02238264c559ddbf8879f", "message": "Fix import", "committedDate": "2020-05-14T01:50:39Z", "type": "commit"}, {"oid": "c3b62d87401fe19dca21ee16b66c2a7d8071f82c", "url": "https://github.com/line/armeria/commit/c3b62d87401fe19dca21ee16b66c2a7d8071f82c", "message": "Add static factory methods", "committedDate": "2020-05-14T03:43:37Z", "type": "commit"}]}