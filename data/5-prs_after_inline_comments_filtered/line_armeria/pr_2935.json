{"pr_number": 2935, "pr_title": "Add facility to capture dns metrics", "pr_createdAt": "2020-07-25T17:46:08Z", "pr_url": "https://github.com/line/armeria/pull/2935", "timeline": [{"oid": "8d24a6844cd227561e20bda9ceaf920fe61224ae", "url": "https://github.com/line/armeria/commit/8d24a6844cd227561e20bda9ceaf920fe61224ae", "message": "Add facility to capture dns metrics", "committedDate": "2020-07-25T17:44:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0ODQ1NQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r460648455", "bodyText": "I think this option is too early to introduce now. Could we hard-code for now and then add later when we get some user demands?", "author": "trustin", "createdAt": "2020-07-27T05:04:48Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java", "diffHunk": "@@ -184,6 +185,10 @@\n     public static final ClientFactoryOption<ProxyConfigSelector> PROXY_CONFIG_SELECTOR =\n             ClientFactoryOption.define(\"PROXY_CONFIG_SELECTOR\", ProxyConfigSelector.of(ProxyConfig.direct()));\n \n+    public static final ClientFactoryOption<MeterIdPrefix> DEFAULT_METER_ID_PREFIX =\n+            ClientFactoryOption.define(\"DEFAULT_DNS_METER_ID_PREFIX\",\n+                    new MeterIdPrefix(\"armeria.client.dns.queries\"));", "originalCommit": "8d24a6844cd227561e20bda9ceaf920fe61224ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk4OTAwMw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r460989003", "bodyText": "Sounds good. I will make the change.", "author": "amitvc", "createdAt": "2020-07-27T15:47:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0ODQ1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0ODk2Mg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r460648962", "bodyText": "We never use IXFR or AXFR for DNS queries, so there's no way to tell if it's UDP or TCP. Let's remove protocol tag until the upstream provides a proper way to determine the protocol.", "author": "trustin", "createdAt": "2020-07-27T05:06:50Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.List;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Counter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsRecordType;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final Counter success;\n+    private final Counter failure;\n+    private final Counter protocolType;\n+    private final Counter dnsErrorCode;\n+    private final Counter queryWritten;\n+    private final Counter queryType;\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry, DnsQuestion question, MeterIdPrefix prefix) {\n+        success = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"result\", \"success\",\n+                        \"question\", question.name()).tags());\n+        failure = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"result\", \"failure\",\n+                        \"question\", question.name()).tags());\n+        dnsErrorCode = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"dns\", \"errorcodes\",\n+                        \"question\", question.name()).tags());\n+        queryWritten = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"written\", question.type().name()).tags());\n+        queryType = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(),\n+                        \"type\", question.type().name()).tags());\n+        protocolType = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"protocol\", getProtocolType(question.type()),\n+                        \"question\", question.name()).tags());\n+        protocolType.increment();\n+    }\n+\n+    private static String getProtocolType(DnsRecordType type) {\n+        if (DnsRecordType.IXFR.equals(type) ||\n+                DnsRecordType.AXFR.equals(type)) {\n+            return \"tcp\";\n+        }\n+        return \"udp\";\n+    }", "originalCommit": "8d24a6844cd227561e20bda9ceaf920fe61224ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk4OTEwMg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r460989102", "bodyText": "Ok. will do.", "author": "amitvc", "createdAt": "2020-07-27T15:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0ODk2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDEzMQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r460650131", "bodyText": "There are many incorrectness in this block, so I'm not sure how I can advise on this. Please make sure to re-read my suggestions about the names and tags and try re-writing this block completely.\nFor example, you should have different counter for each error code. To do this, you must get the counter lazily in the callback.", "author": "trustin", "createdAt": "2020-07-27T05:11:54Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.List;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Counter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsRecordType;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final Counter success;\n+    private final Counter failure;\n+    private final Counter protocolType;\n+    private final Counter dnsErrorCode;\n+    private final Counter queryWritten;\n+    private final Counter queryType;\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry, DnsQuestion question, MeterIdPrefix prefix) {\n+        success = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"result\", \"success\",\n+                        \"question\", question.name()).tags());\n+        failure = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"result\", \"failure\",\n+                        \"question\", question.name()).tags());\n+        dnsErrorCode = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"dns\", \"errorcodes\",\n+                        \"question\", question.name()).tags());\n+        queryWritten = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"written\", question.type().name()).tags());\n+        queryType = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(),\n+                        \"type\", question.type().name()).tags());\n+        protocolType = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"protocol\", getProtocolType(question.type()),\n+                        \"question\", question.name()).tags());\n+        protocolType.increment();", "originalCommit": "8d24a6844cd227561e20bda9ceaf920fe61224ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxODMxNA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r462718314", "bodyText": "Regarding this - Your original comment -\nAll meters with the same name must have the same set of tags in Prometheus, i.e. this will fail. How about organizing like this:\nTIMER <prefix>{name=<domain name>, result=<success_or_failure>, cause=<cause_of_failure>}\nCOUNTER <prefix>.written{name=<domain_name>, server=<dns_server_ip_address>}\nCOUNTER <prefix>.cancelled{name=<domain_name>}\nCOUNTER <prefix>.cnamed{name=<domain_name>, cname=<name_in_cname_question>}\nCOUNTER <prefix>.redirected{name=<domain_name>, servers=<list_of_name_servers>}\nCOUNTER <prefix>.noanswer{name=<domain_name>, code=<response_code>}\n\nThe prefix here is something default like 'armeria.client.dns.queries'. So .cnamed is the name of the Counter ? and everything inside {} are the tags for that counter? Maybe we can pass the metricRegistry to DefaultDnsQueryLifecycleObserver and use it to instantiate the necessary counters when the appropriate dns lifecycle methods are being called?", "author": "amitvc", "createdAt": "2020-07-30T03:50:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ3Njg1MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r463476850", "bodyText": "So .cnamed is the name of the Counter ?\n\nYes, its name will be armeria.client.dns.queries.cnamed and its tags will be name=<....> and cname=<...>. The counter will be increased when queryCNAMEd() method is invoked.\n\neverything inside {} are the tags for that counter?\n\nThat's correct. \ud83d\ude04\n\nMaybe we can pass the metricRegistry to DefaultDnsQueryLifecycleObserver and use it to instantiate the necessary counters when the appropriate dns lifecycle methods are being called?\n\nYes! \ud83d\udc4d", "author": "trustin", "createdAt": "2020-07-31T08:29:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDIzNQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r460650235", "bodyText": "Indentation", "author": "trustin", "createdAt": "2020-07-27T05:12:19Z", "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -343,6 +369,7 @@ RefreshingAddressResolverGroup build(EventLoopGroup eventLoopGroup) {\n             }\n         };\n         return new RefreshingAddressResolverGroup(resolverConfigurator, minTtl, maxTtl, negativeTtl,\n-                                                  queryTimeoutMillis, refreshBackoff, resolvedAddressTypes);\n+                                                  queryTimeoutMillis, refreshBackoff, resolvedAddressTypes,\n+                                                   meterRegistry, meterIdPrefix);", "originalCommit": "8d24a6844cd227561e20bda9ceaf920fe61224ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDU1MQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r460650551", "bodyText": "When you create a ClientFactory, you can specify a MeterRegistry. Create a new MeterRegistry so that ClientFactory does not use the default MeterRegistry, then check what's recorded in the MeterRegistry you specified. I'd recommend using PrometheusMeterRegistries.newRegistry() to create one.", "author": "trustin", "createdAt": "2020-07-27T05:13:53Z", "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+\n+public class DnsMetricsTest {\n+\n+    @Test\n+    void test() throws ExecutionException, InterruptedException {\n+\n+        final ClientFactory factory = ClientFactory.builder()\n+                .meterIdPrefix(new MeterIdPrefix(\"armeria.dns.metrics.test\"))", "originalCommit": "8d24a6844cd227561e20bda9ceaf920fe61224ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk5MDAyNg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r460990026", "bodyText": "Ok.", "author": "amitvc", "createdAt": "2020-07-27T15:49:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY3NjU3MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r467676570", "bodyText": "Isn't it just setting a new MeterRegistry like\nfinal MeterRegistry registry = PrometheusMeterRegistries.newRegistry():\nClientFactory.builder().meterRegistry(registry)...\n\ninstead of introducing a new MeterRegirstry? \ud83e\udd14", "author": "minwoox", "createdAt": "2020-08-10T03:51:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzkxNDExNQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r467914115", "bodyText": "Not sure @minwoox. I think the default meter registry in the ClientFactory is used to collect various different stats. See example -\n{armeria.client.connections.lifespan#count{protocol=h2c}=0.0, armeria.client.connections.lifespan#total{protocol=h2c}=0.0, armeria.client.connections.lifespan#max{protocol=h2c}=0.0, armeria.client.connections.lifespan#count{protocol=h1c}=0.0, armeria.client.connections.lifespan#total{protocol=h1c}=0.0, armeria.client.connections.lifespan#max{protocol=h1c}=0.0}\nAre we ok to reuse the same registry for DNS metrics? If yes then it makes sense. Let me know.", "author": "amitvc", "createdAt": "2020-08-10T13:45:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzkxNDUwMw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r467914503", "bodyText": "Example of DNS metric registry --\n{armeria.client.dns.queries.written#count{name=wikipedia.com.,server=/2001:558:feed:0:0:0:0:1}=2.0, armeria.client.dns.queries#count{cause=,name=wikipedia.com.,result=success}=2.0}", "author": "amitvc", "createdAt": "2020-08-10T13:46:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzkxOTk5OQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r467919999", "bodyText": "Are we ok to reuse the same registry for DNS metrics? If yes then it makes sense. Let me know.\n\nI think so. \ud83d\ude04  We can check whether the metric is recorded correctly or not using the combination of tags. This is an example:\nhttps://github.com/line/armeria/blob/master/grpc/src/test/java/com/linecorp/armeria/it/grpc/GrpcMetricsIntegrationTest.java#L201", "author": "minwoox", "createdAt": "2020-08-10T13:54:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDU1MQ=="}], "type": "inlineReview"}, {"oid": "78c156d413430822fe9088f60ea271c3442b3fbc", "url": "https://github.com/line/armeria/commit/78c156d413430822fe9088f60ea271c3442b3fbc", "message": "changes made based on comments, added UT", "committedDate": "2020-08-09T05:05:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5OTEzNg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r468999136", "bodyText": "I don't think we need this at all. We can use the same MeterRegistry for DNS metrics.", "author": "trustin", "createdAt": "2020-08-12T04:32:55Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactory.java", "diffHunk": "@@ -177,6 +178,11 @@ static void disableShutdownHook() {\n      */\n     MeterRegistry meterRegistry();\n \n+    /**\n+     * Returns the {@link PrometheusMeterRegistry} that collects various DNS stats.\n+     */\n+    PrometheusMeterRegistry dnsMetricRegistry();\n+", "originalCommit": "78c156d413430822fe9088f60ea271c3442b3fbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM3MzI1OQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r470373259", "bodyText": "I have removed it.", "author": "amitvc", "createdAt": "2020-08-14T02:17:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5OTEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5OTI5MQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r468999291", "bodyText": "Ditto - We don't need this.", "author": "trustin", "createdAt": "2020-08-12T04:33:39Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java", "diffHunk": "@@ -178,6 +180,9 @@\n     public static final ClientFactoryOption<MeterRegistry> METER_REGISTRY =\n             ClientFactoryOption.define(\"METER_REGISTRY\", Metrics.globalRegistry);\n \n+    public static final ClientFactoryOption<PrometheusMeterRegistry> DNS_METRIC_REGISTRY =\n+            ClientFactoryOption.define(\"DNS_METER_REGISTRY\", PrometheusMeterRegistries.newRegistry());\n+", "originalCommit": "78c156d413430822fe9088f60ea271c3442b3fbc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e1b3a01b5b6f221dce5de3aed8cbd32c9305e6c8", "url": "https://github.com/line/armeria/commit/e1b3a01b5b6f221dce5de3aed8cbd32c9305e6c8", "message": "Removed dns specific metric registry and refactored some code based on feedback", "committedDate": "2020-08-13T03:50:58Z", "type": "commit"}, {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "url": "https://github.com/line/armeria/commit/1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "message": "Only enable DefaultDnsQueryLifecycleObserverFactory if user is expecting to capture dns metrics", "committedDate": "2020-08-15T23:51:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5ODA1MQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471898051", "bodyText": "You can always do builder.metricRegistry(options.meterRegistry()).build(eventLoopGroup).", "author": "trustin", "createdAt": "2020-08-18T03:52:26Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -597,7 +598,10 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+                        return options.containsKey(ClientFactoryOptions.METER_REGISTRY) ? builder\n+                                .metricRegistry((PrometheusMeterRegistry)\n+                                        options.get(ClientFactoryOptions.METER_REGISTRY).value())\n+                                .build(eventLoopGroup) : builder.build(eventLoopGroup);", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5ODE1MQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471898151", "bodyText": "You can just accept MeterRegistry here.", "author": "trustin", "createdAt": "2020-08-18T03:52:52Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2NDg4MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r473064880", "bodyText": "Ok.", "author": "amitvc", "createdAt": "2020-08-19T14:18:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5ODE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5ODIzNA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471898234", "bodyText": "Could you move these fields before the member fields in this class?", "author": "trustin", "createdAt": "2020-08-18T03:53:12Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2NDc3Mw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r473064773", "bodyText": "Yes will do.", "author": "amitvc", "createdAt": "2020-08-19T14:18:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5ODIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDA5MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471900090", "bodyText": "Could you use .getAddress().getHostAddress() because we are only interested in an IP address?", "author": "trustin", "createdAt": "2020-08-18T04:01:06Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDE0Ng==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471900146", "bodyText": "Could you use .getAddress().getHostAddress() because we are only interested in IP addresses?", "author": "trustin", "createdAt": "2020-08-18T04:01:18Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        registry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        registry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().toString())", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDM1MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471900350", "bodyText": "intValue() instead of toString()?", "author": "trustin", "createdAt": "2020-08-18T04:02:11Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        registry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        registry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().toString())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        registry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        registry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, code.toString()))).increment();", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEzMTAwMA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r482131000", "bodyText": "Done", "author": "amitvc", "createdAt": "2020-09-02T14:50:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDYwNw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471900607", "bodyText": "Ditto - could use MeterRegistry", "author": "trustin", "createdAt": "2020-08-18T04:03:27Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserverFactory.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserverFactory;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserverFactory} factory that helps create DnsQueryLifecycleObserver.\n+ */\n+final class DefaultDnsQueryLifecycleObserverFactory implements DnsQueryLifecycleObserverFactory {\n+\n+    private final PrometheusMeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+\n+    DefaultDnsQueryLifecycleObserverFactory(PrometheusMeterRegistry meterRegistry,", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDg5Mw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471900893", "bodyText": "How about \"none\" instead of \"\"?", "author": "trustin", "createdAt": "2020-08-18T04:04:44Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        registry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        registry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().toString())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        registry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        registry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, code.toString()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        registry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, cause.getMessage()))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        registry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"success\"),\n+                        Tag.of(CAUSE_TAG, \"\"))).increment();", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTEwMA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471901100", "bodyText": "I'm somewhat concerned about using an exception message as a tag value because it can increase the cardinality dramatically. How about categorizing the exceptions into a few?", "author": "trustin", "createdAt": "2020-08-18T04:05:41Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        registry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        registry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().toString())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        registry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        registry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, code.toString()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        registry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, cause.getMessage()))).increment();", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTYzMjc2MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r481632760", "bodyText": "Can you elaborate on this, please?  If I understand correctly we want to see what is the type of exception and use that to add CAUSE_TAG instead of cause.getMessage()?", "author": "amitvc", "createdAt": "2020-09-02T03:56:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTEwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwMjYzOA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r484202638", "bodyText": "If I understand correctly we want to see what is the type of exception and use that to add CAUSE_TAG instead of cause.getMessage()?\n\nYes, if Netty gives different exception type for different causes. If not, we'll have to categorize all possible exception types and messages into a set of well-defined strings. Makes sense?", "author": "trustin", "createdAt": "2020-09-07T06:14:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTEwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI0Mjg4Nw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r485242887", "bodyText": "Netty will return a runtimeexception of type DnsResolveContext::DnsResolveContextException which is RuntimeException. There are 5 different types of these exceptions defined in https://github.com/netty/netty/blob/fde6bc88859a41b2bdd5aae00beef09b1b17bda7/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java#L65.  We also receive DnsNameResolverTimeoutException exception when there are time outs.", "author": "amitvc", "createdAt": "2020-09-08T23:06:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTEwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3NTQ0MQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r485275441", "bodyText": "I see. Thanks for looking into. We need to do some text pattern matching in this case. You might want to contribute to Netty so that each case is distinguishable by exception type later, though.", "author": "trustin", "createdAt": "2020-09-09T00:59:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTEwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTUwMQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471901501", "bodyText": "Should accept MeterRegistry.\nCould be package-private?", "author": "trustin", "createdAt": "2020-08-18T04:07:26Z", "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -292,6 +295,16 @@ public DnsResolverGroupBuilder decodeIdn(boolean decodeIdn) {\n         return this;\n     }\n \n+    /**\n+     * Sets MeterRegistry.\n+     * @param metricRegistry {@link PrometheusMeterRegistry}.\n+     * @return DnsResolverGroupBuilder.\n+     */\n+    public DnsResolverGroupBuilder metricRegistry(PrometheusMeterRegistry metricRegistry) {", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTYyMTUwNw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r481621507", "bodyText": "Done", "author": "amitvc", "createdAt": "2020-09-02T03:44:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTYyMQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471901621", "bodyText": "@Nonnull is redundant. Everything in our code is nonnull.\nShould accept MeterRegistry\nmetricRegistry -> meterRegistry", "author": "trustin", "createdAt": "2020-08-18T04:08:02Z", "path": "core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java", "diffHunk": "@@ -99,11 +102,13 @@\n     private final Backoff refreshBackoff;\n     private final List<DnsRecordType> dnsRecordTypes;\n     private final Consumer<DnsNameResolverBuilder> resolverConfigurator;\n+    private final PrometheusMeterRegistry metricRegistry;\n \n     RefreshingAddressResolverGroup(Consumer<DnsNameResolverBuilder> resolverConfigurator,\n                                    int minTtl, int maxTtl, int negativeTtl, long queryTimeoutMillis,\n                                    Backoff refreshBackoff,\n-                                   @Nullable ResolvedAddressTypes resolvedAddressTypes) {\n+                                   @Nullable ResolvedAddressTypes resolvedAddressTypes,\n+                                   @Nonnull PrometheusMeterRegistry metricRegistry) {", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTcyOA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471901728", "bodyText": "metricRegistry is always non-null. No need to check nullness.", "author": "trustin", "createdAt": "2020-08-18T04:08:27Z", "path": "core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java", "diffHunk": "@@ -127,6 +134,11 @@\n         assert executor instanceof EventLoop;\n         final EventLoop eventLoop = (EventLoop) executor;\n         final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop);\n+        if (metricRegistry != null) {", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMjI4Mw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471902283", "bodyText": "Could you use the TestDnsServer instead of using a public DNS server? This way, we can test all life cycle observer callbacks easily.", "author": "trustin", "createdAt": "2020-08-18T04:11:05Z", "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+import com.linecorp.armeria.common.metric.PrometheusMeterRegistries;\n+\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+\n+public class DnsMetricsTest {", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2ODg4Ng==", "url": "https://github.com/line/armeria/pull/2935#discussion_r481468886", "bodyText": "Done.", "author": "amitvc", "createdAt": "2020-09-01T22:33:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMjI4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMjQwMQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471902401", "bodyText": "Global comment: ClientFactory must be closed at the end of the test. Use try-with-resources on it.", "author": "trustin", "createdAt": "2020-08-18T04:11:37Z", "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+import com.linecorp.armeria.common.metric.PrometheusMeterRegistries;\n+\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+\n+public class DnsMetricsTest {\n+\n+    @Test\n+    void dns_metric_test_for_successful_query_writes() throws ExecutionException, InterruptedException {\n+        final ClientFactory factory = ClientFactory.builder()\n+                .meterRegistry(PrometheusMeterRegistries.newRegistry())\n+                .build();\n+\n+        final WebClient client2 = WebClient.builder()\n+                .factory(factory)\n+                .build();\n+\n+        client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://wikipedia.com\")).aggregate().get();\n+\n+        final double count = ((PrometheusMeterRegistry) factory.meterRegistry())\n+                .getPrometheusRegistry()\n+                .getSampleValue(\"armeria_client_dns_queries_total\",\n+                        new String[] {\"cause\",\"name\",\"result\"},\n+                        new String[] {\"\",\"wikipedia.com.\", \"success\"});\n+        assertThat(count > 1.0).isTrue();\n+    }\n+\n+    @Test\n+    void dns_metric_test_for_query_failures() throws ExecutionException, InterruptedException {\n+        final ClientFactory factory = ClientFactory.builder()\n+                .meterRegistry(PrometheusMeterRegistries.newRegistry())\n+                .build();\n+        try {\n+            final WebClient client2 = WebClient.builder()\n+                    .factory(factory)\n+                    .build();\n+            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://googleusercontent.com\")).aggregate().get();\n+        } catch (Exception ex) {\n+            final double count = ((PrometheusMeterRegistry) factory.meterRegistry())\n+                    .getPrometheusRegistry()\n+                    .getSampleValue(\"armeria_client_dns_queries_total\",\n+                            new String[] {\"cause\",\"name\",\"result\"},\n+                            new String[] {\"No matching record type found\",\"googleusercontent.com.\", \"failure\"});\n+            assertThat(count > 1.0).isTrue();\n+        }\n+    }\n+\n+    @Test\n+    void no_dns_registry_used_when_not_provided_externally() throws ExecutionException, InterruptedException {\n+        final ClientFactory factory = ClientFactory.builder()\n+                .build();", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d51e2d7160aea93657a37175c4488cf81a162983", "url": "https://github.com/line/armeria/commit/d51e2d7160aea93657a37175c4488cf81a162983", "message": "Rewrote unit test using DnsTestServer and address several cr comments", "committedDate": "2020-08-31T03:41:55Z", "type": "commit"}, {"oid": "7c471878e873c79203b3f1bd591ca1365e836f63", "url": "https://github.com/line/armeria/commit/7c471878e873c79203b3f1bd591ca1365e836f63", "message": "Addressing code review comments", "committedDate": "2020-09-02T03:44:24Z", "type": "commit"}, {"oid": "6129f8a064a38c572db68762f0b3039daa69c31d", "url": "https://github.com/line/armeria/commit/6129f8a064a38c572db68762f0b3039daa69c31d", "message": "wrap ClientFactory with try with resource block, general cleanup", "committedDate": "2020-09-02T03:54:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwMTM5Ng==", "url": "https://github.com/line/armeria/pull/2935#discussion_r484201396", "bodyText": "Could avoid using PrometheusMeterRegistries here, because we don't have a hard dependency on it. It has to be like the following IIUC:\nreturn builder.meterRegistry(options.meterRegistry()).build(eventLoopGroup);", "author": "trustin", "createdAt": "2020-09-07T06:10:21Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -597,7 +598,10 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+                        return builder\n+                                .meterRegistry(options.containsKey(ClientFactoryOptions.METER_REGISTRY) ?\n+                                        (MeterRegistry) options.get(ClientFactoryOptions.METER_REGISTRY).value()\n+                                        : PrometheusMeterRegistries.newRegistry()).build(eventLoopGroup);", "originalCommit": "6129f8a064a38c572db68762f0b3039daa69c31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIzMzExNg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r485233116", "bodyText": "options is an Map<ClientFactoryOption, ClientFactoryOptionValue> options in this class.   Also the reason I was doing the null check is because there is a static ClientFactory that is being instantiated inside the https://github.com/line/armeria/blob/master/core/src/main/java/com/linecorp/armeria/client/DefaultClientFactory.java#L72 and that does not have the options Map built up.", "author": "amitvc", "createdAt": "2020-09-08T22:38:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwMTM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3NDgzMQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r485274831", "bodyText": "Ahh, OK. Then could we use ClientFactoryOptions.of().meterRegistry() instead of PrometheusMeterRegistries.newRegistry(), so that the default registry is chosen automatically?", "author": "trustin", "createdAt": "2020-09-09T00:57:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwMTM5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwMjA5NA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r484202094", "bodyText": "Shouldn't SERVER_TAG be replaced with SERVERS_TAG (\"servers\")?", "author": "trustin", "createdAt": "2020-09-07T06:12:21Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private final PrometheusMeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = (PrometheusMeterRegistry)meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,", "originalCommit": "6129f8a064a38c572db68762f0b3039daa69c31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIzMzE4Mg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r485233182", "bodyText": "Yes I will make the change", "author": "amitvc", "createdAt": "2020-09-08T22:38:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwMjA5NA=="}], "type": "inlineReview"}, {"oid": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379", "url": "https://github.com/line/armeria/commit/b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379", "message": "Removed prometheus registry dependency and minor cleanup", "committedDate": "2020-09-10T04:17:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzIwMA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r486053200", "bodyText": "I do not see any metrics being recorded for this test. Where as if I pass in an external PrometheusMeterRegistries like I did in the other unit tests then I see the counters being incremented. Am I missing something here ?\n{armeria.client.connections.lifespan#count{protocol=h2c}=0.0, armeria.client.connections.lifespan#total{protocol=h2c}=0.0, armeria.client.connections.lifespan#max{protocol=h2c}=0.0, armeria.client.connections.lifespan#count{protocol=h1c}=0.0, armeria.client.connections.lifespan#total{protocol=h1c}=0.0, armeria.client.connections.lifespan#max{protocol=h1c}=0.0, armeria.client.dns.queries.written#count{name=google.com.,servers=2001:558:feed:0:0:0:0:1}=0.0, armeria.client.dns.queries#count{cause=none,name=google.com.,result=success}=0.0}", "author": "amitvc", "createdAt": "2020-09-10T04:19:10Z", "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -195,24 +196,15 @@ void dns_test_no_answer() throws ExecutionException, InterruptedException {\n \n     @Test\n     void test_with_real_dns_query() throws ExecutionException, InterruptedException {\n-        final MeterRegistry pm1 = PrometheusMeterRegistries.newRegistry();\n \n-        try (ClientFactory factory = ClientFactory.builder()\n-                .meterRegistry(pm1)\n-                .build()) {\n+        try (ClientFactory factory = ClientFactory.builder().build()) {\n             final WebClient client2 = WebClient.builder()\n                     .factory(factory)\n                     .build();\n \n-            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://wikipedia.com\")).aggregate().get();\n-            final PrometheusMeterRegistry registry =\n-                    (PrometheusMeterRegistry) factory.meterRegistry();\n-\n-            final double count = registry.getPrometheusRegistry()\n-                    .getSampleValue(\"armeria_client_dns_queries_total\",\n-                            new String[] {\"cause\",\"name\",\"result\"},\n-                            new String[] {\"none\",\"wikipedia.com.\", \"success\"});\n-            assertThat(count > 1.0).isTrue();\n+            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://google.com\")).aggregate().get();\n+            final MeterRegistry registry = factory.meterRegistry();\n+            System.out.println(MoreMeters.measureAll(registry));", "originalCommit": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1Mzk4Mw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r486053983", "bodyText": "No you didn't miss out anything. This is a test case, so we need to specify a concrete meter registry implementation, like you did before. My comment about removing the PrometheusMeterRegistry was for the main sources, not the test sources. Sorry if it was confusing. \ud83d\ude47", "author": "trustin", "createdAt": "2020-09-10T04:22:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzIwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0NTIzMw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r486745233", "bodyText": "Ok. In a real use case how do we pass the meterRegistry down to the ClientFactory? Currently, we have the ClientFactoryBuilder::buildOptions method is where we set the meterRegistry in the DnsResolverGroupBuilder used for the factory. We do something like this\nbuilder\n.meterRegistry(ClientFactoryOptions.of().meterRegistry())\n.build(eventLoopGroup);\nClientFactoryOptions.of().meterRegistry() uses the default Metrics.globalRegistry.\nFor the UT I was creating DnsResolverGroupBuilder and setting a new PrometheusMeterRegistries into that object. Then I was using the DnsResolverGroupBuilder i just built and doing something like this\ntry (ClientFactory factory = ClientFactory.builder()\n.addressResolverGroupFactory(builder::build", "author": "amitvc", "createdAt": "2020-09-11T03:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzIwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1ODYxNQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r486758615", "bodyText": "Ah, of course we should use ClientFacrotyOptions.of().meterRegistry() only when a user did not specify one, i.e. should use options.getOrDefault().", "author": "trustin", "createdAt": "2020-09-11T03:55:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzE0NA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r486053144", "bodyText": "You have to use SERVER_TAG here because this tag is for a single name server. \ud83d\ude09", "author": "trustin", "createdAt": "2020-09-10T04:18:52Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -61,7 +60,7 @@\n     public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n         meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n                 Arrays.asList(Tag.of(NAME_TAG, question.name()),\n-                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+                        Tag.of(SERVERS_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();", "originalCommit": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzI0NA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r486053244", "bodyText": "Bring the assertions back?", "author": "trustin", "createdAt": "2020-09-10T04:19:22Z", "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -195,24 +196,15 @@ void dns_test_no_answer() throws ExecutionException, InterruptedException {\n \n     @Test\n     void test_with_real_dns_query() throws ExecutionException, InterruptedException {\n-        final MeterRegistry pm1 = PrometheusMeterRegistries.newRegistry();\n \n-        try (ClientFactory factory = ClientFactory.builder()\n-                .meterRegistry(pm1)\n-                .build()) {\n+        try (ClientFactory factory = ClientFactory.builder().build()) {\n             final WebClient client2 = WebClient.builder()\n                     .factory(factory)\n                     .build();\n \n-            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://wikipedia.com\")).aggregate().get();\n-            final PrometheusMeterRegistry registry =\n-                    (PrometheusMeterRegistry) factory.meterRegistry();\n-\n-            final double count = registry.getPrometheusRegistry()\n-                    .getSampleValue(\"armeria_client_dns_queries_total\",\n-                            new String[] {\"cause\",\"name\",\"result\"},\n-                            new String[] {\"none\",\"wikipedia.com.\", \"success\"});\n-            assertThat(count > 1.0).isTrue();\n+            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://google.com\")).aggregate().get();\n+            final MeterRegistry registry = factory.meterRegistry();\n+            System.out.println(MoreMeters.measureAll(registry));", "originalCommit": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0NTI4Nw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r486745287", "bodyText": "Yes I will bring it back.", "author": "amitvc", "createdAt": "2020-09-11T03:00:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzU4Mg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r486053582", "bodyText": "You can still use PrometheusMeterRegistries.newRegistry() here because this class is a test class, i.e. You can revert the changes in this class.", "author": "trustin", "createdAt": "2020-09-10T04:20:49Z", "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -195,24 +196,15 @@ void dns_test_no_answer() throws ExecutionException, InterruptedException {\n \n     @Test\n     void test_with_real_dns_query() throws ExecutionException, InterruptedException {\n-        final MeterRegistry pm1 = PrometheusMeterRegistries.newRegistry();\n \n-        try (ClientFactory factory = ClientFactory.builder()\n-                .meterRegistry(pm1)\n-                .build()) {\n+        try (ClientFactory factory = ClientFactory.builder().build()) {", "originalCommit": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "084d9afad082712ba185ec3c65388b9bb95ad40c", "url": "https://github.com/line/armeria/commit/084d9afad082712ba185ec3c65388b9bb95ad40c", "message": "code to categorize dns exceptions, cleanup unit tests", "committedDate": "2020-09-13T14:32:39Z", "type": "commit"}, {"oid": "25d4e0944fc4ff6da8d371f008c8314584f35c4c", "url": "https://github.com/line/armeria/commit/25d4e0944fc4ff6da8d371f008c8314584f35c4c", "message": "Fix UT for RefreshingAddressResolverTest", "committedDate": "2020-09-13T16:01:58Z", "type": "commit"}, {"oid": "593fe20ec4e78237b3943e900b91c308f490ebba", "url": "https://github.com/line/armeria/commit/593fe20ec4e78237b3943e900b91c308f490ebba", "message": "fix failing ut", "committedDate": "2020-09-16T00:58:16Z", "type": "commit"}, {"oid": "744beaf10990521be775265eb98049c8e4f140d3", "url": "https://github.com/line/armeria/commit/744beaf10990521be775265eb98049c8e4f140d3", "message": "Add debug code to investigate failing ut on CI pipeline", "committedDate": "2020-09-16T01:52:59Z", "type": "commit"}, {"oid": "34b8c5fff113c58f61490b1b203a8783ca2818a2", "url": "https://github.com/line/armeria/commit/34b8c5fff113c58f61490b1b203a8783ca2818a2", "message": "Merge branch 'master' into 1887_dns_metrics_latest", "committedDate": "2020-10-07T07:53:25Z", "type": "commit"}, {"oid": "4598719e5b45c0d715b485632293b24cc9d27744", "url": "https://github.com/line/armeria/commit/4598719e5b45c0d715b485632293b24cc9d27744", "message": "Trying to figure out which is null", "committedDate": "2020-10-07T08:55:06Z", "type": "commit"}, {"oid": "4598719e5b45c0d715b485632293b24cc9d27744", "url": "https://github.com/line/armeria/commit/4598719e5b45c0d715b485632293b24cc9d27744", "message": "Trying to figure out which is null", "committedDate": "2020-10-07T08:55:06Z", "type": "forcePushed"}, {"oid": "9aa502f6566931169e84ef79287e62d5c33034ff", "url": "https://github.com/line/armeria/commit/9aa502f6566931169e84ef79287e62d5c33034ff", "message": "Fix test failures\n\n- Use `MoreMeters.measureAll()` which is more convenient for testing.\n  - Fixed a `NullPointerException` which occurs when unboxing `Double`.\n    - `null` is returned instead of `Double` when a meter is missing.\n- Use `await()` where necessary.\n- Add a test case for `NXDOMAIN`", "committedDate": "2020-10-07T11:20:53Z", "type": "commit"}, {"oid": "6028e40959ecd997cf01b4e2516203d9c89bfd69", "url": "https://github.com/line/armeria/commit/6028e40959ecd997cf01b4e2516203d9c89bfd69", "message": "Remove flaky test method / Shorten the timeout", "committedDate": "2020-10-07T11:48:16Z", "type": "commit"}, {"oid": "932575fe080f1519d32dce0c8733975b9f8516c3", "url": "https://github.com/line/armeria/commit/932575fe080f1519d32dce0c8733975b9f8516c3", "message": "Adding unit test for cname", "committedDate": "2020-10-09T13:33:31Z", "type": "commit"}, {"oid": "cd789c06ec86cba2a89eb79a410cfda6adde4357", "url": "https://github.com/line/armeria/commit/cd789c06ec86cba2a89eb79a410cfda6adde4357", "message": "Fix timeout ut for dns metrics", "committedDate": "2020-10-09T19:40:51Z", "type": "commit"}, {"oid": "d55ee3f168892cb3b0a69b75e848c0d8a8568a03", "url": "https://github.com/line/armeria/commit/d55ee3f168892cb3b0a69b75e848c0d8a8568a03", "message": "Remove NAME_SERVERS_EXHAUSTED_EXCEPTION exception assertion from noAnswer ut", "committedDate": "2020-10-14T01:23:09Z", "type": "commit"}, {"oid": "6409f1ce95cd97099c79bfbdffe7699bf5491856", "url": "https://github.com/line/armeria/commit/6409f1ce95cd97099c79bfbdffe7699bf5491856", "message": "Change the loopback address to ipv4 instead of ipv6", "committedDate": "2020-10-14T02:05:02Z", "type": "commit"}, {"oid": "c7b9f15834f26408ce5a254bba5d4b60558e3a9c", "url": "https://github.com/line/armeria/commit/c7b9f15834f26408ce5a254bba5d4b60558e3a9c", "message": "Fix unit test for timeout", "committedDate": "2020-10-17T04:24:53Z", "type": "commit"}, {"oid": "8428c533153b0d9284668f5b0a2cde09508a8b36", "url": "https://github.com/line/armeria/commit/8428c533153b0d9284668f5b0a2cde09508a8b36", "message": "Merge branch 'master' into 1887_dns_metrics_latest", "committedDate": "2020-11-02T01:57:12Z", "type": "commit"}, {"oid": "5bd61790c1672d8f2ef33bb957516cf85505d564", "url": "https://github.com/line/armeria/commit/5bd61790c1672d8f2ef33bb957516cf85505d564", "message": "Fix flakiness", "committedDate": "2020-11-02T02:45:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNjYwMg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r515716602", "bodyText": "How about inlining this method? It's used only in determineDNSExceptionTag.", "author": "trustin", "createdAt": "2020-11-02T02:50:27Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+        NX_DOMAIN_QUERY_FAILED_EXCEPTION,\n+        CNAME_NOT_FOUND_QUERY_FAILED_EXCEPTION,\n+        NO_MATCHING_RECORD_QUERY_FAILED_EXCEPTION,\n+        UNRECOGNIZED_TYPE_QUERY_FAILED_EXCEPTION,\n+        NAME_SERVERS_EXHAUSTED_EXCEPTION,\n+        DNS_EXCEPTION,\n+        DNS_TIMEOUT_EXCEPTION,\n+        DNS_RESOLVER_TIMEOUT_EXCEPTION\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVERS_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, determineDNSExceptionTag(cause).name()))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"success\"),\n+                        Tag.of(CAUSE_TAG, \"none\"))).increment();\n+    }\n+\n+    private static DnsExceptionTypes determineDNSExceptionTag(Throwable cause) {\n+        if (cause instanceof DnsTimeoutException) {\n+            return DnsExceptionTypes.DNS_TIMEOUT_EXCEPTION;\n+        } else if (cause instanceof DnsNameResolverTimeoutException) {\n+            return DnsExceptionTypes.DNS_RESOLVER_TIMEOUT_EXCEPTION;\n+        }\n+        return discoverExceptionType(cause.getMessage());\n+    }\n+\n+    private static DnsExceptionTypes discoverExceptionType(String message) {", "originalCommit": "5bd61790c1672d8f2ef33bb957516cf85505d564", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNDczOQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516434739", "bodyText": "Done.", "author": "amitvc", "createdAt": "2020-11-03T05:29:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNjYwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNjYzMw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r515716633", "bodyText": "DNS -> Dns (convention)", "author": "trustin", "createdAt": "2020-11-02T02:50:41Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+        NX_DOMAIN_QUERY_FAILED_EXCEPTION,\n+        CNAME_NOT_FOUND_QUERY_FAILED_EXCEPTION,\n+        NO_MATCHING_RECORD_QUERY_FAILED_EXCEPTION,\n+        UNRECOGNIZED_TYPE_QUERY_FAILED_EXCEPTION,\n+        NAME_SERVERS_EXHAUSTED_EXCEPTION,\n+        DNS_EXCEPTION,\n+        DNS_TIMEOUT_EXCEPTION,\n+        DNS_RESOLVER_TIMEOUT_EXCEPTION\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVERS_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, determineDNSExceptionTag(cause).name()))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"success\"),\n+                        Tag.of(CAUSE_TAG, \"none\"))).increment();\n+    }\n+\n+    private static DnsExceptionTypes determineDNSExceptionTag(Throwable cause) {", "originalCommit": "5bd61790c1672d8f2ef33bb957516cf85505d564", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNzkxMQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r515717911", "bodyText": "How about:\n\nremoving _QUERY_FAILED, _EXCEPTION and DNS_ from all values? e.g.\n\nNX_DOMAIN_QUERY_FAILED_EXCEPTION -> NX_DOMAIN\nDNS_TIMEOUT_EXCEPTION -> TIMEOUT\n\n\nrenaming DNS_EXCEPTION to OTHERS?\nrenaming DNS_TIMEOUT_EXCEPTION to SERVER_TIMEOUT so a user can distinguish it better from RESOLVER_TIMEOUT?\nproviding lower-cased values so we can use them as tag values? i.e.\nprivate enum DnsExceptionTypes {\n    ...;\n\n    final String lowerCasedName;\n\n    DnsExceptionTypes() {\n        tag = Ascii.toLowerCase(name());\n    }\n}\n...\n\nTag.of(CAUSE_TAG, type.lowerCasedName)", "author": "trustin", "createdAt": "2020-11-02T02:57:09Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+        NX_DOMAIN_QUERY_FAILED_EXCEPTION,\n+        CNAME_NOT_FOUND_QUERY_FAILED_EXCEPTION,\n+        NO_MATCHING_RECORD_QUERY_FAILED_EXCEPTION,\n+        UNRECOGNIZED_TYPE_QUERY_FAILED_EXCEPTION,\n+        NAME_SERVERS_EXHAUSTED_EXCEPTION,\n+        DNS_EXCEPTION,\n+        DNS_TIMEOUT_EXCEPTION,\n+        DNS_RESOLVER_TIMEOUT_EXCEPTION", "originalCommit": "5bd61790c1672d8f2ef33bb957516cf85505d564", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxODkwNA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r515718904", "bodyText": "I guess almost all failed queries will end up getting NAME_SERVERS_EXHAUSTED_EXCEPTION, which means it's a kind of duplicate. Could we ignore it until we have a clear reason why we would want to record it?", "author": "trustin", "createdAt": "2020-11-02T03:02:10Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+        NX_DOMAIN_QUERY_FAILED_EXCEPTION,\n+        CNAME_NOT_FOUND_QUERY_FAILED_EXCEPTION,\n+        NO_MATCHING_RECORD_QUERY_FAILED_EXCEPTION,\n+        UNRECOGNIZED_TYPE_QUERY_FAILED_EXCEPTION,\n+        NAME_SERVERS_EXHAUSTED_EXCEPTION,\n+        DNS_EXCEPTION,\n+        DNS_TIMEOUT_EXCEPTION,\n+        DNS_RESOLVER_TIMEOUT_EXCEPTION\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVERS_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, determineDNSExceptionTag(cause).name()))).increment();", "originalCommit": "5bd61790c1672d8f2ef33bb957516cf85505d564", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxOTMyOQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r515719329", "bodyText": "If we're going to make this class public, we have to hide it from the public API. Could you move this class to internal.client? We could also merge it into internal.client.DnsUtil.", "author": "trustin", "createdAt": "2020-11-02T03:04:38Z", "path": "core/src/test/java/com/linecorp/armeria/client/endpoint/dns/DnsNameEncoder.java", "diffHunk": "@@ -18,9 +18,9 @@\n import io.netty.buffer.ByteBuf;\n import io.netty.handler.codec.dns.DefaultDnsRecordEncoder;\n \n-final class DnsNameEncoder {\n+public final class DnsNameEncoder {\n \n-    static void encodeName(String name, ByteBuf out) {\n+    public static void encodeName(String name, ByteBuf out) {", "originalCommit": "5bd61790c1672d8f2ef33bb957516cf85505d564", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "url": "https://github.com/line/armeria/commit/5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "message": "Removed DnsNameEncoder and reconciled the code to DnsUtil, Cleaned up DnsExceptionTypes enum for better readability", "committedDate": "2020-11-03T05:28:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNzI4OQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516437289", "bodyText": "How about just using Metrics.globalRegistry?\nBecause I have to track down which registry will be used if it's not specified.\nfinal MeterRegistry registry;\nfinal ClientFactoryOptionValue<?> opt = options.get(\n        ClientFactoryOptions.METER_REGISTRY);\nif (opt != null) {\n    registry = (MeterRegistry) opt.value();\n} else {\n    registry = Metrics.globalRegistry;\n}\n\nreturn builder.meterRegistry(registry)\n              .build(eventLoopGroup);", "author": "minwoox", "createdAt": "2020-11-03T05:41:42Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -616,7 +616,15 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+\n+                        final ClientFactoryOptionValue<?> opt = options\n+                                .getOrDefault(ClientFactoryOptions.METER_REGISTRY,\n+                                ClientFactoryOptions.METER_REGISTRY", "originalCommit": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ1NzYwMA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516457600", "bodyText": "It's basically same. I suggested this so that we can use the default MeterRegistry defined in ClientFactoryOptions, but I'm fine with @minwoox's suggestion given our default will not change.", "author": "trustin", "createdAt": "2020-11-03T07:02:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNzI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ1ODM1OQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516458359", "bodyText": "I'm fine as it is. \ud83d\ude04  Just don't forget to indent the line. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-11-03T07:05:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNzI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0MjY1Nw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r517042657", "bodyText": "Done.", "author": "amitvc", "createdAt": "2020-11-04T01:08:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNzI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzOTQ2Mw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516439463", "bodyText": "THis is not used. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-11-03T05:51:44Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");", "originalCommit": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0MjcyNQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r517042725", "bodyText": "\ud83d\ude04 Done.", "author": "amitvc", "createdAt": "2020-11-04T01:08:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzOTQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTYwMDQwNQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r519600405", "bodyText": "This needs to be brought back so that it doesn't fall into 'OTHERS' case.", "author": "trustin", "createdAt": "2020-11-09T07:29:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzOTQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516442260", "bodyText": "I think we should set this in DnsResolverGroupBuilder so that this factory is not overridden by the observer factory that the user configures.", "author": "minwoox", "createdAt": "2020-11-03T06:04:01Z", "path": "core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java", "diffHunk": "@@ -127,6 +133,9 @@\n         assert executor instanceof EventLoop;\n         final EventLoop eventLoop = (EventLoop) executor;\n         final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop);\n+        builder.dnsQueryLifecycleObserverFactory(", "originalCommit": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0MzM2MQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r517043361", "bodyText": "Can you please elaborate on this? You mean set the dnsQueryLifecycleObserverFactory in the DnsResolverGroupBuilder::build method ?", "author": "amitvc", "createdAt": "2020-11-04T01:10:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0ODE1OQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r517048159", "bodyText": "Sure. \ud83d\ude04\nAfter we set the observer factory resolverConfigurator.accept(builder); at line 139 is called.\nIn that method, another observer factory might be set\nhttps://github.com/line/armeria/blob/master/core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java#L332\nSo I think we can do sort of:\nfinal DnsQueryLifecycleObserverFactory defaultObserverFactory =\n        new DefaultDnsQueryLifecycleObserverFactory(\n                meterRegistry, new MeterIdPrefix(\"armeria.client.dns.queries\")));\nif (dnsQueryLifecycleObserverFactory == null) {\n    builder.dnsQueryLifecycleObserverFactory(defaultObserverFactory);\n} else {\n    builder.dnsQueryLifecycleObserverFactory(\n            new SomeWrapper(defaultObserverFactory, dnsQueryLifecycleObserverFactory));\n}", "author": "minwoox", "createdAt": "2020-11-04T01:28:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0OTEyMQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r517049121", "bodyText": "And we might need to add a boolean parameter to the setter so that a user can choose the behavior?\nDnsResolverGrouBuilder.dnsQueryLifecycleObserverFactory(observerFactory, overrideDefaultFactory)\nI'm not sure if it's a good idea though. \ud83d\ude05\nDo you have any suggestion? @trustin, @ikhoon", "author": "minwoox", "createdAt": "2020-11-04T01:31:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyNzY2OA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r518727668", "bodyText": "@trustin @ikhoon  can you please comment when you get a chance?", "author": "amitvc", "createdAt": "2020-11-06T12:43:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUxNjc2Ng==", "url": "https://github.com/line/armeria/pull/2935#discussion_r519516766", "bodyText": "Sorry for the late reply. Let me take a look.", "author": "ikhoon", "createdAt": "2020-11-09T02:04:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5OTA4NA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r519599084", "bodyText": "How about moving the modifications in this class to DnsResolverGroupBuilder, so that:\n\nRefreshingAddressResolverGroup doesn't change.\nDnsResolverGroupBuilder creates the default observer factory;\nDnsResolverGroupBuilder.build() creates the resolverConfigurator that calls DnsNameResolverBuilder.dnsQueryLifecycleObserverFactory() with the default observer factory.\n\nUse io.netty.resolver.dns.BiDnsQueryLifecycleObserverFactory to combine the default observer factory and the user-specified observer factory.\n\n\n\nMakes sense?", "author": "trustin", "createdAt": "2020-11-09T07:26:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTYwMjc0Mg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r519602742", "bodyText": "I didn't know there was BiDnsQueryLifecycleObserverFactory \ud83d\ude04", "author": "minwoox", "createdAt": "2020-11-09T07:35:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjY5NQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516442695", "bodyText": "Let's remove this return statement and just do:\nSets {@link MeterRegistry} to collect the DNS query metrics.", "author": "minwoox", "createdAt": "2020-11-03T06:05:45Z", "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -292,6 +295,16 @@ public DnsResolverGroupBuilder decodeIdn(boolean decodeIdn) {\n         return this;\n     }\n \n+    /**\n+     * Sets MeterRegistry.\n+     * @param meterRegistry {@link MeterRegistry}.\n+     * @return DnsResolverGroupBuilder.", "originalCommit": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0MzM3OQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r517043379", "bodyText": "done", "author": "amitvc", "createdAt": "2020-11-04T01:11:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjY5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MzE3NQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516443175", "bodyText": "Could you check the indentation of this class?", "author": "minwoox", "createdAt": "2020-11-03T06:07:44Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),", "originalCommit": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MzM1MQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516443351", "bodyText": "Let's just use + as IDEA suggested which is more readable:\nmeterIdPrefix.name() + \".written\"", "author": "minwoox", "createdAt": "2020-11-03T06:08:35Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),", "originalCommit": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0MzQwNQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r517043405", "bodyText": "done", "author": "amitvc", "createdAt": "2020-11-04T01:11:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MzM1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NDc0MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516444740", "bodyText": "Perhaps we can make Tag.of(NAME_TAG, question.name()) in the constructor and reuse it?", "author": "minwoox", "createdAt": "2020-11-03T06:13:51Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),", "originalCommit": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4MTM1OA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r517081358", "bodyText": "Done", "author": "amitvc", "createdAt": "2020-11-04T03:42:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NDc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTQ0NA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516445444", "bodyText": "Can we remove this CAUSE_TAG?", "author": "minwoox", "createdAt": "2020-11-03T06:16:49Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVERS_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"success\"),\n+                        Tag.of(CAUSE_TAG, \"none\"))).increment();", "originalCommit": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ1ODA0Mg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516458042", "bodyText": "Can we? queryFailed() uses the same meter name, so we have to keep the same set of tags.", "author": "trustin", "createdAt": "2020-11-03T07:04:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTQ0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ1ODY3Nw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516458677", "bodyText": "Oops, I missed that. \ud83d\ude05", "author": "minwoox", "createdAt": "2020-11-03T07:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTkzNg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516445936", "bodyText": "How about moving this method and the class to a test class because they are only used by tests?", "author": "minwoox", "createdAt": "2020-11-03T06:19:03Z", "path": "core/src/main/java/com/linecorp/armeria/internal/client/DnsUtil.java", "diffHunk": "@@ -98,4 +99,24 @@ public static void warnInvalidRecord(Logger logger, String logPrefix, DnsRecordT\n     }\n \n     private DnsUtil() {}\n+\n+    public static void encodeName(String name, ByteBuf out) {", "originalCommit": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ1ODUxMA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516458510", "bodyText": "Ahh, never knew that this is used only by test classes. Sorry, @amitvc, but could we revert this?", "author": "trustin", "createdAt": "2020-11-03T07:05:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTkzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0MzU0Nw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r517043547", "bodyText": "No problem @trustin. I reverted this particular change.", "author": "amitvc", "createdAt": "2020-11-04T01:11:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTkzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4ODQyMQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r519588421", "bodyText": "Thanks, @amitvc \ud83d\ude47", "author": "trustin", "createdAt": "2020-11-09T07:08:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTkzNg=="}], "type": "inlineReview"}, {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "url": "https://github.com/line/armeria/commit/8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "message": "Fix indentation, revert deleted code, initializing name tag for reuse", "committedDate": "2020-11-04T01:08:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4OTU5Ng==", "url": "https://github.com/line/armeria/pull/2935#discussion_r519589596", "bodyText": "This seems unused as well \ud83d\ude09", "author": "trustin", "createdAt": "2020-11-09T07:11:51Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,", "originalCommit": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgwMTY4MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r521801680", "bodyText": "Yes. I have removed it.", "author": "amitvc", "createdAt": "2020-11-12T03:30:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4OTU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDAxOA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r519590018", "bodyText": "How about keeping the names as member fields so we don't have to do string concatenation every time?", "author": "trustin", "createdAt": "2020-11-09T07:13:00Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",", "originalCommit": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgwMTc2Nw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r521801767", "bodyText": "Done.", "author": "amitvc", "createdAt": "2020-11-12T03:31:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDMyMw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r519590323", "bodyText": "else is redundant.", "author": "trustin", "createdAt": "2020-11-09T07:13:46Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))\n+                              .increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cancelled\",\n+                              Tags.of(nameTag)).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".redirected\",\n+                              Arrays.asList(nameTag, Tag.of(SERVERS_TAG,\n+                              nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                              .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cnamed\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".noanswer\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"failure\"),\n+                              Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"success\"),\n+                              Tag.of(CAUSE_TAG, \"none\"))).increment();\n+    }\n+\n+    private static DnsExceptionTypes determineDnsExceptionTag(Throwable cause) {\n+        if (cause instanceof DnsTimeoutException) {\n+            return DnsExceptionTypes.SERVER_TIMEOUT;\n+        } else if (cause instanceof DnsNameResolverTimeoutException) {", "originalCommit": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgwMTgzNg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r521801836", "bodyText": "Done.", "author": "amitvc", "createdAt": "2020-11-12T03:31:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDc4NA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r519590784", "bodyText": "Shouldn't we ignore the 'exhausted name servers' error here instead of returning OTHERS, so that the counter doesn't increase?", "author": "trustin", "createdAt": "2020-11-09T07:14:39Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))\n+                              .increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cancelled\",\n+                              Tags.of(nameTag)).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".redirected\",\n+                              Arrays.asList(nameTag, Tag.of(SERVERS_TAG,\n+                              nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                              .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cnamed\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".noanswer\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"failure\"),\n+                              Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"success\"),\n+                              Tag.of(CAUSE_TAG, \"none\"))).increment();\n+    }\n+\n+    private static DnsExceptionTypes determineDnsExceptionTag(Throwable cause) {\n+        if (cause instanceof DnsTimeoutException) {\n+            return DnsExceptionTypes.SERVER_TIMEOUT;\n+        } else if (cause instanceof DnsNameResolverTimeoutException) {\n+            return DnsExceptionTypes.RESOLVER_TIMEOUT;\n+        }\n+        final String message = cause.getMessage();\n+        if (NXDOMAIN_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.NX_DOMAIN;\n+        }\n+\n+        if (CNAME_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.CNAME_NOT_FOUND;\n+        }\n+\n+        if (NO_MATCHING_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.NO_MATCHING_RECORD;\n+        }\n+\n+        if (UNRECOGNIZED_TYPE_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.UNRECOGNIZED_TYPE;\n+        }\n+", "originalCommit": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgwMDgzNg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r521800836", "bodyText": "Are you suggesting exhausted name servers exception should not be tagged in a counter that is incremented queryFailed callback ?\nI am also noticing this exception is being thrown \"No name servers returned an answer\" but we capture it as other. Don't know what we want to do here.", "author": "amitvc", "createdAt": "2020-11-12T03:29:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDc4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk3NTEyOQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r523975129", "bodyText": "Are you suggesting exhausted name servers exception should not be tagged in a counter that is incremented queryFailed callback ?\n\nYes, but see below:\n\nI am also noticing this exception is being thrown \"No name servers returned an answer\" but we capture it as other. Don't know what we want to do here.\n\nThat's a good point. Is it possible to count \"No name servers returned an answer\" as a separate counter, and ignore other 'exhausted name servers' exceptions?", "author": "trustin", "createdAt": "2020-11-16T08:42:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDc4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg2ODQ4NA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r524868484", "bodyText": "I have added a new tag for \"No name servers returned an answer\"", "author": "amitvc", "createdAt": "2020-11-17T03:55:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDc4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg4NDE0NA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r524884144", "bodyText": "@trustin Sorry for the confusion the \"No name servers returned an answer\" is basically NAME_SERVERS_EXHAUSTED_EXCEPTION returned by the DnsResolveContext[netty class] that we had agreed to ignore.", "author": "amitvc", "createdAt": "2020-11-17T04:55:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5OTgzNQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r519599835", "bodyText": "Global comment: Could we also make sure that no other unexpected counters are created or increased for all test cases? e.g. the meter with cause=others should be 0 or non-existent.", "author": "trustin", "createdAt": "2020-11-09T07:27:47Z", "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import static com.linecorp.armeria.client.endpoint.dns.TestDnsServer.newAddressRecord;\n+import static io.netty.handler.codec.dns.DnsRecordType.A;\n+import static io.netty.handler.codec.dns.DnsRecordType.AAAA;\n+import static io.netty.handler.codec.dns.DnsRecordType.CNAME;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.netty.handler.codec.dns.DnsSection.ANSWER;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.client.endpoint.dns.DnsNameEncoder;\n+import com.linecorp.armeria.client.endpoint.dns.TestDnsServer;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+import com.linecorp.armeria.common.metric.PrometheusMeterRegistries;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.handler.codec.dns.DatagramDnsQuery;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DefaultDnsRawRecord;\n+import io.netty.handler.codec.dns.DefaultDnsResponse;\n+import io.netty.handler.codec.dns.DnsOpCode;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DnsServerAddressStreamProvider;\n+import io.netty.resolver.dns.DnsServerAddresses;\n+import io.netty.util.ReferenceCountUtil;\n+\n+public class DnsMetricsTest {\n+\n+    @Test\n+    void success() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"foo.com.\", A),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"127.0.0.1\"))\n+                        .addRecord(ANSWER, newAddressRecord(\"unrelated.com\", \"1.2.3.4\")),\n+                new DefaultDnsQuestion(\"foo.com.\", AAAA),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"::1\"))\n+        ))) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writeMeterId =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=\" +\n+                        server.addr().getHostString() + '}';\n+                final String successMeterId =\n+                        \"armeria.client.dns.queries#count{cause=none,name=foo.com.,result=success}\";\n+                assertThat(MoreMeters.measureAll(meterRegistry))\n+                        .doesNotContainKeys(writeMeterId, successMeterId);\n+\n+                client.get(\"http://foo.com:1/\").aggregate();\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsEntry(writeMeterId, 1.0)\n+                            .containsEntry(successMeterId, 1.0);\n+                });\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void timeout() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"foo.com.\", A),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"127.0.0.1\"))\n+        ), new AlwaysTimeoutHandler())) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                        builder.queryTimeout(Duration.ofSeconds(1));\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client2 = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writeMeterId_ipv4_addr =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=127.0.0.1}\";\n+                final String writeMeterId_ipv6_addr =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=0:0:0:0:0:0:0:1}\";\n+                final String timeoutMeterId =\n+                        \"armeria.client.dns.queries#count{\" +\n+                        \"cause=resolver_timeout,name=foo.com.,result=failure}\";\n+                assertThat(MoreMeters.measureAll(meterRegistry))\n+                        .doesNotContainKeys(writeMeterId_ipv4_addr,writeMeterId_ipv6_addr, timeoutMeterId);\n+\n+                assertThatThrownBy(() -> client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://foo.com\"))\n+                        .aggregate().join())\n+                        .hasCauseInstanceOf(UnprocessedRequestException.class)\n+                        .hasRootCauseExactlyInstanceOf(DnsTimeoutException.class);\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsAnyOf(entry(writeMeterId_ipv6_addr, 1.0),\n+                                    entry(writeMeterId_ipv4_addr, 1.0));\n+                });\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void nxDomain() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"bar.com.\", A),\n+                new DefaultDnsResponse(0, DnsOpCode.QUERY, DnsResponseCode.NXDOMAIN)\n+        ))) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.searchDomains();\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writtenMeterId =\n+                        \"armeria.client.dns.queries.written#count{name=bar.com.,server=\" +\n+                        server.addr().getHostString() + '}';\n+                final String nxDomainMeterId =\n+                        \"armeria.client.dns.queries#count{\" +\n+                        \"cause=nx_domain,name=bar.com.,result=failure}\";\n+                assertThatThrownBy(() -> client.get(\"http://bar.com\").aggregate().join())\n+                        .hasRootCauseInstanceOf(UnknownHostException.class);\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsEntry(writtenMeterId, 2.0)\n+                            .containsEntry(nxDomainMeterId, 2.0);", "originalCommit": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk3Mjk1Nw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r523972957", "bodyText": "Gentle ping \ud83d\ude04", "author": "trustin", "createdAt": "2020-11-16T08:39:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5OTgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg2ODc3OQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r524868779", "bodyText": "I ran the test with some debug code to print the metric registry for each UT -\nThe results below confirm we do not see cause=others any more. Please ignore the no_name_server_found log. This output was added before I added fix to ignore no_name_server_found.\n----------------------------------------Running success----------------------------------------\n{armeria.client.dns.queries.written#count{name=foo.com.,server=0:0:0:0:0:0:0:1}=1.0, armeria.client.dns.queries#count{cause=none,name=foo.com.,result=success}=1.0}\n----------------------------------------Running timeout----------------------------------------\n{armeria.client.dns.queries#count{cause=no_name_server_found,name=foo.com.,result=failure}=2.0, armeria.client.dns.queries#count{cause=resolver_timeout,name=foo.com.,result=failure}=1.0, armeria.client.dns.queries.written#count{name=foo.com.,server=0:0:0:0:0:0:0:1}=1.0}\n----------------------------------------Running nxDomain----------------------------------------\n{armeria.client.dns.queries#count{cause=nx_domain,name=bar.com.,result=failure}=2.0, armeria.client.dns.queries#count{cause=no_name_server_found,name=bar.com.,result=failure}=3.0, armeria.client.dns.queries.written#count{name=bar.com.,server=0:0:0:0:0:0:0:1}=2.0}\n22:46:37.220 [Test worker] DEBUG c.l.a.i.c.DefaultDnsNameResolver - [bar.com] Sending a DNS query: DnsQuestion(bar.com IN A)\n------------------------------------Running cname----------------------------------------\n{armeria.client.dns.queries.cnamed#count{cname=baz.com.,name=bar.com.}=1.0, armeria.client.connections.lifespan#count{protocol=h2c}=0.0, armeria.client.connections.lifespan#total{protocol=h2c}=0.0, armeria.client.connections.lifespan#max{protocol=h2c}=0.0, armeria.client.dns.queries#count{cause=none,name=bar.com.,result=success}=2.0, armeria.client.dns.queries.written#count{name=bar.com.,server=0:0:0:0:0:0:0:1}=2.0}\n----------------------------------------Running noAnswer----------------------------------------\ncom.linecorp.armeria.client.RefreshingAddressResolver$CacheEntry$$Lambda$595/0x0000000800f9f040@710be18c\n{armeria.client.dns.queries.noanswer#count{code=10,name=bar.com.}=1.0, armeria.client.dns.queries#count{cause=nx_domain,name=bar.com.,result=failure}=1.0, armeria.client.dns.queries#count{cause=no_name_server_found,name=bar.com.,result=failure}=3.0, armeria.client.dns.queries.written#count{name=bar.com.,server=0:0:0:0:0:0:0:1}=2.0}", "author": "amitvc", "createdAt": "2020-11-17T03:56:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5OTgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYxOTgzMA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r526619830", "bodyText": "Great, but could we automate the checks, like adding some assertions?", "author": "trustin", "createdAt": "2020-11-19T06:21:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5OTgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAyMjg0MQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r529022841", "bodyText": "Yes I have added them now.", "author": "amitvc", "createdAt": "2020-11-23T21:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5OTgzNQ=="}], "type": "inlineReview"}, {"oid": "4e6a235c83cecdd402ef5995d45ec218ac731252", "url": "https://github.com/line/armeria/commit/4e6a235c83cecdd402ef5995d45ec218ac731252", "message": "Merge master into 1887_dns_metrics_latest", "committedDate": "2020-11-12T01:46:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3NjI5Mg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r521776292", "bodyText": "Don't we need \\ after unrecognized?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n          \n          \n            \n                private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b/\");", "author": "ikhoon", "createdAt": "2020-11-12T02:22:49Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");", "originalCommit": "4e6a235c83cecdd402ef5995d45ec218ac731252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc5NzQ3OQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r521797479", "bodyText": "Fixed.", "author": "amitvc", "createdAt": "2020-11-12T03:24:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3NjI5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3NzE2OQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r521777169", "bodyText": "How about creating a singleton instance for Tag.of(RESULT_TAG, \"success\") and reuse?", "author": "ikhoon", "createdAt": "2020-11-12T02:25:50Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))\n+                              .increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cancelled\",\n+                              Tags.of(nameTag)).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".redirected\",\n+                              Arrays.asList(nameTag, Tag.of(SERVERS_TAG,\n+                              nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                              .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cnamed\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".noanswer\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"failure\"),\n+                              Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"success\"),", "originalCommit": "4e6a235c83cecdd402ef5995d45ec218ac731252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc5NzM4OQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r521797389", "bodyText": "Done", "author": "amitvc", "createdAt": "2020-11-12T03:24:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3NzE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3NzI2Nw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r521777267", "bodyText": "How about creating a singleton instance for Tag.of(RESULT_TAG, \"failure\") and reuse?", "author": "ikhoon", "createdAt": "2020-11-12T02:26:15Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))\n+                              .increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cancelled\",\n+                              Tags.of(nameTag)).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".redirected\",\n+                              Arrays.asList(nameTag, Tag.of(SERVERS_TAG,\n+                              nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                              .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cnamed\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".noanswer\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"failure\"),", "originalCommit": "4e6a235c83cecdd402ef5995d45ec218ac731252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc5NzMyMg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r521797322", "bodyText": "Done.", "author": "amitvc", "createdAt": "2020-11-12T03:24:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3NzI2Nw=="}], "type": "inlineReview"}, {"oid": "c87bff10cf7978200b5cce4469d3096ad01a01bf", "url": "https://github.com/line/armeria/commit/c87bff10cf7978200b5cce4469d3096ad01a01bf", "message": "addressing several code review comments - Moved meterRegistry from RefreshingAddressResolverGroup, move initialization of DefaultDnsQueryLifecycleObserverFactory to DnsResolverGroupBuilder", "committedDate": "2020-11-12T03:23:45Z", "type": "commit"}, {"oid": "48c4621c689b0c9e39b88f58c5f1ba2489679d3d", "url": "https://github.com/line/armeria/commit/48c4621c689b0c9e39b88f58c5f1ba2489679d3d", "message": "Merge branch 'master' into 1887_dns_metrics_latest", "committedDate": "2020-11-16T08:40:15Z", "type": "commit"}, {"oid": "e67f3f650a8a2ca5eb7677ffbebd075ecff5d136", "url": "https://github.com/line/armeria/commit/e67f3f650a8a2ca5eb7677ffbebd075ecff5d136", "message": "Added no name server tag to the counters and ut for it", "committedDate": "2020-11-17T03:54:54Z", "type": "commit"}, {"oid": "eee42f7ce0241a3edfb8ea9ca3d76efcfe190df9", "url": "https://github.com/line/armeria/commit/eee42f7ce0241a3edfb8ea9ca3d76efcfe190df9", "message": "Merge branch '1887_dns_metrics_latest' of https://github.com/amitvc/armeria into 1887_dns_metrics_latest", "committedDate": "2020-11-17T03:56:47Z", "type": "commit"}, {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3", "url": "https://github.com/line/armeria/commit/736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3", "message": "Ignore NAME_SERVERS_EXHAUSTED_EXCEPTION (No name servers returned an answer) exception from being measured with a metric", "committedDate": "2020-11-17T05:08:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU0NzE2Ng==", "url": "https://github.com/line/armeria/pull/2935#discussion_r526547166", "bodyText": "nit: indentation?", "author": "minwoox", "createdAt": "2020-11-19T02:14:46Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -616,7 +616,16 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+\n+                        final ClientFactoryOptionValue<?> opt = options\n+                                .getOrDefault(ClientFactoryOptions.METER_REGISTRY,\n+                                ClientFactoryOptions\n+                                .METER_REGISTRY", "originalCommit": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU0OTk3MQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r526549971", "bodyText": "extra slash?", "author": "minwoox", "createdAt": "2020-11-19T02:23:52Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");", "originalCommit": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1MDAwOA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r526550008", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-11-19T02:23:58Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b/\");", "originalCommit": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1MDM0MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r526550340", "bodyText": "nit: indentation?", "author": "minwoox", "createdAt": "2020-11-19T02:24:53Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b/\");\n+    private static final Pattern NO_NS_RETURNED_EXCEPTION = Pattern.compile(\"\\\\bservers returned an answer\\\\b\");\n+    private static final Tag TAG_SUCCESS = Tag.of(RESULT_TAG, \"success\");\n+    private static final Tag TAG_FAILURE = Tag.of(RESULT_TAG, \"failure\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+    private final String meterIdPrefixWritten;\n+    private final String meterIdPrefixCancelled;\n+    private final String meterIdPrefixRedirected;\n+    private final String meterIdPrefixCnamed;\n+    private final String meterIdPrefixNoAnswer;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+        meterIdPrefixWritten = meterIdPrefix.name() + \".written\";\n+        meterIdPrefixCancelled = meterIdPrefix.name() + \".cancelled\";\n+        meterIdPrefixRedirected = meterIdPrefix.name() + \".redirected\";\n+        meterIdPrefixCnamed = meterIdPrefix.name() + \".cnamed\";\n+        meterIdPrefixNoAnswer = meterIdPrefix.name() + \".noanswer\";\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefixWritten,\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))", "originalCommit": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NDM2OQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r526554369", "bodyText": "How about making this public?", "author": "minwoox", "createdAt": "2020-11-19T02:36:52Z", "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -297,6 +302,14 @@ public DnsResolverGroupBuilder decodeIdn(boolean decodeIdn) {\n         return this;\n     }\n \n+    /**\n+     * Sets {@link MeterRegistry} to collect the DNS query metrics.\n+     */\n+    DnsResolverGroupBuilder meterRegistry(MeterRegistry meterRegistry) {", "originalCommit": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4NTAwMw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r526585003", "bodyText": "No, because we should use the meterRegistry specified in ClientFactoryBuilder.meterRegistry().", "author": "trustin", "createdAt": "2020-11-19T04:21:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NDM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NDc3MQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r526554771", "bodyText": "Let's add assert meterRegistry != null so that IDE does not complain.\nLet's exctrat\nnew DefaultDnsQueryLifecycleObserverFactory(\n    meterRegistry, new MeterIdPrefix(\"armeria.client.dns.queries\"))\nbefore line 359", "author": "minwoox", "createdAt": "2020-11-19T02:38:18Z", "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -343,8 +356,15 @@ RefreshingAddressResolverGroup build(EventLoopGroup eventLoopGroup) {\n             if (dnsServerAddressStreamProvider != null) {\n                 builder.nameServerProvider(dnsServerAddressStreamProvider);\n             }\n-            if (dnsQueryLifecycleObserverFactory != null) {\n-                builder.dnsQueryLifecycleObserverFactory(dnsQueryLifecycleObserverFactory);\n+            if (dnsQueryLifecycleObserverFactory == null) {\n+                builder.dnsQueryLifecycleObserverFactory(new DefaultDnsQueryLifecycleObserverFactory(\n+                        meterRegistry, new MeterIdPrefix(\"armeria.client.dns.queries\")));", "originalCommit": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM2NjI3OA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r527366278", "bodyText": "@minwoox Interesting observation. If I extract the construction of DefaultDnsQueryLifecycleObserverFactory and then pass the same DefaultDnsQueryLifecycleObserverFactory to both cases then the UT break because we are now using the same DnsQueryLifecycleObserverFactory. The UT break because the write counts are 2 times. Question is we should use the same DnsQueryLifecycleObserverFactory and not create it independently in both cases. I think this might be a bug. What do you think? The breaking UT when I extract the creation of dnsQueryLifecycleObserverFactory is below -\nio.micrometer.core.instrument.MeterRegistryjava.lang.String \nExpecting map:\n <{\"armeria.client.connections.lifespan#count{protocol=h2c}\"=0.0, \"armeria.client.connections.lifespan#max{protocol=h2c}\"=0.0, \"armeria.client.connections.lifespan#total{protocol=h2c}\"=0.0, \"armeria.client.dns.queries#count{cause=none,name=foo.com.,result=success}\"=2.0, \"armeria.client.dns.queries.written#count{name=foo.com.,server=0:0:0:0:0:0:0:1}\"=2.0}>\nto contain:\n <[MapEntry[key=\"armeria.client.dns.queries.written#count{name=foo.com.,server=0:0:0:0:0:0:0:1}\", value=1.0]]>\nbut could not find the following map entries:\n <[MapEntry[key=\"armeria.client.dns.queries.written#count{name=foo.com.,server=0:0:0:0:0:0:0:1}\", value=1.0]]>", "author": "amitvc", "createdAt": "2020-11-20T03:12:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NDc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM3MzM1MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r527373350", "bodyText": "Had a chat with @amitvc and I hope it succeeds this time. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-11-20T03:39:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NDc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwNDQ5Mg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r527704492", "bodyText": "@minwoox the build is successful I think. https://ci.appveyor.com/project/line/armeria/builds/36414924/job/82eers20is37trhi", "author": "amitvc", "createdAt": "2020-11-20T13:53:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NDc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NTk4MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r526555980", "bodyText": "Let's move this class to a test package. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-11-19T02:42:04Z", "path": "core/src/test/java/com/linecorp/armeria/client/endpoint/dns/DnsNameEncoder.java", "diffHunk": "@@ -18,9 +18,9 @@\n import io.netty.buffer.ByteBuf;\n import io.netty.handler.codec.dns.DefaultDnsRecordEncoder;\n \n-final class DnsNameEncoder {\n+public final class DnsNameEncoder {", "originalCommit": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYyMDMzMw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r526620333", "bodyText": "There are classes that depends on this class in armeria.client.endpoint.dns, so moving this class will not help much.", "author": "trustin", "createdAt": "2020-11-19T06:22:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NTk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYyNzU2MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r526627560", "bodyText": "Oops I thought this was in core/src/main....\nPlease forget about the comment. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-11-19T06:43:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NTk4MA=="}], "type": "inlineReview"}, {"oid": "3b0a3d97cef107e56a4597105fb0d856c0c87cb3", "url": "https://github.com/line/armeria/commit/3b0a3d97cef107e56a4597105fb0d856c0c87cb3", "message": "removed unnessary chars from regex, indentation fixes", "committedDate": "2020-11-20T03:06:06Z", "type": "commit"}, {"oid": "d4a10dacf4ab1e87d737b91c02f3657ecba97637", "url": "https://github.com/line/armeria/commit/d4a10dacf4ab1e87d737b91c02f3657ecba97637", "message": "extract construction of DefaultDnsQueryLifecycleObserverFactory in build method of dnsresolvergroupbuilder so we don't create multiple instances of it", "committedDate": "2020-11-20T03:39:54Z", "type": "commit"}, {"oid": "bba534b85d278725ee203f9f7ffba2b8decc7cbd", "url": "https://github.com/line/armeria/commit/bba534b85d278725ee203f9f7ffba2b8decc7cbd", "message": "Merge branch 'master' into 1887_dns_metrics_latest", "committedDate": "2020-11-23T14:07:32Z", "type": "commit"}, {"oid": "4da165e7209dbe5339709b00a068c22a103953c0", "url": "https://github.com/line/armeria/commit/4da165e7209dbe5339709b00a068c22a103953c0", "message": "Add assertions to confirm exception type others is not being emitted", "committedDate": "2020-11-23T14:26:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2MjYxOQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r530162619", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    final ClientFactoryOptionValue<?> opt = options\n          \n          \n            \n                                            .getOrDefault(ClientFactoryOptions.METER_REGISTRY,ClientFactoryOptions\n          \n          \n            \n                                            .METER_REGISTRY\n          \n          \n            \n                                            .newValue(ClientFactoryOptions.of().meterRegistry()));\n          \n          \n            \n                                    final ClientFactoryOptionValue<?> opt = options.getOrDefault(\n          \n          \n            \n                                            ClientFactoryOptions.METER_REGISTRY,\n          \n          \n            \n                                            ClientFactoryOptions.METER_REGISTRY.newValue(\n          \n          \n            \n                                                    ClientFactoryOptions.of().meterRegistry()));", "author": "trustin", "createdAt": "2020-11-25T07:42:29Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -631,7 +631,15 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+\n+                        final ClientFactoryOptionValue<?> opt = options\n+                                .getOrDefault(ClientFactoryOptions.METER_REGISTRY,ClientFactoryOptions\n+                                .METER_REGISTRY\n+                                .newValue(ClientFactoryOptions.of().meterRegistry()));", "originalCommit": "4da165e7209dbe5339709b00a068c22a103953c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0NjM1MQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r530546351", "bodyText": "Fixed.", "author": "amitvc", "createdAt": "2020-11-25T17:41:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2MjYxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2MzcyNQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r530163725", "bodyText": "Could you explain why we have this change? This test case doesn't seem to check and DNS metrics.", "author": "trustin", "createdAt": "2020-11-25T07:44:59Z", "path": "core/src/test/java/com/linecorp/armeria/client/RefreshingAddressResolverTest.java", "diffHunk": "@@ -405,6 +406,7 @@ private static DnsResolverGroupBuilder builder(TestDnsServer... servers) {\n                         Stream.of(servers).map(TestDnsServer::addr).collect(toImmutableList())).stream();\n         return new DnsResolverGroupBuilder()\n                 .dnsServerAddressStreamProvider(dnsServerAddressStreamProvider)\n+                .meterRegistry(PrometheusMeterRegistries.newRegistry())", "originalCommit": "4da165e7209dbe5339709b00a068c22a103953c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0NTU3Mw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r530545573", "bodyText": "Good question @trustin. The reason is DnsResolverGroupBuilder::build method we expect the meterRegistry to be not null. The question can DnsResolverGroupBuilder be constructed without meterRegistry.", "author": "amitvc", "createdAt": "2020-11-25T17:40:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2MzcyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1MzkxNQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r530753915", "bodyText": "Ahh, I see. OK!", "author": "trustin", "createdAt": "2020-11-26T03:30:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2MzcyNQ=="}], "type": "inlineReview"}, {"oid": "c9b744c92ae247a8e217108a09cf17cc515e63cf", "url": "https://github.com/line/armeria/commit/c9b744c92ae247a8e217108a09cf17cc515e63cf", "message": "Fix indentations", "committedDate": "2020-11-25T17:41:22Z", "type": "commit"}, {"oid": "4a1af56eb4037e780b90bf1076fc9b7f16828c83", "url": "https://github.com/line/armeria/commit/4a1af56eb4037e780b90bf1076fc9b7f16828c83", "message": "Merge master into the branch", "committedDate": "2020-11-26T05:23:53Z", "type": "commit"}, {"oid": "ad71406d3ea81235b2899fd74a0e5c01022386c4", "url": "https://github.com/line/armeria/commit/ad71406d3ea81235b2899fd74a0e5c01022386c4", "message": "increase clientfactory timeout", "committedDate": "2020-11-26T05:24:36Z", "type": "commit"}, {"oid": "64571bb7ab4790e99fcfa932ad6dbf3cc4545d10", "url": "https://github.com/line/armeria/commit/64571bb7ab4790e99fcfa932ad6dbf3cc4545d10", "message": "Fix flaky test and code format", "committedDate": "2020-11-27T03:22:30Z", "type": "commit"}, {"oid": "16455362b84dd0995c05be014d023ee68db77ff3", "url": "https://github.com/line/armeria/commit/16455362b84dd0995c05be014d023ee68db77ff3", "message": "Checkstyle", "committedDate": "2020-11-27T04:56:13Z", "type": "commit"}]}