{"pr_number": 2636, "pr_title": "Add HTTP/1 PING(`OPTIONS *`)", "pr_createdAt": "2020-03-28T06:32:26Z", "pr_url": "https://github.com/line/armeria/pull/2636", "timeline": [{"oid": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "url": "https://github.com/line/armeria/commit/3d98d18da9d33e2c643271ac33e837d0f8ff8746", "message": "Clean up", "committedDate": "2020-03-28T06:55:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEwOTA0OQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400109049", "bodyText": "a PING frame", "author": "trustin", "createdAt": "2020-03-30T11:10:03Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java", "diffHunk": "@@ -219,18 +219,14 @@ public long idleTimeoutMillis() {\n     }\n \n     /**\n-     * Returns the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout in milliseconds.\n+     * Returns the PING interval in milliseconds.\n+     * When neither read nor write was performed for the specified period of time,\n+     * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n+     * is sent for HTTP/1,\n+     * or <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2.", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEwOTU2Ng==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400109566", "bodyText": "Keep the getter and setter together.", "author": "trustin", "createdAt": "2020-03-30T11:11:06Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientHttp1ObjectEncoder.java", "diffHunk": "@@ -101,4 +108,21 @@ protected void convertTrailers(HttpHeaders inputHeaders,\n                                    io.netty.handler.codec.http.HttpHeaders outputHeaders) {\n         ArmeriaHttpUtil.toNettyHttp1ClientTrailer(inputHeaders, outputHeaders);\n     }\n+\n+    @Nullable\n+    @Override\n+    public KeepAliveHandler keepAliveHandler() {\n+        return keepAliveHandler;\n+    }\n+\n+    @Override\n+    public void keepAliveWrite(int id) {\n+        if (keepAliveHandler != null && !keepAliveHandler.isPing(id)) {\n+            super.keepAliveWrite(id);\n+        }\n+    }\n+\n+    public void setKeepAliveHandler(Http1ClientKeepAliveHandler keepAliveHandler) {", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExMDU4NA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400110584", "bodyText": "Global comment - maybe<Verb><Object>", "author": "trustin", "createdAt": "2020-03-30T11:13:02Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java", "diffHunk": "@@ -84,6 +88,11 @@ HttpResponseWrapper addResponse(\n         return resWrapper;\n     }\n \n+    void setKeepAliveHandler(ChannelHandlerContext ctx, KeepAliveHandler keepAliveHandler) {\n+        this.keepAliveHandler = keepAliveHandler;\n+        maybeKeepAliveInitialize(ctx);", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExMDcyMg==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400110722", "bodyText": "Global comment - <Verb><Object>", "author": "trustin", "createdAt": "2020-03-30T11:13:20Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java", "diffHunk": "@@ -96,13 +105,18 @@ private void onWrapperCompleted(HttpResponseWrapper resWrapper, @Nullable Throwa\n     }\n \n     @Override\n-    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {}\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        maybeKeepAliveInitialize(ctx);\n+    }\n \n     @Override\n-    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {}\n+    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {\n+        keepAliveDestroy();", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExMTA3NQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400111075", "bodyText": "Maybe no need to check if registered?", "author": "trustin", "createdAt": "2020-03-30T11:13:57Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java", "diffHunk": "@@ -263,4 +284,41 @@ public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exceptio\n     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n         ctx.fireExceptionCaught(cause);\n     }\n+\n+    private void maybeKeepAliveInitialize(ChannelHandlerContext ctx) {\n+        if (keepAliveHandler != null && ctx.channel().isActive() && ctx.channel().isRegistered()) {", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY4MTc3Ng==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400681776", "bodyText": "Removed :-)", "author": "ikhoon", "createdAt": "2020-03-31T06:55:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExMTA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExMTQ4NQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400111485", "bodyText": "keepAlive -> keepAliveHandler", "author": "trustin", "createdAt": "2020-03-30T11:14:42Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java", "diffHunk": "@@ -263,4 +284,41 @@ public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exceptio\n     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n         ctx.fireExceptionCaught(cause);\n     }\n+\n+    private void maybeKeepAliveInitialize(ChannelHandlerContext ctx) {\n+        if (keepAliveHandler != null && ctx.channel().isActive() && ctx.channel().isRegistered()) {\n+            keepAliveHandler.initialize(ctx);\n+        }\n+    }\n+\n+    private void keepAliveDestroy() {", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExMjQ2NA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400112464", "bodyText": "What would be the sensible default for this flag?", "author": "trustin", "createdAt": "2020-03-30T11:16:43Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -197,10 +197,10 @@\n                     DEFAULT_DEFAULT_CLIENT_IDLE_TIMEOUT_MILLIS,\n                     value -> value >= 0);\n \n-    private static final long DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_MILLIS = 0; // Disabled\n-    private static final long DEFAULT_HTTP2_PING_TIMEOUT_MILLIS =\n-            getLong(\"defaultHttp2PingTimeoutMillis\",\n-                    DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_MILLIS,\n+    private static final long DEFAULT_DEFAULT_PING_INTERVAL_MILLIS = 0; // Disabled", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY0ODIwOA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400648208", "bodyText": "Hmm... I thought PING is an optional feature. If we turn it on by default, what about 5000 milliseconds?\nBecause the default PING interval should be less than the default idle timeouts.\n\nthe default idle timeout of service-side is 15000 milliseconds\nthe default idle timeout of client-side is 10000 milliseconds", "author": "ikhoon", "createdAt": "2020-03-31T05:14:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExMjQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIxNTc4Mw==", "url": "https://github.com/line/armeria/pull/2636#discussion_r402215783", "bodyText": "Sounds good to me. I guess it'll be nice if we do not send ping frames too often so that some HTTP/2 servers reject us, e.g. gRPC-Java has such check. Could you double check? Related issue: #2639", "author": "trustin", "createdAt": "2020-04-02T10:36:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExMjQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjMyODE0OA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r402328148", "bodyText": "https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md\nThe default keepalive configuration of upstream gRPC server seems to be conservative.\n\nThe default value of permitKeepAliveTime is 5 minutes.\npermitKeepAliveWithoutCalls() is disable by default.\n\nThese means\n\nOur gRPC client should not send a PING frame with no outstand streams\nThe PING interval should be longer than 5 minutes with active streams.\n\nWe might need a different default keepalive configuration for gRPC? Any thoughts? @anuraaga", "author": "ikhoon", "createdAt": "2020-04-02T13:50:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExMjQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg1OTE2OQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r403859169", "bodyText": "I guess we need to be as conservative as gRPC-Java by default to prevent any surprises. KeepAliveEnforcer contains the core logic of the defense mechanism: https://github.com/grpc/grpc-java/blob/master/netty/src/main/java/io/grpc/netty/KeepAliveEnforcer.java which seems to be:\n\ninterested only in the interval between PING frames. It doesn't take other traffic into account.\n\nPerhaps we need another parameter, like 'minimum interval between pings'?\n\n\naccepting up to 2 violations (dunno why)", "author": "trustin", "createdAt": "2020-04-06T06:39:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExMjQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4MTY0NQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r403881645", "bodyText": "I'm not sure this is useful for us, but gRPC client limits the min ping interval.\nhttps://github.com/grpc/grpc-java/blob/master/core/src/main/java/io/grpc/internal/KeepAliveManager.java#L235-L240", "author": "ikhoon", "createdAt": "2020-04-06T07:29:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExMjQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExNzExMg==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400117112", "bodyText": "Perhaps we can keep accessing it via writer.keepAliveHandler(), instead of adding a new member field?", "author": "trustin", "createdAt": "2020-03-30T11:25:36Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http1RequestDecoder.java", "diffHunk": "@@ -84,6 +84,8 @@\n     private final AsciiString scheme;\n     private final InboundTrafficController inboundTrafficController;\n     private final ServerHttp1ObjectEncoder writer;\n+    @Nullable\n+    private final KeepAliveHandler keepAliveHandler;", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY4MTg4OA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400681888", "bodyText": "Fixed", "author": "ikhoon", "createdAt": "2020-03-31T06:55:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExNzExMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExNzIxOA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400117218", "bodyText": "Can be removed because channelActive() will be invoked.", "author": "trustin", "createdAt": "2020-03-30T11:25:51Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http1RequestDecoder.java", "diffHunk": "@@ -97,6 +99,31 @@\n         this.scheme = scheme;\n         inboundTrafficController = InboundTrafficController.ofHttp1(channel);\n         this.writer = writer;\n+        keepAliveHandler = writer.keepAliveHandler();\n+    }\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        maybeKeepAliveInitialize(ctx);\n+        super.handlerAdded(ctx);\n+    }\n+\n+    @Override\n+    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {\n+        keepAliveDestroy();\n+        super.handlerRemoved(ctx);\n+    }\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        maybeKeepAliveInitialize(ctx);\n+        super.channelRegistered(ctx);\n+    }", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExODI3Mg==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400118272", "bodyText": "I think this name is highly confusing. Please fine something better.\nThis method doesn't have to be public if I understood correctly.", "author": "trustin", "createdAt": "2020-03-30T11:27:49Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/HttpObjectEncoder.java", "diffHunk": "@@ -40,6 +42,16 @@ default EventLoop eventLoop() {\n         return channel().eventLoop();\n     }\n \n+    @Nullable\n+    KeepAliveHandler keepAliveHandler();\n+\n+    default void keepAliveWrite(int id) {", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY4MjQ5NQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400682495", "bodyText": "Agreed, I removed this method and updated sub classes.", "author": "ikhoon", "createdAt": "2020-03-31T06:56:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExODI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExODk3Ng==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400118976", "bodyText": "instance that schedules", "author": "trustin", "createdAt": "2020-03-30T11:29:14Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.ALL_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+/**\n+ * A scheduler that triggers an {@link IdleStateEvent} when {@link #onReadOrWrite()} or {@linkplain #onPing()}\n+ * has not invoked for a while.\n+ *\n+ * <h3>Supported idle states</h3>\n+ * <table border=\"1\">\n+ * <tr><th>Property</th><th>Meaning</th></tr>\n+ * <tr>\n+ *   <td>{@code allIdleTime}</td>\n+ *   <td>an {@link IdleStateEvent} whose state is {@link IdleState#ALL_IDLE}\n+ *       will be triggered when neither read nor write was performed for the\n+ *       specified period of time. Specify {@code 0} to disable.</td>\n+ * </tr>\n+ * <tr>\n+ *   <td>{@code pingIdleTime}</td>\n+ *   <td>an {@link IdleStateEvent} whose state is {@link IdleState#PING_IDLE}\n+ *       will be triggered when neither read nor write was performed for the\n+ *       specified period of time. Specify {@code 0} to disable.</td>\n+ * </tr>\n+ * </table>\n+ */\n+abstract class IdleTimeoutScheduler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java#L99\n+\n+    private static final Logger logger = LoggerFactory.getLogger(IdleTimeoutScheduler.class);\n+\n+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n+\n+    private static long ticksInNanos() {\n+        return System.nanoTime();\n+    }\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case ALL_IDLE:\n+                return first ? FIRST_ALL_IDLE_STATE_EVENT : ALL_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: state=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    private final long allIdleTimeNanos;\n+    private final long pingIdleTimeNanos;\n+    private final ScheduledExecutorService executor;\n+\n+    @Nullable\n+    private ScheduledFuture<?> allIdleTimeout;\n+    private long lastAllIdleTime;\n+    private boolean firstAllIdleEvent = true;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pingIdleTimeout;\n+    private long lastPingAckTime;\n+    private boolean firstPingIdleEvent = true;\n+\n+    private byte state; // 0 - none, 1 - initialized, 2 - destroyed\n+\n+    /**\n+     * Creates a new instance schedules {@link IdleStateEvent}s.", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExOTgyMw==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400119823", "bodyText": "Could be inlined?", "author": "trustin", "createdAt": "2020-03-30T11:31:02Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.ALL_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+/**\n+ * A scheduler that triggers an {@link IdleStateEvent} when {@link #onReadOrWrite()} or {@linkplain #onPing()}\n+ * has not invoked for a while.\n+ *\n+ * <h3>Supported idle states</h3>\n+ * <table border=\"1\">\n+ * <tr><th>Property</th><th>Meaning</th></tr>\n+ * <tr>\n+ *   <td>{@code allIdleTime}</td>\n+ *   <td>an {@link IdleStateEvent} whose state is {@link IdleState#ALL_IDLE}\n+ *       will be triggered when neither read nor write was performed for the\n+ *       specified period of time. Specify {@code 0} to disable.</td>\n+ * </tr>\n+ * <tr>\n+ *   <td>{@code pingIdleTime}</td>\n+ *   <td>an {@link IdleStateEvent} whose state is {@link IdleState#PING_IDLE}\n+ *       will be triggered when neither read nor write was performed for the\n+ *       specified period of time. Specify {@code 0} to disable.</td>\n+ * </tr>\n+ * </table>\n+ */\n+abstract class IdleTimeoutScheduler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java#L99\n+\n+    private static final Logger logger = LoggerFactory.getLogger(IdleTimeoutScheduler.class);\n+\n+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n+\n+    private static long ticksInNanos() {\n+        return System.nanoTime();\n+    }", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEyMTAyMQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400121021", "bodyText": "allIdle -> just idle or connectionIdle ?", "author": "trustin", "createdAt": "2020-03-30T11:33:21Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.ALL_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+/**\n+ * A scheduler that triggers an {@link IdleStateEvent} when {@link #onReadOrWrite()} or {@linkplain #onPing()}\n+ * has not invoked for a while.\n+ *\n+ * <h3>Supported idle states</h3>\n+ * <table border=\"1\">\n+ * <tr><th>Property</th><th>Meaning</th></tr>\n+ * <tr>\n+ *   <td>{@code allIdleTime}</td>\n+ *   <td>an {@link IdleStateEvent} whose state is {@link IdleState#ALL_IDLE}\n+ *       will be triggered when neither read nor write was performed for the\n+ *       specified period of time. Specify {@code 0} to disable.</td>\n+ * </tr>\n+ * <tr>\n+ *   <td>{@code pingIdleTime}</td>\n+ *   <td>an {@link IdleStateEvent} whose state is {@link IdleState#PING_IDLE}\n+ *       will be triggered when neither read nor write was performed for the\n+ *       specified period of time. Specify {@code 0} to disable.</td>\n+ * </tr>\n+ * </table>\n+ */\n+abstract class IdleTimeoutScheduler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java#L99\n+\n+    private static final Logger logger = LoggerFactory.getLogger(IdleTimeoutScheduler.class);\n+\n+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n+\n+    private static long ticksInNanos() {\n+        return System.nanoTime();\n+    }\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case ALL_IDLE:\n+                return first ? FIRST_ALL_IDLE_STATE_EVENT : ALL_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: state=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    private final long allIdleTimeNanos;", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEyMTQyNg==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400121426", "bodyText": "These need to be updated to something similar to what you explained in Flags.", "author": "trustin", "createdAt": "2020-03-30T11:34:03Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.ALL_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+/**\n+ * A scheduler that triggers an {@link IdleStateEvent} when {@link #onReadOrWrite()} or {@linkplain #onPing()}\n+ * has not invoked for a while.\n+ *\n+ * <h3>Supported idle states</h3>\n+ * <table border=\"1\">\n+ * <tr><th>Property</th><th>Meaning</th></tr>\n+ * <tr>\n+ *   <td>{@code allIdleTime}</td>\n+ *   <td>an {@link IdleStateEvent} whose state is {@link IdleState#ALL_IDLE}\n+ *       will be triggered when neither read nor write was performed for the\n+ *       specified period of time. Specify {@code 0} to disable.</td>\n+ * </tr>\n+ * <tr>\n+ *   <td>{@code pingIdleTime}</td>\n+ *   <td>an {@link IdleStateEvent} whose state is {@link IdleState#PING_IDLE}\n+ *       will be triggered when neither read nor write was performed for the\n+ *       specified period of time. Specify {@code 0} to disable.</td>\n+ * </tr>\n+ * </table>\n+ */\n+abstract class IdleTimeoutScheduler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java#L99\n+\n+    private static final Logger logger = LoggerFactory.getLogger(IdleTimeoutScheduler.class);\n+\n+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n+\n+    private static long ticksInNanos() {\n+        return System.nanoTime();\n+    }\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case ALL_IDLE:\n+                return first ? FIRST_ALL_IDLE_STATE_EVENT : ALL_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: state=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    private final long allIdleTimeNanos;\n+    private final long pingIdleTimeNanos;\n+    private final ScheduledExecutorService executor;\n+\n+    @Nullable\n+    private ScheduledFuture<?> allIdleTimeout;\n+    private long lastAllIdleTime;\n+    private boolean firstAllIdleEvent = true;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pingIdleTimeout;\n+    private long lastPingAckTime;\n+    private boolean firstPingIdleEvent = true;\n+\n+    private byte state; // 0 - none, 1 - initialized, 2 - destroyed\n+\n+    /**\n+     * Creates a new instance schedules {@link IdleStateEvent}s.\n+     *\n+     * @param allIdleTime an {@link IdleStateEvent} whose state is {@link IdleState#ALL_IDLE}\n+     *                    will be triggered when neither read nor write was performed for\n+     *                    the specified period of time. Specify {@code 0} to disable.\n+     * @param pingIdleTime an {@link IdleStateEvent} whose state is {@link IdleState#PING_IDLE}\n+     *                     will be triggered when neither read nor write was performed for\n+     *                     the specified period of time. Specify {@code 0} to disable.", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEyMzE4MQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400123181", "bodyText": "Could you update the comments in this class to reflect its actual behavior?", "author": "trustin", "createdAt": "2020-03-30T11:37:22Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.ALL_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+/**\n+ * A scheduler that triggers an {@link IdleStateEvent} when {@link #onReadOrWrite()} or {@linkplain #onPing()}\n+ * has not invoked for a while.\n+ *\n+ * <h3>Supported idle states</h3>\n+ * <table border=\"1\">\n+ * <tr><th>Property</th><th>Meaning</th></tr>\n+ * <tr>\n+ *   <td>{@code allIdleTime}</td>\n+ *   <td>an {@link IdleStateEvent} whose state is {@link IdleState#ALL_IDLE}\n+ *       will be triggered when neither read nor write was performed for the\n+ *       specified period of time. Specify {@code 0} to disable.</td>\n+ * </tr>\n+ * <tr>\n+ *   <td>{@code pingIdleTime}</td>\n+ *   <td>an {@link IdleStateEvent} whose state is {@link IdleState#PING_IDLE}\n+ *       will be triggered when neither read nor write was performed for the\n+ *       specified period of time. Specify {@code 0} to disable.</td>\n+ * </tr>\n+ * </table>\n+ */\n+abstract class IdleTimeoutScheduler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java#L99\n+\n+    private static final Logger logger = LoggerFactory.getLogger(IdleTimeoutScheduler.class);\n+\n+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n+\n+    private static long ticksInNanos() {\n+        return System.nanoTime();\n+    }\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case ALL_IDLE:\n+                return first ? FIRST_ALL_IDLE_STATE_EVENT : ALL_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: state=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    private final long allIdleTimeNanos;\n+    private final long pingIdleTimeNanos;\n+    private final ScheduledExecutorService executor;\n+\n+    @Nullable\n+    private ScheduledFuture<?> allIdleTimeout;\n+    private long lastAllIdleTime;\n+    private boolean firstAllIdleEvent = true;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pingIdleTimeout;\n+    private long lastPingAckTime;\n+    private boolean firstPingIdleEvent = true;\n+\n+    private byte state; // 0 - none, 1 - initialized, 2 - destroyed\n+\n+    /**\n+     * Creates a new instance schedules {@link IdleStateEvent}s.\n+     *\n+     * @param allIdleTime an {@link IdleStateEvent} whose state is {@link IdleState#ALL_IDLE}\n+     *                    will be triggered when neither read nor write was performed for\n+     *                    the specified period of time. Specify {@code 0} to disable.\n+     * @param pingIdleTime an {@link IdleStateEvent} whose state is {@link IdleState#PING_IDLE}\n+     *                     will be triggered when neither read nor write was performed for\n+     *                     the specified period of time. Specify {@code 0} to disable.\n+     * @param unit the {@link TimeUnit}\n+     * @param executor the executor to schedule a timeout to trigger an {@link IdleStateEvent}.\n+     */\n+    IdleTimeoutScheduler(long allIdleTime, long pingIdleTime, TimeUnit unit,\n+                         ScheduledExecutorService executor) {\n+        ObjectUtil.checkNotNull(unit, \"unit\");\n+        this.executor = executor;\n+\n+        if (allIdleTime <= 0) {\n+            allIdleTimeNanos = 0;\n+        } else {\n+            allIdleTimeNanos = Math.max(unit.toNanos(allIdleTime), MIN_TIMEOUT_NANOS);\n+        }\n+        if (pingIdleTime <= 0) {\n+            pingIdleTimeNanos = 0;\n+        } else {\n+            pingIdleTimeNanos = Math.max(unit.toNanos(pingIdleTime), MIN_TIMEOUT_NANOS);\n+        }\n+    }\n+\n+    public void onReadOrWrite() {\n+        if (allIdleTimeNanos > 0 || pingIdleTimeNanos > 0) {\n+            lastAllIdleTime = lastPingAckTime = ticksInNanos();\n+            firstAllIdleEvent = firstPingIdleEvent = true;\n+        }\n+    }\n+\n+    public void onPing() {\n+        if (pingIdleTimeNanos > 0) {\n+            firstPingIdleEvent = true;\n+            lastPingAckTime = ticksInNanos();\n+        }\n+    }\n+\n+    public void initialize(ChannelHandlerContext ctx) {\n+        // Avoid the case where destroy() is called before scheduling timeouts.\n+        // See: https://github.com/netty/netty/issues/143\n+        switch (state) {\n+            case 1:\n+            case 2:\n+                return;\n+        }\n+\n+        state = 1;\n+\n+        if (allIdleTimeNanos > 0) {\n+            allIdleTimeout = executor.schedule(new AllIdleTimeoutTask(ctx),\n+                                               allIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+        if (pingIdleTimeNanos > 0) {\n+            pingIdleTimeout = executor.schedule(new PingIdleTimeoutTask(ctx),\n+                                                pingIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+    }\n+\n+    public void destroy() {\n+        state = 2;\n+        if (allIdleTimeout != null) {\n+            allIdleTimeout.cancel(false);\n+            allIdleTimeout = null;\n+        }\n+        if (pingIdleTimeout != null) {\n+            pingIdleTimeout.cancel(false);\n+            pingIdleTimeout = null;\n+        }\n+    }\n+\n+    protected abstract void onIdleEvent(ChannelHandlerContext ctx, IdleStateEvent evt);\n+\n+    private abstract static class AbstractIdleTask implements Runnable {\n+\n+        private final ChannelHandlerContext ctx;\n+\n+        AbstractIdleTask(ChannelHandlerContext ctx) {\n+            this.ctx = ctx;\n+        }\n+\n+        @Override\n+        public void run() {\n+            if (!ctx.channel().isOpen()) {\n+                return;\n+            }\n+\n+            run(ctx);\n+        }\n+\n+        protected abstract void run(ChannelHandlerContext ctx);\n+    }\n+\n+    private final class AllIdleTimeoutTask extends AbstractIdleTask {\n+\n+        private boolean warn;\n+\n+        AllIdleTimeoutTask(ChannelHandlerContext ctx) {\n+            super(ctx);\n+        }\n+\n+        @Override\n+        protected void run(ChannelHandlerContext ctx) {\n+\n+            final long lastAllIdleTime = IdleTimeoutScheduler.this.lastAllIdleTime;\n+            final long nextDelay = allIdleTimeNanos - (ticksInNanos() - lastAllIdleTime);\n+            if (nextDelay <= 0) {\n+                // Both reader and writer are idle - set a new timeout and\n+                // notify the callback.\n+                allIdleTimeout = executor.schedule(this, allIdleTimeNanos, TimeUnit.NANOSECONDS);\n+\n+                final boolean first = firstAllIdleEvent;\n+                firstAllIdleEvent = false;\n+                final IdleStateEvent event = newIdleStateEvent(IdleState.ALL_IDLE, first);\n+                try {\n+                    onIdleEvent(ctx, event);\n+                } catch (Exception e) {\n+                    if (!warn) {\n+                        logger.warn(\"An error occurred while notifying an all idle event\", e);\n+                        warn = true;\n+                    }\n+                }\n+            } else {\n+                // Either read or write occurred before the timeout - set a new\n+                // timeout with shorter delay.\n+                allIdleTimeout = executor.schedule(this, nextDelay, TimeUnit.NANOSECONDS);\n+            }\n+        }\n+    }\n+\n+    private final class PingIdleTimeoutTask extends AbstractIdleTask {\n+\n+        private boolean warn;\n+\n+        PingIdleTimeoutTask(ChannelHandlerContext ctx) {\n+            super(ctx);\n+        }\n+\n+        @Override\n+        protected void run(ChannelHandlerContext ctx) {\n+\n+            final long lastPingAckTime = IdleTimeoutScheduler.this.lastPingAckTime;\n+            final long nextDelay = pingIdleTimeNanos - (ticksInNanos() - lastPingAckTime);\n+            if (nextDelay <= 0) {\n+                // Ping is idle - set a new timeout and notify the callback.\n+                pingIdleTimeout = executor.schedule(this, pingIdleTimeNanos, TimeUnit.NANOSECONDS);\n+\n+                final boolean first = firstPingIdleEvent;\n+                firstPingIdleEvent = false;\n+\n+                final IdleStateEvent event = newIdleStateEvent(IdleState.PING_IDLE, first);\n+                try {\n+                    onIdleEvent(ctx, event);\n+                } catch (Exception e) {\n+                    if (!warn) {\n+                        logger.warn(\"An error occurred while notifying a ping idle event\", e);\n+                        warn = true;\n+                    }\n+                }\n+            } else {\n+                // Ping occurred before the timeout - set a new timeout with shorter delay.", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEyNDI5Nw==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400124297", "bodyText": "How about merging the two classes into one given that IdleTimeoutScheduler is always used together with KeepAliveHandler?", "author": "trustin", "createdAt": "2020-03-30T11:39:28Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * A {@link IdleTimeoutScheduler} that writes a PING when neither read nor write was performed for\n+ * the specified {@code pingIntervalMillis}, and closes the connection\n+ * when neither read nor write was performed within the given {@code idleTimeoutMillis}.\n+ */\n+public abstract class KeepAliveHandler extends IdleTimeoutScheduler {", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYyNjExOQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400626119", "bodyText": "That sounds good. \ud83d\udc4d It can simplify the hierarchy.", "author": "ikhoon", "createdAt": "2020-03-31T03:46:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEyNDI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgxNDE3OQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400814179", "bodyText": "Can remove public?", "author": "minwoox", "createdAt": "2020-03-31T10:42:47Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientHttp1ObjectEncoder.java", "diffHunk": "@@ -101,4 +108,19 @@ protected void convertTrailers(HttpHeaders inputHeaders,\n                                    io.netty.handler.codec.http.HttpHeaders outputHeaders) {\n         ArmeriaHttpUtil.toNettyHttp1ClientTrailer(inputHeaders, outputHeaders);\n     }\n+\n+    @Nullable\n+    @Override\n+    public KeepAliveHandler keepAliveHandler() {\n+        return keepAliveHandler;\n+    }\n+\n+    public void setKeepAliveHandler(Http1ClientKeepAliveHandler keepAliveHandler) {", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMwNzIwMg==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401307202", "bodyText": "How about making a field for HttpSession and use it instead of channel?", "author": "minwoox", "createdAt": "2020-04-01T01:33:34Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http1ClientKeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.internal.common.KeepAliveHandler;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+\n+final class Http1ClientKeepAliveHandler extends KeepAliveHandler {\n+\n+    private static final RequestHeaders HTTP1_PING_REQUEST = RequestHeaders.of(HttpMethod.OPTIONS, \"*\");\n+\n+    private final Channel channel;\n+    private final ClientHttp1ObjectEncoder encoder;\n+    private final Http1ResponseDecoder decoder;\n+\n+    Http1ClientKeepAliveHandler(Channel channel, ClientHttp1ObjectEncoder encoder, Http1ResponseDecoder decoder,\n+                                long idleTimeoutMillis, long pingIntervalMillis) {\n+        super(channel, \"client\", idleTimeoutMillis, pingIntervalMillis);\n+        this.channel = requireNonNull(channel, \"channel\");", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMwODY1MA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401308650", "bodyText": "nit: we could just set 0 for streamId because it's not used.", "author": "minwoox", "createdAt": "2020-04-01T01:39:41Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http1ClientKeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.internal.common.KeepAliveHandler;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+\n+final class Http1ClientKeepAliveHandler extends KeepAliveHandler {\n+\n+    private static final RequestHeaders HTTP1_PING_REQUEST = RequestHeaders.of(HttpMethod.OPTIONS, \"*\");\n+\n+    private final Channel channel;\n+    private final ClientHttp1ObjectEncoder encoder;\n+    private final Http1ResponseDecoder decoder;\n+\n+    Http1ClientKeepAliveHandler(Channel channel, ClientHttp1ObjectEncoder encoder, Http1ResponseDecoder decoder,\n+                                long idleTimeoutMillis, long pingIntervalMillis) {\n+        super(channel, \"client\", idleTimeoutMillis, pingIntervalMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.encoder = requireNonNull(encoder, \"encoder\");\n+        this.decoder = requireNonNull(decoder, \"decoder\");\n+    }\n+\n+    @Override\n+    protected ChannelFuture writePing(ChannelHandlerContext ctx) {\n+        final HttpSession httpSession = HttpSession.get(channel);\n+        final int id = httpSession.incrementAndGetNumRequestsSent();\n+        final int streamId = (id << 1) + 1;", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMyMTU4OA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401321588", "bodyText": "It seems like we can replace this to a boolean field like isInitialized?", "author": "minwoox", "createdAt": "2020-04-01T02:31:13Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * A {@link KeepAliveHandler} that writes a PING when neither read nor write was performed for\n+ * the specified {@code pingIntervalMillis}, and closes the connection\n+ * when neither read nor write was performed within the given {@code idleTimeoutMillis}.\n+ */\n+public abstract class KeepAliveHandler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KeepAliveHandler.class);\n+\n+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case CONNECTION_IDLE:\n+                return first ? FIRST_CONNECTION_IDLE_STATE_EVENT : CONNECTION_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: state=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private final Channel channel;\n+    private final String name;\n+\n+    @Nullable\n+    private ScheduledFuture<?> connectionIdleTimeout;\n+    private final long connectionIdleTimeNanos;\n+    private long lastConnectionIdleTime;\n+    private boolean firstConnectionIdleEvent = true;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pingIdleTimeout;\n+    private final long pingIdleTimeNanos;\n+    private long lastPingIdleTime;\n+    private boolean firstPingIdleEvent = true;\n+\n+    private byte state; // 0 - none, 1 - initialized, 2 - destroyed", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMyNzIwNw==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401327207", "bodyText": "Can't we just assign TimeUnit.MILLISECONDS.toNanos(idleTimeoutMillis)?", "author": "minwoox", "createdAt": "2020-04-01T02:53:32Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * A {@link KeepAliveHandler} that writes a PING when neither read nor write was performed for\n+ * the specified {@code pingIntervalMillis}, and closes the connection\n+ * when neither read nor write was performed within the given {@code idleTimeoutMillis}.\n+ */\n+public abstract class KeepAliveHandler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KeepAliveHandler.class);\n+\n+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case CONNECTION_IDLE:\n+                return first ? FIRST_CONNECTION_IDLE_STATE_EVENT : CONNECTION_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: state=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private final Channel channel;\n+    private final String name;\n+\n+    @Nullable\n+    private ScheduledFuture<?> connectionIdleTimeout;\n+    private final long connectionIdleTimeNanos;\n+    private long lastConnectionIdleTime;\n+    private boolean firstConnectionIdleEvent = true;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pingIdleTimeout;\n+    private final long pingIdleTimeNanos;\n+    private long lastPingIdleTime;\n+    private boolean firstPingIdleEvent = true;\n+\n+    private byte state; // 0 - none, 1 - initialized, 2 - destroyed\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private PingState pingState = PingState.IDLE;\n+\n+    protected KeepAliveHandler(Channel channel, String name, long idleTimeoutMillis, long pingIntervalMillis) {\n+        this.channel = channel;\n+        this.name = name;\n+\n+        if (idleTimeoutMillis <= 0) {\n+            connectionIdleTimeNanos = 0;\n+        } else {\n+            connectionIdleTimeNanos = Math.max(TimeUnit.MILLISECONDS.toNanos(idleTimeoutMillis),\n+                                               MIN_TIMEOUT_NANOS);", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ4MzkyMw==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401483923", "bodyText": "Thanks for pointing out, no longer needed. \ud83d\ude00", "author": "ikhoon", "createdAt": "2020-04-01T09:37:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMyNzIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMyNzIzMQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401327231", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-04-01T02:53:39Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * A {@link KeepAliveHandler} that writes a PING when neither read nor write was performed for\n+ * the specified {@code pingIntervalMillis}, and closes the connection\n+ * when neither read nor write was performed within the given {@code idleTimeoutMillis}.\n+ */\n+public abstract class KeepAliveHandler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KeepAliveHandler.class);\n+\n+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case CONNECTION_IDLE:\n+                return first ? FIRST_CONNECTION_IDLE_STATE_EVENT : CONNECTION_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: state=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private final Channel channel;\n+    private final String name;\n+\n+    @Nullable\n+    private ScheduledFuture<?> connectionIdleTimeout;\n+    private final long connectionIdleTimeNanos;\n+    private long lastConnectionIdleTime;\n+    private boolean firstConnectionIdleEvent = true;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pingIdleTimeout;\n+    private final long pingIdleTimeNanos;\n+    private long lastPingIdleTime;\n+    private boolean firstPingIdleEvent = true;\n+\n+    private byte state; // 0 - none, 1 - initialized, 2 - destroyed\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private PingState pingState = PingState.IDLE;\n+\n+    protected KeepAliveHandler(Channel channel, String name, long idleTimeoutMillis, long pingIntervalMillis) {\n+        this.channel = channel;\n+        this.name = name;\n+\n+        if (idleTimeoutMillis <= 0) {\n+            connectionIdleTimeNanos = 0;\n+        } else {\n+            connectionIdleTimeNanos = Math.max(TimeUnit.MILLISECONDS.toNanos(idleTimeoutMillis),\n+                                               MIN_TIMEOUT_NANOS);\n+        }\n+        if (pingIntervalMillis <= 0) {\n+            pingIdleTimeNanos = 0;\n+        } else {\n+            pingIdleTimeNanos = Math.max(TimeUnit.MILLISECONDS.toNanos(pingIntervalMillis), MIN_TIMEOUT_NANOS);", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMyODE2NA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401328164", "bodyText": "indentation?", "author": "minwoox", "createdAt": "2020-04-01T02:57:26Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandler.java", "diffHunk": "@@ -33,134 +32,56 @@\n import com.google.common.base.Stopwatch;\n \n import com.linecorp.armeria.common.Flags;\n-import com.linecorp.armeria.common.util.Exceptions;\n \n import io.netty.channel.Channel;\n import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.EventLoop;\n-import io.netty.handler.codec.http2.Http2Connection;\n import io.netty.handler.codec.http2.Http2FrameWriter;\n import io.netty.handler.codec.http2.Http2PingFrame;\n-import io.netty.handler.timeout.IdleState;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.handler.timeout.IdleStateHandler;\n \n /**\n- * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n- * IdleStateHandler} and {@link Flags#defaultHttp2PingTimeoutMillis()} is greater that zero.\n- *\n- * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n- * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n- * {@link Flags#defaultUseHttp2PingWhenNoActiveStreams()}.\n+ * A {@link KeepAliveHandler} that sends HTTP2 PING frame\n+ * when neither read nor write was performed within the specified {@code pingIntervalMillis},\n+ * and closes the connection when neither read nor write was performed within\n+ * the given {@code idleTimeoutMillis}.\n  *\n  * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n- * is read on connection will invalidate the condition that triggers connection closure. If either of the\n- * conditions are not met then the connection will be closed.\n+ * is read on connection will invalidate the condition that triggers connection closure.\n  *\n  * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n  * as {@link EventLoop}.\n  *\n- * @see Flags#defaultUseHttp2PingWhenNoActiveStreams()\n- * @see Flags#defaultHttp2PingTimeoutMillis()\n+ * @see Flags#defaultClientIdleTimeoutMillis()\n+ * @see Flags#defaultServerIdleTimeoutMillis()\n+ * @see Flags#defaultPingIntervalMillis()\n  */\n @NotThreadSafe\n-public class Http2KeepAliveHandler {\n+public abstract class Http2KeepAliveHandler extends KeepAliveHandler {\n \n     private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n \n     @Nullable\n     private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n-    private final boolean sendPingsOnNoActiveStreams;\n-    private final long pingTimeoutMillis;\n     private final Http2FrameWriter frameWriter;\n     private final ThreadLocalRandom random = ThreadLocalRandom.current();\n-    private final Http2Connection http2Connection;\n     private final Channel channel;\n-    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n-    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n \n-    @Nullable\n-    private ChannelFuture pingWriteFuture;\n-    @Nullable\n-    private Future<?> shutdownFuture;\n     private long lastPingPayload;\n-    private State state = State.IDLE;\n \n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n-        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+    protected Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 String name, long idleTimeoutMillis, long pingIntervalMillis) {", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMyOTIzOQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401329239", "bodyText": "Seems like Http2ResponseDecoder checks if keepAliveHandler is null or not in onPingRead.\nI think we should do the same approach: assert or null check.", "author": "minwoox", "createdAt": "2020-04-01T03:01:51Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java", "diffHunk": "@@ -263,4 +284,41 @@ public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exceptio\n     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n         ctx.fireExceptionCaught(cause);\n     }\n+\n+    private void maybeInitializeKeepAliveHandler(ChannelHandlerContext ctx) {\n+        if (keepAliveHandler != null && ctx.channel().isActive()) {\n+            keepAliveHandler.initialize(ctx);\n+        }\n+    }\n+\n+    private void destroyKeepAliveHandler() {\n+        if (keepAliveHandler != null) {\n+            keepAliveHandler.destroy();\n+        }\n+    }\n+\n+    private void onPingRead(Object msg) {\n+        if (msg instanceof LastHttpContent) {\n+            onPingComplete();\n+        } else {\n+            keepAliveHandler.onPing();", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ4NzEyMA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401487120", "bodyText": "This method is called when isPing() is true so I didn't add a null check.\nHowever, it looks good to add assert.", "author": "ikhoon", "createdAt": "2020-04-01T09:43:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMyOTIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMzNjg1NQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401336855", "bodyText": "a PING?", "author": "minwoox", "createdAt": "2020-04-01T03:33:32Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -702,36 +700,20 @@ public static boolean defaultUseHttp1Pipelining() {\n     }\n \n     /**\n-     * Returns whether to send <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n-     * frames on a HTTP/2 connection when it is idle and there are no active HTTP/2 stream.\n+     * Returns the default value for the PING interval.\n+     * An <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n+     * is sent for HTTP/1 client, or\n+     * <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2 server and client.", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ4OTc5OA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401489798", "bodyText": "Oops, I've fixed it yesterday, but didn't push it. \ud83d\ude31", "author": "ikhoon", "createdAt": "2020-04-01T09:47:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMzNjg1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMzODg0Nw==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401338847", "bodyText": "not relevant to this change but is it This condition can be false ...?", "author": "minwoox", "createdAt": "2020-04-01T03:42:34Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandler.java", "diffHunk": "@@ -169,21 +90,21 @@ public void onPingAck(long data) {\n             return;\n         }\n \n+        onPing();\n+        final Future<?> shutdownFuture = shutdownFuture();\n         if (shutdownFuture != null) {\n             final boolean isCancelled = shutdownFuture.cancel(false);\n             if (!isCancelled) {\n                 logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n             }\n         }\n         logger.debug(\"{} PING(ACK=1, DATA={}) received in {} ns\", channel, lastPingPayload, elapsed);\n-        state = State.IDLE;\n-        resetFutures();\n     }\n \n     private boolean isGoodPingAck(long data) {\n         // This condition can be true when channel read some data other than PING ACK frame", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMzOTgzNw==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401339837", "bodyText": "@Nullable?", "author": "minwoox", "createdAt": "2020-04-01T03:46:48Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * A {@link KeepAliveHandler} that writes a PING when neither read nor write was performed for\n+ * the specified {@code pingIntervalMillis}, and closes the connection\n+ * when neither read nor write was performed within the given {@code idleTimeoutMillis}.\n+ */\n+public abstract class KeepAliveHandler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KeepAliveHandler.class);\n+\n+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case CONNECTION_IDLE:\n+                return first ? FIRST_CONNECTION_IDLE_STATE_EVENT : CONNECTION_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: state=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private final Channel channel;\n+    private final String name;\n+\n+    @Nullable\n+    private ScheduledFuture<?> connectionIdleTimeout;\n+    private final long connectionIdleTimeNanos;\n+    private long lastConnectionIdleTime;\n+    private boolean firstConnectionIdleEvent = true;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pingIdleTimeout;\n+    private final long pingIdleTimeNanos;\n+    private long lastPingIdleTime;\n+    private boolean firstPingIdleEvent = true;\n+\n+    private byte state; // 0 - none, 1 - initialized, 2 - destroyed\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private PingState pingState = PingState.IDLE;\n+\n+    protected KeepAliveHandler(Channel channel, String name, long idleTimeoutMillis, long pingIntervalMillis) {\n+        this.channel = channel;\n+        this.name = name;\n+\n+        if (idleTimeoutMillis <= 0) {\n+            connectionIdleTimeNanos = 0;\n+        } else {\n+            connectionIdleTimeNanos = Math.max(TimeUnit.MILLISECONDS.toNanos(idleTimeoutMillis),\n+                                               MIN_TIMEOUT_NANOS);\n+        }\n+        if (pingIntervalMillis <= 0) {\n+            pingIdleTimeNanos = 0;\n+        } else {\n+            pingIdleTimeNanos = Math.max(TimeUnit.MILLISECONDS.toNanos(pingIntervalMillis), MIN_TIMEOUT_NANOS);\n+        }\n+    }\n+\n+    public final void initialize(ChannelHandlerContext ctx) {\n+        // Avoid the case where destroy() is called before scheduling timeouts.\n+        // See: https://github.com/netty/netty/issues/143\n+        switch (state) {\n+            case 1:\n+            case 2:\n+                return;\n+        }\n+\n+        state = 1;\n+\n+        if (connectionIdleTimeNanos > 0) {\n+            connectionIdleTimeout = executor().schedule(new ConnectionIdleTimeoutTask(ctx),\n+                                                        connectionIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+        if (pingIdleTimeNanos > 0) {\n+            pingIdleTimeout = executor().schedule(new PingIdleTimeoutTask(ctx),\n+                                                  pingIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+    }\n+\n+    public final void destroy() {\n+        state = 2;\n+        if (connectionIdleTimeout != null) {\n+            connectionIdleTimeout.cancel(false);\n+            connectionIdleTimeout = null;\n+        }\n+        if (pingIdleTimeout != null) {\n+            pingIdleTimeout.cancel(false);\n+            pingIdleTimeout = null;\n+        }\n+        pingState = PingState.SHUTDOWN;\n+        cancelFutures();\n+    }\n+\n+    public final void onReadOrWrite() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+\n+        if (connectionIdleTimeNanos > 0 || pingIdleTimeNanos > 0) {\n+            lastConnectionIdleTime = lastPingIdleTime = System.nanoTime();\n+            firstConnectionIdleEvent = firstPingIdleEvent = true;\n+        }\n+        pingState = PingState.IDLE;\n+        cancelFutures();\n+    }\n+\n+    public final void onPing() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+\n+        if (pingIdleTimeNanos > 0) {\n+            firstPingIdleEvent = true;\n+            lastPingIdleTime = System.nanoTime();\n+        }\n+        pingState = PingState.IDLE;\n+        cancelFutures();\n+    }\n+\n+    protected abstract ChannelFuture writePing(ChannelHandlerContext ctx);\n+\n+    protected abstract boolean hasRequestsInProgress(ChannelHandlerContext ctx);\n+\n+    protected final Future<?> shutdownFuture() {", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM2Nzc0Ng==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401367746", "bodyText": "Could just do this after newIdleStateEvent is called and remove first.", "author": "minwoox", "createdAt": "2020-04-01T05:42:56Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * A {@link KeepAliveHandler} that writes a PING when neither read nor write was performed for\n+ * the specified {@code pingIntervalMillis}, and closes the connection\n+ * when neither read nor write was performed within the given {@code idleTimeoutMillis}.\n+ */\n+public abstract class KeepAliveHandler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KeepAliveHandler.class);\n+\n+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case CONNECTION_IDLE:\n+                return first ? FIRST_CONNECTION_IDLE_STATE_EVENT : CONNECTION_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: state=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private final Channel channel;\n+    private final String name;\n+\n+    @Nullable\n+    private ScheduledFuture<?> connectionIdleTimeout;\n+    private final long connectionIdleTimeNanos;\n+    private long lastConnectionIdleTime;\n+    private boolean firstConnectionIdleEvent = true;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pingIdleTimeout;\n+    private final long pingIdleTimeNanos;\n+    private long lastPingIdleTime;\n+    private boolean firstPingIdleEvent = true;\n+\n+    private byte state; // 0 - none, 1 - initialized, 2 - destroyed\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private PingState pingState = PingState.IDLE;\n+\n+    protected KeepAliveHandler(Channel channel, String name, long idleTimeoutMillis, long pingIntervalMillis) {\n+        this.channel = channel;\n+        this.name = name;\n+\n+        if (idleTimeoutMillis <= 0) {\n+            connectionIdleTimeNanos = 0;\n+        } else {\n+            connectionIdleTimeNanos = Math.max(TimeUnit.MILLISECONDS.toNanos(idleTimeoutMillis),\n+                                               MIN_TIMEOUT_NANOS);\n+        }\n+        if (pingIntervalMillis <= 0) {\n+            pingIdleTimeNanos = 0;\n+        } else {\n+            pingIdleTimeNanos = Math.max(TimeUnit.MILLISECONDS.toNanos(pingIntervalMillis), MIN_TIMEOUT_NANOS);\n+        }\n+    }\n+\n+    public final void initialize(ChannelHandlerContext ctx) {\n+        // Avoid the case where destroy() is called before scheduling timeouts.\n+        // See: https://github.com/netty/netty/issues/143\n+        switch (state) {\n+            case 1:\n+            case 2:\n+                return;\n+        }\n+\n+        state = 1;\n+\n+        if (connectionIdleTimeNanos > 0) {\n+            connectionIdleTimeout = executor().schedule(new ConnectionIdleTimeoutTask(ctx),\n+                                                        connectionIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+        if (pingIdleTimeNanos > 0) {\n+            pingIdleTimeout = executor().schedule(new PingIdleTimeoutTask(ctx),\n+                                                  pingIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+    }\n+\n+    public final void destroy() {\n+        state = 2;\n+        if (connectionIdleTimeout != null) {\n+            connectionIdleTimeout.cancel(false);\n+            connectionIdleTimeout = null;\n+        }\n+        if (pingIdleTimeout != null) {\n+            pingIdleTimeout.cancel(false);\n+            pingIdleTimeout = null;\n+        }\n+        pingState = PingState.SHUTDOWN;\n+        cancelFutures();\n+    }\n+\n+    public final void onReadOrWrite() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+\n+        if (connectionIdleTimeNanos > 0 || pingIdleTimeNanos > 0) {\n+            lastConnectionIdleTime = lastPingIdleTime = System.nanoTime();\n+            firstConnectionIdleEvent = firstPingIdleEvent = true;\n+        }\n+        pingState = PingState.IDLE;\n+        cancelFutures();\n+    }\n+\n+    public final void onPing() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+\n+        if (pingIdleTimeNanos > 0) {\n+            firstPingIdleEvent = true;\n+            lastPingIdleTime = System.nanoTime();\n+        }\n+        pingState = PingState.IDLE;\n+        cancelFutures();\n+    }\n+\n+    protected abstract ChannelFuture writePing(ChannelHandlerContext ctx);\n+\n+    protected abstract boolean hasRequestsInProgress(ChannelHandlerContext ctx);\n+\n+    protected final Future<?> shutdownFuture() {\n+        return shutdownFuture;\n+    }\n+\n+    protected final boolean isPendingPingAck() {\n+        return pingState == PingState.PENDING_PING_ACK;\n+    }\n+\n+    @VisibleForTesting\n+    final PingState state() {\n+        return pingState;\n+    }\n+\n+    @VisibleForTesting\n+    void onIdleEvent(ChannelHandlerContext ctx, IdleStateEvent evt) {\n+        if (evt.state() == IdleState.CONNECTION_IDLE && evt.isFirst()) {\n+            if (!hasRequestsInProgress(ctx)) {\n+                pingState = PingState.SHUTDOWN;\n+                logger.debug(\"{} Closing an idle {} connection\", ctx.channel(), name);\n+                ctx.channel().close();\n+            }\n+            return;\n+        }\n+\n+        if (pingIdleTimeNanos > 0 && evt.state() == IdleState.PING_IDLE && evt.isFirst()) {\n+            pingState = PingState.PING_SCHEDULED;\n+            writePing(ctx).addListener(pingWriteListener);\n+        }\n+    }\n+\n+    private void cancelFutures() {\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    private void closeChannelAndLog() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+        logger.debug(\"{} Closing an idle channel\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed an idle channel\", channel);\n+            } else {\n+                logger.debug(\"{} Failed to close an idle channel\", channel, future.cause());\n+            }\n+            pingState = PingState.SHUTDOWN;\n+        });\n+    }\n+\n+    private ScheduledExecutorService executor() {\n+        return channel.eventLoop();\n+    }\n+\n+    /**\n+     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n+     * channel is inactive then the state changes to SHUTDOWN.\n+     */\n+    @VisibleForTesting\n+    enum PingState {\n+        /* Nothing happening, but waiting for IdleStateEvent */\n+        IDLE,\n+\n+        /* PING is scheduled */\n+        PING_SCHEDULED,\n+\n+        /* PING is sent and is pending ACK */\n+        PENDING_PING_ACK,\n+\n+        /* Not active anymore */\n+        SHUTDOWN\n+    }\n+\n+    private class PingWriteListener implements ChannelFutureListener {\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} PING write successful\", channel);\n+                final EventLoop el = channel.eventLoop();\n+                shutdownFuture = el.schedule(shutdownRunnable, pingIdleTimeNanos, TimeUnit.NANOSECONDS);\n+                pingState = PingState.PENDING_PING_ACK;\n+                resetStopwatch();\n+            } else {\n+                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n+                // If the channel is closed, we change state to SHUTDOWN on destroy.\n+                if (!future.isCancelled() && Exceptions.isExpected(future.cause())) {\n+                    logger.debug(\"{} PING write failed\", channel, future.cause());\n+                }\n+                if (pingState != PingState.SHUTDOWN) {\n+                    pingState = PingState.IDLE;\n+                }\n+            }\n+        }\n+\n+        private void resetStopwatch() {\n+            if (stopwatch != null) {\n+                stopwatch.reset().start();\n+            }\n+        }\n+    }\n+\n+    private abstract static class AbstractIdleTask implements Runnable {\n+\n+        private final ChannelHandlerContext ctx;\n+\n+        AbstractIdleTask(ChannelHandlerContext ctx) {\n+            this.ctx = ctx;\n+        }\n+\n+        @Override\n+        public void run() {\n+            if (!ctx.channel().isOpen()) {\n+                return;\n+            }\n+\n+            run(ctx);\n+        }\n+\n+        protected abstract void run(ChannelHandlerContext ctx);\n+    }\n+\n+    private final class ConnectionIdleTimeoutTask extends AbstractIdleTask {\n+\n+        private boolean warn;\n+\n+        ConnectionIdleTimeoutTask(ChannelHandlerContext ctx) {\n+            super(ctx);\n+        }\n+\n+        @Override\n+        protected void run(ChannelHandlerContext ctx) {\n+\n+            final long lastConnectionIdleTime = KeepAliveHandler.this.lastConnectionIdleTime;\n+            final long nextDelay = connectionIdleTimeNanos - (System.nanoTime() - lastConnectionIdleTime);\n+            if (nextDelay <= 0) {\n+                // Both reader and writer are idle - set a new timeout and\n+                // notify the callback.\n+                connectionIdleTimeout = executor().schedule(this, connectionIdleTimeNanos,\n+                                                            TimeUnit.NANOSECONDS);\n+\n+                final boolean first = firstConnectionIdleEvent;\n+                firstConnectionIdleEvent = false;", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM2ODAyOA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401368028", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-04-01T05:43:57Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * A {@link KeepAliveHandler} that writes a PING when neither read nor write was performed for\n+ * the specified {@code pingIntervalMillis}, and closes the connection\n+ * when neither read nor write was performed within the given {@code idleTimeoutMillis}.\n+ */\n+public abstract class KeepAliveHandler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KeepAliveHandler.class);\n+\n+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case CONNECTION_IDLE:\n+                return first ? FIRST_CONNECTION_IDLE_STATE_EVENT : CONNECTION_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: state=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private final Channel channel;\n+    private final String name;\n+\n+    @Nullable\n+    private ScheduledFuture<?> connectionIdleTimeout;\n+    private final long connectionIdleTimeNanos;\n+    private long lastConnectionIdleTime;\n+    private boolean firstConnectionIdleEvent = true;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pingIdleTimeout;\n+    private final long pingIdleTimeNanos;\n+    private long lastPingIdleTime;\n+    private boolean firstPingIdleEvent = true;\n+\n+    private byte state; // 0 - none, 1 - initialized, 2 - destroyed\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private PingState pingState = PingState.IDLE;\n+\n+    protected KeepAliveHandler(Channel channel, String name, long idleTimeoutMillis, long pingIntervalMillis) {\n+        this.channel = channel;\n+        this.name = name;\n+\n+        if (idleTimeoutMillis <= 0) {\n+            connectionIdleTimeNanos = 0;\n+        } else {\n+            connectionIdleTimeNanos = Math.max(TimeUnit.MILLISECONDS.toNanos(idleTimeoutMillis),\n+                                               MIN_TIMEOUT_NANOS);\n+        }\n+        if (pingIntervalMillis <= 0) {\n+            pingIdleTimeNanos = 0;\n+        } else {\n+            pingIdleTimeNanos = Math.max(TimeUnit.MILLISECONDS.toNanos(pingIntervalMillis), MIN_TIMEOUT_NANOS);\n+        }\n+    }\n+\n+    public final void initialize(ChannelHandlerContext ctx) {\n+        // Avoid the case where destroy() is called before scheduling timeouts.\n+        // See: https://github.com/netty/netty/issues/143\n+        switch (state) {\n+            case 1:\n+            case 2:\n+                return;\n+        }\n+\n+        state = 1;\n+\n+        if (connectionIdleTimeNanos > 0) {\n+            connectionIdleTimeout = executor().schedule(new ConnectionIdleTimeoutTask(ctx),\n+                                                        connectionIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+        if (pingIdleTimeNanos > 0) {\n+            pingIdleTimeout = executor().schedule(new PingIdleTimeoutTask(ctx),\n+                                                  pingIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+    }\n+\n+    public final void destroy() {\n+        state = 2;\n+        if (connectionIdleTimeout != null) {\n+            connectionIdleTimeout.cancel(false);\n+            connectionIdleTimeout = null;\n+        }\n+        if (pingIdleTimeout != null) {\n+            pingIdleTimeout.cancel(false);\n+            pingIdleTimeout = null;\n+        }\n+        pingState = PingState.SHUTDOWN;\n+        cancelFutures();\n+    }\n+\n+    public final void onReadOrWrite() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+\n+        if (connectionIdleTimeNanos > 0 || pingIdleTimeNanos > 0) {\n+            lastConnectionIdleTime = lastPingIdleTime = System.nanoTime();\n+            firstConnectionIdleEvent = firstPingIdleEvent = true;\n+        }\n+        pingState = PingState.IDLE;\n+        cancelFutures();\n+    }\n+\n+    public final void onPing() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+\n+        if (pingIdleTimeNanos > 0) {\n+            firstPingIdleEvent = true;\n+            lastPingIdleTime = System.nanoTime();\n+        }\n+        pingState = PingState.IDLE;\n+        cancelFutures();\n+    }\n+\n+    protected abstract ChannelFuture writePing(ChannelHandlerContext ctx);\n+\n+    protected abstract boolean hasRequestsInProgress(ChannelHandlerContext ctx);\n+\n+    protected final Future<?> shutdownFuture() {\n+        return shutdownFuture;\n+    }\n+\n+    protected final boolean isPendingPingAck() {\n+        return pingState == PingState.PENDING_PING_ACK;\n+    }\n+\n+    @VisibleForTesting\n+    final PingState state() {\n+        return pingState;\n+    }\n+\n+    @VisibleForTesting\n+    void onIdleEvent(ChannelHandlerContext ctx, IdleStateEvent evt) {\n+        if (evt.state() == IdleState.CONNECTION_IDLE && evt.isFirst()) {\n+            if (!hasRequestsInProgress(ctx)) {\n+                pingState = PingState.SHUTDOWN;\n+                logger.debug(\"{} Closing an idle {} connection\", ctx.channel(), name);\n+                ctx.channel().close();\n+            }\n+            return;\n+        }\n+\n+        if (pingIdleTimeNanos > 0 && evt.state() == IdleState.PING_IDLE && evt.isFirst()) {\n+            pingState = PingState.PING_SCHEDULED;\n+            writePing(ctx).addListener(pingWriteListener);\n+        }\n+    }\n+\n+    private void cancelFutures() {\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    private void closeChannelAndLog() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+        logger.debug(\"{} Closing an idle channel\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed an idle channel\", channel);\n+            } else {\n+                logger.debug(\"{} Failed to close an idle channel\", channel, future.cause());\n+            }\n+            pingState = PingState.SHUTDOWN;\n+        });\n+    }\n+\n+    private ScheduledExecutorService executor() {\n+        return channel.eventLoop();\n+    }\n+\n+    /**\n+     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n+     * channel is inactive then the state changes to SHUTDOWN.\n+     */\n+    @VisibleForTesting\n+    enum PingState {\n+        /* Nothing happening, but waiting for IdleStateEvent */\n+        IDLE,\n+\n+        /* PING is scheduled */\n+        PING_SCHEDULED,\n+\n+        /* PING is sent and is pending ACK */\n+        PENDING_PING_ACK,\n+\n+        /* Not active anymore */\n+        SHUTDOWN\n+    }\n+\n+    private class PingWriteListener implements ChannelFutureListener {\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} PING write successful\", channel);\n+                final EventLoop el = channel.eventLoop();\n+                shutdownFuture = el.schedule(shutdownRunnable, pingIdleTimeNanos, TimeUnit.NANOSECONDS);\n+                pingState = PingState.PENDING_PING_ACK;\n+                resetStopwatch();\n+            } else {\n+                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n+                // If the channel is closed, we change state to SHUTDOWN on destroy.\n+                if (!future.isCancelled() && Exceptions.isExpected(future.cause())) {\n+                    logger.debug(\"{} PING write failed\", channel, future.cause());\n+                }\n+                if (pingState != PingState.SHUTDOWN) {\n+                    pingState = PingState.IDLE;\n+                }\n+            }\n+        }\n+\n+        private void resetStopwatch() {\n+            if (stopwatch != null) {\n+                stopwatch.reset().start();\n+            }\n+        }\n+    }\n+\n+    private abstract static class AbstractIdleTask implements Runnable {\n+\n+        private final ChannelHandlerContext ctx;\n+\n+        AbstractIdleTask(ChannelHandlerContext ctx) {\n+            this.ctx = ctx;\n+        }\n+\n+        @Override\n+        public void run() {\n+            if (!ctx.channel().isOpen()) {\n+                return;\n+            }\n+\n+            run(ctx);\n+        }\n+\n+        protected abstract void run(ChannelHandlerContext ctx);\n+    }\n+\n+    private final class ConnectionIdleTimeoutTask extends AbstractIdleTask {\n+\n+        private boolean warn;\n+\n+        ConnectionIdleTimeoutTask(ChannelHandlerContext ctx) {\n+            super(ctx);\n+        }\n+\n+        @Override\n+        protected void run(ChannelHandlerContext ctx) {\n+\n+            final long lastConnectionIdleTime = KeepAliveHandler.this.lastConnectionIdleTime;\n+            final long nextDelay = connectionIdleTimeNanos - (System.nanoTime() - lastConnectionIdleTime);\n+            if (nextDelay <= 0) {\n+                // Both reader and writer are idle - set a new timeout and\n+                // notify the callback.\n+                connectionIdleTimeout = executor().schedule(this, connectionIdleTimeNanos,\n+                                                            TimeUnit.NANOSECONDS);\n+\n+                final boolean first = firstConnectionIdleEvent;\n+                firstConnectionIdleEvent = false;\n+                final IdleStateEvent event = newIdleStateEvent(IdleState.CONNECTION_IDLE, first);\n+                try {\n+                    onIdleEvent(ctx, event);\n+                } catch (Exception e) {\n+                    if (!warn) {\n+                        logger.warn(\"An error occurred while notifying an all idle event\", e);\n+                        warn = true;\n+                    }\n+                }\n+            } else {\n+                // Either read or write occurred before the connection idle timeout - set a new\n+                // timeout with shorter delay.\n+                connectionIdleTimeout = executor().schedule(this, nextDelay, TimeUnit.NANOSECONDS);\n+            }\n+        }\n+    }\n+\n+    private final class PingIdleTimeoutTask extends AbstractIdleTask {\n+\n+        private boolean warn;\n+\n+        PingIdleTimeoutTask(ChannelHandlerContext ctx) {\n+            super(ctx);\n+        }\n+\n+        @Override\n+        protected void run(ChannelHandlerContext ctx) {\n+\n+            final long lastPingIdleTime = KeepAliveHandler.this.lastPingIdleTime;\n+            final long nextDelay = pingIdleTimeNanos - (System.nanoTime() - lastPingIdleTime);\n+            if (nextDelay <= 0) {\n+                // PING is idle - set a new timeout and notify the callback.\n+                pingIdleTimeout = executor().schedule(this, pingIdleTimeNanos, TimeUnit.NANOSECONDS);\n+\n+                final boolean first = firstPingIdleEvent;\n+                firstPingIdleEvent = false;", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQzNzYwOA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401437608", "bodyText": "Question: do we need to check ctx.channel().isRegistered()?", "author": "minwoox", "createdAt": "2020-04-01T08:21:51Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http1RequestDecoder.java", "diffHunk": "@@ -312,4 +342,18 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exc\n \n         ctx.fireUserEventTriggered(evt);\n     }\n+\n+    private void maybeInitializeKeepAliveHandler(ChannelHandlerContext ctx) {\n+        final KeepAliveHandler keepAliveHandler = writer.keepAliveHandler();\n+        if (keepAliveHandler != null && ctx.channel().isActive() && ctx.channel().isRegistered()) {", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ5NzMzOQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401497339", "bodyText": "The original IdleStateHandler checks ctx.channel().isRegistered(). https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java#L241\nIf this method is called by handlerAdded(), I think the condition is meaningful.", "author": "ikhoon", "createdAt": "2020-04-01T09:59:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQzNzYwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0MTEzNA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401441134", "bodyText": "Question: do we need this handler for Http2PrefaceOrHttpHandler?", "author": "minwoox", "createdAt": "2020-04-01T08:27:59Z", "path": "core/src/main/java/com/linecorp/armeria/server/HttpServerPipelineConfigurator.java", "diffHunk": "@@ -448,20 +447,38 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E\n \n         private final ServerHttp1ObjectEncoder responseEncoder;\n         @Nullable\n+        private final KeepAliveHandler keepAliveHandler;\n+        @Nullable\n         private String name;\n \n         Http2PrefaceOrHttpHandler(ServerHttp1ObjectEncoder responseEncoder) {\n             this.responseEncoder = responseEncoder;\n+            keepAliveHandler = responseEncoder.keepAliveHandler();", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUwNTA3OA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401505078", "bodyText": "Yes. When a client connects a connection and does not send any packets, we have to close the connection after an idle timeout.", "author": "ikhoon", "createdAt": "2020-04-01T10:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0MTEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUyNDEzNw==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401524137", "bodyText": "The following test failed without this. \ud83d\ude00\n\n  \n    \n      armeria/core/src/test/java/com/linecorp/armeria/server/ServerTest.java\n    \n    \n         Line 286\n      in\n      46eff82\n    \n    \n    \n    \n\n        \n          \n           void testIdleTimeoutByNoContentSent() throws Exception {", "author": "ikhoon", "createdAt": "2020-04-01T10:47:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0MTEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0MTMxMA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401441310", "bodyText": "an HTTP/2", "author": "minwoox", "createdAt": "2020-04-01T08:28:17Z", "path": "core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java", "diffHunk": "@@ -461,33 +460,21 @@ public ServerBuilder idleTimeout(Duration idleTimeout) {\n     }\n \n     /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n-     *\n-     * @param http2PingTimeoutMillis the timeout in milliseconds. {@code 0} disables the timeout.\n+     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> interval.\n+     * {@code 0} means the server will not send PING frames on a HTTP/2 connection.", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0MTM5MA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401441390", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-04-01T08:28:25Z", "path": "core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java", "diffHunk": "@@ -461,33 +460,21 @@ public ServerBuilder idleTimeout(Duration idleTimeout) {\n     }\n \n     /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n-     *\n-     * @param http2PingTimeoutMillis the timeout in milliseconds. {@code 0} disables the timeout.\n+     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> interval.\n+     * {@code 0} means the server will not send PING frames on a HTTP/2 connection.\n      */\n-    public ServerBuilder http2PingTimeoutMillis(long http2PingTimeoutMillis) {\n-        this.http2PingTimeoutMillis = validateNonNegative(http2PingTimeoutMillis, \"http2PingTimeoutMillis\");\n+    public ServerBuilder pingIntervalMillis(long pingIntervalMillis) {\n+        this.pingIntervalMillis = validateNonNegative(pingIntervalMillis, \"pingIntervalMillis\");\n         return this;\n     }\n \n     /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n-     *\n-     * @param http2PingTimeoutMillis the timeout. {@code 0} disables the timeout.\n+     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> interval.\n+     * {@code 0} means the server will not send PING frames on a HTTP/2 connection.", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0NjUwMA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401446500", "bodyText": "I think this test will make flaky test. How about using just await() after clientIdleTimeout elapsed?", "author": "minwoox", "createdAt": "2020-04-01T08:36:51Z", "path": "core/src/test/java/com/linecorp/armeria/server/HttpServerKeepAliveHandlerTest.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import com.linecorp.armeria.client.ClientFactory;\n+import com.linecorp.armeria.client.ConnectionPoolListener;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.logging.LoggingService;\n+import com.linecorp.armeria.testing.junit.server.ServerExtension;\n+\n+import io.netty.util.AttributeMap;\n+\n+class HttpServerKeepAliveHandlerTest {\n+\n+    private static final int serverIdleTimeout = 5000;\n+    private static final int serverPingInterval = 1000;\n+\n+    @RegisterExtension\n+    static ServerExtension server = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.idleTimeoutMillis(serverIdleTimeout);\n+            sb.pingIntervalMillis(serverPingInterval);\n+            sb.decorator(LoggingService.newDecorator())\n+              .service(\"/\", (ctx, req) -> HttpResponse.of(\"OK\"));\n+        }\n+    };\n+\n+    private AtomicInteger counter;\n+    private ConnectionPoolListener listener;\n+\n+    @BeforeEach\n+    void setUp() {\n+        counter = new AtomicInteger();\n+        listener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                counter.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                counter.decrementAndGet();\n+            }\n+        };\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource({ \"H1C\", \"H2C\" })\n+    void closeByClientIdleTimeout(SessionProtocol protocol) throws InterruptedException {\n+        final int clientIdleTimeout = 2000;\n+        final ClientFactory factory = ClientFactory.builder()\n+                                                   .idleTimeoutMillis(clientIdleTimeout)\n+                                                   .connectionPoolListener(listener)\n+                                                   .build();\n+        final WebClient client = WebClient.builder(server.uri(protocol))\n+                                          .factory(factory)\n+                                          .build();\n+\n+        client.get(\"/\").aggregate().join();\n+\n+        // HTTP/2 PING frame sent by the server cannot prevent to close an idle connection.\n+        Thread.sleep(clientIdleTimeout + 1000);", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUwMjYyOQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401502629", "bodyText": "Unfortunately, we should not use await() because clientIdleTimeout is 2000 and serverIdleTimeout is 5000.\nI wanted to check whether the connection is closed by the client-side.\nIf it waits more than 5000 milliseconds here, we don't know which closes the connection.\nProbably we could multiply the timeouts by 2 and use await().timeout(serverIdleTimeout - buffer).", "author": "ikhoon", "createdAt": "2020-04-01T10:08:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0NjUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk5NTM3MQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401995371", "bodyText": "Then How about just checking if serverIdleTimeout is passed or not after the counter becomes 0?\nAlso, don't we need to check if the counter was 1 before it gets to 0?", "author": "minwoox", "createdAt": "2020-04-02T01:01:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0NjUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk5NTY5OQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401995699", "bodyText": "Oh, that sounds good.", "author": "ikhoon", "createdAt": "2020-04-02T01:03:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0NjUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIwOTQ5NQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r402209495", "bodyText": "A user might find this inconvenient because he or she has to update the both settings when he or she wants to disable the ping and reduce the idle timeout. How about automatically disabling ping interval when it's greater than idle timeout?", "author": "trustin", "createdAt": "2020-04-02T10:26:01Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -558,7 +555,16 @@ private ClientFactoryOptions buildOptions() {\n             return ClientFactoryOption.ADDRESS_RESOLVER_GROUP_FACTORY.newValue(addressResolverGroupFactory);\n         });\n \n-        return ClientFactoryOptions.of(options.values());\n+        final ClientFactoryOptions newOptions = ClientFactoryOptions.of(options.values());\n+        final long idleTimeoutMillis = newOptions.idleTimeoutMillis();\n+        final long pingIntervalMillis = newOptions.pingIntervalMillis();\n+        if (idleTimeoutMillis > 0 && pingIntervalMillis > 0) {\n+            checkArgument(idleTimeoutMillis > pingIntervalMillis,\n+                          \"idleTimeoutMillis: %s, pingIntervalMillis: %s \" +\n+                          \"(expected: idleTimeoutMillis > pingIntervalMillis)\",\n+                          idleTimeoutMillis, pingIntervalMillis);\n+        }\n+        return newOptions;", "originalCommit": "484e319f4f1f660c1c139def88c4e4a1d4d46bb4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcxMzEyNA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r402713124", "bodyText": "SGTM, disabled ping interval automatically and updated Javadoc.", "author": "ikhoon", "createdAt": "2020-04-03T03:10:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIwOTQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIxNDIxMg==", "url": "https://github.com/line/armeria/pull/2636#discussion_r402214212", "bodyText": "I think it's not very common but:\n\nAn OPTIONS response can have chunked content.\nHTTP/1 decoder may emit a FullHttpResponse which is both an HttpResponse and an LastHttpContent.\n\nIn such cases, keepAliveHandler.onPing() can be invoked more or less than desired.", "author": "trustin", "createdAt": "2020-04-02T10:34:21Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java", "diffHunk": "@@ -263,4 +279,47 @@ public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exceptio\n     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n         ctx.fireExceptionCaught(cause);\n     }\n+\n+    void setKeepAliveHandler(ChannelHandlerContext ctx, KeepAliveHandler keepAliveHandler) {\n+        this.keepAliveHandler = keepAliveHandler;\n+        maybeInitializeKeepAliveHandler(ctx);\n+    }\n+\n+    private void maybeInitializeKeepAliveHandler(ChannelHandlerContext ctx) {\n+        if (keepAliveHandler != null && ctx.channel().isActive()) {\n+            keepAliveHandler.initialize(ctx);\n+        }\n+    }\n+\n+    private void destroyKeepAliveHandler() {\n+        if (keepAliveHandler != null) {\n+            keepAliveHandler.destroy();\n+        }\n+    }\n+\n+    private void onPingRead(Object msg) {\n+        if (msg instanceof LastHttpContent) {\n+            onPingComplete();\n+        } else {\n+            assert keepAliveHandler != null;\n+            keepAliveHandler.onPing();\n+        }", "originalCommit": "484e319f4f1f660c1c139def88c4e4a1d4d46bb4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcxNDUzMg==", "url": "https://github.com/line/armeria/pull/2636#discussion_r402714532", "bodyText": "Good point, I didn't think of that.", "author": "ikhoon", "createdAt": "2020-04-03T03:16:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIxNDIxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIyMDMzOA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r402220338", "bodyText": "What happens if a server doesn't respond to a ping? Do we send another OPTIONS *? I guess we should not send another OPTIONS * but close the connection, unlike HTTP/2.", "author": "trustin", "createdAt": "2020-04-02T10:45:53Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java", "diffHunk": "@@ -263,4 +279,47 @@ public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exceptio\n     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n         ctx.fireExceptionCaught(cause);\n     }\n+\n+    void setKeepAliveHandler(ChannelHandlerContext ctx, KeepAliveHandler keepAliveHandler) {\n+        this.keepAliveHandler = keepAliveHandler;\n+        maybeInitializeKeepAliveHandler(ctx);\n+    }\n+\n+    private void maybeInitializeKeepAliveHandler(ChannelHandlerContext ctx) {\n+        if (keepAliveHandler != null && ctx.channel().isActive()) {\n+            keepAliveHandler.initialize(ctx);\n+        }\n+    }\n+\n+    private void destroyKeepAliveHandler() {\n+        if (keepAliveHandler != null) {\n+            keepAliveHandler.destroy();\n+        }\n+    }\n+\n+    private void onPingRead(Object msg) {\n+        if (msg instanceof LastHttpContent) {\n+            onPingComplete();\n+        } else {\n+            assert keepAliveHandler != null;\n+            keepAliveHandler.onPing();\n+        }\n+    }\n+\n+    void setPingReqId(int id) {\n+        lastPingReqId = id;\n+    }\n+\n+    boolean isPingReqId(int id) {\n+        return lastPingReqId == id;\n+    }", "originalCommit": "484e319f4f1f660c1c139def88c4e4a1d4d46bb4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0Njg0MA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r403846840", "bodyText": "Could use a singleton.", "author": "trustin", "createdAt": "2020-04-06T06:03:17Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -558,11 +564,8 @@ private ClientFactoryOptions buildOptions() {\n         final ClientFactoryOptions newOptions = ClientFactoryOptions.of(options.values());\n         final long idleTimeoutMillis = newOptions.idleTimeoutMillis();\n         final long pingIntervalMillis = newOptions.pingIntervalMillis();\n-        if (idleTimeoutMillis > 0 && pingIntervalMillis > 0) {\n-            checkArgument(idleTimeoutMillis > pingIntervalMillis,\n-                          \"idleTimeoutMillis: %s, pingIntervalMillis: %s \" +\n-                          \"(expected: idleTimeoutMillis > pingIntervalMillis)\",\n-                          idleTimeoutMillis, pingIntervalMillis);\n+        if (idleTimeoutMillis > 0 && pingIntervalMillis >= idleTimeoutMillis) {\n+            return ClientFactoryOptions.of(newOptions, ClientFactoryOption.PING_INTERVAL_MILLIS.newValue(0L));", "originalCommit": "b5d13a4136d6a6826b4a42dd085863538662ffad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0ODYzNA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r403848634", "bodyText": "nit: how about mentioning HTTP/2's case first?", "author": "trustin", "createdAt": "2020-04-06T06:08:55Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -419,36 +419,39 @@ public ClientFactoryBuilder idleTimeoutMillis(long idleTimeoutMillis) {\n     }\n \n     /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * Sets the PING interval in milliseconds.\n+     * When neither read nor write was performed for the given {@code pingIntervalMillis},\n+     * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n+     * is sent for HTTP/1,\n+     * or a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2.", "originalCommit": "b5d13a4136d6a6826b4a42dd085863538662ffad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwMDkyNg==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405200926", "bodyText": "Do we need this?", "author": "minwoox", "createdAt": "2020-04-08T01:07:09Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -558,7 +572,19 @@ private ClientFactoryOptions buildOptions() {\n             return ClientFactoryOption.ADDRESS_RESOLVER_GROUP_FACTORY.newValue(addressResolverGroupFactory);\n         });\n \n-        return ClientFactoryOptions.of(options.values());\n+        final ClientFactoryOptions newOptions = ClientFactoryOptions.of(options.values());\n+        final long idleTimeoutMillis = newOptions.idleTimeoutMillis();\n+        final long pingIntervalMillis = newOptions.pingIntervalMillis();\n+        final long minPingIntervalMillis = Math.max(pingIntervalMillis, MIN_PING_INTERVAL_MILLIS);\n+        if (idleTimeoutMillis > 0) {\n+            if (minPingIntervalMillis >= idleTimeoutMillis) {\n+                return ClientFactoryOptions.of(newOptions, ZERO_PING_INTERVAL);\n+            }\n+            if (minPingIntervalMillis == MIN_PING_INTERVAL_MILLIS) {", "originalCommit": "32e036591c7d89eae4a73ac17bc1f95bbd37b565", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUzNjcwMg==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405536702", "bodyText": "Because the default PING interval could be set by Flags.defaultPingIntervalMillis().\nIf the default PING interval is smaller than 10 seconds, bumps that to 10 seconds.", "author": "ikhoon", "createdAt": "2020-04-08T13:45:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwMDkyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwMzYxMQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405903611", "bodyText": "When I left the comment there was no\nif (pingIntervalMillis == MIN_PING_INTERVAL_MILLIS) {\n    return newOptions;\n}\nthis condition, so I left the comment. I guess it's fixed now.", "author": "minwoox", "createdAt": "2020-04-09T01:20:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwMDkyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkxNzAzOA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405917038", "bodyText": "Ah... thanks!", "author": "ikhoon", "createdAt": "2020-04-09T02:12:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwMDkyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwMjQ4Nw==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405202487", "bodyText": "Shouldn't we subscribe to this to prevent memory leak?", "author": "minwoox", "createdAt": "2020-04-08T01:13:19Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java", "diffHunk": "@@ -263,4 +279,48 @@ public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exceptio\n     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n         ctx.fireExceptionCaught(cause);\n     }\n+\n+    void setKeepAliveHandler(ChannelHandlerContext ctx, KeepAliveHandler keepAliveHandler) {\n+        this.keepAliveHandler = keepAliveHandler;\n+        maybeInitializeKeepAliveHandler(ctx);\n+    }\n+\n+    private void maybeInitializeKeepAliveHandler(ChannelHandlerContext ctx) {\n+        if (keepAliveHandler != null && ctx.channel().isActive()) {\n+            keepAliveHandler.initialize(ctx);\n+        }\n+    }\n+\n+    private void destroyKeepAliveHandler() {\n+        if (keepAliveHandler != null) {\n+            keepAliveHandler.destroy();\n+        }\n+    }\n+\n+    private void onPingRead(Object msg) {\n+        if (msg instanceof HttpResponse) {", "originalCommit": "32e036591c7d89eae4a73ac17bc1f95bbd37b565", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU0Nzc1OA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405547758", "bodyText": "It's Netty HttpResponse. I forgot to release it. \ud83d\ude05", "author": "ikhoon", "createdAt": "2020-04-08T14:00:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwMjQ4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwOTU0MA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405209540", "bodyText": "If the event is not first, then the channel is not closed even there's no requests in progress?", "author": "minwoox", "createdAt": "2020-04-08T01:39:43Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,399 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * A {@link KeepAliveHandler} that writes a PING when neither read nor write was performed for\n+ * the specified {@code pingIntervalMillis}, and closes the connection\n+ * when neither read nor write was performed within the given {@code idleTimeoutMillis}.\n+ */\n+public abstract class KeepAliveHandler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KeepAliveHandler.class);\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case CONNECTION_IDLE:\n+                return first ? FIRST_CONNECTION_IDLE_STATE_EVENT : CONNECTION_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: initialized=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private final Channel channel;\n+    private final String name;\n+\n+    @Nullable\n+    private ScheduledFuture<?> connectionIdleTimeout;\n+    private final long connectionIdleTimeNanos;\n+    private long lastConnectionIdleTime;\n+    private boolean firstConnectionIdleEvent = true;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pingIdleTimeout;\n+    private final long pingIdleTimeNanos;\n+    private long lastPingIdleTime;\n+    private boolean firstPingIdleEvent = true;\n+\n+    private boolean isInitialized;\n+    private PingState pingState = PingState.IDLE;\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+\n+    protected KeepAliveHandler(Channel channel, String name, long idleTimeoutMillis, long pingIntervalMillis) {\n+        this.channel = channel;\n+        this.name = name;\n+\n+        if (idleTimeoutMillis <= 0) {\n+            connectionIdleTimeNanos = 0;\n+        } else {\n+            connectionIdleTimeNanos = TimeUnit.MILLISECONDS.toNanos(idleTimeoutMillis);\n+        }\n+        if (pingIntervalMillis <= 0) {\n+            pingIdleTimeNanos = 0;\n+        } else {\n+            pingIdleTimeNanos = TimeUnit.MILLISECONDS.toNanos(pingIntervalMillis);\n+        }\n+    }\n+\n+    public final void initialize(ChannelHandlerContext ctx) {\n+        // Avoid the case where destroy() is called before scheduling timeouts.\n+        // See: https://github.com/netty/netty/issues/143\n+        if (isInitialized) {\n+            return;\n+        }\n+        isInitialized = true;\n+\n+        if (connectionIdleTimeNanos > 0) {\n+            connectionIdleTimeout = executor().schedule(new ConnectionIdleTimeoutTask(ctx),\n+                                                        connectionIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+        if (pingIdleTimeNanos > 0) {\n+            pingIdleTimeout = executor().schedule(new PingIdleTimeoutTask(ctx),\n+                                                  pingIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+    }\n+\n+    public final void destroy() {\n+        isInitialized = true;\n+        if (connectionIdleTimeout != null) {\n+            connectionIdleTimeout.cancel(false);\n+            connectionIdleTimeout = null;\n+        }\n+        if (pingIdleTimeout != null) {\n+            pingIdleTimeout.cancel(false);\n+            pingIdleTimeout = null;\n+        }\n+        pingState = PingState.SHUTDOWN;\n+        cancelFutures();\n+    }\n+\n+    public final void onReadOrWrite() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+\n+        if (connectionIdleTimeNanos > 0) {\n+            lastConnectionIdleTime = System.nanoTime();\n+            firstConnectionIdleEvent = true;\n+        }\n+\n+        if (pingResetsPreviousPing()) {\n+            if (pingIdleTimeNanos > 0) {\n+                lastPingIdleTime = System.nanoTime();\n+                firstPingIdleEvent = true;\n+            }\n+            pingState = PingState.IDLE;\n+            cancelFutures();\n+        }\n+    }\n+\n+    public final void onPing() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+\n+        if (pingIdleTimeNanos > 0) {\n+            firstPingIdleEvent = true;\n+            lastPingIdleTime = System.nanoTime();\n+        }\n+        pingState = PingState.IDLE;\n+        cancelFutures();\n+    }\n+\n+    protected abstract ChannelFuture writePing(ChannelHandlerContext ctx);\n+\n+    protected abstract boolean pingResetsPreviousPing();\n+\n+    protected abstract boolean hasRequestsInProgress(ChannelHandlerContext ctx);\n+\n+    @Nullable\n+    protected final Future<?> shutdownFuture() {\n+        return shutdownFuture;\n+    }\n+\n+    protected final boolean isPendingPingAck() {\n+        return pingState == PingState.PENDING_PING_ACK;\n+    }\n+\n+    @VisibleForTesting\n+    final PingState state() {\n+        return pingState;\n+    }\n+\n+    @VisibleForTesting\n+    void onIdleEvent(ChannelHandlerContext ctx, IdleStateEvent evt) {\n+        if (evt.state() == IdleState.CONNECTION_IDLE && evt.isFirst()) {", "originalCommit": "32e036591c7d89eae4a73ac17bc1f95bbd37b565", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU5ODI5OQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405598299", "bodyText": "The original code in IdleTimeoutHandler is:\n\n  \n    \n      armeria/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutHandler.java\n    \n    \n        Lines 57 to 64\n      in\n      b1bb733\n    \n    \n    \n    \n\n        \n          \n           if (!evt.isFirst()) { \n        \n\n        \n          \n               return; \n        \n\n        \n          \n           } \n        \n\n        \n          \n            \n        \n\n        \n          \n           if (!hasRequestsInProgress(ctx)) { \n        \n\n        \n          \n               logger.debug(\"{} Closing an idle {} connection\", ctx.channel(), name); \n        \n\n        \n          \n               ctx.channel().close(); \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nI will investigate more to know how the connection is handled on idle with active requests.", "author": "ikhoon", "createdAt": "2020-04-08T15:09:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwOTU0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYzMjk5Nw==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405632997", "bodyText": "A connection is not closed when an active request is closed by the request timeout after the first CONNECTION_IDLE event. This behavior seems weird because there are no active requests in the connection.\nLet me remove evt.isFirst() condition.", "author": "ikhoon", "createdAt": "2020-04-08T15:56:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwOTU0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxMDg1NA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405210854", "bodyText": "Can remove idleTimeoutMillis > 0.", "author": "minwoox", "createdAt": "2020-04-08T01:45:00Z", "path": "core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java", "diffHunk": "@@ -1406,6 +1401,11 @@ public ServerBuilder annotatedServiceExtensions(\n      * Returns a newly-created {@link Server} based on the configuration properties set so far.\n      */\n     public Server build() {\n+        long pingIntervalMillis = Math.max(this.pingIntervalMillis, 10_000L);\n+        if (idleTimeoutMillis > 0 && pingIntervalMillis >= idleTimeoutMillis) {", "originalCommit": "32e036591c7d89eae4a73ac17bc1f95bbd37b565", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwNTU5Mw==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405905593", "bodyText": "This could be\n<p>The minimum PING interval is {@value #MIN_PING_INTERVAL_MILLIS} milliseconds.", "author": "minwoox", "createdAt": "2020-04-09T01:27:56Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -419,36 +428,44 @@ public ClientFactoryBuilder idleTimeoutMillis(long idleTimeoutMillis) {\n     }\n \n     /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * Sets the PING interval in milliseconds.\n+     * When neither read nor write was performed for the given {@code pingIntervalMillis},\n+     * a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2 or\n+     * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n+     * is sent for HTTP/1.\n      *\n-     * @param http2PingTimeoutMillis the timeout in milliseconds. {@code 0} disables the timeout.\n-     */\n-    public ClientFactoryBuilder http2PingTimeoutMillis(long http2PingTimeoutMillis) {\n-        checkArgument(http2PingTimeoutMillis >= 0,\n-                      \"http2PingTimeoutMillis: %s (expected: >= 0)\", http2PingTimeoutMillis);\n-        option(ClientFactoryOption.HTTP2_PING_TIMEOUT_MILLIS, http2PingTimeoutMillis);\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n+     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n      *\n-     * @param http2PingTimeout the timeout. {@code 0} disables the timeout.\n-     */\n-    public ClientFactoryBuilder http2PingTimeout(Duration http2PingTimeout) {\n-        requireNonNull(http2PingTimeout, \"http2PingTimeout\");\n-        checkArgument(http2PingTimeout.toMillis() >= 0,\n-                      \"http2PingTimeoutMillis: %s (expected: >= 0)\", http2PingTimeout.toMillis());\n-        http2PingTimeoutMillis(http2PingTimeout.toMillis());\n+     * <p>The minimum PING interval is 10 seconds. {@code 0} means the client will not send a PING.\n+     *\n+     * @throws IllegalArgumentException if the specified {@code pingIntervalMillis}\n+     *                                  is smaller than 10000 milliseconds.\n+     */\n+    public ClientFactoryBuilder pingIntervalMillis(long pingIntervalMillis) {\n+        checkArgument(pingIntervalMillis == 0 || pingIntervalMillis >= MIN_PING_INTERVAL_MILLIS,\n+                      \"pingIntervalMillis: %s (expected: >= %s or == 0)\", pingIntervalMillis,\n+                      MIN_PING_INTERVAL_MILLIS);\n+        option(ClientFactoryOption.PING_INTERVAL_MILLIS, pingIntervalMillis);\n         return this;\n     }\n \n     /**\n-     * Sets whether to send HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n-     * when there are no active streams open.\n+     * Sets the PING interval.\n+     * When neither read nor write was performed for the given {@code pingInterval},\n+     * a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2 or\n+     * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n+     * is sent for HTTP/1.\n+     *\n+     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n+     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n+     *\n+     * <p>The minimum PING interval is 10 seconds. {@code 0} means the client will not send a PING.", "originalCommit": "4850e0202f5307be535f26d4aad8d86ede1b05e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwNTY0NQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405905645", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-04-09T01:28:07Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -419,36 +428,44 @@ public ClientFactoryBuilder idleTimeoutMillis(long idleTimeoutMillis) {\n     }\n \n     /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * Sets the PING interval in milliseconds.\n+     * When neither read nor write was performed for the given {@code pingIntervalMillis},\n+     * a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2 or\n+     * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n+     * is sent for HTTP/1.\n      *\n-     * @param http2PingTimeoutMillis the timeout in milliseconds. {@code 0} disables the timeout.\n-     */\n-    public ClientFactoryBuilder http2PingTimeoutMillis(long http2PingTimeoutMillis) {\n-        checkArgument(http2PingTimeoutMillis >= 0,\n-                      \"http2PingTimeoutMillis: %s (expected: >= 0)\", http2PingTimeoutMillis);\n-        option(ClientFactoryOption.HTTP2_PING_TIMEOUT_MILLIS, http2PingTimeoutMillis);\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n+     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n      *\n-     * @param http2PingTimeout the timeout. {@code 0} disables the timeout.\n-     */\n-    public ClientFactoryBuilder http2PingTimeout(Duration http2PingTimeout) {\n-        requireNonNull(http2PingTimeout, \"http2PingTimeout\");\n-        checkArgument(http2PingTimeout.toMillis() >= 0,\n-                      \"http2PingTimeoutMillis: %s (expected: >= 0)\", http2PingTimeout.toMillis());\n-        http2PingTimeoutMillis(http2PingTimeout.toMillis());\n+     * <p>The minimum PING interval is 10 seconds. {@code 0} means the client will not send a PING.", "originalCommit": "4850e0202f5307be535f26d4aad8d86ede1b05e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwNjA4Ng==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405906086", "bodyText": "ditto. Could use {@value }", "author": "minwoox", "createdAt": "2020-04-09T01:29:56Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -419,36 +428,44 @@ public ClientFactoryBuilder idleTimeoutMillis(long idleTimeoutMillis) {\n     }\n \n     /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * Sets the PING interval in milliseconds.\n+     * When neither read nor write was performed for the given {@code pingIntervalMillis},\n+     * a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2 or\n+     * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n+     * is sent for HTTP/1.\n      *\n-     * @param http2PingTimeoutMillis the timeout in milliseconds. {@code 0} disables the timeout.\n-     */\n-    public ClientFactoryBuilder http2PingTimeoutMillis(long http2PingTimeoutMillis) {\n-        checkArgument(http2PingTimeoutMillis >= 0,\n-                      \"http2PingTimeoutMillis: %s (expected: >= 0)\", http2PingTimeoutMillis);\n-        option(ClientFactoryOption.HTTP2_PING_TIMEOUT_MILLIS, http2PingTimeoutMillis);\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n+     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n      *\n-     * @param http2PingTimeout the timeout. {@code 0} disables the timeout.\n-     */\n-    public ClientFactoryBuilder http2PingTimeout(Duration http2PingTimeout) {\n-        requireNonNull(http2PingTimeout, \"http2PingTimeout\");\n-        checkArgument(http2PingTimeout.toMillis() >= 0,\n-                      \"http2PingTimeoutMillis: %s (expected: >= 0)\", http2PingTimeout.toMillis());\n-        http2PingTimeoutMillis(http2PingTimeout.toMillis());\n+     * <p>The minimum PING interval is 10 seconds. {@code 0} means the client will not send a PING.\n+     *\n+     * @throws IllegalArgumentException if the specified {@code pingIntervalMillis}\n+     *                                  is smaller than 10000 milliseconds.\n+     */\n+    public ClientFactoryBuilder pingIntervalMillis(long pingIntervalMillis) {\n+        checkArgument(pingIntervalMillis == 0 || pingIntervalMillis >= MIN_PING_INTERVAL_MILLIS,\n+                      \"pingIntervalMillis: %s (expected: >= %s or == 0)\", pingIntervalMillis,\n+                      MIN_PING_INTERVAL_MILLIS);\n+        option(ClientFactoryOption.PING_INTERVAL_MILLIS, pingIntervalMillis);\n         return this;\n     }\n \n     /**\n-     * Sets whether to send HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n-     * when there are no active streams open.\n+     * Sets the PING interval.\n+     * When neither read nor write was performed for the given {@code pingInterval},\n+     * a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2 or\n+     * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n+     * is sent for HTTP/1.\n+     *\n+     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n+     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n+     *\n+     * <p>The minimum PING interval is 10 seconds. {@code 0} means the client will not send a PING.\n+     *\n+     * @throws IllegalArgumentException if the specified {@code pingInterval} is smaller than 10 seconds.", "originalCommit": "4850e0202f5307be535f26d4aad8d86ede1b05e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwNzU1MA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405907550", "bodyText": "nit: it's", "author": "minwoox", "createdAt": "2020-04-09T01:35:53Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/IdleStateEvent.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.netty.util.internal.StringUtil;\n+\n+/**\n+ * An idle state event triggered by {@link KeepAliveHandler}.\n+ */\n+class IdleStateEvent {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java\n+\n+    public static final IdleStateEvent FIRST_CONNECTION_IDLE_STATE_EVENT =\n+            new DefaultIdleStateEvent(IdleState.CONNECTION_IDLE, true);\n+    public static final IdleStateEvent CONNECTION_IDLE_STATE_EVENT =\n+            new DefaultIdleStateEvent(IdleState.CONNECTION_IDLE, false);\n+    public static final IdleStateEvent FIRST_PING_IDLE_STATE_EVENT =\n+            new DefaultIdleStateEvent(IdleState.PING_IDLE, true);\n+    public static final IdleStateEvent PING_IDLE_STATE_EVENT =\n+            new DefaultIdleStateEvent(IdleState.PING_IDLE, false);\n+\n+    private final IdleState state;\n+    private final boolean first;\n+\n+    /**\n+     * Constructor for sub-classes.\n+     *\n+     * @param state the {@link IdleStateEvent} which triggered the event.\n+     * @param first {@code true} if its the first idle event for the {@link IdleStateEvent}.", "originalCommit": "4850e0202f5307be535f26d4aad8d86ede1b05e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwOTg0Mg==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405909842", "bodyText": "How about inlining this? I think connection and ping idle event doesn't have to be in the same place.", "author": "minwoox", "createdAt": "2020-04-09T01:44:59Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,399 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * A {@link KeepAliveHandler} that writes a PING when neither read nor write was performed for\n+ * the specified {@code pingIntervalMillis}, and closes the connection\n+ * when neither read nor write was performed within the given {@code idleTimeoutMillis}.\n+ */\n+public abstract class KeepAliveHandler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KeepAliveHandler.class);\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case CONNECTION_IDLE:\n+                return first ? FIRST_CONNECTION_IDLE_STATE_EVENT : CONNECTION_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: initialized=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private final Channel channel;\n+    private final String name;\n+\n+    @Nullable\n+    private ScheduledFuture<?> connectionIdleTimeout;\n+    private final long connectionIdleTimeNanos;\n+    private long lastConnectionIdleTime;\n+    private boolean firstConnectionIdleEvent = true;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pingIdleTimeout;\n+    private final long pingIdleTimeNanos;\n+    private long lastPingIdleTime;\n+    private boolean firstPingIdleEvent = true;\n+\n+    private boolean isInitialized;\n+    private PingState pingState = PingState.IDLE;\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+\n+    protected KeepAliveHandler(Channel channel, String name, long idleTimeoutMillis, long pingIntervalMillis) {\n+        this.channel = channel;\n+        this.name = name;\n+\n+        if (idleTimeoutMillis <= 0) {\n+            connectionIdleTimeNanos = 0;\n+        } else {\n+            connectionIdleTimeNanos = TimeUnit.MILLISECONDS.toNanos(idleTimeoutMillis);\n+        }\n+        if (pingIntervalMillis <= 0) {\n+            pingIdleTimeNanos = 0;\n+        } else {\n+            pingIdleTimeNanos = TimeUnit.MILLISECONDS.toNanos(pingIntervalMillis);\n+        }\n+    }\n+\n+    public final void initialize(ChannelHandlerContext ctx) {\n+        // Avoid the case where destroy() is called before scheduling timeouts.\n+        // See: https://github.com/netty/netty/issues/143\n+        if (isInitialized) {\n+            return;\n+        }\n+        isInitialized = true;\n+\n+        if (connectionIdleTimeNanos > 0) {\n+            connectionIdleTimeout = executor().schedule(new ConnectionIdleTimeoutTask(ctx),\n+                                                        connectionIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+        if (pingIdleTimeNanos > 0) {\n+            pingIdleTimeout = executor().schedule(new PingIdleTimeoutTask(ctx),\n+                                                  pingIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+    }\n+\n+    public final void destroy() {\n+        isInitialized = true;\n+        if (connectionIdleTimeout != null) {\n+            connectionIdleTimeout.cancel(false);\n+            connectionIdleTimeout = null;\n+        }\n+        if (pingIdleTimeout != null) {\n+            pingIdleTimeout.cancel(false);\n+            pingIdleTimeout = null;\n+        }\n+        pingState = PingState.SHUTDOWN;\n+        cancelFutures();\n+    }\n+\n+    public final void onReadOrWrite() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+\n+        if (connectionIdleTimeNanos > 0) {\n+            lastConnectionIdleTime = System.nanoTime();\n+            firstConnectionIdleEvent = true;\n+        }\n+\n+        if (pingResetsPreviousPing()) {\n+            if (pingIdleTimeNanos > 0) {\n+                lastPingIdleTime = System.nanoTime();\n+                firstPingIdleEvent = true;\n+            }\n+            pingState = PingState.IDLE;\n+            cancelFutures();\n+        }\n+    }\n+\n+    public final void onPing() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+\n+        if (pingIdleTimeNanos > 0) {\n+            firstPingIdleEvent = true;\n+            lastPingIdleTime = System.nanoTime();\n+        }\n+        pingState = PingState.IDLE;\n+        cancelFutures();\n+    }\n+\n+    protected abstract ChannelFuture writePing(ChannelHandlerContext ctx);\n+\n+    protected abstract boolean pingResetsPreviousPing();\n+\n+    protected abstract boolean hasRequestsInProgress(ChannelHandlerContext ctx);\n+\n+    @Nullable\n+    protected final Future<?> shutdownFuture() {\n+        return shutdownFuture;\n+    }\n+\n+    protected final boolean isPendingPingAck() {\n+        return pingState == PingState.PENDING_PING_ACK;\n+    }\n+\n+    @VisibleForTesting\n+    final PingState state() {\n+        return pingState;\n+    }\n+\n+    @VisibleForTesting\n+    void onIdleEvent(ChannelHandlerContext ctx, IdleStateEvent evt) {", "originalCommit": "4850e0202f5307be535f26d4aad8d86ede1b05e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkzODgwOQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405938809", "bodyText": "That sounds good. I will remove this generalization.", "author": "ikhoon", "createdAt": "2020-04-09T03:42:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwOTg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkxMDQ4MQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405910481", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-04-09T01:47:32Z", "path": "core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java", "diffHunk": "@@ -461,33 +463,39 @@ public ServerBuilder idleTimeout(Duration idleTimeout) {\n     }\n \n     /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> interval.\n      *\n-     * @param http2PingTimeoutMillis the timeout in milliseconds. {@code 0} disables the timeout.\n-     */\n-    public ServerBuilder http2PingTimeoutMillis(long http2PingTimeoutMillis) {\n-        this.http2PingTimeoutMillis = validateNonNegative(http2PingTimeoutMillis, \"http2PingTimeoutMillis\");\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n+     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n      *\n-     * @param http2PingTimeoutMillis the timeout. {@code 0} disables the timeout.\n-     */\n-    public ServerBuilder http2PingTimeoutMillis(Duration http2PingTimeoutMillis) {\n-        requireNonNull(http2PingTimeoutMillis, \"http2PingTimeoutMillis\");\n-        this.http2PingTimeoutMillis =\n-                validateNonNegative(http2PingTimeoutMillis.toMillis(), \"http2PingTimeoutMillis\");\n+     * <p>The minimum PING interval is 10 seconds.", "originalCommit": "4850e0202f5307be535f26d4aad8d86ede1b05e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkxMDUyOQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405910529", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-04-09T01:47:43Z", "path": "core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java", "diffHunk": "@@ -461,33 +463,39 @@ public ServerBuilder idleTimeout(Duration idleTimeout) {\n     }\n \n     /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> interval.\n      *\n-     * @param http2PingTimeoutMillis the timeout in milliseconds. {@code 0} disables the timeout.\n-     */\n-    public ServerBuilder http2PingTimeoutMillis(long http2PingTimeoutMillis) {\n-        this.http2PingTimeoutMillis = validateNonNegative(http2PingTimeoutMillis, \"http2PingTimeoutMillis\");\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n+     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n      *\n-     * @param http2PingTimeoutMillis the timeout. {@code 0} disables the timeout.\n-     */\n-    public ServerBuilder http2PingTimeoutMillis(Duration http2PingTimeoutMillis) {\n-        requireNonNull(http2PingTimeoutMillis, \"http2PingTimeoutMillis\");\n-        this.http2PingTimeoutMillis =\n-                validateNonNegative(http2PingTimeoutMillis.toMillis(), \"http2PingTimeoutMillis\");\n+     * <p>The minimum PING interval is 10 seconds.\n+     * {@code 0} means the server will not send PING frames on an HTTP/2 connection.\n+     *\n+     * @throws IllegalArgumentException if the specified {@code pingIntervalMillis}\n+     *                                  is smaller than 10000 milliseconds.", "originalCommit": "4850e0202f5307be535f26d4aad8d86ede1b05e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "url": "https://github.com/line/armeria/commit/15fe952b48ecafeaf7ab3da9dac1800770c5218c", "message": "Add HTTP/1 PING(`OPTIONS *`)\n\nMotivation:\n\nSometimes, a client that sends a request via a load balancer could get `ClosedSessionException`\nbecause the load balancer closes the connection while sending the request.\nPlease see #2576 for detail information.\n\nModifications:\n\n- Make HTTP/1 client send `PING` with `OPTIONS *` when a connection is idle.\n- Introduce `IdleTimeoutScheduler` that schedules a PING interval and an idle timeout.\n- Split PING traffic from normal read and write.\n  - Regardless of PING requests and responses, the connection would be closed on idle.\n- Breaking\n  - Remove `Flags.defaultHttp2PingTimeoutMillis` in favor of `defaultPingIntervalMillis`.\n  - Remove `Flags.defaultUseHttp2PingWhenNoActiveStreams` without replacement.\n    - HTTP/2 can send PING frame with or without active streams.\n    - HTTP/1 can only send PING on no active streams.\n  - Remove `ClientFactory*.http2PingTimeoutMillis()` and `ServerBuilder.http2PingTimeoutMillis()`\n    in favor of `*.pingIntervalMillis()`\n- Miscellaneous\n  - Move ClientHttp*ObjectEncoder to `client` package from `internal` and make them package private\n  - Move ServerHttp*ObjectEncoder to `server` package from `internal` and make them package private\n\nResult:\n\n- HTTP/1 client can send `OPTION *` when a connection is idle.\n- You can now prevent an unexpected disconnection from an idle timeout of a load balancer.", "committedDate": "2020-04-09T03:46:07Z", "type": "commit"}, {"oid": "50331d35ef0cca97aa8d433cfc7e38e5d4f3d403", "url": "https://github.com/line/armeria/commit/50331d35ef0cca97aa8d433cfc7e38e5d4f3d403", "message": "Indent", "committedDate": "2020-04-09T03:46:07Z", "type": "commit"}, {"oid": "4946e8b65179a07991dcddbba38cb1449880f55b", "url": "https://github.com/line/armeria/commit/4946e8b65179a07991dcddbba38cb1449880f55b", "message": "Clean up", "committedDate": "2020-04-09T03:46:08Z", "type": "commit"}, {"oid": "95610a5376e147631156f86173cbdd69edc3ce60", "url": "https://github.com/line/armeria/commit/95610a5376e147631156f86173cbdd69edc3ce60", "message": "Address comments by @trustin", "committedDate": "2020-04-09T03:46:08Z", "type": "commit"}, {"oid": "830b1427949561bec9ce446b63b10784387a2be8", "url": "https://github.com/line/armeria/commit/830b1427949561bec9ce446b63b10784387a2be8", "message": "Update Javadoc and clean up", "committedDate": "2020-04-09T03:46:08Z", "type": "commit"}, {"oid": "16efa9fd17dd8b1996c19adcba8f5191cbb6b105", "url": "https://github.com/line/armeria/commit/16efa9fd17dd8b1996c19adcba8f5191cbb6b105", "message": "Address comments by @minwoox", "committedDate": "2020-04-09T03:46:08Z", "type": "commit"}, {"oid": "7f3b4ae3e411a7aea755a52fcdfc79b94c8737d3", "url": "https://github.com/line/armeria/commit/7f3b4ae3e411a7aea755a52fcdfc79b94c8737d3", "message": "Destroy KeepAliveHandler when HttpObjectEncoder is closed", "committedDate": "2020-04-09T03:46:08Z", "type": "commit"}, {"oid": "5b4794e5d12a22917930848057f70acd2f38a40a", "url": "https://github.com/line/armeria/commit/5b4794e5d12a22917930848057f70acd2f38a40a", "message": "Address comments by @minwoox / Remove a potential flaky test", "committedDate": "2020-04-09T03:46:08Z", "type": "commit"}, {"oid": "69655ac442a81900523d1de83e41aa8ca376d3fe", "url": "https://github.com/line/armeria/commit/69655ac442a81900523d1de83e41aa8ca376d3fe", "message": "Address comments by @trustin\n\n- Don't send other PINGs before receiving PING ack for HTTP/1\n- Ignore the specified PING interval when it is greater than the idle timeout.\n- Update `Http1ResponseDecoder.onPingRead()`", "committedDate": "2020-04-09T03:46:08Z", "type": "commit"}, {"oid": "140cb8b7bdb75b1f0d97e955f74d21950ad826c2", "url": "https://github.com/line/armeria/commit/140cb8b7bdb75b1f0d97e955f74d21950ad826c2", "message": "Address comments by @trusin", "committedDate": "2020-04-09T03:46:09Z", "type": "commit"}, {"oid": "f62d7557d401abb82295238aeaf8944315e8f85b", "url": "https://github.com/line/armeria/commit/f62d7557d401abb82295238aeaf8944315e8f85b", "message": "Fix flaky test", "committedDate": "2020-04-09T03:46:09Z", "type": "commit"}, {"oid": "d0cf22e9fbe0c3233194e365984f59abf8b59fb8", "url": "https://github.com/line/armeria/commit/d0cf22e9fbe0c3233194e365984f59abf8b59fb8", "message": "Limit minimum PING interval to 10 seconds", "committedDate": "2020-04-09T03:46:09Z", "type": "commit"}, {"oid": "bca216965f84dc480451d419b158b46f323eddcd", "url": "https://github.com/line/armeria/commit/bca216965f84dc480451d419b158b46f323eddcd", "message": "throw IllegalArgumentException if pingInterval < MIN_PING_INTERVAL in builders", "committedDate": "2020-04-09T03:46:09Z", "type": "commit"}, {"oid": "85a95b5bca39a9fa7e2d817bbe0c837cb180c99f", "url": "https://github.com/line/armeria/commit/85a95b5bca39a9fa7e2d817bbe0c837cb180c99f", "message": "Fix checkstyle", "committedDate": "2020-04-09T03:46:09Z", "type": "commit"}, {"oid": "d54696d921ddc1734259b1dfc0afafd8d519e06c", "url": "https://github.com/line/armeria/commit/d54696d921ddc1734259b1dfc0afafd8d519e06c", "message": "Release message", "committedDate": "2020-04-09T03:46:09Z", "type": "commit"}, {"oid": "e92e8c202dd3413655d05d7926414312412e7dcd", "url": "https://github.com/line/armeria/commit/e92e8c202dd3413655d05d7926414312412e7dcd", "message": "Address comments by @minwoox / Allow closing an connection with non first idle event", "committedDate": "2020-04-09T03:46:09Z", "type": "commit"}, {"oid": "d641ad23961fcb912ff097bf782a1af98d76dc46", "url": "https://github.com/line/armeria/commit/d641ad23961fcb912ff097bf782a1af98d76dc46", "message": "Address comments by @minwoox\n\n- Inline `onIdleEvent` method\n- Remove IdleState and IdleStateEvent\n- Update Javadoc", "committedDate": "2020-04-09T03:46:10Z", "type": "commit"}, {"oid": "d641ad23961fcb912ff097bf782a1af98d76dc46", "url": "https://github.com/line/armeria/commit/d641ad23961fcb912ff097bf782a1af98d76dc46", "message": "Address comments by @minwoox\n\n- Inline `onIdleEvent` method\n- Remove IdleState and IdleStateEvent\n- Update Javadoc", "committedDate": "2020-04-09T03:46:10Z", "type": "forcePushed"}, {"oid": "ce067274766fc052591730da4b14df0683994344", "url": "https://github.com/line/armeria/commit/ce067274766fc052591730da4b14df0683994344", "message": "Fix broken test", "committedDate": "2020-04-09T04:40:22Z", "type": "commit"}, {"oid": "6bc4459e9a3b7b87988508fcd2f4e19136f1ac17", "url": "https://github.com/line/armeria/commit/6bc4459e9a3b7b87988508fcd2f4e19136f1ac17", "message": "Remove 'isLastConnectionIdleTimeSet' and 'isLastPingIdleTimeSet'", "committedDate": "2020-04-11T15:03:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMzOTY3NQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r407339675", "bodyText": "minimum -> minimum allowed", "author": "trustin", "createdAt": "2020-04-13T06:30:52Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -419,36 +428,47 @@ public ClientFactoryBuilder idleTimeoutMillis(long idleTimeoutMillis) {\n     }\n \n     /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * Sets the PING interval in milliseconds.\n+     * When neither read nor write was performed for the given {@code pingIntervalMillis},\n+     * a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2 or\n+     * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n+     * is sent for HTTP/1.\n      *\n-     * @param http2PingTimeoutMillis the timeout in milliseconds. {@code 0} disables the timeout.\n-     */\n-    public ClientFactoryBuilder http2PingTimeoutMillis(long http2PingTimeoutMillis) {\n-        checkArgument(http2PingTimeoutMillis >= 0,\n-                      \"http2PingTimeoutMillis: %s (expected: >= 0)\", http2PingTimeoutMillis);\n-        option(ClientFactoryOption.HTTP2_PING_TIMEOUT_MILLIS, http2PingTimeoutMillis);\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n+     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n      *\n-     * @param http2PingTimeout the timeout. {@code 0} disables the timeout.\n-     */\n-    public ClientFactoryBuilder http2PingTimeout(Duration http2PingTimeout) {\n-        requireNonNull(http2PingTimeout, \"http2PingTimeout\");\n-        checkArgument(http2PingTimeout.toMillis() >= 0,\n-                      \"http2PingTimeoutMillis: %s (expected: >= 0)\", http2PingTimeout.toMillis());\n-        http2PingTimeoutMillis(http2PingTimeout.toMillis());\n+     * <p>The minimum PING interval is {@value #MIN_PING_INTERVAL_MILLIS} milliseconds.", "originalCommit": "6bc4459e9a3b7b87988508fcd2f4e19136f1ac17", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0MDM0Ng==", "url": "https://github.com/line/armeria/pull/2636#discussion_r407340346", "bodyText": "min -> clamped?", "author": "trustin", "createdAt": "2020-04-13T06:33:19Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -558,7 +578,22 @@ private ClientFactoryOptions buildOptions() {\n             return ClientFactoryOption.ADDRESS_RESOLVER_GROUP_FACTORY.newValue(addressResolverGroupFactory);\n         });\n \n-        return ClientFactoryOptions.of(options.values());\n+        final ClientFactoryOptions newOptions = ClientFactoryOptions.of(options.values());\n+        final long idleTimeoutMillis = newOptions.idleTimeoutMillis();\n+        final long pingIntervalMillis = newOptions.pingIntervalMillis();\n+        if (idleTimeoutMillis > 0 && pingIntervalMillis > 0) {\n+            final long minPingIntervalMillis = Math.max(pingIntervalMillis, MIN_PING_INTERVAL_MILLIS);", "originalCommit": "6bc4459e9a3b7b87988508fcd2f4e19136f1ac17", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0ODY3NA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r407348674", "bodyText": "Ditto", "author": "trustin", "createdAt": "2020-04-13T07:02:06Z", "path": "core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java", "diffHunk": "@@ -461,33 +463,39 @@ public ServerBuilder idleTimeout(Duration idleTimeout) {\n     }\n \n     /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> interval.\n      *\n-     * @param http2PingTimeoutMillis the timeout in milliseconds. {@code 0} disables the timeout.\n-     */\n-    public ServerBuilder http2PingTimeoutMillis(long http2PingTimeoutMillis) {\n-        this.http2PingTimeoutMillis = validateNonNegative(http2PingTimeoutMillis, \"http2PingTimeoutMillis\");\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n+     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n      *\n-     * @param http2PingTimeoutMillis the timeout. {@code 0} disables the timeout.\n-     */\n-    public ServerBuilder http2PingTimeoutMillis(Duration http2PingTimeoutMillis) {\n-        requireNonNull(http2PingTimeoutMillis, \"http2PingTimeoutMillis\");\n-        this.http2PingTimeoutMillis =\n-                validateNonNegative(http2PingTimeoutMillis.toMillis(), \"http2PingTimeoutMillis\");\n+     * <p>The minimum PING interval is {@value #MIN_PING_INTERVAL_MILLIS} milliseconds.", "originalCommit": "6bc4459e9a3b7b87988508fcd2f4e19136f1ac17", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1389c13084780397f0a9b6510f56d47f12c7e6aa", "url": "https://github.com/line/armeria/commit/1389c13084780397f0a9b6510f56d47f12c7e6aa", "message": "Adress comments by @trustin", "committedDate": "2020-04-13T07:16:06Z", "type": "commit"}]}